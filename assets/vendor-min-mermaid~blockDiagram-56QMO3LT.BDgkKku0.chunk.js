var _a, _b;
import { d } from "./vendor-min-mermaid~chunk-S67DUUA5.BuO375mV.chunk.js";
import { n } from "./vendor-min-mermaid~chunk-LM6QDVU5.BV2Ps5xm.chunk.js";
import { f as ft, Z as Zt$1 } from "./vendor-min-mermaid~chunk-AFC6EC46.CY61scRQ.chunk.js";
import { m } from "./vendor-min-mermaid~chunk-ZN7TASNU.CDN7G8CE.chunk.js";
import { X as Xe$1, I as Ie$1, b as be$1 } from "./vendor-min-mermaid~chunk-UENA7NWE.a12nwn0g.chunk.js";
import { m as m$1 } from "./vendor-min-mermaid~chunk-GTKDMUJJ.Q7R0ayzM.chunk.js";
import { W as Wl, m as mC, t as tt, b as bf, E as Er$1, s as se$1, u as uf, r as rh, a as Sc, D as De, C as Cf, c as ku, e as wc } from "./vendor-min-mermaid~chunk-OR2G2HG5.BWDWUMki.chunk.js";
import { _ as _f } from "./vendor-min-mermaid~chunk-5ZJXQJOJ.DyIdZ9M4.chunk.js";
var yt = /* @__PURE__ */ function() {
  var e = /* @__PURE__ */ m$1(function(T, y, d2, f) {
    for (d2 = d2 || {}, f = T.length; f--; d2[T[f]] = y) ;
    return d2;
  }, "o"), t = [
    1,
    7
  ], s = [
    1,
    13
  ], n2 = [
    1,
    14
  ], i = [
    1,
    15
  ], r = [
    1,
    19
  ], a = [
    1,
    16
  ], l = [
    1,
    17
  ], o = [
    1,
    18
  ], u = [
    8,
    30
  ], g = [
    8,
    21,
    28,
    29,
    30,
    31,
    32,
    40,
    44,
    47
  ], x = [
    1,
    23
  ], m2 = [
    1,
    24
  ], b = [
    8,
    15,
    16,
    21,
    28,
    29,
    30,
    31,
    32,
    40,
    44,
    47
  ], L = [
    8,
    15,
    16,
    21,
    27,
    28,
    29,
    30,
    31,
    32,
    40,
    44,
    47
  ], _ = [
    1,
    49
  ], S = {
    trace: /* @__PURE__ */ m$1(function() {
    }, "trace"),
    yy: {},
    symbols_: {
      error: 2,
      spaceLines: 3,
      SPACELINE: 4,
      NL: 5,
      separator: 6,
      SPACE: 7,
      EOF: 8,
      start: 9,
      BLOCK_DIAGRAM_KEY: 10,
      document: 11,
      stop: 12,
      statement: 13,
      link: 14,
      LINK: 15,
      START_LINK: 16,
      LINK_LABEL: 17,
      STR: 18,
      nodeStatement: 19,
      columnsStatement: 20,
      SPACE_BLOCK: 21,
      blockStatement: 22,
      classDefStatement: 23,
      cssClassStatement: 24,
      styleStatement: 25,
      node: 26,
      SIZE: 27,
      COLUMNS: 28,
      "id-block": 29,
      end: 30,
      block: 31,
      NODE_ID: 32,
      nodeShapeNLabel: 33,
      dirList: 34,
      DIR: 35,
      NODE_DSTART: 36,
      NODE_DEND: 37,
      BLOCK_ARROW_START: 38,
      BLOCK_ARROW_END: 39,
      classDef: 40,
      CLASSDEF_ID: 41,
      CLASSDEF_STYLEOPTS: 42,
      DEFAULT: 43,
      class: 44,
      CLASSENTITY_IDS: 45,
      STYLECLASS: 46,
      style: 47,
      STYLE_ENTITY_IDS: 48,
      STYLE_DEFINITION_DATA: 49,
      $accept: 0,
      $end: 1
    },
    terminals_: {
      2: "error",
      4: "SPACELINE",
      5: "NL",
      7: "SPACE",
      8: "EOF",
      10: "BLOCK_DIAGRAM_KEY",
      15: "LINK",
      16: "START_LINK",
      17: "LINK_LABEL",
      18: "STR",
      21: "SPACE_BLOCK",
      27: "SIZE",
      28: "COLUMNS",
      29: "id-block",
      30: "end",
      31: "block",
      32: "NODE_ID",
      35: "DIR",
      36: "NODE_DSTART",
      37: "NODE_DEND",
      38: "BLOCK_ARROW_START",
      39: "BLOCK_ARROW_END",
      40: "classDef",
      41: "CLASSDEF_ID",
      42: "CLASSDEF_STYLEOPTS",
      43: "DEFAULT",
      44: "class",
      45: "CLASSENTITY_IDS",
      46: "STYLECLASS",
      47: "style",
      48: "STYLE_ENTITY_IDS",
      49: "STYLE_DEFINITION_DATA"
    },
    productions_: [
      0,
      [
        3,
        1
      ],
      [
        3,
        2
      ],
      [
        3,
        2
      ],
      [
        6,
        1
      ],
      [
        6,
        1
      ],
      [
        6,
        1
      ],
      [
        9,
        3
      ],
      [
        12,
        1
      ],
      [
        12,
        1
      ],
      [
        12,
        2
      ],
      [
        12,
        2
      ],
      [
        11,
        1
      ],
      [
        11,
        2
      ],
      [
        14,
        1
      ],
      [
        14,
        4
      ],
      [
        13,
        1
      ],
      [
        13,
        1
      ],
      [
        13,
        1
      ],
      [
        13,
        1
      ],
      [
        13,
        1
      ],
      [
        13,
        1
      ],
      [
        13,
        1
      ],
      [
        19,
        3
      ],
      [
        19,
        2
      ],
      [
        19,
        1
      ],
      [
        20,
        1
      ],
      [
        22,
        4
      ],
      [
        22,
        3
      ],
      [
        26,
        1
      ],
      [
        26,
        2
      ],
      [
        34,
        1
      ],
      [
        34,
        2
      ],
      [
        33,
        3
      ],
      [
        33,
        4
      ],
      [
        23,
        3
      ],
      [
        23,
        3
      ],
      [
        24,
        3
      ],
      [
        25,
        3
      ]
    ],
    performAction: /* @__PURE__ */ m$1(function(y, d2, f, w, E, h, Y) {
      var p = h.length - 1;
      switch (E) {
        case 4:
          w.getLogger().debug("Rule: separator (NL) ");
          break;
        case 5:
          w.getLogger().debug("Rule: separator (Space) ");
          break;
        case 6:
          w.getLogger().debug("Rule: separator (EOF) ");
          break;
        case 7:
          w.getLogger().debug("Rule: hierarchy: ", h[p - 1]), w.setHierarchy(h[p - 1]);
          break;
        case 8:
          w.getLogger().debug("Stop NL ");
          break;
        case 9:
          w.getLogger().debug("Stop EOF ");
          break;
        case 10:
          w.getLogger().debug("Stop NL2 ");
          break;
        case 11:
          w.getLogger().debug("Stop EOF2 ");
          break;
        case 12:
          w.getLogger().debug("Rule: statement: ", h[p]), typeof h[p].length == "number" ? this.$ = h[p] : this.$ = [
            h[p]
          ];
          break;
        case 13:
          w.getLogger().debug("Rule: statement #2: ", h[p - 1]), this.$ = /* @__PURE__ */ [
            h[p - 1]
          ].concat(h[p]);
          break;
        case 14:
          w.getLogger().debug("Rule: link: ", h[p], y), this.$ = {
            edgeTypeStr: h[p],
            label: ""
          };
          break;
        case 15:
          w.getLogger().debug("Rule: LABEL link: ", h[p - 3], h[p - 1], h[p]), this.$ = {
            edgeTypeStr: h[p],
            label: h[p - 1]
          };
          break;
        case 18:
          let R = /* @__PURE__ */ parseInt(h[p]), Z = /* @__PURE__ */ w.generateId();
          this.$ = {
            id: Z,
            type: "space",
            label: "",
            width: R,
            children: []
          };
          break;
        case 23:
          w.getLogger().debug("Rule: (nodeStatement link node) ", h[p - 2], h[p - 1], h[p], " typestr: ", h[p - 1].edgeTypeStr);
          let V = /* @__PURE__ */ w.edgeStrToEdgeData(h[p - 1].edgeTypeStr);
          this.$ = [
            {
              id: h[p - 2].id,
              label: h[p - 2].label,
              type: h[p - 2].type,
              directions: h[p - 2].directions
            },
            {
              id: h[p - 2].id + "-" + h[p].id,
              start: h[p - 2].id,
              end: h[p].id,
              label: h[p - 1].label,
              type: "edge",
              directions: h[p].directions,
              arrowTypeEnd: V,
              arrowTypeStart: "arrow_open"
            },
            {
              id: h[p].id,
              label: h[p].label,
              type: /* @__PURE__ */ w.typeStr2Type(h[p].typeStr),
              directions: h[p].directions
            }
          ];
          break;
        case 24:
          w.getLogger().debug("Rule: nodeStatement (abc88 node size) ", h[p - 1], h[p]), this.$ = {
            id: h[p - 1].id,
            label: h[p - 1].label,
            type: /* @__PURE__ */ w.typeStr2Type(h[p - 1].typeStr),
            directions: h[p - 1].directions,
            widthInColumns: /* @__PURE__ */ parseInt(h[p], 10)
          };
          break;
        case 25:
          w.getLogger().debug("Rule: nodeStatement (node) ", h[p]), this.$ = {
            id: h[p].id,
            label: h[p].label,
            type: /* @__PURE__ */ w.typeStr2Type(h[p].typeStr),
            directions: h[p].directions,
            widthInColumns: 1
          };
          break;
        case 26:
          w.getLogger().debug("APA123", this ? this : "na"), w.getLogger().debug("COLUMNS: ", h[p]), this.$ = {
            type: "column-setting",
            columns: h[p] === "auto" ? -1 : parseInt(h[p])
          };
          break;
        case 27:
          w.getLogger().debug("Rule: id-block statement : ", h[p - 2], h[p - 1]);
          w.generateId();
          this.$ = {
            ...h[p - 2],
            type: "composite",
            children: h[p - 1]
          };
          break;
        case 28:
          w.getLogger().debug("Rule: blockStatement : ", h[p - 2], h[p - 1], h[p]);
          let at = /* @__PURE__ */ w.generateId();
          this.$ = {
            id: at,
            type: "composite",
            label: "",
            children: h[p - 1]
          };
          break;
        case 29:
          w.getLogger().debug("Rule: node (NODE_ID separator): ", h[p]), this.$ = {
            id: h[p]
          };
          break;
        case 30:
          w.getLogger().debug("Rule: node (NODE_ID nodeShapeNLabel separator): ", h[p - 1], h[p]), this.$ = {
            id: h[p - 1],
            label: h[p].label,
            typeStr: h[p].typeStr,
            directions: h[p].directions
          };
          break;
        case 31:
          w.getLogger().debug("Rule: dirList: ", h[p]), this.$ = [
            h[p]
          ];
          break;
        case 32:
          w.getLogger().debug("Rule: dirList: ", h[p - 1], h[p]), this.$ = /* @__PURE__ */ [
            h[p - 1]
          ].concat(h[p]);
          break;
        case 33:
          w.getLogger().debug("Rule: nodeShapeNLabel: ", h[p - 2], h[p - 1], h[p]), this.$ = {
            typeStr: h[p - 2] + h[p],
            label: h[p - 1]
          };
          break;
        case 34:
          w.getLogger().debug("Rule: BLOCK_ARROW nodeShapeNLabel: ", h[p - 3], h[p - 2], " #3:", h[p - 1], h[p]), this.$ = {
            typeStr: h[p - 3] + h[p],
            label: h[p - 2],
            directions: h[p - 1]
          };
          break;
        case 35:
        case 36:
          this.$ = {
            type: "classDef",
            id: /* @__PURE__ */ h[p - 1].trim(),
            css: /* @__PURE__ */ h[p].trim()
          };
          break;
        case 37:
          this.$ = {
            type: "applyClass",
            id: /* @__PURE__ */ h[p - 1].trim(),
            styleClass: /* @__PURE__ */ h[p].trim()
          };
          break;
        case 38:
          this.$ = {
            type: "applyStyles",
            id: /* @__PURE__ */ h[p - 1].trim(),
            stylesStr: /* @__PURE__ */ h[p].trim()
          };
          break;
      }
    }, "anonymous"),
    table: [
      {
        9: 1,
        10: [
          1,
          2
        ]
      },
      {
        1: [
          3
        ]
      },
      {
        11: 3,
        13: 4,
        19: 5,
        20: 6,
        21: t,
        22: 8,
        23: 9,
        24: 10,
        25: 11,
        26: 12,
        28: s,
        29: n2,
        31: i,
        32: r,
        40: a,
        44: l,
        47: o
      },
      {
        8: [
          1,
          20
        ]
      },
      /* @__PURE__ */ e(u, [
        2,
        12
      ], {
        13: 4,
        19: 5,
        20: 6,
        22: 8,
        23: 9,
        24: 10,
        25: 11,
        26: 12,
        11: 21,
        21: t,
        28: s,
        29: n2,
        31: i,
        32: r,
        40: a,
        44: l,
        47: o
      }),
      /* @__PURE__ */ e(g, [
        2,
        16
      ], {
        14: 22,
        15: x,
        16: m2
      }),
      /* @__PURE__ */ e(g, [
        2,
        17
      ]),
      /* @__PURE__ */ e(g, [
        2,
        18
      ]),
      /* @__PURE__ */ e(g, [
        2,
        19
      ]),
      /* @__PURE__ */ e(g, [
        2,
        20
      ]),
      /* @__PURE__ */ e(g, [
        2,
        21
      ]),
      /* @__PURE__ */ e(g, [
        2,
        22
      ]),
      /* @__PURE__ */ e(b, [
        2,
        25
      ], {
        27: [
          1,
          25
        ]
      }),
      /* @__PURE__ */ e(g, [
        2,
        26
      ]),
      {
        19: 26,
        26: 12,
        32: r
      },
      {
        11: 27,
        13: 4,
        19: 5,
        20: 6,
        21: t,
        22: 8,
        23: 9,
        24: 10,
        25: 11,
        26: 12,
        28: s,
        29: n2,
        31: i,
        32: r,
        40: a,
        44: l,
        47: o
      },
      {
        41: [
          1,
          28
        ],
        43: [
          1,
          29
        ]
      },
      {
        45: [
          1,
          30
        ]
      },
      {
        48: [
          1,
          31
        ]
      },
      /* @__PURE__ */ e(L, [
        2,
        29
      ], {
        33: 32,
        36: [
          1,
          33
        ],
        38: [
          1,
          34
        ]
      }),
      {
        1: [
          2,
          7
        ]
      },
      /* @__PURE__ */ e(u, [
        2,
        13
      ]),
      {
        26: 35,
        32: r
      },
      {
        32: [
          2,
          14
        ]
      },
      {
        17: [
          1,
          36
        ]
      },
      /* @__PURE__ */ e(b, [
        2,
        24
      ]),
      {
        11: 37,
        13: 4,
        14: 22,
        15: x,
        16: m2,
        19: 5,
        20: 6,
        21: t,
        22: 8,
        23: 9,
        24: 10,
        25: 11,
        26: 12,
        28: s,
        29: n2,
        31: i,
        32: r,
        40: a,
        44: l,
        47: o
      },
      {
        30: [
          1,
          38
        ]
      },
      {
        42: [
          1,
          39
        ]
      },
      {
        42: [
          1,
          40
        ]
      },
      {
        46: [
          1,
          41
        ]
      },
      {
        49: [
          1,
          42
        ]
      },
      /* @__PURE__ */ e(L, [
        2,
        30
      ]),
      {
        18: [
          1,
          43
        ]
      },
      {
        18: [
          1,
          44
        ]
      },
      /* @__PURE__ */ e(b, [
        2,
        23
      ]),
      {
        18: [
          1,
          45
        ]
      },
      {
        30: [
          1,
          46
        ]
      },
      /* @__PURE__ */ e(g, [
        2,
        28
      ]),
      /* @__PURE__ */ e(g, [
        2,
        35
      ]),
      /* @__PURE__ */ e(g, [
        2,
        36
      ]),
      /* @__PURE__ */ e(g, [
        2,
        37
      ]),
      /* @__PURE__ */ e(g, [
        2,
        38
      ]),
      {
        37: [
          1,
          47
        ]
      },
      {
        34: 48,
        35: _
      },
      {
        15: [
          1,
          50
        ]
      },
      /* @__PURE__ */ e(g, [
        2,
        27
      ]),
      /* @__PURE__ */ e(L, [
        2,
        33
      ]),
      {
        39: [
          1,
          51
        ]
      },
      {
        34: 52,
        35: _,
        39: [
          2,
          31
        ]
      },
      {
        32: [
          2,
          15
        ]
      },
      /* @__PURE__ */ e(L, [
        2,
        34
      ]),
      {
        39: [
          2,
          32
        ]
      }
    ],
    defaultActions: {
      20: [
        2,
        7
      ],
      23: [
        2,
        14
      ],
      50: [
        2,
        15
      ],
      52: [
        2,
        32
      ]
    },
    parseError: /* @__PURE__ */ m$1(function(y, d2) {
      if (d2.recoverable) this.trace(y);
      else {
        var f = new Error(y);
        throw f.hash = d2, f;
      }
    }, "parseError"),
    parse: /* @__PURE__ */ m$1(function(y) {
      var d2 = this, f = [
        0
      ], w = [], E = [
        null
      ], h = [], Y = this.table, p = "", R = 0, Z = 0, V = 0, Bt = 2, at = 1, _e = /* @__PURE__ */ h.slice.call(arguments, 1), z = /* @__PURE__ */ Object.create(this.lexer), J = {
        yy: {}
      };
      for (var dt in this.yy) Object.prototype.hasOwnProperty.call(this.yy, dt) && (J.yy[dt] = this.yy[dt]);
      z.setInput(y, J.yy), J.yy.lexer = z, J.yy.parser = this, typeof z.yylloc > "u" && (z.yylloc = {});
      var ut = z.yylloc;
      h.push(ut);
      var De2 = z.options && z.options.ranges;
      typeof J.yy.parseError == "function" ? this.parseError = J.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
      function Gr(H) {
        f.length = f.length - 2 * H, E.length = E.length - H, h.length = h.length - H;
      }
      m$1(Gr, "popStack");
      function Be() {
        var H;
        return H = w.pop() || z.lex() || at, typeof H != "number" && (H instanceof Array && (w = H, H = /* @__PURE__ */ w.pop()), H = d2.symbols_[H] || H), H;
      }
      m$1(Be, "lex");
      for (var F, pt, Q, K, Zr, ft2, $ = {}, st, G, vt, it; ; ) {
        if (Q = f[f.length - 1], this.defaultActions[Q] ? K = this.defaultActions[Q] : ((F === null || typeof F > "u") && (F = /* @__PURE__ */ Be()), K = Y[Q] && Y[Q][F]), typeof K > "u" || !K.length || !K[0]) {
          var xt = "";
          it = [];
          for (st in Y[Q]) this.terminals_[st] && st > Bt && it.push("'" + this.terminals_[st] + "'");
          z.showPosition ? xt = "Parse error on line " + (R + 1) + `:
` + z.showPosition() + `
Expecting ` + it.join(", ") + ", got '" + (this.terminals_[F] || F) + "'" : xt = "Parse error on line " + (R + 1) + ": Unexpected " + (F == at ? "end of input" : "'" + (this.terminals_[F] || F) + "'"), this.parseError(xt, {
            text: z.match,
            token: this.terminals_[F] || F,
            line: z.yylineno,
            loc: ut,
            expected: it
          });
        }
        if (K[0] instanceof Array && K.length > 1) throw new Error("Parse Error: multiple actions possible at state: " + Q + ", token: " + F);
        switch (K[0]) {
          case 1:
            f.push(F), E.push(z.yytext), h.push(z.yylloc), f.push(K[1]), F = null, pt ? (F = pt, pt = null) : (Z = z.yyleng, p = z.yytext, R = z.yylineno, ut = z.yylloc, V > 0);
            break;
          case 2:
            if (G = this.productions_[K[1]][1], $.$ = E[E.length - G], $._$ = {
              first_line: h[h.length - (G || 1)].first_line,
              last_line: h[h.length - 1].last_line,
              first_column: h[h.length - (G || 1)].first_column,
              last_column: h[h.length - 1].last_column
            }, De2 && ($._$.range = [
              h[h.length - (G || 1)].range[0],
              h[h.length - 1].range[1]
            ]), ft2 = /* @__PURE__ */ this.performAction.apply($, /* @__PURE__ */ [
              p,
              Z,
              R,
              J.yy,
              K[1],
              E,
              h
            ].concat(_e)), typeof ft2 < "u") return ft2;
            G && (f = /* @__PURE__ */ f.slice(0, -1 * G * 2), E = /* @__PURE__ */ E.slice(0, -1 * G), h = /* @__PURE__ */ h.slice(0, -1 * G)), f.push(this.productions_[K[1]][0]), E.push($.$), h.push($._$), vt = Y[f[f.length - 2]][f[f.length - 1]], f.push(vt);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }, "parse")
  }, I = /* @__PURE__ */ function() {
    var T = {
      EOF: 1,
      parseError: /* @__PURE__ */ m$1(function(d2, f) {
        if (this.yy.parser) this.yy.parser.parseError(d2, f);
        else throw new Error(d2);
      }, "parseError"),
      setInput: /* @__PURE__ */ m$1(function(y, d2) {
        return this.yy = d2 || this.yy || {}, this._input = y, this._more = this._backtrack = this.done = false, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = [
          "INITIAL"
        ], this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        }, this.options.ranges && (this.yylloc.range = [
          0,
          0
        ]), this.offset = 0, this;
      }, "setInput"),
      input: /* @__PURE__ */ m$1(function() {
        var y = this._input[0];
        this.yytext += y, this.yyleng++, this.offset++, this.match += y, this.matched += y;
        var d2 = /* @__PURE__ */ y.match(/(?:\r\n?|\n).*/g);
        return d2 ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = /* @__PURE__ */ this._input.slice(1), y;
      }, "input"),
      unput: /* @__PURE__ */ m$1(function(y) {
        var d2 = y.length, f = /* @__PURE__ */ y.split(/(?:\r\n?|\n)/g);
        this._input = y + this._input, this.yytext = /* @__PURE__ */ this.yytext.substr(0, this.yytext.length - d2), this.offset -= d2;
        var w = /* @__PURE__ */ this.match.split(/(?:\r\n?|\n)/g);
        this.match = /* @__PURE__ */ this.match.substr(0, this.match.length - 1), this.matched = /* @__PURE__ */ this.matched.substr(0, this.matched.length - 1), f.length - 1 && (this.yylineno -= f.length - 1);
        var E = this.yylloc.range;
        return this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: f ? (f.length === w.length ? this.yylloc.first_column : 0) + w[w.length - f.length].length - f[0].length : this.yylloc.first_column - d2
        }, this.options.ranges && (this.yylloc.range = [
          E[0],
          E[0] + this.yyleng - d2
        ]), this.yyleng = this.yytext.length, this;
      }, "unput"),
      more: /* @__PURE__ */ m$1(function() {
        return this._more = true, this;
      }, "more"),
      reject: /* @__PURE__ */ m$1(function() {
        if (this.options.backtrack_lexer) this._backtrack = true;
        else return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
        return this;
      }, "reject"),
      less: /* @__PURE__ */ m$1(function(y) {
        this.unput(/* @__PURE__ */ this.match.slice(y));
      }, "less"),
      pastInput: /* @__PURE__ */ m$1(function() {
        var y = /* @__PURE__ */ this.matched.substr(0, this.matched.length - this.match.length);
        return (y.length > 20 ? "..." : "") + y.substr(-20).replace(/\n/g, "");
      }, "pastInput"),
      upcomingInput: /* @__PURE__ */ m$1(function() {
        var y = this.match;
        return y.length < 20 && (y += /* @__PURE__ */ this._input.substr(0, 20 - y.length)), (y.substr(0, 20) + (y.length > 20 ? "..." : "")).replace(/\n/g, "");
      }, "upcomingInput"),
      showPosition: /* @__PURE__ */ m$1(function() {
        var y = /* @__PURE__ */ this.pastInput(), d2 = /* @__PURE__ */ new Array(y.length + 1).join("-");
        return y + this.upcomingInput() + `
` + d2 + "^";
      }, "showPosition"),
      test_match: /* @__PURE__ */ m$1(function(y, d2) {
        var f, w, E;
        if (this.options.backtrack_lexer && (E = {
          yylineno: this.yylineno,
          yylloc: {
            first_line: this.yylloc.first_line,
            last_line: this.last_line,
            first_column: this.yylloc.first_column,
            last_column: this.yylloc.last_column
          },
          yytext: this.yytext,
          match: this.match,
          matches: this.matches,
          matched: this.matched,
          yyleng: this.yyleng,
          offset: this.offset,
          _more: this._more,
          _input: this._input,
          yy: this.yy,
          conditionStack: /* @__PURE__ */ this.conditionStack.slice(0),
          done: this.done
        }, this.options.ranges && (E.yylloc.range = /* @__PURE__ */ this.yylloc.range.slice(0))), w = /* @__PURE__ */ y[0].match(/(?:\r\n?|\n).*/g), w && (this.yylineno += w.length), this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: w ? w[w.length - 1].length - w[w.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + y[0].length
        }, this.yytext += y[0], this.match += y[0], this.matches = y, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [
          this.offset,
          this.offset += this.yyleng
        ]), this._more = false, this._backtrack = false, this._input = /* @__PURE__ */ this._input.slice(y[0].length), this.matched += y[0], f = /* @__PURE__ */ this.performAction.call(this, this.yy, this, d2, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = false), f) return f;
        if (this._backtrack) {
          for (var h in E) this[h] = E[h];
          return false;
        }
        return false;
      }, "test_match"),
      next: /* @__PURE__ */ m$1(function() {
        if (this.done) return this.EOF;
        this._input || (this.done = true);
        var y, d2, f, w;
        this._more || (this.yytext = "", this.match = "");
        for (var E = /* @__PURE__ */ this._currentRules(), h = 0; h < E.length; h++) if (f = /* @__PURE__ */ this._input.match(this.rules[E[h]]), f && (!d2 || f[0].length > d2[0].length)) {
          if (d2 = f, w = h, this.options.backtrack_lexer) {
            if (y = /* @__PURE__ */ this.test_match(f, E[h]), y !== false) return y;
            if (this._backtrack) {
              d2 = false;
              continue;
            } else return false;
          } else if (!this.options.flex) break;
        }
        return d2 ? (y = /* @__PURE__ */ this.test_match(d2, E[w]), y !== false ? y : false) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      }, "next"),
      lex: /* @__PURE__ */ m$1(function() {
        var d2 = /* @__PURE__ */ this.next();
        return d2 || this.lex();
      }, "lex"),
      begin: /* @__PURE__ */ m$1(function(d2) {
        this.conditionStack.push(d2);
      }, "begin"),
      popState: /* @__PURE__ */ m$1(function() {
        var d2 = this.conditionStack.length - 1;
        return d2 > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      }, "popState"),
      _currentRules: /* @__PURE__ */ m$1(function() {
        return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
      }, "_currentRules"),
      topState: /* @__PURE__ */ m$1(function(d2) {
        return d2 = this.conditionStack.length - 1 - Math.abs(d2 || 0), d2 >= 0 ? this.conditionStack[d2] : "INITIAL";
      }, "topState"),
      pushState: /* @__PURE__ */ m$1(function(d2) {
        this.begin(d2);
      }, "pushState"),
      stateStackSize: /* @__PURE__ */ m$1(function() {
        return this.conditionStack.length;
      }, "stateStackSize"),
      options: {},
      performAction: /* @__PURE__ */ m$1(function(d2, f, w, E) {
        switch (w) {
          case 0:
            return 10;
          case 1:
            return d2.getLogger().debug("Found space-block"), 31;
          case 2:
            return d2.getLogger().debug("Found nl-block"), 31;
          case 3:
            return d2.getLogger().debug("Found space-block"), 29;
          case 4:
            d2.getLogger().debug(".", f.yytext);
            break;
          case 5:
            d2.getLogger().debug("_", f.yytext);
            break;
          case 6:
            return 5;
          case 7:
            return f.yytext = -1, 28;
          case 8:
            return f.yytext = /* @__PURE__ */ f.yytext.replace(/columns\s+/, ""), d2.getLogger().debug("COLUMNS (LEX)", f.yytext), 28;
          case 9:
            this.pushState("md_string");
            break;
          case 10:
            return "MD_STR";
          case 11:
            this.popState();
            break;
          case 12:
            this.pushState("string");
            break;
          case 13:
            d2.getLogger().debug("LEX: POPPING STR:", f.yytext), this.popState();
            break;
          case 14:
            return d2.getLogger().debug("LEX: STR end:", f.yytext), "STR";
          case 15:
            return f.yytext = /* @__PURE__ */ f.yytext.replace(/space\:/, ""), d2.getLogger().debug("SPACE NUM (LEX)", f.yytext), 21;
          case 16:
            return f.yytext = "1", d2.getLogger().debug("COLUMNS (LEX)", f.yytext), 21;
          case 17:
            return 43;
          case 18:
            return "LINKSTYLE";
          case 19:
            return "INTERPOLATE";
          case 20:
            return this.pushState("CLASSDEF"), 40;
          case 21:
            return this.popState(), this.pushState("CLASSDEFID"), "DEFAULT_CLASSDEF_ID";
          case 22:
            return this.popState(), this.pushState("CLASSDEFID"), 41;
          case 23:
            return this.popState(), 42;
          case 24:
            return this.pushState("CLASS"), 44;
          case 25:
            return this.popState(), this.pushState("CLASS_STYLE"), 45;
          case 26:
            return this.popState(), 46;
          case 27:
            return this.pushState("STYLE_STMNT"), 47;
          case 28:
            return this.popState(), this.pushState("STYLE_DEFINITION"), 48;
          case 29:
            return this.popState(), 49;
          case 30:
            return this.pushState("acc_title"), "acc_title";
          case 31:
            return this.popState(), "acc_title_value";
          case 32:
            return this.pushState("acc_descr"), "acc_descr";
          case 33:
            return this.popState(), "acc_descr_value";
          case 34:
            this.pushState("acc_descr_multiline");
            break;
          case 35:
            this.popState();
            break;
          case 36:
            return "acc_descr_multiline_value";
          case 37:
            return 30;
          case 38:
            return this.popState(), d2.getLogger().debug("Lex: (("), "NODE_DEND";
          case 39:
            return this.popState(), d2.getLogger().debug("Lex: (("), "NODE_DEND";
          case 40:
            return this.popState(), d2.getLogger().debug("Lex: ))"), "NODE_DEND";
          case 41:
            return this.popState(), d2.getLogger().debug("Lex: (("), "NODE_DEND";
          case 42:
            return this.popState(), d2.getLogger().debug("Lex: (("), "NODE_DEND";
          case 43:
            return this.popState(), d2.getLogger().debug("Lex: (-"), "NODE_DEND";
          case 44:
            return this.popState(), d2.getLogger().debug("Lex: -)"), "NODE_DEND";
          case 45:
            return this.popState(), d2.getLogger().debug("Lex: (("), "NODE_DEND";
          case 46:
            return this.popState(), d2.getLogger().debug("Lex: ]]"), "NODE_DEND";
          case 47:
            return this.popState(), d2.getLogger().debug("Lex: ("), "NODE_DEND";
          case 48:
            return this.popState(), d2.getLogger().debug("Lex: ])"), "NODE_DEND";
          case 49:
            return this.popState(), d2.getLogger().debug("Lex: /]"), "NODE_DEND";
          case 50:
            return this.popState(), d2.getLogger().debug("Lex: /]"), "NODE_DEND";
          case 51:
            return this.popState(), d2.getLogger().debug("Lex: )]"), "NODE_DEND";
          case 52:
            return this.popState(), d2.getLogger().debug("Lex: )"), "NODE_DEND";
          case 53:
            return this.popState(), d2.getLogger().debug("Lex: ]>"), "NODE_DEND";
          case 54:
            return this.popState(), d2.getLogger().debug("Lex: ]"), "NODE_DEND";
          case 55:
            return d2.getLogger().debug("Lexa: -)"), this.pushState("NODE"), 36;
          case 56:
            return d2.getLogger().debug("Lexa: (-"), this.pushState("NODE"), 36;
          case 57:
            return d2.getLogger().debug("Lexa: ))"), this.pushState("NODE"), 36;
          case 58:
            return d2.getLogger().debug("Lexa: )"), this.pushState("NODE"), 36;
          case 59:
            return d2.getLogger().debug("Lex: ((("), this.pushState("NODE"), 36;
          case 60:
            return d2.getLogger().debug("Lexa: )"), this.pushState("NODE"), 36;
          case 61:
            return d2.getLogger().debug("Lexa: )"), this.pushState("NODE"), 36;
          case 62:
            return d2.getLogger().debug("Lexa: )"), this.pushState("NODE"), 36;
          case 63:
            return d2.getLogger().debug("Lexc: >"), this.pushState("NODE"), 36;
          case 64:
            return d2.getLogger().debug("Lexa: (["), this.pushState("NODE"), 36;
          case 65:
            return d2.getLogger().debug("Lexa: )"), this.pushState("NODE"), 36;
          case 66:
            return this.pushState("NODE"), 36;
          case 67:
            return this.pushState("NODE"), 36;
          case 68:
            return this.pushState("NODE"), 36;
          case 69:
            return this.pushState("NODE"), 36;
          case 70:
            return this.pushState("NODE"), 36;
          case 71:
            return this.pushState("NODE"), 36;
          case 72:
            return this.pushState("NODE"), 36;
          case 73:
            return d2.getLogger().debug("Lexa: ["), this.pushState("NODE"), 36;
          case 74:
            return this.pushState("BLOCK_ARROW"), d2.getLogger().debug("LEX ARR START"), 38;
          case 75:
            return d2.getLogger().debug("Lex: NODE_ID", f.yytext), 32;
          case 76:
            return d2.getLogger().debug("Lex: EOF", f.yytext), 8;
          case 77:
            this.pushState("md_string");
            break;
          case 78:
            this.pushState("md_string");
            break;
          case 79:
            return "NODE_DESCR";
          case 80:
            this.popState();
            break;
          case 81:
            d2.getLogger().debug("Lex: Starting string"), this.pushState("string");
            break;
          case 82:
            d2.getLogger().debug("LEX ARR: Starting string"), this.pushState("string");
            break;
          case 83:
            return d2.getLogger().debug("LEX: NODE_DESCR:", f.yytext), "NODE_DESCR";
          case 84:
            d2.getLogger().debug("LEX POPPING"), this.popState();
            break;
          case 85:
            d2.getLogger().debug("Lex: =>BAE"), this.pushState("ARROW_DIR");
            break;
          case 86:
            return f.yytext = /* @__PURE__ */ f.yytext.replace(/^,\s*/, ""), d2.getLogger().debug("Lex (right): dir:", f.yytext), "DIR";
          case 87:
            return f.yytext = /* @__PURE__ */ f.yytext.replace(/^,\s*/, ""), d2.getLogger().debug("Lex (left):", f.yytext), "DIR";
          case 88:
            return f.yytext = /* @__PURE__ */ f.yytext.replace(/^,\s*/, ""), d2.getLogger().debug("Lex (x):", f.yytext), "DIR";
          case 89:
            return f.yytext = /* @__PURE__ */ f.yytext.replace(/^,\s*/, ""), d2.getLogger().debug("Lex (y):", f.yytext), "DIR";
          case 90:
            return f.yytext = /* @__PURE__ */ f.yytext.replace(/^,\s*/, ""), d2.getLogger().debug("Lex (up):", f.yytext), "DIR";
          case 91:
            return f.yytext = /* @__PURE__ */ f.yytext.replace(/^,\s*/, ""), d2.getLogger().debug("Lex (down):", f.yytext), "DIR";
          case 92:
            return f.yytext = "]>", d2.getLogger().debug("Lex (ARROW_DIR end):", f.yytext), this.popState(), this.popState(), "BLOCK_ARROW_END";
          case 93:
            return d2.getLogger().debug("Lex: LINK", "#" + f.yytext + "#"), 15;
          case 94:
            return d2.getLogger().debug("Lex: LINK", f.yytext), 15;
          case 95:
            return d2.getLogger().debug("Lex: LINK", f.yytext), 15;
          case 96:
            return d2.getLogger().debug("Lex: LINK", f.yytext), 15;
          case 97:
            return d2.getLogger().debug("Lex: START_LINK", f.yytext), this.pushState("LLABEL"), 16;
          case 98:
            return d2.getLogger().debug("Lex: START_LINK", f.yytext), this.pushState("LLABEL"), 16;
          case 99:
            return d2.getLogger().debug("Lex: START_LINK", f.yytext), this.pushState("LLABEL"), 16;
          case 100:
            this.pushState("md_string");
            break;
          case 101:
            return d2.getLogger().debug("Lex: Starting string"), this.pushState("string"), "LINK_LABEL";
          case 102:
            return this.popState(), d2.getLogger().debug("Lex: LINK", "#" + f.yytext + "#"), 15;
          case 103:
            return this.popState(), d2.getLogger().debug("Lex: LINK", f.yytext), 15;
          case 104:
            return this.popState(), d2.getLogger().debug("Lex: LINK", f.yytext), 15;
          case 105:
            return d2.getLogger().debug("Lex: COLON", f.yytext), f.yytext = /* @__PURE__ */ f.yytext.slice(1), 27;
        }
      }, "anonymous"),
      rules: [
        /^(?:block-beta\b)/,
        /^(?:block\s+)/,
        /^(?:block\n+)/,
        /^(?:block:)/,
        /^(?:[\s]+)/,
        /^(?:[\n]+)/,
        /^(?:((\u000D\u000A)|(\u000A)))/,
        /^(?:columns\s+auto\b)/,
        /^(?:columns\s+[\d]+)/,
        /^(?:["][`])/,
        /^(?:[^`"]+)/,
        /^(?:[`]["])/,
        /^(?:["])/,
        /^(?:["])/,
        /^(?:[^"]*)/,
        /^(?:space[:]\d+)/,
        /^(?:space\b)/,
        /^(?:default\b)/,
        /^(?:linkStyle\b)/,
        /^(?:interpolate\b)/,
        /^(?:classDef\s+)/,
        /^(?:DEFAULT\s+)/,
        /^(?:\w+\s+)/,
        /^(?:[^\n]*)/,
        /^(?:class\s+)/,
        /^(?:(\w+)+((,\s*\w+)*))/,
        /^(?:[^\n]*)/,
        /^(?:style\s+)/,
        /^(?:(\w+)+((,\s*\w+)*))/,
        /^(?:[^\n]*)/,
        /^(?:accTitle\s*:\s*)/,
        /^(?:(?!\n||)*[^\n]*)/,
        /^(?:accDescr\s*:\s*)/,
        /^(?:(?!\n||)*[^\n]*)/,
        /^(?:accDescr\s*\{\s*)/,
        /^(?:[\}])/,
        /^(?:[^\}]*)/,
        /^(?:end\b\s*)/,
        /^(?:\(\(\()/,
        /^(?:\)\)\))/,
        /^(?:[\)]\))/,
        /^(?:\}\})/,
        /^(?:\})/,
        /^(?:\(-)/,
        /^(?:-\))/,
        /^(?:\(\()/,
        /^(?:\]\])/,
        /^(?:\()/,
        /^(?:\]\))/,
        /^(?:\\\])/,
        /^(?:\/\])/,
        /^(?:\)\])/,
        /^(?:[\)])/,
        /^(?:\]>)/,
        /^(?:[\]])/,
        /^(?:-\))/,
        /^(?:\(-)/,
        /^(?:\)\))/,
        /^(?:\))/,
        /^(?:\(\(\()/,
        /^(?:\(\()/,
        /^(?:\{\{)/,
        /^(?:\{)/,
        /^(?:>)/,
        /^(?:\(\[)/,
        /^(?:\()/,
        /^(?:\[\[)/,
        /^(?:\[\|)/,
        /^(?:\[\()/,
        /^(?:\)\)\))/,
        /^(?:\[\\)/,
        /^(?:\[\/)/,
        /^(?:\[\\)/,
        /^(?:\[)/,
        /^(?:<\[)/,
        /^(?:[^\(\[\n\-\)\{\}\s\<\>:]+)/,
        /^(?:$)/,
        /^(?:["][`])/,
        /^(?:["][`])/,
        /^(?:[^`"]+)/,
        /^(?:[`]["])/,
        /^(?:["])/,
        /^(?:["])/,
        /^(?:[^"]+)/,
        /^(?:["])/,
        /^(?:\]>\s*\()/,
        /^(?:,?\s*right\s*)/,
        /^(?:,?\s*left\s*)/,
        /^(?:,?\s*x\s*)/,
        /^(?:,?\s*y\s*)/,
        /^(?:,?\s*up\s*)/,
        /^(?:,?\s*down\s*)/,
        /^(?:\)\s*)/,
        /^(?:\s*[xo<]?--+[-xo>]\s*)/,
        /^(?:\s*[xo<]?==+[=xo>]\s*)/,
        /^(?:\s*[xo<]?-?\.+-[xo>]?\s*)/,
        /^(?:\s*~~[\~]+\s*)/,
        /^(?:\s*[xo<]?--\s*)/,
        /^(?:\s*[xo<]?==\s*)/,
        /^(?:\s*[xo<]?-\.\s*)/,
        /^(?:["][`])/,
        /^(?:["])/,
        /^(?:\s*[xo<]?--+[-xo>]\s*)/,
        /^(?:\s*[xo<]?==+[=xo>]\s*)/,
        /^(?:\s*[xo<]?-?\.+-[xo>]?\s*)/,
        /^(?::\d+)/
      ],
      conditions: {
        STYLE_DEFINITION: {
          rules: [
            29
          ],
          inclusive: false
        },
        STYLE_STMNT: {
          rules: [
            28
          ],
          inclusive: false
        },
        CLASSDEFID: {
          rules: [
            23
          ],
          inclusive: false
        },
        CLASSDEF: {
          rules: [
            21,
            22
          ],
          inclusive: false
        },
        CLASS_STYLE: {
          rules: [
            26
          ],
          inclusive: false
        },
        CLASS: {
          rules: [
            25
          ],
          inclusive: false
        },
        LLABEL: {
          rules: [
            100,
            101,
            102,
            103,
            104
          ],
          inclusive: false
        },
        ARROW_DIR: {
          rules: [
            86,
            87,
            88,
            89,
            90,
            91,
            92
          ],
          inclusive: false
        },
        BLOCK_ARROW: {
          rules: [
            77,
            82,
            85
          ],
          inclusive: false
        },
        NODE: {
          rules: [
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            78,
            81
          ],
          inclusive: false
        },
        md_string: {
          rules: [
            10,
            11,
            79,
            80
          ],
          inclusive: false
        },
        space: {
          rules: [],
          inclusive: false
        },
        string: {
          rules: [
            13,
            14,
            83,
            84
          ],
          inclusive: false
        },
        acc_descr_multiline: {
          rules: [
            35,
            36
          ],
          inclusive: false
        },
        acc_descr: {
          rules: [
            33
          ],
          inclusive: false
        },
        acc_title: {
          rules: [
            31
          ],
          inclusive: false
        },
        INITIAL: {
          rules: [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            12,
            15,
            16,
            17,
            18,
            19,
            20,
            24,
            27,
            30,
            32,
            34,
            37,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            93,
            94,
            95,
            96,
            97,
            98,
            99,
            105
          ],
          inclusive: true
        }
      }
    };
    return T;
  }();
  S.lexer = I;
  function D() {
    this.yy = {};
  }
  return m$1(D, "Parser"), D.prototype = S, S.Parser = D, new D();
}();
yt.parser = yt;
var Ht = yt;
var X = /* @__PURE__ */ new Map(), kt = [], mt = /* @__PURE__ */ new Map(), jt = "color", Kt = "fill", Te = "bgFill", Ut = ",", Ce = /* @__PURE__ */ Wl(), lt = /* @__PURE__ */ new Map(), Ne = /* @__PURE__ */ m$1((e) => mC.sanitizeText(e, Ce), "sanitizeText"), Ie = /* @__PURE__ */ m$1(function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  let s = /* @__PURE__ */ lt.get(e);
  s || (s = {
    id: e,
    styles: [],
    textStyles: []
  }, lt.set(e, s)), t == null ? void 0 : t.split(Ut).forEach((n2) => {
    let i = /* @__PURE__ */ n2.replace(/([^;]*);/, "$1").trim();
    if (RegExp(jt).exec(n2)) {
      let a = /* @__PURE__ */ i.replace(Kt, Te).replace(jt, Kt);
      s.textStyles.push(a);
    }
    s.styles.push(i);
  });
}, "addStyleClass"), Oe = /* @__PURE__ */ m$1(function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  let s = /* @__PURE__ */ X.get(e);
  t != null && (s.styles = /* @__PURE__ */ t.split(Ut));
}, "addStyle2Node"), Re = /* @__PURE__ */ m$1(function(e, t) {
  e.split(",").forEach(function(s) {
    let n2 = /* @__PURE__ */ X.get(s);
    if (n2 === void 0) {
      let i = /* @__PURE__ */ s.trim();
      n2 = {
        id: i,
        type: "na",
        children: []
      }, X.set(i, n2);
    }
    n2.classes || (n2.classes = []), n2.classes.push(t);
  });
}, "setCssClass"), Vt = m$1((e, t) => {
  let s = /* @__PURE__ */ e.flat(), n2 = [];
  for (let i of s) {
    if (i.label && (i.label = /* @__PURE__ */ Ne(i.label)), i.type === "classDef") {
      Ie(i.id, i.css);
      continue;
    }
    if (i.type === "applyClass") {
      Re(i.id, (i == null ? void 0 : i.styleClass) ?? "");
      continue;
    }
    if (i.type === "applyStyles") {
      (i == null ? void 0 : i.stylesStr) && Oe(i.id, i == null ? void 0 : i.stylesStr);
      continue;
    }
    if (i.type === "column-setting") t.columns = i.columns ?? -1;
    else if (i.type === "edge") {
      let r = (mt.get(i.id) ?? 0) + 1;
      mt.set(i.id, r), i.id = r + "-" + i.id, kt.push(i);
    } else {
      i.label || (i.type === "composite" ? i.label = "" : i.label = i.id);
      let r = /* @__PURE__ */ X.get(i.id);
      if (r === void 0 ? X.set(i.id, i) : (i.type !== "na" && (r.type = i.type), i.label !== i.id && (r.label = i.label)), i.children && Vt(i.children, i), i.type === "space") {
        let a = i.width ?? 1;
        for (let l = 0; l < a; l++) {
          let o = /* @__PURE__ */ _f(i);
          o.id = o.id + "-" + l, X.set(o.id, o), n2.push(o);
        }
      } else r === void 0 && n2.push(i);
    }
  }
  t.children = n2;
}, "populateBlockDatabase"), wt = [], rt = {
  id: "root",
  type: "composite",
  children: [],
  columns: -1
}, Ae = /* @__PURE__ */ m$1(() => {
  tt.debug("Clear called"), bf(), rt = {
    id: "root",
    type: "composite",
    children: [],
    columns: -1
  }, X = /* @__PURE__ */ new Map([
    [
      "root",
      rt
    ]
  ]), wt = [], lt = /* @__PURE__ */ new Map(), kt = [], mt = /* @__PURE__ */ new Map();
}, "clear");
function ze(e) {
  switch (tt.debug("typeStr2Type", e), e) {
    case "[]":
      return "square";
    case "()":
      return tt.debug("we have a round"), "round";
    case "(())":
      return "circle";
    case ">]":
      return "rect_left_inv_arrow";
    case "{}":
      return "diamond";
    case "{{}}":
      return "hexagon";
    case "([])":
      return "stadium";
    case "[[]]":
      return "subroutine";
    case "[()]":
      return "cylinder";
    case "((()))":
      return "doublecircle";
    case "[//]":
      return "lean_right";
    case "[\\\\]":
      return "lean_left";
    case "[/\\]":
      return "trapezoid";
    case "[\\/]":
      return "inv_trapezoid";
    case "<[]>":
      return "block_arrow";
    default:
      return "na";
  }
}
m$1(ze, "typeStr2Type");
function Me(e) {
  switch (tt.debug("typeStr2Type", e), e) {
    case "==":
      return "thick";
    default:
      return "normal";
  }
}
m$1(Me, "edgeTypeStr2Type");
function Fe(e) {
  switch (e.trim()) {
    case "--x":
      return "arrow_cross";
    case "--o":
      return "arrow_circle";
    default:
      return "arrow_point";
  }
}
m$1(Fe, "edgeStrToEdgeData");
var Xt = 0, We = /* @__PURE__ */ m$1(() => (Xt++, "id-" + Math.random().toString(36).substr(2, 12) + "-" + Xt), "generateId"), Pe = /* @__PURE__ */ m$1((e) => {
  rt.children = e, Vt(e, rt), wt = rt.children;
}, "setHierarchy"), Ye = /* @__PURE__ */ m$1((e) => {
  let t = /* @__PURE__ */ X.get(e);
  return t ? t.columns ? t.columns : t.children ? t.children.length : -1 : -1;
}, "getColumns"), He = /* @__PURE__ */ m$1(() => [
  .../* @__PURE__ */ X.values()
], "getBlocksFlat"), je = /* @__PURE__ */ m$1(() => wt || [], "getBlocks"), Ke = /* @__PURE__ */ m$1(() => kt, "getEdges"), Xe = /* @__PURE__ */ m$1((e) => X.get(e), "getBlock"), Ue = /* @__PURE__ */ m$1((e) => {
  X.set(e.id, e);
}, "setBlock"), Ve = /* @__PURE__ */ m$1(() => console, "getLogger"), Ge = /* @__PURE__ */ m$1(function() {
  return lt;
}, "getClasses"), Ze = {
  getConfig: /* @__PURE__ */ m$1(() => Er$1().block, "getConfig"),
  typeStr2Type: ze,
  edgeTypeStr2Type: Me,
  edgeStrToEdgeData: Fe,
  getLogger: Ve,
  getBlocksFlat: He,
  getBlocks: je,
  getEdges: Ke,
  setHierarchy: Pe,
  getBlock: Xe,
  setBlock: Ue,
  getColumns: Ye,
  getClasses: Ge,
  clear: Ae,
  generateId: We
}, Gt = Ze;
var ot = /* @__PURE__ */ m$1((e, t) => {
  let s = ku, n2 = /* @__PURE__ */ s(e, "r"), i = /* @__PURE__ */ s(e, "g"), r = /* @__PURE__ */ s(e, "b");
  return se$1(n2, i, r, t);
}, "fade"), qe = /* @__PURE__ */ m$1((e) => `.label {
    font-family: ${e.fontFamily};
    color: ${e.nodeTextColor || e.textColor};
  }
  .cluster-label text {
    fill: ${e.titleColor};
  }
  .cluster-label span,p {
    color: ${e.titleColor};
  }



  .label text,span,p {
    fill: ${e.nodeTextColor || e.textColor};
    color: ${e.nodeTextColor || e.textColor};
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${e.mainBkg};
    stroke: ${e.nodeBorder};
    stroke-width: 1px;
  }
  .flowchart-label text {
    text-anchor: middle;
  }
  // .flowchart-label .text-outer-tspan {
  //   text-anchor: middle;
  // }
  // .flowchart-label .text-inner-tspan {
  //   text-anchor: start;
  // }

  .node .label {
    text-align: center;
  }
  .node.clickable {
    cursor: pointer;
  }

  .arrowheadPath {
    fill: ${e.arrowheadColor};
  }

  .edgePath .path {
    stroke: ${e.lineColor};
    stroke-width: 2.0px;
  }

  .flowchart-link {
    stroke: ${e.lineColor};
    fill: none;
  }

  .edgeLabel {
    background-color: ${e.edgeLabelBackground};
    rect {
      opacity: 0.5;
      background-color: ${e.edgeLabelBackground};
      fill: ${e.edgeLabelBackground};
    }
    text-align: center;
  }

  /* For html labels only */
  .labelBkg {
    background-color: ${ot(e.edgeLabelBackground, 0.5)};
    // background-color:
  }

  .node .cluster {
    // fill: ${ot(e.mainBkg, 0.5)};
    fill: ${ot(e.clusterBkg, 0.5)};
    stroke: ${ot(e.clusterBorder, 0.2)};
    box-shadow: rgba(50, 50, 93, 0.25) 0px 13px 27px -5px, rgba(0, 0, 0, 0.3) 0px 8px 16px -8px;
    stroke-width: 1px;
  }

  .cluster text {
    fill: ${e.titleColor};
  }

  .cluster span,p {
    color: ${e.titleColor};
  }
  /* .cluster div {
    color: ${e.titleColor};
  } */

  div.mermaidTooltip {
    position: absolute;
    text-align: center;
    max-width: 200px;
    padding: 2px;
    font-family: ${e.fontFamily};
    font-size: 12px;
    background: ${e.tertiaryColor};
    border: 1px solid ${e.border2};
    border-radius: 2px;
    pointer-events: none;
    z-index: 100;
  }

  .flowchartTitleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${e.textColor};
  }
`, "getStyles"), Zt = qe;
var Je = /* @__PURE__ */ m$1((e, t, s, n2) => {
  t.forEach((i) => {
    lr[i](e, s, n2);
  });
}, "insertMarkers"), Qe = /* @__PURE__ */ m$1((e, t, s) => {
  tt.trace("Making markers for ", s), e.append("defs").append("marker").attr("id", s + "_" + t + "-extensionStart").attr("class", "marker extension " + t).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 1,7 L18,13 V 1 Z"), e.append("defs").append("marker").attr("id", s + "_" + t + "-extensionEnd").attr("class", "marker extension " + t).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 1,1 V 13 L18,7 Z");
}, "extension"), $e = /* @__PURE__ */ m$1((e, t, s) => {
  e.append("defs").append("marker").attr("id", s + "_" + t + "-compositionStart").attr("class", "marker composition " + t).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), e.append("defs").append("marker").attr("id", s + "_" + t + "-compositionEnd").attr("class", "marker composition " + t).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
}, "composition"), tr = /* @__PURE__ */ m$1((e, t, s) => {
  e.append("defs").append("marker").attr("id", s + "_" + t + "-aggregationStart").attr("class", "marker aggregation " + t).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), e.append("defs").append("marker").attr("id", s + "_" + t + "-aggregationEnd").attr("class", "marker aggregation " + t).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
}, "aggregation"), er = /* @__PURE__ */ m$1((e, t, s) => {
  e.append("defs").append("marker").attr("id", s + "_" + t + "-dependencyStart").attr("class", "marker dependency " + t).attr("refX", 6).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 5,7 L9,13 L1,7 L9,1 Z"), e.append("defs").append("marker").attr("id", s + "_" + t + "-dependencyEnd").attr("class", "marker dependency " + t).attr("refX", 13).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
}, "dependency"), rr = /* @__PURE__ */ m$1((e, t, s) => {
  e.append("defs").append("marker").attr("id", s + "_" + t + "-lollipopStart").attr("class", "marker lollipop " + t).attr("refX", 13).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6), e.append("defs").append("marker").attr("id", s + "_" + t + "-lollipopEnd").attr("class", "marker lollipop " + t).attr("refX", 1).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6);
}, "lollipop"), ar = /* @__PURE__ */ m$1((e, t, s) => {
  e.append("marker").attr("id", s + "_" + t + "-pointEnd").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", 6).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), e.append("marker").attr("id", s + "_" + t + "-pointStart").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", 4.5).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 5 L 10 10 L 10 0 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
}, "point"), sr = /* @__PURE__ */ m$1((e, t, s) => {
  e.append("marker").attr("id", s + "_" + t + "-circleEnd").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", 11).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), e.append("marker").attr("id", s + "_" + t + "-circleStart").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", -1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
}, "circle"), ir = /* @__PURE__ */ m$1((e, t, s) => {
  e.append("marker").attr("id", s + "_" + t + "-crossEnd").attr("class", "marker cross " + t).attr("viewBox", "0 0 11 11").attr("refX", 12).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0"), e.append("marker").attr("id", s + "_" + t + "-crossStart").attr("class", "marker cross " + t).attr("viewBox", "0 0 11 11").attr("refX", -1).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0");
}, "cross"), nr = /* @__PURE__ */ m$1((e, t, s) => {
  e.append("defs").append("marker").attr("id", s + "_" + t + "-barbEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 14).attr("markerUnits", "strokeWidth").attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
}, "barb"), lr = {
  extension: Qe,
  composition: $e,
  aggregation: tr,
  dependency: er,
  lollipop: rr,
  point: ar,
  circle: sr,
  cross: ir,
  barb: nr
}, qt = Je;
var O = ((_b = (_a = Wl()) == null ? void 0 : _a.block) == null ? void 0 : _b.padding) ?? 8;
function or(e, t) {
  if (e === 0 || !Number.isInteger(e)) throw new Error("Columns must be an integer !== 0.");
  if (t < 0 || !Number.isInteger(t)) throw new Error("Position must be a non-negative integer." + t);
  if (e < 0) return {
    px: t,
    py: 0
  };
  if (e === 1) return {
    px: 0,
    py: t
  };
  let s = t % e, n2 = /* @__PURE__ */ Math.floor(t / e);
  return {
    px: s,
    py: n2
  };
}
m$1(or, "calculateBlockPosition");
var cr = /* @__PURE__ */ m$1((e) => {
  let t = 0, s = 0;
  for (let n2 of e.children) {
    let { width: i, height: r, x: a, y: l } = n2.size ?? {
      width: 0,
      height: 0,
      x: 0,
      y: 0
    };
    tt.debug("getMaxChildSize abc95 child:", n2.id, "width:", i, "height:", r, "x:", a, "y:", l, n2.type), n2.type !== "space" && (i > t && (t = i / (e.widthInColumns ?? 1)), r > s && (s = r));
  }
  return {
    width: t,
    height: s
  };
}, "getMaxChildSize");
function Lt(e, t) {
  var _a2, _b2, _c, _d, _e, _f2, _g, _h, _i, _j, _k;
  let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, n2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
  tt.debug("setBlockSizes abc95 (start)", e.id, (_a2 = e == null ? void 0 : e.size) == null ? void 0 : _a2.x, "block width =", e == null ? void 0 : e.size, "sieblingWidth", s), ((_b2 = e == null ? void 0 : e.size) == null ? void 0 : _b2.width) || (e.size = {
    width: s,
    height: n2,
    x: 0,
    y: 0
  });
  let i = 0, r = 0;
  if (((_c = e.children) == null ? void 0 : _c.length) > 0) {
    for (let b of e.children) Lt(b, t);
    let a = /* @__PURE__ */ cr(e);
    i = a.width, r = a.height, tt.debug("setBlockSizes abc95 maxWidth of", e.id, ":s children is ", i, r);
    for (let b of e.children) b.size && (tt.debug(`abc95 Setting size of children of ${e.id} id=${b.id} ${i} ${r} ${JSON.stringify(b.size)}`), b.size.width = i * (b.widthInColumns ?? 1) + O * ((b.widthInColumns ?? 1) - 1), b.size.height = r, b.size.x = 0, b.size.y = 0, tt.debug(`abc95 updating size of ${e.id} children child:${b.id} maxWidth:${i} maxHeight:${r}`));
    for (let b of e.children) Lt(b, t, i, r);
    let l = e.columns ?? -1, o = 0;
    for (let b of e.children) o += b.widthInColumns ?? 1;
    let u = e.children.length;
    l > 0 && l < o && (u = l);
    let g = /* @__PURE__ */ Math.ceil(o / u), x = u * (i + O) + O, m2 = g * (r + O) + O;
    if (x < s) {
      tt.debug(`Detected to small siebling: abc95 ${e.id} sieblingWidth ${s} sieblingHeight ${n2} width ${x}`), x = s, m2 = n2;
      let b = (s - u * O - O) / u, L = (n2 - g * O - O) / g;
      tt.debug("Size indata abc88", e.id, "childWidth", b, "maxWidth", i), tt.debug("Size indata abc88", e.id, "childHeight", L, "maxHeight", r), tt.debug("Size indata abc88 xSize", u, "padding", O);
      for (let _ of e.children) _.size && (_.size.width = b, _.size.height = L, _.size.x = 0, _.size.y = 0);
    }
    if (tt.debug(`abc95 (finale calc) ${e.id} xSize ${u} ySize ${g} columns ${l}${e.children.length} width=${Math.max(x, ((_d = e.size) == null ? void 0 : _d.width) || 0)}`), x < (((_e = e == null ? void 0 : e.size) == null ? void 0 : _e.width) || 0)) {
      x = ((_f2 = e == null ? void 0 : e.size) == null ? void 0 : _f2.width) || 0;
      let b = l > 0 ? Math.min(e.children.length, l) : e.children.length;
      if (b > 0) {
        let L = (x - b * O - O) / b;
        tt.debug("abc95 (growing to fit) width", e.id, x, (_g = e.size) == null ? void 0 : _g.width, L);
        for (let _ of e.children) _.size && (_.size.width = L);
      }
    }
    e.size = {
      width: x,
      height: m2,
      x: 0,
      y: 0
    };
  }
  tt.debug("setBlockSizes abc94 (done)", e.id, (_h = e == null ? void 0 : e.size) == null ? void 0 : _h.x, (_i = e == null ? void 0 : e.size) == null ? void 0 : _i.width, (_j = e == null ? void 0 : e.size) == null ? void 0 : _j.y, (_k = e == null ? void 0 : e.size) == null ? void 0 : _k.height);
}
m$1(Lt, "setBlockSizes");
function Jt(e, t) {
  var _a2, _b2, _c, _d, _e, _f2, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
  tt.debug(`abc85 layout blocks (=>layoutBlocks) ${e.id} x: ${(_a2 = e == null ? void 0 : e.size) == null ? void 0 : _a2.x} y: ${(_b2 = e == null ? void 0 : e.size) == null ? void 0 : _b2.y} width: ${(_c = e == null ? void 0 : e.size) == null ? void 0 : _c.width}`);
  let s = e.columns ?? -1;
  if (tt.debug("layoutBlocks columns abc95", e.id, "=>", s, e), e.children && e.children.length > 0) {
    let n2 = ((_e = (_d = e == null ? void 0 : e.children[0]) == null ? void 0 : _d.size) == null ? void 0 : _e.width) ?? 0, i = e.children.length * n2 + (e.children.length - 1) * O;
    tt.debug("widthOfChildren 88", i, "posX");
    let r = 0;
    tt.debug("abc91 block?.size?.x", e.id, (_f2 = e == null ? void 0 : e.size) == null ? void 0 : _f2.x);
    let a = ((_g = e == null ? void 0 : e.size) == null ? void 0 : _g.x) ? ((_h = e == null ? void 0 : e.size) == null ? void 0 : _h.x) + (-((_i = e == null ? void 0 : e.size) == null ? void 0 : _i.width) / 2 || 0) : -O, l = 0;
    for (let o of e.children) {
      let u = e;
      if (!o.size) continue;
      let { width: g, height: x } = o.size, { px: m2, py: b } = or(s, r);
      if (b != l && (l = b, a = ((_j = e == null ? void 0 : e.size) == null ? void 0 : _j.x) ? ((_k = e == null ? void 0 : e.size) == null ? void 0 : _k.x) + (-((_l = e == null ? void 0 : e.size) == null ? void 0 : _l.width) / 2 || 0) : -O, tt.debug("New row in layout for block", e.id, " and child ", o.id, l)), tt.debug(`abc89 layout blocks (child) id: ${o.id} Pos: ${r} (px, py) ${m2},${b} (${(_m = u == null ? void 0 : u.size) == null ? void 0 : _m.x},${(_n = u == null ? void 0 : u.size) == null ? void 0 : _n.y}) parent: ${u.id} width: ${g}${O}`), u.size) {
        let L = g / 2;
        o.size.x = a + O + L, tt.debug(`abc91 layout blocks (calc) px, pyid:${o.id} startingPos=X${a} new startingPosX${o.size.x} ${L} padding=${O} width=${g} halfWidth=${L} => x:${o.size.x} y:${o.size.y} ${o.widthInColumns} (width * (child?.w || 1)) / 2 ${g * ((o == null ? void 0 : o.widthInColumns) ?? 1) / 2}`), a = o.size.x + L, o.size.y = u.size.y - u.size.height / 2 + b * (x + O) + x / 2 + O, tt.debug(`abc88 layout blocks (calc) px, pyid:${o.id}startingPosX${a}${O}${L}=>x:${o.size.x}y:${o.size.y}${o.widthInColumns}(width * (child?.w || 1)) / 2${g * ((o == null ? void 0 : o.widthInColumns) ?? 1) / 2}`);
      }
      o.children && Jt(o), r += (o == null ? void 0 : o.widthInColumns) ?? 1, tt.debug("abc88 columnsPos", o, r);
    }
  }
  tt.debug(`layout blocks (<==layoutBlocks) ${e.id} x: ${(_o = e == null ? void 0 : e.size) == null ? void 0 : _o.x} y: ${(_p = e == null ? void 0 : e.size) == null ? void 0 : _p.y} width: ${(_q = e == null ? void 0 : e.size) == null ? void 0 : _q.width}`);
}
m$1(Jt, "layoutBlocks");
function Qt(e) {
  let { minX: t, minY: s, maxX: n2, maxY: i } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    minX: 0,
    minY: 0,
    maxX: 0,
    maxY: 0
  };
  if (e.size && e.id !== "root") {
    let { x: r, y: a, width: l, height: o } = e.size;
    r - l / 2 < t && (t = r - l / 2), a - o / 2 < s && (s = a - o / 2), r + l / 2 > n2 && (n2 = r + l / 2), a + o / 2 > i && (i = a + o / 2);
  }
  if (e.children) for (let r of e.children) ({ minX: t, minY: s, maxX: n2, maxY: i } = /* @__PURE__ */ Qt(r, {
    minX: t,
    minY: s,
    maxX: n2,
    maxY: i
  }));
  return {
    minX: t,
    minY: s,
    maxX: n2,
    maxY: i
  };
}
m$1(Qt, "findBounds");
function $t(e) {
  let t = /* @__PURE__ */ e.getBlock("root");
  if (!t) return;
  Lt(t, e, 0, 0), Jt(t), tt.debug("getBlocks", /* @__PURE__ */ JSON.stringify(t, null, 2));
  let { minX: s, minY: n2, maxX: i, maxY: r } = Qt(t), a = r - n2, l = i - s;
  return {
    x: s,
    y: n2,
    width: l,
    height: a
  };
}
m$1($t, "layout");
function te(e, t) {
  t && e.attr("style", t);
}
m$1(te, "applyStyle");
function hr(e) {
  let t = /* @__PURE__ */ rh(/* @__PURE__ */ document.createElementNS("http://www.w3.org/2000/svg", "foreignObject")), s = /* @__PURE__ */ t.append("xhtml:div"), n2 = e.label, i = e.isNode ? "nodeLabel" : "edgeLabel", r = /* @__PURE__ */ s.append("span");
  return r.html(n2), te(r, e.labelStyle), r.attr("class", i), te(s, e.labelStyle), s.style("display", "inline-block"), s.style("white-space", "nowrap"), s.attr("xmlns", "http://www.w3.org/1999/xhtml"), t.node();
}
m$1(hr, "addHtmlLabel");
var gr = /* @__PURE__ */ m$1((e, t, s, n2) => {
  let i = e || "";
  if (typeof i == "object" && (i = i[0]), uf(Wl().flowchart.htmlLabels)) {
    i = /* @__PURE__ */ i.replace(/\\n|\n/g, "<br />"), tt.debug("vertexText" + i);
    let r = {
      isNode: n2,
      label: /* @__PURE__ */ ft(/* @__PURE__ */ Xe$1(i)),
      labelStyle: /* @__PURE__ */ t.replace("fill:", "color:")
    };
    return hr(r);
  } else {
    let r = /* @__PURE__ */ document.createElementNS("http://www.w3.org/2000/svg", "text");
    r.setAttribute("style", /* @__PURE__ */ t.replace("color:", "fill:"));
    let a = [];
    typeof i == "string" ? a = /* @__PURE__ */ i.split(/\\n|\n|<br\s*\/?>/gi) : Array.isArray(i) ? a = i : a = [];
    for (let l of a) {
      let o = /* @__PURE__ */ document.createElementNS("http://www.w3.org/2000/svg", "tspan");
      o.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), o.setAttribute("dy", "1em"), o.setAttribute("x", "0"), s ? o.setAttribute("class", "title-row") : o.setAttribute("class", "row"), o.textContent = /* @__PURE__ */ l.trim(), r.appendChild(o);
    }
    return r;
  }
}, "createLabel"), W = gr;
var re = /* @__PURE__ */ m$1((e, t, s, n2, i) => {
  t.arrowTypeStart && ee(e, "start", t.arrowTypeStart, s, n2, i), t.arrowTypeEnd && ee(e, "end", t.arrowTypeEnd, s, n2, i);
}, "addEdgeMarkers"), dr = {
  arrow_cross: "cross",
  arrow_point: "point",
  arrow_barb: "barb",
  arrow_circle: "circle",
  aggregation: "aggregation",
  extension: "extension",
  composition: "composition",
  dependency: "dependency",
  lollipop: "lollipop"
}, ee = /* @__PURE__ */ m$1((e, t, s, n2, i, r) => {
  let a = dr[s];
  if (!a) {
    tt.warn(`Unknown arrow type: ${s}`);
    return;
  }
  let l = t === "start" ? "Start" : "End";
  e.attr(`marker-${t}`, `url(${n2}#${i}_${r}-${a}${l})`);
}, "addEdgeMarker");
var St = {}, M = {};
var se = /* @__PURE__ */ m$1((e, t) => {
  let s = /* @__PURE__ */ Wl(), n2 = /* @__PURE__ */ uf(s.flowchart.htmlLabels), i = t.labelType === "markdown" ? Zt$1(e, t.label, {
    style: t.labelStyle,
    useHtmlLabels: n2,
    addSvgBackground: true
  }, s) : W(t.label, t.labelStyle), r = /* @__PURE__ */ e.insert("g").attr("class", "edgeLabel"), a = /* @__PURE__ */ r.insert("g").attr("class", "label");
  a.node().appendChild(i);
  let l = /* @__PURE__ */ i.getBBox();
  if (n2) {
    let u = i.children[0], g = /* @__PURE__ */ rh(i);
    l = /* @__PURE__ */ u.getBoundingClientRect(), g.attr("width", l.width), g.attr("height", l.height);
  }
  a.attr("transform", "translate(" + -l.width / 2 + ", " + -l.height / 2 + ")"), St[t.id] = r, t.width = l.width, t.height = l.height;
  let o;
  if (t.startLabelLeft) {
    let u = /* @__PURE__ */ W(t.startLabelLeft, t.labelStyle), g = /* @__PURE__ */ e.insert("g").attr("class", "edgeTerminals"), x = /* @__PURE__ */ g.insert("g").attr("class", "inner");
    o = /* @__PURE__ */ x.node().appendChild(u);
    let m2 = /* @__PURE__ */ u.getBBox();
    x.attr("transform", "translate(" + -m2.width / 2 + ", " + -m2.height / 2 + ")"), M[t.id] || (M[t.id] = {}), M[t.id].startLeft = g, ct(o, t.startLabelLeft);
  }
  if (t.startLabelRight) {
    let u = /* @__PURE__ */ W(t.startLabelRight, t.labelStyle), g = /* @__PURE__ */ e.insert("g").attr("class", "edgeTerminals"), x = /* @__PURE__ */ g.insert("g").attr("class", "inner");
    o = /* @__PURE__ */ g.node().appendChild(u), x.node().appendChild(u);
    let m2 = /* @__PURE__ */ u.getBBox();
    x.attr("transform", "translate(" + -m2.width / 2 + ", " + -m2.height / 2 + ")"), M[t.id] || (M[t.id] = {}), M[t.id].startRight = g, ct(o, t.startLabelRight);
  }
  if (t.endLabelLeft) {
    let u = /* @__PURE__ */ W(t.endLabelLeft, t.labelStyle), g = /* @__PURE__ */ e.insert("g").attr("class", "edgeTerminals"), x = /* @__PURE__ */ g.insert("g").attr("class", "inner");
    o = /* @__PURE__ */ x.node().appendChild(u);
    let m2 = /* @__PURE__ */ u.getBBox();
    x.attr("transform", "translate(" + -m2.width / 2 + ", " + -m2.height / 2 + ")"), g.node().appendChild(u), M[t.id] || (M[t.id] = {}), M[t.id].endLeft = g, ct(o, t.endLabelLeft);
  }
  if (t.endLabelRight) {
    let u = /* @__PURE__ */ W(t.endLabelRight, t.labelStyle), g = /* @__PURE__ */ e.insert("g").attr("class", "edgeTerminals"), x = /* @__PURE__ */ g.insert("g").attr("class", "inner");
    o = /* @__PURE__ */ x.node().appendChild(u);
    let m2 = /* @__PURE__ */ u.getBBox();
    x.attr("transform", "translate(" + -m2.width / 2 + ", " + -m2.height / 2 + ")"), g.node().appendChild(u), M[t.id] || (M[t.id] = {}), M[t.id].endRight = g, ct(o, t.endLabelRight);
  }
  return i;
}, "insertEdgeLabel");
function ct(e, t) {
  Wl().flowchart.htmlLabels && e && (e.style.width = t.length * 9 + "px", e.style.height = "12px");
}
m$1(ct, "setTerminalWidth");
var ie = /* @__PURE__ */ m$1((e, t) => {
  tt.debug("Moving label abc88 ", e.id, e.label, St[e.id], t);
  let s = t.updatedPath ? t.updatedPath : t.originalPath, n$1 = /* @__PURE__ */ Wl(), { subGraphTitleTotalMargin: i } = n(n$1);
  if (e.label) {
    let r = St[e.id], a = e.x, l = e.y;
    if (s) {
      let o = /* @__PURE__ */ Ie$1.calcLabelPosition(s);
      tt.debug("Moving label " + e.label + " from (", a, ",", l, ") to (", o.x, ",", o.y, ") abc88"), t.updatedPath && (a = o.x, l = o.y);
    }
    r.attr("transform", `translate(${a}, ${l + i / 2})`);
  }
  if (e.startLabelLeft) {
    let r = M[e.id].startLeft, a = e.x, l = e.y;
    if (s) {
      let o = /* @__PURE__ */ Ie$1.calcTerminalLabelPosition(e.arrowTypeStart ? 10 : 0, "start_left", s);
      a = o.x, l = o.y;
    }
    r.attr("transform", `translate(${a}, ${l})`);
  }
  if (e.startLabelRight) {
    let r = M[e.id].startRight, a = e.x, l = e.y;
    if (s) {
      let o = /* @__PURE__ */ Ie$1.calcTerminalLabelPosition(e.arrowTypeStart ? 10 : 0, "start_right", s);
      a = o.x, l = o.y;
    }
    r.attr("transform", `translate(${a}, ${l})`);
  }
  if (e.endLabelLeft) {
    let r = M[e.id].endLeft, a = e.x, l = e.y;
    if (s) {
      let o = /* @__PURE__ */ Ie$1.calcTerminalLabelPosition(e.arrowTypeEnd ? 10 : 0, "end_left", s);
      a = o.x, l = o.y;
    }
    r.attr("transform", `translate(${a}, ${l})`);
  }
  if (e.endLabelRight) {
    let r = M[e.id].endRight, a = e.x, l = e.y;
    if (s) {
      let o = /* @__PURE__ */ Ie$1.calcTerminalLabelPosition(e.arrowTypeEnd ? 10 : 0, "end_right", s);
      a = o.x, l = o.y;
    }
    r.attr("transform", `translate(${a}, ${l})`);
  }
}, "positionEdgeLabel"), ur = /* @__PURE__ */ m$1((e, t) => {
  let s = e.x, n2 = e.y, i = /* @__PURE__ */ Math.abs(t.x - s), r = /* @__PURE__ */ Math.abs(t.y - n2), a = e.width / 2, l = e.height / 2;
  return i >= a || r >= l;
}, "outsideNode"), pr = /* @__PURE__ */ m$1((e, t, s) => {
  tt.debug(`intersection calc abc89:
  outsidePoint: ${JSON.stringify(t)}
  insidePoint : ${JSON.stringify(s)}
  node        : x:${e.x} y:${e.y} w:${e.width} h:${e.height}`);
  let n2 = e.x, i = e.y, r = /* @__PURE__ */ Math.abs(n2 - s.x), a = e.width / 2, l = s.x < t.x ? a - r : a + r, o = e.height / 2, u = /* @__PURE__ */ Math.abs(t.y - s.y), g = /* @__PURE__ */ Math.abs(t.x - s.x);
  if (Math.abs(i - t.y) * a > Math.abs(n2 - t.x) * o) {
    let x = s.y < t.y ? t.y - o - i : i - o - t.y;
    l = g * x / u;
    let m2 = {
      x: s.x < t.x ? s.x + l : s.x - g + l,
      y: s.y < t.y ? s.y + u - x : s.y - u + x
    };
    return l === 0 && (m2.x = t.x, m2.y = t.y), g === 0 && (m2.x = t.x), u === 0 && (m2.y = t.y), tt.debug(`abc89 topp/bott calc, Q ${u}, q ${x}, R ${g}, r ${l}`, m2), m2;
  } else {
    s.x < t.x ? l = t.x - a - n2 : l = n2 - a - t.x;
    let x = u * l / g, m2 = s.x < t.x ? s.x + g - l : s.x - g + l, b = s.y < t.y ? s.y + x : s.y - x;
    return tt.debug(`sides calc abc89, Q ${u}, q ${x}, R ${g}, r ${l}`, {
      _x: m2,
      _y: b
    }), l === 0 && (m2 = t.x, b = t.y), g === 0 && (m2 = t.x), u === 0 && (b = t.y), {
      x: m2,
      y: b
    };
  }
}, "intersection"), ae = /* @__PURE__ */ m$1((e, t) => {
  tt.debug("abc88 cutPathAtIntersect", e, t);
  let s = [], n2 = e[0], i = false;
  return e.forEach((r) => {
    if (!ur(t, r) && !i) {
      let a = /* @__PURE__ */ pr(t, n2, r), l = false;
      s.forEach((o) => {
        l = l || o.x === a.x && o.y === a.y;
      }), s.some((o) => o.x === a.x && o.y === a.y) || s.push(a), i = true;
    } else n2 = r, i || s.push(r);
  }), s;
}, "cutPathAtIntersect"), ne = /* @__PURE__ */ m$1(function(e, t, s, n2, i, r, a) {
  let l = s.points;
  tt.debug("abc88 InsertEdge: edge=", s, "e=", t);
  let o = false, u = /* @__PURE__ */ r.node(t.v);
  var g = /* @__PURE__ */ r.node(t.w);
  (g == null ? void 0 : g.intersect) && (u == null ? void 0 : u.intersect) && (l = /* @__PURE__ */ l.slice(1, s.points.length - 1), l.unshift(/* @__PURE__ */ u.intersect(l[0])), l.push(/* @__PURE__ */ g.intersect(l[l.length - 1]))), s.toCluster && (tt.debug("to cluster abc88", n2[s.toCluster]), l = /* @__PURE__ */ ae(s.points, n2[s.toCluster].node), o = true), s.fromCluster && (tt.debug("from cluster abc88", n2[s.fromCluster]), l = /* @__PURE__ */ ae(/* @__PURE__ */ l.reverse(), n2[s.fromCluster].node).reverse(), o = true);
  let x = /* @__PURE__ */ l.filter((y) => !Number.isNaN(y.y)), m2 = wc;
  s.curve && (i === "graph" || i === "flowchart") && (m2 = s.curve);
  let { x: b, y: L } = d(s), _ = /* @__PURE__ */ Sc().x(b).y(L).curve(m2), S;
  switch (s.thickness) {
    case "normal":
      S = "edge-thickness-normal";
      break;
    case "thick":
      S = "edge-thickness-thick";
      break;
    case "invisible":
      S = "edge-thickness-thick";
      break;
    default:
      S = "";
  }
  switch (s.pattern) {
    case "solid":
      S += " edge-pattern-solid";
      break;
    case "dotted":
      S += " edge-pattern-dotted";
      break;
    case "dashed":
      S += " edge-pattern-dashed";
      break;
  }
  let I = /* @__PURE__ */ e.append("path").attr("d", /* @__PURE__ */ _(x)).attr("id", s.id).attr("class", " " + S + (s.classes ? " " + s.classes : "")).attr("style", s.style), D = "";
  (Wl().flowchart.arrowMarkerAbsolute || Wl().state.arrowMarkerAbsolute) && (D = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search, D = /* @__PURE__ */ D.replace(/\(/g, "\\("), D = /* @__PURE__ */ D.replace(/\)/g, "\\)")), re(I, s, D, a, i);
  let T = {};
  return o && (T.updatedPath = l), T.originalPath = s.points, T;
}, "insertEdge");
var fr = /* @__PURE__ */ m$1((e) => {
  let t = /* @__PURE__ */ new Set();
  for (let s of e) switch (s) {
    case "x":
      t.add("right"), t.add("left");
      break;
    case "y":
      t.add("up"), t.add("down");
      break;
    default:
      t.add(s);
      break;
  }
  return t;
}, "expandAndDeduplicateDirections"), le = /* @__PURE__ */ m$1((e, t, s) => {
  let n2 = /* @__PURE__ */ fr(e), i = 2, r = t.height + 2 * s.padding, a = r / i, l = t.width + 2 * a + s.padding, o = s.padding / 2;
  return n2.has("right") && n2.has("left") && n2.has("up") && n2.has("down") ? [
    {
      x: 0,
      y: 0
    },
    {
      x: a,
      y: 0
    },
    {
      x: l / 2,
      y: 2 * o
    },
    {
      x: l - a,
      y: 0
    },
    {
      x: l,
      y: 0
    },
    {
      x: l,
      y: -r / 3
    },
    {
      x: l + 2 * o,
      y: -r / 2
    },
    {
      x: l,
      y: -2 * r / 3
    },
    {
      x: l,
      y: -r
    },
    {
      x: l - a,
      y: -r
    },
    {
      x: l / 2,
      y: -r - 2 * o
    },
    {
      x: a,
      y: -r
    },
    {
      x: 0,
      y: -r
    },
    {
      x: 0,
      y: -2 * r / 3
    },
    {
      x: -2 * o,
      y: -r / 2
    },
    {
      x: 0,
      y: -r / 3
    }
  ] : n2.has("right") && n2.has("left") && n2.has("up") ? [
    {
      x: a,
      y: 0
    },
    {
      x: l - a,
      y: 0
    },
    {
      x: l,
      y: -r / 2
    },
    {
      x: l - a,
      y: -r
    },
    {
      x: a,
      y: -r
    },
    {
      x: 0,
      y: -r / 2
    }
  ] : n2.has("right") && n2.has("left") && n2.has("down") ? [
    {
      x: 0,
      y: 0
    },
    {
      x: a,
      y: -r
    },
    {
      x: l - a,
      y: -r
    },
    {
      x: l,
      y: 0
    }
  ] : n2.has("right") && n2.has("up") && n2.has("down") ? [
    {
      x: 0,
      y: 0
    },
    {
      x: l,
      y: -a
    },
    {
      x: l,
      y: -r + a
    },
    {
      x: 0,
      y: -r
    }
  ] : n2.has("left") && n2.has("up") && n2.has("down") ? [
    {
      x: l,
      y: 0
    },
    {
      x: 0,
      y: -a
    },
    {
      x: 0,
      y: -r + a
    },
    {
      x: l,
      y: -r
    }
  ] : n2.has("right") && n2.has("left") ? [
    {
      x: a,
      y: 0
    },
    {
      x: a,
      y: -o
    },
    {
      x: l - a,
      y: -o
    },
    {
      x: l - a,
      y: 0
    },
    {
      x: l,
      y: -r / 2
    },
    {
      x: l - a,
      y: -r
    },
    {
      x: l - a,
      y: -r + o
    },
    {
      x: a,
      y: -r + o
    },
    {
      x: a,
      y: -r
    },
    {
      x: 0,
      y: -r / 2
    }
  ] : n2.has("up") && n2.has("down") ? [
    {
      x: l / 2,
      y: 0
    },
    {
      x: 0,
      y: -o
    },
    {
      x: a,
      y: -o
    },
    {
      x: a,
      y: -r + o
    },
    {
      x: 0,
      y: -r + o
    },
    {
      x: l / 2,
      y: -r
    },
    {
      x: l,
      y: -r + o
    },
    {
      x: l - a,
      y: -r + o
    },
    {
      x: l - a,
      y: -o
    },
    {
      x: l,
      y: -o
    }
  ] : n2.has("right") && n2.has("up") ? [
    {
      x: 0,
      y: 0
    },
    {
      x: l,
      y: -a
    },
    {
      x: 0,
      y: -r
    }
  ] : n2.has("right") && n2.has("down") ? [
    {
      x: 0,
      y: 0
    },
    {
      x: l,
      y: 0
    },
    {
      x: 0,
      y: -r
    }
  ] : n2.has("left") && n2.has("up") ? [
    {
      x: l,
      y: 0
    },
    {
      x: 0,
      y: -a
    },
    {
      x: l,
      y: -r
    }
  ] : n2.has("left") && n2.has("down") ? [
    {
      x: l,
      y: 0
    },
    {
      x: 0,
      y: 0
    },
    {
      x: l,
      y: -r
    }
  ] : n2.has("right") ? [
    {
      x: a,
      y: -o
    },
    {
      x: a,
      y: -o
    },
    {
      x: l - a,
      y: -o
    },
    {
      x: l - a,
      y: 0
    },
    {
      x: l,
      y: -r / 2
    },
    {
      x: l - a,
      y: -r
    },
    {
      x: l - a,
      y: -r + o
    },
    {
      x: a,
      y: -r + o
    },
    {
      x: a,
      y: -r + o
    }
  ] : n2.has("left") ? [
    {
      x: a,
      y: 0
    },
    {
      x: a,
      y: -o
    },
    {
      x: l - a,
      y: -o
    },
    {
      x: l - a,
      y: -r + o
    },
    {
      x: a,
      y: -r + o
    },
    {
      x: a,
      y: -r
    },
    {
      x: 0,
      y: -r / 2
    }
  ] : n2.has("up") ? [
    {
      x: a,
      y: -o
    },
    {
      x: a,
      y: -r + o
    },
    {
      x: 0,
      y: -r + o
    },
    {
      x: l / 2,
      y: -r
    },
    {
      x: l,
      y: -r + o
    },
    {
      x: l - a,
      y: -r + o
    },
    {
      x: l - a,
      y: -o
    }
  ] : n2.has("down") ? [
    {
      x: l / 2,
      y: 0
    },
    {
      x: 0,
      y: -o
    },
    {
      x: a,
      y: -o
    },
    {
      x: a,
      y: -r + o
    },
    {
      x: l - a,
      y: -r + o
    },
    {
      x: l - a,
      y: -o
    },
    {
      x: l,
      y: -o
    }
  ] : [
    {
      x: 0,
      y: 0
    }
  ];
}, "getArrowPoints");
function xr(e, t) {
  return e.intersect(t);
}
m$1(xr, "intersectNode");
var oe = xr;
function br(e, t, s, n2) {
  var i = e.x, r = e.y, a = i - n2.x, l = r - n2.y, o = /* @__PURE__ */ Math.sqrt(t * t * l * l + s * s * a * a), u = /* @__PURE__ */ Math.abs(t * s * a / o);
  n2.x < i && (u = -u);
  var g = /* @__PURE__ */ Math.abs(t * s * l / o);
  return n2.y < r && (g = -g), {
    x: i + u,
    y: r + g
  };
}
m$1(br, "intersectEllipse");
var ht = br;
function yr(e, t, s) {
  return ht(e, t, t, s);
}
m$1(yr, "intersectCircle");
var ce = yr;
function mr(e, t, s, n2) {
  var i, r, a, l, o, u, g, x, m2, b, L, _, S, I, D;
  if (i = t.y - e.y, a = e.x - t.x, o = t.x * e.y - e.x * t.y, m2 = i * s.x + a * s.y + o, b = i * n2.x + a * n2.y + o, !(m2 !== 0 && b !== 0 && he(m2, b)) && (r = n2.y - s.y, l = s.x - n2.x, u = n2.x * s.y - s.x * n2.y, g = r * e.x + l * e.y + u, x = r * t.x + l * t.y + u, !(g !== 0 && x !== 0 && he(g, x)) && (L = i * l - r * a, L !== 0))) return _ = /* @__PURE__ */ Math.abs(L / 2), S = a * u - l * o, I = S < 0 ? (S - _) / L : (S + _) / L, S = r * o - i * u, D = S < 0 ? (S - _) / L : (S + _) / L, {
    x: I,
    y: D
  };
}
m$1(mr, "intersectLine");
function he(e, t) {
  return e * t > 0;
}
m$1(he, "sameSign");
var ge = mr;
var de = kr;
function kr(e, t, s) {
  var n2 = e.x, i = e.y, r = [], a = Number.POSITIVE_INFINITY, l = Number.POSITIVE_INFINITY;
  typeof t.forEach == "function" ? t.forEach(function(L) {
    a = /* @__PURE__ */ Math.min(a, L.x), l = /* @__PURE__ */ Math.min(l, L.y);
  }) : (a = /* @__PURE__ */ Math.min(a, t.x), l = /* @__PURE__ */ Math.min(l, t.y));
  for (var o = n2 - e.width / 2 - a, u = i - e.height / 2 - l, g = 0; g < t.length; g++) {
    var x = t[g], m2 = t[g < t.length - 1 ? g + 1 : 0], b = /* @__PURE__ */ ge(e, s, {
      x: o + x.x,
      y: u + x.y
    }, {
      x: o + m2.x,
      y: u + m2.y
    });
    b && r.push(b);
  }
  return r.length ? (r.length > 1 && r.sort(function(L, _) {
    var S = L.x - s.x, I = L.y - s.y, D = /* @__PURE__ */ Math.sqrt(S * S + I * I), T = _.x - s.x, y = _.y - s.y, d2 = /* @__PURE__ */ Math.sqrt(T * T + y * y);
    return D < d2 ? -1 : D === d2 ? 0 : 1;
  }), r[0]) : e;
}
m$1(kr, "intersectPolygon");
var wr = /* @__PURE__ */ m$1((e, t) => {
  var s = e.x, n2 = e.y, i = t.x - s, r = t.y - n2, a = e.width / 2, l = e.height / 2, o, u;
  return Math.abs(r) * a > Math.abs(i) * l ? (r < 0 && (l = -l), o = r === 0 ? 0 : l * i / r, u = l) : (i < 0 && (a = -a), o = a, u = i === 0 ? 0 : a * r / i), {
    x: s + o,
    y: n2 + u
  };
}, "intersectRect"), ue = wr;
var v = {
  node: oe,
  circle: ce,
  ellipse: ht,
  polygon: de,
  rect: ue
};
var A = /* @__PURE__ */ m$1(async (e, t, s, n2) => {
  let i = /* @__PURE__ */ Wl(), r, a = t.useHtmlLabels || uf(i.flowchart.htmlLabels);
  s ? r = s : r = "node default";
  let l = /* @__PURE__ */ e.insert("g").attr("class", r).attr("id", t.domId || t.id), o = /* @__PURE__ */ l.insert("g").attr("class", "label").attr("style", t.labelStyle), u;
  t.labelText === void 0 ? u = "" : u = typeof t.labelText == "string" ? t.labelText : t.labelText[0];
  let g = /* @__PURE__ */ o.node(), x;
  t.labelType === "markdown" ? x = /* @__PURE__ */ Zt$1(o, /* @__PURE__ */ De(/* @__PURE__ */ Xe$1(u), i), {
    useHtmlLabels: a,
    width: t.width || i.flowchart.wrappingWidth,
    classes: "markdown-node-label"
  }, i) : x = /* @__PURE__ */ g.appendChild(/* @__PURE__ */ W(/* @__PURE__ */ De(/* @__PURE__ */ Xe$1(u), i), t.labelStyle, false, n2));
  let m2 = /* @__PURE__ */ x.getBBox(), b = t.padding / 2;
  if (uf(i.flowchart.htmlLabels)) {
    let L = x.children[0], _ = /* @__PURE__ */ rh(x), S = /* @__PURE__ */ L.getElementsByTagName("img");
    if (S) {
      let I = u.replace(/<img[^>]*>/g, "").trim() === "";
      await Promise.all(/* @__PURE__ */ [
        ...S
      ].map((D) => new Promise((T) => {
        function y() {
          if (D.style.display = "flex", D.style.flexDirection = "column", I) {
            let d2 = i.fontSize ? i.fontSize : window.getComputedStyle(document.body).fontSize, w = parseInt(d2, 10) * 5 + "px";
            D.style.minWidth = w, D.style.maxWidth = w;
          } else D.style.width = "100%";
          T(D);
        }
        m$1(y, "setupImage"), setTimeout(() => {
          D.complete && y();
        }), D.addEventListener("error", y), D.addEventListener("load", y);
      })));
    }
    m2 = /* @__PURE__ */ L.getBoundingClientRect(), _.attr("width", m2.width), _.attr("height", m2.height);
  }
  return a ? o.attr("transform", "translate(" + -m2.width / 2 + ", " + -m2.height / 2 + ")") : o.attr("transform", "translate(0, " + -m2.height / 2 + ")"), t.centerLabel && o.attr("transform", "translate(" + -m2.width / 2 + ", " + -m2.height / 2 + ")"), o.insert("rect", ":first-child"), {
    shapeSvg: l,
    bbox: m2,
    halfPadding: b,
    label: o
  };
}, "labelHelper"), N = /* @__PURE__ */ m$1((e, t) => {
  let s = /* @__PURE__ */ t.node().getBBox();
  e.width = s.width, e.height = s.height;
}, "updateNodeBounds");
function U(e, t, s, n2) {
  return e.insert("polygon", ":first-child").attr("points", /* @__PURE__ */ n2.map(function(i) {
    return i.x + "," + i.y;
  }).join(" ")).attr("class", "label-container").attr("transform", "translate(" + -t / 2 + "," + s / 2 + ")");
}
m$1(U, "insertPolygonShape");
var Lr = /* @__PURE__ */ m$1(async (e, t) => {
  t.useHtmlLabels || Wl().flowchart.htmlLabels || (t.centerLabel = true);
  let { shapeSvg: n2, bbox: i, halfPadding: r } = await A(e, t, "node " + t.classes, true);
  tt.info("Classes = ", t.classes);
  let a = /* @__PURE__ */ n2.insert("rect", ":first-child");
  return a.attr("rx", t.rx).attr("ry", t.ry).attr("x", -i.width / 2 - r).attr("y", -i.height / 2 - r).attr("width", i.width + t.padding).attr("height", i.height + t.padding), N(t, a), t.intersect = function(l) {
    return v.rect(t, l);
  }, n2;
}, "note"), pe = Lr;
var fe = /* @__PURE__ */ m$1((e) => e ? " " + e : "", "formatClass"), j = /* @__PURE__ */ m$1((e, t) => `${t || "node default"}${fe(e.classes)} ${fe(e.class)}`, "getClassesFromNode"), xe = /* @__PURE__ */ m$1(async (e, t) => {
  let { shapeSvg: s, bbox: n2 } = await A(e, t, /* @__PURE__ */ j(t, void 0), true), i = n2.width + t.padding, r = n2.height + t.padding, a = i + r, l = [
    {
      x: a / 2,
      y: 0
    },
    {
      x: a,
      y: -a / 2
    },
    {
      x: a / 2,
      y: -a
    },
    {
      x: 0,
      y: -a / 2
    }
  ];
  tt.info("Question main (Circle)");
  let o = /* @__PURE__ */ U(s, a, a, l);
  return o.attr("style", t.style), N(t, o), t.intersect = function(u) {
    return tt.warn("Intersect called"), v.polygon(t, l, u);
  }, s;
}, "question"), Sr = /* @__PURE__ */ m$1((e, t) => {
  let s = /* @__PURE__ */ e.insert("g").attr("class", "node default").attr("id", t.domId || t.id), n2 = 28, i = [
    {
      x: 0,
      y: n2 / 2
    },
    {
      x: n2 / 2,
      y: 0
    },
    {
      x: 0,
      y: -28 / 2
    },
    {
      x: -28 / 2,
      y: 0
    }
  ];
  return s.insert("polygon", ":first-child").attr("points", /* @__PURE__ */ i.map(function(a) {
    return a.x + "," + a.y;
  }).join(" ")).attr("class", "state-start").attr("r", 7).attr("width", 28).attr("height", 28), t.width = 28, t.height = 28, t.intersect = function(a) {
    return v.circle(t, 14, a);
  }, s;
}, "choice"), Er = /* @__PURE__ */ m$1(async (e, t) => {
  let { shapeSvg: s, bbox: n2 } = await A(e, t, /* @__PURE__ */ j(t, void 0), true), i = 4, r = n2.height + t.padding, a = r / i, l = n2.width + 2 * a + t.padding, o = [
    {
      x: a,
      y: 0
    },
    {
      x: l - a,
      y: 0
    },
    {
      x: l,
      y: -r / 2
    },
    {
      x: l - a,
      y: -r
    },
    {
      x: a,
      y: -r
    },
    {
      x: 0,
      y: -r / 2
    }
  ], u = /* @__PURE__ */ U(s, l, r, o);
  return u.attr("style", t.style), N(t, u), t.intersect = function(g) {
    return v.polygon(t, o, g);
  }, s;
}, "hexagon"), _r = /* @__PURE__ */ m$1(async (e, t) => {
  let { shapeSvg: s, bbox: n2 } = await A(e, t, void 0, true), i = 2, r = n2.height + 2 * t.padding, a = r / i, l = n2.width + 2 * a + t.padding, o = /* @__PURE__ */ le(t.directions, n2, t), u = /* @__PURE__ */ U(s, l, r, o);
  return u.attr("style", t.style), N(t, u), t.intersect = function(g) {
    return v.polygon(t, o, g);
  }, s;
}, "block_arrow"), Dr = /* @__PURE__ */ m$1(async (e, t) => {
  let { shapeSvg: s, bbox: n2 } = await A(e, t, /* @__PURE__ */ j(t, void 0), true), i = n2.width + t.padding, r = n2.height + t.padding, a = [
    {
      x: -r / 2,
      y: 0
    },
    {
      x: i,
      y: 0
    },
    {
      x: i,
      y: -r
    },
    {
      x: -r / 2,
      y: -r
    },
    {
      x: 0,
      y: -r / 2
    }
  ];
  return U(s, i, r, a).attr("style", t.style), t.width = i + r, t.height = r, t.intersect = function(o) {
    return v.polygon(t, a, o);
  }, s;
}, "rect_left_inv_arrow"), Br = /* @__PURE__ */ m$1(async (e, t) => {
  let { shapeSvg: s, bbox: n2 } = await A(e, t, /* @__PURE__ */ j(t), true), i = n2.width + t.padding, r = n2.height + t.padding, a = [
    {
      x: -2 * r / 6,
      y: 0
    },
    {
      x: i - r / 6,
      y: 0
    },
    {
      x: i + 2 * r / 6,
      y: -r
    },
    {
      x: r / 6,
      y: -r
    }
  ], l = /* @__PURE__ */ U(s, i, r, a);
  return l.attr("style", t.style), N(t, l), t.intersect = function(o) {
    return v.polygon(t, a, o);
  }, s;
}, "lean_right"), vr = /* @__PURE__ */ m$1(async (e, t) => {
  let { shapeSvg: s, bbox: n2 } = await A(e, t, /* @__PURE__ */ j(t, void 0), true), i = n2.width + t.padding, r = n2.height + t.padding, a = [
    {
      x: 2 * r / 6,
      y: 0
    },
    {
      x: i + r / 6,
      y: 0
    },
    {
      x: i - 2 * r / 6,
      y: -r
    },
    {
      x: -r / 6,
      y: -r
    }
  ], l = /* @__PURE__ */ U(s, i, r, a);
  return l.attr("style", t.style), N(t, l), t.intersect = function(o) {
    return v.polygon(t, a, o);
  }, s;
}, "lean_left"), Tr = /* @__PURE__ */ m$1(async (e, t) => {
  let { shapeSvg: s, bbox: n2 } = await A(e, t, /* @__PURE__ */ j(t, void 0), true), i = n2.width + t.padding, r = n2.height + t.padding, a = [
    {
      x: -2 * r / 6,
      y: 0
    },
    {
      x: i + 2 * r / 6,
      y: 0
    },
    {
      x: i - r / 6,
      y: -r
    },
    {
      x: r / 6,
      y: -r
    }
  ], l = /* @__PURE__ */ U(s, i, r, a);
  return l.attr("style", t.style), N(t, l), t.intersect = function(o) {
    return v.polygon(t, a, o);
  }, s;
}, "trapezoid"), Cr = /* @__PURE__ */ m$1(async (e, t) => {
  let { shapeSvg: s, bbox: n2 } = await A(e, t, /* @__PURE__ */ j(t, void 0), true), i = n2.width + t.padding, r = n2.height + t.padding, a = [
    {
      x: r / 6,
      y: 0
    },
    {
      x: i - r / 6,
      y: 0
    },
    {
      x: i + 2 * r / 6,
      y: -r
    },
    {
      x: -2 * r / 6,
      y: -r
    }
  ], l = /* @__PURE__ */ U(s, i, r, a);
  return l.attr("style", t.style), N(t, l), t.intersect = function(o) {
    return v.polygon(t, a, o);
  }, s;
}, "inv_trapezoid"), Nr = /* @__PURE__ */ m$1(async (e, t) => {
  let { shapeSvg: s, bbox: n2 } = await A(e, t, /* @__PURE__ */ j(t, void 0), true), i = n2.width + t.padding, r = n2.height + t.padding, a = [
    {
      x: 0,
      y: 0
    },
    {
      x: i + r / 2,
      y: 0
    },
    {
      x: i,
      y: -r / 2
    },
    {
      x: i + r / 2,
      y: -r
    },
    {
      x: 0,
      y: -r
    }
  ], l = /* @__PURE__ */ U(s, i, r, a);
  return l.attr("style", t.style), N(t, l), t.intersect = function(o) {
    return v.polygon(t, a, o);
  }, s;
}, "rect_right_inv_arrow"), Ir = /* @__PURE__ */ m$1(async (e, t) => {
  let { shapeSvg: s, bbox: n2 } = await A(e, t, /* @__PURE__ */ j(t, void 0), true), i = n2.width + t.padding, r = i / 2, a = r / (2.5 + i / 50), l = n2.height + a + t.padding, o = "M 0," + a + " a " + r + "," + a + " 0,0,0 " + i + " 0 a " + r + "," + a + " 0,0,0 " + -i + " 0 l 0," + l + " a " + r + "," + a + " 0,0,0 " + i + " 0 l 0," + -l, u = /* @__PURE__ */ s.attr("label-offset-y", a).insert("path", ":first-child").attr("style", t.style).attr("d", o).attr("transform", "translate(" + -i / 2 + "," + -(l / 2 + a) + ")");
  return N(t, u), t.intersect = function(g) {
    let x = /* @__PURE__ */ v.rect(t, g), m2 = x.x - t.x;
    if (r != 0 && (Math.abs(m2) < t.width / 2 || Math.abs(m2) == t.width / 2 && Math.abs(x.y - t.y) > t.height / 2 - a)) {
      let b = a * a * (1 - m2 * m2 / (r * r));
      b != 0 && (b = /* @__PURE__ */ Math.sqrt(b)), b = a - b, g.y - t.y > 0 && (b = -b), x.y += b;
    }
    return x;
  }, s;
}, "cylinder"), Or = /* @__PURE__ */ m$1(async (e, t) => {
  let { shapeSvg: s, bbox: n2, halfPadding: i } = await A(e, t, "node " + t.classes + " " + t.class, true), r = /* @__PURE__ */ s.insert("rect", ":first-child"), a = t.positioned ? t.width : n2.width + t.padding, l = t.positioned ? t.height : n2.height + t.padding, o = t.positioned ? -a / 2 : -n2.width / 2 - i, u = t.positioned ? -l / 2 : -n2.height / 2 - i;
  if (r.attr("class", "basic label-container").attr("style", t.style).attr("rx", t.rx).attr("ry", t.ry).attr("x", o).attr("y", u).attr("width", a).attr("height", l), t.props) {
    let g = new Set(Object.keys(t.props));
    t.props.borders && (Et(r, t.props.borders, a, l), g.delete("borders")), g.forEach((x) => {
      tt.warn(`Unknown node property ${x}`);
    });
  }
  return N(t, r), t.intersect = function(g) {
    return v.rect(t, g);
  }, s;
}, "rect"), Rr = /* @__PURE__ */ m$1(async (e, t) => {
  let { shapeSvg: s, bbox: n2, halfPadding: i } = await A(e, t, "node " + t.classes, true), r = /* @__PURE__ */ s.insert("rect", ":first-child"), a = t.positioned ? t.width : n2.width + t.padding, l = t.positioned ? t.height : n2.height + t.padding, o = t.positioned ? -a / 2 : -n2.width / 2 - i, u = t.positioned ? -l / 2 : -n2.height / 2 - i;
  if (r.attr("class", "basic cluster composite label-container").attr("style", t.style).attr("rx", t.rx).attr("ry", t.ry).attr("x", o).attr("y", u).attr("width", a).attr("height", l), t.props) {
    let g = new Set(Object.keys(t.props));
    t.props.borders && (Et(r, t.props.borders, a, l), g.delete("borders")), g.forEach((x) => {
      tt.warn(`Unknown node property ${x}`);
    });
  }
  return N(t, r), t.intersect = function(g) {
    return v.rect(t, g);
  }, s;
}, "composite"), Ar = /* @__PURE__ */ m$1(async (e, t) => {
  let { shapeSvg: s } = await A(e, t, "label", true);
  tt.trace("Classes = ", t.class);
  let n2 = /* @__PURE__ */ s.insert("rect", ":first-child"), i = 0, r = 0;
  if (n2.attr("width", i).attr("height", r), s.attr("class", "label edgeLabel"), t.props) {
    let a = new Set(Object.keys(t.props));
    t.props.borders && (Et(n2, t.props.borders, i, r), a.delete("borders")), a.forEach((l) => {
      tt.warn(`Unknown node property ${l}`);
    });
  }
  return N(t, n2), t.intersect = function(a) {
    return v.rect(t, a);
  }, s;
}, "labelRect");
function Et(e, t, s, n2) {
  let i = [], r = /* @__PURE__ */ m$1((l) => {
    i.push(l, 0);
  }, "addBorder"), a = /* @__PURE__ */ m$1((l) => {
    i.push(0, l);
  }, "skipBorder");
  t.includes("t") ? (tt.debug("add top border"), r(s)) : a(s), t.includes("r") ? (tt.debug("add right border"), r(n2)) : a(n2), t.includes("b") ? (tt.debug("add bottom border"), r(s)) : a(s), t.includes("l") ? (tt.debug("add left border"), r(n2)) : a(n2), e.attr("stroke-dasharray", /* @__PURE__ */ i.join(" "));
}
m$1(Et, "applyNodePropertyBorders");
var zr = /* @__PURE__ */ m$1((e, t) => {
  let s;
  t.classes ? s = "node " + t.classes : s = "node default";
  let n2 = /* @__PURE__ */ e.insert("g").attr("class", s).attr("id", t.domId || t.id), i = /* @__PURE__ */ n2.insert("rect", ":first-child"), r = /* @__PURE__ */ n2.insert("line"), a = /* @__PURE__ */ n2.insert("g").attr("class", "label"), l = t.labelText.flat ? t.labelText.flat() : t.labelText, o = "";
  typeof l == "object" ? o = l[0] : o = l, tt.info("Label text abc79", o, l, typeof l == "object");
  let u = /* @__PURE__ */ a.node().appendChild(/* @__PURE__ */ W(o, t.labelStyle, true, true)), g = {
    width: 0,
    height: 0
  };
  if (uf(Wl().flowchart.htmlLabels)) {
    let _ = u.children[0], S = /* @__PURE__ */ rh(u);
    g = /* @__PURE__ */ _.getBoundingClientRect(), S.attr("width", g.width), S.attr("height", g.height);
  }
  tt.info("Text 2", l);
  let x = /* @__PURE__ */ l.slice(1, l.length), m2 = /* @__PURE__ */ u.getBBox(), b = /* @__PURE__ */ a.node().appendChild(/* @__PURE__ */ W(x.join ? x.join("<br/>") : x, t.labelStyle, true, true));
  if (uf(Wl().flowchart.htmlLabels)) {
    let _ = b.children[0], S = /* @__PURE__ */ rh(b);
    g = /* @__PURE__ */ _.getBoundingClientRect(), S.attr("width", g.width), S.attr("height", g.height);
  }
  let L = t.padding / 2;
  return rh(b).attr("transform", "translate( " + (g.width > m2.width ? 0 : (m2.width - g.width) / 2) + ", " + (m2.height + L + 5) + ")"), rh(u).attr("transform", "translate( " + (g.width < m2.width ? 0 : -(m2.width - g.width) / 2) + ", 0)"), g = /* @__PURE__ */ a.node().getBBox(), a.attr("transform", "translate(" + -g.width / 2 + ", " + (-g.height / 2 - L + 3) + ")"), i.attr("class", "outer title-state").attr("x", -g.width / 2 - L).attr("y", -g.height / 2 - L).attr("width", g.width + t.padding).attr("height", g.height + t.padding), r.attr("class", "divider").attr("x1", -g.width / 2 - L).attr("x2", g.width / 2 + L).attr("y1", -g.height / 2 - L + m2.height + L).attr("y2", -g.height / 2 - L + m2.height + L), N(t, i), t.intersect = function(_) {
    return v.rect(t, _);
  }, n2;
}, "rectWithTitle"), Mr = /* @__PURE__ */ m$1(async (e, t) => {
  let { shapeSvg: s, bbox: n2 } = await A(e, t, /* @__PURE__ */ j(t, void 0), true), i = n2.height + t.padding, r = n2.width + i / 4 + t.padding, a = /* @__PURE__ */ s.insert("rect", ":first-child").attr("style", t.style).attr("rx", i / 2).attr("ry", i / 2).attr("x", -r / 2).attr("y", -i / 2).attr("width", r).attr("height", i);
  return N(t, a), t.intersect = function(l) {
    return v.rect(t, l);
  }, s;
}, "stadium"), Fr = /* @__PURE__ */ m$1(async (e, t) => {
  let { shapeSvg: s, bbox: n2, halfPadding: i } = await A(e, t, /* @__PURE__ */ j(t, void 0), true), r = /* @__PURE__ */ s.insert("circle", ":first-child");
  return r.attr("style", t.style).attr("rx", t.rx).attr("ry", t.ry).attr("r", n2.width / 2 + i).attr("width", n2.width + t.padding).attr("height", n2.height + t.padding), tt.info("Circle main"), N(t, r), t.intersect = function(a) {
    return tt.info("Circle intersect", t, n2.width / 2 + i, a), v.circle(t, n2.width / 2 + i, a);
  }, s;
}, "circle"), Wr = /* @__PURE__ */ m$1(async (e, t) => {
  let { shapeSvg: s, bbox: n2, halfPadding: i } = await A(e, t, /* @__PURE__ */ j(t, void 0), true), r = 5, a = /* @__PURE__ */ s.insert("g", ":first-child"), l = /* @__PURE__ */ a.insert("circle"), o = /* @__PURE__ */ a.insert("circle");
  return a.attr("class", t.class), l.attr("style", t.style).attr("rx", t.rx).attr("ry", t.ry).attr("r", n2.width / 2 + i + r).attr("width", n2.width + t.padding + r * 2).attr("height", n2.height + t.padding + r * 2), o.attr("style", t.style).attr("rx", t.rx).attr("ry", t.ry).attr("r", n2.width / 2 + i).attr("width", n2.width + t.padding).attr("height", n2.height + t.padding), tt.info("DoubleCircle main"), N(t, l), t.intersect = function(u) {
    return tt.info("DoubleCircle intersect", t, n2.width / 2 + i + r, u), v.circle(t, n2.width / 2 + i + r, u);
  }, s;
}, "doublecircle"), Pr = /* @__PURE__ */ m$1(async (e, t) => {
  let { shapeSvg: s, bbox: n2 } = await A(e, t, /* @__PURE__ */ j(t, void 0), true), i = n2.width + t.padding, r = n2.height + t.padding, a = [
    {
      x: 0,
      y: 0
    },
    {
      x: i,
      y: 0
    },
    {
      x: i,
      y: -r
    },
    {
      x: 0,
      y: -r
    },
    {
      x: 0,
      y: 0
    },
    {
      x: -8,
      y: 0
    },
    {
      x: i + 8,
      y: 0
    },
    {
      x: i + 8,
      y: -r
    },
    {
      x: -8,
      y: -r
    },
    {
      x: -8,
      y: 0
    }
  ], l = /* @__PURE__ */ U(s, i, r, a);
  return l.attr("style", t.style), N(t, l), t.intersect = function(o) {
    return v.polygon(t, a, o);
  }, s;
}, "subroutine"), Yr = /* @__PURE__ */ m$1((e, t) => {
  let s = /* @__PURE__ */ e.insert("g").attr("class", "node default").attr("id", t.domId || t.id), n2 = /* @__PURE__ */ s.insert("circle", ":first-child");
  return n2.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14), N(t, n2), t.intersect = function(i) {
    return v.circle(t, 7, i);
  }, s;
}, "start"), be = /* @__PURE__ */ m$1((e, t, s) => {
  let n2 = /* @__PURE__ */ e.insert("g").attr("class", "node default").attr("id", t.domId || t.id), i = 70, r = 10;
  s === "LR" && (i = 10, r = 70);
  let a = /* @__PURE__ */ n2.append("rect").attr("x", -1 * i / 2).attr("y", -1 * r / 2).attr("width", i).attr("height", r).attr("class", "fork-join");
  return N(t, a), t.height = t.height + t.padding / 2, t.width = t.width + t.padding / 2, t.intersect = function(l) {
    return v.rect(t, l);
  }, n2;
}, "forkJoin"), Hr = /* @__PURE__ */ m$1((e, t) => {
  let s = /* @__PURE__ */ e.insert("g").attr("class", "node default").attr("id", t.domId || t.id), n2 = /* @__PURE__ */ s.insert("circle", ":first-child"), i = /* @__PURE__ */ s.insert("circle", ":first-child");
  return i.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14), n2.attr("class", "state-end").attr("r", 5).attr("width", 10).attr("height", 10), N(t, i), t.intersect = function(r) {
    return v.circle(t, 7, r);
  }, s;
}, "end"), jr = /* @__PURE__ */ m$1((e, t) => {
  var _a2;
  let s = t.padding / 2, n2 = 4, i = 8, r;
  t.classes ? r = "node " + t.classes : r = "node default";
  let a = /* @__PURE__ */ e.insert("g").attr("class", r).attr("id", t.domId || t.id), l = /* @__PURE__ */ a.insert("rect", ":first-child"), o = /* @__PURE__ */ a.insert("line"), u = /* @__PURE__ */ a.insert("line"), g = 0, x = n2, m2 = /* @__PURE__ */ a.insert("g").attr("class", "label"), b = 0, L = (_a2 = t.classData.annotations) == null ? void 0 : _a2[0], _ = t.classData.annotations[0] ? "«" + t.classData.annotations[0] + "»" : "", S = /* @__PURE__ */ m2.node().appendChild(/* @__PURE__ */ W(_, t.labelStyle, true, true)), I = /* @__PURE__ */ S.getBBox();
  if (uf(Wl().flowchart.htmlLabels)) {
    let E = S.children[0], h = /* @__PURE__ */ rh(S);
    I = /* @__PURE__ */ E.getBoundingClientRect(), h.attr("width", I.width), h.attr("height", I.height);
  }
  t.classData.annotations[0] && (x += I.height + n2, g += I.width);
  let D = t.classData.label;
  t.classData.type !== void 0 && t.classData.type !== "" && (Wl().flowchart.htmlLabels ? D += "&lt;" + t.classData.type + "&gt;" : D += "<" + t.classData.type + ">");
  let T = /* @__PURE__ */ m2.node().appendChild(/* @__PURE__ */ W(D, t.labelStyle, true, true));
  rh(T).attr("class", "classTitle");
  let y = /* @__PURE__ */ T.getBBox();
  if (uf(Wl().flowchart.htmlLabels)) {
    let E = T.children[0], h = /* @__PURE__ */ rh(T);
    y = /* @__PURE__ */ E.getBoundingClientRect(), h.attr("width", y.width), h.attr("height", y.height);
  }
  x += y.height + n2, y.width > g && (g = y.width);
  let d2 = [];
  t.classData.members.forEach((E) => {
    let h = /* @__PURE__ */ E.getDisplayDetails(), Y = h.displayText;
    Wl().flowchart.htmlLabels && (Y = /* @__PURE__ */ Y.replace(/</g, "&lt;").replace(/>/g, "&gt;"));
    let p = /* @__PURE__ */ m2.node().appendChild(/* @__PURE__ */ W(Y, h.cssStyle ? h.cssStyle : t.labelStyle, true, true)), R = /* @__PURE__ */ p.getBBox();
    if (uf(Wl().flowchart.htmlLabels)) {
      let Z = p.children[0], V = /* @__PURE__ */ rh(p);
      R = /* @__PURE__ */ Z.getBoundingClientRect(), V.attr("width", R.width), V.attr("height", R.height);
    }
    R.width > g && (g = R.width), x += R.height + n2, d2.push(p);
  }), x += i;
  let f = [];
  if (t.classData.methods.forEach((E) => {
    let h = /* @__PURE__ */ E.getDisplayDetails(), Y = h.displayText;
    Wl().flowchart.htmlLabels && (Y = /* @__PURE__ */ Y.replace(/</g, "&lt;").replace(/>/g, "&gt;"));
    let p = /* @__PURE__ */ m2.node().appendChild(/* @__PURE__ */ W(Y, h.cssStyle ? h.cssStyle : t.labelStyle, true, true)), R = /* @__PURE__ */ p.getBBox();
    if (uf(Wl().flowchart.htmlLabels)) {
      let Z = p.children[0], V = /* @__PURE__ */ rh(p);
      R = /* @__PURE__ */ Z.getBoundingClientRect(), V.attr("width", R.width), V.attr("height", R.height);
    }
    R.width > g && (g = R.width), x += R.height + n2, f.push(p);
  }), x += i, L) {
    let E = (g - I.width) / 2;
    rh(S).attr("transform", "translate( " + (-1 * g / 2 + E) + ", " + -1 * x / 2 + ")"), b = I.height + n2;
  }
  let w = (g - y.width) / 2;
  return rh(T).attr("transform", "translate( " + (-1 * g / 2 + w) + ", " + (-1 * x / 2 + b) + ")"), b += y.height + n2, o.attr("class", "divider").attr("x1", -g / 2 - s).attr("x2", g / 2 + s).attr("y1", -x / 2 - s + i + b).attr("y2", -x / 2 - s + i + b), b += i, d2.forEach((E) => {
    rh(E).attr("transform", "translate( " + -g / 2 + ", " + (-1 * x / 2 + b + i / 2) + ")");
    let h = E == null ? void 0 : E.getBBox();
    b += ((h == null ? void 0 : h.height) ?? 0) + n2;
  }), b += i, u.attr("class", "divider").attr("x1", -g / 2 - s).attr("x2", g / 2 + s).attr("y1", -x / 2 - s + i + b).attr("y2", -x / 2 - s + i + b), b += i, f.forEach((E) => {
    rh(E).attr("transform", "translate( " + -g / 2 + ", " + (-1 * x / 2 + b) + ")");
    let h = E == null ? void 0 : E.getBBox();
    b += ((h == null ? void 0 : h.height) ?? 0) + n2;
  }), l.attr("style", t.style).attr("class", "outer title-state").attr("x", -g / 2 - s).attr("y", -(x / 2) - s).attr("width", g + t.padding).attr("height", x + t.padding), N(t, l), t.intersect = function(E) {
    return v.rect(t, E);
  }, a;
}, "class_box"), ye = {
  rhombus: xe,
  composite: Rr,
  question: xe,
  rect: Or,
  labelRect: Ar,
  rectWithTitle: zr,
  choice: Sr,
  circle: Fr,
  doublecircle: Wr,
  stadium: Mr,
  hexagon: Er,
  block_arrow: _r,
  rect_left_inv_arrow: Dr,
  lean_right: Br,
  lean_left: vr,
  trapezoid: Tr,
  inv_trapezoid: Cr,
  rect_right_inv_arrow: Nr,
  cylinder: Ir,
  start: Yr,
  end: Hr,
  note: pe,
  subroutine: Pr,
  fork: be,
  join: be,
  class_box: jr
}, gt = {}, _t = /* @__PURE__ */ m$1(async (e, t, s) => {
  let n2, i;
  if (t.link) {
    let r;
    Wl().securityLevel === "sandbox" ? r = "_top" : t.linkTarget && (r = t.linkTarget || "_blank"), n2 = /* @__PURE__ */ e.insert("svg:a").attr("xlink:href", t.link).attr("target", r), i = await ye[t.shape](n2, t, s);
  } else i = await ye[t.shape](e, t, s), n2 = i;
  return t.tooltip && i.attr("title", t.tooltip), t.class && i.attr("class", "node default " + t.class), gt[t.id] = n2, t.haveCallback && gt[t.id].attr("class", gt[t.id].attr("class") + " clickable"), n2;
}, "insertNode");
var me = /* @__PURE__ */ m$1((e) => {
  let t = gt[e.id];
  tt.trace("Transforming node", e.diff, e, "translate(" + (e.x - e.width / 2 - 5) + ", " + e.width / 2 + ")");
  let s = 8, n2 = e.diff || 0;
  return e.clusterNode ? t.attr("transform", "translate(" + (e.x + n2 - e.width / 2) + ", " + (e.y - e.height / 2 - s) + ")") : t.attr("transform", "translate(" + e.x + ", " + e.y + ")"), n2;
}, "positionNode");
function ke(e, t) {
  var _a2, _b2, _c;
  let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  let n2 = e, i = "default";
  (((_a2 = n2 == null ? void 0 : n2.classes) == null ? void 0 : _a2.length) || 0) > 0 && (i = /* @__PURE__ */ ((n2 == null ? void 0 : n2.classes) ?? []).join(" ")), i = i + " flowchart-label";
  let r = 0, a = "", l;
  switch (n2.type) {
    case "round":
      r = 5, a = "rect";
      break;
    case "composite":
      r = 0, a = "composite", l = 0;
      break;
    case "square":
      a = "rect";
      break;
    case "diamond":
      a = "question";
      break;
    case "hexagon":
      a = "hexagon";
      break;
    case "block_arrow":
      a = "block_arrow";
      break;
    case "odd":
      a = "rect_left_inv_arrow";
      break;
    case "lean_right":
      a = "lean_right";
      break;
    case "lean_left":
      a = "lean_left";
      break;
    case "trapezoid":
      a = "trapezoid";
      break;
    case "inv_trapezoid":
      a = "inv_trapezoid";
      break;
    case "rect_left_inv_arrow":
      a = "rect_left_inv_arrow";
      break;
    case "circle":
      a = "circle";
      break;
    case "ellipse":
      a = "ellipse";
      break;
    case "stadium":
      a = "stadium";
      break;
    case "subroutine":
      a = "subroutine";
      break;
    case "cylinder":
      a = "cylinder";
      break;
    case "group":
      a = "rect";
      break;
    case "doublecircle":
      a = "doublecircle";
      break;
    default:
      a = "rect";
  }
  let o = /* @__PURE__ */ be$1((n2 == null ? void 0 : n2.styles) ?? []), u = n2.label, g = n2.size ?? {
    width: 0,
    height: 0,
    x: 0,
    y: 0
  };
  return {
    labelStyle: o.labelStyle,
    shape: a,
    labelText: u,
    rx: r,
    ry: r,
    class: i,
    style: o.style,
    id: n2.id,
    directions: n2.directions,
    width: g.width,
    height: g.height,
    x: g.x,
    y: g.y,
    positioned: s,
    intersect: void 0,
    type: n2.type,
    padding: l ?? ((_c = (_b2 = Er$1()) == null ? void 0 : _b2.block) == null ? void 0 : _c.padding) ?? 0
  };
}
m$1(ke, "getNodeFromBlock");
async function Kr(e, t, s) {
  let n2 = /* @__PURE__ */ ke(t, s, false);
  if (n2.type === "group") return;
  let i = /* @__PURE__ */ Er$1(), r = await _t(e, n2, {
    config: i
  }), a = /* @__PURE__ */ r.node().getBBox(), l = /* @__PURE__ */ s.getBlock(n2.id);
  l.size = {
    width: a.width,
    height: a.height,
    x: 0,
    y: 0,
    node: r
  }, s.setBlock(l), r.remove();
}
m$1(Kr, "calculateBlockSize");
async function Xr(e, t, s) {
  let n2 = /* @__PURE__ */ ke(t, s, true);
  if (s.getBlock(n2.id).type !== "space") {
    let r = /* @__PURE__ */ Er$1();
    await _t(e, n2, {
      config: r
    }), t.intersect = n2 == null ? void 0 : n2.intersect, me(n2);
  }
}
m$1(Xr, "insertBlockPositioned");
async function Dt(e, t, s, n2) {
  for (let i of t) await n2(e, i, s), i.children && await Dt(e, i.children, s, n2);
}
m$1(Dt, "performOperations");
async function we(e, t, s) {
  await Dt(e, t, s, Kr);
}
m$1(we, "calculateBlockSizes");
async function Le(e, t, s) {
  await Dt(e, t, s, Xr);
}
m$1(Le, "insertBlocks");
async function Se(e, t, s, n2, i) {
  let r = new m({
    multigraph: true,
    compound: true
  });
  r.setGraph({
    rankdir: "TB",
    nodesep: 10,
    ranksep: 10,
    marginx: 8,
    marginy: 8
  });
  for (let a of s) a.size && r.setNode(a.id, {
    width: a.size.width,
    height: a.size.height,
    intersect: a.intersect
  });
  for (let a of t) if (a.start && a.end) {
    let l = /* @__PURE__ */ n2.getBlock(a.start), o = /* @__PURE__ */ n2.getBlock(a.end);
    if ((l == null ? void 0 : l.size) && (o == null ? void 0 : o.size)) {
      let u = l.size, g = o.size, x = [
        {
          x: u.x,
          y: u.y
        },
        {
          x: u.x + (g.x - u.x) / 2,
          y: u.y + (g.y - u.y) / 2
        },
        {
          x: g.x,
          y: g.y
        }
      ];
      ne(e, {
        v: a.start,
        w: a.end,
        name: a.id
      }, {
        ...a,
        arrowTypeEnd: a.arrowTypeEnd,
        arrowTypeStart: a.arrowTypeStart,
        points: x,
        classes: "edge-thickness-normal edge-pattern-solid flowchart-link LS-a1 LE-b1"
      }, void 0, "block", r, i), a.label && (await se(e, {
        ...a,
        label: a.label,
        labelStyle: "stroke: #333; stroke-width: 1.5px;fill:none;",
        arrowTypeEnd: a.arrowTypeEnd,
        arrowTypeStart: a.arrowTypeStart,
        points: x,
        classes: "edge-thickness-normal edge-pattern-solid flowchart-link LS-a1 LE-b1"
      }), ie({
        ...a,
        x: x[1].x,
        y: x[1].y
      }, {
        originalPath: x
      }));
    }
  }
}
m$1(Se, "insertEdges");
var Ur = /* @__PURE__ */ m$1(function(e, t) {
  return t.db.getClasses();
}, "getClasses"), Vr = /* @__PURE__ */ m$1(async function(e, t, s, n2) {
  let { securityLevel: i, block: r } = Er$1(), a = n2.db, l;
  i === "sandbox" && (l = /* @__PURE__ */ rh("#i" + t));
  let o = i === "sandbox" ? rh(l.nodes()[0].contentDocument.body) : rh("body"), u = i === "sandbox" ? o.select(`[id="${t}"]`) : rh(`[id="${t}"]`);
  qt(u, [
    "point",
    "circle",
    "cross"
  ], n2.type, t);
  let x = /* @__PURE__ */ a.getBlocks(), m2 = /* @__PURE__ */ a.getBlocksFlat(), b = /* @__PURE__ */ a.getEdges(), L = /* @__PURE__ */ u.insert("g").attr("class", "block");
  await we(L, x, a);
  let _ = /* @__PURE__ */ $t(a);
  if (await Le(L, x, a), await Se(L, b, m2, a, t), _) {
    let S = _, I = /* @__PURE__ */ Math.max(1, /* @__PURE__ */ Math.round(0.125 * (S.width / S.height))), D = S.height + I + 10, T = S.width + 10, { useMaxWidth: y } = r;
    Cf(u, D, T, !!y), tt.debug("Here Bounds", _, S), u.attr("viewBox", `${S.x - 5} ${S.y - 5} ${S.width + 10} ${S.height + 10}`);
  }
}, "draw"), Ee = {
  draw: Vr,
  getClasses: Ur
};
var qs = {
  parser: Ht,
  db: Gt,
  renderer: Ee,
  styles: Zt
};
export {
  qs as diagram
};
