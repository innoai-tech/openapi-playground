let t, e, i, s, n, o;
class r {
  lineAt(t107) {
    if (t107 < 0 || t107 > this.length) throw RangeError(`Invalid position ${t107} in document of length ${this.length}`);
    return this.lineInner(t107, false, 1, 0);
  }
  line(t107) {
    if (t107 < 1 || t107 > this.lines) throw RangeError(`Invalid line number ${t107} in ${this.lines}-line document`);
    return this.lineInner(t107, true, 1, 0);
  }
  replace(t107, e10, i10) {
    [t107, e10] = g(this, t107, e10);
    let s10 = [];
    return this.decompose(0, t107, s10, 2), i10.length && i10.decompose(0, i10.length, s10, 3), this.decompose(e10, this.length, s10, 1), h.from(s10, this.length - (e10 - t107) + i10.length);
  }
  append(t107) {
    return this.replace(this.length, this.length, t107);
  }
  slice(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.length;
    [t107, e10] = g(this, t107, e10);
    let i10 = [];
    return this.decompose(t107, e10, i10, 0), h.from(i10, e10 - t107);
  }
  eq(t107) {
    if (t107 == this) return true;
    if (t107.length != this.length || t107.lines != this.lines) return false;
    let e10 = this.scanIdentical(t107, 1), i10 = this.length - this.scanIdentical(t107, -1), s10 = new c(this), n10 = new c(t107);
    for (let t108 = e10, o10 = e10; ; ) {
      if (s10.next(t108), n10.next(t108), t108 = 0, s10.lineBreak != n10.lineBreak || s10.done != n10.done || s10.value != n10.value) return false;
      if (o10 += s10.value.length, s10.done || o10 >= i10) return true;
    }
  }
  iter() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
    return new c(this, t107);
  }
  iterRange(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.length;
    return new d(this, t107, e10);
  }
  iterLines(t107, e10) {
    let i10;
    if (null == t107) i10 = this.iter();
    else {
      null == e10 && (e10 = this.lines + 1);
      let s10 = this.line(t107).from;
      i10 = this.iterRange(s10, Math.max(s10, e10 == this.lines + 1 ? this.length : e10 <= 1 ? 0 : this.line(e10 - 1).to));
    }
    return new u(i10);
  }
  toString() {
    return this.sliceString(0);
  }
  toJSON() {
    let t107 = [];
    return this.flatten(t107), t107;
  }
  constructor() {
  }
  static of(t107) {
    if (0 == t107.length) throw RangeError("A document must have at least one line");
    return 1 != t107.length || t107[0] ? t107.length <= 32 ? new l(t107) : h.from(l.split(t107, [])) : r.empty;
  }
}
class l extends r {
  constructor(t107, e10 = function(t108) {
    let e11 = -1;
    for (let i10 of t108) e11 += i10.length + 1;
    return e11;
  }(t107)) {
    super(), this.text = t107, this.length = e10;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(t107, e10, i10, s10) {
    for (let n10 = 0; ; n10++) {
      let o10 = this.text[n10], r10 = s10 + o10.length;
      if ((e10 ? i10 : r10) >= t107) return new f(s10, r10, i10, o10);
      s10 = r10 + 1, i10++;
    }
  }
  decompose(t107, e10, i10, s10) {
    let n10 = t107 <= 0 && e10 >= this.length ? this : new l(a(this.text, [""], t107, e10), Math.min(e10, this.length) - Math.max(0, t107));
    if (1 & s10) {
      let t108 = i10.pop(), e11 = a(n10.text, t108.text.slice(), 0, n10.length);
      if (e11.length <= 32) i10.push(new l(e11, t108.length + n10.length));
      else {
        let t109 = e11.length >> 1;
        i10.push(new l(e11.slice(0, t109)), new l(e11.slice(t109)));
      }
    } else i10.push(n10);
  }
  replace(t107, e10, i10) {
    if (!(i10 instanceof l)) return super.replace(t107, e10, i10);
    [t107, e10] = g(this, t107, e10);
    let s10 = a(this.text, a(i10.text, a(this.text, [""], 0, t107)), e10), n10 = this.length + i10.length - (e10 - t107);
    return s10.length <= 32 ? new l(s10, n10) : h.from(l.split(s10, []), n10);
  }
  sliceString(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.length, i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "\n";
    [t107, e10] = g(this, t107, e10);
    let s10 = "";
    for (let n10 = 0, o10 = 0; n10 <= e10 && o10 < this.text.length; o10++) {
      let r10 = this.text[o10], l10 = n10 + r10.length;
      n10 > t107 && o10 && (s10 += i10), t107 < l10 && e10 > n10 && (s10 += r10.slice(Math.max(0, t107 - n10), e10 - n10)), n10 = l10 + 1;
    }
    return s10;
  }
  flatten(t107) {
    for (let e10 of this.text) t107.push(e10);
  }
  scanIdentical() {
    return 0;
  }
  static split(t107, e10) {
    let i10 = [], s10 = -1;
    for (let n10 of t107) i10.push(n10), s10 += n10.length + 1, 32 == i10.length && (e10.push(new l(i10, s10)), i10 = [], s10 = -1);
    return s10 > -1 && e10.push(new l(i10, s10)), e10;
  }
}
class h extends r {
  constructor(t107, e10) {
    for (let i10 of (super(), this.children = t107, this.length = e10, this.lines = 0, t107)) this.lines += i10.lines;
  }
  lineInner(t107, e10, i10, s10) {
    for (let n10 = 0; ; n10++) {
      let o10 = this.children[n10], r10 = s10 + o10.length, l10 = i10 + o10.lines - 1;
      if ((e10 ? l10 : r10) >= t107) return o10.lineInner(t107, e10, i10, s10);
      s10 = r10 + 1, i10 = l10 + 1;
    }
  }
  decompose(t107, e10, i10, s10) {
    for (let n10 = 0, o10 = 0; o10 <= e10 && n10 < this.children.length; n10++) {
      let r10 = this.children[n10], l10 = o10 + r10.length;
      if (t107 <= l10 && e10 >= o10) {
        let n11 = s10 & ((o10 <= t107 ? 1 : 0) | (l10 >= e10 ? 2 : 0));
        o10 >= t107 && l10 <= e10 && !n11 ? i10.push(r10) : r10.decompose(t107 - o10, e10 - o10, i10, n11);
      }
      o10 = l10 + 1;
    }
  }
  replace(t107, e10, i10) {
    if ([t107, e10] = g(this, t107, e10), i10.lines < this.lines) for (let s10 = 0, n10 = 0; s10 < this.children.length; s10++) {
      let o10 = this.children[s10], r10 = n10 + o10.length;
      if (t107 >= n10 && e10 <= r10) {
        let l10 = o10.replace(t107 - n10, e10 - n10, i10), a10 = this.lines - o10.lines + l10.lines;
        if (l10.lines < a10 >> 4 && l10.lines > a10 >> 6) {
          let n11 = this.children.slice();
          return n11[s10] = l10, new h(n11, this.length - (e10 - t107) + i10.length);
        }
        return super.replace(n10, r10, l10);
      }
      n10 = r10 + 1;
    }
    return super.replace(t107, e10, i10);
  }
  sliceString(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.length, i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "\n";
    [t107, e10] = g(this, t107, e10);
    let s10 = "";
    for (let n10 = 0, o10 = 0; n10 < this.children.length && o10 <= e10; n10++) {
      let r10 = this.children[n10], l10 = o10 + r10.length;
      o10 > t107 && n10 && (s10 += i10), t107 < l10 && e10 > o10 && (s10 += r10.sliceString(t107 - o10, e10 - o10, i10)), o10 = l10 + 1;
    }
    return s10;
  }
  flatten(t107) {
    for (let e10 of this.children) e10.flatten(t107);
  }
  scanIdentical(t107, e10) {
    if (!(t107 instanceof h)) return 0;
    let i10 = 0, [s10, n10, o10, r10] = e10 > 0 ? [0, 0, this.children.length, t107.children.length] : [this.children.length - 1, t107.children.length - 1, -1, -1];
    for (; ; s10 += e10, n10 += e10) {
      if (s10 == o10 || n10 == r10) return i10;
      let l10 = this.children[s10], h10 = t107.children[n10];
      if (l10 != h10) return i10 + l10.scanIdentical(h10, e10);
      i10 += l10.length + 1;
    }
  }
  static from(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t107.reduce((t108, e11) => t108 + e11.length + 1, -1), i10 = 0;
    for (let e11 of t107) i10 += e11.lines;
    if (i10 < 32) {
      let i11 = [];
      for (let e11 of t107) e11.flatten(i11);
      return new l(i11, e10);
    }
    let s10 = Math.max(32, i10 >> 5), n10 = s10 << 1, o10 = s10 >> 1, r10 = [], a10 = 0, c10 = -1, d10 = [];
    function u10() {
      0 != a10 && (r10.push(1 == d10.length ? d10[0] : h.from(d10, c10)), c10 = -1, a10 = d10.length = 0);
    }
    for (let e11 of t107) !function t108(e12) {
      let i11;
      if (e12.lines > n10 && e12 instanceof h) for (let i12 of e12.children) t108(i12);
      else e12.lines > o10 && (a10 > o10 || !a10) ? (u10(), r10.push(e12)) : e12 instanceof l && a10 && (i11 = d10[d10.length - 1]) instanceof l && e12.lines + i11.lines <= 32 ? (a10 += e12.lines, c10 += e12.length + 1, d10[d10.length - 1] = new l(i11.text.concat(e12.text), i11.length + 1 + e12.length)) : (a10 + e12.lines > s10 && u10(), a10 += e12.lines, c10 += e12.length + 1, d10.push(e12));
    }(e11);
    return u10(), 1 == r10.length ? r10[0] : new h(r10, e10);
  }
}
function a(t107, e10) {
  let i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, s10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e9;
  for (let n10 = 0, o10 = 0, r10 = true; o10 < t107.length && n10 <= s10; o10++) {
    let l10 = t107[o10], h10 = n10 + l10.length;
    h10 >= i10 && (h10 > s10 && (l10 = l10.slice(0, s10 - n10)), n10 < i10 && (l10 = l10.slice(i10 - n10)), r10 ? (e10[e10.length - 1] += l10, r10 = false) : e10.push(l10)), n10 = h10 + 1;
  }
  return e10;
}
r.empty = new l([""], 0);
class c {
  constructor(t107, e10 = 1) {
    this.dir = e10, this.done = false, this.lineBreak = false, this.value = "", this.nodes = [t107], this.offsets = [e10 > 0 ? 1 : (t107 instanceof l ? t107.text.length : t107.children.length) << 1];
  }
  nextInner(t107, e10) {
    for (this.done = this.lineBreak = false; ; ) {
      let i10 = this.nodes.length - 1, s10 = this.nodes[i10], n10 = this.offsets[i10], o10 = n10 >> 1, r10 = s10 instanceof l ? s10.text.length : s10.children.length;
      if (o10 == (e10 > 0 ? r10 : 0)) {
        if (0 == i10) return this.done = true, this.value = "", this;
        e10 > 0 && this.offsets[i10 - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((1 & n10) == (e10 > 0 ? 0 : 1)) {
        if (this.offsets[i10] += e10, 0 == t107) return this.lineBreak = true, this.value = "\n", this;
        t107--;
      } else if (s10 instanceof l) {
        let n11 = s10.text[o10 + (e10 < 0 ? -1 : 0)];
        if (this.offsets[i10] += e10, n11.length > Math.max(0, t107)) return this.value = 0 == t107 ? n11 : e10 > 0 ? n11.slice(t107) : n11.slice(0, n11.length - t107), this;
        t107 -= n11.length;
      } else {
        let n11 = s10.children[o10 + (e10 < 0 ? -1 : 0)];
        t107 > n11.length ? (t107 -= n11.length, this.offsets[i10] += e10) : (e10 < 0 && this.offsets[i10]--, this.nodes.push(n11), this.offsets.push(e10 > 0 ? 1 : (n11 instanceof l ? n11.text.length : n11.children.length) << 1));
      }
    }
  }
  next() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
    return t107 < 0 && (this.nextInner(-t107, -this.dir), t107 = this.value.length), this.nextInner(t107, this.dir);
  }
}
class d {
  constructor(t107, e10, i10) {
    this.value = "", this.done = false, this.cursor = new c(t107, e10 > i10 ? -1 : 1), this.pos = e10 > i10 ? t107.length : 0, this.from = Math.min(e10, i10), this.to = Math.max(e10, i10);
  }
  nextInner(t107, e10) {
    if (e10 < 0 ? this.pos <= this.from : this.pos >= this.to) return this.value = "", this.done = true, this;
    t107 += Math.max(0, e10 < 0 ? this.pos - this.to : this.from - this.pos);
    let i10 = e10 < 0 ? this.pos - this.from : this.to - this.pos;
    t107 > i10 && (t107 = i10), i10 -= t107;
    let { value: s10 } = this.cursor.next(t107);
    return this.pos += (s10.length + t107) * e10, this.value = s10.length <= i10 ? s10 : e10 < 0 ? s10.slice(s10.length - i10) : s10.slice(0, i10), this.done = !this.value, this;
  }
  next() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
    return t107 < 0 ? t107 = Math.max(t107, this.from - this.pos) : t107 > 0 && (t107 = Math.min(t107, this.to - this.pos)), this.nextInner(t107, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && "" != this.value;
  }
}
class u {
  constructor(t107) {
    this.inner = t107, this.afterBreak = true, this.value = "", this.done = false;
  }
  next() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, { done: e10, lineBreak: i10, value: s10 } = this.inner.next(t107);
    return e10 && this.afterBreak ? (this.value = "", this.afterBreak = false) : e10 ? (this.done = true, this.value = "") : i10 ? this.afterBreak ? this.value = "" : (this.afterBreak = true, this.next()) : (this.value = s10, this.afterBreak = false), this;
  }
  get lineBreak() {
    return false;
  }
}
"undefined" != typeof Symbol && (r.prototype[Symbol.iterator] = function() {
  return this.iter();
}, c.prototype[Symbol.iterator] = d.prototype[Symbol.iterator] = u.prototype[Symbol.iterator] = function() {
  return this;
});
class f {
  constructor(t107, e10, i10, s10) {
    this.from = t107, this.to = e10, this.number = i10, this.text = s10;
  }
  get length() {
    return this.to - this.from;
  }
}
function g(t107, e10, i10) {
  return [e10 = Math.max(0, Math.min(t107.length, e10)), Math.max(e10, Math.min(t107.length, i10))];
}
let p = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((t107) => t107 ? parseInt(t107, 36) : 1);
for (let t107 = 1; t107 < p.length; t107++) p[t107] += p[t107 - 1];
function m(t107) {
  return t107 >= 127462 && t107 <= 127487;
}
function v(t107, e10) {
  let i10 = !(arguments.length > 2) || void 0 === arguments[2] || arguments[2], s10 = !(arguments.length > 3) || void 0 === arguments[3] || arguments[3];
  return (i10 ? w : function(t108, e11, i11) {
    for (; e11 > 0; ) {
      let s11 = w(t108, e11 - 2, i11);
      if (s11 < e11) return s11;
      e11--;
    }
    return 0;
  })(t107, e10, s10);
}
function w(t107, e10, i10) {
  if (e10 == t107.length) return e10;
  e10 && b(t107.charCodeAt(e10)) && y(t107.charCodeAt(e10 - 1)) && e10--;
  let s10 = x(t107, e10);
  for (e10 += k(s10); e10 < t107.length; ) {
    let n10 = x(t107, e10);
    if (8205 == s10 || 8205 == n10 || i10 && function(t108) {
      for (let e11 = 1; e11 < p.length; e11 += 2) if (p[e11] > t108) return p[e11 - 1] <= t108;
      return false;
    }(n10)) e10 += k(n10), s10 = n10;
    else if (m(n10)) {
      let i11 = 0, s11 = e10 - 2;
      for (; s11 >= 0 && m(x(t107, s11)); ) i11++, s11 -= 2;
      if (i11 % 2 == 0) break;
      e10 += 2;
    } else break;
  }
  return e10;
}
function b(t107) {
  return t107 >= 56320 && t107 < 57344;
}
function y(t107) {
  return t107 >= 55296 && t107 < 56320;
}
function x(t107, e10) {
  let i10 = t107.charCodeAt(e10);
  if (!y(i10) || e10 + 1 == t107.length) return i10;
  let s10 = t107.charCodeAt(e10 + 1);
  return b(s10) ? (i10 - 55296 << 10) + (s10 - 56320) + 65536 : i10;
}
function S(t107) {
  return t107 <= 65535 ? String.fromCharCode(t107) : String.fromCharCode(((t107 -= 65536) >> 10) + 55296, (1023 & t107) + 56320);
}
function k(t107) {
  return t107 < 65536 ? 1 : 2;
}
let M = /\r\n?|\n/;
var C, A, D, O, T, E, R, B, L, P, N, V, H, F, W, I, z, K, q, _, G, j = ((q = j || (j = {}))[q.Simple = 0] = "Simple", q[q.TrackDel = 1] = "TrackDel", q[q.TrackBefore = 2] = "TrackBefore", q[q.TrackAfter = 3] = "TrackAfter", q);
class U {
  constructor(t107) {
    this.sections = t107;
  }
  get length() {
    let t107 = 0;
    for (let e10 = 0; e10 < this.sections.length; e10 += 2) t107 += this.sections[e10];
    return t107;
  }
  get newLength() {
    let t107 = 0;
    for (let e10 = 0; e10 < this.sections.length; e10 += 2) {
      let i10 = this.sections[e10 + 1];
      t107 += i10 < 0 ? this.sections[e10] : i10;
    }
    return t107;
  }
  get empty() {
    return 0 == this.sections.length || 2 == this.sections.length && this.sections[1] < 0;
  }
  iterGaps(t107) {
    for (let e10 = 0, i10 = 0, s10 = 0; e10 < this.sections.length; ) {
      let n10 = this.sections[e10++], o10 = this.sections[e10++];
      o10 < 0 ? (t107(i10, s10, n10), s10 += n10) : s10 += o10, i10 += n10;
    }
  }
  iterChangedRanges(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    J(this, t107, e10);
  }
  get invertedDesc() {
    let t107 = [];
    for (let e10 = 0; e10 < this.sections.length; ) {
      let i10 = this.sections[e10++], s10 = this.sections[e10++];
      s10 < 0 ? t107.push(i10, s10) : t107.push(s10, i10);
    }
    return new U(t107);
  }
  composeDesc(t107) {
    return this.empty ? t107 : t107.empty ? this : Z(this, t107);
  }
  mapDesc(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return t107.empty ? this : Q(this, t107, e10);
  }
  mapPos(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1, i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : j.Simple, s10 = 0, n10 = 0;
    for (let o10 = 0; o10 < this.sections.length; ) {
      let r10 = this.sections[o10++], l10 = this.sections[o10++], h10 = s10 + r10;
      if (l10 < 0) {
        if (h10 > t107) return n10 + (t107 - s10);
        n10 += r10;
      } else {
        if (i10 != j.Simple && h10 >= t107 && (i10 == j.TrackDel && s10 < t107 && h10 > t107 || i10 == j.TrackBefore && s10 < t107 || i10 == j.TrackAfter && h10 > t107)) return null;
        if (h10 > t107 || h10 == t107 && e10 < 0 && !r10) return t107 == s10 || e10 < 0 ? n10 : n10 + l10;
        n10 += l10;
      }
      s10 = h10;
    }
    if (t107 > s10) throw RangeError(`Position ${t107} is out of range for changeset of length ${s10}`);
    return n10;
  }
  touchesRange(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t107;
    for (let i10 = 0, s10 = 0; i10 < this.sections.length && s10 <= e10; ) {
      let n10 = this.sections[i10++], o10 = this.sections[i10++], r10 = s10 + n10;
      if (o10 >= 0 && s10 <= e10 && r10 >= t107) return !(s10 < t107) || !(r10 > e10) || "cover";
      s10 = r10;
    }
    return false;
  }
  toString() {
    let t107 = "";
    for (let e10 = 0; e10 < this.sections.length; ) {
      let i10 = this.sections[e10++], s10 = this.sections[e10++];
      t107 += (t107 ? " " : "") + i10 + (s10 >= 0 ? ":" + s10 : "");
    }
    return t107;
  }
  toJSON() {
    return this.sections;
  }
  static fromJSON(t107) {
    if (!Array.isArray(t107) || t107.length % 2 || t107.some((t108) => "number" != typeof t108)) throw RangeError("Invalid JSON representation of ChangeDesc");
    return new U(t107);
  }
  static create(t107) {
    return new U(t107);
  }
}
class Y extends U {
  constructor(t107, e10) {
    super(t107), this.inserted = e10;
  }
  apply(t107) {
    if (this.length != t107.length) throw RangeError("Applying change set to a document with the wrong length");
    return J(this, (e10, i10, s10, n10, o10) => t107 = t107.replace(s10, s10 + (i10 - e10), o10), false), t107;
  }
  mapDesc(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return Q(this, t107, e10, true);
  }
  invert(t107) {
    let e10 = this.sections.slice(), i10 = [];
    for (let s10 = 0, n10 = 0; s10 < e10.length; s10 += 2) {
      let o10 = e10[s10], l10 = e10[s10 + 1];
      if (l10 >= 0) {
        e10[s10] = l10, e10[s10 + 1] = o10;
        let h10 = s10 >> 1;
        for (; i10.length < h10; ) i10.push(r.empty);
        i10.push(o10 ? t107.slice(n10, n10 + o10) : r.empty);
      }
      n10 += o10;
    }
    return new Y(e10, i10);
  }
  compose(t107) {
    return this.empty ? t107 : t107.empty ? this : Z(this, t107, true);
  }
  map(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return t107.empty ? this : Q(this, t107, e10, true);
  }
  iterChanges(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    J(this, t107, e10);
  }
  get desc() {
    return U.create(this.sections);
  }
  filter(t107) {
    let e10 = [], i10 = [], s10 = [], n10 = new tt(this);
    t: for (let o10 = 0, r10 = 0; ; ) {
      let l10 = o10 == t107.length ? 1e9 : t107[o10++];
      for (; r10 < l10 || r10 == l10 && 0 == n10.len; ) {
        if (n10.done) break t;
        let t108 = Math.min(n10.len, l10 - r10);
        $(s10, t108, -1);
        let o11 = -1 == n10.ins ? -1 : 0 == n10.off ? n10.ins : 0;
        $(e10, t108, o11), o11 > 0 && X(i10, e10, n10.text), n10.forward(t108), r10 += t108;
      }
      let h10 = t107[o10++];
      for (; r10 < h10; ) {
        if (n10.done) break t;
        let t108 = Math.min(n10.len, h10 - r10);
        $(e10, t108, -1), $(s10, t108, -1 == n10.ins ? -1 : 0 == n10.off ? n10.ins : 0), n10.forward(t108), r10 += t108;
      }
    }
    return { changes: new Y(e10, i10), filtered: U.create(s10) };
  }
  toJSON() {
    let t107 = [];
    for (let e10 = 0; e10 < this.sections.length; e10 += 2) {
      let i10 = this.sections[e10], s10 = this.sections[e10 + 1];
      s10 < 0 ? t107.push(i10) : 0 == s10 ? t107.push([i10]) : t107.push([i10].concat(this.inserted[e10 >> 1].toJSON()));
    }
    return t107;
  }
  static of(t107, e10, i10) {
    let s10 = [], n10 = [], o10 = 0, l10 = null;
    function h10() {
      let t108 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      if (!t108 && !s10.length) return;
      o10 < e10 && $(s10, e10 - o10, -1);
      let i11 = new Y(s10, n10);
      l10 = l10 ? l10.compose(i11.map(l10)) : i11, s10 = [], n10 = [], o10 = 0;
    }
    return !function t108(a10) {
      if (Array.isArray(a10)) for (let e11 of a10) t108(e11);
      else if (a10 instanceof Y) {
        if (a10.length != e10) throw RangeError(`Mismatched change set length (got ${a10.length}, expected ${e10})`);
        h10(), l10 = l10 ? l10.compose(a10.map(l10)) : a10;
      } else {
        let { from: t109, to: l11 = t109, insert: c10 } = a10;
        if (t109 > l11 || t109 < 0 || l11 > e10) throw RangeError(`Invalid change range ${t109} to ${l11} (in doc of length ${e10})`);
        let d10 = c10 ? "string" == typeof c10 ? r.of(c10.split(i10 || M)) : c10 : r.empty, u10 = d10.length;
        if (t109 == l11 && 0 == u10) return;
        t109 < o10 && h10(), t109 > o10 && $(s10, t109 - o10, -1), $(s10, l11 - t109, u10), X(n10, s10, d10), o10 = l11;
      }
    }(t107), h10(!l10), l10;
  }
  static empty(t107) {
    return new Y(t107 ? [t107, -1] : [], []);
  }
  static fromJSON(t107) {
    if (!Array.isArray(t107)) throw RangeError("Invalid JSON representation of ChangeSet");
    let e10 = [], i10 = [];
    for (let s10 = 0; s10 < t107.length; s10++) {
      let n10 = t107[s10];
      if ("number" == typeof n10) e10.push(n10, -1);
      else if (!Array.isArray(n10) || "number" != typeof n10[0] || n10.some((t108, e11) => e11 && "string" != typeof t108)) throw RangeError("Invalid JSON representation of ChangeSet");
      else if (1 == n10.length) e10.push(n10[0], 0);
      else {
        for (; i10.length < s10; ) i10.push(r.empty);
        i10[s10] = r.of(n10.slice(1)), e10.push(n10[0], i10[s10].length);
      }
    }
    return new Y(e10, i10);
  }
  static createSet(t107, e10) {
    return new Y(t107, e10);
  }
}
function $(t107, e10, i10) {
  let s10 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
  if (0 == e10 && i10 <= 0) return;
  let n10 = t107.length - 2;
  n10 >= 0 && i10 <= 0 && i10 == t107[n10 + 1] ? t107[n10] += e10 : 0 == e10 && 0 == t107[n10] ? t107[n10 + 1] += i10 : s10 ? (t107[n10] += e10, t107[n10 + 1] += i10) : t107.push(e10, i10);
}
function X(t107, e10, i10) {
  if (0 == i10.length) return;
  let s10 = e10.length - 2 >> 1;
  if (s10 < t107.length) t107[t107.length - 1] = t107[t107.length - 1].append(i10);
  else {
    for (; t107.length < s10; ) t107.push(r.empty);
    t107.push(i10);
  }
}
function J(t107, e10, i10) {
  let s10 = t107.inserted;
  for (let n10 = 0, o10 = 0, l10 = 0; l10 < t107.sections.length; ) {
    let h10 = t107.sections[l10++], a10 = t107.sections[l10++];
    if (a10 < 0) n10 += h10, o10 += h10;
    else {
      let c10 = n10, d10 = o10, u10 = r.empty;
      for (; c10 += h10, d10 += a10, a10 && s10 && (u10 = u10.append(s10[l10 - 2 >> 1])), !i10 && l10 != t107.sections.length && !(t107.sections[l10 + 1] < 0); ) h10 = t107.sections[l10++], a10 = t107.sections[l10++];
      e10(n10, c10, o10, d10, u10), n10 = c10, o10 = d10;
    }
  }
}
function Q(t107, e10, i10) {
  let s10 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3], n10 = [], o10 = s10 ? [] : null, r10 = new tt(t107), l10 = new tt(e10);
  for (let t108 = -1; ; ) if (-1 == r10.ins && -1 == l10.ins) {
    let t109 = Math.min(r10.len, l10.len);
    $(n10, t109, -1), r10.forward(t109), l10.forward(t109);
  } else if (l10.ins >= 0 && (r10.ins < 0 || t108 == r10.i || 0 == r10.off && (l10.len < r10.len || l10.len == r10.len && !i10))) {
    let e11 = l10.len;
    for ($(n10, l10.ins, -1); e11; ) {
      let i11 = Math.min(r10.len, e11);
      r10.ins >= 0 && t108 < r10.i && r10.len <= i11 && ($(n10, 0, r10.ins), o10 && X(o10, n10, r10.text), t108 = r10.i), r10.forward(i11), e11 -= i11;
    }
    l10.next();
  } else if (r10.ins >= 0) {
    let e11 = 0, i11 = r10.len;
    for (; i11; ) if (-1 == l10.ins) {
      let t109 = Math.min(i11, l10.len);
      e11 += t109, i11 -= t109, l10.forward(t109);
    } else if (0 == l10.ins && l10.len < i11) i11 -= l10.len, l10.next();
    else break;
    $(n10, e11, t108 < r10.i ? r10.ins : 0), o10 && t108 < r10.i && X(o10, n10, r10.text), t108 = r10.i, r10.forward(r10.len - i11);
  } else if (r10.done && l10.done) return o10 ? Y.createSet(n10, o10) : U.create(n10);
  else throw Error("Mismatched change set lengths");
}
function Z(t107, e10) {
  let i10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], s10 = [], n10 = i10 ? [] : null, o10 = new tt(t107), r10 = new tt(e10);
  for (let t108 = false; ; ) {
    if (o10.done && r10.done) return n10 ? Y.createSet(s10, n10) : U.create(s10);
    if (0 == o10.ins) $(s10, o10.len, 0, t108), o10.next();
    else if (0 != r10.len || r10.done) {
      if (o10.done || r10.done) throw Error("Mismatched change set lengths");
      {
        let e11 = Math.min(o10.len2, r10.len), i11 = s10.length;
        if (-1 == o10.ins) {
          let i12 = -1 == r10.ins ? -1 : r10.off ? 0 : r10.ins;
          $(s10, e11, i12, t108), n10 && i12 && X(n10, s10, r10.text);
        } else -1 == r10.ins ? ($(s10, o10.off ? 0 : o10.len, e11, t108), n10 && X(n10, s10, o10.textBit(e11))) : ($(s10, o10.off ? 0 : o10.len, r10.off ? 0 : r10.ins, t108), n10 && !r10.off && X(n10, s10, r10.text));
        t108 = (o10.ins > e11 || r10.ins >= 0 && r10.len > e11) && (t108 || s10.length > i11), o10.forward2(e11), r10.forward(e11);
      }
    } else $(s10, 0, r10.ins, t108), n10 && X(n10, s10, r10.text), r10.next();
  }
}
class tt {
  constructor(t107) {
    this.set = t107, this.i = 0, this.next();
  }
  next() {
    let { sections: t107 } = this.set;
    this.i < t107.length ? (this.len = t107[this.i++], this.ins = t107[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return -2 == this.ins;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: t107 } = this.set, e10 = this.i - 2 >> 1;
    return e10 >= t107.length ? r.empty : t107[e10];
  }
  textBit(t107) {
    let { inserted: e10 } = this.set, i10 = this.i - 2 >> 1;
    return i10 >= e10.length && !t107 ? r.empty : e10[i10].slice(this.off, null == t107 ? void 0 : this.off + t107);
  }
  forward(t107) {
    t107 == this.len ? this.next() : (this.len -= t107, this.off += t107);
  }
  forward2(t107) {
    -1 == this.ins ? this.forward(t107) : t107 == this.ins ? this.next() : (this.ins -= t107, this.off += t107);
  }
}
class te {
  constructor(t107, e10, i10) {
    this.from = t107, this.to = e10, this.flags = i10;
  }
  get anchor() {
    return 32 & this.flags ? this.to : this.from;
  }
  get head() {
    return 32 & this.flags ? this.from : this.to;
  }
  get empty() {
    return this.from == this.to;
  }
  get assoc() {
    return 8 & this.flags ? -1 : 16 & this.flags ? 1 : 0;
  }
  get bidiLevel() {
    let t107 = 7 & this.flags;
    return 7 == t107 ? null : t107;
  }
  get goalColumn() {
    let t107 = this.flags >> 6;
    return 16777215 == t107 ? void 0 : t107;
  }
  map(t107) {
    let e10, i10, s10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1;
    return this.empty ? e10 = i10 = t107.mapPos(this.from, s10) : (e10 = t107.mapPos(this.from, 1), i10 = t107.mapPos(this.to, -1)), e10 == this.from && i10 == this.to ? this : new te(e10, i10, this.flags);
  }
  extend(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t107;
    if (t107 <= this.anchor && e10 >= this.anchor) return ti.range(t107, e10);
    let i10 = Math.abs(t107 - this.anchor) > Math.abs(e10 - this.anchor) ? t107 : e10;
    return ti.range(this.anchor, i10);
  }
  eq(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return this.anchor == t107.anchor && this.head == t107.head && (!e10 || !this.empty || this.assoc == t107.assoc);
  }
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  static fromJSON(t107) {
    if (!t107 || "number" != typeof t107.anchor || "number" != typeof t107.head) throw RangeError("Invalid JSON representation for SelectionRange");
    return ti.range(t107.anchor, t107.head);
  }
  static create(t107, e10, i10) {
    return new te(t107, e10, i10);
  }
}
class ti {
  constructor(t107, e10) {
    this.ranges = t107, this.mainIndex = e10;
  }
  map(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1;
    return t107.empty ? this : ti.create(this.ranges.map((i10) => i10.map(t107, e10)), this.mainIndex);
  }
  eq(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    if (this.ranges.length != t107.ranges.length || this.mainIndex != t107.mainIndex) return false;
    for (let i10 = 0; i10 < this.ranges.length; i10++) if (!this.ranges[i10].eq(t107.ranges[i10], e10)) return false;
    return true;
  }
  get main() {
    return this.ranges[this.mainIndex];
  }
  asSingle() {
    return 1 == this.ranges.length ? this : new ti([this.main], 0);
  }
  addRange(t107) {
    let e10 = !(arguments.length > 1) || void 0 === arguments[1] || arguments[1];
    return ti.create([t107].concat(this.ranges), e10 ? 0 : this.mainIndex + 1);
  }
  replaceRange(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.mainIndex, i10 = this.ranges.slice();
    return i10[e10] = t107, ti.create(i10, this.mainIndex);
  }
  toJSON() {
    return { ranges: this.ranges.map((t107) => t107.toJSON()), main: this.mainIndex };
  }
  static fromJSON(t107) {
    if (!t107 || !Array.isArray(t107.ranges) || "number" != typeof t107.main || t107.main >= t107.ranges.length) throw RangeError("Invalid JSON representation for EditorSelection");
    return new ti(t107.ranges.map((t108) => te.fromJSON(t108)), t107.main);
  }
  static single(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t107;
    return new ti([ti.range(t107, e10)], 0);
  }
  static create(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    if (0 == t107.length) throw RangeError("A selection needs at least one range");
    for (let i10 = 0, s10 = 0; s10 < t107.length; s10++) {
      let n10 = t107[s10];
      if (n10.empty ? n10.from <= i10 : n10.from < i10) return ti.normalized(t107.slice(), e10);
      i10 = n10.to;
    }
    return new ti(t107, e10);
  }
  static cursor(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i10 = arguments.length > 2 ? arguments[2] : void 0, s10 = arguments.length > 3 ? arguments[3] : void 0;
    return te.create(t107, t107, (0 == e10 ? 0 : e10 < 0 ? 8 : 16) | (null == i10 ? 7 : Math.min(6, i10)) | (null != s10 ? s10 : 16777215) << 6);
  }
  static range(t107, e10, i10, s10) {
    let n10 = (null != i10 ? i10 : 16777215) << 6 | (null == s10 ? 7 : Math.min(6, s10));
    return e10 < t107 ? te.create(e10, t107, 48 | n10) : te.create(t107, e10, (e10 > t107 ? 8 : 0) | n10);
  }
  static normalized(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i10 = t107[e10];
    t107.sort((t108, e11) => t108.from - e11.from), e10 = t107.indexOf(i10);
    for (let i11 = 1; i11 < t107.length; i11++) {
      let s10 = t107[i11], n10 = t107[i11 - 1];
      if (s10.empty ? s10.from <= n10.to : s10.from < n10.to) {
        let o10 = n10.from, r10 = Math.max(s10.to, n10.to);
        i11 <= e10 && e10--, t107.splice(--i11, 2, s10.anchor > s10.head ? ti.range(r10, o10) : ti.range(o10, r10));
      }
    }
    return new ti(t107, e10);
  }
}
function ts(t107, e10) {
  for (let i10 of t107.ranges) if (i10.to > e10) throw RangeError("Selection points outside of document");
}
let tn = 0;
class to {
  constructor(t107, e10, i10, s10, n10) {
    this.combine = t107, this.compareInput = e10, this.compare = i10, this.isStatic = s10, this.id = tn++, this.default = t107([]), this.extensions = "function" == typeof n10 ? n10(this) : n10;
  }
  get reader() {
    return this;
  }
  static define() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    return new to(t107.combine || ((t108) => t108), t107.compareInput || ((t108, e10) => t108 === e10), t107.compare || (t107.combine ? (t108, e10) => t108 === e10 : tr), !!t107.static, t107.enables);
  }
  of(t107) {
    return new tl([], this, 0, t107);
  }
  compute(t107, e10) {
    if (this.isStatic) throw Error("Can't compute a static facet");
    return new tl(t107, this, 1, e10);
  }
  computeN(t107, e10) {
    if (this.isStatic) throw Error("Can't compute a static facet");
    return new tl(t107, this, 2, e10);
  }
  from(t107, e10) {
    return e10 || (e10 = (t108) => t108), this.compute([t107], (i10) => e10(i10.field(t107)));
  }
}
function tr(t107, e10) {
  return t107 == e10 || t107.length == e10.length && t107.every((t108, i10) => t108 === e10[i10]);
}
class tl {
  constructor(t107, e10, i10, s10) {
    this.dependencies = t107, this.facet = e10, this.type = i10, this.value = s10, this.id = tn++;
  }
  dynamicSlot(t107) {
    var e10;
    let i10 = this.value, s10 = this.facet.compareInput, n10 = this.id, o10 = t107[n10] >> 1, r10 = 2 == this.type, l10 = false, h10 = false, a10 = [];
    for (let i11 of this.dependencies) "doc" == i11 ? l10 = true : "selection" == i11 ? h10 = true : ((null !== (e10 = t107[i11.id]) && void 0 !== e10 ? e10 : 1) & 1) == 0 && a10.push(t107[i11.id]);
    return { create: (t108) => (t108.values[o10] = i10(t108), 1), update(t108, e11) {
      if (l10 && e11.docChanged || h10 && (e11.docChanged || e11.selection) || ta(t108, a10)) {
        let e12 = i10(t108);
        if (r10 ? !th(e12, t108.values[o10], s10) : !s10(e12, t108.values[o10])) return t108.values[o10] = e12, 1;
      }
      return 0;
    }, reconfigure: (t108, e11) => {
      let l11, h11 = e11.config.address[n10];
      if (null != h11) {
        let n11 = ty(e11, h11);
        if (this.dependencies.every((i11) => i11 instanceof to ? e11.facet(i11) === t108.facet(i11) : !(i11 instanceof td) || e11.field(i11, false) == t108.field(i11, false)) || (r10 ? th(l11 = i10(t108), n11, s10) : s10(l11 = i10(t108), n11))) return t108.values[o10] = n11, 0;
      } else l11 = i10(t108);
      return t108.values[o10] = l11, 1;
    } };
  }
}
function th(t107, e10, i10) {
  if (t107.length != e10.length) return false;
  for (let s10 = 0; s10 < t107.length; s10++) if (!i10(t107[s10], e10[s10])) return false;
  return true;
}
function ta(t107, e10) {
  let i10 = false;
  for (let s10 of e10) 1 & tb(t107, s10) && (i10 = true);
  return i10;
}
let tc = to.define({ static: true });
class td {
  constructor(t107, e10, i10, s10, n10) {
    this.id = t107, this.createF = e10, this.updateF = i10, this.compareF = s10, this.spec = n10, this.provides = void 0;
  }
  static define(t107) {
    let e10 = new td(tn++, t107.create, t107.update, t107.compare || ((t108, e11) => t108 === e11), t107);
    return t107.provide && (e10.provides = t107.provide(e10)), e10;
  }
  create(t107) {
    let e10 = t107.facet(tc).find((t108) => t108.field == this);
    return ((null == e10 ? void 0 : e10.create) || this.createF)(t107);
  }
  slot(t107) {
    let e10 = t107[this.id] >> 1;
    return { create: (t108) => (t108.values[e10] = this.create(t108), 1), update: (t108, i10) => {
      let s10 = t108.values[e10], n10 = this.updateF(s10, i10);
      return this.compareF(s10, n10) ? 0 : (t108.values[e10] = n10, 1);
    }, reconfigure: (t108, i10) => null != i10.config.address[this.id] ? (t108.values[e10] = i10.field(this), 0) : (t108.values[e10] = this.create(t108), 1) };
  }
  init(t107) {
    return [this, tc.of({ field: this, create: t107 })];
  }
  get extension() {
    return this;
  }
}
let tu = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function tf(t107) {
  return (e10) => new tp(e10, t107);
}
let tg = { highest: tf(tu.highest), high: tf(tu.high), default: tf(tu.default), low: tf(tu.low), lowest: tf(tu.lowest) };
class tp {
  constructor(t107, e10) {
    this.inner = t107, this.prec = e10;
  }
}
class tm {
  of(t107) {
    return new tv(this, t107);
  }
  reconfigure(t107) {
    return tm.reconfigure.of({ compartment: this, extension: t107 });
  }
  get(t107) {
    return t107.config.compartments.get(this);
  }
}
class tv {
  constructor(t107, e10) {
    this.compartment = t107, this.inner = e10;
  }
}
class tw {
  constructor(t107, e10, i10, s10, n10, o10) {
    for (this.base = t107, this.compartments = e10, this.dynamicSlots = i10, this.address = s10, this.staticValues = n10, this.facets = o10, this.statusTemplate = []; this.statusTemplate.length < i10.length; ) this.statusTemplate.push(0);
  }
  staticFacet(t107) {
    let e10 = this.address[t107.id];
    return null == e10 ? t107.default : this.staticValues[e10 >> 1];
  }
  static resolve(t107, e10, i10) {
    let s10, n10, o10 = [], r10 = /* @__PURE__ */ Object.create(null), l10 = /* @__PURE__ */ new Map();
    for (let i11 of (s10 = [[], [], [], [], []], n10 = /* @__PURE__ */ new Map(), !function t108(i12, o11) {
      let r11 = n10.get(i12);
      if (null != r11) {
        if (r11 <= o11) return;
        let t109 = s10[r11].indexOf(i12);
        t109 > -1 && s10[r11].splice(t109, 1), i12 instanceof tv && l10.delete(i12.compartment);
      }
      if (n10.set(i12, o11), Array.isArray(i12)) for (let e11 of i12) t108(e11, o11);
      else if (i12 instanceof tv) {
        if (l10.has(i12.compartment)) throw RangeError("Duplicate use of compartment in extensions");
        let s11 = e10.get(i12.compartment) || i12.inner;
        l10.set(i12.compartment, s11), t108(s11, o11);
      } else if (i12 instanceof tp) t108(i12.inner, i12.prec);
      else if (i12 instanceof td) s10[o11].push(i12), i12.provides && t108(i12.provides, o11);
      else if (i12 instanceof tl) s10[o11].push(i12), i12.facet.extensions && t108(i12.facet.extensions, tu.default);
      else {
        let e11 = i12.extension;
        if (!e11) throw Error(`Unrecognized extension value in extension set (${i12}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
        t108(e11, o11);
      }
    }(t107, tu.default), s10.reduce((t108, e11) => t108.concat(e11)))) i11 instanceof td ? o10.push(i11) : (r10[i11.facet.id] || (r10[i11.facet.id] = [])).push(i11);
    let h10 = /* @__PURE__ */ Object.create(null), a10 = [], c10 = [];
    for (let t108 of o10) h10[t108.id] = c10.length << 1, c10.push((e11) => t108.slot(e11));
    let d10 = null == i10 ? void 0 : i10.config.facets;
    for (let t108 in r10) {
      let e11 = r10[t108], s11 = e11[0].facet, n11 = d10 && d10[t108] || [];
      if (e11.every((t109) => 0 == t109.type)) {
        if (h10[s11.id] = a10.length << 1 | 1, tr(n11, e11)) a10.push(i10.facet(s11));
        else {
          let t109 = s11.combine(e11.map((t110) => t110.value));
          a10.push(i10 && s11.compare(t109, i10.facet(s11)) ? i10.facet(s11) : t109);
        }
      } else {
        for (let t109 of e11) 0 == t109.type ? (h10[t109.id] = a10.length << 1 | 1, a10.push(t109.value)) : (h10[t109.id] = c10.length << 1, c10.push((e12) => t109.dynamicSlot(e12)));
        h10[s11.id] = c10.length << 1, c10.push((t109) => function(t110, e12, i11) {
          let s12 = i11.map((e13) => t110[e13.id]), n12 = i11.map((t111) => t111.type), o11 = s12.filter((t111) => !(1 & t111)), r11 = t110[e12.id] >> 1;
          function l11(t111) {
            let i12 = [];
            for (let e13 = 0; e13 < s12.length; e13++) {
              let o12 = ty(t111, s12[e13]);
              if (2 == n12[e13]) for (let t112 of o12) i12.push(t112);
              else i12.push(o12);
            }
            return e12.combine(i12);
          }
          return { create(t111) {
            for (let e13 of s12) tb(t111, e13);
            return t111.values[r11] = l11(t111), 1;
          }, update(t111, i12) {
            if (!ta(t111, o11)) return 0;
            let s13 = l11(t111);
            return e12.compare(s13, t111.values[r11]) ? 0 : (t111.values[r11] = s13, 1);
          }, reconfigure(t111, n13) {
            let o12 = ta(t111, s12), h11 = n13.config.facets[e12.id], a11 = n13.facet(e12);
            if (h11 && !o12 && tr(i11, h11)) return t111.values[r11] = a11, 0;
            let c11 = l11(t111);
            return e12.compare(c11, a11) ? (t111.values[r11] = a11, 0) : (t111.values[r11] = c11, 1);
          } };
        }(t109, s11, e11));
      }
    }
    return new tw(t107, l10, c10.map((t108) => t108(h10)), h10, a10, r10);
  }
}
function tb(t107, e10) {
  if (1 & e10) return 2;
  let i10 = e10 >> 1, s10 = t107.status[i10];
  if (4 == s10) throw Error("Cyclic dependency between fields and/or facets");
  if (2 & s10) return s10;
  t107.status[i10] = 4;
  let n10 = t107.computeSlot(t107, t107.config.dynamicSlots[i10]);
  return t107.status[i10] = 2 | n10;
}
function ty(t107, e10) {
  return 1 & e10 ? t107.config.staticValues[e10 >> 1] : t107.values[e10 >> 1];
}
let tx = to.define(), tS = to.define({ combine: (t107) => t107.some((t108) => t108), static: true }), tk = to.define({ combine: (t107) => t107.length ? t107[0] : void 0, static: true }), tM = to.define(), tC = to.define(), tA = to.define(), tD = to.define({ combine: (t107) => !!t107.length && t107[0] });
class tO {
  constructor(t107, e10) {
    this.type = t107, this.value = e10;
  }
  static define() {
    return new tT();
  }
}
class tT {
  of(t107) {
    return new tO(this, t107);
  }
}
class tE {
  constructor(t107) {
    this.map = t107;
  }
  of(t107) {
    return new tR(this, t107);
  }
}
class tR {
  constructor(t107, e10) {
    this.type = t107, this.value = e10;
  }
  map(t107) {
    let e10 = this.type.map(this.value, t107);
    return void 0 === e10 ? void 0 : e10 == this.value ? this : new tR(this.type, e10);
  }
  is(t107) {
    return this.type == t107;
  }
  static define() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    return new tE(t107.map || ((t108) => t108));
  }
  static mapEffects(t107, e10) {
    if (!t107.length) return t107;
    let i10 = [];
    for (let s10 of t107) {
      let t108 = s10.map(e10);
      t108 && i10.push(t108);
    }
    return i10;
  }
}
tR.reconfigure = tR.define(), tR.appendConfig = tR.define();
class tB {
  constructor(t107, e10, i10, s10, n10, o10) {
    this.startState = t107, this.changes = e10, this.selection = i10, this.effects = s10, this.annotations = n10, this.scrollIntoView = o10, this._doc = null, this._state = null, i10 && ts(i10, e10.newLength), n10.some((t108) => t108.type == tB.time) || (this.annotations = n10.concat(tB.time.of(Date.now())));
  }
  static create(t107, e10, i10, s10, n10, o10) {
    return new tB(t107, e10, i10, s10, n10, o10);
  }
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  annotation(t107) {
    for (let e10 of this.annotations) if (e10.type == t107) return e10.value;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  isUserEvent(t107) {
    let e10 = this.annotation(tB.userEvent);
    return !!(e10 && (e10 == t107 || e10.length > t107.length && e10.slice(0, t107.length) == t107 && "." == e10[t107.length]));
  }
}
function tL(t107, e10, i10) {
  var s10;
  let n10, o10, r10;
  return i10 ? (n10 = e10.changes, o10 = Y.empty(e10.changes.length), r10 = t107.changes.compose(e10.changes)) : (n10 = e10.changes.map(t107.changes), o10 = t107.changes.mapDesc(e10.changes, true), r10 = t107.changes.compose(n10)), { changes: r10, selection: e10.selection ? e10.selection.map(o10) : null === (s10 = t107.selection) || void 0 === s10 ? void 0 : s10.map(n10), effects: tR.mapEffects(t107.effects, n10).concat(tR.mapEffects(e10.effects, o10)), annotations: t107.annotations.length ? t107.annotations.concat(e10.annotations) : e10.annotations, scrollIntoView: t107.scrollIntoView || e10.scrollIntoView };
}
function tP(t107, e10, i10) {
  let s10 = e10.selection, n10 = tV(e10.annotations);
  return e10.userEvent && (n10 = n10.concat(tB.userEvent.of(e10.userEvent))), { changes: e10.changes instanceof Y ? e10.changes : Y.of(e10.changes || [], i10, t107.facet(tk)), selection: s10 && (s10 instanceof ti ? s10 : ti.single(s10.anchor, s10.head)), effects: tV(e10.effects), annotations: n10, scrollIntoView: !!e10.scrollIntoView };
}
tB.time = tO.define(), tB.userEvent = tO.define(), tB.addToHistory = tO.define(), tB.remote = tO.define();
let tN = [];
function tV(t107) {
  return null == t107 ? tN : Array.isArray(t107) ? t107 : [t107];
}
var tH = ((C = tH || (tH = {}))[C.Word = 0] = "Word", C[C.Space = 1] = "Space", C[C.Other = 2] = "Other", C);
let tF = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
try {
  t = RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch (t107) {
}
class tW {
  constructor(t107, e10, i10, s10, n10, o10) {
    this.config = t107, this.doc = e10, this.selection = i10, this.values = s10, this.status = t107.statusTemplate.slice(), this.computeSlot = n10, o10 && (o10._state = this);
    for (let t108 = 0; t108 < this.config.dynamicSlots.length; t108++) tb(this, t108 << 1);
    this.computeSlot = null;
  }
  field(t107) {
    let e10 = !(arguments.length > 1) || void 0 === arguments[1] || arguments[1], i10 = this.config.address[t107.id];
    if (null == i10) {
      if (e10) throw RangeError("Field is not present in this state");
      return;
    }
    return tb(this, i10), ty(this, i10);
  }
  update() {
    for (var t107 = arguments.length, e10 = Array(t107), i10 = 0; i10 < t107; i10++) e10[i10] = arguments[i10];
    return function t108(e11, i11, s10) {
      let n10 = tP(e11, i11.length ? i11[0] : {}, e11.doc.length);
      i11.length && false === i11[0].filter && (s10 = false);
      for (let t109 = 1; t109 < i11.length; t109++) {
        false === i11[t109].filter && (s10 = false);
        let o11 = !!i11[t109].sequential;
        n10 = tL(n10, tP(e11, i11[t109], o11 ? n10.changes.newLength : e11.doc.length), o11);
      }
      let o10 = tB.create(e11, n10.changes, n10.selection, n10.effects, n10.annotations, n10.scrollIntoView);
      return function(t109) {
        let e12 = t109.startState, i12 = e12.facet(tA), s11 = t109;
        for (let n11 = i12.length - 1; n11 >= 0; n11--) {
          let o11 = i12[n11](t109);
          o11 && Object.keys(o11).length && (s11 = tL(s11, tP(e12, o11, t109.changes.newLength), true));
        }
        return s11 == t109 ? t109 : tB.create(e12, t109.changes, t109.selection, s11.effects, s11.annotations, s11.scrollIntoView);
      }(s10 ? function(e12) {
        let i12 = e12.startState, s11 = true;
        for (let t109 of i12.facet(tM)) {
          let i13 = t109(e12);
          if (false === i13) {
            s11 = false;
            break;
          }
          Array.isArray(i13) && (s11 = true === s11 ? i13 : function(t110, e13) {
            let i14 = [];
            for (let s12 = 0, n12 = 0; ; ) {
              let o11, r10;
              if (s12 < t110.length && (n12 == e13.length || e13[n12] >= t110[s12])) o11 = t110[s12++], r10 = t110[s12++];
              else {
                if (!(n12 < e13.length)) return i14;
                o11 = e13[n12++], r10 = e13[n12++];
              }
              !i14.length || i14[i14.length - 1] < o11 ? i14.push(o11, r10) : i14[i14.length - 1] < r10 && (i14[i14.length - 1] = r10);
            }
          }(s11, i13));
        }
        if (true !== s11) {
          let t109, n12;
          if (false === s11) n12 = e12.changes.invertedDesc, t109 = Y.empty(i12.doc.length);
          else {
            let i13 = e12.changes.filter(s11);
            t109 = i13.changes, n12 = i13.filtered.mapDesc(i13.changes).invertedDesc;
          }
          e12 = tB.create(i12, t109, e12.selection && e12.selection.map(n12), tR.mapEffects(e12.effects, n12), e12.annotations, e12.scrollIntoView);
        }
        let n11 = i12.facet(tC);
        for (let s12 = n11.length - 1; s12 >= 0; s12--) {
          let o11 = n11[s12](e12);
          e12 = o11 instanceof tB ? o11 : Array.isArray(o11) && 1 == o11.length && o11[0] instanceof tB ? o11[0] : t108(i12, tV(o11), false);
        }
        return e12;
      }(o10) : o10);
    }(this, e10, true);
  }
  applyTransaction(t107) {
    let e10, i10 = this.config, { base: s10, compartments: n10 } = i10;
    for (let e11 of t107.effects) e11.is(tm.reconfigure) ? (i10 && (n10 = /* @__PURE__ */ new Map(), i10.compartments.forEach((t108, e12) => n10.set(e12, t108)), i10 = null), n10.set(e11.value.compartment, e11.value.extension)) : e11.is(tR.reconfigure) ? (i10 = null, s10 = e11.value) : e11.is(tR.appendConfig) && (i10 = null, s10 = tV(s10).concat(e11.value));
    e10 = i10 ? t107.startState.values.slice() : new tW(i10 = tw.resolve(s10, n10, this), this.doc, this.selection, i10.dynamicSlots.map(() => null), (t108, e11) => e11.reconfigure(t108, this), null).values;
    let o10 = t107.startState.facet(tS) ? t107.newSelection : t107.newSelection.asSingle();
    new tW(i10, t107.newDoc, o10, e10, (e11, i11) => i11.update(e11, t107), t107);
  }
  replaceSelection(t107) {
    return "string" == typeof t107 && (t107 = this.toText(t107)), this.changeByRange((e10) => ({ changes: { from: e10.from, to: e10.to, insert: t107 }, range: ti.cursor(e10.from + t107.length) }));
  }
  changeByRange(t107) {
    let e10 = this.selection, i10 = t107(e10.ranges[0]), s10 = this.changes(i10.changes), n10 = [i10.range], o10 = tV(i10.effects);
    for (let i11 = 1; i11 < e10.ranges.length; i11++) {
      let r10 = t107(e10.ranges[i11]), l10 = this.changes(r10.changes), h10 = l10.map(s10);
      for (let t108 = 0; t108 < i11; t108++) n10[t108] = n10[t108].map(h10);
      let a10 = s10.mapDesc(l10, true);
      n10.push(r10.range.map(a10)), s10 = s10.compose(h10), o10 = tR.mapEffects(o10, h10).concat(tR.mapEffects(tV(r10.effects), a10));
    }
    return { changes: s10, selection: ti.create(n10, e10.mainIndex), effects: o10 };
  }
  changes() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
    return t107 instanceof Y ? t107 : Y.of(t107, this.doc.length, this.facet(tW.lineSeparator));
  }
  toText(t107) {
    return r.of(t107.split(this.facet(tW.lineSeparator) || M));
  }
  sliceDoc() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.doc.length;
    return this.doc.sliceString(t107, e10, this.lineBreak);
  }
  facet(t107) {
    let e10 = this.config.address[t107.id];
    return null == e10 ? t107.default : (tb(this, e10), ty(this, e10));
  }
  toJSON(t107) {
    let e10 = { doc: this.sliceDoc(), selection: this.selection.toJSON() };
    if (t107) for (let i10 in t107) {
      let s10 = t107[i10];
      s10 instanceof td && null != this.config.address[s10.id] && (e10[i10] = s10.spec.toJSON(this.field(t107[i10]), this));
    }
    return e10;
  }
  static fromJSON(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i10 = arguments.length > 2 ? arguments[2] : void 0;
    if (!t107 || "string" != typeof t107.doc) throw RangeError("Invalid JSON representation for EditorState");
    let s10 = [];
    if (i10) {
      for (let e11 in i10) if (Object.prototype.hasOwnProperty.call(t107, e11)) {
        let n10 = i10[e11], o10 = t107[e11];
        s10.push(n10.init((t108) => n10.spec.fromJSON(o10, t108)));
      }
    }
    return tW.create({ doc: t107.doc, selection: ti.fromJSON(t107.selection), extensions: e10.extensions ? s10.concat([e10.extensions]) : s10 });
  }
  static create() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e10 = tw.resolve(t107.extensions || [], /* @__PURE__ */ new Map()), i10 = t107.doc instanceof r ? t107.doc : r.of((t107.doc || "").split(e10.staticFacet(tW.lineSeparator) || M)), s10 = t107.selection ? t107.selection instanceof ti ? t107.selection : ti.single(t107.selection.anchor, t107.selection.head) : ti.single(0);
    return ts(s10, i10.length), e10.staticFacet(tS) || (s10 = s10.asSingle()), new tW(e10, i10, s10, e10.dynamicSlots.map(() => null), (t108, e11) => e11.create(t108), null);
  }
  get tabSize() {
    return this.facet(tW.tabSize);
  }
  get lineBreak() {
    return this.facet(tW.lineSeparator) || "\n";
  }
  get readOnly() {
    return this.facet(tD);
  }
  phrase(t107) {
    for (var e10 = arguments.length, i10 = Array(e10 > 1 ? e10 - 1 : 0), s10 = 1; s10 < e10; s10++) i10[s10 - 1] = arguments[s10];
    for (let e11 of this.facet(tW.phrases)) if (Object.prototype.hasOwnProperty.call(e11, t107)) {
      t107 = e11[t107];
      break;
    }
    return i10.length && (t107 = t107.replace(/\$(\$|\d*)/g, (t108, e11) => {
      if ("$" == e11) return "$";
      let s11 = +(e11 || 1);
      return !s11 || s11 > i10.length ? t108 : i10[s11 - 1];
    })), t107;
  }
  languageDataAt(t107, e10) {
    let i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -1, s10 = [];
    for (let n10 of this.facet(tx)) for (let o10 of n10(this, e10, i10)) Object.prototype.hasOwnProperty.call(o10, t107) && s10.push(o10[t107]);
    return s10;
  }
  charCategorizer(e10) {
    var i10;
    return i10 = this.languageDataAt("wordChars", e10).join(""), (e11) => {
      if (!/\S/.test(e11)) return tH.Space;
      if (function(e12) {
        if (t) return t.test(e12);
        for (let t107 = 0; t107 < e12.length; t107++) {
          let i11 = e12[t107];
          if (/\w/.test(i11) || i11 > "" && (i11.toUpperCase() != i11.toLowerCase() || tF.test(i11))) return true;
        }
        return false;
      }(e11)) return tH.Word;
      for (let t107 = 0; t107 < i10.length; t107++) if (e11.indexOf(i10[t107]) > -1) return tH.Word;
      return tH.Other;
    };
  }
  wordAt(t107) {
    let { text: e10, from: i10, length: s10 } = this.doc.lineAt(t107), n10 = this.charCategorizer(t107), o10 = t107 - i10, r10 = t107 - i10;
    for (; o10 > 0; ) {
      let t108 = v(e10, o10, false);
      if (n10(e10.slice(t108, o10)) != tH.Word) break;
      o10 = t108;
    }
    for (; r10 < s10; ) {
      let t108 = v(e10, r10);
      if (n10(e10.slice(r10, t108)) != tH.Word) break;
      r10 = t108;
    }
    return o10 == r10 ? null : ti.range(o10 + i10, r10 + i10);
  }
}
function tI(t107, e10) {
  let i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, s10 = {};
  for (let e11 of t107) for (let t108 of Object.keys(e11)) {
    let n10 = e11[t108], o10 = s10[t108];
    if (void 0 === o10) s10[t108] = n10;
    else if (o10 === n10 || void 0 === n10) ;
    else if (Object.hasOwnProperty.call(i10, t108)) s10[t108] = i10[t108](o10, n10);
    else throw Error("Config merge conflict for field " + t108);
  }
  for (let t108 in e10) void 0 === s10[t108] && (s10[t108] = e10[t108]);
  return s10;
}
tW.allowMultipleSelections = tS, tW.tabSize = to.define({ combine: (t107) => t107.length ? t107[0] : 4 }), tW.lineSeparator = tk, tW.readOnly = tD, tW.phrases = to.define({ compare(t107, e10) {
  let i10 = Object.keys(t107), s10 = Object.keys(e10);
  return i10.length == s10.length && i10.every((i11) => t107[i11] == e10[i11]);
} }), tW.languageData = tx, tW.changeFilter = tM, tW.transactionFilter = tC, tW.transactionExtender = tA, tm.reconfigure = tR.define();
class tz {
  eq(t107) {
    return this == t107;
  }
  range(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t107;
    return tK.create(t107, e10, this);
  }
}
tz.prototype.startSide = tz.prototype.endSide = 0, tz.prototype.point = false, tz.prototype.mapMode = j.TrackDel;
let tK = class t2 {
  constructor(t107, e10, i10) {
    this.from = t107, this.to = e10, this.value = i10;
  }
  static create(e10, i10, s10) {
    return new t2(e10, i10, s10);
  }
};
function tq(t107, e10) {
  return t107.from - e10.from || t107.value.startSide - e10.value.startSide;
}
class t_ {
  constructor(t107, e10, i10, s10) {
    this.from = t107, this.to = e10, this.value = i10, this.maxPoint = s10;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  findIndex(t107, e10, i10) {
    let s10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, n10 = i10 ? this.to : this.from;
    for (let o10 = s10, r10 = n10.length; ; ) {
      if (o10 == r10) return o10;
      let s11 = o10 + r10 >> 1, l10 = n10[s11] - t107 || (i10 ? this.value[s11].endSide : this.value[s11].startSide) - e10;
      if (s11 == o10) return l10 >= 0 ? o10 : r10;
      l10 >= 0 ? r10 = s11 : o10 = s11 + 1;
    }
  }
  between(t107, e10, i10, s10) {
    for (let n10 = this.findIndex(e10, -1e9, true), o10 = this.findIndex(i10, 1e9, false, n10); n10 < o10; n10++) if (false === s10(this.from[n10] + t107, this.to[n10] + t107, this.value[n10])) return false;
  }
  map(t107, e10) {
    let i10 = [], s10 = [], n10 = [], o10 = -1, r10 = -1;
    for (let l10 = 0; l10 < this.value.length; l10++) {
      let h10 = this.value[l10], a10 = this.from[l10] + t107, c10 = this.to[l10] + t107, d10, u10;
      if (a10 == c10) {
        let t108 = e10.mapPos(a10, h10.startSide, h10.mapMode);
        if (null == t108 || (d10 = u10 = t108, h10.startSide != h10.endSide && (u10 = e10.mapPos(a10, h10.endSide)) < d10)) continue;
      } else if ((d10 = e10.mapPos(a10, h10.startSide)) > (u10 = e10.mapPos(c10, h10.endSide)) || d10 == u10 && h10.startSide > 0 && h10.endSide <= 0) continue;
      0 > (u10 - d10 || h10.endSide - h10.startSide) || (o10 < 0 && (o10 = d10), h10.point && (r10 = Math.max(r10, u10 - d10)), i10.push(h10), s10.push(d10 - o10), n10.push(u10 - o10));
    }
    return { mapped: i10.length ? new t_(s10, n10, i10, r10) : null, pos: o10 };
  }
}
class tG {
  constructor(t107, e10, i10, s10) {
    this.chunkPos = t107, this.chunk = e10, this.nextLayer = i10, this.maxPoint = s10;
  }
  static create(t107, e10, i10, s10) {
    return new tG(t107, e10, i10, s10);
  }
  get length() {
    let t107 = this.chunk.length - 1;
    return t107 < 0 ? 0 : Math.max(this.chunkEnd(t107), this.nextLayer.length);
  }
  get size() {
    if (this.isEmpty) return 0;
    let t107 = this.nextLayer.size;
    for (let e10 of this.chunk) t107 += e10.value.length;
    return t107;
  }
  chunkEnd(t107) {
    return this.chunkPos[t107] + this.chunk[t107].length;
  }
  update(t107) {
    let { add: e10 = [], sort: i10 = false, filterFrom: s10 = 0, filterTo: n10 = this.length } = t107, o10 = t107.filter;
    if (0 == e10.length && !o10) return this;
    if (i10 && (e10 = e10.slice().sort(tq)), this.isEmpty) return e10.length ? tG.of(e10) : this;
    let r10 = new tY(this, null, -1).goto(0), l10 = 0, h10 = [], a10 = new tj();
    for (; r10.value || l10 < e10.length; ) if (l10 < e10.length && (r10.from - e10[l10].from || r10.startSide - e10[l10].value.startSide) >= 0) {
      let t108 = e10[l10++];
      a10.addInner(t108.from, t108.to, t108.value) || h10.push(t108);
    } else 1 == r10.rangeIndex && r10.chunkIndex < this.chunk.length && (l10 == e10.length || this.chunkEnd(r10.chunkIndex) < e10[l10].from) && (!o10 || s10 > this.chunkEnd(r10.chunkIndex) || n10 < this.chunkPos[r10.chunkIndex]) && a10.addChunk(this.chunkPos[r10.chunkIndex], this.chunk[r10.chunkIndex]) ? r10.nextChunk() : ((!o10 || s10 > r10.to || n10 < r10.from || o10(r10.from, r10.to, r10.value)) && !a10.addInner(r10.from, r10.to, r10.value) && h10.push(tK.create(r10.from, r10.to, r10.value)), r10.next());
    return a10.finishInner(this.nextLayer.isEmpty && !h10.length ? tG.empty : this.nextLayer.update({ add: h10, filter: o10, filterFrom: s10, filterTo: n10 }));
  }
  map(t107) {
    if (t107.empty || this.isEmpty) return this;
    let e10 = [], i10 = [], s10 = -1;
    for (let n11 = 0; n11 < this.chunk.length; n11++) {
      let o10 = this.chunkPos[n11], r10 = this.chunk[n11], l10 = t107.touchesRange(o10, o10 + r10.length);
      if (false === l10) s10 = Math.max(s10, r10.maxPoint), e10.push(r10), i10.push(t107.mapPos(o10));
      else if (true === l10) {
        let { mapped: n12, pos: l11 } = r10.map(o10, t107);
        n12 && (s10 = Math.max(s10, n12.maxPoint), e10.push(n12), i10.push(l11));
      }
    }
    let n10 = this.nextLayer.map(t107);
    return 0 == e10.length ? n10 : new tG(i10, e10, n10 || tG.empty, s10);
  }
  between(t107, e10, i10) {
    if (!this.isEmpty) {
      for (let s10 = 0; s10 < this.chunk.length; s10++) {
        let n10 = this.chunkPos[s10], o10 = this.chunk[s10];
        if (e10 >= n10 && t107 <= n10 + o10.length && false === o10.between(n10, t107 - n10, e10 - n10, i10)) return;
      }
      this.nextLayer.between(t107, e10, i10);
    }
  }
  iter() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
    return t$.from([this]).goto(t107);
  }
  get isEmpty() {
    return this.nextLayer == this;
  }
  static iter(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    return t$.from(t107).goto(e10);
  }
  static compare(t107, e10, i10, s10) {
    let n10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : -1, o10 = t107.filter((t108) => t108.maxPoint > 0 || !t108.isEmpty && t108.maxPoint >= n10), r10 = e10.filter((t108) => t108.maxPoint > 0 || !t108.isEmpty && t108.maxPoint >= n10), l10 = tU(o10, r10, i10), h10 = new tJ(o10, l10, n10), a10 = new tJ(r10, l10, n10);
    i10.iterGaps((t108, e11, i11) => tQ(h10, t108, a10, e11, i11, s10)), i10.empty && 0 == i10.length && tQ(h10, 0, a10, 0, 0, s10);
  }
  static eq(t107, e10) {
    let i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, s10 = arguments.length > 3 ? arguments[3] : void 0;
    null == s10 && (s10 = 999999999);
    let n10 = t107.filter((t108) => !t108.isEmpty && 0 > e10.indexOf(t108)), o10 = e10.filter((e11) => !e11.isEmpty && 0 > t107.indexOf(e11));
    if (n10.length != o10.length) return false;
    if (!n10.length) return true;
    let r10 = tU(n10, o10), l10 = new tJ(n10, r10, 0).goto(i10), h10 = new tJ(o10, r10, 0).goto(i10);
    for (; ; ) {
      if (l10.to != h10.to || !tZ(l10.active, h10.active) || l10.point && (!h10.point || !l10.point.eq(h10.point))) return false;
      if (l10.to > s10) return true;
      l10.next(), h10.next();
    }
  }
  static spans(t107, e10, i10, s10) {
    let n10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : -1, o10 = new tJ(t107, null, n10).goto(e10), r10 = e10, l10 = o10.openStart;
    for (; ; ) {
      let t108 = Math.min(o10.to, i10);
      if (o10.point) {
        let i11 = o10.activeForPoint(o10.to), n11 = o10.pointFrom < e10 ? i11.length + 1 : o10.point.startSide < 0 ? i11.length : Math.min(i11.length, l10);
        s10.point(r10, t108, o10.point, i11, n11, o10.pointRank), l10 = Math.min(o10.openEnd(t108), i11.length);
      } else t108 > r10 && (s10.span(r10, t108, o10.active, l10), l10 = o10.openEnd(t108));
      if (o10.to > i10) return l10 + (o10.point && o10.to > i10 ? 1 : 0);
      r10 = o10.to, o10.next();
    }
  }
  static of(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], i10 = new tj();
    for (let s10 of t107 instanceof tK ? [t107] : e10 ? function(t108) {
      if (t108.length > 1) for (let e11 = t108[0], i11 = 1; i11 < t108.length; i11++) {
        let s11 = t108[i11];
        if (tq(e11, s11) > 0) return t108.slice().sort(tq);
        e11 = s11;
      }
      return t108;
    }(t107) : t107) i10.add(s10.from, s10.to, s10.value);
    return i10.finish();
  }
  static join(t107) {
    if (!t107.length) return tG.empty;
    let e10 = t107[t107.length - 1];
    for (let i10 = t107.length - 2; i10 >= 0; i10--) for (let s10 = t107[i10]; s10 != tG.empty; s10 = s10.nextLayer) e10 = new tG(s10.chunkPos, s10.chunk, e10, Math.max(s10.maxPoint, e10.maxPoint));
    return e10;
  }
}
tG.empty = new tG([], [], null, -1), tG.empty.nextLayer = tG.empty;
class tj {
  finishChunk(t107) {
    this.chunks.push(new t_(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, t107 && (this.from = [], this.to = [], this.value = []);
  }
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  add(t107, e10, i10) {
    this.addInner(t107, e10, i10) || (this.nextLayer || (this.nextLayer = new tj())).add(t107, e10, i10);
  }
  addInner(t107, e10, i10) {
    let s10 = t107 - this.lastTo || i10.startSide - this.last.endSide;
    if (s10 <= 0 && 0 > (t107 - this.lastFrom || i10.startSide - this.last.startSide)) throw Error("Ranges must be added sorted by `from` position and `startSide`");
    return !(s10 < 0) && (250 == this.from.length && this.finishChunk(true), this.chunkStart < 0 && (this.chunkStart = t107), this.from.push(t107 - this.chunkStart), this.to.push(e10 - this.chunkStart), this.last = i10, this.lastFrom = t107, this.lastTo = e10, this.value.push(i10), i10.point && (this.maxPoint = Math.max(this.maxPoint, e10 - t107)), true);
  }
  addChunk(t107, e10) {
    if (0 > (t107 - this.lastTo || e10.value[0].startSide - this.last.endSide)) return false;
    this.from.length && this.finishChunk(true), this.setMaxPoint = Math.max(this.setMaxPoint, e10.maxPoint), this.chunks.push(e10), this.chunkPos.push(t107);
    let i10 = e10.value.length - 1;
    return this.last = e10.value[i10], this.lastFrom = e10.from[i10] + t107, this.lastTo = e10.to[i10] + t107, true;
  }
  finish() {
    return this.finishInner(tG.empty);
  }
  finishInner(t107) {
    if (this.from.length && this.finishChunk(false), 0 == this.chunks.length) return t107;
    let e10 = tG.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(t107) : t107, this.setMaxPoint);
    return this.from = null, e10;
  }
}
function tU(t107, e10, i10) {
  let s10 = /* @__PURE__ */ new Map();
  for (let e11 of t107) for (let t108 = 0; t108 < e11.chunk.length; t108++) e11.chunk[t108].maxPoint <= 0 && s10.set(e11.chunk[t108], e11.chunkPos[t108]);
  let n10 = /* @__PURE__ */ new Set();
  for (let t108 of e10) for (let e11 = 0; e11 < t108.chunk.length; e11++) {
    let o10 = s10.get(t108.chunk[e11]);
    null == o10 || (i10 ? i10.mapPos(o10) : o10) != t108.chunkPos[e11] || (null == i10 ? void 0 : i10.touchesRange(o10, o10 + t108.chunk[e11].length)) || n10.add(t108.chunk[e11]);
  }
  return n10;
}
class tY {
  constructor(t107, e10, i10, s10 = 0) {
    this.layer = t107, this.skip = e10, this.minPoint = i10, this.rank = s10;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1e9;
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(t107, e10, false), this;
  }
  gotoInner(t107, e10, i10) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let e11 = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(e11) || this.layer.chunkEnd(this.chunkIndex) < t107 || e11.maxPoint < this.minPoint)) break;
      this.chunkIndex++, i10 = false;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let s10 = this.layer.chunk[this.chunkIndex].findIndex(t107 - this.layer.chunkPos[this.chunkIndex], e10, true);
      (!i10 || this.rangeIndex < s10) && this.setRangeIndex(s10);
    }
    this.next();
  }
  forward(t107, e10) {
    0 > (this.to - t107 || this.endSide - e10) && this.gotoInner(t107, e10, true);
  }
  next() {
    for (; ; ) {
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      }
      {
        let t107 = this.layer.chunkPos[this.chunkIndex], e10 = this.layer.chunk[this.chunkIndex], i10 = t107 + e10.from[this.rangeIndex];
        if (this.from = i10, this.to = t107 + e10.to[this.rangeIndex], this.value = e10.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint) break;
      }
    }
  }
  setRangeIndex(t107) {
    if (t107 == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip) for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); ) this.chunkIndex++;
      this.rangeIndex = 0;
    } else this.rangeIndex = t107;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(t107) {
    return this.from - t107.from || this.startSide - t107.startSide || this.rank - t107.rank || this.to - t107.to || this.endSide - t107.endSide;
  }
}
class t$ {
  constructor(t107) {
    this.heap = t107;
  }
  static from(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -1, s10 = [];
    for (let n10 = 0; n10 < t107.length; n10++) for (let o10 = t107[n10]; !o10.isEmpty; o10 = o10.nextLayer) o10.maxPoint >= i10 && s10.push(new tY(o10, e10, i10, n10));
    return 1 == s10.length ? s10[0] : new t$(s10);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1e9;
    for (let i10 of this.heap) i10.goto(t107, e10);
    for (let t108 = this.heap.length >> 1; t108 >= 0; t108--) tX(this.heap, t108);
    return this.next(), this;
  }
  forward(t107, e10) {
    for (let i10 of this.heap) i10.forward(t107, e10);
    for (let t108 = this.heap.length >> 1; t108 >= 0; t108--) tX(this.heap, t108);
    0 > (this.to - t107 || this.value.endSide - e10) && this.next();
  }
  next() {
    if (0 == this.heap.length) this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let t107 = this.heap[0];
      this.from = t107.from, this.to = t107.to, this.value = t107.value, this.rank = t107.rank, t107.value && t107.next(), tX(this.heap, 0);
    }
  }
}
function tX(t107, e10) {
  for (let i10 = t107[e10]; ; ) {
    let s10 = (e10 << 1) + 1;
    if (s10 >= t107.length) break;
    let n10 = t107[s10];
    if (s10 + 1 < t107.length && n10.compare(t107[s10 + 1]) >= 0 && (n10 = t107[s10 + 1], s10++), 0 > i10.compare(n10)) break;
    t107[s10] = i10, t107[e10] = n10, e10 = s10;
  }
}
class tJ {
  constructor(t107, e10, i10) {
    this.minPoint = i10, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = t$.from(t107, e10, i10);
  }
  goto(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1e9;
    return this.cursor.goto(t107, e10), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = t107, this.endSide = e10, this.openStart = -1, this.next(), this;
  }
  forward(t107, e10) {
    for (; this.minActive > -1 && 0 > (this.activeTo[this.minActive] - t107 || this.active[this.minActive].endSide - e10); ) this.removeActive(this.minActive);
    this.cursor.forward(t107, e10);
  }
  removeActive(t107) {
    t0(this.active, t107), t0(this.activeTo, t107), t0(this.activeRank, t107), this.minActive = t22(this.active, this.activeTo);
  }
  addActive(t107) {
    let e10 = 0, { value: i10, to: s10, rank: n10 } = this.cursor;
    for (; e10 < this.activeRank.length && (n10 - this.activeRank[e10] || s10 - this.activeTo[e10]) > 0; ) e10++;
    t1(this.active, e10, i10), t1(this.activeTo, e10, s10), t1(this.activeRank, e10, n10), t107 && t1(t107, e10, this.cursor.from), this.minActive = t22(this.active, this.activeTo);
  }
  next() {
    let t107 = this.to, e10 = this.point;
    this.point = null;
    let i10 = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let s10 = this.minActive;
      if (s10 > -1 && 0 > (this.activeTo[s10] - this.cursor.from || this.active[s10].endSide - this.cursor.startSide)) {
        if (this.activeTo[s10] > t107) {
          this.to = this.activeTo[s10], this.endSide = this.active[s10].endSide;
          break;
        }
        this.removeActive(s10), i10 && t0(i10, s10);
      } else if (this.cursor.value) {
        if (this.cursor.from > t107) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        }
        {
          let t108 = this.cursor.value;
          if (t108.point) {
            if (e10 && this.cursor.to == this.to && this.cursor.from < this.cursor.to) this.cursor.next();
            else {
              this.point = t108, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = t108.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
              break;
            }
          } else this.addActive(i10), this.cursor.next();
        }
      } else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (i10) {
      this.openStart = 0;
      for (let e11 = i10.length - 1; e11 >= 0 && i10[e11] < t107; e11--) this.openStart++;
    }
  }
  activeForPoint(t107) {
    if (!this.active.length) return this.active;
    let e10 = [];
    for (let i10 = this.active.length - 1; i10 >= 0 && !(this.activeRank[i10] < this.pointRank); i10--) (this.activeTo[i10] > t107 || this.activeTo[i10] == t107 && this.active[i10].endSide >= this.point.endSide) && e10.push(this.active[i10]);
    return e10.reverse();
  }
  openEnd(t107) {
    let e10 = 0;
    for (let i10 = this.activeTo.length - 1; i10 >= 0 && this.activeTo[i10] > t107; i10--) e10++;
    return e10;
  }
}
function tQ(t107, e10, i10, s10, n10, o10) {
  t107.goto(e10), i10.goto(s10);
  let r10 = s10 + n10, l10 = s10, h10 = s10 - e10;
  for (; ; ) {
    let e11 = t107.to + h10 - i10.to || t107.endSide - i10.endSide, s11 = e11 < 0 ? t107.to + h10 : i10.to, n11 = Math.min(s11, r10);
    if (t107.point || i10.point ? t107.point && i10.point && (t107.point == i10.point || t107.point.eq(i10.point)) && tZ(t107.activeForPoint(t107.to), i10.activeForPoint(i10.to)) || o10.comparePoint(l10, n11, t107.point, i10.point) : n11 > l10 && !tZ(t107.active, i10.active) && o10.compareRange(l10, n11, t107.active, i10.active), s11 > r10) break;
    l10 = s11, e11 <= 0 && t107.next(), e11 >= 0 && i10.next();
  }
}
function tZ(t107, e10) {
  if (t107.length != e10.length) return false;
  for (let i10 = 0; i10 < t107.length; i10++) if (t107[i10] != e10[i10] && !t107[i10].eq(e10[i10])) return false;
  return true;
}
function t0(t107, e10) {
  for (let i10 = e10, s10 = t107.length - 1; i10 < s10; i10++) t107[i10] = t107[i10 + 1];
  t107.pop();
}
function t1(t107, e10, i10) {
  for (let i11 = t107.length - 1; i11 >= e10; i11--) t107[i11 + 1] = t107[i11];
  t107[e10] = i10;
}
function t22(t107, e10) {
  let i10 = -1, s10 = 1e9;
  for (let n10 = 0; n10 < e10.length; n10++) 0 > (e10[n10] - s10 || t107[n10].endSide - t107[i10].endSide) && (i10 = n10, s10 = e10[n10]);
  return i10;
}
function t8(t107, e10) {
  let i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t107.length, s10 = 0;
  for (let n10 = 0; n10 < i10; ) 9 == t107.charCodeAt(n10) ? (s10 += e10 - s10 % e10, n10++) : (s10++, n10 = v(t107, n10));
  return s10;
}
function t3(t107, e10, i10, s10) {
  for (let s11 = 0, n10 = 0; ; ) {
    if (n10 >= e10) return s11;
    if (s11 == t107.length) break;
    n10 += 9 == t107.charCodeAt(s11) ? i10 - n10 % i10 : 1, s11 = v(t107, s11);
  }
  return true === s10 ? -1 : t107.length;
}
let t4 = "undefined" == typeof Symbol ? "__" : Symbol.for(""), t9 = "undefined" == typeof Symbol ? "__styleSet" + Math.floor(1e8 * Math.random()) : Symbol("styleSet"), t5 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : {};
class t6 {
  constructor(t107, e10) {
    this.rules = [];
    let { finish: i10 } = e10 || {};
    function s10(t108) {
      return /^@/.test(t108) ? [t108] : t108.split(/,\s*/);
    }
    for (let e11 in t107) !function t108(e12, n10, o10, r10) {
      let l10 = [], h10 = /^@(\w+)\b/.exec(e12[0]), a10 = h10 && "keyframes" == h10[1];
      if (h10 && null == n10) return o10.push(e12[0] + ";");
      for (let i11 in n10) {
        let r11 = n10[i11];
        if (/&/.test(i11)) t108(i11.split(/,\s*/).map((t109) => e12.map((e13) => t109.replace(/&/, e13))).reduce((t109, e13) => t109.concat(e13)), r11, o10);
        else if (r11 && "object" == typeof r11) {
          if (!h10) throw RangeError("The value of a property (" + i11 + ") should be a primitive value.");
          t108(s10(i11), r11, l10, a10);
        } else null != r11 && l10.push(i11.replace(/_.*/, "").replace(/[A-Z]/g, (t109) => "-" + t109.toLowerCase()) + ": " + r11 + ";");
      }
      (l10.length || a10) && o10.push((!i10 || h10 || r10 ? e12 : e12.map(i10)).join(", ") + " {" + l10.join(" ") + "}");
    }(s10(e11), t107[e11], this.rules);
  }
  getRules() {
    return this.rules.join("\n");
  }
  static newName() {
    let t107 = t5[t4] || 1;
    return t5[t4] = t107 + 1, "" + t107.toString(36);
  }
  static mount(t107, e10, i10) {
    let s10 = t107[t9], n10 = i10 && i10.nonce;
    s10 ? n10 && s10.setNonce(n10) : s10 = new et(t107, n10), s10.mount(Array.isArray(e10) ? e10 : [e10], t107);
  }
}
let t7 = /* @__PURE__ */ new Map();
class et {
  constructor(t107, e10) {
    let i10 = t107.ownerDocument || t107, s10 = i10.defaultView;
    if (!t107.head && t107.adoptedStyleSheets && s10.CSSStyleSheet) {
      let e11 = t7.get(i10);
      if (e11) return t107[t9] = e11;
      this.sheet = new s10.CSSStyleSheet(), t7.set(i10, this);
    } else this.styleTag = i10.createElement("style"), e10 && this.styleTag.setAttribute("nonce", e10);
    this.modules = [], t107[t9] = this;
  }
  mount(t107, e10) {
    let i10 = this.sheet, s10 = 0, n10 = 0;
    for (let e11 = 0; e11 < t107.length; e11++) {
      let o10 = t107[e11], r10 = this.modules.indexOf(o10);
      if (r10 < n10 && r10 > -1 && (this.modules.splice(r10, 1), n10--, r10 = -1), -1 == r10) {
        if (this.modules.splice(n10++, 0, o10), i10) for (let t108 = 0; t108 < o10.rules.length; t108++) i10.insertRule(o10.rules[t108], s10++);
      } else {
        for (; n10 < r10; ) s10 += this.modules[n10++].rules.length;
        s10 += o10.rules.length, n10++;
      }
    }
    if (i10) 0 > e10.adoptedStyleSheets.indexOf(this.sheet) && (e10.adoptedStyleSheets = [this.sheet, ...e10.adoptedStyleSheets]);
    else {
      let t108 = "";
      for (let e11 = 0; e11 < this.modules.length; e11++) t108 += this.modules[e11].getRules() + "\n";
      this.styleTag.textContent = t108;
      let i11 = e10.head || e10;
      this.styleTag.parentNode != i11 && i11.insertBefore(this.styleTag, i11.firstChild);
    }
  }
  setNonce(t107) {
    this.styleTag && this.styleTag.getAttribute("nonce") != t107 && this.styleTag.setAttribute("nonce", t107);
  }
}
for (var ee = { 8: "Backspace", 9: "Tab", 10: "Enter", 12: "NumLock", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 44: "PrintScreen", 45: "Insert", 46: "Delete", 59: ";", 61: "=", 91: "Meta", 92: "Meta", 106: "*", 107: "+", 108: ",", 109: "-", 110: ".", 111: "/", 144: "NumLock", 145: "ScrollLock", 160: "Shift", 161: "Shift", 162: "Control", 163: "Control", 164: "Alt", 165: "Alt", 173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\", 221: "]", 222: "'" }, ei = { 48: ")", 49: "!", 50: "@", 51: "#", 52: "$", 53: "%", 54: "^", 55: "&", 56: "*", 57: "(", 59: ":", 61: "+", 173: "_", 186: ":", 187: "+", 188: "<", 189: "_", 190: ">", 191: "?", 192: "~", 219: "{", 220: "|", 221: "}", 222: '"' }, es = "undefined" != typeof navigator && /Mac/.test(navigator.platform), en = "undefined" != typeof navigator && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent), eo = 0; eo < 10; eo++) ee[48 + eo] = ee[96 + eo] = String(eo);
for (var eo = 1; eo <= 24; eo++) ee[eo + 111] = "F" + eo;
for (var eo = 65; eo <= 90; eo++) ee[eo] = String.fromCharCode(eo + 32), ei[eo] = String.fromCharCode(eo);
for (var er in ee) ei.hasOwnProperty(er) || (ei[er] = ee[er]);
function el(t107) {
  var e10 = !(es && t107.metaKey && t107.shiftKey && !t107.ctrlKey && !t107.altKey || en && t107.shiftKey && t107.key && 1 == t107.key.length || "Unidentified" == t107.key) && t107.key || (t107.shiftKey ? ei : ee)[t107.keyCode] || t107.key || "Unidentified";
  return "Esc" == e10 && (e10 = "Escape"), "Del" == e10 && (e10 = "Delete"), "Left" == e10 && (e10 = "ArrowLeft"), "Up" == e10 && (e10 = "ArrowUp"), "Right" == e10 && (e10 = "ArrowRight"), "Down" == e10 && (e10 = "ArrowDown"), e10;
}
function eh(t107) {
  return (11 == t107.nodeType ? t107.getSelection ? t107 : t107.ownerDocument : t107).getSelection();
}
function ea(t107, e10) {
  return !!e10 && (t107 == e10 || t107.contains(1 != e10.nodeType ? e10.parentNode : e10));
}
function ec(t107, e10) {
  if (!e10.anchorNode) return false;
  try {
    return ea(t107, e10.anchorNode);
  } catch (t108) {
    return false;
  }
}
function ed(t107) {
  return 3 == t107.nodeType ? eS(t107, 0, t107.nodeValue.length).getClientRects() : 1 == t107.nodeType ? t107.getClientRects() : [];
}
function eu(t107, e10, i10, s10) {
  return !!i10 && (ep(t107, e10, i10, s10, -1) || ep(t107, e10, i10, s10, 1));
}
function ef(t107) {
  for (var e10 = 0; ; e10++) if (!(t107 = t107.previousSibling)) return e10;
}
function eg(t107) {
  return 1 == t107.nodeType && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t107.nodeName);
}
function ep(t107, e10, i10, s10, n10) {
  for (; ; ) {
    if (t107 == i10 && e10 == s10) return true;
    if (e10 == (n10 < 0 ? 0 : em(t107))) {
      if ("DIV" == t107.nodeName) return false;
      let i11 = t107.parentNode;
      if (!i11 || 1 != i11.nodeType) return false;
      e10 = ef(t107) + (n10 < 0 ? 0 : 1), t107 = i11;
    } else {
      if (1 != t107.nodeType || 1 == (t107 = t107.childNodes[e10 + (n10 < 0 ? -1 : 0)]).nodeType && "false" == t107.contentEditable) return false;
      e10 = n10 < 0 ? em(t107) : 0;
    }
  }
}
function em(t107) {
  return 3 == t107.nodeType ? t107.nodeValue.length : t107.childNodes.length;
}
function ev(t107, e10) {
  let i10 = e10 ? t107.left : t107.right;
  return { left: i10, right: i10, top: t107.top, bottom: t107.bottom };
}
function ew(t107, e10) {
  let i10 = e10.width / t107.offsetWidth, s10 = e10.height / t107.offsetHeight;
  return (i10 > 0.995 && i10 < 1.005 || !isFinite(i10) || 1 > Math.abs(e10.width - t107.offsetWidth)) && (i10 = 1), (s10 > 0.995 && s10 < 1.005 || !isFinite(s10) || 1 > Math.abs(e10.height - t107.offsetHeight)) && (s10 = 1), { scaleX: i10, scaleY: s10 };
}
let eb = class {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(t107) {
    return this.anchorNode == t107.anchorNode && this.anchorOffset == t107.anchorOffset && this.focusNode == t107.focusNode && this.focusOffset == t107.focusOffset;
  }
  setRange(t107) {
    let { anchorNode: e10, focusNode: i10 } = t107;
    this.set(e10, Math.min(t107.anchorOffset, e10 ? em(e10) : 0), i10, Math.min(t107.focusOffset, i10 ? em(i10) : 0));
  }
  set(t107, e10, i10, s10) {
    this.anchorNode = t107, this.anchorOffset = e10, this.focusNode = i10, this.focusOffset = s10;
  }
}, ey = null;
function ex(t107) {
  if (t107.setActive) return t107.setActive();
  if (ey) return t107.focus(ey);
  let e10 = [];
  for (let i10 = t107; i10 && (e10.push(i10, i10.scrollTop, i10.scrollLeft), i10 != i10.ownerDocument); i10 = i10.parentNode) ;
  if (t107.focus(null == ey ? { get preventScroll() {
    return ey = { preventScroll: true }, true;
  } } : void 0), !ey) {
    ey = false;
    for (let t108 = 0; t108 < e10.length; ) {
      let i10 = e10[t108++], s10 = e10[t108++], n10 = e10[t108++];
      i10.scrollTop != s10 && (i10.scrollTop = s10), i10.scrollLeft != n10 && (i10.scrollLeft = n10);
    }
  }
}
function eS(t107, i10) {
  let s10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : i10, n10 = e || (e = document.createRange());
  return n10.setEnd(t107, s10), n10.setStart(t107, i10), n10;
}
function ek(t107, e10, i10, s10) {
  let n10 = { key: e10, code: e10, keyCode: i10, which: i10, cancelable: true };
  s10 && ({ altKey: n10.altKey, ctrlKey: n10.ctrlKey, shiftKey: n10.shiftKey, metaKey: n10.metaKey } = s10);
  let o10 = new KeyboardEvent("keydown", n10);
  o10.synthetic = true, t107.dispatchEvent(o10);
  let r10 = new KeyboardEvent("keyup", n10);
  return r10.synthetic = true, t107.dispatchEvent(r10), o10.defaultPrevented || r10.defaultPrevented;
}
function eM(t107) {
  for (; t107.attributes.length; ) t107.removeAttributeNode(t107.attributes[0]);
}
function eC(t107) {
  return t107.scrollTop > Math.max(1, t107.scrollHeight - t107.clientHeight - 4);
}
function eA(t107, e10) {
  for (let i10 = t107, s10 = e10; ; ) {
    if (3 == i10.nodeType && s10 > 0) return { node: i10, offset: s10 };
    if (1 == i10.nodeType && s10 > 0) {
      if ("false" == i10.contentEditable) return null;
      s10 = em(i10 = i10.childNodes[s10 - 1]);
    } else {
      if (!i10.parentNode || eg(i10)) return null;
      s10 = ef(i10), i10 = i10.parentNode;
    }
  }
}
function eD(t107, e10) {
  for (let i10 = t107, s10 = e10; ; ) {
    if (3 == i10.nodeType && s10 < i10.nodeValue.length) return { node: i10, offset: s10 };
    if (1 == i10.nodeType && s10 < i10.childNodes.length) {
      if ("false" == i10.contentEditable) return null;
      i10 = i10.childNodes[s10], s10 = 0;
    } else {
      if (!i10.parentNode || eg(i10)) return null;
      s10 = ef(i10) + 1, i10 = i10.parentNode;
    }
  }
}
let eO = class t10 {
  constructor(t107, e10, i10 = true) {
    this.node = t107, this.offset = e10, this.precise = i10;
  }
  static before(e10, i10) {
    return new t10(e10.parentNode, ef(e10), i10);
  }
  static after(e10, i10) {
    return new t10(e10.parentNode, ef(e10) + 1, i10);
  }
}, eT = [], eE = class t11 {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(t107) {
    let e10 = this.posAtStart;
    for (let i10 of this.children) {
      if (i10 == t107) return e10;
      e10 += i10.length + i10.breakAfter;
    }
    throw RangeError("Invalid child in posBefore");
  }
  posAfter(t107) {
    return this.posBefore(t107) + t107.length;
  }
  sync(e10, i10) {
    if (2 & this.flags) {
      let s10 = this.dom, n10 = null, o10;
      for (let r10 of this.children) {
        if (7 & r10.flags) {
          if (!r10.dom && (o10 = n10 ? n10.nextSibling : s10.firstChild)) {
            let e11 = t11.get(o10);
            (!e11 || !e11.parent && e11.canReuseDOM(r10)) && r10.reuseDOM(o10);
          }
          r10.sync(e10, i10), r10.flags &= -8;
        }
        if (o10 = n10 ? n10.nextSibling : s10.firstChild, i10 && !i10.written && i10.node == s10 && o10 != r10.dom && (i10.written = true), r10.dom.parentNode == s10) for (; o10 && o10 != r10.dom; ) o10 = eR(o10);
        else s10.insertBefore(r10.dom, o10);
        n10 = r10.dom;
      }
      for ((o10 = n10 ? n10.nextSibling : s10.firstChild) && i10 && i10.node == s10 && (i10.written = true); o10; ) o10 = eR(o10);
    } else if (1 & this.flags) for (let t107 of this.children) 7 & t107.flags && (t107.sync(e10, i10), t107.flags &= -8);
  }
  reuseDOM(t107) {
  }
  localPosFromDOM(e10, i10) {
    let s10;
    if (e10 == this.dom) s10 = this.dom.childNodes[i10];
    else {
      let t107 = 0 == em(e10) ? 0 : 0 == i10 ? -1 : 1;
      for (; ; ) {
        let i11 = e10.parentNode;
        if (i11 == this.dom) break;
        0 == t107 && i11.firstChild != i11.lastChild && (t107 = e10 == i11.firstChild ? -1 : 1), e10 = i11;
      }
      s10 = t107 < 0 ? e10 : e10.nextSibling;
    }
    if (s10 == this.dom.firstChild) return 0;
    for (; s10 && !t11.get(s10); ) s10 = s10.nextSibling;
    if (!s10) return this.length;
    for (let t107 = 0, e11 = 0; ; t107++) {
      let i11 = this.children[t107];
      if (i11.dom == s10) return e11;
      e11 += i11.length + i11.breakAfter;
    }
  }
  domBoundsAround(t107, e10) {
    let i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, s10 = -1, n10 = -1, o10 = -1, r10 = -1;
    for (let l10 = 0, h10 = i10, a10 = i10; l10 < this.children.length; l10++) {
      let i11 = this.children[l10], c10 = h10 + i11.length;
      if (h10 < t107 && c10 > e10) return i11.domBoundsAround(t107, e10, h10);
      if (c10 >= t107 && -1 == s10 && (s10 = l10, n10 = h10), h10 > e10 && i11.dom.parentNode == this.dom) {
        o10 = l10, r10 = a10;
        break;
      }
      a10 = c10, h10 = c10 + i11.breakAfter;
    }
    return { from: n10, to: r10 < 0 ? i10 + this.length : r10, startDOM: (s10 ? this.children[s10 - 1].dom.nextSibling : null) || this.dom.firstChild, endDOM: o10 < this.children.length && o10 >= 0 ? this.children[o10].dom : null };
  }
  markDirty() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
    this.flags |= 2, this.markParentsDirty(t107);
  }
  markParentsDirty(t107) {
    for (let e10 = this.parent; e10; e10 = e10.parent) {
      if (t107 && (e10.flags |= 2), 1 & e10.flags) return;
      e10.flags |= 1, t107 = false;
    }
  }
  setParent(t107) {
    this.parent != t107 && (this.parent = t107, 7 & this.flags && this.markParentsDirty(true));
  }
  setDOM(t107) {
    this.dom != t107 && (this.dom && (this.dom.cmView = null), this.dom = t107, t107.cmView = this);
  }
  get rootView() {
    for (let t107 = this; ; ) {
      let e10 = t107.parent;
      if (!e10) return t107;
      t107 = e10;
    }
  }
  replaceChildren(t107, e10) {
    let i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : eT;
    this.markDirty();
    for (let s10 = t107; s10 < e10; s10++) {
      let t108 = this.children[s10];
      t108.parent == this && 0 > i10.indexOf(t108) && t108.destroy();
    }
    this.children.splice(t107, e10 - t107, ...i10);
    for (let t108 = 0; t108 < i10.length; t108++) i10[t108].setParent(this);
  }
  ignoreMutation(t107) {
    return false;
  }
  ignoreEvent(t107) {
    return false;
  }
  childCursor() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.length;
    return new eB(this.children, t107, this.children.length);
  }
  childPos(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
    return this.childCursor().findPos(t107, e10);
  }
  toString() {
    let t107 = this.constructor.name.replace("View", "");
    return t107 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + ("Text" == t107 ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(t107) {
    return t107.cmView;
  }
  get isEditable() {
    return true;
  }
  get isWidget() {
    return false;
  }
  get isHidden() {
    return false;
  }
  merge(t107, e10, i10, s10, n10, o10) {
    return false;
  }
  become(t107) {
    return false;
  }
  canReuseDOM(t107) {
    return t107.constructor == this.constructor && !((this.flags | t107.flags) & 8);
  }
  getSide() {
    return 0;
  }
  destroy() {
    for (let t107 of this.children) t107.parent == this && t107.destroy();
    this.parent = null;
  }
};
function eR(t107) {
  let e10 = t107.nextSibling;
  return t107.parentNode.removeChild(t107), e10;
}
eE.prototype.breakAfter = 0;
let eB = class {
  constructor(t107, e10, i10) {
    this.children = t107, this.pos = e10, this.i = i10, this.off = 0;
  }
  findPos(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
    for (; ; ) {
      if (t107 > this.pos || t107 == this.pos && (e10 > 0 || 0 == this.i || this.children[this.i - 1].breakAfter)) return this.off = t107 - this.pos, this;
      let i10 = this.children[--this.i];
      this.pos -= i10.length + i10.breakAfter;
    }
  }
};
function eL(t107, e10, i10, s10, n10, o10, r10, l10, h10) {
  let { children: a10 } = t107, c10 = a10.length ? a10[e10] : null, d10 = o10.length ? o10[o10.length - 1] : null, u10 = d10 ? d10.breakAfter : r10;
  if (!(e10 == s10 && c10 && !r10 && !u10 && o10.length < 2 && c10.merge(i10, n10, o10.length ? d10 : null, 0 == i10, l10, h10))) {
    if (s10 < a10.length) {
      let t108 = a10[s10];
      t108 && (n10 < t108.length || t108.breakAfter && (null == d10 ? void 0 : d10.breakAfter)) ? (e10 == s10 && (t108 = t108.split(n10), n10 = 0), !u10 && d10 && t108.merge(0, n10, d10, true, 0, h10) ? o10[o10.length - 1] = t108 : ((n10 || t108.children.length && !t108.children[0].length) && t108.merge(0, n10, null, false, 0, h10), o10.push(t108))) : (null == t108 ? void 0 : t108.breakAfter) && (d10 ? d10.breakAfter = 1 : r10 = 1), s10++;
    }
    for (c10 && (c10.breakAfter = r10, i10 > 0 && (!r10 && o10.length && c10.merge(i10, c10.length, o10[0], false, l10, 0) ? c10.breakAfter = o10.shift().breakAfter : (i10 < c10.length || c10.children.length && 0 == c10.children[c10.children.length - 1].length) && c10.merge(i10, c10.length, null, false, l10, 0), e10++)); e10 < s10 && o10.length; ) if (a10[s10 - 1].become(o10[o10.length - 1])) s10--, o10.pop(), h10 = o10.length ? 0 : l10;
    else if (a10[e10].become(o10[0])) e10++, o10.shift(), l10 = o10.length ? 0 : h10;
    else break;
    !o10.length && e10 && s10 < a10.length && !a10[e10 - 1].breakAfter && a10[s10].merge(0, 0, a10[e10 - 1], false, l10, h10) && e10--, (e10 < s10 || o10.length) && t107.replaceChildren(e10, s10, o10);
  }
}
function eP(t107, e10, i10, s10, n10, o10) {
  let r10 = t107.childCursor(), { i: l10, off: h10 } = r10.findPos(i10, 1), { i: a10, off: c10 } = r10.findPos(e10, -1), d10 = e10 - i10;
  for (let t108 of s10) d10 += t108.length;
  t107.length += d10, eL(t107, a10, c10, l10, h10, s10, 0, n10, o10);
}
let eN = "undefined" != typeof navigator ? navigator : { userAgent: "", vendor: "", platform: "" }, eV = "undefined" != typeof document ? document : { documentElement: { style: {} } }, eH = /Edge\/(\d+)/.exec(eN.userAgent), eF = /MSIE \d/.test(eN.userAgent), eW = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(eN.userAgent), eI = !!(eF || eW || eH), ez = !eI && /gecko\/(\d+)/i.test(eN.userAgent), eK = !eI && /Chrome\/(\d+)/.exec(eN.userAgent), eq = "webkitFontSmoothing" in eV.documentElement.style, e_ = !eI && /Apple Computer/.test(eN.vendor), eG = e_ && (/Mobile\/\w+/.test(eN.userAgent) || eN.maxTouchPoints > 2);
var ej = { mac: eG || /Mac/.test(eN.platform), windows: /Win/.test(eN.platform), linux: /Linux|X11/.test(eN.platform), ie: eI, ie_version: eF ? eV.documentMode || 6 : eW ? +eW[1] : eH ? +eH[1] : 0, gecko: ez, gecko_version: ez ? +(/Firefox\/(\d+)/.exec(eN.userAgent) || [0, 0])[1] : 0, chrome: !!eK, chrome_version: eK ? +eK[1] : 0, ios: eG, android: /Android\b/.test(eN.userAgent), webkit: eq, safari: e_, webkit_version: eq ? +(/\bAppleWebKit\/(\d+)/.exec(eN.userAgent) || [0, 0])[1] : 0, tabSize: null != eV.documentElement.style.tabSize ? "tab-size" : "-moz-tab-size" };
let eU = class t12 extends eE {
  constructor(t107) {
    super(), this.text = t107;
  }
  get length() {
    return this.text.length;
  }
  createDOM(t107) {
    this.setDOM(t107 || document.createTextNode(this.text));
  }
  sync(t107, e10) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (e10 && e10.node == this.dom && (e10.written = true), this.dom.nodeValue = this.text);
  }
  reuseDOM(t107) {
    3 == t107.nodeType && this.createDOM(t107);
  }
  merge(e10, i10, s10) {
    return !(8 & this.flags) && (!s10 || s10 instanceof t12 && !(this.length - (i10 - e10) + s10.length > 256) && !(8 & s10.flags)) && (this.text = this.text.slice(0, e10) + (s10 ? s10.text : "") + this.text.slice(i10), this.markDirty(), true);
  }
  split(e10) {
    let i10 = new t12(this.text.slice(e10));
    return this.text = this.text.slice(0, e10), this.markDirty(), i10.flags |= 8 & this.flags, i10;
  }
  localPosFromDOM(t107, e10) {
    return t107 == this.dom ? e10 : e10 ? this.text.length : 0;
  }
  domAtPos(t107) {
    return new eO(this.dom, t107);
  }
  domBoundsAround(t107, e10, i10) {
    return { from: i10, to: i10 + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(t107, e10) {
    return function(t108, e11, i10) {
      let s10 = t108.nodeValue.length;
      e11 > s10 && (e11 = s10);
      let n10 = e11, o10 = e11, r10 = 0;
      0 == e11 && i10 < 0 || e11 == s10 && i10 >= 0 ? !(ej.chrome || ej.gecko) && (e11 ? (n10--, r10 = 1) : o10 < s10 && (o10++, r10 = -1)) : i10 < 0 ? n10-- : o10 < s10 && o10++;
      let l10 = eS(t108, n10, o10).getClientRects();
      if (!l10.length) return null;
      let h10 = l10[(r10 ? r10 < 0 : i10 >= 0) ? 0 : l10.length - 1];
      return ej.safari && !r10 && 0 == h10.width && (h10 = Array.prototype.find.call(l10, (t109) => t109.width) || h10), r10 ? ev(h10, r10 < 0) : h10 || null;
    }(this.dom, t107, e10);
  }
}, eY = class t13 extends eE {
  constructor(t107, e10 = [], i10 = 0) {
    for (let s10 of (super(), this.mark = t107, this.children = e10, this.length = i10, e10)) s10.setParent(this);
  }
  setAttrs(t107) {
    if (eM(t107), this.mark.class && (t107.className = this.mark.class), this.mark.attrs) for (let e10 in this.mark.attrs) t107.setAttribute(e10, this.mark.attrs[e10]);
    return t107;
  }
  canReuseDOM(t107) {
    return super.canReuseDOM(t107) && !((this.flags | t107.flags) & 8);
  }
  reuseDOM(t107) {
    t107.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(t107), this.flags |= 6);
  }
  sync(t107, e10) {
    this.dom ? 4 & this.flags && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(t107, e10);
  }
  merge(e10, i10, s10, n10, o10, r10) {
    return (!s10 || !!(s10 instanceof t13 && s10.mark.eq(this.mark)) && (!e10 || !(o10 <= 0)) && (!(i10 < this.length) || !(r10 <= 0))) && (eP(this, e10, i10, s10 ? s10.children.slice() : [], o10 - 1, r10 - 1), this.markDirty(), true);
  }
  split(e10) {
    let i10 = [], s10 = 0, n10 = -1, o10 = 0;
    for (let t107 of this.children) {
      let r11 = s10 + t107.length;
      r11 > e10 && i10.push(s10 < e10 ? t107.split(e10 - s10) : t107), n10 < 0 && s10 >= e10 && (n10 = o10), s10 = r11, o10++;
    }
    let r10 = this.length - e10;
    return this.length = e10, n10 > -1 && (this.children.length = n10, this.markDirty()), new t13(this.mark, i10, r10);
  }
  domAtPos(t107) {
    return eJ(this, t107);
  }
  coordsAt(t107, e10) {
    return eQ(this, t107, e10);
  }
}, e$ = class t14 extends eE {
  static create(e10, i10, s10) {
    return new t14(e10, i10, s10);
  }
  constructor(t107, e10, i10) {
    super(), this.widget = t107, this.length = e10, this.side = i10, this.prevWidget = null;
  }
  split(e10) {
    let i10 = t14.create(this.widget, this.length - e10, this.side);
    return this.length -= e10, i10;
  }
  sync(t107) {
    this.dom && this.widget.updateDOM(this.dom, t107) || (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t107)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e10, i10, s10, n10, o10, r10) {
    return (!s10 || s10 instanceof t14 && !!this.widget.compare(s10.widget) && (!(e10 > 0) || !(o10 <= 0)) && (!(i10 < this.length) || !(r10 <= 0))) && (this.length = e10 + (s10 ? s10.length : 0) + (this.length - i10), true);
  }
  become(e10) {
    return e10 instanceof t14 && e10.side == this.side && this.widget.constructor == e10.widget.constructor && (this.widget.compare(e10.widget) || this.markDirty(true), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e10.widget, this.length = e10.length, true);
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(t107) {
    return this.widget.ignoreEvent(t107);
  }
  get overrideDOMText() {
    if (0 == this.length) return r.empty;
    let t107 = this;
    for (; t107.parent; ) t107 = t107.parent;
    let { view: e10 } = t107, i10 = e10 && e10.state.doc, s10 = this.posAtStart;
    return i10 ? i10.slice(s10, s10 + this.length) : r.empty;
  }
  domAtPos(t107) {
    return (this.length ? 0 == t107 : this.side > 0) ? eO.before(this.dom) : eO.after(this.dom, t107 == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(t107, e10) {
    let i10 = this.widget.coordsAt(this.dom, t107, e10);
    if (i10) return i10;
    let s10 = this.dom.getClientRects(), n10 = null;
    if (!s10.length) return null;
    let o10 = this.side ? this.side < 0 : t107 > 0;
    for (let e11 = o10 ? s10.length - 1 : 0; n10 = s10[e11], t107 > 0 ? 0 != e11 : e11 != s10.length - 1 && !(n10.top < n10.bottom); e11 += o10 ? -1 : 1) ;
    return ev(n10, !o10);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}, eX = class t15 extends eE {
  constructor(t107) {
    super(), this.side = t107;
  }
  get length() {
    return 0;
  }
  merge() {
    return false;
  }
  become(e10) {
    return e10 instanceof t15 && e10.side == this.side;
  }
  split() {
    return new t15(this.side);
  }
  sync() {
    if (!this.dom) {
      let t107 = document.createElement("img");
      t107.className = "cm-widgetBuffer", t107.setAttribute("aria-hidden", "true"), this.setDOM(t107);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(t107) {
    return this.side > 0 ? eO.before(this.dom) : eO.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(t107) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return r.empty;
  }
  get isHidden() {
    return true;
  }
};
function eJ(t107, e10) {
  let i10 = t107.dom, { children: s10 } = t107, n10 = 0;
  for (let t108 = 0; n10 < s10.length; n10++) {
    let o10 = s10[n10], r10 = t108 + o10.length;
    if (!(r10 == t108 && 0 >= o10.getSide())) {
      if (e10 > t108 && e10 < r10 && o10.dom.parentNode == i10) return o10.domAtPos(e10 - t108);
      if (e10 <= t108) break;
      t108 = r10;
    }
  }
  for (let t108 = n10; t108 > 0; t108--) {
    let e11 = s10[t108 - 1];
    if (e11.dom.parentNode == i10) return e11.domAtPos(e11.length);
  }
  for (let t108 = n10; t108 < s10.length; t108++) {
    let e11 = s10[t108];
    if (e11.dom.parentNode == i10) return e11.domAtPos(0);
  }
  return new eO(i10, 0);
}
function eQ(t107, e10, i10) {
  let s10 = null, n10 = -1, o10 = null, r10 = -1;
  !function t108(e11, l11) {
    for (let h10 = 0, a10 = 0; h10 < e11.children.length && a10 <= l11; h10++) {
      let c10 = e11.children[h10], d10 = a10 + c10.length;
      d10 >= l11 && (c10.children.length ? t108(c10, l11 - a10) : (!o10 || o10.isHidden && i10 > 0) && (d10 > l11 || a10 == d10 && c10.getSide() > 0) ? (o10 = c10, r10 = l11 - a10) : (a10 < l11 || a10 == d10 && 0 > c10.getSide() && !c10.isHidden) && (s10 = c10, n10 = l11 - a10)), a10 = d10;
    }
  }(t107, e10);
  let l10 = (i10 < 0 ? s10 : o10) || s10 || o10;
  return l10 ? l10.coordsAt(Math.max(0, l10 == s10 ? n10 : r10), i10) : function(t108) {
    let e11 = t108.dom.lastChild;
    if (!e11) return t108.dom.getBoundingClientRect();
    let i11 = ed(e11);
    return i11[i11.length - 1] || null;
  }(t107);
}
function eZ(t107, e10) {
  for (let i10 in t107) "class" == i10 && e10.class ? e10.class += " " + t107.class : "style" == i10 && e10.style ? e10.style += ";" + t107.style : e10[i10] = t107[i10];
  return e10;
}
eU.prototype.children = e$.prototype.children = eX.prototype.children = eT;
let e0 = /* @__PURE__ */ Object.create(null);
function e1(t107, e10, i10) {
  if (t107 == e10) return true;
  t107 || (t107 = e0), e10 || (e10 = e0);
  let s10 = Object.keys(t107), n10 = Object.keys(e10);
  if (s10.length - (i10 && s10.indexOf(i10) > -1 ? 1 : 0) != n10.length - (i10 && n10.indexOf(i10) > -1 ? 1 : 0)) return false;
  for (let o10 of s10) if (o10 != i10 && (-1 == n10.indexOf(o10) || t107[o10] !== e10[o10])) return false;
  return true;
}
function e2(t107, e10, i10) {
  let s10 = false;
  if (e10) for (let n10 in e10) i10 && n10 in i10 || (s10 = true, "style" == n10 ? t107.style.cssText = "" : t107.removeAttribute(n10));
  if (i10) for (let n10 in i10) e10 && e10[n10] == i10[n10] || (s10 = true, "style" == n10 ? t107.style.cssText = i10[n10] : t107.setAttribute(n10, i10[n10]));
  return s10;
}
let e8 = class t16 extends eE {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  merge(e10, i10, s10, n10, o10, r10) {
    if (s10) {
      if (!(s10 instanceof t16)) return false;
      this.dom || s10.transferDOM(this);
    }
    return n10 && this.setDeco(s10 ? s10.attrs : null), eP(this, e10, i10, s10 ? s10.children.slice() : [], o10, r10), true;
  }
  split(e10) {
    let i10 = new t16();
    if (i10.breakAfter = this.breakAfter, 0 == this.length) return i10;
    let { i: s10, off: n10 } = this.childPos(e10);
    n10 && (i10.append(this.children[s10].split(n10), 0), this.children[s10].merge(n10, this.children[s10].length, null, false, 0, 0), s10++);
    for (let t107 = s10; t107 < this.children.length; t107++) i10.append(this.children[t107], 0);
    for (; s10 > 0 && 0 == this.children[s10 - 1].length; ) this.children[--s10].destroy();
    return this.children.length = s10, this.markDirty(), this.length = e10, i10;
  }
  transferDOM(t107) {
    this.dom && (this.markDirty(), t107.setDOM(this.dom), t107.prevAttrs = void 0 === this.prevAttrs ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(t107) {
    e1(this.attrs, t107) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = t107);
  }
  append(t107, e10) {
    !function t108(e11, i10, s10) {
      let n10, { children: o10 } = e11;
      s10 > 0 && i10 instanceof eY && o10.length && (n10 = o10[o10.length - 1]) instanceof eY && n10.mark.eq(i10.mark) ? t108(n10, i10.children[0], s10 - 1) : (o10.push(i10), i10.setParent(e11)), e11.length += i10.length;
    }(this, t107, e10);
  }
  addLineDeco(t107) {
    let e10 = t107.spec.attributes, i10 = t107.spec.class;
    e10 && (this.attrs = eZ(e10, this.attrs || {})), i10 && (this.attrs = eZ({ class: i10 }, this.attrs || {}));
  }
  domAtPos(t107) {
    return eJ(this, t107);
  }
  reuseDOM(t107) {
    "DIV" == t107.nodeName && (this.setDOM(t107), this.flags |= 6);
  }
  sync(t107, e10) {
    var i10;
    this.dom ? 4 & this.flags && (eM(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), void 0 !== this.prevAttrs && (e2(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(t107, e10);
    let s10 = this.dom.lastChild;
    for (; s10 && eE.get(s10) instanceof eY; ) s10 = s10.lastChild;
    if (!s10 || !this.length || "BR" != s10.nodeName && (null === (i10 = eE.get(s10)) || void 0 === i10 ? void 0 : i10.isEditable) == false && (!ej.ios || !this.children.some((t108) => t108 instanceof eU))) {
      let t108 = document.createElement("BR");
      t108.cmIgnore = true, this.dom.appendChild(t108);
    }
  }
  measureTextSize() {
    if (0 == this.children.length || this.length > 20) return null;
    let t107 = 0, e10;
    for (let i10 of this.children) {
      if (!(i10 instanceof eU) || /[^ -~]/.test(i10.text)) return null;
      let s10 = ed(i10.dom);
      if (1 != s10.length) return null;
      t107 += s10[0].width, e10 = s10[0].height;
    }
    return t107 ? { lineHeight: this.dom.getBoundingClientRect().height, charWidth: t107 / this.length, textHeight: e10 } : null;
  }
  coordsAt(t107, e10) {
    let i10 = eQ(this, t107, e10);
    if (!this.children.length && i10 && this.parent) {
      let { heightOracle: t108 } = this.parent.view.viewState, e11 = i10.bottom - i10.top;
      if (2 > Math.abs(e11 - t108.lineHeight) && t108.textHeight < e11) {
        let s10 = (e11 - t108.textHeight) / 2;
        return { top: i10.top + s10, bottom: i10.bottom - s10, left: i10.left, right: i10.left };
      }
    }
    return i10;
  }
  become(e10) {
    return e10 instanceof t16 && 0 == this.children.length && 0 == e10.children.length && e1(this.attrs, e10.attrs) && this.breakAfter == e10.breakAfter;
  }
  covers() {
    return true;
  }
  static find(e10, i10) {
    for (let s10 = 0, n10 = 0; s10 < e10.children.length; s10++) {
      let o10 = e10.children[s10], r10 = n10 + o10.length;
      if (r10 >= i10) {
        if (o10 instanceof t16) return o10;
        if (r10 > i10) break;
      }
      n10 = r10 + o10.breakAfter;
    }
    return null;
  }
}, e3 = class t17 extends eE {
  constructor(t107, e10, i10) {
    super(), this.widget = t107, this.length = e10, this.deco = i10, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e10, i10, s10, n10, o10, r10) {
    return (!s10 || s10 instanceof t17 && !!this.widget.compare(s10.widget) && (!(e10 > 0) || !(o10 <= 0)) && (!(i10 < this.length) || !(r10 <= 0))) && (this.length = e10 + (s10 ? s10.length : 0) + (this.length - i10), true);
  }
  domAtPos(t107) {
    return 0 == t107 ? eO.before(this.dom) : eO.after(this.dom, t107 == this.length);
  }
  split(e10) {
    let i10 = this.length - e10;
    this.length = e10;
    let s10 = new t17(this.widget, i10, this.deco);
    return s10.breakAfter = this.breakAfter, s10;
  }
  get children() {
    return eT;
  }
  sync(t107) {
    this.dom && this.widget.updateDOM(this.dom, t107) || (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t107)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : r.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e10) {
    return e10 instanceof t17 && e10.widget.constructor == this.widget.constructor && (e10.widget.compare(this.widget) || this.markDirty(true), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e10.widget, this.length = e10.length, this.deco = e10.deco, this.breakAfter = e10.breakAfter, true);
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(t107) {
    return this.widget.ignoreEvent(t107);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  coordsAt(t107, e10) {
    return this.widget.coordsAt(this.dom, t107, e10);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(t107) {
    let { startSide: e10, endSide: i10 } = this.deco;
    return e10 != i10 && (t107 < 0 ? e10 < 0 : i10 > 0);
  }
}, e4 = class {
  eq(t107) {
    return false;
  }
  updateDOM(t107, e10) {
    return false;
  }
  compare(t107) {
    return this == t107 || this.constructor == t107.constructor && this.eq(t107);
  }
  get estimatedHeight() {
    return -1;
  }
  get lineBreaks() {
    return 0;
  }
  ignoreEvent(t107) {
    return true;
  }
  coordsAt(t107, e10, i10) {
    return null;
  }
  get isHidden() {
    return false;
  }
  get editable() {
    return false;
  }
  destroy(t107) {
  }
};
var e9 = ((A = e9 || (e9 = {}))[A.Text = 0] = "Text", A[A.WidgetBefore = 1] = "WidgetBefore", A[A.WidgetAfter = 2] = "WidgetAfter", A[A.WidgetRange = 3] = "WidgetRange", A);
let e5 = class extends tz {
  constructor(t107, e10, i10, s10) {
    super(), this.startSide = t107, this.endSide = e10, this.widget = i10, this.spec = s10;
  }
  get heightRelevant() {
    return false;
  }
  static mark(t107) {
    return new e6(t107);
  }
  static widget(t107) {
    let e10 = Math.max(-1e4, Math.min(1e4, t107.side || 0)), i10 = !!t107.block;
    return e10 += i10 && !t107.inlineOrder ? e10 > 0 ? 3e8 : -4e8 : e10 > 0 ? 1e8 : -1e8, new it(t107, e10, e10, i10, t107.widget || null, false);
  }
  static replace(t107) {
    let e10 = !!t107.block, i10, s10;
    if (t107.isBlockGap) i10 = -5e8, s10 = 4e8;
    else {
      let { start: n10, end: o10 } = ie(t107, e10);
      i10 = (n10 ? e10 ? -3e8 : -1 : 5e8) - 1, s10 = (o10 ? e10 ? 2e8 : 1 : -6e8) + 1;
    }
    return new it(t107, i10, s10, e10, t107.widget || null, true);
  }
  static line(t107) {
    return new e7(t107);
  }
  static set(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return tG.of(t107, e10);
  }
  hasHeight() {
    return !!this.widget && this.widget.estimatedHeight > -1;
  }
};
e5.none = tG.empty;
let e6 = class t18 extends e5 {
  constructor(t107) {
    let { start: e10, end: i10 } = ie(t107);
    super(e10 ? -1 : 5e8, i10 ? 1 : -6e8, null, t107), this.tagName = t107.tagName || "span", this.class = t107.class || "", this.attrs = t107.attributes || null;
  }
  eq(e10) {
    var i10, s10;
    return this == e10 || e10 instanceof t18 && this.tagName == e10.tagName && (this.class || (null === (i10 = this.attrs) || void 0 === i10 ? void 0 : i10.class)) == (e10.class || (null === (s10 = e10.attrs) || void 0 === s10 ? void 0 : s10.class)) && e1(this.attrs, e10.attrs, "class");
  }
  range(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t107;
    if (t107 >= e10) throw RangeError("Mark decorations may not be empty");
    return super.range(t107, e10);
  }
};
e6.prototype.point = false;
let e7 = class t19 extends e5 {
  constructor(t107) {
    super(-2e8, -2e8, null, t107);
  }
  eq(e10) {
    return e10 instanceof t19 && this.spec.class == e10.spec.class && e1(this.spec.attributes, e10.spec.attributes);
  }
  range(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t107;
    if (e10 != t107) throw RangeError("Line decoration ranges must be zero-length");
    return super.range(t107, e10);
  }
};
e7.prototype.mapMode = j.TrackBefore, e7.prototype.point = true;
let it = class t20 extends e5 {
  constructor(t107, e10, i10, s10, n10, o10) {
    super(e10, i10, n10, t107), this.block = s10, this.isReplace = o10, this.mapMode = s10 ? e10 <= 0 ? j.TrackBefore : j.TrackAfter : j.TrackDel;
  }
  get type() {
    return this.startSide != this.endSide ? e9.WidgetRange : this.startSide <= 0 ? e9.WidgetBefore : e9.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e10) {
    var i10, s10;
    return e10 instanceof t20 && ((i10 = this.widget) == (s10 = e10.widget) || !!(i10 && s10 && i10.compare(s10))) && this.block == e10.block && this.startSide == e10.startSide && this.endSide == e10.endSide;
  }
  range(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t107;
    if (this.isReplace && (t107 > e10 || t107 == e10 && this.startSide > 0 && this.endSide <= 0)) throw RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && e10 != t107) throw RangeError("Widget decorations can only have zero-length ranges");
    return super.range(t107, e10);
  }
};
function ie(t107) {
  let e10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], { inclusiveStart: i10, inclusiveEnd: s10 } = t107;
  return null == i10 && (i10 = t107.inclusive), null == s10 && (s10 = t107.inclusive), { start: null != i10 ? i10 : e10, end: null != s10 ? s10 : e10 };
}
function ii(t107, e10, i10) {
  let s10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, n10 = i10.length - 1;
  n10 >= 0 && i10[n10] + s10 >= t107 ? i10[n10] = Math.max(i10[n10], e10) : i10.push(t107, e10);
}
it.prototype.point = true;
let is = class t21 {
  constructor(t107, e10, i10, s10) {
    this.doc = t107, this.pos = e10, this.end = i10, this.disallowBlockEffectsFor = s10, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = true, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = t107.iter(), this.skip = e10;
  }
  posCovered() {
    if (0 == this.content.length) return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let t107 = this.content[this.content.length - 1];
    return !(t107.breakAfter || t107 instanceof e3 && t107.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new e8()), this.atCursorPos = true), this.curLine;
  }
  flushBuffer() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.bufferMarks;
    this.pendingBuffer && (this.curLine.append(io(new eX(-1), t107), t107.length), this.pendingBuffer = 0);
  }
  addBlockWidget(t107) {
    this.flushBuffer(), this.curLine = null, this.content.push(t107);
  }
  finish(t107) {
    this.pendingBuffer && t107 <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, this.posCovered() || t107 && this.content.length && this.content[this.content.length - 1] instanceof e3 || this.getLine();
  }
  buildText(t107, e10, i10) {
    for (; t107 > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: e11, lineBreak: i11, done: s11 } = this.cursor.next(this.skip);
        if (this.skip = 0, s11) throw Error("Ran out of text content when drawing inline views");
        if (i11) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = true, t107--;
          continue;
        }
        this.text = e11, this.textOff = 0;
      }
      let s10 = Math.min(this.text.length - this.textOff, t107, 512);
      this.flushBuffer(e10.slice(e10.length - i10)), this.getLine().append(io(new eU(this.text.slice(this.textOff, this.textOff + s10)), e10), i10), this.atCursorPos = true, this.textOff += s10, t107 -= s10, i10 = 0;
    }
  }
  span(t107, e10, i10, s10) {
    this.buildText(e10 - t107, i10, s10), this.pos = e10, this.openStart < 0 && (this.openStart = s10);
  }
  point(t107, e10, i10, s10, n10, o10) {
    if (this.disallowBlockEffectsFor[o10] && i10 instanceof it) {
      if (i10.block) throw RangeError("Block decorations may not be specified via plugins");
      if (e10 > this.doc.lineAt(this.pos).to) throw RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let r10 = e10 - t107;
    if (i10 instanceof it) {
      if (i10.block) i10.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new e3(i10.widget || ir.block, r10, i10));
      else {
        let o11 = e$.create(i10.widget || ir.inline, r10, r10 ? 0 : i10.startSide), l10 = this.atCursorPos && !o11.isEditable && n10 <= s10.length && (t107 < e10 || i10.startSide > 0), h10 = !o11.isEditable && (t107 < e10 || n10 > s10.length || i10.startSide <= 0), a10 = this.getLine();
        2 != this.pendingBuffer || l10 || o11.isEditable || (this.pendingBuffer = 0), this.flushBuffer(s10), l10 && (a10.append(io(new eX(1), s10), n10), n10 = s10.length + Math.max(0, n10 - s10.length)), a10.append(io(o11, s10), n10), this.atCursorPos = h10, this.pendingBuffer = h10 ? t107 < e10 || n10 > s10.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = s10.slice());
      }
    } else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i10);
    r10 && (this.textOff + r10 <= this.text.length ? this.textOff += r10 : (this.skip += r10 - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = e10), this.openStart < 0 && (this.openStart = n10);
  }
  static build(e10, i10, s10, n10, o10) {
    let r10 = new t21(e10, i10, s10, o10);
    return r10.openEnd = tG.spans(n10, i10, s10, r10), r10.openStart < 0 && (r10.openStart = r10.openEnd), r10.finish(r10.openEnd), r10;
  }
};
function io(t107, e10) {
  for (let i10 of e10) t107 = new eY(i10, [t107], t107.length);
  return t107;
}
let ir = class extends e4 {
  constructor(t107) {
    super(), this.tag = t107;
  }
  eq(t107) {
    return t107.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(t107) {
    return t107.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return true;
  }
};
ir.inline = new ir("span"), ir.block = new ir("div");
var il = ((D = il || (il = {}))[D.LTR = 0] = "LTR", D[D.RTL = 1] = "RTL", D);
let ih = il.LTR, ia = il.RTL;
function ic(t107) {
  let e10 = [];
  for (let i10 = 0; i10 < t107.length; i10++) e10.push(1 << +t107[i10]);
  return e10;
}
let id = ic("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), iu = ic("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), ig = /* @__PURE__ */ Object.create(null), ip = [];
for (let t107 of ["()", "[]", "{}"]) {
  let e10 = t107.charCodeAt(0), i10 = t107.charCodeAt(1);
  ig[e10] = i10, ig[i10] = -e10;
}
function im(t107) {
  return t107 <= 247 ? id[t107] : 1424 <= t107 && t107 <= 1524 ? 2 : 1536 <= t107 && t107 <= 1785 ? iu[t107 - 1536] : 1774 <= t107 && t107 <= 2220 ? 4 : 8192 <= t107 && t107 <= 8204 ? 256 : 64336 <= t107 && t107 <= 65023 ? 4 : 1;
}
let iv = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/, iw = class {
  get dir() {
    return this.level % 2 ? ia : ih;
  }
  constructor(t107, e10, i10) {
    this.from = t107, this.to = e10, this.level = i10;
  }
  side(t107, e10) {
    return this.dir == e10 == t107 ? this.to : this.from;
  }
  forward(t107, e10) {
    return t107 == (this.dir == e10);
  }
  static find(t107, e10, i10, s10) {
    let n10 = -1;
    for (let o10 = 0; o10 < t107.length; o10++) {
      let r10 = t107[o10];
      if (r10.from <= e10 && r10.to >= e10) {
        if (r10.level == i10) return o10;
        (n10 < 0 || (0 != s10 ? s10 < 0 ? r10.from < e10 : r10.to > e10 : t107[n10].level > r10.level)) && (n10 = o10);
      }
    }
    if (n10 < 0) throw RangeError("Index out of range");
    return n10;
  }
}, ib = [];
function iy(t107) {
  return [new iw(0, t107, 0)];
}
let ix = "", iS = to.define(), ik = to.define(), iM = to.define(), iC = to.define(), iA = to.define(), iD = to.define(), iO = to.define(), iT = to.define({ combine: (t107) => t107.some((t108) => t108) }), iE = to.define({ combine: (t107) => t107.some((t108) => t108) }), iR = to.define(), iB = class t23 {
  constructor(t107, e10 = "nearest", i10 = "nearest", s10 = 5, n10 = 5, o10 = false) {
    this.range = t107, this.y = e10, this.x = i10, this.yMargin = s10, this.xMargin = n10, this.isSnapshot = o10;
  }
  map(e10) {
    return e10.empty ? this : new t23(this.range.map(e10), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e10) {
    return this.range.to <= e10.doc.length ? this : new t23(ti.cursor(e10.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}, iL = tR.define({ map: (t107, e10) => t107.map(e10) }), iP = tR.define();
function iN(t107, e10, i10) {
  let s10 = t107.facet(iC);
  s10.length ? s10[0](e10) : window.onerror ? window.onerror(String(e10), i10, void 0, void 0, e10) : i10 ? console.error(i10 + ":", e10) : console.error(e10);
}
let iV = to.define({ combine: (t107) => !t107.length || t107[0] }), iH = 0, iF = to.define(), iW = class t24 {
  constructor(t107, e10, i10, s10, n10) {
    this.id = t107, this.create = e10, this.domEventHandlers = i10, this.domEventObservers = s10, this.extension = n10(this);
  }
  static define(e10, i10) {
    let { eventHandlers: s10, eventObservers: n10, provide: o10, decorations: r10 } = i10 || {};
    return new t24(iH++, e10, s10, n10, (t107) => {
      let e11 = [iF.of(t107)];
      return r10 && e11.push(iq.of((e12) => {
        let i11 = e12.plugin(t107);
        return i11 ? r10(i11) : e5.none;
      })), o10 && e11.push(o10(t107)), e11;
    });
  }
  static fromClass(e10, i10) {
    return t24.define((t107) => new e10(t107), i10);
  }
}, iI = class {
  constructor(t107) {
    this.spec = t107, this.mustUpdate = null, this.value = null;
  }
  update(t107) {
    if (this.value) {
      if (this.mustUpdate) {
        let t108 = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update) try {
          this.value.update(t108);
        } catch (e10) {
          if (iN(t108.state, e10, "CodeMirror plugin crashed"), this.value.destroy) try {
            this.value.destroy();
          } catch (t109) {
          }
          this.deactivate();
        }
      }
    } else if (this.spec) try {
      this.value = this.spec.create(t107);
    } catch (e10) {
      iN(t107.state, e10, "CodeMirror plugin crashed"), this.deactivate();
    }
    return this;
  }
  destroy(t107) {
    var e10;
    if (null === (e10 = this.value) || void 0 === e10 ? void 0 : e10.destroy) try {
      this.value.destroy();
    } catch (e11) {
      iN(t107.state, e11, "CodeMirror plugin crashed");
    }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}, iz = to.define(), iK = to.define(), iq = to.define(), i_ = to.define(), iG = to.define(), ij = to.define();
function iU(t107, e10) {
  let i10 = t107.state.facet(ij);
  if (!i10.length) return i10;
  let s10 = i10.map((e11) => e11 instanceof Function ? e11(t107) : e11), n10 = [];
  return tG.spans(s10, e10.from, e10.to, { point() {
  }, span(t108, i11, s11, o10) {
    let r10 = t108 - e10.from, l10 = i11 - e10.from, h10 = n10;
    for (let t109 = s11.length - 1; t109 >= 0; t109--, o10--) {
      let i12 = s11[t109].spec.bidiIsolate, n11;
      if (null == i12 && (i12 = function(t110, e11, i13) {
        for (let s12 = e11; s12 < i13; s12++) {
          let e12 = im(t110.charCodeAt(s12));
          if (1 == e12) break;
          if (2 == e12 || 4 == e12) return ia;
        }
        return ih;
      }(e10.text, r10, l10)), o10 > 0 && h10.length && (n11 = h10[h10.length - 1]).to == r10 && n11.direction == i12) n11.to = l10, h10 = n11.inner;
      else {
        let t110 = { from: r10, to: l10, direction: i12, inner: [] };
        h10.push(t110), h10 = t110.inner;
      }
    }
  } }), n10;
}
let iY = to.define();
function i$(t107) {
  let e10 = 0, i10 = 0, s10 = 0, n10 = 0;
  for (let o10 of t107.state.facet(iY)) {
    let r10 = o10(t107);
    r10 && (null != r10.left && (e10 = Math.max(e10, r10.left)), null != r10.right && (i10 = Math.max(i10, r10.right)), null != r10.top && (s10 = Math.max(s10, r10.top)), null != r10.bottom && (n10 = Math.max(n10, r10.bottom)));
  }
  return { left: e10, right: i10, top: s10, bottom: n10 };
}
let iX = to.define(), iJ = class t25 {
  constructor(t107, e10, i10, s10) {
    this.fromA = t107, this.toA = e10, this.fromB = i10, this.toB = s10;
  }
  join(e10) {
    return new t25(Math.min(this.fromA, e10.fromA), Math.max(this.toA, e10.toA), Math.min(this.fromB, e10.fromB), Math.max(this.toB, e10.toB));
  }
  addToSet(t107) {
    let e10 = t107.length, i10 = this;
    for (; e10 > 0; e10--) {
      let s10 = t107[e10 - 1];
      if (!(s10.fromA > i10.toA)) {
        if (s10.toA < i10.fromA) break;
        i10 = i10.join(s10), t107.splice(e10 - 1, 1);
      }
    }
    return t107.splice(e10, 0, i10), t107;
  }
  static extendWithRanges(e10, i10) {
    if (0 == i10.length) return e10;
    let s10 = [];
    for (let n10 = 0, o10 = 0, r10 = 0, l10 = 0; ; n10++) {
      let h10 = n10 == e10.length ? null : e10[n10], a10 = r10 - l10, c10 = h10 ? h10.fromB : 1e9;
      for (; o10 < i10.length && i10[o10] < c10; ) {
        let e11 = i10[o10], n11 = i10[o10 + 1], r11 = Math.max(l10, e11), h11 = Math.min(c10, n11);
        if (r11 <= h11 && new t25(r11 + a10, h11 + a10, r11, h11).addToSet(s10), n11 > c10) break;
        o10 += 2;
      }
      if (!h10) return s10;
      new t25(h10.fromA, h10.toA, h10.fromB, h10.toB).addToSet(s10), r10 = h10.toA, l10 = h10.toB;
    }
  }
}, iQ = class t26 {
  constructor(t107, e10, i10) {
    for (let s11 of (this.view = t107, this.state = e10, this.transactions = i10, this.flags = 0, this.startState = t107.state, this.changes = Y.empty(this.startState.doc.length), i10)) this.changes = this.changes.compose(s11.changes);
    let s10 = [];
    this.changes.iterChangedRanges((t108, e11, i11, n10) => s10.push(new iJ(t108, e11, i11, n10))), this.changedRanges = s10;
  }
  static create(e10, i10, s10) {
    return new t26(e10, i10, s10);
  }
  get viewportChanged() {
    return (4 & this.flags) > 0;
  }
  get heightChanged() {
    return (2 & this.flags) > 0;
  }
  get geometryChanged() {
    return this.docChanged || (10 & this.flags) > 0;
  }
  get focusChanged() {
    return (1 & this.flags) > 0;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get selectionSet() {
    return this.transactions.some((t107) => t107.selection);
  }
  get empty() {
    return 0 == this.flags && 0 == this.transactions.length;
  }
}, iZ = class extends eE {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(t107) {
    super(), this.view = t107, this.decorations = [], this.dynamicDecorationMap = [false], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = e5.none, this.lastCompositionAfterCursor = false, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = false, this.lastUpdate = Date.now(), this.setDOM(t107.contentDOM), this.children = [new e8()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new iJ(0, 0, 0, t107.state.doc.length)], 0, null);
  }
  update(t107) {
    var e10, i10, s10, n10, o10, r10;
    let l10, h10;
    let a10 = t107.changedRanges;
    this.minWidth > 0 && a10.length && (a10.every((t108) => {
      let { fromA: e11, toA: i11 } = t108;
      return i11 < this.minWidthFrom || e11 > this.minWidthTo;
    }) ? (this.minWidthFrom = t107.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = t107.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(t107);
    let c10 = -1;
    !(this.view.inputState.composing >= 0) || this.view.observer.editContext || ((null === (e10 = this.domChanged) || void 0 === e10 ? void 0 : e10.newSel) ? c10 = this.domChanged.newSel.head : (i10 = t107.changes, s10 = this.hasComposition, l10 = false, s10 && i10.iterChangedRanges((t108, e11) => {
      t108 < s10.to && e11 > s10.from && (l10 = true);
    }), l10 || t107.selectionSet || (c10 = t107.state.selection.main.head)));
    let d10 = c10 > -1 ? function(t108, e11, i11) {
      let s11 = i1(t108, i11);
      if (!s11) return null;
      let { node: n11, from: o11, to: r11 } = s11, l11 = n11.nodeValue;
      if (/[\n\r]/.test(l11) || t108.state.doc.sliceString(s11.from, s11.to) != l11) return null;
      let h11 = e11.invertedDesc, a11 = new iJ(h11.mapPos(o11), h11.mapPos(r11), o11, r11), c11 = [];
      for (let e12 = n11.parentNode; ; e12 = e12.parentNode) {
        let i12 = eE.get(e12);
        if (i12 instanceof eY) c11.push({ node: e12, deco: i12.mark });
        else {
          if (i12 instanceof e8 || "DIV" == e12.nodeName && e12.parentNode == t108.contentDOM) return { range: a11, text: n11, marks: c11, line: e12 };
          if (e12 == t108.contentDOM) return null;
          c11.push({ node: e12, deco: new e6({ inclusive: true, attributes: function(t109) {
            let e13 = /* @__PURE__ */ Object.create(null);
            for (let i13 = 0; i13 < t109.attributes.length; i13++) {
              let s12 = t109.attributes[i13];
              e13[s12.name] = s12.value;
            }
            return e13;
          }(e12), tagName: e12.tagName.toLowerCase() }) });
        }
      }
    }(this.view, t107.changes, c10) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: e11, to: i11 } = this.hasComposition;
      a10 = new iJ(e11, i11, t107.changes.mapPos(e11, -1), t107.changes.mapPos(i11, 1)).addToSet(a10.slice());
    }
    this.hasComposition = d10 ? { from: d10.range.fromB, to: d10.range.toB } : null, (ej.ie || ej.chrome) && !d10 && t107 && t107.state.doc.lines != t107.startState.doc.lines && (this.forceSelection = true);
    let u10 = (n10 = this.decorations, o10 = this.updateDeco(), r10 = t107.changes, h10 = new i2(), tG.compare(n10, o10, r10, h10), h10.changes);
    return a10 = iJ.extendWithRanges(a10, u10), (!!(7 & this.flags) || 0 != a10.length) && (this.updateInner(a10, t107.startState.doc.length, d10), t107.transactions.length && (this.lastUpdate = Date.now()), true);
  }
  updateInner(t107, e10, i10) {
    this.view.viewState.mustMeasureContent = true, this.updateChildren(t107, e10, i10);
    let { observer: s10 } = this.view;
    s10.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let t108 = ej.chrome || ej.ios ? { node: s10.selectionRange.focusNode, written: false } : void 0;
      this.sync(this.view, t108), this.flags &= -8, t108 && (t108.written || s10.selectionRange.focusNode != t108.node) && (this.forceSelection = true), this.dom.style.height = "";
    }), this.markedForComposition.forEach((t108) => t108.flags &= -9);
    let n10 = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) for (let t108 of this.children) t108 instanceof e3 && t108.widget instanceof i0 && n10.push(t108.dom);
    s10.updateGaps(n10);
  }
  updateChildren(t107, e10, i10) {
    let s10 = i10 ? i10.range.addToSet(t107.slice()) : t107, n10 = this.childCursor(e10);
    for (let t108 = s10.length - 1; ; t108--) {
      let e11 = t108 >= 0 ? s10[t108] : null;
      if (!e11) break;
      let { fromA: o10, toA: r10, fromB: l10, toB: h10 } = e11, a10, c10, d10, u10;
      if (i10 && i10.range.fromB < h10 && i10.range.toB > l10) {
        let t109 = is.build(this.view.state.doc, l10, i10.range.fromB, this.decorations, this.dynamicDecorationMap), e12 = is.build(this.view.state.doc, i10.range.toB, h10, this.decorations, this.dynamicDecorationMap);
        c10 = t109.breakAtStart, d10 = t109.openStart, u10 = e12.openEnd;
        let s11 = this.compositionView(i10);
        e12.breakAtStart ? s11.breakAfter = 1 : e12.content.length && s11.merge(s11.length, s11.length, e12.content[0], false, e12.openStart, 0) && (s11.breakAfter = e12.content[0].breakAfter, e12.content.shift()), t109.content.length && s11.merge(0, 0, t109.content[t109.content.length - 1], true, 0, t109.openEnd) && t109.content.pop(), a10 = t109.content.concat(s11).concat(e12.content);
      } else ({ content: a10, breakAtStart: c10, openStart: d10, openEnd: u10 } = is.build(this.view.state.doc, l10, h10, this.decorations, this.dynamicDecorationMap));
      let { i: f10, off: g10 } = n10.findPos(r10, 1), { i: p10, off: m10 } = n10.findPos(o10, -1);
      eL(this, p10, m10, f10, g10, a10, c10, d10, u10);
    }
    i10 && this.fixCompositionDOM(i10);
  }
  updateEditContextFormatting(t107) {
    for (let e10 of (this.editContextFormatting = this.editContextFormatting.map(t107.changes), t107.transactions)) for (let t108 of e10.effects) t108.is(iP) && (this.editContextFormatting = t108.value);
  }
  compositionView(t107) {
    let e10 = new eU(t107.text.nodeValue);
    for (let { deco: i11 } of (e10.flags |= 8, t107.marks)) e10 = new eY(i11, [e10], e10.length);
    let i10 = new e8();
    return i10.append(e10, 0), i10;
  }
  fixCompositionDOM(t107) {
    let e10 = (t108, e11) => {
      e11.flags |= 8 | (e11.children.some((t109) => 7 & t109.flags) ? 1 : 0), this.markedForComposition.add(e11);
      let i11 = eE.get(t108);
      i11 && i11 != e11 && (i11.dom = null), e11.setDOM(t108);
    }, i10 = this.childPos(t107.range.fromB, 1), s10 = this.children[i10.i];
    e10(t107.line, s10);
    for (let n10 = t107.marks.length - 1; n10 >= -1; n10--) i10 = s10.childPos(i10.off, 1), s10 = s10.children[i10.i], e10(n10 >= 0 ? t107.marks[n10].node : t107.text, s10);
  }
  updateSelection() {
    var t107;
    let e10 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], i10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    (e10 || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let s10 = this.view.root.activeElement, n10 = s10 == this.dom, o10 = !n10 && ec(this.dom, this.view.observer.selectionRange) && !(s10 && this.dom.contains(s10));
    if (!(n10 || i10 || o10)) return;
    let r10 = this.forceSelection;
    this.forceSelection = false;
    let l10 = this.view.state.selection.main, h10 = this.moveToLine(this.domAtPos(l10.anchor)), a10 = l10.empty ? h10 : this.moveToLine(this.domAtPos(l10.head));
    if (ej.gecko && l10.empty && !this.hasComposition && 1 == (t107 = h10).node.nodeType && t107.node.firstChild && (0 == t107.offset || "false" == t107.node.childNodes[t107.offset - 1].contentEditable) && (t107.offset == t107.node.childNodes.length || "false" == t107.node.childNodes[t107.offset].contentEditable)) {
      let t108 = document.createTextNode("");
      this.view.observer.ignore(() => h10.node.insertBefore(t108, h10.node.childNodes[h10.offset] || null)), h10 = a10 = new eO(t108, 0), r10 = true;
    }
    let c10 = this.view.observer.selectionRange;
    !r10 && c10.focusNode && (eu(h10.node, h10.offset, c10.anchorNode, c10.anchorOffset) && eu(a10.node, a10.offset, c10.focusNode, c10.focusOffset) || this.suppressWidgetCursorChange(c10, l10)) || (this.view.observer.ignore(() => {
      ej.android && ej.chrome && this.dom.contains(c10.focusNode) && function(t109, e12) {
        for (let i12 = t109; i12 && i12 != e12; i12 = i12.assignedSlot || i12.parentNode) if (1 == i12.nodeType && "false" == i12.contentEditable) return true;
        return false;
      }(c10.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: true }));
      let t108 = eh(this.view.root);
      if (t108) {
        if (l10.empty) {
          if (ej.gecko) {
            var e11, i11;
            let t109 = (e11 = h10.node, i11 = h10.offset, 1 != e11.nodeType ? 0 : (i11 && "false" == e11.childNodes[i11 - 1].contentEditable ? 1 : 0) | (i11 < e11.childNodes.length && "false" == e11.childNodes[i11].contentEditable ? 2 : 0));
            if (t109 && 3 != t109) {
              let e12 = (1 == t109 ? eA : eD)(h10.node, h10.offset);
              e12 && (h10 = new eO(e12.node, e12.offset));
            }
          }
          t108.collapse(h10.node, h10.offset), null != l10.bidiLevel && void 0 !== t108.caretBidiLevel && (t108.caretBidiLevel = l10.bidiLevel);
        } else if (t108.extend) {
          t108.collapse(h10.node, h10.offset);
          try {
            t108.extend(a10.node, a10.offset);
          } catch (t109) {
          }
        } else {
          let e12 = document.createRange();
          l10.anchor > l10.head && ([h10, a10] = [a10, h10]), e12.setEnd(a10.node, a10.offset), e12.setStart(h10.node, h10.offset), t108.removeAllRanges(), t108.addRange(e12);
        }
      }
      o10 && this.view.root.activeElement == this.dom && (this.dom.blur(), s10 && s10.focus());
    }), this.view.observer.setSelectionRange(h10, a10)), this.impreciseAnchor = h10.precise ? null : new eO(c10.anchorNode, c10.anchorOffset), this.impreciseHead = a10.precise ? null : new eO(c10.focusNode, c10.focusOffset);
  }
  suppressWidgetCursorChange(t107, e10) {
    return this.hasComposition && e10.empty && eu(t107.focusNode, t107.focusOffset, t107.anchorNode, t107.anchorOffset) && this.posFromDOM(t107.focusNode, t107.focusOffset) == e10.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition) return;
    let { view: t107 } = this, e10 = t107.state.selection.main, i10 = eh(t107.root), { anchorNode: s10, anchorOffset: n10 } = t107.observer.selectionRange;
    if (!i10 || !e10.empty || !e10.assoc || !i10.modify) return;
    let o10 = e8.find(this, e10.head);
    if (!o10) return;
    let r10 = o10.posAtStart;
    if (e10.head == r10 || e10.head == r10 + o10.length) return;
    let l10 = this.coordsAt(e10.head, -1), h10 = this.coordsAt(e10.head, 1);
    if (!l10 || !h10 || l10.bottom > h10.top) return;
    let a10 = this.domAtPos(e10.head + e10.assoc);
    i10.collapse(a10.node, a10.offset), i10.modify("move", e10.assoc < 0 ? "forward" : "backward", "lineboundary"), t107.observer.readSelectionRange();
    let c10 = t107.observer.selectionRange;
    t107.docView.posFromDOM(c10.anchorNode, c10.anchorOffset) != e10.from && i10.collapse(s10, n10);
  }
  moveToLine(t107) {
    let e10 = this.dom, i10;
    if (t107.node != e10) return t107;
    for (let s10 = t107.offset; !i10 && s10 < e10.childNodes.length; s10++) {
      let t108 = eE.get(e10.childNodes[s10]);
      t108 instanceof e8 && (i10 = t108.domAtPos(0));
    }
    for (let s10 = t107.offset - 1; !i10 && s10 >= 0; s10--) {
      let t108 = eE.get(e10.childNodes[s10]);
      t108 instanceof e8 && (i10 = t108.domAtPos(t108.length));
    }
    return i10 ? new eO(i10.node, i10.offset, true) : t107;
  }
  nearest(t107) {
    for (let e10 = t107; e10; ) {
      let t108 = eE.get(e10);
      if (t108 && t108.rootView == this) return t108;
      e10 = e10.parentNode;
    }
    return null;
  }
  posFromDOM(t107, e10) {
    let i10 = this.nearest(t107);
    if (!i10) throw RangeError("Trying to find position for a DOM position outside of the document");
    return i10.localPosFromDOM(t107, e10) + i10.posAtStart;
  }
  domAtPos(t107) {
    let { i: e10, off: i10 } = this.childCursor().findPos(t107, -1);
    for (; e10 < this.children.length - 1; ) {
      let t108 = this.children[e10];
      if (i10 < t108.length || t108 instanceof e8) break;
      e10++, i10 = 0;
    }
    return this.children[e10].domAtPos(i10);
  }
  coordsAt(t107, e10) {
    let i10 = null, s10 = 0;
    for (let n10 = this.length, o10 = this.children.length - 1; o10 >= 0; o10--) {
      let r10 = this.children[o10], l10 = n10 - r10.breakAfter, h10 = l10 - r10.length;
      if (l10 < t107) break;
      if (h10 <= t107 && (h10 < t107 || r10.covers(-1)) && (l10 > t107 || r10.covers(1)) && (!i10 || r10 instanceof e8 && !(i10 instanceof e8 && e10 >= 0))) i10 = r10, s10 = h10;
      else if (i10 && h10 == t107 && l10 == t107 && r10 instanceof e3 && 2 > Math.abs(e10)) {
        if (r10.deco.startSide < 0) break;
        o10 && (i10 = null);
      }
      n10 = h10;
    }
    return i10 ? i10.coordsAt(t107 - s10, e10) : null;
  }
  coordsForChar(t107) {
    let { i: e10, off: i10 } = this.childPos(t107, 1), s10 = this.children[e10];
    if (!(s10 instanceof e8)) return null;
    for (; s10.children.length; ) {
      let { i: t108, off: e11 } = s10.childPos(i10, 1);
      for (; ; t108++) {
        if (t108 == s10.children.length) return null;
        if ((s10 = s10.children[t108]).length) break;
      }
      i10 = e11;
    }
    if (!(s10 instanceof eU)) return null;
    let n10 = v(s10.text, i10);
    if (n10 == i10) return null;
    let o10 = eS(s10.dom, i10, n10).getClientRects();
    for (let t108 = 0; t108 < o10.length; t108++) {
      let e11 = o10[t108];
      if (t108 == o10.length - 1 || e11.top < e11.bottom && e11.left < e11.right) return e11;
    }
    return null;
  }
  measureVisibleLineHeights(t107) {
    let e10 = [], { from: i10, to: s10 } = t107, n10 = this.view.contentDOM.clientWidth, o10 = n10 > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, r10 = -1, l10 = this.view.textDirection == il.LTR;
    for (let t108 = 0, h10 = 0; h10 < this.children.length; h10++) {
      let a10 = this.children[h10], c10 = t108 + a10.length;
      if (c10 > s10) break;
      if (t108 >= i10) {
        let i11 = a10.dom.getBoundingClientRect();
        if (e10.push(i11.height), o10) {
          let e11 = a10.dom.lastChild, s11 = e11 ? ed(e11) : [];
          if (s11.length) {
            let e12 = s11[s11.length - 1], o11 = l10 ? e12.right - i11.left : i11.right - e12.left;
            o11 > r10 && (r10 = o11, this.minWidth = n10, this.minWidthFrom = t108, this.minWidthTo = c10);
          }
        }
      }
      t108 = c10 + a10.breakAfter;
    }
    return e10;
  }
  textDirectionAt(t107) {
    let { i: e10 } = this.childPos(t107, 1);
    return "rtl" == getComputedStyle(this.children[e10].dom).direction ? il.RTL : il.LTR;
  }
  measureTextSize() {
    for (let t108 of this.children) if (t108 instanceof e8) {
      let e11 = t108.measureTextSize();
      if (e11) return e11;
    }
    let t107 = document.createElement("div"), e10, i10, s10;
    return t107.className = "cm-line", t107.style.width = "99999px", t107.style.position = "absolute", t107.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(t107);
      let n10 = ed(t107.firstChild)[0];
      e10 = t107.getBoundingClientRect().height, i10 = n10 ? n10.width / 27 : 7, s10 = n10 ? n10.height : e10, t107.remove();
    }), { lineHeight: e10, charWidth: i10, textHeight: s10 };
  }
  childCursor() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.length, e10 = this.children.length;
    return e10 && (t107 -= this.children[--e10].length), new eB(this.children, t107, e10);
  }
  computeBlockGapDeco() {
    let t107 = [], e10 = this.view.viewState;
    for (let i10 = 0, s10 = 0; ; s10++) {
      let n10 = s10 == e10.viewports.length ? null : e10.viewports[s10], o10 = n10 ? n10.from - 1 : this.length;
      if (o10 > i10) {
        let s11 = (e10.lineBlockAt(o10).bottom - e10.lineBlockAt(i10).top) / this.view.scaleY;
        t107.push(e5.replace({ widget: new i0(s11), block: true, inclusive: true, isBlockGap: true }).range(i10, o10));
      }
      if (!n10) break;
      i10 = n10.to + 1;
    }
    return e5.set(t107);
  }
  updateDeco() {
    let t107 = 1, e10 = this.view.state.facet(iq).map((e11) => (this.dynamicDecorationMap[t107++] = "function" == typeof e11) ? e11(this.view) : e11), i10 = false, s10 = this.view.state.facet(i_).map((t108, e11) => {
      let s11 = "function" == typeof t108;
      return s11 && (i10 = true), s11 ? t108(this.view) : t108;
    });
    for (s10.length && (this.dynamicDecorationMap[t107++] = i10, e10.push(tG.join(s10))), this.decorations = [this.editContextFormatting, ...e10, this.computeBlockGapDeco(), this.view.viewState.lineGapDeco]; t107 < this.decorations.length; ) this.dynamicDecorationMap[t107++] = false;
    return this.decorations;
  }
  scrollIntoView(t107) {
    if (t107.isSnapshot) {
      let e11 = this.view.viewState.lineBlockAt(t107.range.head);
      this.view.scrollDOM.scrollTop = e11.top - t107.yMargin, this.view.scrollDOM.scrollLeft = t107.xMargin;
      return;
    }
    for (let e11 of this.view.state.facet(iR)) try {
      if (e11(this.view, t107.range, t107)) return true;
    } catch (t108) {
      iN(this.view.state, t108, "scroll handler");
    }
    let { range: e10 } = t107, i10 = this.coordsAt(e10.head, e10.empty ? e10.assoc : e10.head > e10.anchor ? -1 : 1), s10;
    if (!i10) return;
    !e10.empty && (s10 = this.coordsAt(e10.anchor, e10.anchor > e10.head ? -1 : 1)) && (i10 = { left: Math.min(i10.left, s10.left), top: Math.min(i10.top, s10.top), right: Math.max(i10.right, s10.right), bottom: Math.max(i10.bottom, s10.bottom) });
    let n10 = i$(this.view), o10 = { left: i10.left - n10.left, top: i10.top - n10.top, right: i10.right + n10.right, bottom: i10.bottom + n10.bottom }, { offsetWidth: r10, offsetHeight: l10 } = this.view.scrollDOM;
    !function(t108, e11, i11, s11, n11, o11, r11, l11) {
      let h10 = t108.ownerDocument, a10 = h10.defaultView || window;
      for (let c10 = t108, d10 = false; c10 && !d10; ) if (1 == c10.nodeType) {
        let t109, u10 = c10 == h10.body, f10 = 1, g10 = 1;
        if (u10) t109 = function(t110) {
          let e12 = t110.visualViewport;
          return e12 ? { left: 0, right: e12.width, top: 0, bottom: e12.height } : { left: 0, right: t110.innerWidth, top: 0, bottom: t110.innerHeight };
        }(a10);
        else {
          if (/^(fixed|sticky)$/.test(getComputedStyle(c10).position) && (d10 = true), c10.scrollHeight <= c10.clientHeight && c10.scrollWidth <= c10.clientWidth) {
            c10 = c10.assignedSlot || c10.parentNode;
            continue;
          }
          let e12 = c10.getBoundingClientRect();
          ({ scaleX: f10, scaleY: g10 } = ew(c10, e12)), t109 = { left: e12.left, right: e12.left + c10.clientWidth * f10, top: e12.top, bottom: e12.top + c10.clientHeight * g10 };
        }
        let p10 = 0, m10 = 0;
        if ("nearest" == n11) e11.top < t109.top ? (m10 = -(t109.top - e11.top + r11), i11 > 0 && e11.bottom > t109.bottom + m10 && (m10 = e11.bottom - t109.bottom + m10 + r11)) : e11.bottom > t109.bottom && (m10 = e11.bottom - t109.bottom + r11, i11 < 0 && e11.top - m10 < t109.top && (m10 = -(t109.top + m10 - e11.top + r11)));
        else {
          let s12 = e11.bottom - e11.top, o12 = t109.bottom - t109.top;
          m10 = ("center" == n11 && s12 <= o12 ? e11.top + s12 / 2 - o12 / 2 : "start" == n11 || "center" == n11 && i11 < 0 ? e11.top - r11 : e11.bottom - o12 + r11) - t109.top;
        }
        if ("nearest" == s11 ? e11.left < t109.left ? (p10 = -(t109.left - e11.left + o11), i11 > 0 && e11.right > t109.right + p10 && (p10 = e11.right - t109.right + p10 + o11)) : e11.right > t109.right && (p10 = e11.right - t109.right + o11, i11 < 0 && e11.left < t109.left + p10 && (p10 = -(t109.left + p10 - e11.left + o11))) : p10 = ("center" == s11 ? e11.left + (e11.right - e11.left) / 2 - (t109.right - t109.left) / 2 : "start" == s11 == l11 ? e11.left - o11 : e11.right - (t109.right - t109.left) + o11) - t109.left, p10 || m10) {
          if (u10) a10.scrollBy(p10, m10);
          else {
            let t110 = 0, i12 = 0;
            if (m10) {
              let t111 = c10.scrollTop;
              c10.scrollTop += m10 / g10, i12 = (c10.scrollTop - t111) * g10;
            }
            if (p10) {
              let e12 = c10.scrollLeft;
              c10.scrollLeft += p10 / f10, t110 = (c10.scrollLeft - e12) * f10;
            }
            e11 = { left: e11.left - t110, top: e11.top - i12, right: e11.right - t110, bottom: e11.bottom - i12 }, t110 && 1 > Math.abs(t110 - p10) && (s11 = "nearest"), i12 && 1 > Math.abs(i12 - m10) && (n11 = "nearest");
          }
        }
        if (u10) break;
        c10 = c10.assignedSlot || c10.parentNode;
      } else if (11 == c10.nodeType) c10 = c10.host;
      else break;
    }(this.view.scrollDOM, o10, e10.head < e10.anchor ? -1 : 1, t107.x, t107.y, Math.max(Math.min(t107.xMargin, r10), -r10), Math.max(Math.min(t107.yMargin, l10), -l10), this.view.textDirection == il.LTR);
  }
}, i0 = class extends e4 {
  constructor(t107) {
    super(), this.height = t107;
  }
  toDOM() {
    let t107 = document.createElement("div");
    return t107.className = "cm-gap", this.updateDOM(t107), t107;
  }
  eq(t107) {
    return t107.height == this.height;
  }
  updateDOM(t107) {
    return t107.style.height = this.height + "px", true;
  }
  get editable() {
    return true;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return false;
  }
};
function i1(t107, e10) {
  let i10 = t107.observer.selectionRange;
  if (!i10.focusNode) return null;
  let s10 = eA(i10.focusNode, i10.focusOffset), n10 = eD(i10.focusNode, i10.focusOffset), o10 = s10 || n10;
  if (n10 && s10 && n10.node != s10.node) {
    let e11 = eE.get(n10.node);
    if (!e11 || e11 instanceof eU && e11.text != n10.node.nodeValue) o10 = n10;
    else if (t107.docView.lastCompositionAfterCursor) {
      let t108 = eE.get(s10.node);
      !t108 || t108 instanceof eU && t108.text != s10.node.nodeValue || (o10 = n10);
    }
  }
  if (t107.docView.lastCompositionAfterCursor = o10 != s10, !o10) return null;
  let r10 = e10 - o10.offset;
  return { from: r10, to: r10 + o10.node.nodeValue.length, node: o10.node };
}
let i2 = class {
  constructor() {
    this.changes = [];
  }
  compareRange(t107, e10) {
    ii(t107, e10, this.changes);
  }
  comparePoint(t107, e10) {
    ii(t107, e10, this.changes);
  }
};
function i8(t107, e10) {
  return t107.top < e10.bottom - 1 && t107.bottom > e10.top + 1;
}
function i3(t107, e10) {
  return e10 < t107.top ? { top: e10, left: t107.left, right: t107.right, bottom: t107.bottom } : t107;
}
function i4(t107, e10) {
  return e10 > t107.bottom ? { top: t107.top, left: t107.left, right: t107.right, bottom: e10 } : t107;
}
function i9(t107, e10, i10) {
  let s10 = t107.nodeValue.length, n10 = -1, o10 = 1e9, r10 = 0;
  for (let l10 = 0; l10 < s10; l10++) {
    let s11 = eS(t107, l10, l10 + 1).getClientRects();
    for (let h10 = 0; h10 < s11.length; h10++) {
      let a10 = s11[h10];
      if (a10.top == a10.bottom) continue;
      r10 || (r10 = e10 - a10.left);
      let c10 = (a10.top > i10 ? a10.top - i10 : i10 - a10.bottom) - 1;
      if (a10.left - 1 <= e10 && a10.right + 1 >= e10 && c10 < o10) {
        let i11 = e10 >= (a10.left + a10.right) / 2, s12 = i11;
        if ((ej.chrome || ej.gecko) && eS(t107, l10).getBoundingClientRect().left == a10.right && (s12 = !i11), c10 <= 0) return { node: t107, offset: l10 + (s12 ? 1 : 0) };
        n10 = l10 + (s12 ? 1 : 0), o10 = c10;
      }
    }
  }
  return { node: t107, offset: n10 > -1 ? n10 : r10 > 0 ? t107.nodeValue.length : 0 };
}
function i5(t107, e10, i10) {
  var s10, n10;
  let o10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : -1, r10 = t107.contentDOM.getBoundingClientRect(), l10 = r10.top + t107.viewState.paddingTop, h10, { docHeight: a10 } = t107.viewState, { x: c10, y: d10 } = e10, u10 = d10 - l10;
  if (u10 < 0) return 0;
  if (u10 > a10) return t107.state.doc.length;
  for (let e11 = t107.viewState.heightOracle.textHeight / 2, s11 = false; (h10 = t107.elementAtHeight(u10)).type != e9.Text; ) for (; !((u10 = o10 > 0 ? h10.bottom + e11 : h10.top - e11) >= 0) || !(u10 <= a10); ) {
    if (s11) return i10 ? null : 0;
    s11 = true, o10 = -o10;
  }
  d10 = l10 + u10;
  let f10 = h10.from;
  if (f10 < t107.viewport.from) return 0 == t107.viewport.from ? 0 : i10 ? null : i6(t107, r10, h10, c10, d10);
  if (f10 > t107.viewport.to) return t107.viewport.to == t107.state.doc.length ? t107.state.doc.length : i10 ? null : i6(t107, r10, h10, c10, d10);
  let g10 = t107.dom.ownerDocument, p10 = t107.root.elementFromPoint ? t107.root : g10, m10 = p10.elementFromPoint(c10, d10);
  m10 && !t107.contentDOM.contains(m10) && (m10 = null), !m10 && (c10 = Math.max(r10.left + 1, Math.min(r10.right - 1, c10)), (m10 = p10.elementFromPoint(c10, d10)) && !t107.contentDOM.contains(m10) && (m10 = null));
  let v10, w10 = -1;
  if (m10 && (null === (s10 = t107.docView.nearest(m10)) || void 0 === s10 ? void 0 : s10.isEditable) != false) {
    if (g10.caretPositionFromPoint) {
      let t108 = g10.caretPositionFromPoint(c10, d10);
      t108 && ({ offsetNode: v10, offset: w10 } = t108);
    } else if (g10.caretRangeFromPoint) {
      let e11 = g10.caretRangeFromPoint(c10, d10);
      e11 && ({ startContainer: v10, startOffset: w10 } = e11, (!t107.contentDOM.contains(v10) || ej.safari && function(t108, e12, i11) {
        let s11;
        if (3 != t108.nodeType || e12 != (s11 = t108.nodeValue.length)) return false;
        for (let e13 = t108.nextSibling; e13; e13 = e13.nextSibling) if (1 != e13.nodeType || "BR" != e13.nodeName) return false;
        return eS(t108, s11 - 1, s11).getBoundingClientRect().left > i11;
      }(v10, w10, c10) || ej.chrome && function(t108, e12, i11) {
        if (0 != e12) return false;
        for (let e13 = t108; ; ) {
          let t109 = e13.parentNode;
          if (!t109 || 1 != t109.nodeType || t109.firstChild != e13) return false;
          if (t109.classList.contains("cm-line")) break;
          e13 = t109;
        }
        return i11 - (1 == t108.nodeType ? t108.getBoundingClientRect() : eS(t108, 0, Math.max(t108.nodeValue.length, 1)).getBoundingClientRect()).left > 5;
      }(v10, w10, c10)) && (v10 = void 0));
    }
  }
  if (!v10 || !t107.docView.dom.contains(v10)) {
    let e11 = e8.find(t107.docView, f10);
    if (!e11) return u10 > h10.top + h10.height / 2 ? h10.to : h10.from;
    ({ node: v10, offset: w10 } = function t108(e12, i11, s11) {
      let n11, o11, r11, l11, h11, a11, c11, d11, u11 = false;
      for (let p12 = e12.firstChild; p12; p12 = p12.nextSibling) {
        let e13 = ed(p12);
        for (let m12 = 0; m12 < e13.length; m12++) {
          var f11, g11;
          let v11 = e13[m12];
          a11 && i8(a11, v11) && (v11 = i3(i4(v11, a11.bottom), a11.top));
          let w11 = (f11 = v11).left > i11 ? f11.left - i11 : Math.max(0, i11 - f11.right), b11 = (g11 = v11).top > s11 ? g11.top - s11 : Math.max(0, s11 - g11.bottom);
          if (0 == w11 && 0 == b11) return 3 == p12.nodeType ? i9(p12, i11, s11) : t108(p12, i11, s11);
          if (!h11 || d11 > b11 || d11 == b11 && c11 > w11) {
            h11 = p12, a11 = v11, c11 = w11, d11 = b11;
            let t109 = b11 ? s11 < v11.top ? -1 : 1 : w11 ? i11 < v11.left ? -1 : 1 : 0;
            u11 = !t109 || (t109 > 0 ? m12 < e13.length - 1 : m12 > 0);
          }
          0 == w11 ? s11 > v11.bottom && (!r11 || r11.bottom < v11.bottom) ? (n11 = p12, r11 = v11) : s11 < v11.top && (!l11 || l11.top > v11.top) && (o11 = p12, l11 = v11) : r11 && i8(r11, v11) ? r11 = i4(r11, v11.bottom) : l11 && i8(l11, v11) && (l11 = i3(l11, v11.top));
        }
      }
      if (r11 && r11.bottom >= s11 ? (h11 = n11, a11 = r11) : l11 && l11.top <= s11 && (h11 = o11, a11 = l11), !h11) return { node: e12, offset: 0 };
      let p11 = Math.max(a11.left, Math.min(a11.right, i11));
      if (3 == h11.nodeType) return i9(h11, p11, s11);
      if (u11 && "false" != h11.contentEditable) return t108(h11, p11, s11);
      let m11 = Array.prototype.indexOf.call(e12.childNodes, h11) + (i11 >= (a11.left + a11.right) / 2 ? 1 : 0);
      return { node: e12, offset: m11 };
    }(e11.dom, c10, d10));
  }
  let b10 = t107.docView.nearest(v10);
  if (!b10) return null;
  if (!b10.isWidget || (null === (n10 = b10.dom) || void 0 === n10 ? void 0 : n10.nodeType) != 1) return b10.localPosFromDOM(v10, w10) + b10.posAtStart;
  {
    let t108 = b10.dom.getBoundingClientRect();
    return e10.y < t108.top || e10.y <= t108.bottom && e10.x <= (t108.left + t108.right) / 2 ? b10.posAtStart : b10.posAtEnd;
  }
}
function i6(t107, e10, i10, s10, n10) {
  let o10 = Math.round((s10 - e10.left) * t107.defaultCharacterWidth);
  if (t107.lineWrapping && i10.height > 1.5 * t107.defaultLineHeight) {
    let e11 = t107.viewState.heightOracle.textHeight;
    o10 += Math.floor((n10 - i10.top - (t107.defaultLineHeight - e11) * 0.5) / e11) * t107.viewState.heightOracle.lineLength;
  }
  let r10 = t107.state.sliceDoc(i10.from, i10.to);
  return i10.from + t3(r10, o10, t107.state.tabSize);
}
function i7(t107, e10, i10, s10) {
  let n10 = t107.state.doc.lineAt(e10.head), o10 = t107.bidiSpans(n10), r10 = t107.textDirectionAt(n10.from);
  for (let l10 = e10, h10 = null; ; ) {
    let e11 = function(t108, e12, i11, s11, n11) {
      var o11;
      let r11 = s11.head - t108.from, l11 = iw.find(e12, r11, null !== (o11 = s11.bidiLevel) && void 0 !== o11 ? o11 : -1, s11.assoc), h11 = e12[l11], a11 = h11.side(n11, i11);
      if (r11 == a11) {
        let t109 = l11 += n11 ? 1 : -1;
        if (t109 < 0 || t109 >= e12.length) return null;
        r11 = (h11 = e12[l11 = t109]).side(!n11, i11), a11 = h11.side(n11, i11);
      }
      let c10 = v(t108.text, r11, h11.forward(n11, i11));
      (c10 < h11.from || c10 > h11.to) && (c10 = a11), ix = t108.text.slice(Math.min(r11, c10), Math.max(r11, c10));
      let d10 = l11 == (n11 ? e12.length - 1 : 0) ? null : e12[l11 + (n11 ? 1 : -1)];
      return d10 && c10 == a11 && d10.level + (n11 ? 0 : 1) < h11.level ? ti.cursor(d10.side(!n11, i11) + t108.from, d10.forward(n11, i11) ? 1 : -1, d10.level) : ti.cursor(c10 + t108.from, h11.forward(n11, i11) ? -1 : 1, h11.level);
    }(n10, o10, r10, l10, i10), a10 = ix;
    if (!e11) {
      if (n10.number == (i10 ? t107.state.doc.lines : 1)) return l10;
      a10 = "\n", n10 = t107.state.doc.line(n10.number + (i10 ? 1 : -1)), o10 = t107.bidiSpans(n10), e11 = t107.visualLineSide(n10, !i10);
    }
    if (h10) {
      if (!h10(a10)) return l10;
    } else {
      if (!s10) return e11;
      h10 = s10(a10);
    }
    l10 = e11;
  }
}
function st(t107, e10, i10) {
  for (; ; ) {
    let s10 = 0;
    for (let n10 of t107) n10.between(e10 - 1, e10 + 1, (t108, n11, o10) => {
      if (e10 > t108 && e10 < n11) {
        let o11 = s10 || i10 || (e10 - t108 < n11 - e10 ? -1 : 1);
        e10 = o11 < 0 ? t108 : n11, s10 = o11;
      }
    });
    if (!s10) return e10;
  }
}
function se(t107, e10, i10) {
  let s10 = st(t107.state.facet(iG).map((e11) => e11(t107)), i10.from, e10.head > i10.from ? -1 : 1);
  return s10 == i10.from ? i10 : ti.cursor(s10, s10 < i10.from ? 1 : -1);
}
let si = class {
  setSelectionOrigin(t107) {
    this.lastSelectionOrigin = t107, this.lastSelectionTime = Date.now();
  }
  constructor(t107) {
    var e10;
    this.view = t107, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = false, this.compositionPendingChange = false, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = t107.hasFocus, ej.safari && t107.contentDOM.addEventListener("input", () => null), ej.gecko && (e10 = t107.contentDOM.ownerDocument, sA.has(e10) || (sA.add(e10), e10.addEventListener("copy", () => {
    }), e10.addEventListener("cut", () => {
    })));
  }
  handleEvent(t107) {
    !(!function(t108, e10) {
      if (!e10.bubbles) return true;
      if (e10.defaultPrevented) return false;
      for (let i10 = e10.target, s10; i10 != t108.contentDOM; i10 = i10.parentNode) if (!i10 || 11 == i10.nodeType || (s10 = eE.get(i10)) && s10.ignoreEvent(e10)) return false;
      return true;
    }(this.view, t107) || this.ignoreDuringComposition(t107)) && ("keydown" == t107.type && this.keydown(t107) || this.runHandlers(t107.type, t107));
  }
  runHandlers(t107, e10) {
    let i10 = this.handlers[t107];
    if (i10) {
      for (let t108 of i10.observers) t108(this.view, e10);
      for (let t108 of i10.handlers) {
        if (e10.defaultPrevented) break;
        if (t108(this.view, e10)) {
          e10.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(t107) {
    let e10 = function(t108) {
      let e11 = /* @__PURE__ */ Object.create(null);
      function i11(t109) {
        return e11[t109] || (e11[t109] = { observers: [], handlers: [] });
      }
      for (let e12 of t108) {
        let t109 = e12.spec;
        if (t109 && t109.domEventHandlers) for (let s11 in t109.domEventHandlers) {
          let n10 = t109.domEventHandlers[s11];
          n10 && i11(s11).handlers.push(ss(e12.value, n10));
        }
        if (t109 && t109.domEventObservers) for (let s11 in t109.domEventObservers) {
          let n10 = t109.domEventObservers[s11];
          n10 && i11(s11).observers.push(ss(e12.value, n10));
        }
      }
      for (let t109 in sa) i11(t109).handlers.push(sa[t109]);
      for (let t109 in sc) i11(t109).observers.push(sc[t109]);
      return e11;
    }(t107), i10 = this.handlers, s10 = this.view.contentDOM;
    for (let t108 in e10) if ("scroll" != t108) {
      let n10 = !e10[t108].handlers.length, o10 = i10[t108];
      o10 && !o10.handlers.length != n10 && (s10.removeEventListener(t108, this.handleEvent), o10 = null), o10 || s10.addEventListener(t108, this.handleEvent, { passive: n10 });
    }
    for (let t108 in i10) "scroll" == t108 || e10[t108] || s10.removeEventListener(t108, this.handleEvent);
    this.handlers = e10;
  }
  keydown(t107) {
    let e10;
    return this.lastKeyCode = t107.keyCode, this.lastKeyTime = Date.now(), !!(9 == t107.keyCode && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode)) || ((this.tabFocusMode > 0 && 27 != t107.keyCode && 0 > sr.indexOf(t107.keyCode) && (this.tabFocusMode = -1), ej.android && ej.chrome && !t107.synthetic && (13 == t107.keyCode || 8 == t107.keyCode)) ? (this.view.observer.delayAndroidKey(t107.key, t107.keyCode), true) : ej.ios && !t107.synthetic && !t107.altKey && !t107.metaKey && ((e10 = sn.find((e11) => e11.keyCode == t107.keyCode)) && !t107.ctrlKey || so.indexOf(t107.key) > -1 && t107.ctrlKey && !t107.shiftKey) ? (this.pendingIOSKey = e10 || t107, setTimeout(() => this.flushIOSKey(), 250), true) : (229 != t107.keyCode && this.view.observer.forceFlush(), false));
  }
  flushIOSKey(t107) {
    let e10 = this.pendingIOSKey;
    return !(!e10 || "Enter" == e10.key && t107 && t107.from < t107.to && /^\S+$/.test(t107.insert.toString())) && (this.pendingIOSKey = void 0, ek(this.view.contentDOM, e10.key, e10.keyCode, e10 instanceof KeyboardEvent ? e10 : void 0));
  }
  ignoreDuringComposition(t107) {
    return !!/^key/.test(t107.type) && (this.composing > 0 || !!(ej.safari && !ej.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) && (this.compositionPendingKey = false, true));
  }
  startMouseSelection(t107) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = t107;
  }
  update(t107) {
    this.view.observer.update(t107), this.mouseSelection && this.mouseSelection.update(t107), this.draggedContent && t107.docChanged && (this.draggedContent = this.draggedContent.map(t107.changes)), t107.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
};
function ss(t107, e10) {
  return (i10, s10) => {
    try {
      return e10.call(t107, s10, i10);
    } catch (t108) {
      iN(i10.state, t108);
    }
  };
}
let sn = [{ key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" }, { key: "Enter", keyCode: 13, inputType: "insertParagraph" }, { key: "Enter", keyCode: 13, inputType: "insertLineBreak" }, { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }], so = "dthko", sr = [16, 17, 18, 20, 91, 92, 224, 225];
function sl(t107) {
  return 0.7 * Math.max(0, t107) + 8;
}
let sh = class {
  constructor(t107, e10, i10, s10) {
    let n10;
    this.view = t107, this.startEvent = e10, this.style = i10, this.mustSelect = s10, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = e10, this.scrollParents = function(t108) {
      let e11 = t108.ownerDocument, i11, s11;
      for (let n11 = t108.parentNode; n11 && n11 != e11.body && (!i11 || !s11); ) if (1 == n11.nodeType) !s11 && n11.scrollHeight > n11.clientHeight && (s11 = n11), !i11 && n11.scrollWidth > n11.clientWidth && (i11 = n11), n11 = n11.assignedSlot || n11.parentNode;
      else if (11 == n11.nodeType) n11 = n11.host;
      else break;
      return { x: i11, y: s11 };
    }(t107.contentDOM), this.atoms = t107.state.facet(iG).map((e11) => e11(t107));
    let o10 = t107.contentDOM.ownerDocument;
    o10.addEventListener("mousemove", this.move = this.move.bind(this)), o10.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = e10.shiftKey, this.multiple = t107.state.facet(tW.allowMultipleSelections) && ((n10 = t107.state.facet(iS)).length ? n10[0](e10) : ej.mac ? e10.metaKey : e10.ctrlKey), this.dragging = !!function(t108, e11) {
      let { main: i11 } = t108.state.selection;
      if (i11.empty) return false;
      let s11 = eh(t108.root);
      if (!s11 || 0 == s11.rangeCount) return true;
      let n11 = s11.getRangeAt(0).getClientRects();
      for (let t109 = 0; t109 < n11.length; t109++) {
        let i12 = n11[t109];
        if (i12.left <= e11.clientX && i12.right >= e11.clientX && i12.top <= e11.clientY && i12.bottom >= e11.clientY) return true;
      }
      return false;
    }(t107, e10) && 1 == sy(e10) && null;
  }
  start(t107) {
    false === this.dragging && this.select(t107);
  }
  move(t107) {
    var e10;
    if (0 == t107.buttons) return this.destroy();
    if (this.dragging || null == this.dragging && 10 > Math.max(Math.abs((e10 = this.startEvent).clientX - t107.clientX), Math.abs(e10.clientY - t107.clientY))) return;
    this.select(this.lastEvent = t107);
    let i10 = 0, s10 = 0, n10 = 0, o10 = 0, r10 = this.view.win.innerWidth, l10 = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: n10, right: r10 } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: o10, bottom: l10 } = this.scrollParents.y.getBoundingClientRect());
    let h10 = i$(this.view);
    t107.clientX - h10.left <= n10 + 6 ? i10 = -sl(n10 - t107.clientX) : t107.clientX + h10.right >= r10 - 6 && (i10 = sl(t107.clientX - r10)), t107.clientY - h10.top <= o10 + 6 ? s10 = -sl(o10 - t107.clientY) : t107.clientY + h10.bottom >= l10 - 6 && (s10 = sl(t107.clientY - l10)), this.setScrollSpeed(i10, s10);
  }
  up(t107) {
    null == this.dragging && this.select(this.lastEvent), this.dragging || t107.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let t107 = this.view.contentDOM.ownerDocument;
    t107.removeEventListener("mousemove", this.move), t107.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(t107, e10) {
    this.scrollSpeed = { x: t107, y: e10 }, t107 || e10 ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: t107, y: e10 } = this.scrollSpeed;
    t107 && this.scrollParents.x && (this.scrollParents.x.scrollLeft += t107, t107 = 0), e10 && this.scrollParents.y && (this.scrollParents.y.scrollTop += e10, e10 = 0), (t107 || e10) && this.view.win.scrollBy(t107, e10), false === this.dragging && this.select(this.lastEvent);
  }
  skipAtoms(t107) {
    let e10 = null;
    for (let i10 = 0; i10 < t107.ranges.length; i10++) {
      let s10 = t107.ranges[i10], n10 = null;
      if (s10.empty) {
        let t108 = st(this.atoms, s10.from, 0);
        t108 != s10.from && (n10 = ti.cursor(t108, -1));
      } else {
        let t108 = st(this.atoms, s10.from, -1), e11 = st(this.atoms, s10.to, 1);
        (t108 != s10.from || e11 != s10.to) && (n10 = ti.range(s10.from == s10.anchor ? t108 : e11, s10.from == s10.head ? t108 : e11));
      }
      n10 && (e10 || (e10 = t107.ranges.slice()), e10[i10] = n10);
    }
    return e10 ? ti.create(e10, t107.mainIndex) : t107;
  }
  select(t107) {
    let { view: e10 } = this, i10 = this.skipAtoms(this.style.get(t107, this.extend, this.multiple));
    (this.mustSelect || !i10.eq(e10.state.selection, false === this.dragging)) && this.view.dispatch({ selection: i10, userEvent: "select.pointer" }), this.mustSelect = false;
  }
  update(t107) {
    t107.transactions.some((t108) => t108.isUserEvent("input.type")) ? this.destroy() : this.style.update(t107) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}, sa = /* @__PURE__ */ Object.create(null), sc = /* @__PURE__ */ Object.create(null), sd = ej.ie && ej.ie_version < 15 || ej.ios && ej.webkit_version < 604;
function su(t107, e10) {
  let { state: i10 } = t107, s10, n10 = 1, o10 = i10.toText(e10), r10 = o10.lines == i10.selection.ranges.length;
  if (null != sS && i10.selection.ranges.every((t108) => t108.empty) && sS == o10.toString()) {
    let t108 = -1;
    s10 = i10.changeByRange((s11) => {
      let l10 = i10.doc.lineAt(s11.from);
      if (l10.from == t108) return { range: s11 };
      t108 = l10.from;
      let h10 = i10.toText((r10 ? o10.line(n10++).text : e10) + i10.lineBreak);
      return { changes: { from: l10.from, insert: h10 }, range: ti.cursor(s11.from + h10.length) };
    });
  } else s10 = r10 ? i10.changeByRange((t108) => {
    let e11 = o10.line(n10++);
    return { changes: { from: t108.from, to: t108.to, insert: e11.text }, range: ti.cursor(t108.from + e11.length) };
  }) : i10.replaceSelection(o10);
  t107.dispatch(s10, { userEvent: "input.paste", scrollIntoView: true });
}
function sf(t107, e10, i10, s10) {
  if (1 == s10) return ti.cursor(e10, i10);
  if (2 == s10) return function(t108, e11) {
    let i11 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, s11 = t108.charCategorizer(e11), n10 = t108.doc.lineAt(e11), o10 = e11 - n10.from;
    if (0 == n10.length) return ti.cursor(e11);
    0 == o10 ? i11 = 1 : o10 == n10.length && (i11 = -1);
    let r10 = o10, l10 = o10;
    i11 < 0 ? r10 = v(n10.text, o10, false) : l10 = v(n10.text, o10);
    let h10 = s11(n10.text.slice(r10, l10));
    for (; r10 > 0; ) {
      let t109 = v(n10.text, r10, false);
      if (s11(n10.text.slice(t109, r10)) != h10) break;
      r10 = t109;
    }
    for (; l10 < n10.length; ) {
      let t109 = v(n10.text, l10);
      if (s11(n10.text.slice(l10, t109)) != h10) break;
      l10 = t109;
    }
    return ti.range(r10 + n10.from, l10 + n10.from);
  }(t107.state, e10, i10);
  {
    let i11 = e8.find(t107.docView, e10), s11 = t107.state.doc.lineAt(i11 ? i11.posAtEnd : e10), n10 = i11 ? i11.posAtStart : s11.from, o10 = i11 ? i11.posAtEnd : s11.to;
    return o10 < t107.state.doc.length && o10 == s11.to && o10++, ti.range(n10, o10);
  }
}
sc.scroll = (t107) => {
  t107.inputState.lastScrollTop = t107.scrollDOM.scrollTop, t107.inputState.lastScrollLeft = t107.scrollDOM.scrollLeft;
}, sa.keydown = (t107, e10) => (t107.inputState.setSelectionOrigin("select"), 27 == e10.keyCode && 0 != t107.inputState.tabFocusMode && (t107.inputState.tabFocusMode = Date.now() + 2e3), false), sc.touchstart = (t107, e10) => {
  t107.inputState.lastTouchTime = Date.now(), t107.inputState.setSelectionOrigin("select.pointer");
}, sc.touchmove = (t107) => {
  t107.inputState.setSelectionOrigin("select.pointer");
}, sa.mousedown = (t107, e10) => {
  let i10, s10, n10;
  if (t107.observer.flush(), t107.inputState.lastTouchTime > Date.now() - 2e3) return false;
  let o10 = null;
  for (let i11 of t107.state.facet(iM)) if (o10 = i11(t107, e10)) break;
  if (o10 || 0 != e10.button || (i10 = sp(t107, e10), s10 = sy(e10), n10 = t107.state.selection, o10 = { update(t108) {
    t108.docChanged && (i10.pos = t108.changes.mapPos(i10.pos), n10 = n10.map(t108.changes));
  }, get(e11, o11, r10) {
    let l10 = sp(t107, e11), h10, a10 = sf(t107, l10.pos, l10.bias, s10);
    if (i10.pos != l10.pos && !o11) {
      let e12 = sf(t107, i10.pos, i10.bias, s10), n11 = Math.min(e12.from, a10.from), o12 = Math.max(e12.to, a10.to);
      a10 = n11 < a10.from ? ti.range(n11, o12) : ti.range(o12, n11);
    }
    return o11 ? n10.replaceRange(n10.main.extend(a10.from, a10.to)) : r10 && 1 == s10 && n10.ranges.length > 1 && (h10 = function(t108, e12) {
      for (let i11 = 0; i11 < t108.ranges.length; i11++) {
        let { from: s11, to: n11 } = t108.ranges[i11];
        if (s11 <= e12 && n11 >= e12) return ti.create(t108.ranges.slice(0, i11).concat(t108.ranges.slice(i11 + 1)), t108.mainIndex == i11 ? 0 : t108.mainIndex - (t108.mainIndex > i11 ? 1 : 0));
      }
      return null;
    }(n10, l10.pos)) ? h10 : r10 ? n10.addRange(a10) : ti.create([a10]);
  } }), o10) {
    let i11 = !t107.hasFocus;
    t107.inputState.startMouseSelection(new sh(t107, e10, o10, i11)), i11 && t107.observer.ignore(() => {
      ex(t107.contentDOM);
      let e11 = t107.root.activeElement;
      e11 && !e11.contains(t107.contentDOM) && e11.blur();
    });
    let s11 = t107.inputState.mouseSelection;
    if (s11) return s11.start(e10), false === s11.dragging;
  }
  return false;
};
let sg = (t107, e10, i10) => e10 >= i10.top && e10 <= i10.bottom && t107 >= i10.left && t107 <= i10.right;
function sp(t107, e10) {
  let i10 = t107.posAtCoords({ x: e10.clientX, y: e10.clientY }, false);
  return { pos: i10, bias: function(t108, e11, i11, s10) {
    let n10 = e8.find(t108.docView, e11);
    if (!n10) return 1;
    let o10 = e11 - n10.posAtStart;
    if (0 == o10) return 1;
    if (o10 == n10.length) return -1;
    let r10 = n10.coordsAt(o10, -1);
    if (r10 && sg(i11, s10, r10)) return -1;
    let l10 = n10.coordsAt(o10, 1);
    return l10 && sg(i11, s10, l10) ? 1 : r10 && r10.bottom >= s10 ? -1 : 1;
  }(t107, i10, e10.clientX, e10.clientY) };
}
let sm = ej.ie && ej.ie_version <= 11, sv = null, sw = 0, sb = 0;
function sy(t107) {
  if (!sm) return t107.detail;
  let e10 = sv, i10 = sb;
  return sv = t107, sb = Date.now(), sw = !e10 || i10 > Date.now() - 400 && 2 > Math.abs(e10.clientX - t107.clientX) && 2 > Math.abs(e10.clientY - t107.clientY) ? (sw + 1) % 3 : 1;
}
function sx(t107, e10, i10, s10) {
  let n10;
  if (!i10) return;
  let o10 = t107.posAtCoords({ x: e10.clientX, y: e10.clientY }, false), { draggedContent: r10 } = t107.inputState, l10 = s10 && r10 && ((n10 = t107.state.facet(ik)).length ? n10[0](e10) : ej.mac ? !e10.altKey : !e10.ctrlKey) ? { from: r10.from, to: r10.to } : null, h10 = { from: o10, insert: i10 }, a10 = t107.state.changes(l10 ? [l10, h10] : h10);
  t107.focus(), t107.dispatch({ changes: a10, selection: { anchor: a10.mapPos(o10, -1), head: a10.mapPos(o10, 1) }, userEvent: l10 ? "move.drop" : "input.drop" }), t107.inputState.draggedContent = null;
}
sa.dragstart = (t107, e10) => {
  let { selection: { main: i10 } } = t107.state;
  if (e10.target.draggable) {
    let s11 = t107.docView.nearest(e10.target);
    if (s11 && s11.isWidget) {
      let t108 = s11.posAtStart, e11 = t108 + s11.length;
      (t108 >= i10.to || e11 <= i10.from) && (i10 = ti.range(t108, e11));
    }
  }
  let { inputState: s10 } = t107;
  return s10.mouseSelection && (s10.mouseSelection.dragging = true), s10.draggedContent = i10, e10.dataTransfer && (e10.dataTransfer.setData("Text", t107.state.sliceDoc(i10.from, i10.to)), e10.dataTransfer.effectAllowed = "copyMove"), false;
}, sa.dragend = (t107) => (t107.inputState.draggedContent = null, false), sa.drop = (t107, e10) => {
  if (!e10.dataTransfer) return false;
  if (t107.state.readOnly) return true;
  let i10 = e10.dataTransfer.files;
  if (i10 && i10.length) {
    let s10 = Array(i10.length), n10 = 0, o10 = () => {
      ++n10 == i10.length && sx(t107, e10, s10.filter((t108) => null != t108).join(t107.state.lineBreak), false);
    };
    for (let t108 = 0; t108 < i10.length; t108++) {
      let e11 = new FileReader();
      e11.onerror = o10, e11.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(e11.result) || (s10[t108] = e11.result), o10();
      }, e11.readAsText(i10[t108]);
    }
    return true;
  }
  {
    let i11 = e10.dataTransfer.getData("Text");
    if (i11) return sx(t107, e10, i11, true), true;
  }
  return false;
}, sa.paste = (t107, e10) => {
  if (t107.state.readOnly) return true;
  t107.observer.flush();
  let i10 = sd ? null : e10.clipboardData;
  return i10 ? (su(t107, i10.getData("text/plain") || i10.getData("text/uri-list")), true) : (function(t108) {
    let e11 = t108.dom.parentNode;
    if (!e11) return;
    let i11 = e11.appendChild(document.createElement("textarea"));
    i11.style.cssText = "position: fixed; left: -10000px; top: 10px", i11.focus(), setTimeout(() => {
      t108.focus(), i11.remove(), su(t108, i11.value);
    }, 50);
  }(t107), false);
};
let sS = null;
sa.copy = sa.cut = (t107, e10) => {
  let { text: i10, ranges: s10, linewise: n10 } = function(t108) {
    let e11 = [], i11 = [], s11 = false;
    for (let s12 of t108.selection.ranges) s12.empty || (e11.push(t108.sliceDoc(s12.from, s12.to)), i11.push(s12));
    if (!e11.length) {
      let n11 = -1;
      for (let { from: s12 } of t108.selection.ranges) {
        let o11 = t108.doc.lineAt(s12);
        o11.number > n11 && (e11.push(o11.text), i11.push({ from: o11.from, to: Math.min(t108.doc.length, o11.to + 1) })), n11 = o11.number;
      }
      s11 = true;
    }
    return { text: e11.join(t108.lineBreak), ranges: i11, linewise: s11 };
  }(t107.state);
  if (!i10 && !n10) return false;
  sS = n10 ? i10 : null, "cut" != e10.type || t107.state.readOnly || t107.dispatch({ changes: s10, scrollIntoView: true, userEvent: "delete.cut" });
  let o10 = sd ? null : e10.clipboardData;
  return o10 ? (o10.clearData(), o10.setData("text/plain", i10), true) : (!function(t108, e11) {
    let i11 = t108.dom.parentNode;
    if (!i11) return;
    let s11 = i11.appendChild(document.createElement("textarea"));
    s11.style.cssText = "position: fixed; left: -10000px; top: 10px", s11.value = e11, s11.focus(), s11.selectionEnd = e11.length, s11.selectionStart = 0, setTimeout(() => {
      s11.remove(), t108.focus();
    }, 50);
  }(t107, i10), false);
};
let sk = tO.define();
function sM(t107, e10) {
  let i10 = [];
  for (let s10 of t107.facet(iO)) {
    let n10 = s10(t107, e10);
    n10 && i10.push(n10);
  }
  return i10 ? t107.update({ effects: i10, annotations: sk.of(true) }) : null;
}
function sC(t107) {
  setTimeout(() => {
    let e10 = t107.hasFocus;
    if (e10 != t107.inputState.notifiedFocused) {
      let i10 = sM(t107.state, e10);
      i10 ? t107.dispatch(i10) : t107.update([]);
    }
  }, 10);
}
sc.focus = (t107) => {
  t107.inputState.lastFocusTime = Date.now(), !t107.scrollDOM.scrollTop && (t107.inputState.lastScrollTop || t107.inputState.lastScrollLeft) && (t107.scrollDOM.scrollTop = t107.inputState.lastScrollTop, t107.scrollDOM.scrollLeft = t107.inputState.lastScrollLeft), sC(t107);
}, sc.blur = (t107) => {
  t107.observer.clearSelectionRange(), sC(t107);
}, sc.compositionstart = sc.compositionupdate = (t107) => {
  !t107.observer.editContext && (null == t107.inputState.compositionFirstChange && (t107.inputState.compositionFirstChange = true), t107.inputState.composing < 0 && (t107.inputState.composing = 0));
}, sc.compositionend = (t107) => {
  t107.observer.editContext || (t107.inputState.composing = -1, t107.inputState.compositionEndedAt = Date.now(), t107.inputState.compositionPendingKey = true, t107.inputState.compositionPendingChange = t107.observer.pendingRecords().length > 0, t107.inputState.compositionFirstChange = null, ej.chrome && ej.android ? t107.observer.flushSoon() : t107.inputState.compositionPendingChange ? Promise.resolve().then(() => t107.observer.flush()) : setTimeout(() => {
    t107.inputState.composing < 0 && t107.docView.hasComposition && t107.update([]);
  }, 50));
}, sc.contextmenu = (t107) => {
  t107.inputState.lastContextMenu = Date.now();
}, sa.beforeinput = (t107, e10) => {
  var i10;
  let s10;
  if (ej.chrome && ej.android && (s10 = sn.find((t108) => t108.inputType == e10.inputType)) && (t107.observer.delayAndroidKey(s10.key, s10.keyCode), "Backspace" == s10.key || "Delete" == s10.key)) {
    let e11 = (null === (i10 = window.visualViewport) || void 0 === i10 ? void 0 : i10.height) || 0;
    setTimeout(() => {
      var i11;
      ((null === (i11 = window.visualViewport) || void 0 === i11 ? void 0 : i11.height) || 0) > e11 + 10 && t107.hasFocus && (t107.contentDOM.blur(), t107.focus());
    }, 100);
  }
  return ej.ios && "deleteContentForward" == e10.inputType && t107.observer.flushSoon(), ej.safari && "insertText" == e10.inputType && t107.inputState.composing >= 0 && setTimeout(() => sc.compositionend(t107, e10), 20), false;
};
let sA = /* @__PURE__ */ new Set(), sD = ["pre-wrap", "normal", "pre-line", "break-spaces"], sO = false, sT = class {
  constructor(t107) {
    this.lineWrapping = t107, this.doc = r.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30;
  }
  heightForGap(t107, e10) {
    let i10 = this.doc.lineAt(e10).number - this.doc.lineAt(t107).number + 1;
    return this.lineWrapping && (i10 += Math.max(0, Math.ceil((e10 - t107 - i10 * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * i10;
  }
  heightForLine(t107) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((t107 - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(t107) {
    return this.doc = t107, this;
  }
  mustRefreshForWrapping(t107) {
    return sD.indexOf(t107) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(t107) {
    let e10 = false;
    for (let i10 = 0; i10 < t107.length; i10++) {
      let s10 = t107[i10];
      s10 < 0 ? i10++ : this.heightSamples[Math.floor(10 * s10)] || (e10 = true, this.heightSamples[Math.floor(10 * s10)] = true);
    }
    return e10;
  }
  refresh(t107, e10, i10, s10, n10, o10) {
    let r10 = sD.indexOf(t107) > -1, l10 = Math.round(e10) != Math.round(this.lineHeight) || this.lineWrapping != r10;
    if (this.lineWrapping = r10, this.lineHeight = e10, this.charWidth = i10, this.textHeight = s10, this.lineLength = n10, l10) {
      this.heightSamples = {};
      for (let t108 = 0; t108 < o10.length; t108++) {
        let e11 = o10[t108];
        e11 < 0 ? t108++ : this.heightSamples[Math.floor(10 * e11)] = true;
      }
    }
    return l10;
  }
}, sE = class {
  constructor(t107, e10) {
    this.from = t107, this.heights = e10, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}, sR = class t27 {
  constructor(t107, e10, i10, s10, n10) {
    this.from = t107, this.length = e10, this.top = i10, this.height = s10, this._content = n10;
  }
  get type() {
    return "number" == typeof this._content ? e9.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  get to() {
    return this.from + this.length;
  }
  get bottom() {
    return this.top + this.height;
  }
  get widget() {
    return this._content instanceof it ? this._content.widget : null;
  }
  get widgetLineBreaks() {
    return "number" == typeof this._content ? this._content : 0;
  }
  join(e10) {
    let i10 = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e10._content) ? e10._content : [e10]);
    return new t27(this.from, this.length + e10.length, this.top, this.height + e10.height, i10);
  }
};
var sB = ((O = sB || (sB = {}))[O.ByPos = 0] = "ByPos", O[O.ByHeight = 1] = "ByHeight", O[O.ByPosNoHeight = 2] = "ByPosNoHeight", O);
let sL = class t28 {
  constructor(t107, e10, i10 = 2) {
    this.length = t107, this.height = e10, this.flags = i10;
  }
  get outdated() {
    return (2 & this.flags) > 0;
  }
  set outdated(t107) {
    this.flags = (t107 ? 2 : 0) | -3 & this.flags;
  }
  setHeight(t107) {
    this.height != t107 && (Math.abs(this.height - t107) > 1e-3 && (sO = true), this.height = t107);
  }
  replace(e10, i10, s10) {
    return t28.of(s10);
  }
  decomposeLeft(t107, e10) {
    e10.push(this);
  }
  decomposeRight(t107, e10) {
    e10.push(this);
  }
  applyChanges(t107, e10, i10, s10) {
    let n10 = this, o10 = i10.doc;
    for (let r10 = s10.length - 1; r10 >= 0; r10--) {
      let { fromA: l10, toA: h10, fromB: a10, toB: c10 } = s10[r10], d10 = n10.lineAt(l10, sB.ByPosNoHeight, i10.setDoc(e10), 0, 0), u10 = d10.to >= h10 ? d10 : n10.lineAt(h10, sB.ByPosNoHeight, i10, 0, 0);
      for (c10 += u10.to - h10, h10 = u10.to; r10 > 0 && d10.from <= s10[r10 - 1].toA; ) l10 = s10[r10 - 1].fromA, a10 = s10[r10 - 1].fromB, r10--, l10 < d10.from && (d10 = n10.lineAt(l10, sB.ByPosNoHeight, i10, 0, 0));
      a10 += d10.from - l10, l10 = d10.from;
      let f10 = sI.build(i10.setDoc(o10), t107, a10, c10);
      n10 = sP(n10, n10.replace(l10, h10, f10));
    }
    return n10.updateHeight(i10, 0);
  }
  static empty() {
    return new sV(0, 0);
  }
  static of(e10) {
    if (1 == e10.length) return e10[0];
    let i10 = 0, s10 = e10.length, n10 = 0, o10 = 0;
    for (; ; ) if (i10 == s10) {
      if (n10 > 2 * o10) {
        let t107 = e10[i10 - 1];
        t107.break ? e10.splice(--i10, 1, t107.left, null, t107.right) : e10.splice(--i10, 1, t107.left, t107.right), s10 += 1 + t107.break, n10 -= t107.size;
      } else if (o10 > 2 * n10) {
        let t107 = e10[s10];
        t107.break ? e10.splice(s10, 1, t107.left, null, t107.right) : e10.splice(s10, 1, t107.left, t107.right), s10 += 2 + t107.break, o10 -= t107.size;
      } else break;
    } else if (n10 < o10) {
      let t107 = e10[i10++];
      t107 && (n10 += t107.size);
    } else {
      let t107 = e10[--s10];
      t107 && (o10 += t107.size);
    }
    let r10 = 0;
    return null == e10[i10 - 1] ? (r10 = 1, i10--) : null == e10[i10] && (r10 = 1, s10++), new sF(t28.of(e10.slice(0, i10)), r10, t28.of(e10.slice(s10)));
  }
};
function sP(t107, e10) {
  return t107 == e10 ? t107 : (t107.constructor != e10.constructor && (sO = true), e10);
}
sL.prototype.size = 1;
let sN = class extends sL {
  constructor(t107, e10, i10) {
    super(t107, e10), this.deco = i10;
  }
  blockAt(t107, e10, i10, s10) {
    return new sR(s10, this.length, i10, this.height, this.deco || 0);
  }
  lineAt(t107, e10, i10, s10, n10) {
    return this.blockAt(0, i10, s10, n10);
  }
  forEachLine(t107, e10, i10, s10, n10, o10) {
    t107 <= n10 + this.length && e10 >= n10 && o10(this.blockAt(0, i10, s10, n10));
  }
  updateHeight(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i10 = (arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 ? arguments[3] : void 0);
    return i10 && i10.from <= e10 && i10.more && this.setHeight(i10.heights[i10.index++]), this.outdated = false, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}, sV = class t29 extends sN {
  constructor(t107, e10) {
    super(t107, e10, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(t107, e10, i10, s10) {
    return new sR(s10, this.length, i10, this.height, this.breaks);
  }
  replace(e10, i10, s10) {
    let n10 = s10[0];
    return 1 == s10.length && (n10 instanceof t29 || n10 instanceof sH && 4 & n10.flags) && 10 > Math.abs(this.length - n10.length) ? (n10 instanceof sH ? n10 = new t29(n10.length, this.height) : n10.height = this.height, this.outdated || (n10.outdated = false), n10) : sL.of(s10);
  }
  updateHeight(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], s10 = arguments.length > 3 ? arguments[3] : void 0;
    return s10 && s10.from <= e10 && s10.more ? this.setHeight(s10.heights[s10.index++]) : (i10 || this.outdated) && this.setHeight(Math.max(this.widgetHeight, t107.heightForLine(this.length - this.collapsed)) + this.breaks * t107.lineHeight), this.outdated = false, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}, sH = class t30 extends sL {
  constructor(t107) {
    super(t107, 0);
  }
  heightMetrics(t107, e10) {
    let i10 = t107.doc.lineAt(e10).number, s10 = t107.doc.lineAt(e10 + this.length).number, n10 = s10 - i10 + 1, o10, r10 = 0;
    if (t107.lineWrapping) {
      let e11 = Math.min(this.height, t107.lineHeight * n10);
      o10 = e11 / n10, this.length > n10 + 1 && (r10 = (this.height - e11) / (this.length - n10 - 1));
    } else o10 = this.height / n10;
    return { firstLine: i10, lastLine: s10, perLine: o10, perChar: r10 };
  }
  blockAt(t107, e10, i10, s10) {
    let { firstLine: n10, lastLine: o10, perLine: r10, perChar: l10 } = this.heightMetrics(e10, s10);
    if (e10.lineWrapping) {
      let n11 = s10 + (t107 < e10.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (t107 - i10) / this.height)) * this.length)), o11 = e10.doc.lineAt(n11), h10 = r10 + o11.length * l10, a10 = Math.max(i10, t107 - h10 / 2);
      return new sR(o11.from, o11.length, a10, h10, 0);
    }
    {
      let s11 = Math.max(0, Math.min(o10 - n10, Math.floor((t107 - i10) / r10))), { from: l11, length: h10 } = e10.doc.line(n10 + s11);
      return new sR(l11, h10, i10 + r10 * s11, r10, 0);
    }
  }
  lineAt(t107, e10, i10, s10, n10) {
    if (e10 == sB.ByHeight) return this.blockAt(t107, i10, s10, n10);
    if (e10 == sB.ByPosNoHeight) {
      let { from: e11, to: s11 } = i10.doc.lineAt(t107);
      return new sR(e11, s11 - e11, 0, 0, 0);
    }
    let { firstLine: o10, perLine: r10, perChar: l10 } = this.heightMetrics(i10, n10), h10 = i10.doc.lineAt(t107), a10 = r10 + h10.length * l10, c10 = h10.number - o10, d10 = s10 + r10 * c10 + l10 * (h10.from - n10 - c10);
    return new sR(h10.from, h10.length, Math.max(s10, Math.min(d10, s10 + this.height - a10)), a10, 0);
  }
  forEachLine(t107, e10, i10, s10, n10, o10) {
    t107 = Math.max(t107, n10), e10 = Math.min(e10, n10 + this.length);
    let { firstLine: r10, perLine: l10, perChar: h10 } = this.heightMetrics(i10, n10);
    for (let a10 = t107, c10 = s10; a10 <= e10; ) {
      let e11 = i10.doc.lineAt(a10);
      if (a10 == t107) {
        let i11 = e11.number - r10;
        c10 += l10 * i11 + h10 * (t107 - n10 - i11);
      }
      let s11 = l10 + h10 * e11.length;
      o10(new sR(e11.from, e11.length, c10, s11, 0)), c10 += s11, a10 = e11.to + 1;
    }
  }
  replace(e10, i10, s10) {
    let n10 = this.length - i10;
    if (n10 > 0) {
      let e11 = s10[s10.length - 1];
      e11 instanceof t30 ? s10[s10.length - 1] = new t30(e11.length + n10) : s10.push(null, new t30(n10 - 1));
    }
    if (e10 > 0) {
      let i11 = s10[0];
      i11 instanceof t30 ? s10[0] = new t30(e10 + i11.length) : s10.unshift(new t30(e10 - 1), null);
    }
    return sL.of(s10);
  }
  decomposeLeft(e10, i10) {
    i10.push(new t30(e10 - 1), null);
  }
  decomposeRight(e10, i10) {
    i10.push(null, new t30(this.length - e10 - 1));
  }
  updateHeight(e10) {
    let i10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, s10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n10 = arguments.length > 3 ? arguments[3] : void 0, o10 = i10 + this.length;
    if (n10 && n10.from <= i10 + this.length && n10.more) {
      let s11 = [], r10 = Math.max(i10, n10.from), l10 = -1;
      for (n10.from > i10 && s11.push(new t30(n10.from - i10 - 1).updateHeight(e10, i10)); r10 <= o10 && n10.more; ) {
        let t107 = e10.doc.lineAt(r10).length;
        s11.length && s11.push(null);
        let i11 = n10.heights[n10.index++];
        -1 == l10 ? l10 = i11 : Math.abs(i11 - l10) >= 1e-3 && (l10 = -2);
        let o11 = new sV(t107, i11);
        o11.outdated = false, s11.push(o11), r10 += t107 + 1;
      }
      r10 <= o10 && s11.push(null, new t30(o10 - r10).updateHeight(e10, r10));
      let h10 = sL.of(s11);
      return (l10 < 0 || Math.abs(h10.height - this.height) >= 1e-3 || Math.abs(l10 - this.heightMetrics(e10, i10).perLine) >= 1e-3) && (sO = true), sP(this, h10);
    }
    return (s10 || this.outdated) && (this.setHeight(e10.heightForGap(i10, i10 + this.length)), this.outdated = false), this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}, sF = class extends sL {
  constructor(t107, e10, i10) {
    super(t107.length + e10 + i10.length, t107.height + i10.height, e10 | (t107.outdated || i10.outdated ? 2 : 0)), this.left = t107, this.right = i10, this.size = t107.size + i10.size;
  }
  get break() {
    return 1 & this.flags;
  }
  blockAt(t107, e10, i10, s10) {
    let n10 = i10 + this.left.height;
    return t107 < n10 ? this.left.blockAt(t107, e10, i10, s10) : this.right.blockAt(t107, e10, n10, s10 + this.left.length + this.break);
  }
  lineAt(t107, e10, i10, s10, n10) {
    let o10 = s10 + this.left.height, r10 = n10 + this.left.length + this.break, l10 = e10 == sB.ByHeight ? t107 < o10 : t107 < r10, h10 = l10 ? this.left.lineAt(t107, e10, i10, s10, n10) : this.right.lineAt(t107, e10, i10, o10, r10);
    if (this.break || (l10 ? h10.to < r10 : h10.from > r10)) return h10;
    let a10 = e10 == sB.ByPosNoHeight ? sB.ByPosNoHeight : sB.ByPos;
    return l10 ? h10.join(this.right.lineAt(r10, a10, i10, o10, r10)) : this.left.lineAt(r10, a10, i10, s10, n10).join(h10);
  }
  forEachLine(t107, e10, i10, s10, n10, o10) {
    let r10 = s10 + this.left.height, l10 = n10 + this.left.length + this.break;
    if (this.break) t107 < l10 && this.left.forEachLine(t107, e10, i10, s10, n10, o10), e10 >= l10 && this.right.forEachLine(t107, e10, i10, r10, l10, o10);
    else {
      let h10 = this.lineAt(l10, sB.ByPos, i10, s10, n10);
      t107 < h10.from && this.left.forEachLine(t107, h10.from - 1, i10, s10, n10, o10), h10.to >= t107 && h10.from <= e10 && o10(h10), e10 > h10.to && this.right.forEachLine(h10.to + 1, e10, i10, r10, l10, o10);
    }
  }
  replace(t107, e10, i10) {
    let s10 = this.left.length + this.break;
    if (e10 < s10) return this.balanced(this.left.replace(t107, e10, i10), this.right);
    if (t107 > this.left.length) return this.balanced(this.left, this.right.replace(t107 - s10, e10 - s10, i10));
    let n10 = [];
    t107 > 0 && this.decomposeLeft(t107, n10);
    let o10 = n10.length;
    for (let t108 of i10) n10.push(t108);
    if (t107 > 0 && sW(n10, o10 - 1), e10 < this.length) {
      let t108 = n10.length;
      this.decomposeRight(e10, n10), sW(n10, t108);
    }
    return sL.of(n10);
  }
  decomposeLeft(t107, e10) {
    let i10 = this.left.length;
    if (t107 <= i10) return this.left.decomposeLeft(t107, e10);
    e10.push(this.left), this.break && t107 >= ++i10 && e10.push(null), t107 > i10 && this.right.decomposeLeft(t107 - i10, e10);
  }
  decomposeRight(t107, e10) {
    let i10 = this.left.length, s10 = i10 + this.break;
    if (t107 >= s10) return this.right.decomposeRight(t107 - s10, e10);
    t107 < i10 && this.left.decomposeRight(t107, e10), this.break && t107 < s10 && e10.push(null), e10.push(this.right);
  }
  balanced(t107, e10) {
    return t107.size > 2 * e10.size || e10.size > 2 * t107.size ? sL.of(this.break ? [t107, null, e10] : [t107, e10]) : (this.left = sP(this.left, t107), this.right = sP(this.right, e10), this.setHeight(t107.height + e10.height), this.outdated = t107.outdated || e10.outdated, this.size = t107.size + e10.size, this.length = t107.length + this.break + e10.length, this);
  }
  updateHeight(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], s10 = arguments.length > 3 ? arguments[3] : void 0, { left: n10, right: o10 } = this, r10 = e10 + n10.length + this.break, l10 = null;
    return (s10 && s10.from <= e10 + n10.length && s10.more ? l10 = n10 = n10.updateHeight(t107, e10, i10, s10) : n10.updateHeight(t107, e10, i10), s10 && s10.from <= r10 + o10.length && s10.more ? l10 = o10 = o10.updateHeight(t107, r10, i10, s10) : o10.updateHeight(t107, r10, i10), l10) ? this.balanced(n10, o10) : (this.height = this.left.height + this.right.height, this.outdated = false, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
};
function sW(t107, e10) {
  let i10, s10;
  null == t107[e10] && (i10 = t107[e10 - 1]) instanceof sH && (s10 = t107[e10 + 1]) instanceof sH && t107.splice(e10 - 1, 3, new sH(i10.length + 1 + s10.length));
}
let sI = class t31 {
  constructor(t107, e10) {
    this.pos = t107, this.oracle = e10, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = t107;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(t107, e10) {
    if (this.lineStart > -1) {
      let t108 = Math.min(e10, this.lineEnd), i10 = this.nodes[this.nodes.length - 1];
      i10 instanceof sV ? i10.length += t108 - this.pos : (t108 > this.pos || !this.isCovered) && this.nodes.push(new sV(t108 - this.pos, -1)), this.writtenTo = t108, e10 > t108 && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = e10;
  }
  point(t107, e10, i10) {
    if (t107 < e10 || i10.heightRelevant) {
      let s10 = i10.widget ? i10.widget.estimatedHeight : 0, n10 = i10.widget ? i10.widget.lineBreaks : 0;
      s10 < 0 && (s10 = this.oracle.lineHeight);
      let o10 = e10 - t107;
      i10.block ? this.addBlock(new sN(o10, s10, i10)) : (o10 || n10 || s10 >= 5) && this.addLineDeco(s10, n10, o10);
    } else e10 > t107 && this.span(t107, e10);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1) return;
    let { from: t107, to: e10 } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = t107, this.lineEnd = e10, this.writtenTo < t107 && ((this.writtenTo < t107 - 1 || null == this.nodes[this.nodes.length - 1]) && this.nodes.push(this.blankContent(this.writtenTo, t107 - 1)), this.nodes.push(null)), this.pos > t107 && this.nodes.push(new sV(this.pos - t107, -1)), this.writtenTo = this.pos;
  }
  blankContent(t107, e10) {
    let i10 = new sH(e10 - t107);
    return this.oracle.doc.lineAt(t107).to == e10 && (i10.flags |= 4), i10;
  }
  ensureLine() {
    this.enterLine();
    let t107 = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (t107 instanceof sV) return t107;
    let e10 = new sV(0, -1);
    return this.nodes.push(e10), e10;
  }
  addBlock(t107) {
    this.enterLine();
    let e10 = t107.deco;
    e10 && e10.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(t107), this.writtenTo = this.pos = this.pos + t107.length, e10 && e10.endSide > 0 && (this.covering = t107);
  }
  addLineDeco(t107, e10, i10) {
    let s10 = this.ensureLine();
    s10.length += i10, s10.collapsed += i10, s10.widgetHeight = Math.max(s10.widgetHeight, t107), s10.breaks += e10, this.writtenTo = this.pos = this.pos + i10;
  }
  finish(t107) {
    let e10 = 0 == this.nodes.length ? null : this.nodes[this.nodes.length - 1];
    !(this.lineStart > -1) || e10 instanceof sV || this.isCovered ? (this.writtenTo < this.pos || null == e10) && this.nodes.push(this.blankContent(this.writtenTo, this.pos)) : this.nodes.push(new sV(0, -1));
    let i10 = t107;
    for (let t108 of this.nodes) t108 instanceof sV && t108.updateHeight(this.oracle, i10), i10 += t108 ? t108.length : 1;
    return this.nodes;
  }
  static build(e10, i10, s10, n10) {
    let o10 = new t31(s10, e10);
    return tG.spans(i10, s10, n10, o10, 0), o10.finish(s10);
  }
}, sz = class {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(t107, e10, i10, s10) {
    (t107 < e10 || i10 && i10.heightRelevant || s10 && s10.heightRelevant) && ii(t107, e10, this.changes, 5);
  }
}, sK = class {
  constructor(t107, e10, i10) {
    this.from = t107, this.to = e10, this.size = i10;
  }
  static same(t107, e10) {
    if (t107.length != e10.length) return false;
    for (let i10 = 0; i10 < t107.length; i10++) {
      let s10 = t107[i10], n10 = e10[i10];
      if (s10.from != n10.from || s10.to != n10.to || s10.size != n10.size) return false;
    }
    return true;
  }
  draw(t107, e10) {
    return e5.replace({ widget: new sq(this.size * (e10 ? t107.scaleY : t107.scaleX), e10) }).range(this.from, this.to);
  }
}, sq = class extends e4 {
  constructor(t107, e10) {
    super(), this.size = t107, this.vertical = e10;
  }
  eq(t107) {
    return t107.size == this.size && t107.vertical == this.vertical;
  }
  toDOM() {
    let t107 = document.createElement("div");
    return this.vertical ? t107.style.height = this.size + "px" : (t107.style.width = this.size + "px", t107.style.height = "2px", t107.style.display = "inline-block"), t107;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}, s_ = class {
  constructor(t107) {
    this.state = t107, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = true, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = false, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = sY, this.scrollTarget = null, this.printing = false, this.mustMeasureContent = true, this.defaultTextDirection = il.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = false;
    let e10 = t107.facet(iK).some((t108) => "function" != typeof t108 && "cm-lineWrapping" == t108.class);
    this.heightOracle = new sT(e10), this.stateDeco = t107.facet(iq).filter((t108) => "function" != typeof t108), this.heightMap = sL.empty().applyChanges(this.stateDeco, r.empty, this.heightOracle.setDoc(t107.doc), [new iJ(0, 0, 0, t107.doc.length)]);
    for (let t108 = 0; t108 < 2 && (this.viewport = this.getViewport(0, null), this.updateForViewport()); t108++) ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = e5.set(this.lineGaps.map((t108) => t108.draw(this, false))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let t107 = [this.viewport], { main: e10 } = this.state.selection;
    for (let i10 = 0; i10 <= 1; i10++) {
      let s10 = i10 ? e10.head : e10.anchor;
      if (!t107.some((t108) => {
        let { from: e11, to: i11 } = t108;
        return s10 >= e11 && s10 <= i11;
      })) {
        let { from: e11, to: i11 } = this.lineBlockAt(s10);
        t107.push(new sG(e11, i11));
      }
    }
    return this.viewports = t107.sort((t108, e11) => t108.from - e11.from), this.updateScaler();
  }
  updateScaler() {
    let t107 = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? sY : new s$(this.heightOracle, this.heightMap, this.viewports), t107.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (t107) => {
      this.viewportLines.push(sX(t107, this.scaler));
    });
  }
  update(t107) {
    var e10, i10;
    let s10, n10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    this.state = t107.state;
    let o10 = this.stateDeco;
    this.stateDeco = this.state.facet(iq).filter((t108) => "function" != typeof t108);
    let r10 = t107.changedRanges, l10 = iJ.extendWithRanges(r10, (e10 = this.stateDeco, i10 = t107 ? t107.changes : Y.empty(this.state.doc.length), s10 = new sz(), tG.compare(o10, e10, i10, s10, 0), s10.changes)), h10 = this.heightMap.height, a10 = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    sO = false, this.heightMap = this.heightMap.applyChanges(this.stateDeco, t107.startState.doc, this.heightOracle.setDoc(this.state.doc), l10), (this.heightMap.height != h10 || sO) && (t107.flags |= 2), a10 ? (this.scrollAnchorPos = t107.changes.mapPos(a10.from, -1), this.scrollAnchorHeight = a10.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let c10 = l10.length ? this.mapViewport(this.viewport, t107.changes) : this.viewport;
    (n10 && (n10.range.head < c10.from || n10.range.head > c10.to) || !this.viewportIsAppropriate(c10)) && (c10 = this.getViewport(0, n10));
    let d10 = c10.from != this.viewport.from || c10.to != this.viewport.to;
    this.viewport = c10, t107.flags |= this.updateForViewport(), (d10 || !t107.changes.empty || 2 & t107.flags) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, t107.changes))), t107.flags |= this.computeVisibleRanges(), n10 && (this.scrollTarget = n10), !this.mustEnforceCursorAssoc && t107.selectionSet && t107.view.lineWrapping && t107.state.selection.main.empty && t107.state.selection.main.assoc && !t107.state.facet(iE) && (this.mustEnforceCursorAssoc = true);
  }
  measure(t107) {
    let e10 = t107.contentDOM, i10 = window.getComputedStyle(e10), s10 = this.heightOracle, n10 = i10.whiteSpace;
    this.defaultTextDirection = "rtl" == i10.direction ? il.RTL : il.LTR;
    let o10 = this.heightOracle.mustRefreshForWrapping(n10), l10 = e10.getBoundingClientRect(), h10 = o10 || this.mustMeasureContent || this.contentDOMHeight != l10.height;
    this.contentDOMHeight = l10.height, this.mustMeasureContent = false;
    let a10 = 0, c10 = 0;
    if (l10.width && l10.height) {
      let { scaleX: t108, scaleY: i11 } = ew(e10, l10);
      (t108 > 5e-3 && Math.abs(this.scaleX - t108) > 5e-3 || i11 > 5e-3 && Math.abs(this.scaleY - i11) > 5e-3) && (this.scaleX = t108, this.scaleY = i11, a10 |= 8, o10 = h10 = true);
    }
    let d10 = (parseInt(i10.paddingTop) || 0) * this.scaleY, u10 = (parseInt(i10.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != d10 || this.paddingBottom != u10) && (this.paddingTop = d10, this.paddingBottom = u10, a10 |= 10), this.editorWidth != t107.scrollDOM.clientWidth && (s10.lineWrapping && (h10 = true), this.editorWidth = t107.scrollDOM.clientWidth, a10 |= 8);
    let f10 = t107.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != f10 && (this.scrollAnchorHeight = -1, this.scrollTop = f10), this.scrolledToBottom = eC(t107.scrollDOM);
    let g10 = (this.printing ? function(t108, e11) {
      let i11 = t108.getBoundingClientRect();
      return { left: 0, right: i11.right - i11.left, top: e11, bottom: i11.bottom - (i11.top + e11) };
    } : function(t108, e11) {
      let i11 = t108.getBoundingClientRect(), s11 = t108.ownerDocument, n11 = s11.defaultView || window, o11 = Math.max(0, i11.left), r10 = Math.min(n11.innerWidth, i11.right), l11 = Math.max(0, i11.top), h11 = Math.min(n11.innerHeight, i11.bottom);
      for (let e12 = t108.parentNode; e12 && e12 != s11.body; ) if (1 == e12.nodeType) {
        let i12 = e12, s12 = window.getComputedStyle(i12);
        if ((i12.scrollHeight > i12.clientHeight || i12.scrollWidth > i12.clientWidth) && "visible" != s12.overflow) {
          let s13 = i12.getBoundingClientRect();
          o11 = Math.max(o11, s13.left), r10 = Math.min(r10, s13.right), l11 = Math.max(l11, s13.top), h11 = e12 == t108.parentNode ? s13.bottom : Math.min(h11, s13.bottom);
        }
        e12 = "absolute" == s12.position || "fixed" == s12.position ? i12.offsetParent : i12.parentNode;
      } else if (11 == e12.nodeType) e12 = e12.host;
      else break;
      return { left: o11 - i11.left, right: Math.max(o11, r10) - i11.left, top: l11 - (i11.top + e11), bottom: Math.max(l11, h11) - (i11.top + e11) };
    })(e10, this.paddingTop), p10 = g10.top - this.pixelViewport.top, m10 = g10.bottom - this.pixelViewport.bottom;
    this.pixelViewport = g10;
    let v10 = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (v10 != this.inView && (this.inView = v10, v10 && (h10 = true)), !this.inView && !this.scrollTarget) return 0;
    let w10 = l10.width;
    if ((this.contentDOMWidth != w10 || this.editorHeight != t107.scrollDOM.clientHeight) && (this.contentDOMWidth = l10.width, this.editorHeight = t107.scrollDOM.clientHeight, a10 |= 8), h10) {
      let e11 = t107.docView.measureVisibleLineHeights(this.viewport);
      if (s10.mustRefreshForHeights(e11) && (o10 = true), o10 || s10.lineWrapping && Math.abs(w10 - this.contentDOMWidth) > s10.charWidth) {
        let { lineHeight: i11, charWidth: r10, textHeight: l11 } = t107.docView.measureTextSize();
        (o10 = i11 > 0 && s10.refresh(n10, i11, r10, l11, w10 / r10, e11)) && (t107.docView.minWidth = 0, a10 |= 8);
      }
      for (let i11 of (p10 > 0 && m10 > 0 ? c10 = Math.max(p10, m10) : p10 < 0 && m10 < 0 && (c10 = Math.min(p10, m10)), sO = false, this.viewports)) {
        let n11 = i11.from == this.viewport.from ? e11 : t107.docView.measureVisibleLineHeights(i11);
        this.heightMap = (o10 ? sL.empty().applyChanges(this.stateDeco, r.empty, this.heightOracle, [new iJ(0, 0, 0, t107.state.doc.length)]) : this.heightMap).updateHeight(s10, 0, o10, new sE(i11.from, n11));
      }
      sO && (a10 |= 2);
    }
    let b10 = !this.viewportIsAppropriate(this.viewport, c10) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return b10 && (2 & a10 && (a10 |= this.updateScaler()), this.viewport = this.getViewport(c10, this.scrollTarget), a10 |= this.updateForViewport()), (2 & a10 || b10) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(o10 ? [] : this.lineGaps, t107)), a10 |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = false, t107.docView.enforceCursorAssoc()), a10;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(t107, e10) {
    let i10 = 0.5 - Math.max(-0.5, Math.min(0.5, t107 / 1e3 / 2)), s10 = this.heightMap, n10 = this.heightOracle, { visibleTop: o10, visibleBottom: r10 } = this, l10 = new sG(s10.lineAt(o10 - 1e3 * i10, sB.ByHeight, n10, 0, 0).from, s10.lineAt(r10 + (1 - i10) * 1e3, sB.ByHeight, n10, 0, 0).to);
    if (e10) {
      let { head: t108 } = e10.range;
      if (t108 < l10.from || t108 > l10.to) {
        let i11 = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), o11 = s10.lineAt(t108, sB.ByPos, n10, 0, 0), r11;
        r11 = "center" == e10.y ? (o11.top + o11.bottom) / 2 - i11 / 2 : "start" == e10.y || "nearest" == e10.y && t108 < l10.from ? o11.top : o11.bottom - i11, l10 = new sG(s10.lineAt(r11 - 500, sB.ByHeight, n10, 0, 0).from, s10.lineAt(r11 + i11 + 500, sB.ByHeight, n10, 0, 0).to);
      }
    }
    return l10;
  }
  mapViewport(t107, e10) {
    let i10 = e10.mapPos(t107.from, -1), s10 = e10.mapPos(t107.to, 1);
    return new sG(this.heightMap.lineAt(i10, sB.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(s10, sB.ByPos, this.heightOracle, 0, 0).to);
  }
  viewportIsAppropriate(t107) {
    let { from: e10, to: i10 } = t107, s10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    if (!this.inView) return true;
    let { top: n10 } = this.heightMap.lineAt(e10, sB.ByPos, this.heightOracle, 0, 0), { bottom: o10 } = this.heightMap.lineAt(i10, sB.ByPos, this.heightOracle, 0, 0), { visibleTop: r10, visibleBottom: l10 } = this;
    return (0 == e10 || n10 <= r10 - Math.max(10, Math.min(-s10, 250))) && (i10 == this.state.doc.length || o10 >= l10 + Math.max(10, Math.min(s10, 250))) && n10 > r10 - 2e3 && o10 < l10 + 2e3;
  }
  mapLineGaps(t107, e10) {
    if (!t107.length || e10.empty) return t107;
    let i10 = [];
    for (let s10 of t107) e10.touchesRange(s10.from, s10.to) || i10.push(new sK(e10.mapPos(s10.from), e10.mapPos(s10.to), s10.size));
    return i10;
  }
  ensureLineGaps(t107, e10) {
    let i10 = this.heightOracle.lineWrapping, s10 = i10 ? 1e4 : 2e3, n10 = s10 >> 1, o10 = s10 << 1;
    if (this.defaultTextDirection != il.LTR && !i10) return [];
    let r10 = [], l10 = (s11, o11, h11, a10) => {
      if (o11 - s11 < n10) return;
      let c10 = this.state.selection.main, d10 = [c10.from];
      for (let t108 of (c10.empty || d10.push(c10.to), d10)) if (t108 > s11 && t108 < o11) {
        l10(s11, t108 - 10, h11, a10), l10(t108 + 10, o11, h11, a10);
        return;
      }
      let u10 = function(t108, e11) {
        for (let i11 of t108) if (e11(i11)) return i11;
      }(t107, (t108) => t108.from >= h11.from && t108.to <= h11.to && Math.abs(t108.from - s11) < n10 && Math.abs(t108.to - o11) < n10 && !d10.some((e11) => t108.from < e11 && t108.to > e11));
      if (!u10) {
        if (o11 < h11.to && e10 && i10 && e10.visibleRanges.some((t108) => t108.from <= o11 && t108.to >= o11)) {
          let t108 = e10.moveToLineBoundary(ti.cursor(o11), false, true).head;
          t108 > s11 && (o11 = t108);
        }
        u10 = new sK(s11, o11, this.gapSize(h11, s11, o11, a10));
      }
      r10.push(u10);
    }, h10 = (t108) => {
      var e11, n11, r11;
      let h11, a10, c10, d10, u10;
      if (t108.length < o10 || t108.type != e9.Text) return;
      let f10 = (e11 = t108.from, n11 = t108.to, r11 = this.stateDeco, c10 = [], d10 = e11, u10 = 0, tG.spans(r11, e11, n11, { span() {
      }, point(t109, e12) {
        t109 > d10 && (c10.push({ from: d10, to: t109 }), u10 += t109 - d10), d10 = e12;
      } }, 20), d10 < n11 && (c10.push({ from: d10, to: n11 }), u10 += n11 - d10), { total: u10, ranges: c10 });
      if (f10.total < o10) return;
      let g10 = this.scrollTarget ? this.scrollTarget.range.head : null;
      if (i10) {
        let e12, i11, n12 = s10 / this.heightOracle.lineLength * this.heightOracle.lineHeight;
        if (null != g10) {
          let s11 = sU(f10, g10), o11 = ((this.visibleBottom - this.visibleTop) / 2 + n12) / t108.height;
          e12 = s11 - o11, i11 = s11 + o11;
        } else e12 = (this.visibleTop - t108.top - n12) / t108.height, i11 = (this.visibleBottom - t108.top + n12) / t108.height;
        h11 = sj(f10, e12), a10 = sj(f10, i11);
      } else {
        let t109, e12, i11 = f10.total * this.heightOracle.charWidth, n12 = s10 * this.heightOracle.charWidth;
        if (null != g10) {
          let s11 = sU(f10, g10), o11 = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + n12) / i11;
          t109 = s11 - o11, e12 = s11 + o11;
        } else t109 = (this.pixelViewport.left - n12) / i11, e12 = (this.pixelViewport.right + n12) / i11;
        h11 = sj(f10, t109), a10 = sj(f10, e12);
      }
      h11 > t108.from && l10(t108.from, h11, t108, f10), a10 < t108.to && l10(a10, t108.to, t108, f10);
    };
    for (let t108 of this.viewportLines) Array.isArray(t108.type) ? t108.type.forEach(h10) : h10(t108);
    return r10;
  }
  gapSize(t107, e10, i10, s10) {
    let n10 = sU(s10, i10) - sU(s10, e10);
    return this.heightOracle.lineWrapping ? t107.height * n10 : s10.total * this.heightOracle.charWidth * n10;
  }
  updateLineGaps(t107) {
    sK.same(t107, this.lineGaps) || (this.lineGaps = t107, this.lineGapDeco = e5.set(t107.map((t108) => t108.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let t107 = this.stateDeco;
    this.lineGaps.length && (t107 = t107.concat(this.lineGapDeco));
    let e10 = [];
    tG.spans(t107, this.viewport.from, this.viewport.to, { span(t108, i11) {
      e10.push({ from: t108, to: i11 });
    }, point() {
    } }, 20);
    let i10 = e10.length != this.visibleRanges.length || this.visibleRanges.some((t108, i11) => t108.from != e10[i11].from || t108.to != e10[i11].to);
    return this.visibleRanges = e10, i10 ? 4 : 0;
  }
  lineBlockAt(t107) {
    return t107 >= this.viewport.from && t107 <= this.viewport.to && this.viewportLines.find((e10) => e10.from <= t107 && e10.to >= t107) || sX(this.heightMap.lineAt(t107, sB.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(t107) {
    return t107 >= this.viewportLines[0].top && t107 <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((e10) => e10.top <= t107 && e10.bottom >= t107) || sX(this.heightMap.lineAt(this.scaler.fromDOM(t107), sB.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(t107) {
    let e10 = this.lineBlockAtHeight(t107 + 8);
    return e10.from >= this.viewport.from || this.viewportLines[0].top - t107 > 200 ? e10 : this.viewportLines[0];
  }
  elementAtHeight(t107) {
    return sX(this.heightMap.blockAt(this.scaler.fromDOM(t107), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}, sG = class {
  constructor(t107, e10) {
    this.from = t107, this.to = e10;
  }
};
function sj(t107, e10) {
  let { total: i10, ranges: s10 } = t107;
  if (e10 <= 0) return s10[0].from;
  if (e10 >= 1) return s10[s10.length - 1].to;
  let n10 = Math.floor(i10 * e10);
  for (let t108 = 0; ; t108++) {
    let { from: e11, to: i11 } = s10[t108], o10 = i11 - e11;
    if (n10 <= o10) return e11 + n10;
    n10 -= o10;
  }
}
function sU(t107, e10) {
  let i10 = 0;
  for (let { from: s10, to: n10 } of t107.ranges) {
    if (e10 <= n10) {
      i10 += e10 - s10;
      break;
    }
    i10 += n10 - s10;
  }
  return i10 / t107.total;
}
let sY = { toDOM: (t107) => t107, fromDOM: (t107) => t107, scale: 1, eq(t107) {
  return t107 == this;
} }, s$ = class t32 {
  constructor(t107, e10, i10) {
    let s10 = 0, n10 = 0, o10 = 0;
    for (let r10 of (this.viewports = i10.map((i11) => {
      let { from: n11, to: o11 } = i11, r11 = e10.lineAt(n11, sB.ByPos, t107, 0, 0).top, l10 = e10.lineAt(o11, sB.ByPos, t107, 0, 0).bottom;
      return s10 += l10 - r11, { from: n11, to: o11, top: r11, bottom: l10, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - s10) / (e10.height - s10), this.viewports)) r10.domTop = o10 + (r10.top - n10) * this.scale, o10 = r10.domBottom = r10.domTop + (r10.bottom - r10.top), n10 = r10.bottom;
  }
  toDOM(t107) {
    for (let e10 = 0, i10 = 0, s10 = 0; ; e10++) {
      let n10 = e10 < this.viewports.length ? this.viewports[e10] : null;
      if (!n10 || t107 < n10.top) return s10 + (t107 - i10) * this.scale;
      if (t107 <= n10.bottom) return n10.domTop + (t107 - n10.top);
      i10 = n10.bottom, s10 = n10.domBottom;
    }
  }
  fromDOM(t107) {
    for (let e10 = 0, i10 = 0, s10 = 0; ; e10++) {
      let n10 = e10 < this.viewports.length ? this.viewports[e10] : null;
      if (!n10 || t107 < n10.domTop) return i10 + (t107 - s10) / this.scale;
      if (t107 <= n10.domBottom) return n10.top + (t107 - n10.domTop);
      i10 = n10.bottom, s10 = n10.domBottom;
    }
  }
  eq(e10) {
    return e10 instanceof t32 && this.scale == e10.scale && this.viewports.length == e10.viewports.length && this.viewports.every((t107, i10) => t107.from == e10.viewports[i10].from && t107.to == e10.viewports[i10].to);
  }
};
function sX(t107, e10) {
  if (1 == e10.scale) return t107;
  let i10 = e10.toDOM(t107.top), s10 = e10.toDOM(t107.bottom);
  return new sR(t107.from, t107.length, i10, s10 - i10, Array.isArray(t107._content) ? t107._content.map((t108) => sX(t108, e10)) : t107._content);
}
let sJ = to.define({ combine: (t107) => t107.join(" ") }), sQ = to.define({ combine: (t107) => t107.indexOf(true) > -1 }), sZ = t6.newName(), s0 = t6.newName(), s1 = t6.newName(), s2 = { "&light": "." + s0, "&dark": "." + s1 };
function s8(t107, e10, i10) {
  return new t6(e10, { finish: (e11) => /&/.test(e11) ? e11.replace(/&\w*/, (e12) => {
    if ("&" == e12) return t107;
    if (!i10 || !i10[e12]) throw RangeError(`Unsupported selector: ${e12}`);
    return i10[e12];
  }) : t107 + " " + e11 });
}
let s3 = s8("." + sZ, { "&": { position: "relative !important", boxSizing: "border-box", "&.cm-focused": { outline: "1px dotted #212121" }, display: "flex !important", flexDirection: "column" }, ".cm-scroller": { display: "flex !important", alignItems: "flex-start !important", fontFamily: "monospace", lineHeight: 1.4, height: "100%", overflowX: "auto", position: "relative", zIndex: 0 }, ".cm-content": { margin: 0, flexGrow: 2, flexShrink: 0, display: "block", whiteSpace: "pre", wordWrap: "normal", boxSizing: "border-box", minHeight: "100%", padding: "4px 0", outline: "none", "&[contenteditable=true]": { WebkitUserModify: "read-write-plaintext-only" } }, ".cm-lineWrapping": { whiteSpace_fallback: "pre-wrap", whiteSpace: "break-spaces", wordBreak: "break-word", overflowWrap: "anywhere", flexShrink: 1 }, "&light .cm-content": { caretColor: "black" }, "&dark .cm-content": { caretColor: "white" }, ".cm-line": { display: "block", padding: "0 2px 0 6px" }, ".cm-layer": { position: "absolute", left: 0, top: 0, contain: "size style", "& > *": { position: "absolute" } }, "&light .cm-selectionBackground": { background: "#d9d9d9" }, "&dark .cm-selectionBackground": { background: "#222" }, "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": { background: "#d7d4f0" }, "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": { background: "#233" }, ".cm-cursorLayer": { pointerEvents: "none" }, "&.cm-focused > .cm-scroller > .cm-cursorLayer": { animation: "steps(1) cm-blink 1.2s infinite" }, "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} }, "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} }, ".cm-cursor, .cm-dropCursor": { borderLeft: "1.2px solid black", marginLeft: "-0.6px", pointerEvents: "none" }, ".cm-cursor": { display: "none" }, "&dark .cm-cursor": { borderLeftColor: "#444" }, ".cm-dropCursor": { position: "absolute" }, "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": { display: "block" }, ".cm-iso": { unicodeBidi: "isolate" }, ".cm-announced": { position: "fixed", top: "-10000px" }, "@media print": { ".cm-announced": { display: "none" } }, "&light .cm-activeLine": { backgroundColor: "#cceeff44" }, "&dark .cm-activeLine": { backgroundColor: "#99eeff33" }, "&light .cm-specialChar": { color: "red" }, "&dark .cm-specialChar": { color: "#f78" }, ".cm-gutters": { flexShrink: 0, display: "flex", height: "100%", boxSizing: "border-box", insetInlineStart: 0, zIndex: 200 }, "&light .cm-gutters": { backgroundColor: "#f5f5f5", color: "#6c6c6c", borderRight: "1px solid #ddd" }, "&dark .cm-gutters": { backgroundColor: "#333338", color: "#ccc" }, ".cm-gutter": { display: "flex !important", flexDirection: "column", flexShrink: 0, boxSizing: "border-box", minHeight: "100%", overflow: "hidden" }, ".cm-gutterElement": { boxSizing: "border-box" }, ".cm-lineNumbers .cm-gutterElement": { padding: "0 3px 0 5px", minWidth: "20px", textAlign: "right", whiteSpace: "nowrap" }, "&light .cm-activeLineGutter": { backgroundColor: "#e2f2ff" }, "&dark .cm-activeLineGutter": { backgroundColor: "#222227" }, ".cm-panels": { boxSizing: "border-box", position: "sticky", left: 0, right: 0 }, "&light .cm-panels": { backgroundColor: "#f5f5f5", color: "black" }, "&light .cm-panels-top": { borderBottom: "1px solid #ddd" }, "&light .cm-panels-bottom": { borderTop: "1px solid #ddd" }, "&dark .cm-panels": { backgroundColor: "#333338", color: "white" }, ".cm-tab": { display: "inline-block", overflow: "hidden", verticalAlign: "bottom" }, ".cm-widgetBuffer": { verticalAlign: "text-top", height: "1em", width: 0, display: "inline" }, ".cm-placeholder": { color: "#888", display: "inline-block", verticalAlign: "top" }, ".cm-highlightSpace:before": { content: "attr(data-display)", position: "absolute", pointerEvents: "none", color: "#888" }, ".cm-highlightTab": { backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`, backgroundSize: "auto 100%", backgroundPosition: "right 90%", backgroundRepeat: "no-repeat" }, ".cm-trailingSpace": { backgroundColor: "#ff332255" }, ".cm-button": { verticalAlign: "middle", color: "inherit", fontSize: "70%", padding: ".2em 1em", borderRadius: "1px" }, "&light .cm-button": { backgroundImage: "linear-gradient(#eff1f5, #d9d9df)", border: "1px solid #888", "&:active": { backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)" } }, "&dark .cm-button": { backgroundImage: "linear-gradient(#393939, #111)", border: "1px solid #888", "&:active": { backgroundImage: "linear-gradient(#111, #333)" } }, ".cm-textfield": { verticalAlign: "middle", color: "inherit", fontSize: "70%", border: "1px solid silver", padding: ".2em .5em" }, "&light .cm-textfield": { backgroundColor: "white" }, "&dark .cm-textfield": { border: "1px solid #555", backgroundColor: "inherit" } }, s2), s4 = class {
  constructor(t107, e10) {
    this.points = t107, this.text = "", this.lineSeparator = e10.facet(tW.lineSeparator);
  }
  append(t107) {
    this.text += t107;
  }
  lineBreak() {
    this.text += "";
  }
  readRange(t107, e10) {
    if (!t107) return this;
    let i10 = t107.parentNode;
    for (let s10 = t107; ; ) {
      this.findPointBefore(i10, s10);
      let t108 = this.text.length;
      this.readNode(s10);
      let n10 = s10.nextSibling;
      if (n10 == e10) break;
      let o10 = eE.get(s10), r10 = eE.get(n10);
      (o10 && r10 ? o10.breakAfter : (o10 ? o10.breakAfter : eg(s10)) || eg(n10) && ("BR" != s10.nodeName || s10.cmIgnore) && this.text.length > t108) && this.lineBreak(), s10 = n10;
    }
    return this.findPointBefore(i10, e10), this;
  }
  readTextNode(t107) {
    let e10 = t107.nodeValue;
    for (let i10 of this.points) i10.node == t107 && (i10.pos = this.text.length + Math.min(i10.offset, e10.length));
    for (let i10 = 0, s10 = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let n10 = -1, o10 = 1, r10;
      if (this.lineSeparator ? (n10 = e10.indexOf(this.lineSeparator, i10), o10 = this.lineSeparator.length) : (r10 = s10.exec(e10)) && (n10 = r10.index, o10 = r10[0].length), this.append(e10.slice(i10, n10 < 0 ? e10.length : n10)), n10 < 0) break;
      if (this.lineBreak(), o10 > 1) for (let e11 of this.points) e11.node == t107 && e11.pos > this.text.length && (e11.pos -= o10 - 1);
      i10 = n10 + o10;
    }
  }
  readNode(t107) {
    if (t107.cmIgnore) return;
    let e10 = eE.get(t107), i10 = e10 && e10.overrideDOMText;
    if (null != i10) {
      this.findPointInside(t107, i10.length);
      for (let t108 = i10.iter(); !t108.next().done; ) t108.lineBreak ? this.lineBreak() : this.append(t108.value);
    } else 3 == t107.nodeType ? this.readTextNode(t107) : "BR" == t107.nodeName ? t107.nextSibling && this.lineBreak() : 1 == t107.nodeType && this.readRange(t107.firstChild, null);
  }
  findPointBefore(t107, e10) {
    for (let i10 of this.points) i10.node == t107 && t107.childNodes[i10.offset] == e10 && (i10.pos = this.text.length);
  }
  findPointInside(t107, e10) {
    for (let i10 of this.points) (3 == t107.nodeType ? i10.node == t107 : t107.contains(i10.node)) && (i10.pos = this.text.length + (!function(t108, e11, i11) {
      for (; ; ) {
        if (!e11 || i11 < em(e11)) return false;
        if (e11 == t108) return true;
        i11 = ef(e11) + 1, e11 = e11.parentNode;
      }
    }(t107, i10.node, i10.offset) ? 0 : e10));
  }
}, s9 = class {
  constructor(t107, e10) {
    this.node = t107, this.offset = e10, this.pos = -1;
  }
}, s5 = class {
  constructor(t107, e10, i10, s10) {
    this.typeOver = s10, this.bounds = null, this.text = "", this.domChanged = e10 > -1;
    let { impreciseHead: n10, impreciseAnchor: o10 } = t107.docView;
    if (t107.state.readOnly && e10 > -1) this.newSel = null;
    else if (e10 > -1 && (this.bounds = t107.docView.domBoundsAround(e10, i10, 0))) {
      let e11 = n10 || o10 ? [] : function(t108) {
        let e12 = [];
        if (t108.root.activeElement != t108.contentDOM) return e12;
        let { anchorNode: i12, anchorOffset: s11, focusNode: n11, focusOffset: o11 } = t108.observer.selectionRange;
        return i12 && (e12.push(new s9(i12, s11)), (n11 != i12 || o11 != s11) && e12.push(new s9(n11, o11))), e12;
      }(t107), i11 = new s4(e11, t107.state);
      i11.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = i11.text, this.newSel = function(t108, e12) {
        if (0 == t108.length) return null;
        let i12 = t108[0].pos, s11 = 2 == t108.length ? t108[1].pos : i12;
        return i12 > -1 && s11 > -1 ? ti.single(i12 + e12, s11 + e12) : null;
      }(e11, this.bounds.from);
    } else {
      let e11 = t107.observer.selectionRange, i11 = n10 && n10.node == e11.focusNode && n10.offset == e11.focusOffset || !ea(t107.contentDOM, e11.focusNode) ? t107.state.selection.main.head : t107.docView.posFromDOM(e11.focusNode, e11.focusOffset), s11 = o10 && o10.node == e11.anchorNode && o10.offset == e11.anchorOffset || !ea(t107.contentDOM, e11.anchorNode) ? t107.state.selection.main.anchor : t107.docView.posFromDOM(e11.anchorNode, e11.anchorOffset), r10 = t107.viewport;
      if ((ej.ios || ej.chrome) && t107.state.selection.main.empty && i11 != s11 && (r10.from > 0 || r10.to < t107.state.doc.length)) {
        let e12 = Math.min(i11, s11), n11 = Math.max(i11, s11), o11 = r10.from - e12, l10 = r10.to - n11;
        (0 == o11 || 1 == o11 || 0 == e12) && (0 == l10 || -1 == l10 || n11 == t107.state.doc.length) && (i11 = 0, s11 = t107.state.doc.length);
      }
      this.newSel = ti.single(s11, i11);
    }
  }
};
function s6(t107, e10) {
  let i10;
  let { newSel: s10 } = e10, n10 = t107.state.selection.main, o10 = t107.inputState.lastKeyTime > Date.now() - 100 ? t107.inputState.lastKeyCode : -1;
  if (e10.bounds) {
    let { from: s11, to: l10 } = e10.bounds, h10 = n10.from, a10 = null;
    (8 === o10 || ej.android && e10.text.length < l10 - s11) && (h10 = n10.to, a10 = "end");
    let c10 = function(t108, e11, i11, s12) {
      let n11 = Math.min(t108.length, e11.length), o11 = 0;
      for (; o11 < n11 && t108.charCodeAt(o11) == e11.charCodeAt(o11); ) o11++;
      if (o11 == n11 && t108.length == e11.length) return null;
      let r10 = t108.length, l11 = e11.length;
      for (; r10 > 0 && l11 > 0 && t108.charCodeAt(r10 - 1) == e11.charCodeAt(l11 - 1); ) r10--, l11--;
      if ("end" == s12) {
        let t109 = Math.max(0, o11 - Math.min(r10, l11));
        i11 -= r10 + t109 - o11;
      }
      if (r10 < o11 && t108.length < e11.length) {
        let t109 = i11 <= o11 && i11 >= r10 ? o11 - i11 : 0;
        o11 -= t109, l11 = o11 + (l11 - r10), r10 = o11;
      } else if (l11 < o11) {
        let t109 = i11 <= o11 && i11 >= l11 ? o11 - i11 : 0;
        o11 -= t109, r10 = o11 + (r10 - l11), l11 = o11;
      }
      return { from: o11, toA: r10, toB: l11 };
    }(t107.state.doc.sliceString(s11, l10, ""), e10.text, h10 - s11, a10);
    c10 && (ej.chrome && 13 == o10 && c10.toB == c10.from + 2 && "" == e10.text.slice(c10.from, c10.toB) && c10.toB--, i10 = { from: s11 + c10.from, to: s11 + c10.toA, insert: r.of(e10.text.slice(c10.from, c10.toB).split("")) });
  } else s10 && (!t107.hasFocus && t107.state.facet(iV) || s10.main.eq(n10)) && (s10 = null);
  if (!i10 && !s10) return false;
  if (!i10 && e10.typeOver && !n10.empty && s10 && s10.main.empty ? i10 = { from: n10.from, to: n10.to, insert: t107.state.doc.slice(n10.from, n10.to) } : i10 && i10.from >= n10.from && i10.to <= n10.to && (i10.from != n10.from || i10.to != n10.to) && n10.to - n10.from - (i10.to - i10.from) <= 4 ? i10 = { from: n10.from, to: n10.to, insert: t107.state.doc.slice(n10.from, i10.from).append(i10.insert).append(t107.state.doc.slice(i10.to, n10.to)) } : (ej.mac || ej.android) && i10 && i10.from == i10.to && i10.from == n10.head - 1 && /^\. ?$/.test(i10.insert.toString()) && "off" == t107.contentDOM.getAttribute("autocorrect") ? (s10 && 2 == i10.insert.length && (s10 = ti.single(s10.main.anchor - 1, s10.main.head - 1)), i10 = { from: n10.from, to: n10.to, insert: r.of([" "]) }) : ej.chrome && i10 && i10.from == i10.to && i10.from == n10.head && "\n " == i10.insert.toString() && t107.lineWrapping && (s10 && (s10 = ti.single(s10.main.anchor - 1, s10.main.head - 1)), i10 = { from: n10.from, to: n10.to, insert: r.of([" "]) }), i10) return s7(t107, i10, s10, o10);
  if (!s10 || s10.main.eq(n10)) return false;
  {
    let e11 = false, i11 = "select";
    return t107.inputState.lastSelectionTime > Date.now() - 50 && ("select" == t107.inputState.lastSelectionOrigin && (e11 = true), i11 = t107.inputState.lastSelectionOrigin), t107.dispatch({ selection: s10, scrollIntoView: e11, userEvent: i11 }), true;
  }
}
function s7(t107, e10, i10) {
  let s10, n10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : -1;
  if (ej.ios && t107.inputState.flushIOSKey(e10)) return true;
  let o10 = t107.state.selection.main;
  if (ej.android && (e10.to == o10.to && (e10.from == o10.from || e10.from == o10.from - 1 && " " == t107.state.sliceDoc(e10.from, o10.from)) && 1 == e10.insert.length && 2 == e10.insert.lines && ek(t107.contentDOM, "Enter", 13) || (e10.from == o10.from - 1 && e10.to == o10.to && 0 == e10.insert.length || 8 == n10 && e10.insert.length < e10.to - e10.from && e10.to > o10.head) && ek(t107.contentDOM, "Backspace", 8) || e10.from == o10.from && e10.to == o10.to + 1 && 0 == e10.insert.length && ek(t107.contentDOM, "Delete", 46))) return true;
  let r10 = e10.insert.toString();
  t107.inputState.composing >= 0 && t107.inputState.composing++;
  let l10 = () => s10 || (s10 = function(t108, e11, i11) {
    let s11, n11 = t108.state, o11 = n11.selection.main;
    if (e11.from >= o11.from && e11.to <= o11.to && e11.to - e11.from >= (o11.to - o11.from) / 3 && (!i11 || i11.main.empty && i11.main.from == e11.from + e11.insert.length) && t108.inputState.composing < 0) {
      let i12 = o11.from < e11.from ? n11.sliceDoc(o11.from, e11.from) : "", r12 = o11.to > e11.to ? n11.sliceDoc(e11.to, o11.to) : "";
      s11 = n11.replaceSelection(t108.state.toText(i12 + e11.insert.sliceString(0, void 0, t108.state.lineBreak) + r12));
    } else {
      let r12 = n11.changes(e11), l11 = i11 && i11.main.to <= r12.newLength ? i11.main : void 0;
      if (n11.selection.ranges.length > 1 && t108.inputState.composing >= 0 && e11.to <= o11.to && e11.to >= o11.to - 10) {
        let h10 = t108.state.sliceDoc(e11.from, e11.to), a10, c10 = i11 && i1(t108, i11.main.head);
        if (c10) {
          let t109 = e11.insert.length - (e11.to - e11.from);
          a10 = { from: c10.from, to: c10.to - t109 };
        } else a10 = t108.state.doc.lineAt(o11.head);
        let d10 = o11.to - e11.to, u10 = o11.to - o11.from;
        s11 = n11.changeByRange((i12) => {
          if (i12.from == o11.from && i12.to == o11.to) return { changes: r12, range: l11 || i12.map(r12) };
          let s12 = i12.to - d10, c11 = s12 - h10.length;
          if (i12.to - i12.from != u10 || t108.state.sliceDoc(c11, s12) != h10 || i12.to >= a10.from && i12.from <= a10.to) return { range: i12 };
          let f10 = n11.changes({ from: c11, to: s12, insert: e11.insert }), g10 = i12.to - o11.to;
          return { changes: f10, range: l11 ? ti.range(Math.max(0, l11.anchor + g10), Math.max(0, l11.head + g10)) : i12.map(f10) };
        });
      } else s11 = { changes: r12, selection: l11 && n11.selection.replaceRange(l11) };
    }
    let r11 = "input.type";
    return (t108.composing || t108.inputState.compositionPendingChange && t108.inputState.compositionEndedAt > Date.now() - 50) && (t108.inputState.compositionPendingChange = false, r11 += ".compose", t108.inputState.compositionFirstChange && (r11 += ".start", t108.inputState.compositionFirstChange = false)), n11.update(s11, { userEvent: r11, scrollIntoView: true });
  }(t107, e10, i10));
  return t107.state.facet(iD).some((i11) => i11(t107, e10.from, e10.to, r10, l10)) || t107.dispatch(l10()), true;
}
let nt = { childList: true, characterData: true, subtree: true, attributes: true, characterDataOldValue: true }, ne = ej.ie && ej.ie_version <= 11, ni = class {
  constructor(t107) {
    this.view = t107, this.active = false, this.editContext = null, this.selectionRange = new eb(), this.selectionChanged = false, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = false, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = t107.contentDOM, this.observer = new MutationObserver((e10) => {
      for (let t108 of e10) this.queue.push(t108);
      (ej.ie && ej.ie_version <= 11 || ej.ios && t107.composing) && e10.some((t108) => "childList" == t108.type && t108.removedNodes.length || "characterData" == t108.type && t108.oldValue.length > t108.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && false !== t107.constructor.EDIT_CONTEXT && !(ej.chrome && ej.chrome_version < 126) && (this.editContext = new no(t107), t107.state.facet(iV) && (t107.contentDOM.editContext = this.editContext.editContext)), ne && (this.onCharData = (t108) => {
      this.queue.push({ target: t108.target, type: "characterData", oldValue: t108.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), "function" == typeof ResizeObserver && (this.resizeScroll = new ResizeObserver(() => {
      var t108;
      (null === (t108 = this.view.docView) || void 0 === t108 ? void 0 : t108.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(t107.scrollDOM)), this.addWindowListeners(this.win = t107.win), this.start(), "function" == typeof IntersectionObserver && (this.intersection = new IntersectionObserver((t108) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), t108.length > 0 && t108[t108.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((t108) => {
      t108.length > 0 && t108[t108.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(t107) {
    this.view.inputState.runHandlers("scroll", t107), this.intersecting && this.view.measure();
  }
  onScroll(t107) {
    this.intersecting && this.flush(false), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(t107);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(t107) {
    ("change" != t107.type && t107.type || t107.matches) && (this.view.viewState.printing = true, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = false, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(t107) {
    if (this.gapIntersection && (t107.length != this.gaps.length || this.gaps.some((e10, i10) => e10 != t107[i10]))) {
      for (let e10 of (this.gapIntersection.disconnect(), t107)) this.gapIntersection.observe(e10);
      this.gaps = t107;
    }
  }
  onSelectionChange(t107) {
    let e10 = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey) return;
    let { view: i10 } = this, s10 = this.selectionRange;
    if (i10.state.facet(iV) ? i10.root.activeElement != this.dom : !ec(i10.dom, s10)) return;
    let n10 = s10.anchorNode && i10.docView.nearest(s10.anchorNode);
    if (n10 && n10.ignoreEvent(t107)) {
      e10 || (this.selectionChanged = false);
      return;
    }
    (ej.ie && ej.ie_version <= 11 || ej.android && ej.chrome) && !i10.state.selection.main.empty && s10.focusNode && eu(s10.focusNode, s10.focusOffset, s10.anchorNode, s10.anchorOffset) ? this.flushSoon() : this.flush(false);
  }
  readSelectionRange() {
    let { view: t107 } = this, e10 = eh(t107.root);
    if (!e10) return false;
    let i10 = ej.safari && 11 == t107.root.nodeType && function(t108) {
      let e11 = t108.activeElement;
      for (; e11 && e11.shadowRoot; ) e11 = e11.shadowRoot.activeElement;
      return e11;
    }(this.dom.ownerDocument) == this.dom && function(t108, e11) {
      if (e11.getComposedRanges) {
        let i12 = e11.getComposedRanges(t108.root)[0];
        if (i12) return nn(t108, i12);
      }
      let i11 = null;
      function s11(t109) {
        t109.preventDefault(), t109.stopImmediatePropagation(), i11 = t109.getTargetRanges()[0];
      }
      return t108.contentDOM.addEventListener("beforeinput", s11, true), t108.dom.ownerDocument.execCommand("indent"), t108.contentDOM.removeEventListener("beforeinput", s11, true), i11 ? nn(t108, i11) : null;
    }(this.view, e10) || e10;
    if (!i10 || this.selectionRange.eq(i10)) return false;
    let s10 = ec(this.dom, i10);
    return s10 && !this.selectionChanged && t107.inputState.lastFocusTime > Date.now() - 200 && t107.inputState.lastTouchTime < Date.now() - 300 && function(t108, e11) {
      let i11 = e11.focusNode, s11 = e11.focusOffset;
      if (!i11 || e11.anchorNode != i11 || e11.anchorOffset != s11) return false;
      for (s11 = Math.min(s11, em(i11)); ; ) if (s11) {
        if (1 != i11.nodeType) return false;
        let t109 = i11.childNodes[s11 - 1];
        "false" == t109.contentEditable ? s11-- : s11 = em(i11 = t109);
      } else {
        if (i11 == t108) return true;
        s11 = ef(i11), i11 = i11.parentNode;
      }
    }(this.dom, i10) ? (this.view.inputState.lastFocusTime = 0, t107.docView.updateSelection(), false) : (this.selectionRange.setRange(i10), s10 && (this.selectionChanged = true), true);
  }
  setSelectionRange(t107, e10) {
    this.selectionRange.set(t107.node, t107.offset, e10.node, e10.offset), this.selectionChanged = false;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let t107 = 0, e10 = null;
    for (let i10 = this.dom; i10; ) if (1 == i10.nodeType) !e10 && t107 < this.scrollTargets.length && this.scrollTargets[t107] == i10 ? t107++ : e10 || (e10 = this.scrollTargets.slice(0, t107)), e10 && e10.push(i10), i10 = i10.assignedSlot || i10.parentNode;
    else if (11 == i10.nodeType) i10 = i10.host;
    else break;
    if (t107 < this.scrollTargets.length && !e10 && (e10 = this.scrollTargets.slice(0, t107)), e10) {
      for (let t108 of this.scrollTargets) t108.removeEventListener("scroll", this.onScroll);
      for (let t108 of this.scrollTargets = e10) t108.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(t107) {
    if (!this.active) return t107();
    try {
      return this.stop(), t107();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, nt), ne && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = true);
  }
  stop() {
    this.active && (this.active = false, this.observer.disconnect(), ne && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = false;
  }
  delayAndroidKey(t107, e10) {
    var i10;
    this.delayedAndroidKey || (this.flushingAndroidKey = this.view.win.requestAnimationFrame(() => {
      let t108 = this.delayedAndroidKey;
      t108 && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = t108.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && t108.force && ek(this.dom, t108.key, t108.keyCode));
    })), this.delayedAndroidKey && "Enter" != t107 || (this.delayedAndroidKey = { key: t107, keyCode: e10, force: this.lastChange < Date.now() - 50 || !!(null === (i10 = this.delayedAndroidKey) || void 0 === i10 ? void 0 : i10.force) });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let t107 of this.observer.takeRecords()) this.queue.push(t107);
    return this.queue;
  }
  processRecords() {
    let t107 = this.pendingRecords();
    t107.length && (this.queue = []);
    let e10 = -1, i10 = -1, s10 = false;
    for (let n10 of t107) {
      let t108 = this.readMutation(n10);
      t108 && (t108.typeOver && (s10 = true), -1 == e10 ? { from: e10, to: i10 } = t108 : (e10 = Math.min(t108.from, e10), i10 = Math.max(t108.to, i10)));
    }
    return { from: e10, to: i10, typeOver: s10 };
  }
  readChange() {
    let { from: t107, to: e10, typeOver: i10 } = this.processRecords(), s10 = this.selectionChanged && ec(this.dom, this.selectionRange);
    if (t107 < 0 && !s10) return null;
    t107 > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = false;
    let n10 = new s5(this.view, t107, e10, i10);
    return this.view.docView.domChanged = { newSel: n10.newSel ? n10.newSel.main : null }, n10;
  }
  flush() {
    let t107 = !(arguments.length > 0) || void 0 === arguments[0] || arguments[0];
    if (this.delayedFlush >= 0 || this.delayedAndroidKey) return false;
    t107 && this.readSelectionRange();
    let e10 = this.readChange();
    if (!e10) return this.view.requestMeasure(), false;
    let i10 = this.view.state, s10 = s6(this.view, e10);
    return this.view.state == i10 && (e10.domChanged || e10.newSel && !e10.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), s10;
  }
  readMutation(t107) {
    let e10 = this.view.docView.nearest(t107.target);
    if (!e10 || e10.ignoreMutation(t107)) return null;
    if (e10.markDirty("attributes" == t107.type), "attributes" == t107.type && (e10.flags |= 4), "childList" == t107.type) {
      let i10 = ns(e10, t107.previousSibling || t107.target.previousSibling, -1), s10 = ns(e10, t107.nextSibling || t107.target.nextSibling, 1);
      return { from: i10 ? e10.posAfter(i10) : e10.posAtStart, to: s10 ? e10.posBefore(s10) : e10.posAtEnd, typeOver: false };
    }
    return "characterData" == t107.type ? { from: e10.posAtStart, to: e10.posAtEnd, typeOver: t107.target.nodeValue == t107.oldValue } : null;
  }
  setWindow(t107) {
    t107 != this.win && (this.removeWindowListeners(this.win), this.win = t107, this.addWindowListeners(this.win));
  }
  addWindowListeners(t107) {
    t107.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener ? this.printQuery.addEventListener("change", this.onPrint) : this.printQuery.addListener(this.onPrint) : t107.addEventListener("beforeprint", this.onPrint), t107.addEventListener("scroll", this.onScroll), t107.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(t107) {
    t107.removeEventListener("scroll", this.onScroll), t107.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener ? this.printQuery.removeEventListener("change", this.onPrint) : this.printQuery.removeListener(this.onPrint) : t107.removeEventListener("beforeprint", this.onPrint), t107.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(t107) {
    this.editContext && (this.editContext.update(t107), t107.startState.facet(iV) != t107.state.facet(iV) && (t107.view.contentDOM.editContext = t107.state.facet(iV) ? this.editContext.editContext : null));
  }
  destroy() {
    var t107, e10, i10;
    for (let s10 of (this.stop(), null === (t107 = this.intersection) || void 0 === t107 || t107.disconnect(), null === (e10 = this.gapIntersection) || void 0 === e10 || e10.disconnect(), null === (i10 = this.resizeScroll) || void 0 === i10 || i10.disconnect(), this.scrollTargets)) s10.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
};
function ns(t107, e10, i10) {
  for (; e10; ) {
    let s10 = eE.get(e10);
    if (s10 && s10.parent == t107) return s10;
    let n10 = e10.parentNode;
    e10 = n10 != t107.dom ? n10 : i10 > 0 ? e10.nextSibling : e10.previousSibling;
  }
  return null;
}
function nn(t107, e10) {
  let i10 = e10.startContainer, s10 = e10.startOffset, n10 = e10.endContainer, o10 = e10.endOffset, r10 = t107.docView.domAtPos(t107.state.selection.main.anchor);
  return eu(r10.node, r10.offset, n10, o10) && ([i10, s10, n10, o10] = [n10, o10, i10, s10]), { anchorNode: i10, anchorOffset: s10, focusNode: n10, focusOffset: o10 };
}
let no = class {
  constructor(t107) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.resetRange(t107.state);
    let e10 = this.editContext = new window.EditContext({ text: t107.state.doc.sliceString(this.from, this.to), selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, t107.state.selection.main.anchor))), selectionEnd: this.toContextPos(t107.state.selection.main.head) });
    for (let i10 in this.handlers.textupdate = (e11) => {
      let { anchor: i11 } = t107.state.selection.main, s10 = { from: this.toEditorPos(e11.updateRangeStart), to: this.toEditorPos(e11.updateRangeEnd), insert: r.of(e11.text.split("\n")) };
      s10.from == this.from && i11 < this.from ? s10.from = i11 : s10.to == this.to && i11 > this.to && (s10.to = i11), (s10.from != s10.to || s10.insert.length) && (this.pendingContextChange = s10, t107.state.readOnly || s7(t107, s10, ti.single(this.toEditorPos(e11.selectionStart), this.toEditorPos(e11.selectionEnd))), this.pendingContextChange && (this.revertPending(t107.state), this.setSelection(t107.state)));
    }, this.handlers.characterboundsupdate = (i11) => {
      let s10 = [], n10 = null;
      for (let e11 = this.toEditorPos(i11.rangeStart), o10 = this.toEditorPos(i11.rangeEnd); e11 < o10; e11++) {
        let i12 = t107.coordsForChar(e11);
        n10 = i12 && new DOMRect(i12.left, i12.top, i12.right - i12.left, i12.bottom - i12.top) || n10 || new DOMRect(), s10.push(n10);
      }
      e10.updateCharacterBounds(i11.rangeStart, s10);
    }, this.handlers.textformatupdate = (e11) => {
      let i11 = [];
      for (let t108 of e11.getTextFormats()) {
        let e12 = t108.underlineStyle, s10 = t108.underlineThickness;
        if ("None" != e12 && "None" != s10) {
          let n10 = `text-decoration: underline ${"Dashed" == e12 ? "dashed " : "Squiggle" == e12 ? "wavy " : ""}${"Thin" == s10 ? 1 : 2}px`;
          i11.push(e5.mark({ attributes: { style: n10 } }).range(this.toEditorPos(t108.rangeStart), this.toEditorPos(t108.rangeEnd)));
        }
      }
      t107.dispatch({ effects: iP.of(e5.set(i11)) });
    }, this.handlers.compositionstart = () => {
      t107.inputState.composing < 0 && (t107.inputState.composing = 0, t107.inputState.compositionFirstChange = true);
    }, this.handlers.compositionend = () => {
      t107.inputState.composing = -1, t107.inputState.compositionFirstChange = null;
    }, this.handlers) e10.addEventListener(i10, this.handlers[i10]);
    this.measureReq = { read: (t108) => {
      this.editContext.updateControlBounds(t108.contentDOM.getBoundingClientRect());
      let e11 = eh(t108.root);
      e11 && e11.rangeCount && this.editContext.updateSelectionBounds(e11.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(t107) {
    let e10 = 0, i10 = false, s10 = this.pendingContextChange;
    return t107.changes.iterChanges((n10, o10, r10, l10, h10) => {
      if (i10) return;
      let a10 = h10.length - (o10 - n10);
      if (s10 && o10 >= s10.to) {
        if (s10.from == n10 && s10.to == o10 && s10.insert.eq(h10)) {
          s10 = this.pendingContextChange = null, e10 += a10, this.to += a10;
          return;
        }
        s10 = null, this.revertPending(t107.state);
      }
      if (n10 += e10, (o10 += e10) <= this.from) this.from += a10, this.to += a10;
      else if (n10 < this.to) {
        if (n10 < this.from || o10 > this.to || this.to - this.from + h10.length > 3e4) {
          i10 = true;
          return;
        }
        this.editContext.updateText(this.toContextPos(n10), this.toContextPos(o10), h10.toString()), this.to += a10;
      }
      e10 += a10;
    }), s10 && !i10 && this.revertPending(t107.state), !i10;
  }
  update(t107) {
    let e10 = this.pendingContextChange;
    this.applyEdits(t107) && this.rangeIsValid(t107.state) ? (t107.docChanged || t107.selectionSet || e10) && this.setSelection(t107.state) : (this.pendingContextChange = null, this.resetRange(t107.state), this.editContext.updateText(0, this.editContext.text.length, t107.state.doc.sliceString(this.from, this.to)), this.setSelection(t107.state)), (t107.geometryChanged || t107.docChanged || t107.selectionSet) && t107.view.requestMeasure(this.measureReq);
  }
  resetRange(t107) {
    let { head: e10 } = t107.selection.main;
    this.from = Math.max(0, e10 - 1e4), this.to = Math.min(t107.doc.length, e10 + 1e4);
  }
  revertPending(t107) {
    let e10 = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(e10.from), this.toContextPos(e10.from + e10.insert.length), t107.doc.sliceString(e10.from, e10.to));
  }
  setSelection(t107) {
    let { main: e10 } = t107.selection, i10 = this.toContextPos(Math.max(this.from, Math.min(this.to, e10.anchor))), s10 = this.toContextPos(e10.head);
    (this.editContext.selectionStart != i10 || this.editContext.selectionEnd != s10) && this.editContext.updateSelection(i10, s10);
  }
  rangeIsValid(t107) {
    let { head: e10 } = t107.selection.main;
    return !(this.from > 0 && e10 - this.from < 500 || this.to < t107.doc.length && this.to - e10 < 500 || this.to - this.from > 3e4);
  }
  toEditorPos(t107) {
    return t107 + this.from;
  }
  toContextPos(t107) {
    return t107 - this.from;
  }
  destroy() {
    for (let t107 in this.handlers) this.editContext.removeEventListener(t107, this.handlers[t107]);
  }
}, nr = class t33 {
  get state() {
    return this.viewState.state;
  }
  get viewport() {
    return this.viewState.viewport;
  }
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  get inView() {
    return this.viewState.inView;
  }
  get composing() {
    return this.inputState.composing > 0;
  }
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  get root() {
    return this._root;
  }
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  constructor(t107 = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = false, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), t107.parent && t107.parent.appendChild(this.dom);
    let { dispatch: e10 } = t107;
    for (let i10 of (this.dispatchTransactions = t107.dispatchTransactions || e10 && ((t108) => t108.forEach((t109) => e10(t109, this))) || ((t108) => this.update(t108)), this.dispatch = this.dispatch.bind(this), this._root = t107.root || function(t108) {
      for (; t108; ) {
        if (t108 && (9 == t108.nodeType || 11 == t108.nodeType && t108.host)) return t108;
        t108 = t108.assignedSlot || t108.parentNode;
      }
      return null;
    }(t107.parent) || document, this.viewState = new s_(t107.state || tW.create(t107)), t107.scrollTo && t107.scrollTo.is(iL) && (this.viewState.scrollTarget = t107.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(iF).map((t108) => new iI(t108)), this.plugins)) i10.update(this);
    this.observer = new ni(this), this.inputState = new si(this), this.inputState.ensureHandlers(this.plugins), this.docView = new iZ(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure();
  }
  dispatch() {
    for (var t107 = arguments.length, e10 = Array(t107), i10 = 0; i10 < t107; i10++) e10[i10] = arguments[i10];
    let s10 = 1 == e10.length && e10[0] instanceof tB ? e10 : 1 == e10.length && Array.isArray(e10[0]) ? e10[0] : [this.state.update(...e10)];
    this.dispatchTransactions(s10, this);
  }
  update(t107) {
    if (0 != this.updateState) throw Error("Calls to EditorView.update are not allowed while an update is in progress");
    let e10 = false, i10 = false, s10, n10 = this.state;
    for (let e11 of t107) {
      if (e11.startState != n10) throw RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      n10 = e11.state;
    }
    if (this.destroyed) {
      this.viewState.state = n10;
      return;
    }
    let o10 = this.hasFocus, r10 = 0, l10 = null;
    t107.some((t108) => t108.annotation(sk)) ? (this.inputState.notifiedFocused = o10, r10 = 1) : o10 == this.inputState.notifiedFocused || (this.inputState.notifiedFocused = o10, (l10 = sM(n10, o10)) || (r10 = 1));
    let h10 = this.observer.delayedAndroidKey, a10 = null;
    if (h10 ? (this.observer.clearDelayedAndroidKey(), ((a10 = this.observer.readChange()) && !this.state.doc.eq(n10.doc) || !this.state.selection.eq(n10.selection)) && (a10 = null)) : this.observer.clear(), n10.facet(tW.phrases) != this.state.facet(tW.phrases)) return this.setState(n10);
    s10 = iQ.create(this, n10, t107), s10.flags |= r10;
    let c10 = this.viewState.scrollTarget;
    try {
      for (let e11 of (this.updateState = 2, t107)) {
        if (c10 && (c10 = c10.map(e11.changes)), e11.scrollIntoView) {
          let { main: t108 } = e11.state.selection;
          c10 = new iB(t108.empty ? t108 : ti.cursor(t108.head, t108.head > t108.anchor ? -1 : 1));
        }
        for (let t108 of e11.effects) t108.is(iL) && (c10 = t108.value.clip(this.state));
      }
      this.viewState.update(s10, c10), this.bidiCache = na.update(this.bidiCache, s10.changes), s10.empty || (this.updatePlugins(s10), this.inputState.update(s10)), e10 = this.docView.update(s10), this.state.facet(iX) != this.styleModules && this.mountStyles(), i10 = this.updateAttrs(), this.showAnnouncements(t107), this.docView.updateSelection(e10, t107.some((t108) => t108.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (s10.startState.facet(sJ) != s10.state.facet(sJ) && (this.viewState.mustMeasureContent = true), (e10 || i10 || c10 || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), e10 && this.docViewUpdate(), !s10.empty) for (let t108 of this.state.facet(iA)) try {
      t108(s10);
    } catch (t109) {
      iN(this.state, t109, "update listener");
    }
    (l10 || a10) && Promise.resolve().then(() => {
      l10 && this.state == l10.startState && this.dispatch(l10), a10 && !s6(this, a10) && h10.force && ek(this.contentDOM, h10.key, h10.keyCode);
    });
  }
  setState(t107) {
    if (0 != this.updateState) throw Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = t107;
      return;
    }
    this.updateState = 2;
    let e10 = this.hasFocus;
    try {
      for (let t108 of this.plugins) t108.destroy(this);
      for (let e11 of (this.viewState = new s_(t107), this.plugins = t107.facet(iF).map((t108) => new iI(t108)), this.pluginMap.clear(), this.plugins)) e11.update(this);
      this.docView.destroy(), this.docView = new iZ(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    e10 && this.focus(), this.requestMeasure();
  }
  updatePlugins(t107) {
    let e10 = t107.startState.facet(iF), i10 = t107.state.facet(iF);
    if (e10 != i10) {
      let s10 = [];
      for (let n10 of i10) {
        let i11 = e10.indexOf(n10);
        if (i11 < 0) s10.push(new iI(n10));
        else {
          let e11 = this.plugins[i11];
          e11.mustUpdate = t107, s10.push(e11);
        }
      }
      for (let e11 of this.plugins) e11.mustUpdate != t107 && e11.destroy(this);
      this.plugins = s10, this.pluginMap.clear();
    } else for (let e11 of this.plugins) e11.mustUpdate = t107;
    for (let t108 = 0; t108 < this.plugins.length; t108++) this.plugins[t108].update(this);
    e10 != i10 && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let t107 of this.plugins) {
      let e10 = t107.value;
      if (e10 && e10.docViewUpdate) try {
        e10.docViewUpdate(this);
      } catch (t108) {
        iN(this.state, t108, "doc view update listener");
      }
    }
  }
  measure() {
    let t107 = !(arguments.length > 0) || void 0 === arguments[0] || arguments[0];
    if (this.destroyed) return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, t107 && this.observer.forceFlush();
    let e10 = null, i10 = this.scrollDOM, s10 = i10.scrollTop * this.scaleY, { scrollAnchorPos: n10, scrollAnchorHeight: o10 } = this.viewState;
    Math.abs(s10 - this.viewState.scrollTop) > 1 && (o10 = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let t108 = 0; ; t108++) {
        if (o10 < 0) {
          if (eC(i10)) n10 = -1, o10 = this.viewState.heightMap.height;
          else {
            let t109 = this.viewState.scrollAnchorAt(s10);
            n10 = t109.from, o10 = t109.top;
          }
        }
        this.updateState = 1;
        let r10 = this.viewState.measure(this);
        if (!r10 && !this.measureRequests.length && null == this.viewState.scrollTarget) break;
        if (t108 > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let l10 = [];
        4 & r10 || ([this.measureRequests, l10] = [l10, this.measureRequests]);
        let h10 = l10.map((t109) => {
          try {
            return t109.read(this);
          } catch (t110) {
            return iN(this.state, t110), nh;
          }
        }), a10 = iQ.create(this, this.state, []), c10 = false;
        a10.flags |= r10, e10 ? e10.flags |= r10 : e10 = a10, this.updateState = 2, !a10.empty && (this.updatePlugins(a10), this.inputState.update(a10), this.updateAttrs(), (c10 = this.docView.update(a10)) && this.docViewUpdate());
        for (let t109 = 0; t109 < l10.length; t109++) if (h10[t109] != nh) try {
          let e11 = l10[t109];
          e11.write && e11.write(h10[t109], this);
        } catch (t110) {
          iN(this.state, t110);
        }
        if (c10 && this.docView.updateSelection(true), !a10.viewportChanged && 0 == this.measureRequests.length) {
          if (this.viewState.editorHeight) {
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, o10 = -1;
              continue;
            }
            {
              let t109 = (n10 < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(n10).top) - o10;
              if (t109 > 1 || t109 < -1) {
                s10 += t109, i10.scrollTop = s10 / this.scaleY, o10 = -1;
                continue;
              }
            }
          }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (e10 && !e10.empty) for (let t108 of this.state.facet(iA)) t108(e10);
  }
  get themeClasses() {
    return sZ + " " + (this.state.facet(sQ) ? s1 : s0) + " " + this.state.facet(sJ);
  }
  updateAttrs() {
    let t107 = nc(this, iz, { class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses }), e10 = { spellcheck: "false", autocorrect: "off", autocapitalize: "off", translate: "no", contenteditable: this.state.facet(iV) ? "true" : "false", class: "cm-content", style: `${ej.tabSize}: ${this.state.tabSize}`, role: "textbox", "aria-multiline": "true" };
    this.state.readOnly && (e10["aria-readonly"] = "true"), nc(this, iK, e10);
    let i10 = this.observer.ignore(() => {
      let i11 = e2(this.contentDOM, this.contentAttrs, e10), s10 = e2(this.dom, this.editorAttrs, t107);
      return i11 || s10;
    });
    return this.editorAttrs = t107, this.contentAttrs = e10, i10;
  }
  showAnnouncements(e10) {
    let i10 = true;
    for (let s10 of e10) for (let e11 of s10.effects) e11.is(t33.announce) && (i10 && (this.announceDOM.textContent = ""), i10 = false, this.announceDOM.appendChild(document.createElement("div")).textContent = e11.value);
  }
  mountStyles() {
    this.styleModules = this.state.facet(iX);
    let e10 = this.state.facet(t33.cspNonce);
    t6.mount(this.root, this.styleModules.concat(s3).reverse(), e10 ? { nonce: e10 } : void 0);
  }
  readMeasured() {
    if (2 == this.updateState) throw Error("Reading the editor layout isn't allowed during an update");
    0 == this.updateState && this.measureScheduled > -1 && this.measure(false);
  }
  requestMeasure(t107) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), t107 && !(this.measureRequests.indexOf(t107) > -1)) {
      if (null != t107.key) {
        for (let e10 = 0; e10 < this.measureRequests.length; e10++) if (this.measureRequests[e10].key === t107.key) {
          this.measureRequests[e10] = t107;
          return;
        }
      }
      this.measureRequests.push(t107);
    }
  }
  plugin(t107) {
    let e10 = this.pluginMap.get(t107);
    return (void 0 === e10 || e10 && e10.spec != t107) && this.pluginMap.set(t107, e10 = this.plugins.find((e11) => e11.spec == t107) || null), e10 && e10.update(this).value;
  }
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  get scaleX() {
    return this.viewState.scaleX;
  }
  get scaleY() {
    return this.viewState.scaleY;
  }
  elementAtHeight(t107) {
    return this.readMeasured(), this.viewState.elementAtHeight(t107);
  }
  lineBlockAtHeight(t107) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(t107);
  }
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  lineBlockAt(t107) {
    return this.viewState.lineBlockAt(t107);
  }
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  moveByChar(t107, e10, i10) {
    return se(this, t107, i7(this, t107, e10, i10));
  }
  moveByGroup(t107, e10) {
    return se(this, t107, i7(this, t107, e10, (e11) => {
      var i10;
      let s10, n10;
      return i10 = t107.head, n10 = (s10 = this.state.charCategorizer(i10))(e11), (t108) => {
        let e12 = s10(t108);
        return n10 == tH.Space && (n10 = e12), n10 == e12;
      };
    }));
  }
  visualLineSide(t107, e10) {
    let i10 = this.bidiSpans(t107), s10 = this.textDirectionAt(t107.from), n10 = i10[e10 ? i10.length - 1 : 0];
    return ti.cursor(n10.side(e10, s10) + t107.from, n10.forward(!e10, s10) ? 1 : -1);
  }
  moveToLineBoundary(t107, e10) {
    let i10 = !(arguments.length > 2) || void 0 === arguments[2] || arguments[2];
    return function(t108, e11, i11, s10) {
      let n10 = function(t109, e12) {
        let i12 = t109.lineBlockAt(e12);
        if (Array.isArray(i12.type)) {
          for (let t110 of i12.type) if (t110.to > e12 || t110.to == e12 && (t110.to == i12.to || t110.type == e9.Text)) return t110;
        }
        return i12;
      }(t108, e11.head), o10 = s10 && n10.type == e9.Text && (t108.lineWrapping || n10.widgetLineBreaks) ? t108.coordsAtPos(e11.assoc < 0 && e11.head > n10.from ? e11.head - 1 : e11.head) : null;
      if (o10) {
        let e12 = t108.dom.getBoundingClientRect(), s11 = t108.textDirectionAt(n10.from), r10 = t108.posAtCoords({ x: i11 == (s11 == il.LTR) ? e12.right - 1 : e12.left + 1, y: (o10.top + o10.bottom) / 2 });
        if (null != r10) return ti.cursor(r10, i11 ? -1 : 1);
      }
      return ti.cursor(i11 ? n10.to : n10.from, i11 ? -1 : 1);
    }(this, t107, e10, i10);
  }
  moveVertically(t107, e10, i10) {
    return se(this, t107, function(t108, e11, i11, s10) {
      let n10 = e11.head, o10 = i11 ? 1 : -1;
      if (n10 == (i11 ? t108.state.doc.length : 0)) return ti.cursor(n10, e11.assoc);
      let r10 = e11.goalColumn, l10, h10 = t108.contentDOM.getBoundingClientRect(), a10 = t108.coordsAtPos(n10, e11.assoc || -1), c10 = t108.documentTop;
      if (a10) null == r10 && (r10 = a10.left - h10.left), l10 = o10 < 0 ? a10.top : a10.bottom;
      else {
        let e12 = t108.viewState.lineBlockAt(n10);
        null == r10 && (r10 = Math.min(h10.right - h10.left, t108.defaultCharacterWidth * (n10 - e12.from))), l10 = (o10 < 0 ? e12.top : e12.bottom) + c10;
      }
      let d10 = h10.left + r10, u10 = null != s10 ? s10 : t108.viewState.heightOracle.textHeight >> 1;
      for (let e12 = 0; ; e12 += 10) {
        let i12 = l10 + (u10 + e12) * o10, s11 = i5(t108, { x: d10, y: i12 }, false, o10);
        if (i12 < h10.top || i12 > h10.bottom || (o10 < 0 ? s11 < n10 : s11 > n10)) {
          let e13 = t108.docView.coordsForChar(s11), n11 = !e13 || i12 < e13.top ? -1 : 1;
          return ti.cursor(s11, n11, void 0, r10);
        }
      }
    }(this, t107, e10, i10));
  }
  domAtPos(t107) {
    return this.docView.domAtPos(t107);
  }
  posAtDOM(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    return this.docView.posFromDOM(t107, e10);
  }
  posAtCoords(t107) {
    let e10 = !(arguments.length > 1) || void 0 === arguments[1] || arguments[1];
    return this.readMeasured(), i5(this, t107, e10);
  }
  coordsAtPos(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
    this.readMeasured();
    let i10 = this.docView.coordsAt(t107, e10);
    if (!i10 || i10.left == i10.right) return i10;
    let s10 = this.state.doc.lineAt(t107), n10 = this.bidiSpans(s10);
    return ev(i10, n10[iw.find(n10, t107 - s10.from, -1, e10)].dir == il.LTR == e10 > 0);
  }
  coordsForChar(t107) {
    return this.readMeasured(), this.docView.coordsForChar(t107);
  }
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  textDirectionAt(t107) {
    return !this.state.facet(iT) || t107 < this.viewport.from || t107 > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(t107));
  }
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  bidiSpans(t107) {
    if (t107.length > nl) return iy(t107.length);
    let e10 = this.textDirectionAt(t107.from), i10;
    for (let s11 of this.bidiCache) if (s11.from == t107.from && s11.dir == e10 && (s11.fresh || function t108(e11, i11) {
      if (e11.length != i11.length) return false;
      for (let s12 = 0; s12 < e11.length; s12++) {
        let n10 = e11[s12], o10 = i11[s12];
        if (n10.from != o10.from || n10.to != o10.to || n10.direction != o10.direction || !t108(n10.inner, o10.inner)) return false;
      }
      return true;
    }(s11.isolates, i10 = iU(this, t107)))) return s11.order;
    i10 || (i10 = iU(this, t107));
    let s10 = function(t108, e11, i11) {
      if (!t108) return [new iw(0, 0, e11 == ia ? 1 : 0)];
      if (e11 == ih && !i11.length && !iv.test(t108)) return iy(t108.length);
      if (i11.length) for (; t108.length > ib.length; ) ib[ib.length] = 256;
      let s11 = [], n10 = e11 == ih ? 0 : 1;
      return function t109(e12, i12, s12, n11, o10, r10, l10) {
        let h10 = i12 % 2 ? 2 : 1;
        (function(t110, e13, i13, s13, n12) {
          for (let o11 = 0; o11 <= s13.length; o11++) {
            let r11 = o11 ? s13[o11 - 1].to : e13, l11 = o11 < s13.length ? s13[o11].from : i13, h11 = o11 ? 256 : n12;
            for (let e14 = r11, i14 = h11, s14 = h11; e14 < l11; e14++) {
              let n13 = im(t110.charCodeAt(e14));
              512 == n13 ? n13 = i14 : 8 == n13 && 4 == s14 && (n13 = 16), ib[e14] = 4 == n13 ? 2 : n13, 7 & n13 && (s14 = n13), i14 = n13;
            }
            for (let t111 = r11, e14 = h11, s14 = h11; t111 < l11; t111++) {
              let n13 = ib[t111];
              if (128 == n13) t111 < l11 - 1 && e14 == ib[t111 + 1] && 24 & e14 ? n13 = ib[t111] = e14 : ib[t111] = 256;
              else if (64 == n13) {
                let n14 = t111 + 1;
                for (; n14 < l11 && 64 == ib[n14]; ) n14++;
                let o12 = t111 && 8 == e14 || n14 < i13 && 8 == ib[n14] ? 1 == s14 ? 1 : 8 : 256;
                for (let e15 = t111; e15 < n14; e15++) ib[e15] = o12;
                t111 = n14 - 1;
              } else 8 == n13 && 1 == s14 && (ib[t111] = 1);
              e14 = n13, 7 & n13 && (s14 = n13);
            }
          }
        })(e12, o10, r10, n11, h10), function(t110, e13, i13, s13, n12) {
          let o11 = 1 == n12 ? 2 : 1;
          for (let r11 = 0, l11 = 0, h11 = 0; r11 <= s13.length; r11++) {
            let a10 = r11 ? s13[r11 - 1].to : e13, c10 = r11 < s13.length ? s13[r11].from : i13;
            for (let e14 = a10, i14, s14, r12; e14 < c10; e14++) if (s14 = ig[i14 = t110.charCodeAt(e14)]) {
              if (s14 < 0) {
                for (let t111 = l11 - 3; t111 >= 0; t111 -= 3) if (ip[t111 + 1] == -s14) {
                  let i15 = ip[t111 + 2], s15 = 2 & i15 ? n12 : 4 & i15 ? 1 & i15 ? o11 : n12 : 0;
                  s15 && (ib[e14] = ib[ip[t111]] = s15), l11 = t111;
                  break;
                }
              } else if (189 == ip.length) break;
              else ip[l11++] = e14, ip[l11++] = i14, ip[l11++] = h11;
            } else if (2 == (r12 = ib[e14]) || 1 == r12) {
              let t111 = r12 == n12;
              h11 = t111 ? 0 : 1;
              for (let e15 = l11 - 3; e15 >= 0; e15 -= 3) {
                let i15 = ip[e15 + 2];
                if (2 & i15) break;
                if (t111) ip[e15 + 2] |= 2;
                else {
                  if (4 & i15) break;
                  ip[e15 + 2] |= 4;
                }
              }
            }
          }
        }(e12, o10, r10, n11, h10), function(t110, e13, i13, s13) {
          for (let n12 = 0, o11 = s13; n12 <= i13.length; n12++) {
            let r11 = n12 ? i13[n12 - 1].to : t110, l11 = n12 < i13.length ? i13[n12].from : e13;
            for (let h11 = r11; h11 < l11; ) {
              let r12 = ib[h11];
              if (256 == r12) {
                let r13 = h11 + 1;
                for (; ; ) if (r13 == l11) {
                  if (n12 == i13.length) break;
                  r13 = i13[n12++].to, l11 = n12 < i13.length ? i13[n12].from : e13;
                } else if (256 == ib[r13]) r13++;
                else break;
                let a10 = 1 == o11, c10 = a10 == ((r13 < e13 ? ib[r13] : s13) == 1) ? a10 ? 1 : 2 : s13;
                for (let e14 = r13, s14 = n12, o12 = s14 ? i13[s14 - 1].to : t110; e14 > h11; ) e14 == o12 && (e14 = i13[--s14].from, o12 = s14 ? i13[s14 - 1].to : t110), ib[--e14] = c10;
                h11 = r13;
              } else o11 = r12, h11++;
            }
          }
        }(o10, r10, n11, h10), function e13(i13, s13, n12, o11, r11, l11, h11) {
          let a10 = o11 % 2 ? 2 : 1;
          if (o11 % 2 == r11 % 2) for (let c10 = s13, d10 = 0; c10 < n12; ) {
            let s14 = true, u10 = false;
            if (d10 == l11.length || c10 < l11[d10].from) {
              let t110 = ib[c10];
              t110 != a10 && (s14 = false, u10 = 16 == t110);
            }
            let f10 = s14 || 1 != a10 ? null : [], g10 = s14 ? o11 : o11 + 1, p10 = c10;
            e: for (; ; ) if (d10 < l11.length && p10 == l11[d10].from) {
              if (u10) break;
              let e14 = l11[d10];
              if (!s14) for (let t110 = e14.to, i14 = d10 + 1; ; ) {
                if (t110 == n12) break e;
                if (i14 < l11.length && l11[i14].from == t110) t110 = l11[i14++].to;
                else if (ib[t110] == a10) break e;
                else break;
              }
              d10++, f10 ? f10.push(e14) : (e14.from > c10 && h11.push(new iw(c10, e14.from, g10)), t109(i13, e14.direction == ih != !(g10 % 2) ? o11 + 1 : o11, r11, e14.inner, e14.from, e14.to, h11), c10 = e14.to), p10 = e14.to;
            } else if (p10 == n12 || (s14 ? ib[p10] != a10 : ib[p10] == a10)) break;
            else p10++;
            f10 ? e13(i13, c10, p10, o11 + 1, r11, f10, h11) : c10 < p10 && h11.push(new iw(c10, p10, g10)), c10 = p10;
          }
          else for (let c10 = n12, d10 = l11.length; c10 > s13; ) {
            let n13 = true, u10 = false;
            if (!d10 || c10 > l11[d10 - 1].to) {
              let t110 = ib[c10 - 1];
              t110 != a10 && (n13 = false, u10 = 16 == t110);
            }
            let f10 = n13 || 1 != a10 ? null : [], g10 = n13 ? o11 : o11 + 1, p10 = c10;
            e: for (; ; ) if (d10 && p10 == l11[d10 - 1].to) {
              if (u10) break;
              let e14 = l11[--d10];
              if (!n13) for (let t110 = e14.from, i14 = d10; ; ) {
                if (t110 == s13) break e;
                if (i14 && l11[i14 - 1].to == t110) t110 = l11[--i14].from;
                else if (ib[t110 - 1] == a10) break e;
                else break;
              }
              f10 ? f10.push(e14) : (e14.to < c10 && h11.push(new iw(e14.to, c10, g10)), t109(i13, e14.direction == ih != !(g10 % 2) ? o11 + 1 : o11, r11, e14.inner, e14.from, e14.to, h11), c10 = e14.from), p10 = e14.from;
            } else if (p10 == s13 || (n13 ? ib[p10 - 1] != a10 : ib[p10 - 1] == a10)) break;
            else p10--;
            f10 ? e13(i13, p10, c10, o11 + 1, r11, f10, h11) : p10 < c10 && h11.push(new iw(p10, c10, g10)), c10 = p10;
          }
        }(e12, o10, r10, i12, s12, n11, l10);
      }(t108, n10, n10, i11, 0, t108.length, s11), s11;
    }(t107.text, e10, i10);
    return this.bidiCache.push(new na(t107.from, t107.to, e10, i10, true, s10)), s10;
  }
  get hasFocus() {
    var t107;
    return (this.dom.ownerDocument.hasFocus() || ej.safari && (null === (t107 = this.inputState) || void 0 === t107 ? void 0 : t107.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  focus() {
    this.observer.ignore(() => {
      ex(this.contentDOM), this.docView.updateSelection();
    });
  }
  setRoot(t107) {
    this._root != t107 && (this._root = t107, this.observer.setWindow((9 == t107.nodeType ? t107 : t107.ownerDocument).defaultView || window), this.mountStyles());
  }
  destroy() {
    for (let t107 of (this.root.activeElement == this.contentDOM && this.contentDOM.blur(), this.plugins)) t107.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = true;
  }
  static scrollIntoView(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return iL.of(new iB("number" == typeof t107 ? ti.cursor(t107) : t107, e10.y, e10.x, e10.yMargin, e10.xMargin));
  }
  scrollSnapshot() {
    let { scrollTop: t107, scrollLeft: e10 } = this.scrollDOM, i10 = this.viewState.scrollAnchorAt(t107);
    return iL.of(new iB(ti.cursor(i10.from), "start", "start", i10.top - t107, e10, true));
  }
  setTabFocusMode(t107) {
    null == t107 ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : "boolean" == typeof t107 ? this.inputState.tabFocusMode = t107 ? 0 : -1 : 0 != this.inputState.tabFocusMode && (this.inputState.tabFocusMode = Date.now() + t107);
  }
  static domEventHandlers(t107) {
    return iW.define(() => ({}), { eventHandlers: t107 });
  }
  static domEventObservers(t107) {
    return iW.define(() => ({}), { eventObservers: t107 });
  }
  static theme(t107, e10) {
    let i10 = t6.newName(), s10 = [sJ.of(i10), iX.of(s8(`.${i10}`, t107))];
    return e10 && e10.dark && s10.push(sQ.of(true)), s10;
  }
  static baseTheme(t107) {
    return tg.lowest(iX.of(s8("." + sZ, t107, s2)));
  }
  static findFromDOM(t107) {
    var e10;
    let i10 = t107.querySelector(".cm-content"), s10 = i10 && eE.get(i10) || eE.get(t107);
    return (null === (e10 = null == s10 ? void 0 : s10.rootView) || void 0 === e10 ? void 0 : e10.view) || null;
  }
};
nr.styleModule = iX, nr.inputHandler = iD, nr.scrollHandler = iR, nr.focusChangeEffect = iO, nr.perLineTextDirection = iT, nr.exceptionSink = iC, nr.updateListener = iA, nr.editable = iV, nr.mouseSelectionStyle = iM, nr.dragMovesSelection = ik, nr.clickAddsSelectionRange = iS, nr.decorations = iq, nr.outerDecorations = i_, nr.atomicRanges = iG, nr.bidiIsolatedRanges = ij, nr.scrollMargins = iY, nr.darkTheme = sQ, nr.cspNonce = to.define({ combine: (t107) => t107.length ? t107[0] : "" }), nr.contentAttributes = iK, nr.editorAttributes = iz, nr.lineWrapping = nr.contentAttributes.of({ class: "cm-lineWrapping" }), nr.announce = tR.define();
let nl = 4096, nh = {}, na = class t34 {
  constructor(t107, e10, i10, s10, n10, o10) {
    this.from = t107, this.to = e10, this.dir = i10, this.isolates = s10, this.fresh = n10, this.order = o10;
  }
  static update(e10, i10) {
    if (i10.empty && !e10.some((t107) => t107.fresh)) return e10;
    let s10 = [], n10 = e10.length ? e10[e10.length - 1].dir : il.LTR;
    for (let o10 = Math.max(0, e10.length - 10); o10 < e10.length; o10++) {
      let r10 = e10[o10];
      r10.dir != n10 || i10.touchesRange(r10.from, r10.to) || s10.push(new t34(i10.mapPos(r10.from, 1), i10.mapPos(r10.to, -1), r10.dir, r10.isolates, false, r10.order));
    }
    return s10;
  }
};
function nc(t107, e10, i10) {
  for (let s10 = t107.state.facet(e10), n10 = s10.length - 1; n10 >= 0; n10--) {
    let e11 = s10[n10], o10 = "function" == typeof e11 ? e11(t107) : e11;
    o10 && eZ(o10, i10);
  }
  return i10;
}
let nd = ej.mac ? "mac" : ej.windows ? "win" : ej.linux ? "linux" : "key";
function nu(t107, e10, i10) {
  return e10.altKey && (t107 = "Alt-" + t107), e10.ctrlKey && (t107 = "Ctrl-" + t107), e10.metaKey && (t107 = "Meta-" + t107), false !== i10 && e10.shiftKey && (t107 = "Shift-" + t107), t107;
}
let nf = tg.default(nr.domEventHandlers({ keydown: (t107, e10) => {
  var i10, s10;
  let n10, o10, r10, l10, h10, a10, c10, d10, u10, f10, g10, p10, m10;
  return n10 = e10.state.facet(ng), (o10 = np.get(n10)) || np.set(n10, o10 = function(t108) {
    let e11 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : nd, i11 = /* @__PURE__ */ Object.create(null), s11 = /* @__PURE__ */ Object.create(null), n11 = (t109, e12) => {
      let i12 = s11[t109];
      if (null == i12) s11[t109] = e12;
      else if (i12 != e12) throw Error("Key binding " + t109 + " is used both as a regular binding and as a multi-stroke prefix");
    }, o11 = (t109, s12, o12, r11, l11) => {
      var h11, a11;
      let c11 = i11[t109] || (i11[t109] = /* @__PURE__ */ Object.create(null)), d11 = s12.split(/ (?!$)/).map((t110) => function(t111, e12) {
        let i12, s13, n12, o13;
        let r12 = t111.split(/-(?!$)/), l12 = r12[r12.length - 1];
        "Space" == l12 && (l12 = " ");
        for (let t112 = 0; t112 < r12.length - 1; ++t112) {
          let l13 = r12[t112];
          if (/^(cmd|meta|m)$/i.test(l13)) o13 = true;
          else if (/^a(lt)?$/i.test(l13)) i12 = true;
          else if (/^(c|ctrl|control)$/i.test(l13)) s13 = true;
          else if (/^s(hift)?$/i.test(l13)) n12 = true;
          else if (/^mod$/i.test(l13)) "mac" == e12 ? o13 = true : s13 = true;
          else throw Error("Unrecognized modifier name: " + l13);
        }
        return i12 && (l12 = "Alt-" + l12), s13 && (l12 = "Ctrl-" + l12), o13 && (l12 = "Meta-" + l12), n12 && (l12 = "Shift-" + l12), l12;
      }(t110, e11));
      for (let e12 = 1; e12 < d11.length; e12++) {
        let i12 = d11.slice(0, e12).join(" ");
        n11(i12, true), c11[i12] || (c11[i12] = { preventDefault: true, stopPropagation: false, run: [(e13) => {
          let s13 = nm = { view: e13, prefix: i12, scope: t109 };
          return setTimeout(() => {
            nm == s13 && (nm = null);
          }, 4e3), true;
        }] });
      }
      let u11 = d11.join(" ");
      n11(u11, false);
      let f11 = c11[u11] || (c11[u11] = { preventDefault: false, stopPropagation: false, run: (null === (a11 = null === (h11 = c11._any) || void 0 === h11 ? void 0 : h11.run) || void 0 === a11 ? void 0 : a11.slice()) || [] });
      o12 && f11.run.push(o12), r11 && (f11.preventDefault = true), l11 && (f11.stopPropagation = true);
    };
    for (let s12 of t108) {
      let t109 = s12.scope ? s12.scope.split(" ") : ["editor"];
      if (s12.any) for (let e12 of t109) {
        let t110 = i11[e12] || (i11[e12] = /* @__PURE__ */ Object.create(null));
        t110._any || (t110._any = { preventDefault: false, stopPropagation: false, run: [] });
        let { any: n13 } = s12;
        for (let e13 in t110) t110[e13].run.push((t111) => n13(t111, nv));
      }
      let n12 = s12[e11] || s12.key;
      if (n12) for (let e12 of t109) o11(e12, n12, s12.run, s12.preventDefault, s12.stopPropagation), s12.shift && o11(e12, "Shift-" + n12, s12.shift, s12.preventDefault, s12.stopPropagation);
    }
    return i11;
  }(n10.reduce((t108, e11) => t108.concat(e11), []))), i10 = o10, s10 = "editor", nv = t107, l10 = k(x(r10 = el(t107), 0)) == r10.length && " " != r10, h10 = "", a10 = false, c10 = false, d10 = false, nm && nm.view == e10 && nm.scope == s10 && (h10 = nm.prefix + " ", 0 > sr.indexOf(t107.keyCode) && (c10 = true, nm = null)), u10 = /* @__PURE__ */ new Set(), f10 = (t108) => {
    if (t108) {
      for (let i11 of t108.run) if (!u10.has(i11) && (u10.add(i11), i11(e10))) return t108.stopPropagation && (d10 = true), true;
      t108.preventDefault && (t108.stopPropagation && (d10 = true), c10 = true);
    }
    return false;
  }, (g10 = i10[s10]) && (f10(g10[h10 + nu(r10, t107, !l10)]) ? a10 = true : l10 && (t107.altKey || t107.metaKey || t107.ctrlKey) && !(ej.windows && t107.ctrlKey && t107.altKey) && (p10 = ee[t107.keyCode]) && p10 != r10 ? f10(g10[h10 + nu(p10, t107, true)]) ? a10 = true : t107.shiftKey && (m10 = ei[t107.keyCode]) != r10 && m10 != p10 && f10(g10[h10 + nu(m10, t107, false)]) && (a10 = true) : l10 && t107.shiftKey && f10(g10[h10 + nu(r10, t107, true)]) && (a10 = true), !a10 && f10(g10._any) && (a10 = true)), c10 && (a10 = true), a10 && d10 && t107.stopPropagation(), nv = null, a10;
} })), ng = to.define({ enables: nf }), np = /* @__PURE__ */ new WeakMap(), nm = null, nv = null, nw = !ej.ios, nb = { ".cm-line": { "& ::selection, &::selection": { backgroundColor: "transparent !important" } }, ".cm-content": { "& :focus": { caretColor: "initial !important", "&::selection, & ::selection": { backgroundColor: "Highlight !important" } } } };
function ny(t107, e10, i10, s10, n10) {
  e10.lastIndex = 0;
  for (let o10 = t107.iterRange(i10, s10), r10 = i10, l10; !o10.next().done; r10 += o10.value.length) if (!o10.lineBreak) for (; l10 = e10.exec(o10.value); ) n10(r10 + l10.index, l10);
}
nw && (nb[".cm-line"].caretColor = nb[".cm-content"].caretColor = "transparent !important");
class nx {
  constructor(t107) {
    let { regexp: e10, decoration: i10, decorate: s10, boundary: n10, maxLength: o10 = 1e3 } = t107;
    if (!e10.global) throw RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = e10, s10) this.addMatch = (t108, e11, i11, n11) => s10(n11, i11, i11 + t108[0].length, t108, e11);
    else if ("function" == typeof i10) this.addMatch = (t108, e11, s11, n11) => {
      let o11 = i10(t108, e11, s11);
      o11 && n11(s11, s11 + t108[0].length, o11);
    };
    else if (i10) this.addMatch = (t108, e11, s11, n11) => n11(s11, s11 + t108[0].length, i10);
    else throw RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = n10, this.maxLength = o10;
  }
  createDeco(t107) {
    let e10 = new tj(), i10 = e10.add.bind(e10);
    for (let { from: e11, to: s10 } of function(t108, e12) {
      let i11 = t108.visibleRanges;
      if (1 == i11.length && i11[0].from == t108.viewport.from && i11[0].to == t108.viewport.to) return i11;
      let s11 = [];
      for (let { from: n10, to: o10 } of i11) n10 = Math.max(t108.state.doc.lineAt(n10).from, n10 - e12), o10 = Math.min(t108.state.doc.lineAt(o10).to, o10 + e12), s11.length && s11[s11.length - 1].to >= n10 ? s11[s11.length - 1].to = o10 : s11.push({ from: n10, to: o10 });
      return s11;
    }(t107, this.maxLength)) ny(t107.state.doc, this.regexp, e11, s10, (e12, s11) => this.addMatch(s11, t107, e12, i10));
    return e10.finish();
  }
  updateDeco(t107, e10) {
    let i10 = 1e9, s10 = -1;
    return (t107.docChanged && t107.changes.iterChanges((e11, n10, o10, r10) => {
      r10 > t107.view.viewport.from && o10 < t107.view.viewport.to && (i10 = Math.min(o10, i10), s10 = Math.max(r10, s10));
    }), t107.viewportChanged || s10 - i10 > 1e3) ? this.createDeco(t107.view) : s10 > -1 ? this.updateRange(t107.view, e10.map(t107.changes), i10, s10) : e10;
  }
  updateRange(t107, e10, i10, s10) {
    for (let n10 of t107.visibleRanges) {
      let o10 = Math.max(n10.from, i10), r10 = Math.min(n10.to, s10);
      if (r10 > o10) {
        let i11 = t107.state.doc.lineAt(o10), s11 = i11.to < r10 ? t107.state.doc.lineAt(r10) : i11, l10 = Math.max(n10.from, i11.from), h10 = Math.min(n10.to, s11.to);
        if (this.boundary) {
          for (; o10 > i11.from; o10--) if (this.boundary.test(i11.text[o10 - 1 - i11.from])) {
            l10 = o10;
            break;
          }
          for (; r10 < s11.to; r10++) if (this.boundary.test(s11.text[r10 - s11.from])) {
            h10 = r10;
            break;
          }
        }
        let a10 = [], c10, d10 = (t108, e11, i12) => a10.push(i12.range(t108, e11));
        if (i11 == s11) for (this.regexp.lastIndex = l10 - i11.from; (c10 = this.regexp.exec(i11.text)) && c10.index < h10 - i11.from; ) this.addMatch(c10, t107, c10.index + i11.from, d10);
        else ny(t107.state.doc, this.regexp, l10, h10, (e11, i12) => this.addMatch(i12, t107, e11, d10));
        e10 = e10.update({ filterFrom: l10, filterTo: h10, filter: (t108, e11) => t108 < l10 || e11 > h10, add: a10 });
      }
    }
    return e10;
  }
}
let nS = null != /x/.unicode ? "gu" : "g", nk = RegExp("[\0-\b\n--\u2028\u2029\uFEFF-]", nS), nM = { 0: "null", 7: "bell", 8: "backspace", 10: "newline", 11: "vertical tab", 13: "carriage return", 27: "escape", 8203: "zero width space", 8204: "zero width non-joiner", 8205: "zero width joiner", 8206: "left-to-right mark", 8207: "right-to-left mark", 8232: "line separator", 8237: "left-to-right override", 8238: "right-to-left override", 8294: "left-to-right isolate", 8295: "right-to-left isolate", 8297: "pop directional isolate", 8233: "paragraph separator", 65279: "zero width no-break space", 65532: "object replacement" }, nC = null, nA = to.define({ combine(t107) {
  let e10 = tI(t107, { render: null, specialChars: nk, addSpecialChars: null });
  return (e10.replaceTabs = !function() {
    var t108;
    if (null == nC && "undefined" != typeof document && document.body) {
      let e11 = document.body.style;
      nC = (null !== (t108 = e11.tabSize) && void 0 !== t108 ? t108 : e11.MozTabSize) != null;
    }
    return nC || false;
  }()) && (e10.specialChars = RegExp("	|" + e10.specialChars.source, nS)), e10.addSpecialChars && (e10.specialChars = RegExp(e10.specialChars.source + "|" + e10.addSpecialChars.source, nS)), e10;
} });
function nD() {
  let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
  return [nA.of(t107), nO || (nO = iW.fromClass(class {
    constructor(t108) {
      this.view = t108, this.decorations = e5.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(t108.state.facet(nA)), this.decorations = this.decorator.createDeco(t108);
    }
    makeDecorator(t108) {
      return new nx({ regexp: t108.specialChars, decoration: (e10, i10, s10) => {
        let { doc: n10 } = i10.state, o10 = x(e10[0], 0);
        if (9 == o10) {
          let t109 = n10.lineAt(s10), e11 = i10.state.tabSize, o11 = t8(t109.text, e11, s10 - t109.from);
          return e5.replace({ widget: new nE((e11 - o11 % e11) * this.view.defaultCharacterWidth / this.view.scaleX) });
        }
        return this.decorationCache[o10] || (this.decorationCache[o10] = e5.replace({ widget: new nT(t108, o10) }));
      }, boundary: t108.replaceTabs ? void 0 : /[^]/ });
    }
    update(t108) {
      let e10 = t108.state.facet(nA);
      t108.startState.facet(nA) != e10 ? (this.decorator = this.makeDecorator(e10), this.decorations = this.decorator.createDeco(t108.view)) : this.decorations = this.decorator.updateDeco(t108, this.decorations);
    }
  }, { decorations: (t108) => t108.decorations }))];
}
let nO = null;
class nT extends e4 {
  constructor(t107, e10) {
    super(), this.options = t107, this.code = e10;
  }
  eq(t107) {
    return t107.code == this.code;
  }
  toDOM(t107) {
    var e10;
    let i10 = (e10 = this.code) >= 32 ? "" : 10 == e10 ? "" : String.fromCharCode(9216 + e10), s10 = t107.state.phrase("Control character") + " " + (nM[this.code] || "0x" + this.code.toString(16)), n10 = this.options.render && this.options.render(this.code, s10, i10);
    if (n10) return n10;
    let o10 = document.createElement("span");
    return o10.textContent = i10, o10.title = s10, o10.setAttribute("aria-label", s10), o10.className = "cm-specialChar", o10;
  }
  ignoreEvent() {
    return false;
  }
}
class nE extends e4 {
  constructor(t107) {
    super(), this.width = t107;
  }
  eq(t107) {
    return t107.width == this.width;
  }
  toDOM() {
    let t107 = document.createElement("span");
    return t107.textContent = "	", t107.className = "cm-tab", t107.style.width = this.width + "px", t107;
  }
  ignoreEvent() {
    return false;
  }
}
function nR() {
  return nL;
}
let nB = e5.line({ class: "cm-activeLine" }), nL = iW.fromClass(class {
  constructor(t107) {
    this.decorations = this.getDeco(t107);
  }
  update(t107) {
    (t107.docChanged || t107.selectionSet) && (this.decorations = this.getDeco(t107.view));
  }
  getDeco(t107) {
    let e10 = -1, i10 = [];
    for (let s10 of t107.state.selection.ranges) {
      let n10 = t107.lineBlockAt(s10.head);
      n10.from > e10 && (i10.push(nB.range(n10.from)), e10 = n10.from);
    }
    return e5.set(i10);
  }
}, { decorations: (t107) => t107.decorations }), nP = class extends tz {
  compare(t107) {
    return this == t107 || this.constructor == t107.constructor && this.eq(t107);
  }
  eq(t107) {
    return false;
  }
  destroy(t107) {
  }
};
nP.prototype.elementClass = "", nP.prototype.toDOM = void 0, nP.prototype.mapMode = j.TrackBefore, nP.prototype.startSide = nP.prototype.endSide = -1, nP.prototype.point = true;
let nN = to.define(), nV = to.define(), nH = to.define({ combine: (t107) => t107.some((t108) => t108) }), nF = iW.fromClass(class {
  constructor(t107) {
    for (let e10 of (this.view = t107, this.prevViewport = t107.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = t107.state.facet(nV).map((e11) => new nK(t107, e11)), this.gutters)) this.dom.appendChild(e10.dom);
    this.fixed = !t107.state.facet(nH), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(false), t107.scrollDOM.insertBefore(this.dom, t107.contentDOM);
  }
  update(t107) {
    if (this.updateGutters(t107)) {
      let e10 = this.prevViewport, i10 = t107.view.viewport, s10 = Math.min(e10.to, i10.to) - Math.max(e10.from, i10.from);
      this.syncGutters(s10 < (i10.to - i10.from) * 0.8);
    }
    t107.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px"), this.view.state.facet(nH) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = t107.view.viewport;
  }
  syncGutters(t107) {
    let e10 = this.dom.nextSibling;
    t107 && this.dom.remove();
    let i10 = tG.iter(this.view.state.facet(nN), this.view.viewport.from), s10 = [], n10 = this.gutters.map((t108) => new nz(t108, this.view.viewport, -this.view.documentPadding.top));
    for (let t108 of this.view.viewportLineBlocks) if (s10.length && (s10 = []), Array.isArray(t108.type)) {
      let e11 = true;
      for (let o10 of t108.type) if (o10.type == e9.Text && e11) {
        for (let t109 of (nI(i10, s10, o10.from), n10)) t109.line(this.view, o10, s10);
        e11 = false;
      } else if (o10.widget) for (let t109 of n10) t109.widget(this.view, o10);
    } else if (t108.type == e9.Text) for (let e11 of (nI(i10, s10, t108.from), n10)) e11.line(this.view, t108, s10);
    else if (t108.widget) for (let e11 of n10) e11.widget(this.view, t108);
    for (let t108 of n10) t108.finish();
    t107 && this.view.scrollDOM.insertBefore(this.dom, e10);
  }
  updateGutters(t107) {
    let e10 = t107.startState.facet(nV), i10 = t107.state.facet(nV), s10 = t107.docChanged || t107.heightChanged || t107.viewportChanged || !tG.eq(t107.startState.facet(nN), t107.state.facet(nN), t107.view.viewport.from, t107.view.viewport.to);
    if (e10 == i10) for (let e11 of this.gutters) e11.update(t107) && (s10 = true);
    else {
      s10 = true;
      let n10 = [];
      for (let s11 of i10) {
        let i11 = e10.indexOf(s11);
        i11 < 0 ? n10.push(new nK(this.view, s11)) : (this.gutters[i11].update(t107), n10.push(this.gutters[i11]));
      }
      for (let t108 of this.gutters) t108.dom.remove(), 0 > n10.indexOf(t108) && t108.destroy();
      for (let t108 of n10) this.dom.appendChild(t108.dom);
      this.gutters = n10;
    }
    return s10;
  }
  destroy() {
    for (let t107 of this.gutters) t107.destroy();
    this.dom.remove();
  }
}, { provide: (t107) => nr.scrollMargins.of((e10) => {
  let i10 = e10.plugin(t107);
  return i10 && 0 != i10.gutters.length && i10.fixed ? e10.textDirection == il.LTR ? { left: i10.dom.offsetWidth * e10.scaleX } : { right: i10.dom.offsetWidth * e10.scaleX } : null;
}) });
function nW(t107) {
  return Array.isArray(t107) ? t107 : [t107];
}
function nI(t107, e10, i10) {
  for (; t107.value && t107.from <= i10; ) t107.from == i10 && e10.push(t107.value), t107.next();
}
let nz = class {
  constructor(t107, e10, i10) {
    this.gutter = t107, this.height = i10, this.i = 0, this.cursor = tG.iter(t107.markers, e10.from);
  }
  addElement(t107, e10, i10) {
    let { gutter: s10 } = this, n10 = (e10.top - this.height) / t107.scaleY, o10 = e10.height / t107.scaleY;
    if (this.i == s10.elements.length) {
      let e11 = new nq(t107, o10, n10, i10);
      s10.elements.push(e11), s10.dom.appendChild(e11.dom);
    } else s10.elements[this.i].update(t107, o10, n10, i10);
    this.height = e10.bottom, this.i++;
  }
  line(t107, e10, i10) {
    let s10 = [];
    nI(this.cursor, s10, e10.from), i10.length && (s10 = s10.concat(i10));
    let n10 = this.gutter.config.lineMarker(t107, e10, s10);
    n10 && s10.unshift(n10);
    let o10 = this.gutter;
    (0 != s10.length || o10.config.renderEmptyElements) && this.addElement(t107, e10, s10);
  }
  widget(t107, e10) {
    let i10 = this.gutter.config.widgetMarker(t107, e10.widget, e10);
    i10 && this.addElement(t107, e10, [i10]);
  }
  finish() {
    let t107 = this.gutter;
    for (; t107.elements.length > this.i; ) {
      let e10 = t107.elements.pop();
      t107.dom.removeChild(e10.dom), e10.destroy();
    }
  }
}, nK = class {
  constructor(t107, e10) {
    for (let i10 in this.view = t107, this.config = e10, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : ""), e10.domEventHandlers) this.dom.addEventListener(i10, (s10) => {
      let n10 = s10.target, o10;
      if (n10 != this.dom && this.dom.contains(n10)) {
        for (; n10.parentNode != this.dom; ) n10 = n10.parentNode;
        let t108 = n10.getBoundingClientRect();
        o10 = (t108.top + t108.bottom) / 2;
      } else o10 = s10.clientY;
      let r10 = t107.lineBlockAtHeight(o10 - t107.documentTop);
      e10.domEventHandlers[i10](t107, r10, s10) && s10.preventDefault();
    });
    this.markers = nW(e10.markers(t107)), e10.initialSpacer && (this.spacer = new nq(t107, 0, 0, [e10.initialSpacer(t107)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(t107) {
    let e10 = this.markers;
    if (this.markers = nW(this.config.markers(t107.view)), this.spacer && this.config.updateSpacer) {
      let e11 = this.config.updateSpacer(this.spacer.markers[0], t107);
      e11 != this.spacer.markers[0] && this.spacer.update(t107.view, 0, 0, [e11]);
    }
    let i10 = t107.view.viewport;
    return !tG.eq(this.markers, e10, i10.from, i10.to) || !!this.config.lineMarkerChange && this.config.lineMarkerChange(t107);
  }
  destroy() {
    for (let t107 of this.elements) t107.destroy();
  }
}, nq = class {
  constructor(t107, e10, i10, s10) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(t107, e10, i10, s10);
  }
  update(t107, e10, i10, s10) {
    this.height != e10 && (this.height = e10, this.dom.style.height = e10 + "px"), this.above != i10 && (this.dom.style.marginTop = (this.above = i10) ? i10 + "px" : ""), !function(t108, e11) {
      if (t108.length != e11.length) return false;
      for (let i11 = 0; i11 < t108.length; i11++) if (!t108[i11].compare(e11[i11])) return false;
      return true;
    }(this.markers, s10) && this.setMarkers(t107, s10);
  }
  setMarkers(t107, e10) {
    let i10 = "cm-gutterElement", s10 = this.dom.firstChild;
    for (let n10 = 0, o10 = 0; ; ) {
      let r10 = o10, l10 = n10 < e10.length ? e10[n10++] : null, h10 = false;
      if (l10) {
        let t108 = l10.elementClass;
        t108 && (i10 += " " + t108);
        for (let t109 = o10; t109 < this.markers.length; t109++) if (this.markers[t109].compare(l10)) {
          r10 = t109, h10 = true;
          break;
        }
      } else r10 = this.markers.length;
      for (; o10 < r10; ) {
        let t108 = this.markers[o10++];
        if (t108.toDOM) {
          t108.destroy(s10);
          let e11 = s10.nextSibling;
          s10.remove(), s10 = e11;
        }
      }
      if (!l10) break;
      l10.toDOM && (h10 ? s10 = s10.nextSibling : this.dom.insertBefore(l10.toDOM(t107), s10)), h10 && o10++;
    }
    this.dom.className = i10, this.markers = e10;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}, n_ = to.define(), nG = to.define({ combine: (t107) => tI(t107, { formatNumber: String, domEventHandlers: {} }, { domEventHandlers(t108, e10) {
  let i10 = Object.assign({}, t108);
  for (let t109 in e10) {
    let s10 = i10[t109], n10 = e10[t109];
    i10[t109] = s10 ? (t110, e11, i11) => s10(t110, e11, i11) || n10(t110, e11, i11) : n10;
  }
  return i10;
} }) });
class nj extends nP {
  constructor(t107) {
    super(), this.number = t107;
  }
  eq(t107) {
    return this.number == t107.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function nU(t107, e10) {
  return t107.state.facet(nG).formatNumber(e10, t107.state);
}
let nY = nV.compute([nG], (t107) => ({ class: "cm-lineNumbers", renderEmptyElements: false, markers: (t108) => t108.state.facet(n_), lineMarker: (t108, e10, i10) => i10.some((t109) => t109.toDOM) ? null : new nj(nU(t108, t108.state.doc.lineAt(e10.from).number)), widgetMarker: () => null, lineMarkerChange: (t108) => t108.startState.facet(nG) != t108.state.facet(nG), initialSpacer: (t108) => new nj(nU(t108, nX(t108.state.doc.lines))), updateSpacer(t108, e10) {
  let i10 = nU(e10.view, nX(e10.view.state.doc.lines));
  return i10 == t108.number ? t108 : new nj(i10);
}, domEventHandlers: t107.facet(nG).domEventHandlers }));
function n$() {
  let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
  return [nG.of(t107), [nF], nY];
}
function nX(t107) {
  let e10 = 9;
  for (; e10 < t107; ) e10 = 10 * e10 + 9;
  return e10;
}
let nJ = new class extends nP {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), nQ = nN.compute(["selection"], (t107) => {
  let e10 = [], i10 = -1;
  for (let s10 of t107.selection.ranges) {
    let n10 = t107.doc.lineAt(s10.head).from;
    n10 > i10 && (i10 = n10, e10.push(nJ.range(n10)));
  }
  return tG.of(e10);
});
function nZ() {
  return nQ;
}
function n0(t107) {
  return (11 == t107.nodeType ? t107.getSelection ? t107 : t107.ownerDocument : t107).getSelection();
}
function n1(t107, e10) {
  return !!e10 && (t107 == e10 || t107.contains(1 != e10.nodeType ? e10.parentNode : e10));
}
function n2(t107, e10) {
  if (!e10.anchorNode) return false;
  try {
    return n1(t107, e10.anchorNode);
  } catch (t108) {
    return false;
  }
}
function n8(t107) {
  return 3 == t107.nodeType ? on(t107, 0, t107.nodeValue.length).getClientRects() : 1 == t107.nodeType ? t107.getClientRects() : [];
}
function n3(t107, e10, i10, s10) {
  return !!i10 && (n5(t107, e10, i10, s10, -1) || n5(t107, e10, i10, s10, 1));
}
function n4(t107) {
  for (var e10 = 0; ; e10++) if (!(t107 = t107.previousSibling)) return e10;
}
function n9(t107) {
  return 1 == t107.nodeType && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t107.nodeName);
}
function n5(t107, e10, i10, s10, n10) {
  for (; ; ) {
    if (t107 == i10 && e10 == s10) return true;
    if (e10 == (n10 < 0 ? 0 : n6(t107))) {
      if ("DIV" == t107.nodeName) return false;
      let i11 = t107.parentNode;
      if (!i11 || 1 != i11.nodeType) return false;
      e10 = n4(t107) + (n10 < 0 ? 0 : 1), t107 = i11;
    } else {
      if (1 != t107.nodeType || 1 == (t107 = t107.childNodes[e10 + (n10 < 0 ? -1 : 0)]).nodeType && "false" == t107.contentEditable) return false;
      e10 = n10 < 0 ? n6(t107) : 0;
    }
  }
}
function n6(t107) {
  return 3 == t107.nodeType ? t107.nodeValue.length : t107.childNodes.length;
}
function n7(t107, e10) {
  let i10 = e10 ? t107.left : t107.right;
  return { left: i10, right: i10, top: t107.top, bottom: t107.bottom };
}
function ot(t107, e10) {
  let i10 = e10.width / t107.offsetWidth, s10 = e10.height / t107.offsetHeight;
  return (i10 > 0.995 && i10 < 1.005 || !isFinite(i10) || 1 > Math.abs(e10.width - t107.offsetWidth)) && (i10 = 1), (s10 > 0.995 && s10 < 1.005 || !isFinite(s10) || 1 > Math.abs(e10.height - t107.offsetHeight)) && (s10 = 1), { scaleX: i10, scaleY: s10 };
}
let oe = class {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(t107) {
    return this.anchorNode == t107.anchorNode && this.anchorOffset == t107.anchorOffset && this.focusNode == t107.focusNode && this.focusOffset == t107.focusOffset;
  }
  setRange(t107) {
    let { anchorNode: e10, focusNode: i10 } = t107;
    this.set(e10, Math.min(t107.anchorOffset, e10 ? n6(e10) : 0), i10, Math.min(t107.focusOffset, i10 ? n6(i10) : 0));
  }
  set(t107, e10, i10, s10) {
    this.anchorNode = t107, this.anchorOffset = e10, this.focusNode = i10, this.focusOffset = s10;
  }
}, oi = null;
function os(t107) {
  if (t107.setActive) return t107.setActive();
  if (oi) return t107.focus(oi);
  let e10 = [];
  for (let i10 = t107; i10 && (e10.push(i10, i10.scrollTop, i10.scrollLeft), i10 != i10.ownerDocument); i10 = i10.parentNode) ;
  if (t107.focus(null == oi ? { get preventScroll() {
    return oi = { preventScroll: true }, true;
  } } : void 0), !oi) {
    oi = false;
    for (let t108 = 0; t108 < e10.length; ) {
      let i10 = e10[t108++], s10 = e10[t108++], n10 = e10[t108++];
      i10.scrollTop != s10 && (i10.scrollTop = s10), i10.scrollLeft != n10 && (i10.scrollLeft = n10);
    }
  }
}
function on(t107, e10) {
  let s10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e10, n10 = i || (i = document.createRange());
  return n10.setEnd(t107, s10), n10.setStart(t107, e10), n10;
}
function oo(t107, e10, i10, s10) {
  let n10 = { key: e10, code: e10, keyCode: i10, which: i10, cancelable: true };
  s10 && ({ altKey: n10.altKey, ctrlKey: n10.ctrlKey, shiftKey: n10.shiftKey, metaKey: n10.metaKey } = s10);
  let o10 = new KeyboardEvent("keydown", n10);
  o10.synthetic = true, t107.dispatchEvent(o10);
  let r10 = new KeyboardEvent("keyup", n10);
  return r10.synthetic = true, t107.dispatchEvent(r10), o10.defaultPrevented || r10.defaultPrevented;
}
function or(t107) {
  for (; t107.attributes.length; ) t107.removeAttributeNode(t107.attributes[0]);
}
function ol(t107) {
  return t107.scrollTop > Math.max(1, t107.scrollHeight - t107.clientHeight - 4);
}
function oh(t107, e10) {
  for (let i10 = t107, s10 = e10; ; ) {
    if (3 == i10.nodeType && s10 > 0) return { node: i10, offset: s10 };
    if (1 == i10.nodeType && s10 > 0) {
      if ("false" == i10.contentEditable) return null;
      s10 = n6(i10 = i10.childNodes[s10 - 1]);
    } else {
      if (!i10.parentNode || n9(i10)) return null;
      s10 = n4(i10), i10 = i10.parentNode;
    }
  }
}
function oa(t107, e10) {
  for (let i10 = t107, s10 = e10; ; ) {
    if (3 == i10.nodeType && s10 < i10.nodeValue.length) return { node: i10, offset: s10 };
    if (1 == i10.nodeType && s10 < i10.childNodes.length) {
      if ("false" == i10.contentEditable) return null;
      i10 = i10.childNodes[s10], s10 = 0;
    } else {
      if (!i10.parentNode || n9(i10)) return null;
      s10 = n4(i10) + 1, i10 = i10.parentNode;
    }
  }
}
let oc = class t35 {
  constructor(t107, e10, i10 = true) {
    this.node = t107, this.offset = e10, this.precise = i10;
  }
  static before(e10, i10) {
    return new t35(e10.parentNode, n4(e10), i10);
  }
  static after(e10, i10) {
    return new t35(e10.parentNode, n4(e10) + 1, i10);
  }
}, od = [], ou = class t36 {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(t107) {
    let e10 = this.posAtStart;
    for (let i10 of this.children) {
      if (i10 == t107) return e10;
      e10 += i10.length + i10.breakAfter;
    }
    throw RangeError("Invalid child in posBefore");
  }
  posAfter(t107) {
    return this.posBefore(t107) + t107.length;
  }
  sync(e10, i10) {
    if (2 & this.flags) {
      let s10 = this.dom, n10 = null, o10;
      for (let r10 of this.children) {
        if (7 & r10.flags) {
          if (!r10.dom && (o10 = n10 ? n10.nextSibling : s10.firstChild)) {
            let e11 = t36.get(o10);
            (!e11 || !e11.parent && e11.canReuseDOM(r10)) && r10.reuseDOM(o10);
          }
          r10.sync(e10, i10), r10.flags &= -8;
        }
        if (o10 = n10 ? n10.nextSibling : s10.firstChild, i10 && !i10.written && i10.node == s10 && o10 != r10.dom && (i10.written = true), r10.dom.parentNode == s10) for (; o10 && o10 != r10.dom; ) o10 = of(o10);
        else s10.insertBefore(r10.dom, o10);
        n10 = r10.dom;
      }
      for ((o10 = n10 ? n10.nextSibling : s10.firstChild) && i10 && i10.node == s10 && (i10.written = true); o10; ) o10 = of(o10);
    } else if (1 & this.flags) for (let t107 of this.children) 7 & t107.flags && (t107.sync(e10, i10), t107.flags &= -8);
  }
  reuseDOM(t107) {
  }
  localPosFromDOM(e10, i10) {
    let s10;
    if (e10 == this.dom) s10 = this.dom.childNodes[i10];
    else {
      let t107 = 0 == n6(e10) ? 0 : 0 == i10 ? -1 : 1;
      for (; ; ) {
        let i11 = e10.parentNode;
        if (i11 == this.dom) break;
        0 == t107 && i11.firstChild != i11.lastChild && (t107 = e10 == i11.firstChild ? -1 : 1), e10 = i11;
      }
      s10 = t107 < 0 ? e10 : e10.nextSibling;
    }
    if (s10 == this.dom.firstChild) return 0;
    for (; s10 && !t36.get(s10); ) s10 = s10.nextSibling;
    if (!s10) return this.length;
    for (let t107 = 0, e11 = 0; ; t107++) {
      let i11 = this.children[t107];
      if (i11.dom == s10) return e11;
      e11 += i11.length + i11.breakAfter;
    }
  }
  domBoundsAround(t107, e10) {
    let i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, s10 = -1, n10 = -1, o10 = -1, r10 = -1;
    for (let l10 = 0, h10 = i10, a10 = i10; l10 < this.children.length; l10++) {
      let i11 = this.children[l10], c10 = h10 + i11.length;
      if (h10 < t107 && c10 > e10) return i11.domBoundsAround(t107, e10, h10);
      if (c10 >= t107 && -1 == s10 && (s10 = l10, n10 = h10), h10 > e10 && i11.dom.parentNode == this.dom) {
        o10 = l10, r10 = a10;
        break;
      }
      a10 = c10, h10 = c10 + i11.breakAfter;
    }
    return { from: n10, to: r10 < 0 ? i10 + this.length : r10, startDOM: (s10 ? this.children[s10 - 1].dom.nextSibling : null) || this.dom.firstChild, endDOM: o10 < this.children.length && o10 >= 0 ? this.children[o10].dom : null };
  }
  markDirty() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
    this.flags |= 2, this.markParentsDirty(t107);
  }
  markParentsDirty(t107) {
    for (let e10 = this.parent; e10; e10 = e10.parent) {
      if (t107 && (e10.flags |= 2), 1 & e10.flags) return;
      e10.flags |= 1, t107 = false;
    }
  }
  setParent(t107) {
    this.parent != t107 && (this.parent = t107, 7 & this.flags && this.markParentsDirty(true));
  }
  setDOM(t107) {
    this.dom != t107 && (this.dom && (this.dom.cmView = null), this.dom = t107, t107.cmView = this);
  }
  get rootView() {
    for (let t107 = this; ; ) {
      let e10 = t107.parent;
      if (!e10) return t107;
      t107 = e10;
    }
  }
  replaceChildren(t107, e10) {
    let i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : od;
    this.markDirty();
    for (let s10 = t107; s10 < e10; s10++) {
      let t108 = this.children[s10];
      t108.parent == this && 0 > i10.indexOf(t108) && t108.destroy();
    }
    this.children.splice(t107, e10 - t107, ...i10);
    for (let t108 = 0; t108 < i10.length; t108++) i10[t108].setParent(this);
  }
  ignoreMutation(t107) {
    return false;
  }
  ignoreEvent(t107) {
    return false;
  }
  childCursor() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.length;
    return new og(this.children, t107, this.children.length);
  }
  childPos(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
    return this.childCursor().findPos(t107, e10);
  }
  toString() {
    let t107 = this.constructor.name.replace("View", "");
    return t107 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + ("Text" == t107 ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(t107) {
    return t107.cmView;
  }
  get isEditable() {
    return true;
  }
  get isWidget() {
    return false;
  }
  get isHidden() {
    return false;
  }
  merge(t107, e10, i10, s10, n10, o10) {
    return false;
  }
  become(t107) {
    return false;
  }
  canReuseDOM(t107) {
    return t107.constructor == this.constructor && !((this.flags | t107.flags) & 8);
  }
  getSide() {
    return 0;
  }
  destroy() {
    for (let t107 of this.children) t107.parent == this && t107.destroy();
    this.parent = null;
  }
};
function of(t107) {
  let e10 = t107.nextSibling;
  return t107.parentNode.removeChild(t107), e10;
}
ou.prototype.breakAfter = 0;
let og = class {
  constructor(t107, e10, i10) {
    this.children = t107, this.pos = e10, this.i = i10, this.off = 0;
  }
  findPos(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
    for (; ; ) {
      if (t107 > this.pos || t107 == this.pos && (e10 > 0 || 0 == this.i || this.children[this.i - 1].breakAfter)) return this.off = t107 - this.pos, this;
      let i10 = this.children[--this.i];
      this.pos -= i10.length + i10.breakAfter;
    }
  }
};
function op(t107, e10, i10, s10, n10, o10, r10, l10, h10) {
  let { children: a10 } = t107, c10 = a10.length ? a10[e10] : null, d10 = o10.length ? o10[o10.length - 1] : null, u10 = d10 ? d10.breakAfter : r10;
  if (!(e10 == s10 && c10 && !r10 && !u10 && o10.length < 2 && c10.merge(i10, n10, o10.length ? d10 : null, 0 == i10, l10, h10))) {
    if (s10 < a10.length) {
      let t108 = a10[s10];
      t108 && (n10 < t108.length || t108.breakAfter && (null == d10 ? void 0 : d10.breakAfter)) ? (e10 == s10 && (t108 = t108.split(n10), n10 = 0), !u10 && d10 && t108.merge(0, n10, d10, true, 0, h10) ? o10[o10.length - 1] = t108 : ((n10 || t108.children.length && !t108.children[0].length) && t108.merge(0, n10, null, false, 0, h10), o10.push(t108))) : (null == t108 ? void 0 : t108.breakAfter) && (d10 ? d10.breakAfter = 1 : r10 = 1), s10++;
    }
    for (c10 && (c10.breakAfter = r10, i10 > 0 && (!r10 && o10.length && c10.merge(i10, c10.length, o10[0], false, l10, 0) ? c10.breakAfter = o10.shift().breakAfter : (i10 < c10.length || c10.children.length && 0 == c10.children[c10.children.length - 1].length) && c10.merge(i10, c10.length, null, false, l10, 0), e10++)); e10 < s10 && o10.length; ) if (a10[s10 - 1].become(o10[o10.length - 1])) s10--, o10.pop(), h10 = o10.length ? 0 : l10;
    else if (a10[e10].become(o10[0])) e10++, o10.shift(), l10 = o10.length ? 0 : h10;
    else break;
    !o10.length && e10 && s10 < a10.length && !a10[e10 - 1].breakAfter && a10[s10].merge(0, 0, a10[e10 - 1], false, l10, h10) && e10--, (e10 < s10 || o10.length) && t107.replaceChildren(e10, s10, o10);
  }
}
function om(t107, e10, i10, s10, n10, o10) {
  let r10 = t107.childCursor(), { i: l10, off: h10 } = r10.findPos(i10, 1), { i: a10, off: c10 } = r10.findPos(e10, -1), d10 = e10 - i10;
  for (let t108 of s10) d10 += t108.length;
  t107.length += d10, op(t107, a10, c10, l10, h10, s10, 0, n10, o10);
}
let ov = "undefined" != typeof navigator ? navigator : { userAgent: "", vendor: "", platform: "" }, ow = "undefined" != typeof document ? document : { documentElement: { style: {} } }, ob = /Edge\/(\d+)/.exec(ov.userAgent), oy = /MSIE \d/.test(ov.userAgent), ox = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ov.userAgent), oS = !!(oy || ox || ob), ok = !oS && /gecko\/(\d+)/i.test(ov.userAgent), oM = !oS && /Chrome\/(\d+)/.exec(ov.userAgent), oC = "webkitFontSmoothing" in ow.documentElement.style, oA = !oS && /Apple Computer/.test(ov.vendor), oD = oA && (/Mobile\/\w+/.test(ov.userAgent) || ov.maxTouchPoints > 2);
var oO = { mac: oD || /Mac/.test(ov.platform), windows: /Win/.test(ov.platform), linux: /Linux|X11/.test(ov.platform), ie: oS, ie_version: oy ? ow.documentMode || 6 : ox ? +ox[1] : ob ? +ob[1] : 0, gecko: ok, gecko_version: ok ? +(/Firefox\/(\d+)/.exec(ov.userAgent) || [0, 0])[1] : 0, chrome: !!oM, chrome_version: oM ? +oM[1] : 0, ios: oD, android: /Android\b/.test(ov.userAgent), webkit: oC, safari: oA, webkit_version: oC ? +(/\bAppleWebKit\/(\d+)/.exec(ov.userAgent) || [0, 0])[1] : 0, tabSize: null != ow.documentElement.style.tabSize ? "tab-size" : "-moz-tab-size" };
let oT = class t37 extends ou {
  constructor(t107) {
    super(), this.text = t107;
  }
  get length() {
    return this.text.length;
  }
  createDOM(t107) {
    this.setDOM(t107 || document.createTextNode(this.text));
  }
  sync(t107, e10) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (e10 && e10.node == this.dom && (e10.written = true), this.dom.nodeValue = this.text);
  }
  reuseDOM(t107) {
    3 == t107.nodeType && this.createDOM(t107);
  }
  merge(e10, i10, s10) {
    return !(8 & this.flags) && (!s10 || s10 instanceof t37 && !(this.length - (i10 - e10) + s10.length > 256) && !(8 & s10.flags)) && (this.text = this.text.slice(0, e10) + (s10 ? s10.text : "") + this.text.slice(i10), this.markDirty(), true);
  }
  split(e10) {
    let i10 = new t37(this.text.slice(e10));
    return this.text = this.text.slice(0, e10), this.markDirty(), i10.flags |= 8 & this.flags, i10;
  }
  localPosFromDOM(t107, e10) {
    return t107 == this.dom ? e10 : e10 ? this.text.length : 0;
  }
  domAtPos(t107) {
    return new oc(this.dom, t107);
  }
  domBoundsAround(t107, e10, i10) {
    return { from: i10, to: i10 + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(t107, e10) {
    return function(t108, e11, i10) {
      let s10 = t108.nodeValue.length;
      e11 > s10 && (e11 = s10);
      let n10 = e11, o10 = e11, r10 = 0;
      0 == e11 && i10 < 0 || e11 == s10 && i10 >= 0 ? !(oO.chrome || oO.gecko) && (e11 ? (n10--, r10 = 1) : o10 < s10 && (o10++, r10 = -1)) : i10 < 0 ? n10-- : o10 < s10 && o10++;
      let l10 = on(t108, n10, o10).getClientRects();
      if (!l10.length) return null;
      let h10 = l10[(r10 ? r10 < 0 : i10 >= 0) ? 0 : l10.length - 1];
      return oO.safari && !r10 && 0 == h10.width && (h10 = Array.prototype.find.call(l10, (t109) => t109.width) || h10), r10 ? n7(h10, r10 < 0) : h10 || null;
    }(this.dom, t107, e10);
  }
}, oE = class t38 extends ou {
  constructor(t107, e10 = [], i10 = 0) {
    for (let s10 of (super(), this.mark = t107, this.children = e10, this.length = i10, e10)) s10.setParent(this);
  }
  setAttrs(t107) {
    if (or(t107), this.mark.class && (t107.className = this.mark.class), this.mark.attrs) for (let e10 in this.mark.attrs) t107.setAttribute(e10, this.mark.attrs[e10]);
    return t107;
  }
  canReuseDOM(t107) {
    return super.canReuseDOM(t107) && !((this.flags | t107.flags) & 8);
  }
  reuseDOM(t107) {
    t107.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(t107), this.flags |= 6);
  }
  sync(t107, e10) {
    this.dom ? 4 & this.flags && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(t107, e10);
  }
  merge(e10, i10, s10, n10, o10, r10) {
    return (!s10 || !!(s10 instanceof t38 && s10.mark.eq(this.mark)) && (!e10 || !(o10 <= 0)) && (!(i10 < this.length) || !(r10 <= 0))) && (om(this, e10, i10, s10 ? s10.children.slice() : [], o10 - 1, r10 - 1), this.markDirty(), true);
  }
  split(e10) {
    let i10 = [], s10 = 0, n10 = -1, o10 = 0;
    for (let t107 of this.children) {
      let r11 = s10 + t107.length;
      r11 > e10 && i10.push(s10 < e10 ? t107.split(e10 - s10) : t107), n10 < 0 && s10 >= e10 && (n10 = o10), s10 = r11, o10++;
    }
    let r10 = this.length - e10;
    return this.length = e10, n10 > -1 && (this.children.length = n10, this.markDirty()), new t38(this.mark, i10, r10);
  }
  domAtPos(t107) {
    return oL(this, t107);
  }
  coordsAt(t107, e10) {
    return oP(this, t107, e10);
  }
}, oR = class t39 extends ou {
  static create(e10, i10, s10) {
    return new t39(e10, i10, s10);
  }
  constructor(t107, e10, i10) {
    super(), this.widget = t107, this.length = e10, this.side = i10, this.prevWidget = null;
  }
  split(e10) {
    let i10 = t39.create(this.widget, this.length - e10, this.side);
    return this.length -= e10, i10;
  }
  sync(t107) {
    this.dom && this.widget.updateDOM(this.dom, t107) || (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t107)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e10, i10, s10, n10, o10, r10) {
    return (!s10 || s10 instanceof t39 && !!this.widget.compare(s10.widget) && (!(e10 > 0) || !(o10 <= 0)) && (!(i10 < this.length) || !(r10 <= 0))) && (this.length = e10 + (s10 ? s10.length : 0) + (this.length - i10), true);
  }
  become(e10) {
    return e10 instanceof t39 && e10.side == this.side && this.widget.constructor == e10.widget.constructor && (this.widget.compare(e10.widget) || this.markDirty(true), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e10.widget, this.length = e10.length, true);
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(t107) {
    return this.widget.ignoreEvent(t107);
  }
  get overrideDOMText() {
    if (0 == this.length) return r.empty;
    let t107 = this;
    for (; t107.parent; ) t107 = t107.parent;
    let { view: e10 } = t107, i10 = e10 && e10.state.doc, s10 = this.posAtStart;
    return i10 ? i10.slice(s10, s10 + this.length) : r.empty;
  }
  domAtPos(t107) {
    return (this.length ? 0 == t107 : this.side > 0) ? oc.before(this.dom) : oc.after(this.dom, t107 == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(t107, e10) {
    let i10 = this.widget.coordsAt(this.dom, t107, e10);
    if (i10) return i10;
    let s10 = this.dom.getClientRects(), n10 = null;
    if (!s10.length) return null;
    let o10 = this.side ? this.side < 0 : t107 > 0;
    for (let e11 = o10 ? s10.length - 1 : 0; n10 = s10[e11], t107 > 0 ? 0 != e11 : e11 != s10.length - 1 && !(n10.top < n10.bottom); e11 += o10 ? -1 : 1) ;
    return n7(n10, !o10);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}, oB = class t40 extends ou {
  constructor(t107) {
    super(), this.side = t107;
  }
  get length() {
    return 0;
  }
  merge() {
    return false;
  }
  become(e10) {
    return e10 instanceof t40 && e10.side == this.side;
  }
  split() {
    return new t40(this.side);
  }
  sync() {
    if (!this.dom) {
      let t107 = document.createElement("img");
      t107.className = "cm-widgetBuffer", t107.setAttribute("aria-hidden", "true"), this.setDOM(t107);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(t107) {
    return this.side > 0 ? oc.before(this.dom) : oc.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(t107) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return r.empty;
  }
  get isHidden() {
    return true;
  }
};
function oL(t107, e10) {
  let i10 = t107.dom, { children: s10 } = t107, n10 = 0;
  for (let t108 = 0; n10 < s10.length; n10++) {
    let o10 = s10[n10], r10 = t108 + o10.length;
    if (!(r10 == t108 && 0 >= o10.getSide())) {
      if (e10 > t108 && e10 < r10 && o10.dom.parentNode == i10) return o10.domAtPos(e10 - t108);
      if (e10 <= t108) break;
      t108 = r10;
    }
  }
  for (let t108 = n10; t108 > 0; t108--) {
    let e11 = s10[t108 - 1];
    if (e11.dom.parentNode == i10) return e11.domAtPos(e11.length);
  }
  for (let t108 = n10; t108 < s10.length; t108++) {
    let e11 = s10[t108];
    if (e11.dom.parentNode == i10) return e11.domAtPos(0);
  }
  return new oc(i10, 0);
}
function oP(t107, e10, i10) {
  let s10 = null, n10 = -1, o10 = null, r10 = -1;
  !function t108(e11, l11) {
    for (let h10 = 0, a10 = 0; h10 < e11.children.length && a10 <= l11; h10++) {
      let c10 = e11.children[h10], d10 = a10 + c10.length;
      d10 >= l11 && (c10.children.length ? t108(c10, l11 - a10) : (!o10 || o10.isHidden && i10 > 0) && (d10 > l11 || a10 == d10 && c10.getSide() > 0) ? (o10 = c10, r10 = l11 - a10) : (a10 < l11 || a10 == d10 && 0 > c10.getSide() && !c10.isHidden) && (s10 = c10, n10 = l11 - a10)), a10 = d10;
    }
  }(t107, e10);
  let l10 = (i10 < 0 ? s10 : o10) || s10 || o10;
  return l10 ? l10.coordsAt(Math.max(0, l10 == s10 ? n10 : r10), i10) : function(t108) {
    let e11 = t108.dom.lastChild;
    if (!e11) return t108.dom.getBoundingClientRect();
    let i11 = n8(e11);
    return i11[i11.length - 1] || null;
  }(t107);
}
function oN(t107, e10) {
  for (let i10 in t107) "class" == i10 && e10.class ? e10.class += " " + t107.class : "style" == i10 && e10.style ? e10.style += ";" + t107.style : e10[i10] = t107[i10];
  return e10;
}
oT.prototype.children = oR.prototype.children = oB.prototype.children = od;
let oV = /* @__PURE__ */ Object.create(null);
function oH(t107, e10, i10) {
  if (t107 == e10) return true;
  t107 || (t107 = oV), e10 || (e10 = oV);
  let s10 = Object.keys(t107), n10 = Object.keys(e10);
  if (s10.length - (i10 && s10.indexOf(i10) > -1 ? 1 : 0) != n10.length - (i10 && n10.indexOf(i10) > -1 ? 1 : 0)) return false;
  for (let o10 of s10) if (o10 != i10 && (-1 == n10.indexOf(o10) || t107[o10] !== e10[o10])) return false;
  return true;
}
function oF(t107, e10, i10) {
  let s10 = false;
  if (e10) for (let n10 in e10) i10 && n10 in i10 || (s10 = true, "style" == n10 ? t107.style.cssText = "" : t107.removeAttribute(n10));
  if (i10) for (let n10 in i10) e10 && e10[n10] == i10[n10] || (s10 = true, "style" == n10 ? t107.style.cssText = i10[n10] : t107.setAttribute(n10, i10[n10]));
  return s10;
}
let oW = class t41 extends ou {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  merge(e10, i10, s10, n10, o10, r10) {
    if (s10) {
      if (!(s10 instanceof t41)) return false;
      this.dom || s10.transferDOM(this);
    }
    return n10 && this.setDeco(s10 ? s10.attrs : null), om(this, e10, i10, s10 ? s10.children.slice() : [], o10, r10), true;
  }
  split(e10) {
    let i10 = new t41();
    if (i10.breakAfter = this.breakAfter, 0 == this.length) return i10;
    let { i: s10, off: n10 } = this.childPos(e10);
    n10 && (i10.append(this.children[s10].split(n10), 0), this.children[s10].merge(n10, this.children[s10].length, null, false, 0, 0), s10++);
    for (let t107 = s10; t107 < this.children.length; t107++) i10.append(this.children[t107], 0);
    for (; s10 > 0 && 0 == this.children[s10 - 1].length; ) this.children[--s10].destroy();
    return this.children.length = s10, this.markDirty(), this.length = e10, i10;
  }
  transferDOM(t107) {
    this.dom && (this.markDirty(), t107.setDOM(this.dom), t107.prevAttrs = void 0 === this.prevAttrs ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(t107) {
    oH(this.attrs, t107) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = t107);
  }
  append(t107, e10) {
    !function t108(e11, i10, s10) {
      let n10, { children: o10 } = e11;
      s10 > 0 && i10 instanceof oE && o10.length && (n10 = o10[o10.length - 1]) instanceof oE && n10.mark.eq(i10.mark) ? t108(n10, i10.children[0], s10 - 1) : (o10.push(i10), i10.setParent(e11)), e11.length += i10.length;
    }(this, t107, e10);
  }
  addLineDeco(t107) {
    let e10 = t107.spec.attributes, i10 = t107.spec.class;
    e10 && (this.attrs = oN(e10, this.attrs || {})), i10 && (this.attrs = oN({ class: i10 }, this.attrs || {}));
  }
  domAtPos(t107) {
    return oL(this, t107);
  }
  reuseDOM(t107) {
    "DIV" == t107.nodeName && (this.setDOM(t107), this.flags |= 6);
  }
  sync(t107, e10) {
    var i10;
    this.dom ? 4 & this.flags && (or(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), void 0 !== this.prevAttrs && (oF(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(t107, e10);
    let s10 = this.dom.lastChild;
    for (; s10 && ou.get(s10) instanceof oE; ) s10 = s10.lastChild;
    if (!s10 || !this.length || "BR" != s10.nodeName && (null === (i10 = ou.get(s10)) || void 0 === i10 ? void 0 : i10.isEditable) == false && (!oO.ios || !this.children.some((t108) => t108 instanceof oT))) {
      let t108 = document.createElement("BR");
      t108.cmIgnore = true, this.dom.appendChild(t108);
    }
  }
  measureTextSize() {
    if (0 == this.children.length || this.length > 20) return null;
    let t107 = 0, e10;
    for (let i10 of this.children) {
      if (!(i10 instanceof oT) || /[^ -~]/.test(i10.text)) return null;
      let s10 = n8(i10.dom);
      if (1 != s10.length) return null;
      t107 += s10[0].width, e10 = s10[0].height;
    }
    return t107 ? { lineHeight: this.dom.getBoundingClientRect().height, charWidth: t107 / this.length, textHeight: e10 } : null;
  }
  coordsAt(t107, e10) {
    let i10 = oP(this, t107, e10);
    if (!this.children.length && i10 && this.parent) {
      let { heightOracle: t108 } = this.parent.view.viewState, e11 = i10.bottom - i10.top;
      if (2 > Math.abs(e11 - t108.lineHeight) && t108.textHeight < e11) {
        let s10 = (e11 - t108.textHeight) / 2;
        return { top: i10.top + s10, bottom: i10.bottom - s10, left: i10.left, right: i10.left };
      }
    }
    return i10;
  }
  become(e10) {
    return e10 instanceof t41 && 0 == this.children.length && 0 == e10.children.length && oH(this.attrs, e10.attrs) && this.breakAfter == e10.breakAfter;
  }
  covers() {
    return true;
  }
  static find(e10, i10) {
    for (let s10 = 0, n10 = 0; s10 < e10.children.length; s10++) {
      let o10 = e10.children[s10], r10 = n10 + o10.length;
      if (r10 >= i10) {
        if (o10 instanceof t41) return o10;
        if (r10 > i10) break;
      }
      n10 = r10 + o10.breakAfter;
    }
    return null;
  }
}, oI = class t42 extends ou {
  constructor(t107, e10, i10) {
    super(), this.widget = t107, this.length = e10, this.deco = i10, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e10, i10, s10, n10, o10, r10) {
    return (!s10 || s10 instanceof t42 && !!this.widget.compare(s10.widget) && (!(e10 > 0) || !(o10 <= 0)) && (!(i10 < this.length) || !(r10 <= 0))) && (this.length = e10 + (s10 ? s10.length : 0) + (this.length - i10), true);
  }
  domAtPos(t107) {
    return 0 == t107 ? oc.before(this.dom) : oc.after(this.dom, t107 == this.length);
  }
  split(e10) {
    let i10 = this.length - e10;
    this.length = e10;
    let s10 = new t42(this.widget, i10, this.deco);
    return s10.breakAfter = this.breakAfter, s10;
  }
  get children() {
    return od;
  }
  sync(t107) {
    this.dom && this.widget.updateDOM(this.dom, t107) || (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t107)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : r.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e10) {
    return e10 instanceof t42 && e10.widget.constructor == this.widget.constructor && (e10.widget.compare(this.widget) || this.markDirty(true), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e10.widget, this.length = e10.length, this.deco = e10.deco, this.breakAfter = e10.breakAfter, true);
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(t107) {
    return this.widget.ignoreEvent(t107);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  coordsAt(t107, e10) {
    return this.widget.coordsAt(this.dom, t107, e10);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(t107) {
    let { startSide: e10, endSide: i10 } = this.deco;
    return e10 != i10 && (t107 < 0 ? e10 < 0 : i10 > 0);
  }
}, oz = class {
  eq(t107) {
    return false;
  }
  updateDOM(t107, e10) {
    return false;
  }
  compare(t107) {
    return this == t107 || this.constructor == t107.constructor && this.eq(t107);
  }
  get estimatedHeight() {
    return -1;
  }
  get lineBreaks() {
    return 0;
  }
  ignoreEvent(t107) {
    return true;
  }
  coordsAt(t107, e10, i10) {
    return null;
  }
  get isHidden() {
    return false;
  }
  get editable() {
    return false;
  }
  destroy(t107) {
  }
};
var oK = ((T = oK || (oK = {}))[T.Text = 0] = "Text", T[T.WidgetBefore = 1] = "WidgetBefore", T[T.WidgetAfter = 2] = "WidgetAfter", T[T.WidgetRange = 3] = "WidgetRange", T);
let oq = class extends tz {
  constructor(t107, e10, i10, s10) {
    super(), this.startSide = t107, this.endSide = e10, this.widget = i10, this.spec = s10;
  }
  get heightRelevant() {
    return false;
  }
  static mark(t107) {
    return new o_(t107);
  }
  static widget(t107) {
    let e10 = Math.max(-1e4, Math.min(1e4, t107.side || 0)), i10 = !!t107.block;
    return e10 += i10 && !t107.inlineOrder ? e10 > 0 ? 3e8 : -4e8 : e10 > 0 ? 1e8 : -1e8, new oj(t107, e10, e10, i10, t107.widget || null, false);
  }
  static replace(t107) {
    let e10 = !!t107.block, i10, s10;
    if (t107.isBlockGap) i10 = -5e8, s10 = 4e8;
    else {
      let { start: n10, end: o10 } = oU(t107, e10);
      i10 = (n10 ? e10 ? -3e8 : -1 : 5e8) - 1, s10 = (o10 ? e10 ? 2e8 : 1 : -6e8) + 1;
    }
    return new oj(t107, i10, s10, e10, t107.widget || null, true);
  }
  static line(t107) {
    return new oG(t107);
  }
  static set(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return tG.of(t107, e10);
  }
  hasHeight() {
    return !!this.widget && this.widget.estimatedHeight > -1;
  }
};
oq.none = tG.empty;
let o_ = class t43 extends oq {
  constructor(t107) {
    let { start: e10, end: i10 } = oU(t107);
    super(e10 ? -1 : 5e8, i10 ? 1 : -6e8, null, t107), this.tagName = t107.tagName || "span", this.class = t107.class || "", this.attrs = t107.attributes || null;
  }
  eq(e10) {
    var i10, s10;
    return this == e10 || e10 instanceof t43 && this.tagName == e10.tagName && (this.class || (null === (i10 = this.attrs) || void 0 === i10 ? void 0 : i10.class)) == (e10.class || (null === (s10 = e10.attrs) || void 0 === s10 ? void 0 : s10.class)) && oH(this.attrs, e10.attrs, "class");
  }
  range(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t107;
    if (t107 >= e10) throw RangeError("Mark decorations may not be empty");
    return super.range(t107, e10);
  }
};
o_.prototype.point = false;
let oG = class t44 extends oq {
  constructor(t107) {
    super(-2e8, -2e8, null, t107);
  }
  eq(e10) {
    return e10 instanceof t44 && this.spec.class == e10.spec.class && oH(this.spec.attributes, e10.spec.attributes);
  }
  range(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t107;
    if (e10 != t107) throw RangeError("Line decoration ranges must be zero-length");
    return super.range(t107, e10);
  }
};
oG.prototype.mapMode = j.TrackBefore, oG.prototype.point = true;
let oj = class t45 extends oq {
  constructor(t107, e10, i10, s10, n10, o10) {
    super(e10, i10, n10, t107), this.block = s10, this.isReplace = o10, this.mapMode = s10 ? e10 <= 0 ? j.TrackBefore : j.TrackAfter : j.TrackDel;
  }
  get type() {
    return this.startSide != this.endSide ? oK.WidgetRange : this.startSide <= 0 ? oK.WidgetBefore : oK.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e10) {
    var i10, s10;
    return e10 instanceof t45 && ((i10 = this.widget) == (s10 = e10.widget) || !!(i10 && s10 && i10.compare(s10))) && this.block == e10.block && this.startSide == e10.startSide && this.endSide == e10.endSide;
  }
  range(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t107;
    if (this.isReplace && (t107 > e10 || t107 == e10 && this.startSide > 0 && this.endSide <= 0)) throw RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && e10 != t107) throw RangeError("Widget decorations can only have zero-length ranges");
    return super.range(t107, e10);
  }
};
function oU(t107) {
  let e10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], { inclusiveStart: i10, inclusiveEnd: s10 } = t107;
  return null == i10 && (i10 = t107.inclusive), null == s10 && (s10 = t107.inclusive), { start: null != i10 ? i10 : e10, end: null != s10 ? s10 : e10 };
}
function oY(t107, e10, i10) {
  let s10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, n10 = i10.length - 1;
  n10 >= 0 && i10[n10] + s10 >= t107 ? i10[n10] = Math.max(i10[n10], e10) : i10.push(t107, e10);
}
oj.prototype.point = true;
let o$ = class t46 {
  constructor(t107, e10, i10, s10) {
    this.doc = t107, this.pos = e10, this.end = i10, this.disallowBlockEffectsFor = s10, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = true, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = t107.iter(), this.skip = e10;
  }
  posCovered() {
    if (0 == this.content.length) return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let t107 = this.content[this.content.length - 1];
    return !(t107.breakAfter || t107 instanceof oI && t107.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new oW()), this.atCursorPos = true), this.curLine;
  }
  flushBuffer() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.bufferMarks;
    this.pendingBuffer && (this.curLine.append(oX(new oB(-1), t107), t107.length), this.pendingBuffer = 0);
  }
  addBlockWidget(t107) {
    this.flushBuffer(), this.curLine = null, this.content.push(t107);
  }
  finish(t107) {
    this.pendingBuffer && t107 <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, this.posCovered() || t107 && this.content.length && this.content[this.content.length - 1] instanceof oI || this.getLine();
  }
  buildText(t107, e10, i10) {
    for (; t107 > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: e11, lineBreak: i11, done: s11 } = this.cursor.next(this.skip);
        if (this.skip = 0, s11) throw Error("Ran out of text content when drawing inline views");
        if (i11) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = true, t107--;
          continue;
        }
        this.text = e11, this.textOff = 0;
      }
      let s10 = Math.min(this.text.length - this.textOff, t107, 512);
      this.flushBuffer(e10.slice(e10.length - i10)), this.getLine().append(oX(new oT(this.text.slice(this.textOff, this.textOff + s10)), e10), i10), this.atCursorPos = true, this.textOff += s10, t107 -= s10, i10 = 0;
    }
  }
  span(t107, e10, i10, s10) {
    this.buildText(e10 - t107, i10, s10), this.pos = e10, this.openStart < 0 && (this.openStart = s10);
  }
  point(t107, e10, i10, s10, n10, o10) {
    if (this.disallowBlockEffectsFor[o10] && i10 instanceof oj) {
      if (i10.block) throw RangeError("Block decorations may not be specified via plugins");
      if (e10 > this.doc.lineAt(this.pos).to) throw RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let r10 = e10 - t107;
    if (i10 instanceof oj) {
      if (i10.block) i10.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new oI(i10.widget || oJ.block, r10, i10));
      else {
        let o11 = oR.create(i10.widget || oJ.inline, r10, r10 ? 0 : i10.startSide), l10 = this.atCursorPos && !o11.isEditable && n10 <= s10.length && (t107 < e10 || i10.startSide > 0), h10 = !o11.isEditable && (t107 < e10 || n10 > s10.length || i10.startSide <= 0), a10 = this.getLine();
        2 != this.pendingBuffer || l10 || o11.isEditable || (this.pendingBuffer = 0), this.flushBuffer(s10), l10 && (a10.append(oX(new oB(1), s10), n10), n10 = s10.length + Math.max(0, n10 - s10.length)), a10.append(oX(o11, s10), n10), this.atCursorPos = h10, this.pendingBuffer = h10 ? t107 < e10 || n10 > s10.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = s10.slice());
      }
    } else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i10);
    r10 && (this.textOff + r10 <= this.text.length ? this.textOff += r10 : (this.skip += r10 - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = e10), this.openStart < 0 && (this.openStart = n10);
  }
  static build(e10, i10, s10, n10, o10) {
    let r10 = new t46(e10, i10, s10, o10);
    return r10.openEnd = tG.spans(n10, i10, s10, r10), r10.openStart < 0 && (r10.openStart = r10.openEnd), r10.finish(r10.openEnd), r10;
  }
};
function oX(t107, e10) {
  for (let i10 of e10) t107 = new oE(i10, [t107], t107.length);
  return t107;
}
let oJ = class extends oz {
  constructor(t107) {
    super(), this.tag = t107;
  }
  eq(t107) {
    return t107.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(t107) {
    return t107.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return true;
  }
};
oJ.inline = new oJ("span"), oJ.block = new oJ("div");
var oQ = ((E = oQ || (oQ = {}))[E.LTR = 0] = "LTR", E[E.RTL = 1] = "RTL", E);
let oZ = oQ.LTR, o0 = oQ.RTL;
function o1(t107) {
  let e10 = [];
  for (let i10 = 0; i10 < t107.length; i10++) e10.push(1 << +t107[i10]);
  return e10;
}
let o2 = o1("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), o8 = o1("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), o3 = /* @__PURE__ */ Object.create(null), o4 = [];
for (let t107 of ["()", "[]", "{}"]) {
  let e10 = t107.charCodeAt(0), i10 = t107.charCodeAt(1);
  o3[e10] = i10, o3[i10] = -e10;
}
function o9(t107) {
  return t107 <= 247 ? o2[t107] : 1424 <= t107 && t107 <= 1524 ? 2 : 1536 <= t107 && t107 <= 1785 ? o8[t107 - 1536] : 1774 <= t107 && t107 <= 2220 ? 4 : 8192 <= t107 && t107 <= 8204 ? 256 : 64336 <= t107 && t107 <= 65023 ? 4 : 1;
}
let o5 = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/, o6 = class {
  get dir() {
    return this.level % 2 ? o0 : oZ;
  }
  constructor(t107, e10, i10) {
    this.from = t107, this.to = e10, this.level = i10;
  }
  side(t107, e10) {
    return this.dir == e10 == t107 ? this.to : this.from;
  }
  forward(t107, e10) {
    return t107 == (this.dir == e10);
  }
  static find(t107, e10, i10, s10) {
    let n10 = -1;
    for (let o10 = 0; o10 < t107.length; o10++) {
      let r10 = t107[o10];
      if (r10.from <= e10 && r10.to >= e10) {
        if (r10.level == i10) return o10;
        (n10 < 0 || (0 != s10 ? s10 < 0 ? r10.from < e10 : r10.to > e10 : t107[n10].level > r10.level)) && (n10 = o10);
      }
    }
    if (n10 < 0) throw RangeError("Index out of range");
    return n10;
  }
}, o7 = [];
function rt(t107) {
  return [new o6(0, t107, 0)];
}
let re = "", ri = to.define(), rs = to.define(), rn = to.define(), ro = to.define(), rr = to.define(), rl = to.define(), rh = to.define(), ra = to.define({ combine: (t107) => t107.some((t108) => t108) }), rc = to.define({ combine: (t107) => t107.some((t108) => t108) }), rd = to.define(), ru = class t47 {
  constructor(t107, e10 = "nearest", i10 = "nearest", s10 = 5, n10 = 5, o10 = false) {
    this.range = t107, this.y = e10, this.x = i10, this.yMargin = s10, this.xMargin = n10, this.isSnapshot = o10;
  }
  map(e10) {
    return e10.empty ? this : new t47(this.range.map(e10), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e10) {
    return this.range.to <= e10.doc.length ? this : new t47(ti.cursor(e10.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}, rf = tR.define({ map: (t107, e10) => t107.map(e10) }), rg = tR.define();
function rp(t107, e10, i10) {
  let s10 = t107.facet(ro);
  s10.length ? s10[0](e10) : window.onerror ? window.onerror(String(e10), i10, void 0, void 0, e10) : i10 ? console.error(i10 + ":", e10) : console.error(e10);
}
let rm = to.define({ combine: (t107) => !t107.length || t107[0] }), rv = 0, rw = to.define(), rb = class t48 {
  constructor(t107, e10, i10, s10, n10) {
    this.id = t107, this.create = e10, this.domEventHandlers = i10, this.domEventObservers = s10, this.extension = n10(this);
  }
  static define(e10, i10) {
    let { eventHandlers: s10, eventObservers: n10, provide: o10, decorations: r10 } = i10 || {};
    return new t48(rv++, e10, s10, n10, (t107) => {
      let e11 = [rw.of(t107)];
      return r10 && e11.push(rk.of((e12) => {
        let i11 = e12.plugin(t107);
        return i11 ? r10(i11) : oq.none;
      })), o10 && e11.push(o10(t107)), e11;
    });
  }
  static fromClass(e10, i10) {
    return t48.define((t107) => new e10(t107), i10);
  }
}, ry = class {
  constructor(t107) {
    this.spec = t107, this.mustUpdate = null, this.value = null;
  }
  update(t107) {
    if (this.value) {
      if (this.mustUpdate) {
        let t108 = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update) try {
          this.value.update(t108);
        } catch (e10) {
          if (rp(t108.state, e10, "CodeMirror plugin crashed"), this.value.destroy) try {
            this.value.destroy();
          } catch (t109) {
          }
          this.deactivate();
        }
      }
    } else if (this.spec) try {
      this.value = this.spec.create(t107);
    } catch (e10) {
      rp(t107.state, e10, "CodeMirror plugin crashed"), this.deactivate();
    }
    return this;
  }
  destroy(t107) {
    var e10;
    if (null === (e10 = this.value) || void 0 === e10 ? void 0 : e10.destroy) try {
      this.value.destroy();
    } catch (e11) {
      rp(t107.state, e11, "CodeMirror plugin crashed");
    }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}, rx = to.define(), rS = to.define(), rk = to.define(), rM = to.define(), rC = to.define(), rA = to.define();
function rD(t107, e10) {
  let i10 = t107.state.facet(rA);
  if (!i10.length) return i10;
  let s10 = i10.map((e11) => e11 instanceof Function ? e11(t107) : e11), n10 = [];
  return tG.spans(s10, e10.from, e10.to, { point() {
  }, span(t108, i11, s11, o10) {
    let r10 = t108 - e10.from, l10 = i11 - e10.from, h10 = n10;
    for (let t109 = s11.length - 1; t109 >= 0; t109--, o10--) {
      let i12 = s11[t109].spec.bidiIsolate, n11;
      if (null == i12 && (i12 = function(t110, e11, i13) {
        for (let s12 = e11; s12 < i13; s12++) {
          let e12 = o9(t110.charCodeAt(s12));
          if (1 == e12) break;
          if (2 == e12 || 4 == e12) return o0;
        }
        return oZ;
      }(e10.text, r10, l10)), o10 > 0 && h10.length && (n11 = h10[h10.length - 1]).to == r10 && n11.direction == i12) n11.to = l10, h10 = n11.inner;
      else {
        let t110 = { from: r10, to: l10, direction: i12, inner: [] };
        h10.push(t110), h10 = t110.inner;
      }
    }
  } }), n10;
}
let rO = to.define();
function rT(t107) {
  let e10 = 0, i10 = 0, s10 = 0, n10 = 0;
  for (let o10 of t107.state.facet(rO)) {
    let r10 = o10(t107);
    r10 && (null != r10.left && (e10 = Math.max(e10, r10.left)), null != r10.right && (i10 = Math.max(i10, r10.right)), null != r10.top && (s10 = Math.max(s10, r10.top)), null != r10.bottom && (n10 = Math.max(n10, r10.bottom)));
  }
  return { left: e10, right: i10, top: s10, bottom: n10 };
}
let rE = to.define(), rR = class t49 {
  constructor(t107, e10, i10, s10) {
    this.fromA = t107, this.toA = e10, this.fromB = i10, this.toB = s10;
  }
  join(e10) {
    return new t49(Math.min(this.fromA, e10.fromA), Math.max(this.toA, e10.toA), Math.min(this.fromB, e10.fromB), Math.max(this.toB, e10.toB));
  }
  addToSet(t107) {
    let e10 = t107.length, i10 = this;
    for (; e10 > 0; e10--) {
      let s10 = t107[e10 - 1];
      if (!(s10.fromA > i10.toA)) {
        if (s10.toA < i10.fromA) break;
        i10 = i10.join(s10), t107.splice(e10 - 1, 1);
      }
    }
    return t107.splice(e10, 0, i10), t107;
  }
  static extendWithRanges(e10, i10) {
    if (0 == i10.length) return e10;
    let s10 = [];
    for (let n10 = 0, o10 = 0, r10 = 0, l10 = 0; ; n10++) {
      let h10 = n10 == e10.length ? null : e10[n10], a10 = r10 - l10, c10 = h10 ? h10.fromB : 1e9;
      for (; o10 < i10.length && i10[o10] < c10; ) {
        let e11 = i10[o10], n11 = i10[o10 + 1], r11 = Math.max(l10, e11), h11 = Math.min(c10, n11);
        if (r11 <= h11 && new t49(r11 + a10, h11 + a10, r11, h11).addToSet(s10), n11 > c10) break;
        o10 += 2;
      }
      if (!h10) return s10;
      new t49(h10.fromA, h10.toA, h10.fromB, h10.toB).addToSet(s10), r10 = h10.toA, l10 = h10.toB;
    }
  }
}, rB = class t50 {
  constructor(t107, e10, i10) {
    for (let s11 of (this.view = t107, this.state = e10, this.transactions = i10, this.flags = 0, this.startState = t107.state, this.changes = Y.empty(this.startState.doc.length), i10)) this.changes = this.changes.compose(s11.changes);
    let s10 = [];
    this.changes.iterChangedRanges((t108, e11, i11, n10) => s10.push(new rR(t108, e11, i11, n10))), this.changedRanges = s10;
  }
  static create(e10, i10, s10) {
    return new t50(e10, i10, s10);
  }
  get viewportChanged() {
    return (4 & this.flags) > 0;
  }
  get heightChanged() {
    return (2 & this.flags) > 0;
  }
  get geometryChanged() {
    return this.docChanged || (10 & this.flags) > 0;
  }
  get focusChanged() {
    return (1 & this.flags) > 0;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get selectionSet() {
    return this.transactions.some((t107) => t107.selection);
  }
  get empty() {
    return 0 == this.flags && 0 == this.transactions.length;
  }
}, rL = class extends ou {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(t107) {
    super(), this.view = t107, this.decorations = [], this.dynamicDecorationMap = [false], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = oq.none, this.lastCompositionAfterCursor = false, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = false, this.lastUpdate = Date.now(), this.setDOM(t107.contentDOM), this.children = [new oW()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new rR(0, 0, 0, t107.state.doc.length)], 0, null);
  }
  update(t107) {
    var e10, i10, s10, n10, o10, r10;
    let l10, h10;
    let a10 = t107.changedRanges;
    this.minWidth > 0 && a10.length && (a10.every((t108) => {
      let { fromA: e11, toA: i11 } = t108;
      return i11 < this.minWidthFrom || e11 > this.minWidthTo;
    }) ? (this.minWidthFrom = t107.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = t107.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(t107);
    let c10 = -1;
    !(this.view.inputState.composing >= 0) || this.view.observer.editContext || ((null === (e10 = this.domChanged) || void 0 === e10 ? void 0 : e10.newSel) ? c10 = this.domChanged.newSel.head : (i10 = t107.changes, s10 = this.hasComposition, l10 = false, s10 && i10.iterChangedRanges((t108, e11) => {
      t108 < s10.to && e11 > s10.from && (l10 = true);
    }), l10 || t107.selectionSet || (c10 = t107.state.selection.main.head)));
    let d10 = c10 > -1 ? function(t108, e11, i11) {
      let s11 = rN(t108, i11);
      if (!s11) return null;
      let { node: n11, from: o11, to: r11 } = s11, l11 = n11.nodeValue;
      if (/[\n\r]/.test(l11) || t108.state.doc.sliceString(s11.from, s11.to) != l11) return null;
      let h11 = e11.invertedDesc, a11 = new rR(h11.mapPos(o11), h11.mapPos(r11), o11, r11), c11 = [];
      for (let e12 = n11.parentNode; ; e12 = e12.parentNode) {
        let i12 = ou.get(e12);
        if (i12 instanceof oE) c11.push({ node: e12, deco: i12.mark });
        else {
          if (i12 instanceof oW || "DIV" == e12.nodeName && e12.parentNode == t108.contentDOM) return { range: a11, text: n11, marks: c11, line: e12 };
          if (e12 == t108.contentDOM) return null;
          c11.push({ node: e12, deco: new o_({ inclusive: true, attributes: function(t109) {
            let e13 = /* @__PURE__ */ Object.create(null);
            for (let i13 = 0; i13 < t109.attributes.length; i13++) {
              let s12 = t109.attributes[i13];
              e13[s12.name] = s12.value;
            }
            return e13;
          }(e12), tagName: e12.tagName.toLowerCase() }) });
        }
      }
    }(this.view, t107.changes, c10) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: e11, to: i11 } = this.hasComposition;
      a10 = new rR(e11, i11, t107.changes.mapPos(e11, -1), t107.changes.mapPos(i11, 1)).addToSet(a10.slice());
    }
    this.hasComposition = d10 ? { from: d10.range.fromB, to: d10.range.toB } : null, (oO.ie || oO.chrome) && !d10 && t107 && t107.state.doc.lines != t107.startState.doc.lines && (this.forceSelection = true);
    let u10 = (n10 = this.decorations, o10 = this.updateDeco(), r10 = t107.changes, h10 = new rV(), tG.compare(n10, o10, r10, h10), h10.changes);
    return a10 = rR.extendWithRanges(a10, u10), (!!(7 & this.flags) || 0 != a10.length) && (this.updateInner(a10, t107.startState.doc.length, d10), t107.transactions.length && (this.lastUpdate = Date.now()), true);
  }
  updateInner(t107, e10, i10) {
    this.view.viewState.mustMeasureContent = true, this.updateChildren(t107, e10, i10);
    let { observer: s10 } = this.view;
    s10.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let t108 = oO.chrome || oO.ios ? { node: s10.selectionRange.focusNode, written: false } : void 0;
      this.sync(this.view, t108), this.flags &= -8, t108 && (t108.written || s10.selectionRange.focusNode != t108.node) && (this.forceSelection = true), this.dom.style.height = "";
    }), this.markedForComposition.forEach((t108) => t108.flags &= -9);
    let n10 = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) for (let t108 of this.children) t108 instanceof oI && t108.widget instanceof rP && n10.push(t108.dom);
    s10.updateGaps(n10);
  }
  updateChildren(t107, e10, i10) {
    let s10 = i10 ? i10.range.addToSet(t107.slice()) : t107, n10 = this.childCursor(e10);
    for (let t108 = s10.length - 1; ; t108--) {
      let e11 = t108 >= 0 ? s10[t108] : null;
      if (!e11) break;
      let { fromA: o10, toA: r10, fromB: l10, toB: h10 } = e11, a10, c10, d10, u10;
      if (i10 && i10.range.fromB < h10 && i10.range.toB > l10) {
        let t109 = o$.build(this.view.state.doc, l10, i10.range.fromB, this.decorations, this.dynamicDecorationMap), e12 = o$.build(this.view.state.doc, i10.range.toB, h10, this.decorations, this.dynamicDecorationMap);
        c10 = t109.breakAtStart, d10 = t109.openStart, u10 = e12.openEnd;
        let s11 = this.compositionView(i10);
        e12.breakAtStart ? s11.breakAfter = 1 : e12.content.length && s11.merge(s11.length, s11.length, e12.content[0], false, e12.openStart, 0) && (s11.breakAfter = e12.content[0].breakAfter, e12.content.shift()), t109.content.length && s11.merge(0, 0, t109.content[t109.content.length - 1], true, 0, t109.openEnd) && t109.content.pop(), a10 = t109.content.concat(s11).concat(e12.content);
      } else ({ content: a10, breakAtStart: c10, openStart: d10, openEnd: u10 } = o$.build(this.view.state.doc, l10, h10, this.decorations, this.dynamicDecorationMap));
      let { i: f10, off: g10 } = n10.findPos(r10, 1), { i: p10, off: m10 } = n10.findPos(o10, -1);
      op(this, p10, m10, f10, g10, a10, c10, d10, u10);
    }
    i10 && this.fixCompositionDOM(i10);
  }
  updateEditContextFormatting(t107) {
    for (let e10 of (this.editContextFormatting = this.editContextFormatting.map(t107.changes), t107.transactions)) for (let t108 of e10.effects) t108.is(rg) && (this.editContextFormatting = t108.value);
  }
  compositionView(t107) {
    let e10 = new oT(t107.text.nodeValue);
    for (let { deco: i11 } of (e10.flags |= 8, t107.marks)) e10 = new oE(i11, [e10], e10.length);
    let i10 = new oW();
    return i10.append(e10, 0), i10;
  }
  fixCompositionDOM(t107) {
    let e10 = (t108, e11) => {
      e11.flags |= 8 | (e11.children.some((t109) => 7 & t109.flags) ? 1 : 0), this.markedForComposition.add(e11);
      let i11 = ou.get(t108);
      i11 && i11 != e11 && (i11.dom = null), e11.setDOM(t108);
    }, i10 = this.childPos(t107.range.fromB, 1), s10 = this.children[i10.i];
    e10(t107.line, s10);
    for (let n10 = t107.marks.length - 1; n10 >= -1; n10--) i10 = s10.childPos(i10.off, 1), s10 = s10.children[i10.i], e10(n10 >= 0 ? t107.marks[n10].node : t107.text, s10);
  }
  updateSelection() {
    var t107;
    let e10 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], i10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    (e10 || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let s10 = this.view.root.activeElement, n10 = s10 == this.dom, o10 = !n10 && n2(this.dom, this.view.observer.selectionRange) && !(s10 && this.dom.contains(s10));
    if (!(n10 || i10 || o10)) return;
    let r10 = this.forceSelection;
    this.forceSelection = false;
    let l10 = this.view.state.selection.main, h10 = this.moveToLine(this.domAtPos(l10.anchor)), a10 = l10.empty ? h10 : this.moveToLine(this.domAtPos(l10.head));
    if (oO.gecko && l10.empty && !this.hasComposition && 1 == (t107 = h10).node.nodeType && t107.node.firstChild && (0 == t107.offset || "false" == t107.node.childNodes[t107.offset - 1].contentEditable) && (t107.offset == t107.node.childNodes.length || "false" == t107.node.childNodes[t107.offset].contentEditable)) {
      let t108 = document.createTextNode("");
      this.view.observer.ignore(() => h10.node.insertBefore(t108, h10.node.childNodes[h10.offset] || null)), h10 = a10 = new oc(t108, 0), r10 = true;
    }
    let c10 = this.view.observer.selectionRange;
    !r10 && c10.focusNode && (n3(h10.node, h10.offset, c10.anchorNode, c10.anchorOffset) && n3(a10.node, a10.offset, c10.focusNode, c10.focusOffset) || this.suppressWidgetCursorChange(c10, l10)) || (this.view.observer.ignore(() => {
      oO.android && oO.chrome && this.dom.contains(c10.focusNode) && function(t109, e12) {
        for (let i12 = t109; i12 && i12 != e12; i12 = i12.assignedSlot || i12.parentNode) if (1 == i12.nodeType && "false" == i12.contentEditable) return true;
        return false;
      }(c10.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: true }));
      let t108 = n0(this.view.root);
      if (t108) {
        if (l10.empty) {
          if (oO.gecko) {
            var e11, i11;
            let t109 = (e11 = h10.node, i11 = h10.offset, 1 != e11.nodeType ? 0 : (i11 && "false" == e11.childNodes[i11 - 1].contentEditable ? 1 : 0) | (i11 < e11.childNodes.length && "false" == e11.childNodes[i11].contentEditable ? 2 : 0));
            if (t109 && 3 != t109) {
              let e12 = (1 == t109 ? oh : oa)(h10.node, h10.offset);
              e12 && (h10 = new oc(e12.node, e12.offset));
            }
          }
          t108.collapse(h10.node, h10.offset), null != l10.bidiLevel && void 0 !== t108.caretBidiLevel && (t108.caretBidiLevel = l10.bidiLevel);
        } else if (t108.extend) {
          t108.collapse(h10.node, h10.offset);
          try {
            t108.extend(a10.node, a10.offset);
          } catch (t109) {
          }
        } else {
          let e12 = document.createRange();
          l10.anchor > l10.head && ([h10, a10] = [a10, h10]), e12.setEnd(a10.node, a10.offset), e12.setStart(h10.node, h10.offset), t108.removeAllRanges(), t108.addRange(e12);
        }
      }
      o10 && this.view.root.activeElement == this.dom && (this.dom.blur(), s10 && s10.focus());
    }), this.view.observer.setSelectionRange(h10, a10)), this.impreciseAnchor = h10.precise ? null : new oc(c10.anchorNode, c10.anchorOffset), this.impreciseHead = a10.precise ? null : new oc(c10.focusNode, c10.focusOffset);
  }
  suppressWidgetCursorChange(t107, e10) {
    return this.hasComposition && e10.empty && n3(t107.focusNode, t107.focusOffset, t107.anchorNode, t107.anchorOffset) && this.posFromDOM(t107.focusNode, t107.focusOffset) == e10.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition) return;
    let { view: t107 } = this, e10 = t107.state.selection.main, i10 = n0(t107.root), { anchorNode: s10, anchorOffset: n10 } = t107.observer.selectionRange;
    if (!i10 || !e10.empty || !e10.assoc || !i10.modify) return;
    let o10 = oW.find(this, e10.head);
    if (!o10) return;
    let r10 = o10.posAtStart;
    if (e10.head == r10 || e10.head == r10 + o10.length) return;
    let l10 = this.coordsAt(e10.head, -1), h10 = this.coordsAt(e10.head, 1);
    if (!l10 || !h10 || l10.bottom > h10.top) return;
    let a10 = this.domAtPos(e10.head + e10.assoc);
    i10.collapse(a10.node, a10.offset), i10.modify("move", e10.assoc < 0 ? "forward" : "backward", "lineboundary"), t107.observer.readSelectionRange();
    let c10 = t107.observer.selectionRange;
    t107.docView.posFromDOM(c10.anchorNode, c10.anchorOffset) != e10.from && i10.collapse(s10, n10);
  }
  moveToLine(t107) {
    let e10 = this.dom, i10;
    if (t107.node != e10) return t107;
    for (let s10 = t107.offset; !i10 && s10 < e10.childNodes.length; s10++) {
      let t108 = ou.get(e10.childNodes[s10]);
      t108 instanceof oW && (i10 = t108.domAtPos(0));
    }
    for (let s10 = t107.offset - 1; !i10 && s10 >= 0; s10--) {
      let t108 = ou.get(e10.childNodes[s10]);
      t108 instanceof oW && (i10 = t108.domAtPos(t108.length));
    }
    return i10 ? new oc(i10.node, i10.offset, true) : t107;
  }
  nearest(t107) {
    for (let e10 = t107; e10; ) {
      let t108 = ou.get(e10);
      if (t108 && t108.rootView == this) return t108;
      e10 = e10.parentNode;
    }
    return null;
  }
  posFromDOM(t107, e10) {
    let i10 = this.nearest(t107);
    if (!i10) throw RangeError("Trying to find position for a DOM position outside of the document");
    return i10.localPosFromDOM(t107, e10) + i10.posAtStart;
  }
  domAtPos(t107) {
    let { i: e10, off: i10 } = this.childCursor().findPos(t107, -1);
    for (; e10 < this.children.length - 1; ) {
      let t108 = this.children[e10];
      if (i10 < t108.length || t108 instanceof oW) break;
      e10++, i10 = 0;
    }
    return this.children[e10].domAtPos(i10);
  }
  coordsAt(t107, e10) {
    let i10 = null, s10 = 0;
    for (let n10 = this.length, o10 = this.children.length - 1; o10 >= 0; o10--) {
      let r10 = this.children[o10], l10 = n10 - r10.breakAfter, h10 = l10 - r10.length;
      if (l10 < t107) break;
      if (h10 <= t107 && (h10 < t107 || r10.covers(-1)) && (l10 > t107 || r10.covers(1)) && (!i10 || r10 instanceof oW && !(i10 instanceof oW && e10 >= 0))) i10 = r10, s10 = h10;
      else if (i10 && h10 == t107 && l10 == t107 && r10 instanceof oI && 2 > Math.abs(e10)) {
        if (r10.deco.startSide < 0) break;
        o10 && (i10 = null);
      }
      n10 = h10;
    }
    return i10 ? i10.coordsAt(t107 - s10, e10) : null;
  }
  coordsForChar(t107) {
    let { i: e10, off: i10 } = this.childPos(t107, 1), s10 = this.children[e10];
    if (!(s10 instanceof oW)) return null;
    for (; s10.children.length; ) {
      let { i: t108, off: e11 } = s10.childPos(i10, 1);
      for (; ; t108++) {
        if (t108 == s10.children.length) return null;
        if ((s10 = s10.children[t108]).length) break;
      }
      i10 = e11;
    }
    if (!(s10 instanceof oT)) return null;
    let n10 = v(s10.text, i10);
    if (n10 == i10) return null;
    let o10 = on(s10.dom, i10, n10).getClientRects();
    for (let t108 = 0; t108 < o10.length; t108++) {
      let e11 = o10[t108];
      if (t108 == o10.length - 1 || e11.top < e11.bottom && e11.left < e11.right) return e11;
    }
    return null;
  }
  measureVisibleLineHeights(t107) {
    let e10 = [], { from: i10, to: s10 } = t107, n10 = this.view.contentDOM.clientWidth, o10 = n10 > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, r10 = -1, l10 = this.view.textDirection == oQ.LTR;
    for (let t108 = 0, h10 = 0; h10 < this.children.length; h10++) {
      let a10 = this.children[h10], c10 = t108 + a10.length;
      if (c10 > s10) break;
      if (t108 >= i10) {
        let i11 = a10.dom.getBoundingClientRect();
        if (e10.push(i11.height), o10) {
          let e11 = a10.dom.lastChild, s11 = e11 ? n8(e11) : [];
          if (s11.length) {
            let e12 = s11[s11.length - 1], o11 = l10 ? e12.right - i11.left : i11.right - e12.left;
            o11 > r10 && (r10 = o11, this.minWidth = n10, this.minWidthFrom = t108, this.minWidthTo = c10);
          }
        }
      }
      t108 = c10 + a10.breakAfter;
    }
    return e10;
  }
  textDirectionAt(t107) {
    let { i: e10 } = this.childPos(t107, 1);
    return "rtl" == getComputedStyle(this.children[e10].dom).direction ? oQ.RTL : oQ.LTR;
  }
  measureTextSize() {
    for (let t108 of this.children) if (t108 instanceof oW) {
      let e11 = t108.measureTextSize();
      if (e11) return e11;
    }
    let t107 = document.createElement("div"), e10, i10, s10;
    return t107.className = "cm-line", t107.style.width = "99999px", t107.style.position = "absolute", t107.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(t107);
      let n10 = n8(t107.firstChild)[0];
      e10 = t107.getBoundingClientRect().height, i10 = n10 ? n10.width / 27 : 7, s10 = n10 ? n10.height : e10, t107.remove();
    }), { lineHeight: e10, charWidth: i10, textHeight: s10 };
  }
  childCursor() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.length, e10 = this.children.length;
    return e10 && (t107 -= this.children[--e10].length), new og(this.children, t107, e10);
  }
  computeBlockGapDeco() {
    let t107 = [], e10 = this.view.viewState;
    for (let i10 = 0, s10 = 0; ; s10++) {
      let n10 = s10 == e10.viewports.length ? null : e10.viewports[s10], o10 = n10 ? n10.from - 1 : this.length;
      if (o10 > i10) {
        let s11 = (e10.lineBlockAt(o10).bottom - e10.lineBlockAt(i10).top) / this.view.scaleY;
        t107.push(oq.replace({ widget: new rP(s11), block: true, inclusive: true, isBlockGap: true }).range(i10, o10));
      }
      if (!n10) break;
      i10 = n10.to + 1;
    }
    return oq.set(t107);
  }
  updateDeco() {
    let t107 = 1, e10 = this.view.state.facet(rk).map((e11) => (this.dynamicDecorationMap[t107++] = "function" == typeof e11) ? e11(this.view) : e11), i10 = false, s10 = this.view.state.facet(rM).map((t108, e11) => {
      let s11 = "function" == typeof t108;
      return s11 && (i10 = true), s11 ? t108(this.view) : t108;
    });
    for (s10.length && (this.dynamicDecorationMap[t107++] = i10, e10.push(tG.join(s10))), this.decorations = [this.editContextFormatting, ...e10, this.computeBlockGapDeco(), this.view.viewState.lineGapDeco]; t107 < this.decorations.length; ) this.dynamicDecorationMap[t107++] = false;
    return this.decorations;
  }
  scrollIntoView(t107) {
    if (t107.isSnapshot) {
      let e11 = this.view.viewState.lineBlockAt(t107.range.head);
      this.view.scrollDOM.scrollTop = e11.top - t107.yMargin, this.view.scrollDOM.scrollLeft = t107.xMargin;
      return;
    }
    for (let e11 of this.view.state.facet(rd)) try {
      if (e11(this.view, t107.range, t107)) return true;
    } catch (t108) {
      rp(this.view.state, t108, "scroll handler");
    }
    let { range: e10 } = t107, i10 = this.coordsAt(e10.head, e10.empty ? e10.assoc : e10.head > e10.anchor ? -1 : 1), s10;
    if (!i10) return;
    !e10.empty && (s10 = this.coordsAt(e10.anchor, e10.anchor > e10.head ? -1 : 1)) && (i10 = { left: Math.min(i10.left, s10.left), top: Math.min(i10.top, s10.top), right: Math.max(i10.right, s10.right), bottom: Math.max(i10.bottom, s10.bottom) });
    let n10 = rT(this.view), o10 = { left: i10.left - n10.left, top: i10.top - n10.top, right: i10.right + n10.right, bottom: i10.bottom + n10.bottom }, { offsetWidth: r10, offsetHeight: l10 } = this.view.scrollDOM;
    !function(t108, e11, i11, s11, n11, o11, r11, l11) {
      let h10 = t108.ownerDocument, a10 = h10.defaultView || window;
      for (let c10 = t108, d10 = false; c10 && !d10; ) if (1 == c10.nodeType) {
        let t109, u10 = c10 == h10.body, f10 = 1, g10 = 1;
        if (u10) t109 = function(t110) {
          let e12 = t110.visualViewport;
          return e12 ? { left: 0, right: e12.width, top: 0, bottom: e12.height } : { left: 0, right: t110.innerWidth, top: 0, bottom: t110.innerHeight };
        }(a10);
        else {
          if (/^(fixed|sticky)$/.test(getComputedStyle(c10).position) && (d10 = true), c10.scrollHeight <= c10.clientHeight && c10.scrollWidth <= c10.clientWidth) {
            c10 = c10.assignedSlot || c10.parentNode;
            continue;
          }
          let e12 = c10.getBoundingClientRect();
          ({ scaleX: f10, scaleY: g10 } = ot(c10, e12)), t109 = { left: e12.left, right: e12.left + c10.clientWidth * f10, top: e12.top, bottom: e12.top + c10.clientHeight * g10 };
        }
        let p10 = 0, m10 = 0;
        if ("nearest" == n11) e11.top < t109.top ? (m10 = -(t109.top - e11.top + r11), i11 > 0 && e11.bottom > t109.bottom + m10 && (m10 = e11.bottom - t109.bottom + m10 + r11)) : e11.bottom > t109.bottom && (m10 = e11.bottom - t109.bottom + r11, i11 < 0 && e11.top - m10 < t109.top && (m10 = -(t109.top + m10 - e11.top + r11)));
        else {
          let s12 = e11.bottom - e11.top, o12 = t109.bottom - t109.top;
          m10 = ("center" == n11 && s12 <= o12 ? e11.top + s12 / 2 - o12 / 2 : "start" == n11 || "center" == n11 && i11 < 0 ? e11.top - r11 : e11.bottom - o12 + r11) - t109.top;
        }
        if ("nearest" == s11 ? e11.left < t109.left ? (p10 = -(t109.left - e11.left + o11), i11 > 0 && e11.right > t109.right + p10 && (p10 = e11.right - t109.right + p10 + o11)) : e11.right > t109.right && (p10 = e11.right - t109.right + o11, i11 < 0 && e11.left < t109.left + p10 && (p10 = -(t109.left + p10 - e11.left + o11))) : p10 = ("center" == s11 ? e11.left + (e11.right - e11.left) / 2 - (t109.right - t109.left) / 2 : "start" == s11 == l11 ? e11.left - o11 : e11.right - (t109.right - t109.left) + o11) - t109.left, p10 || m10) {
          if (u10) a10.scrollBy(p10, m10);
          else {
            let t110 = 0, i12 = 0;
            if (m10) {
              let t111 = c10.scrollTop;
              c10.scrollTop += m10 / g10, i12 = (c10.scrollTop - t111) * g10;
            }
            if (p10) {
              let e12 = c10.scrollLeft;
              c10.scrollLeft += p10 / f10, t110 = (c10.scrollLeft - e12) * f10;
            }
            e11 = { left: e11.left - t110, top: e11.top - i12, right: e11.right - t110, bottom: e11.bottom - i12 }, t110 && 1 > Math.abs(t110 - p10) && (s11 = "nearest"), i12 && 1 > Math.abs(i12 - m10) && (n11 = "nearest");
          }
        }
        if (u10) break;
        c10 = c10.assignedSlot || c10.parentNode;
      } else if (11 == c10.nodeType) c10 = c10.host;
      else break;
    }(this.view.scrollDOM, o10, e10.head < e10.anchor ? -1 : 1, t107.x, t107.y, Math.max(Math.min(t107.xMargin, r10), -r10), Math.max(Math.min(t107.yMargin, l10), -l10), this.view.textDirection == oQ.LTR);
  }
}, rP = class extends oz {
  constructor(t107) {
    super(), this.height = t107;
  }
  toDOM() {
    let t107 = document.createElement("div");
    return t107.className = "cm-gap", this.updateDOM(t107), t107;
  }
  eq(t107) {
    return t107.height == this.height;
  }
  updateDOM(t107) {
    return t107.style.height = this.height + "px", true;
  }
  get editable() {
    return true;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return false;
  }
};
function rN(t107, e10) {
  let i10 = t107.observer.selectionRange;
  if (!i10.focusNode) return null;
  let s10 = oh(i10.focusNode, i10.focusOffset), n10 = oa(i10.focusNode, i10.focusOffset), o10 = s10 || n10;
  if (n10 && s10 && n10.node != s10.node) {
    let e11 = ou.get(n10.node);
    if (!e11 || e11 instanceof oT && e11.text != n10.node.nodeValue) o10 = n10;
    else if (t107.docView.lastCompositionAfterCursor) {
      let t108 = ou.get(s10.node);
      !t108 || t108 instanceof oT && t108.text != s10.node.nodeValue || (o10 = n10);
    }
  }
  if (t107.docView.lastCompositionAfterCursor = o10 != s10, !o10) return null;
  let r10 = e10 - o10.offset;
  return { from: r10, to: r10 + o10.node.nodeValue.length, node: o10.node };
}
let rV = class {
  constructor() {
    this.changes = [];
  }
  compareRange(t107, e10) {
    oY(t107, e10, this.changes);
  }
  comparePoint(t107, e10) {
    oY(t107, e10, this.changes);
  }
};
function rH(t107, e10) {
  return t107.top < e10.bottom - 1 && t107.bottom > e10.top + 1;
}
function rF(t107, e10) {
  return e10 < t107.top ? { top: e10, left: t107.left, right: t107.right, bottom: t107.bottom } : t107;
}
function rW(t107, e10) {
  return e10 > t107.bottom ? { top: t107.top, left: t107.left, right: t107.right, bottom: e10 } : t107;
}
function rI(t107, e10, i10) {
  let s10 = t107.nodeValue.length, n10 = -1, o10 = 1e9, r10 = 0;
  for (let l10 = 0; l10 < s10; l10++) {
    let s11 = on(t107, l10, l10 + 1).getClientRects();
    for (let h10 = 0; h10 < s11.length; h10++) {
      let a10 = s11[h10];
      if (a10.top == a10.bottom) continue;
      r10 || (r10 = e10 - a10.left);
      let c10 = (a10.top > i10 ? a10.top - i10 : i10 - a10.bottom) - 1;
      if (a10.left - 1 <= e10 && a10.right + 1 >= e10 && c10 < o10) {
        let i11 = e10 >= (a10.left + a10.right) / 2, s12 = i11;
        if ((oO.chrome || oO.gecko) && on(t107, l10).getBoundingClientRect().left == a10.right && (s12 = !i11), c10 <= 0) return { node: t107, offset: l10 + (s12 ? 1 : 0) };
        n10 = l10 + (s12 ? 1 : 0), o10 = c10;
      }
    }
  }
  return { node: t107, offset: n10 > -1 ? n10 : r10 > 0 ? t107.nodeValue.length : 0 };
}
function rz(t107, e10, i10) {
  var s10, n10;
  let o10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : -1, r10 = t107.contentDOM.getBoundingClientRect(), l10 = r10.top + t107.viewState.paddingTop, h10, { docHeight: a10 } = t107.viewState, { x: c10, y: d10 } = e10, u10 = d10 - l10;
  if (u10 < 0) return 0;
  if (u10 > a10) return t107.state.doc.length;
  for (let e11 = t107.viewState.heightOracle.textHeight / 2, s11 = false; (h10 = t107.elementAtHeight(u10)).type != oK.Text; ) for (; !((u10 = o10 > 0 ? h10.bottom + e11 : h10.top - e11) >= 0) || !(u10 <= a10); ) {
    if (s11) return i10 ? null : 0;
    s11 = true, o10 = -o10;
  }
  d10 = l10 + u10;
  let f10 = h10.from;
  if (f10 < t107.viewport.from) return 0 == t107.viewport.from ? 0 : i10 ? null : rK(t107, r10, h10, c10, d10);
  if (f10 > t107.viewport.to) return t107.viewport.to == t107.state.doc.length ? t107.state.doc.length : i10 ? null : rK(t107, r10, h10, c10, d10);
  let g10 = t107.dom.ownerDocument, p10 = t107.root.elementFromPoint ? t107.root : g10, m10 = p10.elementFromPoint(c10, d10);
  m10 && !t107.contentDOM.contains(m10) && (m10 = null), !m10 && (c10 = Math.max(r10.left + 1, Math.min(r10.right - 1, c10)), (m10 = p10.elementFromPoint(c10, d10)) && !t107.contentDOM.contains(m10) && (m10 = null));
  let v10, w10 = -1;
  if (m10 && (null === (s10 = t107.docView.nearest(m10)) || void 0 === s10 ? void 0 : s10.isEditable) != false) {
    if (g10.caretPositionFromPoint) {
      let t108 = g10.caretPositionFromPoint(c10, d10);
      t108 && ({ offsetNode: v10, offset: w10 } = t108);
    } else if (g10.caretRangeFromPoint) {
      let e11 = g10.caretRangeFromPoint(c10, d10);
      e11 && ({ startContainer: v10, startOffset: w10 } = e11, (!t107.contentDOM.contains(v10) || oO.safari && function(t108, e12, i11) {
        let s11;
        if (3 != t108.nodeType || e12 != (s11 = t108.nodeValue.length)) return false;
        for (let e13 = t108.nextSibling; e13; e13 = e13.nextSibling) if (1 != e13.nodeType || "BR" != e13.nodeName) return false;
        return on(t108, s11 - 1, s11).getBoundingClientRect().left > i11;
      }(v10, w10, c10) || oO.chrome && function(t108, e12, i11) {
        if (0 != e12) return false;
        for (let e13 = t108; ; ) {
          let t109 = e13.parentNode;
          if (!t109 || 1 != t109.nodeType || t109.firstChild != e13) return false;
          if (t109.classList.contains("cm-line")) break;
          e13 = t109;
        }
        return i11 - (1 == t108.nodeType ? t108.getBoundingClientRect() : on(t108, 0, Math.max(t108.nodeValue.length, 1)).getBoundingClientRect()).left > 5;
      }(v10, w10, c10)) && (v10 = void 0));
    }
  }
  if (!v10 || !t107.docView.dom.contains(v10)) {
    let e11 = oW.find(t107.docView, f10);
    if (!e11) return u10 > h10.top + h10.height / 2 ? h10.to : h10.from;
    ({ node: v10, offset: w10 } = function t108(e12, i11, s11) {
      let n11, o11, r11, l11, h11, a11, c11, d11, u11 = false;
      for (let p12 = e12.firstChild; p12; p12 = p12.nextSibling) {
        let e13 = n8(p12);
        for (let m12 = 0; m12 < e13.length; m12++) {
          var f11, g11;
          let v11 = e13[m12];
          a11 && rH(a11, v11) && (v11 = rF(rW(v11, a11.bottom), a11.top));
          let w11 = (f11 = v11).left > i11 ? f11.left - i11 : Math.max(0, i11 - f11.right), b11 = (g11 = v11).top > s11 ? g11.top - s11 : Math.max(0, s11 - g11.bottom);
          if (0 == w11 && 0 == b11) return 3 == p12.nodeType ? rI(p12, i11, s11) : t108(p12, i11, s11);
          if (!h11 || d11 > b11 || d11 == b11 && c11 > w11) {
            h11 = p12, a11 = v11, c11 = w11, d11 = b11;
            let t109 = b11 ? s11 < v11.top ? -1 : 1 : w11 ? i11 < v11.left ? -1 : 1 : 0;
            u11 = !t109 || (t109 > 0 ? m12 < e13.length - 1 : m12 > 0);
          }
          0 == w11 ? s11 > v11.bottom && (!r11 || r11.bottom < v11.bottom) ? (n11 = p12, r11 = v11) : s11 < v11.top && (!l11 || l11.top > v11.top) && (o11 = p12, l11 = v11) : r11 && rH(r11, v11) ? r11 = rW(r11, v11.bottom) : l11 && rH(l11, v11) && (l11 = rF(l11, v11.top));
        }
      }
      if (r11 && r11.bottom >= s11 ? (h11 = n11, a11 = r11) : l11 && l11.top <= s11 && (h11 = o11, a11 = l11), !h11) return { node: e12, offset: 0 };
      let p11 = Math.max(a11.left, Math.min(a11.right, i11));
      if (3 == h11.nodeType) return rI(h11, p11, s11);
      if (u11 && "false" != h11.contentEditable) return t108(h11, p11, s11);
      let m11 = Array.prototype.indexOf.call(e12.childNodes, h11) + (i11 >= (a11.left + a11.right) / 2 ? 1 : 0);
      return { node: e12, offset: m11 };
    }(e11.dom, c10, d10));
  }
  let b10 = t107.docView.nearest(v10);
  if (!b10) return null;
  if (!b10.isWidget || (null === (n10 = b10.dom) || void 0 === n10 ? void 0 : n10.nodeType) != 1) return b10.localPosFromDOM(v10, w10) + b10.posAtStart;
  {
    let t108 = b10.dom.getBoundingClientRect();
    return e10.y < t108.top || e10.y <= t108.bottom && e10.x <= (t108.left + t108.right) / 2 ? b10.posAtStart : b10.posAtEnd;
  }
}
function rK(t107, e10, i10, s10, n10) {
  let o10 = Math.round((s10 - e10.left) * t107.defaultCharacterWidth);
  if (t107.lineWrapping && i10.height > 1.5 * t107.defaultLineHeight) {
    let e11 = t107.viewState.heightOracle.textHeight;
    o10 += Math.floor((n10 - i10.top - (t107.defaultLineHeight - e11) * 0.5) / e11) * t107.viewState.heightOracle.lineLength;
  }
  let r10 = t107.state.sliceDoc(i10.from, i10.to);
  return i10.from + t3(r10, o10, t107.state.tabSize);
}
function rq(t107, e10, i10, s10) {
  let n10 = t107.state.doc.lineAt(e10.head), o10 = t107.bidiSpans(n10), r10 = t107.textDirectionAt(n10.from);
  for (let l10 = e10, h10 = null; ; ) {
    let e11 = function(t108, e12, i11, s11, n11) {
      var o11;
      let r11 = s11.head - t108.from, l11 = o6.find(e12, r11, null !== (o11 = s11.bidiLevel) && void 0 !== o11 ? o11 : -1, s11.assoc), h11 = e12[l11], a11 = h11.side(n11, i11);
      if (r11 == a11) {
        let t109 = l11 += n11 ? 1 : -1;
        if (t109 < 0 || t109 >= e12.length) return null;
        r11 = (h11 = e12[l11 = t109]).side(!n11, i11), a11 = h11.side(n11, i11);
      }
      let c10 = v(t108.text, r11, h11.forward(n11, i11));
      (c10 < h11.from || c10 > h11.to) && (c10 = a11), re = t108.text.slice(Math.min(r11, c10), Math.max(r11, c10));
      let d10 = l11 == (n11 ? e12.length - 1 : 0) ? null : e12[l11 + (n11 ? 1 : -1)];
      return d10 && c10 == a11 && d10.level + (n11 ? 0 : 1) < h11.level ? ti.cursor(d10.side(!n11, i11) + t108.from, d10.forward(n11, i11) ? 1 : -1, d10.level) : ti.cursor(c10 + t108.from, h11.forward(n11, i11) ? -1 : 1, h11.level);
    }(n10, o10, r10, l10, i10), a10 = re;
    if (!e11) {
      if (n10.number == (i10 ? t107.state.doc.lines : 1)) return l10;
      a10 = "\n", n10 = t107.state.doc.line(n10.number + (i10 ? 1 : -1)), o10 = t107.bidiSpans(n10), e11 = t107.visualLineSide(n10, !i10);
    }
    if (h10) {
      if (!h10(a10)) return l10;
    } else {
      if (!s10) return e11;
      h10 = s10(a10);
    }
    l10 = e11;
  }
}
function r_(t107, e10, i10) {
  for (; ; ) {
    let s10 = 0;
    for (let n10 of t107) n10.between(e10 - 1, e10 + 1, (t108, n11, o10) => {
      if (e10 > t108 && e10 < n11) {
        let o11 = s10 || i10 || (e10 - t108 < n11 - e10 ? -1 : 1);
        e10 = o11 < 0 ? t108 : n11, s10 = o11;
      }
    });
    if (!s10) return e10;
  }
}
function rG(t107, e10, i10) {
  let s10 = r_(t107.state.facet(rC).map((e11) => e11(t107)), i10.from, e10.head > i10.from ? -1 : 1);
  return s10 == i10.from ? i10 : ti.cursor(s10, s10 < i10.from ? 1 : -1);
}
let rj = class {
  setSelectionOrigin(t107) {
    this.lastSelectionOrigin = t107, this.lastSelectionTime = Date.now();
  }
  constructor(t107) {
    var e10;
    this.view = t107, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = false, this.compositionPendingChange = false, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = t107.hasFocus, oO.safari && t107.contentDOM.addEventListener("input", () => null), oO.gecko && (e10 = t107.contentDOM.ownerDocument, ll.has(e10) || (ll.add(e10), e10.addEventListener("copy", () => {
    }), e10.addEventListener("cut", () => {
    })));
  }
  handleEvent(t107) {
    !(!function(t108, e10) {
      if (!e10.bubbles) return true;
      if (e10.defaultPrevented) return false;
      for (let i10 = e10.target, s10; i10 != t108.contentDOM; i10 = i10.parentNode) if (!i10 || 11 == i10.nodeType || (s10 = ou.get(i10)) && s10.ignoreEvent(e10)) return false;
      return true;
    }(this.view, t107) || this.ignoreDuringComposition(t107)) && ("keydown" == t107.type && this.keydown(t107) || this.runHandlers(t107.type, t107));
  }
  runHandlers(t107, e10) {
    let i10 = this.handlers[t107];
    if (i10) {
      for (let t108 of i10.observers) t108(this.view, e10);
      for (let t108 of i10.handlers) {
        if (e10.defaultPrevented) break;
        if (t108(this.view, e10)) {
          e10.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(t107) {
    let e10 = function(t108) {
      let e11 = /* @__PURE__ */ Object.create(null);
      function i11(t109) {
        return e11[t109] || (e11[t109] = { observers: [], handlers: [] });
      }
      for (let e12 of t108) {
        let t109 = e12.spec;
        if (t109 && t109.domEventHandlers) for (let s11 in t109.domEventHandlers) {
          let n10 = t109.domEventHandlers[s11];
          n10 && i11(s11).handlers.push(rU(e12.value, n10));
        }
        if (t109 && t109.domEventObservers) for (let s11 in t109.domEventObservers) {
          let n10 = t109.domEventObservers[s11];
          n10 && i11(s11).observers.push(rU(e12.value, n10));
        }
      }
      for (let t109 in rZ) i11(t109).handlers.push(rZ[t109]);
      for (let t109 in r0) i11(t109).observers.push(r0[t109]);
      return e11;
    }(t107), i10 = this.handlers, s10 = this.view.contentDOM;
    for (let t108 in e10) if ("scroll" != t108) {
      let n10 = !e10[t108].handlers.length, o10 = i10[t108];
      o10 && !o10.handlers.length != n10 && (s10.removeEventListener(t108, this.handleEvent), o10 = null), o10 || s10.addEventListener(t108, this.handleEvent, { passive: n10 });
    }
    for (let t108 in i10) "scroll" == t108 || e10[t108] || s10.removeEventListener(t108, this.handleEvent);
    this.handlers = e10;
  }
  keydown(t107) {
    let e10;
    return this.lastKeyCode = t107.keyCode, this.lastKeyTime = Date.now(), !!(9 == t107.keyCode && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode)) || ((this.tabFocusMode > 0 && 27 != t107.keyCode && 0 > rX.indexOf(t107.keyCode) && (this.tabFocusMode = -1), oO.android && oO.chrome && !t107.synthetic && (13 == t107.keyCode || 8 == t107.keyCode)) ? (this.view.observer.delayAndroidKey(t107.key, t107.keyCode), true) : oO.ios && !t107.synthetic && !t107.altKey && !t107.metaKey && ((e10 = rY.find((e11) => e11.keyCode == t107.keyCode)) && !t107.ctrlKey || r$.indexOf(t107.key) > -1 && t107.ctrlKey && !t107.shiftKey) ? (this.pendingIOSKey = e10 || t107, setTimeout(() => this.flushIOSKey(), 250), true) : (229 != t107.keyCode && this.view.observer.forceFlush(), false));
  }
  flushIOSKey(t107) {
    let e10 = this.pendingIOSKey;
    return !(!e10 || "Enter" == e10.key && t107 && t107.from < t107.to && /^\S+$/.test(t107.insert.toString())) && (this.pendingIOSKey = void 0, oo(this.view.contentDOM, e10.key, e10.keyCode, e10 instanceof KeyboardEvent ? e10 : void 0));
  }
  ignoreDuringComposition(t107) {
    return !!/^key/.test(t107.type) && (this.composing > 0 || !!(oO.safari && !oO.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) && (this.compositionPendingKey = false, true));
  }
  startMouseSelection(t107) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = t107;
  }
  update(t107) {
    this.view.observer.update(t107), this.mouseSelection && this.mouseSelection.update(t107), this.draggedContent && t107.docChanged && (this.draggedContent = this.draggedContent.map(t107.changes)), t107.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
};
function rU(t107, e10) {
  return (i10, s10) => {
    try {
      return e10.call(t107, s10, i10);
    } catch (t108) {
      rp(i10.state, t108);
    }
  };
}
let rY = [{ key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" }, { key: "Enter", keyCode: 13, inputType: "insertParagraph" }, { key: "Enter", keyCode: 13, inputType: "insertLineBreak" }, { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }], r$ = "dthko", rX = [16, 17, 18, 20, 91, 92, 224, 225];
function rJ(t107) {
  return 0.7 * Math.max(0, t107) + 8;
}
let rQ = class {
  constructor(t107, e10, i10, s10) {
    let n10;
    this.view = t107, this.startEvent = e10, this.style = i10, this.mustSelect = s10, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = e10, this.scrollParents = function(t108) {
      let e11 = t108.ownerDocument, i11, s11;
      for (let n11 = t108.parentNode; n11 && n11 != e11.body && (!i11 || !s11); ) if (1 == n11.nodeType) !s11 && n11.scrollHeight > n11.clientHeight && (s11 = n11), !i11 && n11.scrollWidth > n11.clientWidth && (i11 = n11), n11 = n11.assignedSlot || n11.parentNode;
      else if (11 == n11.nodeType) n11 = n11.host;
      else break;
      return { x: i11, y: s11 };
    }(t107.contentDOM), this.atoms = t107.state.facet(rC).map((e11) => e11(t107));
    let o10 = t107.contentDOM.ownerDocument;
    o10.addEventListener("mousemove", this.move = this.move.bind(this)), o10.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = e10.shiftKey, this.multiple = t107.state.facet(tW.allowMultipleSelections) && ((n10 = t107.state.facet(ri)).length ? n10[0](e10) : oO.mac ? e10.metaKey : e10.ctrlKey), this.dragging = !!function(t108, e11) {
      let { main: i11 } = t108.state.selection;
      if (i11.empty) return false;
      let s11 = n0(t108.root);
      if (!s11 || 0 == s11.rangeCount) return true;
      let n11 = s11.getRangeAt(0).getClientRects();
      for (let t109 = 0; t109 < n11.length; t109++) {
        let i12 = n11[t109];
        if (i12.left <= e11.clientX && i12.right >= e11.clientX && i12.top <= e11.clientY && i12.bottom >= e11.clientY) return true;
      }
      return false;
    }(t107, e10) && 1 == le(e10) && null;
  }
  start(t107) {
    false === this.dragging && this.select(t107);
  }
  move(t107) {
    var e10;
    if (0 == t107.buttons) return this.destroy();
    if (this.dragging || null == this.dragging && 10 > Math.max(Math.abs((e10 = this.startEvent).clientX - t107.clientX), Math.abs(e10.clientY - t107.clientY))) return;
    this.select(this.lastEvent = t107);
    let i10 = 0, s10 = 0, n10 = 0, o10 = 0, r10 = this.view.win.innerWidth, l10 = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: n10, right: r10 } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: o10, bottom: l10 } = this.scrollParents.y.getBoundingClientRect());
    let h10 = rT(this.view);
    t107.clientX - h10.left <= n10 + 6 ? i10 = -rJ(n10 - t107.clientX) : t107.clientX + h10.right >= r10 - 6 && (i10 = rJ(t107.clientX - r10)), t107.clientY - h10.top <= o10 + 6 ? s10 = -rJ(o10 - t107.clientY) : t107.clientY + h10.bottom >= l10 - 6 && (s10 = rJ(t107.clientY - l10)), this.setScrollSpeed(i10, s10);
  }
  up(t107) {
    null == this.dragging && this.select(this.lastEvent), this.dragging || t107.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let t107 = this.view.contentDOM.ownerDocument;
    t107.removeEventListener("mousemove", this.move), t107.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(t107, e10) {
    this.scrollSpeed = { x: t107, y: e10 }, t107 || e10 ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: t107, y: e10 } = this.scrollSpeed;
    t107 && this.scrollParents.x && (this.scrollParents.x.scrollLeft += t107, t107 = 0), e10 && this.scrollParents.y && (this.scrollParents.y.scrollTop += e10, e10 = 0), (t107 || e10) && this.view.win.scrollBy(t107, e10), false === this.dragging && this.select(this.lastEvent);
  }
  skipAtoms(t107) {
    let e10 = null;
    for (let i10 = 0; i10 < t107.ranges.length; i10++) {
      let s10 = t107.ranges[i10], n10 = null;
      if (s10.empty) {
        let t108 = r_(this.atoms, s10.from, 0);
        t108 != s10.from && (n10 = ti.cursor(t108, -1));
      } else {
        let t108 = r_(this.atoms, s10.from, -1), e11 = r_(this.atoms, s10.to, 1);
        (t108 != s10.from || e11 != s10.to) && (n10 = ti.range(s10.from == s10.anchor ? t108 : e11, s10.from == s10.head ? t108 : e11));
      }
      n10 && (e10 || (e10 = t107.ranges.slice()), e10[i10] = n10);
    }
    return e10 ? ti.create(e10, t107.mainIndex) : t107;
  }
  select(t107) {
    let { view: e10 } = this, i10 = this.skipAtoms(this.style.get(t107, this.extend, this.multiple));
    (this.mustSelect || !i10.eq(e10.state.selection, false === this.dragging)) && this.view.dispatch({ selection: i10, userEvent: "select.pointer" }), this.mustSelect = false;
  }
  update(t107) {
    t107.transactions.some((t108) => t108.isUserEvent("input.type")) ? this.destroy() : this.style.update(t107) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}, rZ = /* @__PURE__ */ Object.create(null), r0 = /* @__PURE__ */ Object.create(null), r1 = oO.ie && oO.ie_version < 15 || oO.ios && oO.webkit_version < 604;
function r2(t107, e10) {
  let { state: i10 } = t107, s10, n10 = 1, o10 = i10.toText(e10), r10 = o10.lines == i10.selection.ranges.length;
  if (null != ls && i10.selection.ranges.every((t108) => t108.empty) && ls == o10.toString()) {
    let t108 = -1;
    s10 = i10.changeByRange((s11) => {
      let l10 = i10.doc.lineAt(s11.from);
      if (l10.from == t108) return { range: s11 };
      t108 = l10.from;
      let h10 = i10.toText((r10 ? o10.line(n10++).text : e10) + i10.lineBreak);
      return { changes: { from: l10.from, insert: h10 }, range: ti.cursor(s11.from + h10.length) };
    });
  } else s10 = r10 ? i10.changeByRange((t108) => {
    let e11 = o10.line(n10++);
    return { changes: { from: t108.from, to: t108.to, insert: e11.text }, range: ti.cursor(t108.from + e11.length) };
  }) : i10.replaceSelection(o10);
  t107.dispatch(s10, { userEvent: "input.paste", scrollIntoView: true });
}
function r8(t107, e10, i10, s10) {
  if (1 == s10) return ti.cursor(e10, i10);
  if (2 == s10) return function(t108, e11) {
    let i11 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, s11 = t108.charCategorizer(e11), n10 = t108.doc.lineAt(e11), o10 = e11 - n10.from;
    if (0 == n10.length) return ti.cursor(e11);
    0 == o10 ? i11 = 1 : o10 == n10.length && (i11 = -1);
    let r10 = o10, l10 = o10;
    i11 < 0 ? r10 = v(n10.text, o10, false) : l10 = v(n10.text, o10);
    let h10 = s11(n10.text.slice(r10, l10));
    for (; r10 > 0; ) {
      let t109 = v(n10.text, r10, false);
      if (s11(n10.text.slice(t109, r10)) != h10) break;
      r10 = t109;
    }
    for (; l10 < n10.length; ) {
      let t109 = v(n10.text, l10);
      if (s11(n10.text.slice(l10, t109)) != h10) break;
      l10 = t109;
    }
    return ti.range(r10 + n10.from, l10 + n10.from);
  }(t107.state, e10, i10);
  {
    let i11 = oW.find(t107.docView, e10), s11 = t107.state.doc.lineAt(i11 ? i11.posAtEnd : e10), n10 = i11 ? i11.posAtStart : s11.from, o10 = i11 ? i11.posAtEnd : s11.to;
    return o10 < t107.state.doc.length && o10 == s11.to && o10++, ti.range(n10, o10);
  }
}
r0.scroll = (t107) => {
  t107.inputState.lastScrollTop = t107.scrollDOM.scrollTop, t107.inputState.lastScrollLeft = t107.scrollDOM.scrollLeft;
}, rZ.keydown = (t107, e10) => (t107.inputState.setSelectionOrigin("select"), 27 == e10.keyCode && 0 != t107.inputState.tabFocusMode && (t107.inputState.tabFocusMode = Date.now() + 2e3), false), r0.touchstart = (t107, e10) => {
  t107.inputState.lastTouchTime = Date.now(), t107.inputState.setSelectionOrigin("select.pointer");
}, r0.touchmove = (t107) => {
  t107.inputState.setSelectionOrigin("select.pointer");
}, rZ.mousedown = (t107, e10) => {
  let i10, s10, n10;
  if (t107.observer.flush(), t107.inputState.lastTouchTime > Date.now() - 2e3) return false;
  let o10 = null;
  for (let i11 of t107.state.facet(rn)) if (o10 = i11(t107, e10)) break;
  if (o10 || 0 != e10.button || (i10 = r9(t107, e10), s10 = le(e10), n10 = t107.state.selection, o10 = { update(t108) {
    t108.docChanged && (i10.pos = t108.changes.mapPos(i10.pos), n10 = n10.map(t108.changes));
  }, get(e11, o11, r10) {
    let l10 = r9(t107, e11), h10, a10 = r8(t107, l10.pos, l10.bias, s10);
    if (i10.pos != l10.pos && !o11) {
      let e12 = r8(t107, i10.pos, i10.bias, s10), n11 = Math.min(e12.from, a10.from), o12 = Math.max(e12.to, a10.to);
      a10 = n11 < a10.from ? ti.range(n11, o12) : ti.range(o12, n11);
    }
    return o11 ? n10.replaceRange(n10.main.extend(a10.from, a10.to)) : r10 && 1 == s10 && n10.ranges.length > 1 && (h10 = function(t108, e12) {
      for (let i11 = 0; i11 < t108.ranges.length; i11++) {
        let { from: s11, to: n11 } = t108.ranges[i11];
        if (s11 <= e12 && n11 >= e12) return ti.create(t108.ranges.slice(0, i11).concat(t108.ranges.slice(i11 + 1)), t108.mainIndex == i11 ? 0 : t108.mainIndex - (t108.mainIndex > i11 ? 1 : 0));
      }
      return null;
    }(n10, l10.pos)) ? h10 : r10 ? n10.addRange(a10) : ti.create([a10]);
  } }), o10) {
    let i11 = !t107.hasFocus;
    t107.inputState.startMouseSelection(new rQ(t107, e10, o10, i11)), i11 && t107.observer.ignore(() => {
      os(t107.contentDOM);
      let e11 = t107.root.activeElement;
      e11 && !e11.contains(t107.contentDOM) && e11.blur();
    });
    let s11 = t107.inputState.mouseSelection;
    if (s11) return s11.start(e10), false === s11.dragging;
  }
  return false;
};
let r3 = (t107, e10) => t107 >= e10.top && t107 <= e10.bottom, r4 = (t107, e10, i10) => r3(e10, i10) && t107 >= i10.left && t107 <= i10.right;
function r9(t107, e10) {
  let i10 = t107.posAtCoords({ x: e10.clientX, y: e10.clientY }, false);
  return { pos: i10, bias: function(t108, e11, i11, s10) {
    let n10 = oW.find(t108.docView, e11);
    if (!n10) return 1;
    let o10 = e11 - n10.posAtStart;
    if (0 == o10) return 1;
    if (o10 == n10.length) return -1;
    let r10 = n10.coordsAt(o10, -1);
    if (r10 && r4(i11, s10, r10)) return -1;
    let l10 = n10.coordsAt(o10, 1);
    return l10 && r4(i11, s10, l10) ? 1 : r10 && r3(s10, r10) ? -1 : 1;
  }(t107, i10, e10.clientX, e10.clientY) };
}
let r5 = oO.ie && oO.ie_version <= 11, r6 = null, r7 = 0, lt = 0;
function le(t107) {
  if (!r5) return t107.detail;
  let e10 = r6, i10 = lt;
  return r6 = t107, lt = Date.now(), r7 = !e10 || i10 > Date.now() - 400 && 2 > Math.abs(e10.clientX - t107.clientX) && 2 > Math.abs(e10.clientY - t107.clientY) ? (r7 + 1) % 3 : 1;
}
function li(t107, e10, i10, s10) {
  let n10;
  if (!i10) return;
  let o10 = t107.posAtCoords({ x: e10.clientX, y: e10.clientY }, false), { draggedContent: r10 } = t107.inputState, l10 = s10 && r10 && ((n10 = t107.state.facet(rs)).length ? n10[0](e10) : oO.mac ? !e10.altKey : !e10.ctrlKey) ? { from: r10.from, to: r10.to } : null, h10 = { from: o10, insert: i10 }, a10 = t107.state.changes(l10 ? [l10, h10] : h10);
  t107.focus(), t107.dispatch({ changes: a10, selection: { anchor: a10.mapPos(o10, -1), head: a10.mapPos(o10, 1) }, userEvent: l10 ? "move.drop" : "input.drop" }), t107.inputState.draggedContent = null;
}
rZ.dragstart = (t107, e10) => {
  let { selection: { main: i10 } } = t107.state;
  if (e10.target.draggable) {
    let s11 = t107.docView.nearest(e10.target);
    if (s11 && s11.isWidget) {
      let t108 = s11.posAtStart, e11 = t108 + s11.length;
      (t108 >= i10.to || e11 <= i10.from) && (i10 = ti.range(t108, e11));
    }
  }
  let { inputState: s10 } = t107;
  return s10.mouseSelection && (s10.mouseSelection.dragging = true), s10.draggedContent = i10, e10.dataTransfer && (e10.dataTransfer.setData("Text", t107.state.sliceDoc(i10.from, i10.to)), e10.dataTransfer.effectAllowed = "copyMove"), false;
}, rZ.dragend = (t107) => (t107.inputState.draggedContent = null, false), rZ.drop = (t107, e10) => {
  if (!e10.dataTransfer) return false;
  if (t107.state.readOnly) return true;
  let i10 = e10.dataTransfer.files;
  if (i10 && i10.length) {
    let s10 = Array(i10.length), n10 = 0, o10 = () => {
      ++n10 == i10.length && li(t107, e10, s10.filter((t108) => null != t108).join(t107.state.lineBreak), false);
    };
    for (let t108 = 0; t108 < i10.length; t108++) {
      let e11 = new FileReader();
      e11.onerror = o10, e11.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(e11.result) || (s10[t108] = e11.result), o10();
      }, e11.readAsText(i10[t108]);
    }
    return true;
  }
  {
    let i11 = e10.dataTransfer.getData("Text");
    if (i11) return li(t107, e10, i11, true), true;
  }
  return false;
}, rZ.paste = (t107, e10) => {
  if (t107.state.readOnly) return true;
  t107.observer.flush();
  let i10 = r1 ? null : e10.clipboardData;
  return i10 ? (r2(t107, i10.getData("text/plain") || i10.getData("text/uri-list")), true) : (function(t108) {
    let e11 = t108.dom.parentNode;
    if (!e11) return;
    let i11 = e11.appendChild(document.createElement("textarea"));
    i11.style.cssText = "position: fixed; left: -10000px; top: 10px", i11.focus(), setTimeout(() => {
      t108.focus(), i11.remove(), r2(t108, i11.value);
    }, 50);
  }(t107), false);
};
let ls = null;
rZ.copy = rZ.cut = (t107, e10) => {
  let { text: i10, ranges: s10, linewise: n10 } = function(t108) {
    let e11 = [], i11 = [], s11 = false;
    for (let s12 of t108.selection.ranges) s12.empty || (e11.push(t108.sliceDoc(s12.from, s12.to)), i11.push(s12));
    if (!e11.length) {
      let n11 = -1;
      for (let { from: s12 } of t108.selection.ranges) {
        let o11 = t108.doc.lineAt(s12);
        o11.number > n11 && (e11.push(o11.text), i11.push({ from: o11.from, to: Math.min(t108.doc.length, o11.to + 1) })), n11 = o11.number;
      }
      s11 = true;
    }
    return { text: e11.join(t108.lineBreak), ranges: i11, linewise: s11 };
  }(t107.state);
  if (!i10 && !n10) return false;
  ls = n10 ? i10 : null, "cut" != e10.type || t107.state.readOnly || t107.dispatch({ changes: s10, scrollIntoView: true, userEvent: "delete.cut" });
  let o10 = r1 ? null : e10.clipboardData;
  return o10 ? (o10.clearData(), o10.setData("text/plain", i10), true) : (!function(t108, e11) {
    let i11 = t108.dom.parentNode;
    if (!i11) return;
    let s11 = i11.appendChild(document.createElement("textarea"));
    s11.style.cssText = "position: fixed; left: -10000px; top: 10px", s11.value = e11, s11.focus(), s11.selectionEnd = e11.length, s11.selectionStart = 0, setTimeout(() => {
      s11.remove(), t108.focus();
    }, 50);
  }(t107, i10), false);
};
let ln = tO.define();
function lo(t107, e10) {
  let i10 = [];
  for (let s10 of t107.facet(rh)) {
    let n10 = s10(t107, e10);
    n10 && i10.push(n10);
  }
  return i10 ? t107.update({ effects: i10, annotations: ln.of(true) }) : null;
}
function lr(t107) {
  setTimeout(() => {
    let e10 = t107.hasFocus;
    if (e10 != t107.inputState.notifiedFocused) {
      let i10 = lo(t107.state, e10);
      i10 ? t107.dispatch(i10) : t107.update([]);
    }
  }, 10);
}
r0.focus = (t107) => {
  t107.inputState.lastFocusTime = Date.now(), !t107.scrollDOM.scrollTop && (t107.inputState.lastScrollTop || t107.inputState.lastScrollLeft) && (t107.scrollDOM.scrollTop = t107.inputState.lastScrollTop, t107.scrollDOM.scrollLeft = t107.inputState.lastScrollLeft), lr(t107);
}, r0.blur = (t107) => {
  t107.observer.clearSelectionRange(), lr(t107);
}, r0.compositionstart = r0.compositionupdate = (t107) => {
  !t107.observer.editContext && (null == t107.inputState.compositionFirstChange && (t107.inputState.compositionFirstChange = true), t107.inputState.composing < 0 && (t107.inputState.composing = 0));
}, r0.compositionend = (t107) => {
  t107.observer.editContext || (t107.inputState.composing = -1, t107.inputState.compositionEndedAt = Date.now(), t107.inputState.compositionPendingKey = true, t107.inputState.compositionPendingChange = t107.observer.pendingRecords().length > 0, t107.inputState.compositionFirstChange = null, oO.chrome && oO.android ? t107.observer.flushSoon() : t107.inputState.compositionPendingChange ? Promise.resolve().then(() => t107.observer.flush()) : setTimeout(() => {
    t107.inputState.composing < 0 && t107.docView.hasComposition && t107.update([]);
  }, 50));
}, r0.contextmenu = (t107) => {
  t107.inputState.lastContextMenu = Date.now();
}, rZ.beforeinput = (t107, e10) => {
  var i10;
  let s10;
  if (oO.chrome && oO.android && (s10 = rY.find((t108) => t108.inputType == e10.inputType)) && (t107.observer.delayAndroidKey(s10.key, s10.keyCode), "Backspace" == s10.key || "Delete" == s10.key)) {
    let e11 = (null === (i10 = window.visualViewport) || void 0 === i10 ? void 0 : i10.height) || 0;
    setTimeout(() => {
      var i11;
      ((null === (i11 = window.visualViewport) || void 0 === i11 ? void 0 : i11.height) || 0) > e11 + 10 && t107.hasFocus && (t107.contentDOM.blur(), t107.focus());
    }, 100);
  }
  return oO.ios && "deleteContentForward" == e10.inputType && t107.observer.flushSoon(), oO.safari && "insertText" == e10.inputType && t107.inputState.composing >= 0 && setTimeout(() => r0.compositionend(t107, e10), 20), false;
};
let ll = /* @__PURE__ */ new Set(), lh = ["pre-wrap", "normal", "pre-line", "break-spaces"], la = class {
  constructor(t107) {
    this.lineWrapping = t107, this.doc = r.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30, this.heightChanged = false;
  }
  heightForGap(t107, e10) {
    let i10 = this.doc.lineAt(e10).number - this.doc.lineAt(t107).number + 1;
    return this.lineWrapping && (i10 += Math.max(0, Math.ceil((e10 - t107 - i10 * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * i10;
  }
  heightForLine(t107) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((t107 - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(t107) {
    return this.doc = t107, this;
  }
  mustRefreshForWrapping(t107) {
    return lh.indexOf(t107) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(t107) {
    let e10 = false;
    for (let i10 = 0; i10 < t107.length; i10++) {
      let s10 = t107[i10];
      s10 < 0 ? i10++ : this.heightSamples[Math.floor(10 * s10)] || (e10 = true, this.heightSamples[Math.floor(10 * s10)] = true);
    }
    return e10;
  }
  refresh(t107, e10, i10, s10, n10, o10) {
    let r10 = lh.indexOf(t107) > -1, l10 = Math.round(e10) != Math.round(this.lineHeight) || this.lineWrapping != r10;
    if (this.lineWrapping = r10, this.lineHeight = e10, this.charWidth = i10, this.textHeight = s10, this.lineLength = n10, l10) {
      this.heightSamples = {};
      for (let t108 = 0; t108 < o10.length; t108++) {
        let e11 = o10[t108];
        e11 < 0 ? t108++ : this.heightSamples[Math.floor(10 * e11)] = true;
      }
    }
    return l10;
  }
}, lc = class {
  constructor(t107, e10) {
    this.from = t107, this.heights = e10, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}, ld = class t51 {
  constructor(t107, e10, i10, s10, n10) {
    this.from = t107, this.length = e10, this.top = i10, this.height = s10, this._content = n10;
  }
  get type() {
    return "number" == typeof this._content ? oK.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  get to() {
    return this.from + this.length;
  }
  get bottom() {
    return this.top + this.height;
  }
  get widget() {
    return this._content instanceof oj ? this._content.widget : null;
  }
  get widgetLineBreaks() {
    return "number" == typeof this._content ? this._content : 0;
  }
  join(e10) {
    let i10 = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e10._content) ? e10._content : [e10]);
    return new t51(this.from, this.length + e10.length, this.top, this.height + e10.height, i10);
  }
};
var lu = ((R = lu || (lu = {}))[R.ByPos = 0] = "ByPos", R[R.ByHeight = 1] = "ByHeight", R[R.ByPosNoHeight = 2] = "ByPosNoHeight", R);
let lf = class t52 {
  constructor(t107, e10, i10 = 2) {
    this.length = t107, this.height = e10, this.flags = i10;
  }
  get outdated() {
    return (2 & this.flags) > 0;
  }
  set outdated(t107) {
    this.flags = (t107 ? 2 : 0) | -3 & this.flags;
  }
  setHeight(t107, e10) {
    this.height != e10 && (Math.abs(this.height - e10) > 1e-3 && (t107.heightChanged = true), this.height = e10);
  }
  replace(e10, i10, s10) {
    return t52.of(s10);
  }
  decomposeLeft(t107, e10) {
    e10.push(this);
  }
  decomposeRight(t107, e10) {
    e10.push(this);
  }
  applyChanges(t107, e10, i10, s10) {
    let n10 = this, o10 = i10.doc;
    for (let r10 = s10.length - 1; r10 >= 0; r10--) {
      let { fromA: l10, toA: h10, fromB: a10, toB: c10 } = s10[r10], d10 = n10.lineAt(l10, lu.ByPosNoHeight, i10.setDoc(e10), 0, 0), u10 = d10.to >= h10 ? d10 : n10.lineAt(h10, lu.ByPosNoHeight, i10, 0, 0);
      for (c10 += u10.to - h10, h10 = u10.to; r10 > 0 && d10.from <= s10[r10 - 1].toA; ) l10 = s10[r10 - 1].fromA, a10 = s10[r10 - 1].fromB, r10--, l10 < d10.from && (d10 = n10.lineAt(l10, lu.ByPosNoHeight, i10, 0, 0));
      a10 += d10.from - l10, l10 = d10.from;
      let f10 = lb.build(i10.setDoc(o10), t107, a10, c10);
      n10 = n10.replace(l10, h10, f10);
    }
    return n10.updateHeight(i10, 0);
  }
  static empty() {
    return new lp(0, 0);
  }
  static of(e10) {
    if (1 == e10.length) return e10[0];
    let i10 = 0, s10 = e10.length, n10 = 0, o10 = 0;
    for (; ; ) if (i10 == s10) {
      if (n10 > 2 * o10) {
        let t107 = e10[i10 - 1];
        t107.break ? e10.splice(--i10, 1, t107.left, null, t107.right) : e10.splice(--i10, 1, t107.left, t107.right), s10 += 1 + t107.break, n10 -= t107.size;
      } else if (o10 > 2 * n10) {
        let t107 = e10[s10];
        t107.break ? e10.splice(s10, 1, t107.left, null, t107.right) : e10.splice(s10, 1, t107.left, t107.right), s10 += 2 + t107.break, o10 -= t107.size;
      } else break;
    } else if (n10 < o10) {
      let t107 = e10[i10++];
      t107 && (n10 += t107.size);
    } else {
      let t107 = e10[--s10];
      t107 && (o10 += t107.size);
    }
    let r10 = 0;
    return null == e10[i10 - 1] ? (r10 = 1, i10--) : null == e10[i10] && (r10 = 1, s10++), new lv(t52.of(e10.slice(0, i10)), r10, t52.of(e10.slice(s10)));
  }
};
lf.prototype.size = 1;
let lg = class extends lf {
  constructor(t107, e10, i10) {
    super(t107, e10), this.deco = i10;
  }
  blockAt(t107, e10, i10, s10) {
    return new ld(s10, this.length, i10, this.height, this.deco || 0);
  }
  lineAt(t107, e10, i10, s10, n10) {
    return this.blockAt(0, i10, s10, n10);
  }
  forEachLine(t107, e10, i10, s10, n10, o10) {
    t107 <= n10 + this.length && e10 >= n10 && o10(this.blockAt(0, i10, s10, n10));
  }
  updateHeight(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i10 = (arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 ? arguments[3] : void 0);
    return i10 && i10.from <= e10 && i10.more && this.setHeight(t107, i10.heights[i10.index++]), this.outdated = false, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}, lp = class t53 extends lg {
  constructor(t107, e10) {
    super(t107, e10, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(t107, e10, i10, s10) {
    return new ld(s10, this.length, i10, this.height, this.breaks);
  }
  replace(e10, i10, s10) {
    let n10 = s10[0];
    return 1 == s10.length && (n10 instanceof t53 || n10 instanceof lm && 4 & n10.flags) && 10 > Math.abs(this.length - n10.length) ? (n10 instanceof lm ? n10 = new t53(n10.length, this.height) : n10.height = this.height, this.outdated || (n10.outdated = false), n10) : lf.of(s10);
  }
  updateHeight(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], s10 = arguments.length > 3 ? arguments[3] : void 0;
    return s10 && s10.from <= e10 && s10.more ? this.setHeight(t107, s10.heights[s10.index++]) : (i10 || this.outdated) && this.setHeight(t107, Math.max(this.widgetHeight, t107.heightForLine(this.length - this.collapsed)) + this.breaks * t107.lineHeight), this.outdated = false, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}, lm = class t54 extends lf {
  constructor(t107) {
    super(t107, 0);
  }
  heightMetrics(t107, e10) {
    let i10 = t107.doc.lineAt(e10).number, s10 = t107.doc.lineAt(e10 + this.length).number, n10 = s10 - i10 + 1, o10, r10 = 0;
    if (t107.lineWrapping) {
      let e11 = Math.min(this.height, t107.lineHeight * n10);
      o10 = e11 / n10, this.length > n10 + 1 && (r10 = (this.height - e11) / (this.length - n10 - 1));
    } else o10 = this.height / n10;
    return { firstLine: i10, lastLine: s10, perLine: o10, perChar: r10 };
  }
  blockAt(t107, e10, i10, s10) {
    let { firstLine: n10, lastLine: o10, perLine: r10, perChar: l10 } = this.heightMetrics(e10, s10);
    if (e10.lineWrapping) {
      let n11 = s10 + (t107 < e10.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (t107 - i10) / this.height)) * this.length)), o11 = e10.doc.lineAt(n11), h10 = r10 + o11.length * l10, a10 = Math.max(i10, t107 - h10 / 2);
      return new ld(o11.from, o11.length, a10, h10, 0);
    }
    {
      let s11 = Math.max(0, Math.min(o10 - n10, Math.floor((t107 - i10) / r10))), { from: l11, length: h10 } = e10.doc.line(n10 + s11);
      return new ld(l11, h10, i10 + r10 * s11, r10, 0);
    }
  }
  lineAt(t107, e10, i10, s10, n10) {
    if (e10 == lu.ByHeight) return this.blockAt(t107, i10, s10, n10);
    if (e10 == lu.ByPosNoHeight) {
      let { from: e11, to: s11 } = i10.doc.lineAt(t107);
      return new ld(e11, s11 - e11, 0, 0, 0);
    }
    let { firstLine: o10, perLine: r10, perChar: l10 } = this.heightMetrics(i10, n10), h10 = i10.doc.lineAt(t107), a10 = r10 + h10.length * l10, c10 = h10.number - o10, d10 = s10 + r10 * c10 + l10 * (h10.from - n10 - c10);
    return new ld(h10.from, h10.length, Math.max(s10, Math.min(d10, s10 + this.height - a10)), a10, 0);
  }
  forEachLine(t107, e10, i10, s10, n10, o10) {
    t107 = Math.max(t107, n10), e10 = Math.min(e10, n10 + this.length);
    let { firstLine: r10, perLine: l10, perChar: h10 } = this.heightMetrics(i10, n10);
    for (let a10 = t107, c10 = s10; a10 <= e10; ) {
      let e11 = i10.doc.lineAt(a10);
      if (a10 == t107) {
        let i11 = e11.number - r10;
        c10 += l10 * i11 + h10 * (t107 - n10 - i11);
      }
      let s11 = l10 + h10 * e11.length;
      o10(new ld(e11.from, e11.length, c10, s11, 0)), c10 += s11, a10 = e11.to + 1;
    }
  }
  replace(e10, i10, s10) {
    let n10 = this.length - i10;
    if (n10 > 0) {
      let e11 = s10[s10.length - 1];
      e11 instanceof t54 ? s10[s10.length - 1] = new t54(e11.length + n10) : s10.push(null, new t54(n10 - 1));
    }
    if (e10 > 0) {
      let i11 = s10[0];
      i11 instanceof t54 ? s10[0] = new t54(e10 + i11.length) : s10.unshift(new t54(e10 - 1), null);
    }
    return lf.of(s10);
  }
  decomposeLeft(e10, i10) {
    i10.push(new t54(e10 - 1), null);
  }
  decomposeRight(e10, i10) {
    i10.push(null, new t54(this.length - e10 - 1));
  }
  updateHeight(e10) {
    let i10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, s10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n10 = arguments.length > 3 ? arguments[3] : void 0, o10 = i10 + this.length;
    if (n10 && n10.from <= i10 + this.length && n10.more) {
      let s11 = [], r10 = Math.max(i10, n10.from), l10 = -1;
      for (n10.from > i10 && s11.push(new t54(n10.from - i10 - 1).updateHeight(e10, i10)); r10 <= o10 && n10.more; ) {
        let t107 = e10.doc.lineAt(r10).length;
        s11.length && s11.push(null);
        let i11 = n10.heights[n10.index++];
        -1 == l10 ? l10 = i11 : Math.abs(i11 - l10) >= 1e-3 && (l10 = -2);
        let o11 = new lp(t107, i11);
        o11.outdated = false, s11.push(o11), r10 += t107 + 1;
      }
      r10 <= o10 && s11.push(null, new t54(o10 - r10).updateHeight(e10, r10));
      let h10 = lf.of(s11);
      return (l10 < 0 || Math.abs(h10.height - this.height) >= 1e-3 || Math.abs(l10 - this.heightMetrics(e10, i10).perLine) >= 1e-3) && (e10.heightChanged = true), h10;
    }
    return (s10 || this.outdated) && (this.setHeight(e10, e10.heightForGap(i10, i10 + this.length)), this.outdated = false), this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}, lv = class extends lf {
  constructor(t107, e10, i10) {
    super(t107.length + e10 + i10.length, t107.height + i10.height, e10 | (t107.outdated || i10.outdated ? 2 : 0)), this.left = t107, this.right = i10, this.size = t107.size + i10.size;
  }
  get break() {
    return 1 & this.flags;
  }
  blockAt(t107, e10, i10, s10) {
    let n10 = i10 + this.left.height;
    return t107 < n10 ? this.left.blockAt(t107, e10, i10, s10) : this.right.blockAt(t107, e10, n10, s10 + this.left.length + this.break);
  }
  lineAt(t107, e10, i10, s10, n10) {
    let o10 = s10 + this.left.height, r10 = n10 + this.left.length + this.break, l10 = e10 == lu.ByHeight ? t107 < o10 : t107 < r10, h10 = l10 ? this.left.lineAt(t107, e10, i10, s10, n10) : this.right.lineAt(t107, e10, i10, o10, r10);
    if (this.break || (l10 ? h10.to < r10 : h10.from > r10)) return h10;
    let a10 = e10 == lu.ByPosNoHeight ? lu.ByPosNoHeight : lu.ByPos;
    return l10 ? h10.join(this.right.lineAt(r10, a10, i10, o10, r10)) : this.left.lineAt(r10, a10, i10, s10, n10).join(h10);
  }
  forEachLine(t107, e10, i10, s10, n10, o10) {
    let r10 = s10 + this.left.height, l10 = n10 + this.left.length + this.break;
    if (this.break) t107 < l10 && this.left.forEachLine(t107, e10, i10, s10, n10, o10), e10 >= l10 && this.right.forEachLine(t107, e10, i10, r10, l10, o10);
    else {
      let h10 = this.lineAt(l10, lu.ByPos, i10, s10, n10);
      t107 < h10.from && this.left.forEachLine(t107, h10.from - 1, i10, s10, n10, o10), h10.to >= t107 && h10.from <= e10 && o10(h10), e10 > h10.to && this.right.forEachLine(h10.to + 1, e10, i10, r10, l10, o10);
    }
  }
  replace(t107, e10, i10) {
    let s10 = this.left.length + this.break;
    if (e10 < s10) return this.balanced(this.left.replace(t107, e10, i10), this.right);
    if (t107 > this.left.length) return this.balanced(this.left, this.right.replace(t107 - s10, e10 - s10, i10));
    let n10 = [];
    t107 > 0 && this.decomposeLeft(t107, n10);
    let o10 = n10.length;
    for (let t108 of i10) n10.push(t108);
    if (t107 > 0 && lw(n10, o10 - 1), e10 < this.length) {
      let t108 = n10.length;
      this.decomposeRight(e10, n10), lw(n10, t108);
    }
    return lf.of(n10);
  }
  decomposeLeft(t107, e10) {
    let i10 = this.left.length;
    if (t107 <= i10) return this.left.decomposeLeft(t107, e10);
    e10.push(this.left), this.break && t107 >= ++i10 && e10.push(null), t107 > i10 && this.right.decomposeLeft(t107 - i10, e10);
  }
  decomposeRight(t107, e10) {
    let i10 = this.left.length, s10 = i10 + this.break;
    if (t107 >= s10) return this.right.decomposeRight(t107 - s10, e10);
    t107 < i10 && this.left.decomposeRight(t107, e10), this.break && t107 < s10 && e10.push(null), e10.push(this.right);
  }
  balanced(t107, e10) {
    return t107.size > 2 * e10.size || e10.size > 2 * t107.size ? lf.of(this.break ? [t107, null, e10] : [t107, e10]) : (this.left = t107, this.right = e10, this.height = t107.height + e10.height, this.outdated = t107.outdated || e10.outdated, this.size = t107.size + e10.size, this.length = t107.length + this.break + e10.length, this);
  }
  updateHeight(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], s10 = arguments.length > 3 ? arguments[3] : void 0, { left: n10, right: o10 } = this, r10 = e10 + n10.length + this.break, l10 = null;
    return (s10 && s10.from <= e10 + n10.length && s10.more ? l10 = n10 = n10.updateHeight(t107, e10, i10, s10) : n10.updateHeight(t107, e10, i10), s10 && s10.from <= r10 + o10.length && s10.more ? l10 = o10 = o10.updateHeight(t107, r10, i10, s10) : o10.updateHeight(t107, r10, i10), l10) ? this.balanced(n10, o10) : (this.height = this.left.height + this.right.height, this.outdated = false, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
};
function lw(t107, e10) {
  let i10, s10;
  null == t107[e10] && (i10 = t107[e10 - 1]) instanceof lm && (s10 = t107[e10 + 1]) instanceof lm && t107.splice(e10 - 1, 3, new lm(i10.length + 1 + s10.length));
}
let lb = class t55 {
  constructor(t107, e10) {
    this.pos = t107, this.oracle = e10, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = t107;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(t107, e10) {
    if (this.lineStart > -1) {
      let t108 = Math.min(e10, this.lineEnd), i10 = this.nodes[this.nodes.length - 1];
      i10 instanceof lp ? i10.length += t108 - this.pos : (t108 > this.pos || !this.isCovered) && this.nodes.push(new lp(t108 - this.pos, -1)), this.writtenTo = t108, e10 > t108 && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = e10;
  }
  point(t107, e10, i10) {
    if (t107 < e10 || i10.heightRelevant) {
      let s10 = i10.widget ? i10.widget.estimatedHeight : 0, n10 = i10.widget ? i10.widget.lineBreaks : 0;
      s10 < 0 && (s10 = this.oracle.lineHeight);
      let o10 = e10 - t107;
      i10.block ? this.addBlock(new lg(o10, s10, i10)) : (o10 || n10 || s10 >= 5) && this.addLineDeco(s10, n10, o10);
    } else e10 > t107 && this.span(t107, e10);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1) return;
    let { from: t107, to: e10 } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = t107, this.lineEnd = e10, this.writtenTo < t107 && ((this.writtenTo < t107 - 1 || null == this.nodes[this.nodes.length - 1]) && this.nodes.push(this.blankContent(this.writtenTo, t107 - 1)), this.nodes.push(null)), this.pos > t107 && this.nodes.push(new lp(this.pos - t107, -1)), this.writtenTo = this.pos;
  }
  blankContent(t107, e10) {
    let i10 = new lm(e10 - t107);
    return this.oracle.doc.lineAt(t107).to == e10 && (i10.flags |= 4), i10;
  }
  ensureLine() {
    this.enterLine();
    let t107 = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (t107 instanceof lp) return t107;
    let e10 = new lp(0, -1);
    return this.nodes.push(e10), e10;
  }
  addBlock(t107) {
    this.enterLine();
    let e10 = t107.deco;
    e10 && e10.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(t107), this.writtenTo = this.pos = this.pos + t107.length, e10 && e10.endSide > 0 && (this.covering = t107);
  }
  addLineDeco(t107, e10, i10) {
    let s10 = this.ensureLine();
    s10.length += i10, s10.collapsed += i10, s10.widgetHeight = Math.max(s10.widgetHeight, t107), s10.breaks += e10, this.writtenTo = this.pos = this.pos + i10;
  }
  finish(t107) {
    let e10 = 0 == this.nodes.length ? null : this.nodes[this.nodes.length - 1];
    !(this.lineStart > -1) || e10 instanceof lp || this.isCovered ? (this.writtenTo < this.pos || null == e10) && this.nodes.push(this.blankContent(this.writtenTo, this.pos)) : this.nodes.push(new lp(0, -1));
    let i10 = t107;
    for (let t108 of this.nodes) t108 instanceof lp && t108.updateHeight(this.oracle, i10), i10 += t108 ? t108.length : 1;
    return this.nodes;
  }
  static build(e10, i10, s10, n10) {
    let o10 = new t55(s10, e10);
    return tG.spans(i10, s10, n10, o10, 0), o10.finish(s10);
  }
}, ly = class {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(t107, e10, i10, s10) {
    (t107 < e10 || i10 && i10.heightRelevant || s10 && s10.heightRelevant) && oY(t107, e10, this.changes, 5);
  }
}, lx = class {
  constructor(t107, e10, i10) {
    this.from = t107, this.to = e10, this.size = i10;
  }
  static same(t107, e10) {
    if (t107.length != e10.length) return false;
    for (let i10 = 0; i10 < t107.length; i10++) {
      let s10 = t107[i10], n10 = e10[i10];
      if (s10.from != n10.from || s10.to != n10.to || s10.size != n10.size) return false;
    }
    return true;
  }
  draw(t107, e10) {
    return oq.replace({ widget: new lS(this.size * (e10 ? t107.scaleY : t107.scaleX), e10) }).range(this.from, this.to);
  }
}, lS = class extends oz {
  constructor(t107, e10) {
    super(), this.size = t107, this.vertical = e10;
  }
  eq(t107) {
    return t107.size == this.size && t107.vertical == this.vertical;
  }
  toDOM() {
    let t107 = document.createElement("div");
    return this.vertical ? t107.style.height = this.size + "px" : (t107.style.width = this.size + "px", t107.style.height = "2px", t107.style.display = "inline-block"), t107;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}, lk = class {
  constructor(t107) {
    this.state = t107, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = true, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = false, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = lD, this.scrollTarget = null, this.printing = false, this.mustMeasureContent = true, this.defaultTextDirection = oQ.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = false;
    let e10 = t107.facet(rS).some((t108) => "function" != typeof t108 && "cm-lineWrapping" == t108.class);
    this.heightOracle = new la(e10), this.stateDeco = t107.facet(rk).filter((t108) => "function" != typeof t108), this.heightMap = lf.empty().applyChanges(this.stateDeco, r.empty, this.heightOracle.setDoc(t107.doc), [new rR(0, 0, 0, t107.doc.length)]);
    for (let t108 = 0; t108 < 2 && (this.viewport = this.getViewport(0, null), this.updateForViewport()); t108++) ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = oq.set(this.lineGaps.map((t108) => t108.draw(this, false))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let t107 = [this.viewport], { main: e10 } = this.state.selection;
    for (let i10 = 0; i10 <= 1; i10++) {
      let s10 = i10 ? e10.head : e10.anchor;
      if (!t107.some((t108) => {
        let { from: e11, to: i11 } = t108;
        return s10 >= e11 && s10 <= i11;
      })) {
        let { from: e11, to: i11 } = this.lineBlockAt(s10);
        t107.push(new lM(e11, i11));
      }
    }
    return this.viewports = t107.sort((t108, e11) => t108.from - e11.from), this.updateScaler();
  }
  updateScaler() {
    let t107 = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? lD : new lO(this.heightOracle, this.heightMap, this.viewports), t107.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (t107) => {
      this.viewportLines.push(lT(t107, this.scaler));
    });
  }
  update(t107) {
    var e10, i10;
    let s10, n10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    this.state = t107.state;
    let o10 = this.stateDeco;
    this.stateDeco = this.state.facet(rk).filter((t108) => "function" != typeof t108);
    let r10 = t107.changedRanges, l10 = rR.extendWithRanges(r10, (e10 = this.stateDeco, i10 = t107 ? t107.changes : Y.empty(this.state.doc.length), s10 = new ly(), tG.compare(o10, e10, i10, s10, 0), s10.changes)), h10 = this.heightMap.height, a10 = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, t107.startState.doc, this.heightOracle.setDoc(this.state.doc), l10), this.heightMap.height != h10 && (t107.flags |= 2), a10 ? (this.scrollAnchorPos = t107.changes.mapPos(a10.from, -1), this.scrollAnchorHeight = a10.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let c10 = l10.length ? this.mapViewport(this.viewport, t107.changes) : this.viewport;
    (n10 && (n10.range.head < c10.from || n10.range.head > c10.to) || !this.viewportIsAppropriate(c10)) && (c10 = this.getViewport(0, n10));
    let d10 = c10.from != this.viewport.from || c10.to != this.viewport.to;
    this.viewport = c10, t107.flags |= this.updateForViewport(), (d10 || !t107.changes.empty || 2 & t107.flags) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, t107.changes))), t107.flags |= this.computeVisibleRanges(), n10 && (this.scrollTarget = n10), !this.mustEnforceCursorAssoc && t107.selectionSet && t107.view.lineWrapping && t107.state.selection.main.empty && t107.state.selection.main.assoc && !t107.state.facet(rc) && (this.mustEnforceCursorAssoc = true);
  }
  measure(t107) {
    let e10 = t107.contentDOM, i10 = window.getComputedStyle(e10), s10 = this.heightOracle, n10 = i10.whiteSpace;
    this.defaultTextDirection = "rtl" == i10.direction ? oQ.RTL : oQ.LTR;
    let o10 = this.heightOracle.mustRefreshForWrapping(n10), l10 = e10.getBoundingClientRect(), h10 = o10 || this.mustMeasureContent || this.contentDOMHeight != l10.height;
    this.contentDOMHeight = l10.height, this.mustMeasureContent = false;
    let a10 = 0, c10 = 0;
    if (l10.width && l10.height) {
      let { scaleX: t108, scaleY: i11 } = ot(e10, l10);
      (t108 > 5e-3 && Math.abs(this.scaleX - t108) > 5e-3 || i11 > 5e-3 && Math.abs(this.scaleY - i11) > 5e-3) && (this.scaleX = t108, this.scaleY = i11, a10 |= 8, o10 = h10 = true);
    }
    let d10 = (parseInt(i10.paddingTop) || 0) * this.scaleY, u10 = (parseInt(i10.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != d10 || this.paddingBottom != u10) && (this.paddingTop = d10, this.paddingBottom = u10, a10 |= 10), this.editorWidth != t107.scrollDOM.clientWidth && (s10.lineWrapping && (h10 = true), this.editorWidth = t107.scrollDOM.clientWidth, a10 |= 8);
    let f10 = t107.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != f10 && (this.scrollAnchorHeight = -1, this.scrollTop = f10), this.scrolledToBottom = ol(t107.scrollDOM);
    let g10 = (this.printing ? function(t108, e11) {
      let i11 = t108.getBoundingClientRect();
      return { left: 0, right: i11.right - i11.left, top: e11, bottom: i11.bottom - (i11.top + e11) };
    } : function(t108, e11) {
      let i11 = t108.getBoundingClientRect(), s11 = t108.ownerDocument, n11 = s11.defaultView || window, o11 = Math.max(0, i11.left), r10 = Math.min(n11.innerWidth, i11.right), l11 = Math.max(0, i11.top), h11 = Math.min(n11.innerHeight, i11.bottom);
      for (let e12 = t108.parentNode; e12 && e12 != s11.body; ) if (1 == e12.nodeType) {
        let i12 = e12, s12 = window.getComputedStyle(i12);
        if ((i12.scrollHeight > i12.clientHeight || i12.scrollWidth > i12.clientWidth) && "visible" != s12.overflow) {
          let s13 = i12.getBoundingClientRect();
          o11 = Math.max(o11, s13.left), r10 = Math.min(r10, s13.right), l11 = Math.max(l11, s13.top), h11 = e12 == t108.parentNode ? s13.bottom : Math.min(h11, s13.bottom);
        }
        e12 = "absolute" == s12.position || "fixed" == s12.position ? i12.offsetParent : i12.parentNode;
      } else if (11 == e12.nodeType) e12 = e12.host;
      else break;
      return { left: o11 - i11.left, right: Math.max(o11, r10) - i11.left, top: l11 - (i11.top + e11), bottom: Math.max(l11, h11) - (i11.top + e11) };
    })(e10, this.paddingTop), p10 = g10.top - this.pixelViewport.top, m10 = g10.bottom - this.pixelViewport.bottom;
    this.pixelViewport = g10;
    let v10 = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (v10 != this.inView && (this.inView = v10, v10 && (h10 = true)), !this.inView && !this.scrollTarget) return 0;
    let w10 = l10.width;
    if ((this.contentDOMWidth != w10 || this.editorHeight != t107.scrollDOM.clientHeight) && (this.contentDOMWidth = l10.width, this.editorHeight = t107.scrollDOM.clientHeight, a10 |= 8), h10) {
      let e11 = t107.docView.measureVisibleLineHeights(this.viewport);
      if (s10.mustRefreshForHeights(e11) && (o10 = true), o10 || s10.lineWrapping && Math.abs(w10 - this.contentDOMWidth) > s10.charWidth) {
        let { lineHeight: i11, charWidth: r10, textHeight: l11 } = t107.docView.measureTextSize();
        (o10 = i11 > 0 && s10.refresh(n10, i11, r10, l11, w10 / r10, e11)) && (t107.docView.minWidth = 0, a10 |= 8);
      }
      for (let i11 of (p10 > 0 && m10 > 0 ? c10 = Math.max(p10, m10) : p10 < 0 && m10 < 0 && (c10 = Math.min(p10, m10)), s10.heightChanged = false, this.viewports)) {
        let n11 = i11.from == this.viewport.from ? e11 : t107.docView.measureVisibleLineHeights(i11);
        this.heightMap = (o10 ? lf.empty().applyChanges(this.stateDeco, r.empty, this.heightOracle, [new rR(0, 0, 0, t107.state.doc.length)]) : this.heightMap).updateHeight(s10, 0, o10, new lc(i11.from, n11));
      }
      s10.heightChanged && (a10 |= 2);
    }
    let b10 = !this.viewportIsAppropriate(this.viewport, c10) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return b10 && (2 & a10 && (a10 |= this.updateScaler()), this.viewport = this.getViewport(c10, this.scrollTarget), a10 |= this.updateForViewport()), (2 & a10 || b10) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(o10 ? [] : this.lineGaps, t107)), a10 |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = false, t107.docView.enforceCursorAssoc()), a10;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(t107, e10) {
    let i10 = 0.5 - Math.max(-0.5, Math.min(0.5, t107 / 1e3 / 2)), s10 = this.heightMap, n10 = this.heightOracle, { visibleTop: o10, visibleBottom: r10 } = this, l10 = new lM(s10.lineAt(o10 - 1e3 * i10, lu.ByHeight, n10, 0, 0).from, s10.lineAt(r10 + (1 - i10) * 1e3, lu.ByHeight, n10, 0, 0).to);
    if (e10) {
      let { head: t108 } = e10.range;
      if (t108 < l10.from || t108 > l10.to) {
        let i11 = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), o11 = s10.lineAt(t108, lu.ByPos, n10, 0, 0), r11;
        r11 = "center" == e10.y ? (o11.top + o11.bottom) / 2 - i11 / 2 : "start" == e10.y || "nearest" == e10.y && t108 < l10.from ? o11.top : o11.bottom - i11, l10 = new lM(s10.lineAt(r11 - 500, lu.ByHeight, n10, 0, 0).from, s10.lineAt(r11 + i11 + 500, lu.ByHeight, n10, 0, 0).to);
      }
    }
    return l10;
  }
  mapViewport(t107, e10) {
    let i10 = e10.mapPos(t107.from, -1), s10 = e10.mapPos(t107.to, 1);
    return new lM(this.heightMap.lineAt(i10, lu.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(s10, lu.ByPos, this.heightOracle, 0, 0).to);
  }
  viewportIsAppropriate(t107) {
    let { from: e10, to: i10 } = t107, s10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    if (!this.inView) return true;
    let { top: n10 } = this.heightMap.lineAt(e10, lu.ByPos, this.heightOracle, 0, 0), { bottom: o10 } = this.heightMap.lineAt(i10, lu.ByPos, this.heightOracle, 0, 0), { visibleTop: r10, visibleBottom: l10 } = this;
    return (0 == e10 || n10 <= r10 - Math.max(10, Math.min(-s10, 250))) && (i10 == this.state.doc.length || o10 >= l10 + Math.max(10, Math.min(s10, 250))) && n10 > r10 - 2e3 && o10 < l10 + 2e3;
  }
  mapLineGaps(t107, e10) {
    if (!t107.length || e10.empty) return t107;
    let i10 = [];
    for (let s10 of t107) e10.touchesRange(s10.from, s10.to) || i10.push(new lx(e10.mapPos(s10.from), e10.mapPos(s10.to), s10.size));
    return i10;
  }
  ensureLineGaps(t107, e10) {
    let i10 = this.heightOracle.lineWrapping, s10 = i10 ? 1e4 : 2e3, n10 = s10 >> 1, o10 = s10 << 1;
    if (this.defaultTextDirection != oQ.LTR && !i10) return [];
    let r10 = [], l10 = (s11, o11, h11, a10) => {
      if (o11 - s11 < n10) return;
      let c10 = this.state.selection.main, d10 = [c10.from];
      for (let t108 of (c10.empty || d10.push(c10.to), d10)) if (t108 > s11 && t108 < o11) {
        l10(s11, t108 - 10, h11, a10), l10(t108 + 10, o11, h11, a10);
        return;
      }
      let u10 = function(t108, e11) {
        for (let i11 of t108) if (e11(i11)) return i11;
      }(t107, (t108) => t108.from >= h11.from && t108.to <= h11.to && Math.abs(t108.from - s11) < n10 && Math.abs(t108.to - o11) < n10 && !d10.some((e11) => t108.from < e11 && t108.to > e11));
      if (!u10) {
        if (o11 < h11.to && e10 && i10 && e10.visibleRanges.some((t108) => t108.from <= o11 && t108.to >= o11)) {
          let t108 = e10.moveToLineBoundary(ti.cursor(o11), false, true).head;
          t108 > s11 && (o11 = t108);
        }
        u10 = new lx(s11, o11, this.gapSize(h11, s11, o11, a10));
      }
      r10.push(u10);
    }, h10 = (t108) => {
      var e11, n11, r11;
      let h11, a10, c10, d10, u10;
      if (t108.length < o10 || t108.type != oK.Text) return;
      let f10 = (e11 = t108.from, n11 = t108.to, r11 = this.stateDeco, c10 = [], d10 = e11, u10 = 0, tG.spans(r11, e11, n11, { span() {
      }, point(t109, e12) {
        t109 > d10 && (c10.push({ from: d10, to: t109 }), u10 += t109 - d10), d10 = e12;
      } }, 20), d10 < n11 && (c10.push({ from: d10, to: n11 }), u10 += n11 - d10), { total: u10, ranges: c10 });
      if (f10.total < o10) return;
      let g10 = this.scrollTarget ? this.scrollTarget.range.head : null;
      if (i10) {
        let e12, i11, n12 = s10 / this.heightOracle.lineLength * this.heightOracle.lineHeight;
        if (null != g10) {
          let s11 = lA(f10, g10), o11 = ((this.visibleBottom - this.visibleTop) / 2 + n12) / t108.height;
          e12 = s11 - o11, i11 = s11 + o11;
        } else e12 = (this.visibleTop - t108.top - n12) / t108.height, i11 = (this.visibleBottom - t108.top + n12) / t108.height;
        h11 = lC(f10, e12), a10 = lC(f10, i11);
      } else {
        let t109, e12, i11 = f10.total * this.heightOracle.charWidth, n12 = s10 * this.heightOracle.charWidth;
        if (null != g10) {
          let s11 = lA(f10, g10), o11 = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + n12) / i11;
          t109 = s11 - o11, e12 = s11 + o11;
        } else t109 = (this.pixelViewport.left - n12) / i11, e12 = (this.pixelViewport.right + n12) / i11;
        h11 = lC(f10, t109), a10 = lC(f10, e12);
      }
      h11 > t108.from && l10(t108.from, h11, t108, f10), a10 < t108.to && l10(a10, t108.to, t108, f10);
    };
    for (let t108 of this.viewportLines) Array.isArray(t108.type) ? t108.type.forEach(h10) : h10(t108);
    return r10;
  }
  gapSize(t107, e10, i10, s10) {
    let n10 = lA(s10, i10) - lA(s10, e10);
    return this.heightOracle.lineWrapping ? t107.height * n10 : s10.total * this.heightOracle.charWidth * n10;
  }
  updateLineGaps(t107) {
    lx.same(t107, this.lineGaps) || (this.lineGaps = t107, this.lineGapDeco = oq.set(t107.map((t108) => t108.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let t107 = this.stateDeco;
    this.lineGaps.length && (t107 = t107.concat(this.lineGapDeco));
    let e10 = [];
    tG.spans(t107, this.viewport.from, this.viewport.to, { span(t108, i11) {
      e10.push({ from: t108, to: i11 });
    }, point() {
    } }, 20);
    let i10 = e10.length != this.visibleRanges.length || this.visibleRanges.some((t108, i11) => t108.from != e10[i11].from || t108.to != e10[i11].to);
    return this.visibleRanges = e10, i10 ? 4 : 0;
  }
  lineBlockAt(t107) {
    return t107 >= this.viewport.from && t107 <= this.viewport.to && this.viewportLines.find((e10) => e10.from <= t107 && e10.to >= t107) || lT(this.heightMap.lineAt(t107, lu.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(t107) {
    return t107 >= this.viewportLines[0].top && t107 <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((e10) => e10.top <= t107 && e10.bottom >= t107) || lT(this.heightMap.lineAt(this.scaler.fromDOM(t107), lu.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(t107) {
    let e10 = this.lineBlockAtHeight(t107 + 8);
    return e10.from >= this.viewport.from || this.viewportLines[0].top - t107 > 200 ? e10 : this.viewportLines[0];
  }
  elementAtHeight(t107) {
    return lT(this.heightMap.blockAt(this.scaler.fromDOM(t107), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}, lM = class {
  constructor(t107, e10) {
    this.from = t107, this.to = e10;
  }
};
function lC(t107, e10) {
  let { total: i10, ranges: s10 } = t107;
  if (e10 <= 0) return s10[0].from;
  if (e10 >= 1) return s10[s10.length - 1].to;
  let n10 = Math.floor(i10 * e10);
  for (let t108 = 0; ; t108++) {
    let { from: e11, to: i11 } = s10[t108], o10 = i11 - e11;
    if (n10 <= o10) return e11 + n10;
    n10 -= o10;
  }
}
function lA(t107, e10) {
  let i10 = 0;
  for (let { from: s10, to: n10 } of t107.ranges) {
    if (e10 <= n10) {
      i10 += e10 - s10;
      break;
    }
    i10 += n10 - s10;
  }
  return i10 / t107.total;
}
let lD = { toDOM: (t107) => t107, fromDOM: (t107) => t107, scale: 1, eq(t107) {
  return t107 == this;
} }, lO = class t56 {
  constructor(t107, e10, i10) {
    let s10 = 0, n10 = 0, o10 = 0;
    for (let r10 of (this.viewports = i10.map((i11) => {
      let { from: n11, to: o11 } = i11, r11 = e10.lineAt(n11, lu.ByPos, t107, 0, 0).top, l10 = e10.lineAt(o11, lu.ByPos, t107, 0, 0).bottom;
      return s10 += l10 - r11, { from: n11, to: o11, top: r11, bottom: l10, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - s10) / (e10.height - s10), this.viewports)) r10.domTop = o10 + (r10.top - n10) * this.scale, o10 = r10.domBottom = r10.domTop + (r10.bottom - r10.top), n10 = r10.bottom;
  }
  toDOM(t107) {
    for (let e10 = 0, i10 = 0, s10 = 0; ; e10++) {
      let n10 = e10 < this.viewports.length ? this.viewports[e10] : null;
      if (!n10 || t107 < n10.top) return s10 + (t107 - i10) * this.scale;
      if (t107 <= n10.bottom) return n10.domTop + (t107 - n10.top);
      i10 = n10.bottom, s10 = n10.domBottom;
    }
  }
  fromDOM(t107) {
    for (let e10 = 0, i10 = 0, s10 = 0; ; e10++) {
      let n10 = e10 < this.viewports.length ? this.viewports[e10] : null;
      if (!n10 || t107 < n10.domTop) return i10 + (t107 - s10) / this.scale;
      if (t107 <= n10.domBottom) return n10.top + (t107 - n10.domTop);
      i10 = n10.bottom, s10 = n10.domBottom;
    }
  }
  eq(e10) {
    return e10 instanceof t56 && this.scale == e10.scale && this.viewports.length == e10.viewports.length && this.viewports.every((t107, i10) => t107.from == e10.viewports[i10].from && t107.to == e10.viewports[i10].to);
  }
};
function lT(t107, e10) {
  if (1 == e10.scale) return t107;
  let i10 = e10.toDOM(t107.top), s10 = e10.toDOM(t107.bottom);
  return new ld(t107.from, t107.length, i10, s10 - i10, Array.isArray(t107._content) ? t107._content.map((t108) => lT(t108, e10)) : t107._content);
}
let lE = to.define({ combine: (t107) => t107.join(" ") }), lR = to.define({ combine: (t107) => t107.indexOf(true) > -1 }), lB = t6.newName(), lL = t6.newName(), lP = t6.newName(), lN = { "&light": "." + lL, "&dark": "." + lP };
function lV(t107, e10, i10) {
  return new t6(e10, { finish: (e11) => /&/.test(e11) ? e11.replace(/&\w*/, (e12) => {
    if ("&" == e12) return t107;
    if (!i10 || !i10[e12]) throw RangeError(`Unsupported selector: ${e12}`);
    return i10[e12];
  }) : t107 + " " + e11 });
}
let lH = lV("." + lB, { "&": { position: "relative !important", boxSizing: "border-box", "&.cm-focused": { outline: "1px dotted #212121" }, display: "flex !important", flexDirection: "column" }, ".cm-scroller": { display: "flex !important", alignItems: "flex-start !important", fontFamily: "monospace", lineHeight: 1.4, height: "100%", overflowX: "auto", position: "relative", zIndex: 0 }, ".cm-content": { margin: 0, flexGrow: 2, flexShrink: 0, display: "block", whiteSpace: "pre", wordWrap: "normal", boxSizing: "border-box", minHeight: "100%", padding: "4px 0", outline: "none", "&[contenteditable=true]": { WebkitUserModify: "read-write-plaintext-only" } }, ".cm-lineWrapping": { whiteSpace_fallback: "pre-wrap", whiteSpace: "break-spaces", wordBreak: "break-word", overflowWrap: "anywhere", flexShrink: 1 }, "&light .cm-content": { caretColor: "black" }, "&dark .cm-content": { caretColor: "white" }, ".cm-line": { display: "block", padding: "0 2px 0 6px" }, ".cm-layer": { position: "absolute", left: 0, top: 0, contain: "size style", "& > *": { position: "absolute" } }, "&light .cm-selectionBackground": { background: "#d9d9d9" }, "&dark .cm-selectionBackground": { background: "#222" }, "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": { background: "#d7d4f0" }, "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": { background: "#233" }, ".cm-cursorLayer": { pointerEvents: "none" }, "&.cm-focused > .cm-scroller > .cm-cursorLayer": { animation: "steps(1) cm-blink 1.2s infinite" }, "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} }, "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} }, ".cm-cursor, .cm-dropCursor": { borderLeft: "1.2px solid black", marginLeft: "-0.6px", pointerEvents: "none" }, ".cm-cursor": { display: "none" }, "&dark .cm-cursor": { borderLeftColor: "#444" }, ".cm-dropCursor": { position: "absolute" }, "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": { display: "block" }, ".cm-iso": { unicodeBidi: "isolate" }, ".cm-announced": { position: "fixed", top: "-10000px" }, "@media print": { ".cm-announced": { display: "none" } }, "&light .cm-activeLine": { backgroundColor: "#cceeff44" }, "&dark .cm-activeLine": { backgroundColor: "#99eeff33" }, "&light .cm-specialChar": { color: "red" }, "&dark .cm-specialChar": { color: "#f78" }, ".cm-gutters": { flexShrink: 0, display: "flex", height: "100%", boxSizing: "border-box", insetInlineStart: 0, zIndex: 200 }, "&light .cm-gutters": { backgroundColor: "#f5f5f5", color: "#6c6c6c", borderRight: "1px solid #ddd" }, "&dark .cm-gutters": { backgroundColor: "#333338", color: "#ccc" }, ".cm-gutter": { display: "flex !important", flexDirection: "column", flexShrink: 0, boxSizing: "border-box", minHeight: "100%", overflow: "hidden" }, ".cm-gutterElement": { boxSizing: "border-box" }, ".cm-lineNumbers .cm-gutterElement": { padding: "0 3px 0 5px", minWidth: "20px", textAlign: "right", whiteSpace: "nowrap" }, "&light .cm-activeLineGutter": { backgroundColor: "#e2f2ff" }, "&dark .cm-activeLineGutter": { backgroundColor: "#222227" }, ".cm-panels": { boxSizing: "border-box", position: "sticky", left: 0, right: 0 }, "&light .cm-panels": { backgroundColor: "#f5f5f5", color: "black" }, "&light .cm-panels-top": { borderBottom: "1px solid #ddd" }, "&light .cm-panels-bottom": { borderTop: "1px solid #ddd" }, "&dark .cm-panels": { backgroundColor: "#333338", color: "white" }, ".cm-tab": { display: "inline-block", overflow: "hidden", verticalAlign: "bottom" }, ".cm-widgetBuffer": { verticalAlign: "text-top", height: "1em", width: 0, display: "inline" }, ".cm-placeholder": { color: "#888", display: "inline-block", verticalAlign: "top" }, ".cm-highlightSpace:before": { content: "attr(data-display)", position: "absolute", pointerEvents: "none", color: "#888" }, ".cm-highlightTab": { backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`, backgroundSize: "auto 100%", backgroundPosition: "right 90%", backgroundRepeat: "no-repeat" }, ".cm-trailingSpace": { backgroundColor: "#ff332255" }, ".cm-button": { verticalAlign: "middle", color: "inherit", fontSize: "70%", padding: ".2em 1em", borderRadius: "1px" }, "&light .cm-button": { backgroundImage: "linear-gradient(#eff1f5, #d9d9df)", border: "1px solid #888", "&:active": { backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)" } }, "&dark .cm-button": { backgroundImage: "linear-gradient(#393939, #111)", border: "1px solid #888", "&:active": { backgroundImage: "linear-gradient(#111, #333)" } }, ".cm-textfield": { verticalAlign: "middle", color: "inherit", fontSize: "70%", border: "1px solid silver", padding: ".2em .5em" }, "&light .cm-textfield": { backgroundColor: "white" }, "&dark .cm-textfield": { border: "1px solid #555", backgroundColor: "inherit" } }, lN), lF = class {
  constructor(t107, e10) {
    this.points = t107, this.text = "", this.lineSeparator = e10.facet(tW.lineSeparator);
  }
  append(t107) {
    this.text += t107;
  }
  lineBreak() {
    this.text += "";
  }
  readRange(t107, e10) {
    if (!t107) return this;
    let i10 = t107.parentNode;
    for (let s10 = t107; ; ) {
      this.findPointBefore(i10, s10);
      let t108 = this.text.length;
      this.readNode(s10);
      let n10 = s10.nextSibling;
      if (n10 == e10) break;
      let o10 = ou.get(s10), r10 = ou.get(n10);
      (o10 && r10 ? o10.breakAfter : (o10 ? o10.breakAfter : n9(s10)) || n9(n10) && ("BR" != s10.nodeName || s10.cmIgnore) && this.text.length > t108) && this.lineBreak(), s10 = n10;
    }
    return this.findPointBefore(i10, e10), this;
  }
  readTextNode(t107) {
    let e10 = t107.nodeValue;
    for (let i10 of this.points) i10.node == t107 && (i10.pos = this.text.length + Math.min(i10.offset, e10.length));
    for (let i10 = 0, s10 = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let n10 = -1, o10 = 1, r10;
      if (this.lineSeparator ? (n10 = e10.indexOf(this.lineSeparator, i10), o10 = this.lineSeparator.length) : (r10 = s10.exec(e10)) && (n10 = r10.index, o10 = r10[0].length), this.append(e10.slice(i10, n10 < 0 ? e10.length : n10)), n10 < 0) break;
      if (this.lineBreak(), o10 > 1) for (let e11 of this.points) e11.node == t107 && e11.pos > this.text.length && (e11.pos -= o10 - 1);
      i10 = n10 + o10;
    }
  }
  readNode(t107) {
    if (t107.cmIgnore) return;
    let e10 = ou.get(t107), i10 = e10 && e10.overrideDOMText;
    if (null != i10) {
      this.findPointInside(t107, i10.length);
      for (let t108 = i10.iter(); !t108.next().done; ) t108.lineBreak ? this.lineBreak() : this.append(t108.value);
    } else 3 == t107.nodeType ? this.readTextNode(t107) : "BR" == t107.nodeName ? t107.nextSibling && this.lineBreak() : 1 == t107.nodeType && this.readRange(t107.firstChild, null);
  }
  findPointBefore(t107, e10) {
    for (let i10 of this.points) i10.node == t107 && t107.childNodes[i10.offset] == e10 && (i10.pos = this.text.length);
  }
  findPointInside(t107, e10) {
    for (let i10 of this.points) (3 == t107.nodeType ? i10.node == t107 : t107.contains(i10.node)) && (i10.pos = this.text.length + (!function(t108, e11, i11) {
      for (; ; ) {
        if (!e11 || i11 < n6(e11)) return false;
        if (e11 == t108) return true;
        i11 = n4(e11) + 1, e11 = e11.parentNode;
      }
    }(t107, i10.node, i10.offset) ? 0 : e10));
  }
}, lW = class {
  constructor(t107, e10) {
    this.node = t107, this.offset = e10, this.pos = -1;
  }
}, lI = class {
  constructor(t107, e10, i10, s10) {
    this.typeOver = s10, this.bounds = null, this.text = "", this.domChanged = e10 > -1;
    let { impreciseHead: n10, impreciseAnchor: o10 } = t107.docView;
    if (t107.state.readOnly && e10 > -1) this.newSel = null;
    else if (e10 > -1 && (this.bounds = t107.docView.domBoundsAround(e10, i10, 0))) {
      let e11 = n10 || o10 ? [] : function(t108) {
        let e12 = [];
        if (t108.root.activeElement != t108.contentDOM) return e12;
        let { anchorNode: i12, anchorOffset: s11, focusNode: n11, focusOffset: o11 } = t108.observer.selectionRange;
        return i12 && (e12.push(new lW(i12, s11)), (n11 != i12 || o11 != s11) && e12.push(new lW(n11, o11))), e12;
      }(t107), i11 = new lF(e11, t107.state);
      i11.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = i11.text, this.newSel = function(t108, e12) {
        if (0 == t108.length) return null;
        let i12 = t108[0].pos, s11 = 2 == t108.length ? t108[1].pos : i12;
        return i12 > -1 && s11 > -1 ? ti.single(i12 + e12, s11 + e12) : null;
      }(e11, this.bounds.from);
    } else {
      let e11 = t107.observer.selectionRange, i11 = n10 && n10.node == e11.focusNode && n10.offset == e11.focusOffset || !n1(t107.contentDOM, e11.focusNode) ? t107.state.selection.main.head : t107.docView.posFromDOM(e11.focusNode, e11.focusOffset), s11 = o10 && o10.node == e11.anchorNode && o10.offset == e11.anchorOffset || !n1(t107.contentDOM, e11.anchorNode) ? t107.state.selection.main.anchor : t107.docView.posFromDOM(e11.anchorNode, e11.anchorOffset), r10 = t107.viewport;
      if ((oO.ios || oO.chrome) && t107.state.selection.main.empty && i11 != s11 && (r10.from > 0 || r10.to < t107.state.doc.length)) {
        let e12 = Math.min(i11, s11), n11 = Math.max(i11, s11), o11 = r10.from - e12, l10 = r10.to - n11;
        (0 == o11 || 1 == o11 || 0 == e12) && (0 == l10 || -1 == l10 || n11 == t107.state.doc.length) && (i11 = 0, s11 = t107.state.doc.length);
      }
      this.newSel = ti.single(s11, i11);
    }
  }
};
function lz(t107, e10) {
  let i10;
  let { newSel: s10 } = e10, n10 = t107.state.selection.main, o10 = t107.inputState.lastKeyTime > Date.now() - 100 ? t107.inputState.lastKeyCode : -1;
  if (e10.bounds) {
    let { from: s11, to: l10 } = e10.bounds, h10 = n10.from, a10 = null;
    (8 === o10 || oO.android && e10.text.length < l10 - s11) && (h10 = n10.to, a10 = "end");
    let c10 = function(t108, e11, i11, s12) {
      let n11 = Math.min(t108.length, e11.length), o11 = 0;
      for (; o11 < n11 && t108.charCodeAt(o11) == e11.charCodeAt(o11); ) o11++;
      if (o11 == n11 && t108.length == e11.length) return null;
      let r10 = t108.length, l11 = e11.length;
      for (; r10 > 0 && l11 > 0 && t108.charCodeAt(r10 - 1) == e11.charCodeAt(l11 - 1); ) r10--, l11--;
      if ("end" == s12) {
        let t109 = Math.max(0, o11 - Math.min(r10, l11));
        i11 -= r10 + t109 - o11;
      }
      if (r10 < o11 && t108.length < e11.length) {
        let t109 = i11 <= o11 && i11 >= r10 ? o11 - i11 : 0;
        o11 -= t109, l11 = o11 + (l11 - r10), r10 = o11;
      } else if (l11 < o11) {
        let t109 = i11 <= o11 && i11 >= l11 ? o11 - i11 : 0;
        o11 -= t109, r10 = o11 + (r10 - l11), l11 = o11;
      }
      return { from: o11, toA: r10, toB: l11 };
    }(t107.state.doc.sliceString(s11, l10, ""), e10.text, h10 - s11, a10);
    c10 && (oO.chrome && 13 == o10 && c10.toB == c10.from + 2 && "" == e10.text.slice(c10.from, c10.toB) && c10.toB--, i10 = { from: s11 + c10.from, to: s11 + c10.toA, insert: r.of(e10.text.slice(c10.from, c10.toB).split("")) });
  } else s10 && (!t107.hasFocus && t107.state.facet(rm) || s10.main.eq(n10)) && (s10 = null);
  if (!i10 && !s10) return false;
  if (!i10 && e10.typeOver && !n10.empty && s10 && s10.main.empty ? i10 = { from: n10.from, to: n10.to, insert: t107.state.doc.slice(n10.from, n10.to) } : i10 && i10.from >= n10.from && i10.to <= n10.to && (i10.from != n10.from || i10.to != n10.to) && n10.to - n10.from - (i10.to - i10.from) <= 4 ? i10 = { from: n10.from, to: n10.to, insert: t107.state.doc.slice(n10.from, i10.from).append(i10.insert).append(t107.state.doc.slice(i10.to, n10.to)) } : (oO.mac || oO.android) && i10 && i10.from == i10.to && i10.from == n10.head - 1 && /^\. ?$/.test(i10.insert.toString()) && "off" == t107.contentDOM.getAttribute("autocorrect") ? (s10 && 2 == i10.insert.length && (s10 = ti.single(s10.main.anchor - 1, s10.main.head - 1)), i10 = { from: n10.from, to: n10.to, insert: r.of([" "]) }) : oO.chrome && i10 && i10.from == i10.to && i10.from == n10.head && "\n " == i10.insert.toString() && t107.lineWrapping && (s10 && (s10 = ti.single(s10.main.anchor - 1, s10.main.head - 1)), i10 = { from: n10.from, to: n10.to, insert: r.of([" "]) }), i10) return lK(t107, i10, s10, o10);
  if (!s10 || s10.main.eq(n10)) return false;
  {
    let e11 = false, i11 = "select";
    return t107.inputState.lastSelectionTime > Date.now() - 50 && ("select" == t107.inputState.lastSelectionOrigin && (e11 = true), i11 = t107.inputState.lastSelectionOrigin), t107.dispatch({ selection: s10, scrollIntoView: e11, userEvent: i11 }), true;
  }
}
function lK(t107, e10, i10) {
  let s10, n10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : -1;
  if (oO.ios && t107.inputState.flushIOSKey(e10)) return true;
  let o10 = t107.state.selection.main;
  if (oO.android && (e10.to == o10.to && (e10.from == o10.from || e10.from == o10.from - 1 && " " == t107.state.sliceDoc(e10.from, o10.from)) && 1 == e10.insert.length && 2 == e10.insert.lines && oo(t107.contentDOM, "Enter", 13) || (e10.from == o10.from - 1 && e10.to == o10.to && 0 == e10.insert.length || 8 == n10 && e10.insert.length < e10.to - e10.from && e10.to > o10.head) && oo(t107.contentDOM, "Backspace", 8) || e10.from == o10.from && e10.to == o10.to + 1 && 0 == e10.insert.length && oo(t107.contentDOM, "Delete", 46))) return true;
  let r10 = e10.insert.toString();
  t107.inputState.composing >= 0 && t107.inputState.composing++;
  let l10 = () => s10 || (s10 = function(t108, e11, i11) {
    let s11, n11 = t108.state, o11 = n11.selection.main;
    if (e11.from >= o11.from && e11.to <= o11.to && e11.to - e11.from >= (o11.to - o11.from) / 3 && (!i11 || i11.main.empty && i11.main.from == e11.from + e11.insert.length) && t108.inputState.composing < 0) {
      let i12 = o11.from < e11.from ? n11.sliceDoc(o11.from, e11.from) : "", r12 = o11.to > e11.to ? n11.sliceDoc(e11.to, o11.to) : "";
      s11 = n11.replaceSelection(t108.state.toText(i12 + e11.insert.sliceString(0, void 0, t108.state.lineBreak) + r12));
    } else {
      let r12 = n11.changes(e11), l11 = i11 && i11.main.to <= r12.newLength ? i11.main : void 0;
      if (n11.selection.ranges.length > 1 && t108.inputState.composing >= 0 && e11.to <= o11.to && e11.to >= o11.to - 10) {
        let h10 = t108.state.sliceDoc(e11.from, e11.to), a10, c10 = i11 && rN(t108, i11.main.head);
        if (c10) {
          let t109 = e11.insert.length - (e11.to - e11.from);
          a10 = { from: c10.from, to: c10.to - t109 };
        } else a10 = t108.state.doc.lineAt(o11.head);
        let d10 = o11.to - e11.to, u10 = o11.to - o11.from;
        s11 = n11.changeByRange((i12) => {
          if (i12.from == o11.from && i12.to == o11.to) return { changes: r12, range: l11 || i12.map(r12) };
          let s12 = i12.to - d10, c11 = s12 - h10.length;
          if (i12.to - i12.from != u10 || t108.state.sliceDoc(c11, s12) != h10 || i12.to >= a10.from && i12.from <= a10.to) return { range: i12 };
          let f10 = n11.changes({ from: c11, to: s12, insert: e11.insert }), g10 = i12.to - o11.to;
          return { changes: f10, range: l11 ? ti.range(Math.max(0, l11.anchor + g10), Math.max(0, l11.head + g10)) : i12.map(f10) };
        });
      } else s11 = { changes: r12, selection: l11 && n11.selection.replaceRange(l11) };
    }
    let r11 = "input.type";
    return (t108.composing || t108.inputState.compositionPendingChange && t108.inputState.compositionEndedAt > Date.now() - 50) && (t108.inputState.compositionPendingChange = false, r11 += ".compose", t108.inputState.compositionFirstChange && (r11 += ".start", t108.inputState.compositionFirstChange = false)), n11.update(s11, { userEvent: r11, scrollIntoView: true });
  }(t107, e10, i10));
  return t107.state.facet(rl).some((i11) => i11(t107, e10.from, e10.to, r10, l10)) || t107.dispatch(l10()), true;
}
let lq = { childList: true, characterData: true, subtree: true, attributes: true, characterDataOldValue: true }, l_ = oO.ie && oO.ie_version <= 11, lG = class {
  constructor(t107) {
    this.view = t107, this.active = false, this.editContext = null, this.selectionRange = new oe(), this.selectionChanged = false, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = false, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = t107.contentDOM, this.observer = new MutationObserver((e10) => {
      for (let t108 of e10) this.queue.push(t108);
      (oO.ie && oO.ie_version <= 11 || oO.ios && t107.composing) && e10.some((t108) => "childList" == t108.type && t108.removedNodes.length || "characterData" == t108.type && t108.oldValue.length > t108.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && false !== t107.constructor.EDIT_CONTEXT && !(oO.chrome && oO.chrome_version < 126) && (this.editContext = new lY(t107), t107.state.facet(rm) && (t107.contentDOM.editContext = this.editContext.editContext)), l_ && (this.onCharData = (t108) => {
      this.queue.push({ target: t108.target, type: "characterData", oldValue: t108.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), "function" == typeof ResizeObserver && (this.resizeScroll = new ResizeObserver(() => {
      var t108;
      (null === (t108 = this.view.docView) || void 0 === t108 ? void 0 : t108.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(t107.scrollDOM)), this.addWindowListeners(this.win = t107.win), this.start(), "function" == typeof IntersectionObserver && (this.intersection = new IntersectionObserver((t108) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), t108.length > 0 && t108[t108.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((t108) => {
      t108.length > 0 && t108[t108.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(t107) {
    this.view.inputState.runHandlers("scroll", t107), this.intersecting && this.view.measure();
  }
  onScroll(t107) {
    this.intersecting && this.flush(false), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(t107);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(t107) {
    ("change" != t107.type || t107.matches) && (this.view.viewState.printing = true, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = false, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(t107) {
    if (this.gapIntersection && (t107.length != this.gaps.length || this.gaps.some((e10, i10) => e10 != t107[i10]))) {
      for (let e10 of (this.gapIntersection.disconnect(), t107)) this.gapIntersection.observe(e10);
      this.gaps = t107;
    }
  }
  onSelectionChange(t107) {
    let e10 = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey) return;
    let { view: i10 } = this, s10 = this.selectionRange;
    if (i10.state.facet(rm) ? i10.root.activeElement != this.dom : !n2(i10.dom, s10)) return;
    let n10 = s10.anchorNode && i10.docView.nearest(s10.anchorNode);
    if (n10 && n10.ignoreEvent(t107)) {
      e10 || (this.selectionChanged = false);
      return;
    }
    (oO.ie && oO.ie_version <= 11 || oO.android && oO.chrome) && !i10.state.selection.main.empty && s10.focusNode && n3(s10.focusNode, s10.focusOffset, s10.anchorNode, s10.anchorOffset) ? this.flushSoon() : this.flush(false);
  }
  readSelectionRange() {
    let { view: t107 } = this, e10 = n0(t107.root);
    if (!e10) return false;
    let i10 = oO.safari && 11 == t107.root.nodeType && function(t108) {
      let e11 = t108.activeElement;
      for (; e11 && e11.shadowRoot; ) e11 = e11.shadowRoot.activeElement;
      return e11;
    }(this.dom.ownerDocument) == this.dom && function(t108, e11) {
      if (e11.getComposedRanges) {
        let i12 = e11.getComposedRanges(t108.root)[0];
        if (i12) return lU(t108, i12);
      }
      let i11 = null;
      function s11(t109) {
        t109.preventDefault(), t109.stopImmediatePropagation(), i11 = t109.getTargetRanges()[0];
      }
      return t108.contentDOM.addEventListener("beforeinput", s11, true), t108.dom.ownerDocument.execCommand("indent"), t108.contentDOM.removeEventListener("beforeinput", s11, true), i11 ? lU(t108, i11) : null;
    }(this.view, e10) || e10;
    if (!i10 || this.selectionRange.eq(i10)) return false;
    let s10 = n2(this.dom, i10);
    return s10 && !this.selectionChanged && t107.inputState.lastFocusTime > Date.now() - 200 && t107.inputState.lastTouchTime < Date.now() - 300 && function(t108, e11) {
      let i11 = e11.focusNode, s11 = e11.focusOffset;
      if (!i11 || e11.anchorNode != i11 || e11.anchorOffset != s11) return false;
      for (s11 = Math.min(s11, n6(i11)); ; ) if (s11) {
        if (1 != i11.nodeType) return false;
        let t109 = i11.childNodes[s11 - 1];
        "false" == t109.contentEditable ? s11-- : s11 = n6(i11 = t109);
      } else {
        if (i11 == t108) return true;
        s11 = n4(i11), i11 = i11.parentNode;
      }
    }(this.dom, i10) ? (this.view.inputState.lastFocusTime = 0, t107.docView.updateSelection(), false) : (this.selectionRange.setRange(i10), s10 && (this.selectionChanged = true), true);
  }
  setSelectionRange(t107, e10) {
    this.selectionRange.set(t107.node, t107.offset, e10.node, e10.offset), this.selectionChanged = false;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let t107 = 0, e10 = null;
    for (let i10 = this.dom; i10; ) if (1 == i10.nodeType) !e10 && t107 < this.scrollTargets.length && this.scrollTargets[t107] == i10 ? t107++ : e10 || (e10 = this.scrollTargets.slice(0, t107)), e10 && e10.push(i10), i10 = i10.assignedSlot || i10.parentNode;
    else if (11 == i10.nodeType) i10 = i10.host;
    else break;
    if (t107 < this.scrollTargets.length && !e10 && (e10 = this.scrollTargets.slice(0, t107)), e10) {
      for (let t108 of this.scrollTargets) t108.removeEventListener("scroll", this.onScroll);
      for (let t108 of this.scrollTargets = e10) t108.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(t107) {
    if (!this.active) return t107();
    try {
      return this.stop(), t107();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, lq), l_ && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = true);
  }
  stop() {
    this.active && (this.active = false, this.observer.disconnect(), l_ && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = false;
  }
  delayAndroidKey(t107, e10) {
    var i10;
    this.delayedAndroidKey || (this.flushingAndroidKey = this.view.win.requestAnimationFrame(() => {
      let t108 = this.delayedAndroidKey;
      t108 && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = t108.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && t108.force && oo(this.dom, t108.key, t108.keyCode));
    })), this.delayedAndroidKey && "Enter" != t107 || (this.delayedAndroidKey = { key: t107, keyCode: e10, force: this.lastChange < Date.now() - 50 || !!(null === (i10 = this.delayedAndroidKey) || void 0 === i10 ? void 0 : i10.force) });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let t107 of this.observer.takeRecords()) this.queue.push(t107);
    return this.queue;
  }
  processRecords() {
    let t107 = this.pendingRecords();
    t107.length && (this.queue = []);
    let e10 = -1, i10 = -1, s10 = false;
    for (let n10 of t107) {
      let t108 = this.readMutation(n10);
      t108 && (t108.typeOver && (s10 = true), -1 == e10 ? { from: e10, to: i10 } = t108 : (e10 = Math.min(t108.from, e10), i10 = Math.max(t108.to, i10)));
    }
    return { from: e10, to: i10, typeOver: s10 };
  }
  readChange() {
    let { from: t107, to: e10, typeOver: i10 } = this.processRecords(), s10 = this.selectionChanged && n2(this.dom, this.selectionRange);
    if (t107 < 0 && !s10) return null;
    t107 > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = false;
    let n10 = new lI(this.view, t107, e10, i10);
    return this.view.docView.domChanged = { newSel: n10.newSel ? n10.newSel.main : null }, n10;
  }
  flush() {
    let t107 = !(arguments.length > 0) || void 0 === arguments[0] || arguments[0];
    if (this.delayedFlush >= 0 || this.delayedAndroidKey) return false;
    t107 && this.readSelectionRange();
    let e10 = this.readChange();
    if (!e10) return this.view.requestMeasure(), false;
    let i10 = this.view.state, s10 = lz(this.view, e10);
    return this.view.state == i10 && (e10.domChanged || e10.newSel && !e10.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), s10;
  }
  readMutation(t107) {
    let e10 = this.view.docView.nearest(t107.target);
    if (!e10 || e10.ignoreMutation(t107)) return null;
    if (e10.markDirty("attributes" == t107.type), "attributes" == t107.type && (e10.flags |= 4), "childList" == t107.type) {
      let i10 = lj(e10, t107.previousSibling || t107.target.previousSibling, -1), s10 = lj(e10, t107.nextSibling || t107.target.nextSibling, 1);
      return { from: i10 ? e10.posAfter(i10) : e10.posAtStart, to: s10 ? e10.posBefore(s10) : e10.posAtEnd, typeOver: false };
    }
    return "characterData" == t107.type ? { from: e10.posAtStart, to: e10.posAtEnd, typeOver: t107.target.nodeValue == t107.oldValue } : null;
  }
  setWindow(t107) {
    t107 != this.win && (this.removeWindowListeners(this.win), this.win = t107, this.addWindowListeners(this.win));
  }
  addWindowListeners(t107) {
    t107.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener("change", this.onPrint) : t107.addEventListener("beforeprint", this.onPrint), t107.addEventListener("scroll", this.onScroll), t107.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(t107) {
    t107.removeEventListener("scroll", this.onScroll), t107.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener("change", this.onPrint) : t107.removeEventListener("beforeprint", this.onPrint), t107.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(t107) {
    this.editContext && (this.editContext.update(t107), t107.startState.facet(rm) != t107.state.facet(rm) && (t107.view.contentDOM.editContext = t107.state.facet(rm) ? this.editContext.editContext : null));
  }
  destroy() {
    var t107, e10, i10;
    for (let s10 of (this.stop(), null === (t107 = this.intersection) || void 0 === t107 || t107.disconnect(), null === (e10 = this.gapIntersection) || void 0 === e10 || e10.disconnect(), null === (i10 = this.resizeScroll) || void 0 === i10 || i10.disconnect(), this.scrollTargets)) s10.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
};
function lj(t107, e10, i10) {
  for (; e10; ) {
    let s10 = ou.get(e10);
    if (s10 && s10.parent == t107) return s10;
    let n10 = e10.parentNode;
    e10 = n10 != t107.dom ? n10 : i10 > 0 ? e10.nextSibling : e10.previousSibling;
  }
  return null;
}
function lU(t107, e10) {
  let i10 = e10.startContainer, s10 = e10.startOffset, n10 = e10.endContainer, o10 = e10.endOffset, r10 = t107.docView.domAtPos(t107.state.selection.main.anchor);
  return n3(r10.node, r10.offset, n10, o10) && ([i10, s10, n10, o10] = [n10, o10, i10, s10]), { anchorNode: i10, anchorOffset: s10, focusNode: n10, focusOffset: o10 };
}
let lY = class {
  constructor(t107) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.resetRange(t107.state);
    let e10 = this.editContext = new window.EditContext({ text: t107.state.doc.sliceString(this.from, this.to), selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, t107.state.selection.main.anchor))), selectionEnd: this.toContextPos(t107.state.selection.main.head) });
    for (let i10 in this.handlers.textupdate = (e11) => {
      let { anchor: i11 } = t107.state.selection.main, s10 = { from: this.toEditorPos(e11.updateRangeStart), to: this.toEditorPos(e11.updateRangeEnd), insert: r.of(e11.text.split("\n")) };
      s10.from == this.from && i11 < this.from ? s10.from = i11 : s10.to == this.to && i11 > this.to && (s10.to = i11), (s10.from != s10.to || s10.insert.length) && (this.pendingContextChange = s10, lK(t107, s10, ti.single(this.toEditorPos(e11.selectionStart), this.toEditorPos(e11.selectionEnd))), this.pendingContextChange && (this.revertPending(t107.state), this.setSelection(t107.state)));
    }, this.handlers.characterboundsupdate = (i11) => {
      let s10 = [], n10 = null;
      for (let e11 = this.toEditorPos(i11.rangeStart), o10 = this.toEditorPos(i11.rangeEnd); e11 < o10; e11++) {
        let i12 = t107.coordsForChar(e11);
        n10 = i12 && new DOMRect(i12.left, i12.top, i12.right - i12.left, i12.bottom - i12.top) || n10 || new DOMRect(), s10.push(n10);
      }
      e10.updateCharacterBounds(i11.rangeStart, s10);
    }, this.handlers.textformatupdate = (e11) => {
      let i11 = [];
      for (let t108 of e11.getTextFormats()) {
        let e12 = t108.underlineStyle, s10 = t108.underlineThickness;
        if ("None" != e12 && "None" != s10) {
          let n10 = `text-decoration: underline ${"Dashed" == e12 ? "dashed " : "Squiggle" == e12 ? "wavy " : ""}${"Thin" == s10 ? 1 : 2}px`;
          i11.push(oq.mark({ attributes: { style: n10 } }).range(this.toEditorPos(t108.rangeStart), this.toEditorPos(t108.rangeEnd)));
        }
      }
      t107.dispatch({ effects: rg.of(oq.set(i11)) });
    }, this.handlers.compositionstart = () => {
      t107.inputState.composing < 0 && (t107.inputState.composing = 0, t107.inputState.compositionFirstChange = true);
    }, this.handlers.compositionend = () => {
      t107.inputState.composing = -1, t107.inputState.compositionFirstChange = null;
    }, this.handlers) e10.addEventListener(i10, this.handlers[i10]);
    this.measureReq = { read: (t108) => {
      this.editContext.updateControlBounds(t108.contentDOM.getBoundingClientRect());
      let e11 = n0(t108.root);
      e11 && e11.rangeCount && this.editContext.updateSelectionBounds(e11.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(t107) {
    let e10 = 0, i10 = false, s10 = this.pendingContextChange;
    return t107.changes.iterChanges((n10, o10, r10, l10, h10) => {
      if (i10) return;
      let a10 = h10.length - (o10 - n10);
      if (s10 && o10 >= s10.to) {
        if (s10.from == n10 && s10.to == o10 && s10.insert.eq(h10)) {
          s10 = this.pendingContextChange = null, e10 += a10, this.to += a10;
          return;
        }
        s10 = null, this.revertPending(t107.state);
      }
      if (n10 += e10, (o10 += e10) <= this.from) this.from += a10, this.to += a10;
      else if (n10 < this.to) {
        if (n10 < this.from || o10 > this.to || this.to - this.from + h10.length > 3e4) {
          i10 = true;
          return;
        }
        this.editContext.updateText(this.toContextPos(n10), this.toContextPos(o10), h10.toString()), this.to += a10;
      }
      e10 += a10;
    }), s10 && !i10 && this.revertPending(t107.state), !i10;
  }
  update(t107) {
    let e10 = this.pendingContextChange;
    this.applyEdits(t107) && this.rangeIsValid(t107.state) ? (t107.docChanged || t107.selectionSet || e10) && this.setSelection(t107.state) : (this.pendingContextChange = null, this.resetRange(t107.state), this.editContext.updateText(0, this.editContext.text.length, t107.state.doc.sliceString(this.from, this.to)), this.setSelection(t107.state)), (t107.geometryChanged || t107.docChanged || t107.selectionSet) && t107.view.requestMeasure(this.measureReq);
  }
  resetRange(t107) {
    let { head: e10 } = t107.selection.main;
    this.from = Math.max(0, e10 - 1e4), this.to = Math.min(t107.doc.length, e10 + 1e4);
  }
  revertPending(t107) {
    let e10 = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(e10.from), this.toContextPos(e10.from + e10.insert.length), t107.doc.sliceString(e10.from, e10.to));
  }
  setSelection(t107) {
    let { main: e10 } = t107.selection, i10 = this.toContextPos(Math.max(this.from, Math.min(this.to, e10.anchor))), s10 = this.toContextPos(e10.head);
    (this.editContext.selectionStart != i10 || this.editContext.selectionEnd != s10) && this.editContext.updateSelection(i10, s10);
  }
  rangeIsValid(t107) {
    let { head: e10 } = t107.selection.main;
    return !(this.from > 0 && e10 - this.from < 500 || this.to < t107.doc.length && this.to - e10 < 500 || this.to - this.from > 3e4);
  }
  toEditorPos(t107) {
    return t107 + this.from;
  }
  toContextPos(t107) {
    return t107 - this.from;
  }
  destroy() {
    for (let t107 in this.handlers) this.editContext.removeEventListener(t107, this.handlers[t107]);
  }
}, l$ = class t57 {
  get state() {
    return this.viewState.state;
  }
  get viewport() {
    return this.viewState.viewport;
  }
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  get inView() {
    return this.viewState.inView;
  }
  get composing() {
    return this.inputState.composing > 0;
  }
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  get root() {
    return this._root;
  }
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  constructor(t107 = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = false, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), t107.parent && t107.parent.appendChild(this.dom);
    let { dispatch: e10 } = t107;
    for (let i10 of (this.dispatchTransactions = t107.dispatchTransactions || e10 && ((t108) => t108.forEach((t109) => e10(t109, this))) || ((t108) => this.update(t108)), this.dispatch = this.dispatch.bind(this), this._root = t107.root || function(t108) {
      for (; t108; ) {
        if (t108 && (9 == t108.nodeType || 11 == t108.nodeType && t108.host)) return t108;
        t108 = t108.assignedSlot || t108.parentNode;
      }
      return null;
    }(t107.parent) || document, this.viewState = new lk(t107.state || tW.create(t107)), t107.scrollTo && t107.scrollTo.is(rf) && (this.viewState.scrollTarget = t107.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(rw).map((t108) => new ry(t108)), this.plugins)) i10.update(this);
    this.observer = new lG(this), this.inputState = new rj(this), this.inputState.ensureHandlers(this.plugins), this.docView = new rL(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure();
  }
  dispatch() {
    for (var t107 = arguments.length, e10 = Array(t107), i10 = 0; i10 < t107; i10++) e10[i10] = arguments[i10];
    let s10 = 1 == e10.length && e10[0] instanceof tB ? e10 : 1 == e10.length && Array.isArray(e10[0]) ? e10[0] : [this.state.update(...e10)];
    this.dispatchTransactions(s10, this);
  }
  update(t107) {
    if (0 != this.updateState) throw Error("Calls to EditorView.update are not allowed while an update is in progress");
    let e10 = false, i10 = false, s10, n10 = this.state;
    for (let e11 of t107) {
      if (e11.startState != n10) throw RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      n10 = e11.state;
    }
    if (this.destroyed) {
      this.viewState.state = n10;
      return;
    }
    let o10 = this.hasFocus, r10 = 0, l10 = null;
    t107.some((t108) => t108.annotation(ln)) ? (this.inputState.notifiedFocused = o10, r10 = 1) : o10 == this.inputState.notifiedFocused || (this.inputState.notifiedFocused = o10, (l10 = lo(n10, o10)) || (r10 = 1));
    let h10 = this.observer.delayedAndroidKey, a10 = null;
    if (h10 ? (this.observer.clearDelayedAndroidKey(), ((a10 = this.observer.readChange()) && !this.state.doc.eq(n10.doc) || !this.state.selection.eq(n10.selection)) && (a10 = null)) : this.observer.clear(), n10.facet(tW.phrases) != this.state.facet(tW.phrases)) return this.setState(n10);
    s10 = rB.create(this, n10, t107), s10.flags |= r10;
    let c10 = this.viewState.scrollTarget;
    try {
      for (let e11 of (this.updateState = 2, t107)) {
        if (c10 && (c10 = c10.map(e11.changes)), e11.scrollIntoView) {
          let { main: t108 } = e11.state.selection;
          c10 = new ru(t108.empty ? t108 : ti.cursor(t108.head, t108.head > t108.anchor ? -1 : 1));
        }
        for (let t108 of e11.effects) t108.is(rf) && (c10 = t108.value.clip(this.state));
      }
      this.viewState.update(s10, c10), this.bidiCache = lQ.update(this.bidiCache, s10.changes), s10.empty || (this.updatePlugins(s10), this.inputState.update(s10)), e10 = this.docView.update(s10), this.state.facet(rE) != this.styleModules && this.mountStyles(), i10 = this.updateAttrs(), this.showAnnouncements(t107), this.docView.updateSelection(e10, t107.some((t108) => t108.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (s10.startState.facet(lE) != s10.state.facet(lE) && (this.viewState.mustMeasureContent = true), (e10 || i10 || c10 || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), e10 && this.docViewUpdate(), !s10.empty) for (let t108 of this.state.facet(rr)) try {
      t108(s10);
    } catch (t109) {
      rp(this.state, t109, "update listener");
    }
    (l10 || a10) && Promise.resolve().then(() => {
      l10 && this.state == l10.startState && this.dispatch(l10), a10 && !lz(this, a10) && h10.force && oo(this.contentDOM, h10.key, h10.keyCode);
    });
  }
  setState(t107) {
    if (0 != this.updateState) throw Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = t107;
      return;
    }
    this.updateState = 2;
    let e10 = this.hasFocus;
    try {
      for (let t108 of this.plugins) t108.destroy(this);
      for (let e11 of (this.viewState = new lk(t107), this.plugins = t107.facet(rw).map((t108) => new ry(t108)), this.pluginMap.clear(), this.plugins)) e11.update(this);
      this.docView.destroy(), this.docView = new rL(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    e10 && this.focus(), this.requestMeasure();
  }
  updatePlugins(t107) {
    let e10 = t107.startState.facet(rw), i10 = t107.state.facet(rw);
    if (e10 != i10) {
      let s10 = [];
      for (let n10 of i10) {
        let i11 = e10.indexOf(n10);
        if (i11 < 0) s10.push(new ry(n10));
        else {
          let e11 = this.plugins[i11];
          e11.mustUpdate = t107, s10.push(e11);
        }
      }
      for (let e11 of this.plugins) e11.mustUpdate != t107 && e11.destroy(this);
      this.plugins = s10, this.pluginMap.clear();
    } else for (let e11 of this.plugins) e11.mustUpdate = t107;
    for (let t108 = 0; t108 < this.plugins.length; t108++) this.plugins[t108].update(this);
    e10 != i10 && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let t107 of this.plugins) {
      let e10 = t107.value;
      if (e10 && e10.docViewUpdate) try {
        e10.docViewUpdate(this);
      } catch (t108) {
        rp(this.state, t108, "doc view update listener");
      }
    }
  }
  measure() {
    let t107 = !(arguments.length > 0) || void 0 === arguments[0] || arguments[0];
    if (this.destroyed) return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, t107 && this.observer.forceFlush();
    let e10 = null, i10 = this.scrollDOM, s10 = i10.scrollTop * this.scaleY, { scrollAnchorPos: n10, scrollAnchorHeight: o10 } = this.viewState;
    Math.abs(s10 - this.viewState.scrollTop) > 1 && (o10 = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let t108 = 0; ; t108++) {
        if (o10 < 0) {
          if (ol(i10)) n10 = -1, o10 = this.viewState.heightMap.height;
          else {
            let t109 = this.viewState.scrollAnchorAt(s10);
            n10 = t109.from, o10 = t109.top;
          }
        }
        this.updateState = 1;
        let r10 = this.viewState.measure(this);
        if (!r10 && !this.measureRequests.length && null == this.viewState.scrollTarget) break;
        if (t108 > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let l10 = [];
        4 & r10 || ([this.measureRequests, l10] = [l10, this.measureRequests]);
        let h10 = l10.map((t109) => {
          try {
            return t109.read(this);
          } catch (t110) {
            return rp(this.state, t110), lJ;
          }
        }), a10 = rB.create(this, this.state, []), c10 = false;
        a10.flags |= r10, e10 ? e10.flags |= r10 : e10 = a10, this.updateState = 2, !a10.empty && (this.updatePlugins(a10), this.inputState.update(a10), this.updateAttrs(), (c10 = this.docView.update(a10)) && this.docViewUpdate());
        for (let t109 = 0; t109 < l10.length; t109++) if (h10[t109] != lJ) try {
          let e11 = l10[t109];
          e11.write && e11.write(h10[t109], this);
        } catch (t110) {
          rp(this.state, t110);
        }
        if (c10 && this.docView.updateSelection(true), !a10.viewportChanged && 0 == this.measureRequests.length) {
          if (this.viewState.editorHeight) {
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, o10 = -1;
              continue;
            }
            {
              let t109 = (n10 < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(n10).top) - o10;
              if (t109 > 1 || t109 < -1) {
                s10 += t109, i10.scrollTop = s10 / this.scaleY, o10 = -1;
                continue;
              }
            }
          }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (e10 && !e10.empty) for (let t108 of this.state.facet(rr)) t108(e10);
  }
  get themeClasses() {
    return lB + " " + (this.state.facet(lR) ? lP : lL) + " " + this.state.facet(lE);
  }
  updateAttrs() {
    let t107 = lZ(this, rx, { class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses }), e10 = { spellcheck: "false", autocorrect: "off", autocapitalize: "off", translate: "no", contenteditable: this.state.facet(rm) ? "true" : "false", class: "cm-content", style: `${oO.tabSize}: ${this.state.tabSize}`, role: "textbox", "aria-multiline": "true" };
    this.state.readOnly && (e10["aria-readonly"] = "true"), lZ(this, rS, e10);
    let i10 = this.observer.ignore(() => {
      let i11 = oF(this.contentDOM, this.contentAttrs, e10), s10 = oF(this.dom, this.editorAttrs, t107);
      return i11 || s10;
    });
    return this.editorAttrs = t107, this.contentAttrs = e10, i10;
  }
  showAnnouncements(e10) {
    let i10 = true;
    for (let s10 of e10) for (let e11 of s10.effects) e11.is(t57.announce) && (i10 && (this.announceDOM.textContent = ""), i10 = false, this.announceDOM.appendChild(document.createElement("div")).textContent = e11.value);
  }
  mountStyles() {
    this.styleModules = this.state.facet(rE);
    let e10 = this.state.facet(t57.cspNonce);
    t6.mount(this.root, this.styleModules.concat(lH).reverse(), e10 ? { nonce: e10 } : void 0);
  }
  readMeasured() {
    if (2 == this.updateState) throw Error("Reading the editor layout isn't allowed during an update");
    0 == this.updateState && this.measureScheduled > -1 && this.measure(false);
  }
  requestMeasure(t107) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), t107 && !(this.measureRequests.indexOf(t107) > -1)) {
      if (null != t107.key) {
        for (let e10 = 0; e10 < this.measureRequests.length; e10++) if (this.measureRequests[e10].key === t107.key) {
          this.measureRequests[e10] = t107;
          return;
        }
      }
      this.measureRequests.push(t107);
    }
  }
  plugin(t107) {
    let e10 = this.pluginMap.get(t107);
    return (void 0 === e10 || e10 && e10.spec != t107) && this.pluginMap.set(t107, e10 = this.plugins.find((e11) => e11.spec == t107) || null), e10 && e10.update(this).value;
  }
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  get scaleX() {
    return this.viewState.scaleX;
  }
  get scaleY() {
    return this.viewState.scaleY;
  }
  elementAtHeight(t107) {
    return this.readMeasured(), this.viewState.elementAtHeight(t107);
  }
  lineBlockAtHeight(t107) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(t107);
  }
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  lineBlockAt(t107) {
    return this.viewState.lineBlockAt(t107);
  }
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  moveByChar(t107, e10, i10) {
    return rG(this, t107, rq(this, t107, e10, i10));
  }
  moveByGroup(t107, e10) {
    return rG(this, t107, rq(this, t107, e10, (e11) => {
      var i10;
      let s10, n10;
      return i10 = t107.head, n10 = (s10 = this.state.charCategorizer(i10))(e11), (t108) => {
        let e12 = s10(t108);
        return n10 == tH.Space && (n10 = e12), n10 == e12;
      };
    }));
  }
  visualLineSide(t107, e10) {
    let i10 = this.bidiSpans(t107), s10 = this.textDirectionAt(t107.from), n10 = i10[e10 ? i10.length - 1 : 0];
    return ti.cursor(n10.side(e10, s10) + t107.from, n10.forward(!e10, s10) ? 1 : -1);
  }
  moveToLineBoundary(t107, e10) {
    let i10 = !(arguments.length > 2) || void 0 === arguments[2] || arguments[2];
    return function(t108, e11, i11, s10) {
      let n10 = function(t109, e12) {
        let i12 = t109.lineBlockAt(e12);
        if (Array.isArray(i12.type)) {
          for (let t110 of i12.type) if (t110.to > e12 || t110.to == e12 && (t110.to == i12.to || t110.type == oK.Text)) return t110;
        }
        return i12;
      }(t108, e11.head), o10 = s10 && n10.type == oK.Text && (t108.lineWrapping || n10.widgetLineBreaks) ? t108.coordsAtPos(e11.assoc < 0 && e11.head > n10.from ? e11.head - 1 : e11.head) : null;
      if (o10) {
        let e12 = t108.dom.getBoundingClientRect(), s11 = t108.textDirectionAt(n10.from), r10 = t108.posAtCoords({ x: i11 == (s11 == oQ.LTR) ? e12.right - 1 : e12.left + 1, y: (o10.top + o10.bottom) / 2 });
        if (null != r10) return ti.cursor(r10, i11 ? -1 : 1);
      }
      return ti.cursor(i11 ? n10.to : n10.from, i11 ? -1 : 1);
    }(this, t107, e10, i10);
  }
  moveVertically(t107, e10, i10) {
    return rG(this, t107, function(t108, e11, i11, s10) {
      let n10 = e11.head, o10 = i11 ? 1 : -1;
      if (n10 == (i11 ? t108.state.doc.length : 0)) return ti.cursor(n10, e11.assoc);
      let r10 = e11.goalColumn, l10, h10 = t108.contentDOM.getBoundingClientRect(), a10 = t108.coordsAtPos(n10, e11.assoc || -1), c10 = t108.documentTop;
      if (a10) null == r10 && (r10 = a10.left - h10.left), l10 = o10 < 0 ? a10.top : a10.bottom;
      else {
        let e12 = t108.viewState.lineBlockAt(n10);
        null == r10 && (r10 = Math.min(h10.right - h10.left, t108.defaultCharacterWidth * (n10 - e12.from))), l10 = (o10 < 0 ? e12.top : e12.bottom) + c10;
      }
      let d10 = h10.left + r10, u10 = null != s10 ? s10 : t108.viewState.heightOracle.textHeight >> 1;
      for (let e12 = 0; ; e12 += 10) {
        let i12 = l10 + (u10 + e12) * o10, s11 = rz(t108, { x: d10, y: i12 }, false, o10);
        if (i12 < h10.top || i12 > h10.bottom || (o10 < 0 ? s11 < n10 : s11 > n10)) {
          let e13 = t108.docView.coordsForChar(s11), n11 = !e13 || i12 < e13.top ? -1 : 1;
          return ti.cursor(s11, n11, void 0, r10);
        }
      }
    }(this, t107, e10, i10));
  }
  domAtPos(t107) {
    return this.docView.domAtPos(t107);
  }
  posAtDOM(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    return this.docView.posFromDOM(t107, e10);
  }
  posAtCoords(t107) {
    let e10 = !(arguments.length > 1) || void 0 === arguments[1] || arguments[1];
    return this.readMeasured(), rz(this, t107, e10);
  }
  coordsAtPos(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
    this.readMeasured();
    let i10 = this.docView.coordsAt(t107, e10);
    if (!i10 || i10.left == i10.right) return i10;
    let s10 = this.state.doc.lineAt(t107), n10 = this.bidiSpans(s10);
    return n7(i10, n10[o6.find(n10, t107 - s10.from, -1, e10)].dir == oQ.LTR == e10 > 0);
  }
  coordsForChar(t107) {
    return this.readMeasured(), this.docView.coordsForChar(t107);
  }
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  textDirectionAt(t107) {
    return !this.state.facet(ra) || t107 < this.viewport.from || t107 > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(t107));
  }
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  bidiSpans(t107) {
    if (t107.length > lX) return rt(t107.length);
    let e10 = this.textDirectionAt(t107.from), i10;
    for (let s11 of this.bidiCache) if (s11.from == t107.from && s11.dir == e10 && (s11.fresh || function t108(e11, i11) {
      if (e11.length != i11.length) return false;
      for (let s12 = 0; s12 < e11.length; s12++) {
        let n10 = e11[s12], o10 = i11[s12];
        if (n10.from != o10.from || n10.to != o10.to || n10.direction != o10.direction || !t108(n10.inner, o10.inner)) return false;
      }
      return true;
    }(s11.isolates, i10 = rD(this, t107)))) return s11.order;
    i10 || (i10 = rD(this, t107));
    let s10 = function(t108, e11, i11) {
      if (!t108) return [new o6(0, 0, e11 == o0 ? 1 : 0)];
      if (e11 == oZ && !i11.length && !o5.test(t108)) return rt(t108.length);
      if (i11.length) for (; t108.length > o7.length; ) o7[o7.length] = 256;
      let s11 = [], n10 = e11 == oZ ? 0 : 1;
      return function t109(e12, i12, s12, n11, o10, r10, l10) {
        let h10 = i12 % 2 ? 2 : 1;
        (function(t110, e13, i13, s13, n12) {
          for (let o11 = 0; o11 <= s13.length; o11++) {
            let r11 = o11 ? s13[o11 - 1].to : e13, l11 = o11 < s13.length ? s13[o11].from : i13, h11 = o11 ? 256 : n12;
            for (let e14 = r11, i14 = h11, s14 = h11; e14 < l11; e14++) {
              let n13 = o9(t110.charCodeAt(e14));
              512 == n13 ? n13 = i14 : 8 == n13 && 4 == s14 && (n13 = 16), o7[e14] = 4 == n13 ? 2 : n13, 7 & n13 && (s14 = n13), i14 = n13;
            }
            for (let t111 = r11, e14 = h11, s14 = h11; t111 < l11; t111++) {
              let n13 = o7[t111];
              if (128 == n13) t111 < l11 - 1 && e14 == o7[t111 + 1] && 24 & e14 ? n13 = o7[t111] = e14 : o7[t111] = 256;
              else if (64 == n13) {
                let n14 = t111 + 1;
                for (; n14 < l11 && 64 == o7[n14]; ) n14++;
                let o12 = t111 && 8 == e14 || n14 < i13 && 8 == o7[n14] ? 1 == s14 ? 1 : 8 : 256;
                for (let e15 = t111; e15 < n14; e15++) o7[e15] = o12;
                t111 = n14 - 1;
              } else 8 == n13 && 1 == s14 && (o7[t111] = 1);
              e14 = n13, 7 & n13 && (s14 = n13);
            }
          }
        })(e12, o10, r10, n11, h10), function(t110, e13, i13, s13, n12) {
          let o11 = 1 == n12 ? 2 : 1;
          for (let r11 = 0, l11 = 0, h11 = 0; r11 <= s13.length; r11++) {
            let a10 = r11 ? s13[r11 - 1].to : e13, c10 = r11 < s13.length ? s13[r11].from : i13;
            for (let e14 = a10, i14, s14, r12; e14 < c10; e14++) if (s14 = o3[i14 = t110.charCodeAt(e14)]) {
              if (s14 < 0) {
                for (let t111 = l11 - 3; t111 >= 0; t111 -= 3) if (o4[t111 + 1] == -s14) {
                  let i15 = o4[t111 + 2], s15 = 2 & i15 ? n12 : 4 & i15 ? 1 & i15 ? o11 : n12 : 0;
                  s15 && (o7[e14] = o7[o4[t111]] = s15), l11 = t111;
                  break;
                }
              } else if (189 == o4.length) break;
              else o4[l11++] = e14, o4[l11++] = i14, o4[l11++] = h11;
            } else if (2 == (r12 = o7[e14]) || 1 == r12) {
              let t111 = r12 == n12;
              h11 = t111 ? 0 : 1;
              for (let e15 = l11 - 3; e15 >= 0; e15 -= 3) {
                let i15 = o4[e15 + 2];
                if (2 & i15) break;
                if (t111) o4[e15 + 2] |= 2;
                else {
                  if (4 & i15) break;
                  o4[e15 + 2] |= 4;
                }
              }
            }
          }
        }(e12, o10, r10, n11, h10), function(t110, e13, i13, s13) {
          for (let n12 = 0, o11 = s13; n12 <= i13.length; n12++) {
            let r11 = n12 ? i13[n12 - 1].to : t110, l11 = n12 < i13.length ? i13[n12].from : e13;
            for (let h11 = r11; h11 < l11; ) {
              let r12 = o7[h11];
              if (256 == r12) {
                let r13 = h11 + 1;
                for (; ; ) if (r13 == l11) {
                  if (n12 == i13.length) break;
                  r13 = i13[n12++].to, l11 = n12 < i13.length ? i13[n12].from : e13;
                } else if (256 == o7[r13]) r13++;
                else break;
                let a10 = 1 == o11, c10 = a10 == ((r13 < e13 ? o7[r13] : s13) == 1) ? a10 ? 1 : 2 : s13;
                for (let e14 = r13, s14 = n12, o12 = s14 ? i13[s14 - 1].to : t110; e14 > h11; ) e14 == o12 && (e14 = i13[--s14].from, o12 = s14 ? i13[s14 - 1].to : t110), o7[--e14] = c10;
                h11 = r13;
              } else o11 = r12, h11++;
            }
          }
        }(o10, r10, n11, h10), function e13(i13, s13, n12, o11, r11, l11, h11) {
          let a10 = o11 % 2 ? 2 : 1;
          if (o11 % 2 == r11 % 2) for (let c10 = s13, d10 = 0; c10 < n12; ) {
            let s14 = true, u10 = false;
            if (d10 == l11.length || c10 < l11[d10].from) {
              let t110 = o7[c10];
              t110 != a10 && (s14 = false, u10 = 16 == t110);
            }
            let f10 = s14 || 1 != a10 ? null : [], g10 = s14 ? o11 : o11 + 1, p10 = c10;
            e: for (; ; ) if (d10 < l11.length && p10 == l11[d10].from) {
              if (u10) break;
              let e14 = l11[d10];
              if (!s14) for (let t110 = e14.to, i14 = d10 + 1; ; ) {
                if (t110 == n12) break e;
                if (i14 < l11.length && l11[i14].from == t110) t110 = l11[i14++].to;
                else if (o7[t110] == a10) break e;
                else break;
              }
              d10++, f10 ? f10.push(e14) : (e14.from > c10 && h11.push(new o6(c10, e14.from, g10)), t109(i13, e14.direction == oZ != !(g10 % 2) ? o11 + 1 : o11, r11, e14.inner, e14.from, e14.to, h11), c10 = e14.to), p10 = e14.to;
            } else if (p10 == n12 || (s14 ? o7[p10] != a10 : o7[p10] == a10)) break;
            else p10++;
            f10 ? e13(i13, c10, p10, o11 + 1, r11, f10, h11) : c10 < p10 && h11.push(new o6(c10, p10, g10)), c10 = p10;
          }
          else for (let c10 = n12, d10 = l11.length; c10 > s13; ) {
            let n13 = true, u10 = false;
            if (!d10 || c10 > l11[d10 - 1].to) {
              let t110 = o7[c10 - 1];
              t110 != a10 && (n13 = false, u10 = 16 == t110);
            }
            let f10 = n13 || 1 != a10 ? null : [], g10 = n13 ? o11 : o11 + 1, p10 = c10;
            e: for (; ; ) if (d10 && p10 == l11[d10 - 1].to) {
              if (u10) break;
              let e14 = l11[--d10];
              if (!n13) for (let t110 = e14.from, i14 = d10; ; ) {
                if (t110 == s13) break e;
                if (i14 && l11[i14 - 1].to == t110) t110 = l11[--i14].from;
                else if (o7[t110 - 1] == a10) break e;
                else break;
              }
              f10 ? f10.push(e14) : (e14.to < c10 && h11.push(new o6(e14.to, c10, g10)), t109(i13, e14.direction == oZ != !(g10 % 2) ? o11 + 1 : o11, r11, e14.inner, e14.from, e14.to, h11), c10 = e14.from), p10 = e14.from;
            } else if (p10 == s13 || (n13 ? o7[p10 - 1] != a10 : o7[p10 - 1] == a10)) break;
            else p10--;
            f10 ? e13(i13, p10, c10, o11 + 1, r11, f10, h11) : p10 < c10 && h11.push(new o6(p10, c10, g10)), c10 = p10;
          }
        }(e12, o10, r10, i12, s12, n11, l10);
      }(t108, n10, n10, i11, 0, t108.length, s11), s11;
    }(t107.text, e10, i10);
    return this.bidiCache.push(new lQ(t107.from, t107.to, e10, i10, true, s10)), s10;
  }
  get hasFocus() {
    var t107;
    return (this.dom.ownerDocument.hasFocus() || oO.safari && (null === (t107 = this.inputState) || void 0 === t107 ? void 0 : t107.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  focus() {
    this.observer.ignore(() => {
      os(this.contentDOM), this.docView.updateSelection();
    });
  }
  setRoot(t107) {
    this._root != t107 && (this._root = t107, this.observer.setWindow((9 == t107.nodeType ? t107 : t107.ownerDocument).defaultView || window), this.mountStyles());
  }
  destroy() {
    for (let t107 of (this.root.activeElement == this.contentDOM && this.contentDOM.blur(), this.plugins)) t107.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = true;
  }
  static scrollIntoView(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return rf.of(new ru("number" == typeof t107 ? ti.cursor(t107) : t107, e10.y, e10.x, e10.yMargin, e10.xMargin));
  }
  scrollSnapshot() {
    let { scrollTop: t107, scrollLeft: e10 } = this.scrollDOM, i10 = this.viewState.scrollAnchorAt(t107);
    return rf.of(new ru(ti.cursor(i10.from), "start", "start", i10.top - t107, e10, true));
  }
  setTabFocusMode(t107) {
    null == t107 ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : "boolean" == typeof t107 ? this.inputState.tabFocusMode = t107 ? 0 : -1 : 0 != this.inputState.tabFocusMode && (this.inputState.tabFocusMode = Date.now() + t107);
  }
  static domEventHandlers(t107) {
    return rb.define(() => ({}), { eventHandlers: t107 });
  }
  static domEventObservers(t107) {
    return rb.define(() => ({}), { eventObservers: t107 });
  }
  static theme(t107, e10) {
    let i10 = t6.newName(), s10 = [lE.of(i10), rE.of(lV(`.${i10}`, t107))];
    return e10 && e10.dark && s10.push(lR.of(true)), s10;
  }
  static baseTheme(t107) {
    return tg.lowest(rE.of(lV("." + lB, t107, lN)));
  }
  static findFromDOM(t107) {
    var e10;
    let i10 = t107.querySelector(".cm-content"), s10 = i10 && ou.get(i10) || ou.get(t107);
    return (null === (e10 = null == s10 ? void 0 : s10.rootView) || void 0 === e10 ? void 0 : e10.view) || null;
  }
};
l$.styleModule = rE, l$.inputHandler = rl, l$.scrollHandler = rd, l$.focusChangeEffect = rh, l$.perLineTextDirection = ra, l$.exceptionSink = ro, l$.updateListener = rr, l$.editable = rm, l$.mouseSelectionStyle = rn, l$.dragMovesSelection = rs, l$.clickAddsSelectionRange = ri, l$.decorations = rk, l$.outerDecorations = rM, l$.atomicRanges = rC, l$.bidiIsolatedRanges = rA, l$.scrollMargins = rO, l$.darkTheme = lR, l$.cspNonce = to.define({ combine: (t107) => t107.length ? t107[0] : "" }), l$.contentAttributes = rS, l$.editorAttributes = rx, l$.lineWrapping = l$.contentAttributes.of({ class: "cm-lineWrapping" }), l$.announce = tR.define();
let lX = 4096, lJ = {}, lQ = class t58 {
  constructor(t107, e10, i10, s10, n10, o10) {
    this.from = t107, this.to = e10, this.dir = i10, this.isolates = s10, this.fresh = n10, this.order = o10;
  }
  static update(e10, i10) {
    if (i10.empty && !e10.some((t107) => t107.fresh)) return e10;
    let s10 = [], n10 = e10.length ? e10[e10.length - 1].dir : oQ.LTR;
    for (let o10 = Math.max(0, e10.length - 10); o10 < e10.length; o10++) {
      let r10 = e10[o10];
      r10.dir != n10 || i10.touchesRange(r10.from, r10.to) || s10.push(new t58(i10.mapPos(r10.from, 1), i10.mapPos(r10.to, -1), r10.dir, r10.isolates, false, r10.order));
    }
    return s10;
  }
};
function lZ(t107, e10, i10) {
  for (let s10 = t107.state.facet(e10), n10 = s10.length - 1; n10 >= 0; n10--) {
    let e11 = s10[n10], o10 = "function" == typeof e11 ? e11(t107) : e11;
    o10 && oN(o10, i10);
  }
  return i10;
}
let l0 = !oO.ios, l1 = { ".cm-line": { "& ::selection, &::selection": { backgroundColor: "transparent !important" } }, ".cm-content": { "& :focus": { caretColor: "initial !important", "&::selection, & ::selection": { backgroundColor: "Highlight !important" } } } };
l0 && (l1[".cm-line"].caretColor = l1[".cm-content"].caretColor = "transparent !important");
let l2 = "-10000px", l8 = class {
  constructor(t107, e10, i10, s10) {
    this.facet = e10, this.createTooltipView = i10, this.removeTooltipView = s10, this.input = t107.state.facet(e10), this.tooltips = this.input.filter((t108) => t108);
    let n10 = null;
    this.tooltipViews = this.tooltips.map((t108) => n10 = i10(t108, n10));
  }
  update(t107, e10) {
    var i10;
    let s10 = t107.state.facet(this.facet), n10 = s10.filter((t108) => t108);
    if (s10 === this.input) {
      for (let e11 of this.tooltipViews) e11.update && e11.update(t107);
      return false;
    }
    let o10 = [], r10 = e10 ? [] : null;
    for (let i11 = 0; i11 < n10.length; i11++) {
      let s11 = n10[i11], l10 = -1;
      if (s11) {
        for (let t108 = 0; t108 < this.tooltips.length; t108++) {
          let e11 = this.tooltips[t108];
          e11 && e11.create == s11.create && (l10 = t108);
        }
        if (l10 < 0) o10[i11] = this.createTooltipView(s11, i11 ? o10[i11 - 1] : null), r10 && (r10[i11] = !!s11.above);
        else {
          let s12 = o10[i11] = this.tooltipViews[l10];
          r10 && (r10[i11] = e10[l10]), s12.update && s12.update(t107);
        }
      }
    }
    for (let t108 of this.tooltipViews) 0 > o10.indexOf(t108) && (this.removeTooltipView(t108), null === (i10 = t108.destroy) || void 0 === i10 || i10.call(t108));
    return e10 && (r10.forEach((t108, i11) => e10[i11] = t108), e10.length = r10.length), this.input = s10, this.tooltips = n10, this.tooltipViews = o10, true;
  }
};
function l3(t107) {
  let { win: e10 } = t107;
  return { top: 0, left: 0, bottom: e10.innerHeight, right: e10.innerWidth };
}
let l4 = to.define({ combine: (t107) => {
  var e10, i10, s10;
  return { position: oO.ios ? "absolute" : (null === (e10 = t107.find((t108) => t108.position)) || void 0 === e10 ? void 0 : e10.position) || "fixed", parent: (null === (i10 = t107.find((t108) => t108.parent)) || void 0 === i10 ? void 0 : i10.parent) || null, tooltipSpace: (null === (s10 = t107.find((t108) => t108.tooltipSpace)) || void 0 === s10 ? void 0 : s10.tooltipSpace) || l3 };
} }), l9 = /* @__PURE__ */ new WeakMap(), l5 = rb.fromClass(class {
  constructor(t107) {
    this.view = t107, this.above = [], this.inView = true, this.madeAbsolute = false, this.lastTransaction = 0, this.measureTimeout = -1;
    let e10 = t107.state.facet(l4);
    this.position = e10.position, this.parent = e10.parent, this.classes = t107.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = "function" == typeof ResizeObserver ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new l8(t107, ht, (t108, e11) => this.createTooltip(t108, e11), (t108) => {
      this.resizeObserver && this.resizeObserver.unobserve(t108.dom), t108.dom.remove();
    }), this.above = this.manager.tooltips.map((t108) => !!t108.above), this.intersectionObserver = "function" == typeof IntersectionObserver ? new IntersectionObserver((t108) => {
      Date.now() > this.lastTransaction - 50 && t108.length > 0 && t108[t108.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), t107.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) for (let t107 of (this.intersectionObserver.disconnect(), this.manager.tooltipViews)) this.intersectionObserver.observe(t107.dom);
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(t107) {
    t107.transactions.length && (this.lastTransaction = Date.now());
    let e10 = this.manager.update(t107, this.above);
    e10 && this.observeIntersection();
    let i10 = e10 || t107.geometryChanged, s10 = t107.state.facet(l4);
    if (s10.position != this.position && !this.madeAbsolute) {
      for (let t108 of (this.position = s10.position, this.manager.tooltipViews)) t108.dom.style.position = this.position;
      i10 = true;
    }
    if (s10.parent != this.parent) {
      for (let t108 of (this.parent && this.container.remove(), this.parent = s10.parent, this.createContainer(), this.manager.tooltipViews)) this.container.appendChild(t108.dom);
      i10 = true;
    } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    i10 && this.maybeMeasure();
  }
  createTooltip(t107, e10) {
    let i10 = t107.create(this.view), s10 = e10 ? e10.dom : null;
    if (i10.dom.classList.add("cm-tooltip"), t107.arrow && !i10.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let t108 = document.createElement("div");
      t108.className = "cm-tooltip-arrow", i10.dom.appendChild(t108);
    }
    return i10.dom.style.position = this.position, i10.dom.style.top = l2, i10.dom.style.left = "0px", this.container.insertBefore(i10.dom, s10), i10.mount && i10.mount(this.view), this.resizeObserver && this.resizeObserver.observe(i10.dom), i10;
  }
  destroy() {
    var t107, e10, i10;
    for (let e11 of (this.view.win.removeEventListener("resize", this.measureSoon), this.manager.tooltipViews)) e11.dom.remove(), null === (t107 = e11.destroy) || void 0 === t107 || t107.call(e11);
    this.parent && this.container.remove(), null === (e10 = this.resizeObserver) || void 0 === e10 || e10.disconnect(), null === (i10 = this.intersectionObserver) || void 0 === i10 || i10.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let t107 = this.view.dom.getBoundingClientRect(), e10 = 1, i10 = 1, s10 = false;
    if ("fixed" == this.position && this.manager.tooltipViews.length) {
      let { dom: t108 } = this.manager.tooltipViews[0];
      if (oO.gecko) s10 = t108.offsetParent != this.container.ownerDocument.body;
      else if (t108.style.top == l2 && "0px" == t108.style.left) {
        let e11 = t108.getBoundingClientRect();
        s10 = Math.abs(e11.top + 1e4) > 1 || Math.abs(e11.left) > 1;
      }
    }
    if (s10 || "absolute" == this.position) {
      if (this.parent) {
        let t108 = this.parent.getBoundingClientRect();
        t108.width && t108.height && (e10 = t108.width / this.parent.offsetWidth, i10 = t108.height / this.parent.offsetHeight);
      } else ({ scaleX: e10, scaleY: i10 } = this.view.viewState);
    }
    return { editor: t107, parent: this.parent ? this.container.getBoundingClientRect() : t107, pos: this.manager.tooltips.map((t108, e11) => {
      let i11 = this.manager.tooltipViews[e11];
      return i11.getCoords ? i11.getCoords(t108.pos) : this.view.coordsAtPos(t108.pos);
    }), size: this.manager.tooltipViews.map((t108) => {
      let { dom: e11 } = t108;
      return e11.getBoundingClientRect();
    }), space: this.view.state.facet(l4).tooltipSpace(this.view), scaleX: e10, scaleY: i10, makeAbsolute: s10 };
  }
  writeMeasure(t107) {
    var e10;
    if (t107.makeAbsolute) for (let t108 of (this.madeAbsolute = true, this.position = "absolute", this.manager.tooltipViews)) t108.dom.style.position = "absolute";
    let { editor: i10, space: s10, scaleX: n10, scaleY: o10 } = t107, r10 = [];
    for (let l10 = 0; l10 < this.manager.tooltips.length; l10++) {
      let h10 = this.manager.tooltips[l10], a10 = this.manager.tooltipViews[l10], { dom: c10 } = a10, d10 = t107.pos[l10], u10 = t107.size[l10];
      if (!d10 || d10.bottom <= Math.max(i10.top, s10.top) || d10.top >= Math.min(i10.bottom, s10.bottom) || d10.right < Math.max(i10.left, s10.left) - 0.1 || d10.left > Math.min(i10.right, s10.right) + 0.1) {
        c10.style.top = l2;
        continue;
      }
      let f10 = h10.arrow ? a10.dom.querySelector(".cm-tooltip-arrow") : null, g10 = f10 ? 7 : 0, p10 = u10.right - u10.left, m10 = null !== (e10 = l9.get(a10)) && void 0 !== e10 ? e10 : u10.bottom - u10.top, v10 = a10.offset || l7, w10 = this.view.textDirection == oQ.LTR, b10 = u10.width > s10.right - s10.left ? w10 ? s10.left : s10.right - u10.width : w10 ? Math.min(d10.left - (f10 ? 14 : 0) + v10.x, s10.right - p10) : Math.max(s10.left, d10.left - p10 + (f10 ? 14 : 0) - v10.x), y10 = this.above[l10];
      !h10.strictSide && (y10 ? d10.top - (u10.bottom - u10.top) - v10.y < s10.top : d10.bottom + (u10.bottom - u10.top) + v10.y > s10.bottom) && y10 == s10.bottom - d10.bottom > d10.top - s10.top && (y10 = this.above[l10] = !y10);
      let x10 = (y10 ? d10.top - s10.top : s10.bottom - d10.bottom) - g10;
      if (x10 < m10 && false !== a10.resize) {
        if (x10 < this.view.defaultLineHeight) {
          c10.style.top = l2;
          continue;
        }
        l9.set(a10, m10), c10.style.height = (m10 = x10) / o10 + "px";
      } else c10.style.height && (c10.style.height = "");
      let S2 = y10 ? d10.top - m10 - g10 - v10.y : d10.bottom + g10 + v10.y, k2 = b10 + p10;
      if (true !== a10.overlap) for (let t108 of r10) t108.left < k2 && t108.right > b10 && t108.top < S2 + m10 && t108.bottom > S2 && (S2 = y10 ? t108.top - m10 - 2 - g10 : t108.bottom + g10 + 2);
      if ("absolute" == this.position ? (c10.style.top = (S2 - t107.parent.top) / o10 + "px", c10.style.left = (b10 - t107.parent.left) / n10 + "px") : (c10.style.top = S2 / o10 + "px", c10.style.left = b10 / n10 + "px"), f10) {
        let t108 = d10.left + (w10 ? v10.x : -v10.x) - (b10 + 14 - 7);
        f10.style.left = t108 / n10 + "px";
      }
      true !== a10.overlap && r10.push({ left: b10, top: S2, right: k2, bottom: S2 + m10 }), c10.classList.toggle("cm-tooltip-above", y10), c10.classList.toggle("cm-tooltip-below", !y10), a10.positioned && a10.positioned(t107.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView))) for (let t107 of this.manager.tooltipViews) t107.dom.style.top = l2;
  }
}, { eventObservers: { scroll() {
  this.maybeMeasure();
} } }), l6 = l$.baseTheme({ ".cm-tooltip": { zIndex: 100, boxSizing: "border-box" }, "&light .cm-tooltip": { border: "1px solid #bbb", backgroundColor: "#f5f5f5" }, "&light .cm-tooltip-section:not(:first-child)": { borderTop: "1px solid #bbb" }, "&dark .cm-tooltip": { backgroundColor: "#333338", color: "white" }, ".cm-tooltip-arrow": { height: "7px", width: "14px", position: "absolute", zIndex: -1, overflow: "hidden", "&:before, &:after": { content: "''", position: "absolute", width: 0, height: 0, borderLeft: "7px solid transparent", borderRight: "7px solid transparent" }, ".cm-tooltip-above &": { bottom: "-7px", "&:before": { borderTop: "7px solid #bbb" }, "&:after": { borderTop: "7px solid #f5f5f5", bottom: "1px" } }, ".cm-tooltip-below &": { top: "-7px", "&:before": { borderBottom: "7px solid #bbb" }, "&:after": { borderBottom: "7px solid #f5f5f5", top: "1px" } } }, "&dark .cm-tooltip .cm-tooltip-arrow": { "&:before": { borderTopColor: "#333338", borderBottomColor: "#333338" }, "&:after": { borderTopColor: "transparent", borderBottomColor: "transparent" } } }), l7 = { x: 0, y: 0 }, ht = to.define({ enables: [l5, l6] }), he = to.define({ combine: (t107) => t107.reduce((t108, e10) => t108.concat(e10), []) });
class hi {
  static create(t107) {
    return new hi(t107);
  }
  constructor(t107) {
    this.view = t107, this.mounted = false, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new l8(t107, he, (t108, e10) => this.createHostedView(t108, e10), (t108) => t108.dom.remove());
  }
  createHostedView(t107, e10) {
    let i10 = t107.create(this.view);
    return i10.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(i10.dom, e10 ? e10.dom.nextSibling : this.dom.firstChild), this.mounted && i10.mount && i10.mount(this.view), i10;
  }
  mount(t107) {
    for (let e10 of this.manager.tooltipViews) e10.mount && e10.mount(t107);
    this.mounted = true;
  }
  positioned(t107) {
    for (let e10 of this.manager.tooltipViews) e10.positioned && e10.positioned(t107);
  }
  update(t107) {
    this.manager.update(t107);
  }
  destroy() {
    var t107;
    for (let e10 of this.manager.tooltipViews) null === (t107 = e10.destroy) || void 0 === t107 || t107.call(e10);
  }
  passProp(t107) {
    let e10;
    for (let i10 of this.manager.tooltipViews) {
      let s10 = i10[t107];
      if (void 0 !== s10) {
        if (void 0 === e10) e10 = s10;
        else if (e10 !== s10) return;
      }
    }
    return e10;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
let hs = ht.compute([he], (t107) => {
  let e10 = t107.facet(he);
  return 0 === e10.length ? null : { pos: Math.min(...e10.map((t108) => t108.pos)), end: Math.max(...e10.map((t108) => {
    var e11;
    return null !== (e11 = t108.end) && void 0 !== e11 ? e11 : t108.pos;
  })), create: hi.create, above: e10[0].above, arrow: e10.some((t108) => t108.arrow) };
});
class hn {
  constructor(t107, e10, i10, s10, n10) {
    this.view = t107, this.source = e10, this.field = i10, this.setHover = s10, this.hoverTime = n10, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: t107.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), t107.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), t107.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length) return;
    let t107 = Date.now() - this.lastMove.time;
    t107 < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - t107) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: t107, lastMove: e10 } = this, i10 = t107.docView.nearest(e10.target);
    if (!i10) return;
    let s10, n10 = 1;
    if (i10 instanceof oR) s10 = i10.posAtStart;
    else {
      if (null == (s10 = t107.posAtCoords(e10))) return;
      let i11 = t107.coordsAtPos(s10);
      if (!i11 || e10.y < i11.top || e10.y > i11.bottom || e10.x < i11.left - t107.defaultCharacterWidth || e10.x > i11.right + t107.defaultCharacterWidth) return;
      let o11 = t107.bidiSpans(t107.state.doc.lineAt(s10)).find((t108) => t108.from <= s10 && t108.to >= s10), r10 = o11 && o11.dir == oQ.RTL ? -1 : 1;
      n10 = e10.x < i11.left ? -r10 : r10;
    }
    let o10 = this.source(t107, s10, n10);
    if (null == o10 ? void 0 : o10.then) {
      let e11 = this.pending = { pos: s10 };
      o10.then((i11) => {
        this.pending == e11 && (this.pending = null, i11 && !(Array.isArray(i11) && !i11.length) && t107.dispatch({ effects: this.setHover.of(Array.isArray(i11) ? i11 : [i11]) }));
      }, (e12) => rp(t107.state, e12, "hover tooltip"));
    } else o10 && !(Array.isArray(o10) && !o10.length) && t107.dispatch({ effects: this.setHover.of(Array.isArray(o10) ? o10 : [o10]) });
  }
  get tooltip() {
    let t107 = this.view.plugin(l5), e10 = t107 ? t107.manager.tooltips.findIndex((t108) => t108.create == hi.create) : -1;
    return e10 > -1 ? t107.manager.tooltipViews[e10] : null;
  }
  mousemove(t107) {
    var e10, i10;
    let s10;
    this.lastMove = { x: t107.clientX, y: t107.clientY, target: t107.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: n10, tooltip: o10 } = this;
    if (n10.length && o10 && (s10 = o10.dom.getBoundingClientRect(), !(t107.clientX >= s10.left - 4) || !(t107.clientX <= s10.right + 4) || !(t107.clientY >= s10.top - 4) || !(t107.clientY <= s10.bottom + 4)) || this.pending) {
      let { pos: s11 } = n10[0] || this.pending, o11 = null !== (i10 = null === (e10 = n10[0]) || void 0 === e10 ? void 0 : e10.end) && void 0 !== i10 ? i10 : s11;
      (s11 == o11 ? this.view.posAtCoords(this.lastMove) != s11 : !function(t108, e11, i11, s12, n11, o12) {
        let r10 = t108.scrollDOM.getBoundingClientRect(), l10 = t108.documentTop + t108.documentPadding.top + t108.contentHeight;
        if (r10.left > s12 || r10.right < s12 || r10.top > n11 || Math.min(r10.bottom, l10) < n11) return false;
        let h10 = t108.posAtCoords({ x: s12, y: n11 }, false);
        return h10 >= e11 && h10 <= i11;
      }(this.view, s11, o11, t107.clientX, t107.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(t107) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: e10 } = this;
    if (e10.length) {
      let { tooltip: e11 } = this;
      e11 && e11.dom.contains(t107.relatedTarget) ? this.watchTooltipLeave(e11.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(t107) {
    let e10 = (i10) => {
      t107.removeEventListener("mouseleave", e10), this.active.length && !this.view.dom.contains(i10.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    t107.addEventListener("mouseleave", e10);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
let ho = tR.define(), hr = to.define({ combine(t107) {
  let e10, i10;
  for (let s10 of t107) e10 = e10 || s10.topContainer, i10 = i10 || s10.bottomContainer;
  return { topContainer: e10, bottomContainer: i10 };
} }), hl = rb.fromClass(class {
  constructor(t107) {
    this.input = t107.state.facet(hc), this.specs = this.input.filter((t108) => t108), this.panels = this.specs.map((e11) => e11(t107));
    let e10 = t107.state.facet(hr);
    for (let i10 of (this.top = new hh(t107, true, e10.topContainer), this.bottom = new hh(t107, false, e10.bottomContainer), this.top.sync(this.panels.filter((t108) => t108.top)), this.bottom.sync(this.panels.filter((t108) => !t108.top)), this.panels)) i10.dom.classList.add("cm-panel"), i10.mount && i10.mount();
  }
  update(t107) {
    let e10 = t107.state.facet(hr);
    this.top.container != e10.topContainer && (this.top.sync([]), this.top = new hh(t107.view, true, e10.topContainer)), this.bottom.container != e10.bottomContainer && (this.bottom.sync([]), this.bottom = new hh(t107.view, false, e10.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let i10 = t107.state.facet(hc);
    if (i10 != this.input) {
      let e11 = i10.filter((t108) => t108), s10 = [], n10 = [], o10 = [], r10 = [];
      for (let i11 of e11) {
        let e12 = this.specs.indexOf(i11), l10;
        e12 < 0 ? (l10 = i11(t107.view), r10.push(l10)) : (l10 = this.panels[e12]).update && l10.update(t107), s10.push(l10), (l10.top ? n10 : o10).push(l10);
      }
      for (let t108 of (this.specs = e11, this.panels = s10, this.top.sync(n10), this.bottom.sync(o10), r10)) t108.dom.classList.add("cm-panel"), t108.mount && t108.mount();
    } else for (let e11 of this.panels) e11.update && e11.update(t107);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, { provide: (t107) => l$.scrollMargins.of((e10) => {
  let i10 = e10.plugin(t107);
  return i10 && { top: i10.top.scrollMargin(), bottom: i10.bottom.scrollMargin() };
}) });
class hh {
  constructor(t107, e10, i10) {
    this.view = t107, this.top = e10, this.container = i10, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(t107) {
    for (let e10 of this.panels) e10.destroy && 0 > t107.indexOf(e10) && e10.destroy();
    this.panels = t107, this.syncDOM();
  }
  syncDOM() {
    if (0 == this.panels.length) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let t108 = this.container || this.view.dom;
      t108.insertBefore(this.dom, this.top ? t108.firstChild : null);
    }
    let t107 = this.dom.firstChild;
    for (let e10 of this.panels) if (e10.dom.parentNode == this.dom) {
      for (; t107 != e10.dom; ) t107 = ha(t107);
      t107 = t107.nextSibling;
    } else this.dom.insertBefore(e10.dom, t107);
    for (; t107; ) t107 = ha(t107);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (this.container && this.classes != this.view.themeClasses) {
      for (let t107 of this.classes.split(" ")) t107 && this.container.classList.remove(t107);
      for (let t107 of (this.classes = this.view.themeClasses).split(" ")) t107 && this.container.classList.add(t107);
    }
  }
}
function ha(t107) {
  let e10 = t107.nextSibling;
  return t107.remove(), e10;
}
let hc = to.define({ enables: hl }), hd = class extends tz {
  compare(t107) {
    return this == t107 || this.constructor == t107.constructor && this.eq(t107);
  }
  eq(t107) {
    return false;
  }
  destroy(t107) {
  }
};
hd.prototype.elementClass = "", hd.prototype.toDOM = void 0, hd.prototype.mapMode = j.TrackBefore, hd.prototype.startSide = hd.prototype.endSide = -1, hd.prototype.point = true;
let hu = to.define(), hf = to.define(), hg = to.define({ combine: (t107) => t107.some((t108) => t108) }), hp = rb.fromClass(class {
  constructor(t107) {
    for (let e10 of (this.view = t107, this.prevViewport = t107.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = t107.state.facet(hf).map((e11) => new hb(t107, e11)), this.gutters)) this.dom.appendChild(e10.dom);
    this.fixed = !t107.state.facet(hg), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(false), t107.scrollDOM.insertBefore(this.dom, t107.contentDOM);
  }
  update(t107) {
    if (this.updateGutters(t107)) {
      let e10 = this.prevViewport, i10 = t107.view.viewport, s10 = Math.min(e10.to, i10.to) - Math.max(e10.from, i10.from);
      this.syncGutters(s10 < (i10.to - i10.from) * 0.8);
    }
    t107.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px"), this.view.state.facet(hg) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = t107.view.viewport;
  }
  syncGutters(t107) {
    let e10 = this.dom.nextSibling;
    t107 && this.dom.remove();
    let i10 = tG.iter(this.view.state.facet(hu), this.view.viewport.from), s10 = [], n10 = this.gutters.map((t108) => new hw(t108, this.view.viewport, -this.view.documentPadding.top));
    for (let t108 of this.view.viewportLineBlocks) if (s10.length && (s10 = []), Array.isArray(t108.type)) {
      let e11 = true;
      for (let o10 of t108.type) if (o10.type == oK.Text && e11) {
        for (let t109 of (hv(i10, s10, o10.from), n10)) t109.line(this.view, o10, s10);
        e11 = false;
      } else if (o10.widget) for (let t109 of n10) t109.widget(this.view, o10);
    } else if (t108.type == oK.Text) for (let e11 of (hv(i10, s10, t108.from), n10)) e11.line(this.view, t108, s10);
    else if (t108.widget) for (let e11 of n10) e11.widget(this.view, t108);
    for (let t108 of n10) t108.finish();
    t107 && this.view.scrollDOM.insertBefore(this.dom, e10);
  }
  updateGutters(t107) {
    let e10 = t107.startState.facet(hf), i10 = t107.state.facet(hf), s10 = t107.docChanged || t107.heightChanged || t107.viewportChanged || !tG.eq(t107.startState.facet(hu), t107.state.facet(hu), t107.view.viewport.from, t107.view.viewport.to);
    if (e10 == i10) for (let e11 of this.gutters) e11.update(t107) && (s10 = true);
    else {
      s10 = true;
      let n10 = [];
      for (let s11 of i10) {
        let i11 = e10.indexOf(s11);
        i11 < 0 ? n10.push(new hb(this.view, s11)) : (this.gutters[i11].update(t107), n10.push(this.gutters[i11]));
      }
      for (let t108 of this.gutters) t108.dom.remove(), 0 > n10.indexOf(t108) && t108.destroy();
      for (let t108 of n10) this.dom.appendChild(t108.dom);
      this.gutters = n10;
    }
    return s10;
  }
  destroy() {
    for (let t107 of this.gutters) t107.destroy();
    this.dom.remove();
  }
}, { provide: (t107) => l$.scrollMargins.of((e10) => {
  let i10 = e10.plugin(t107);
  return i10 && 0 != i10.gutters.length && i10.fixed ? e10.textDirection == oQ.LTR ? { left: i10.dom.offsetWidth * e10.scaleX } : { right: i10.dom.offsetWidth * e10.scaleX } : null;
}) });
function hm(t107) {
  return Array.isArray(t107) ? t107 : [t107];
}
function hv(t107, e10, i10) {
  for (; t107.value && t107.from <= i10; ) t107.from == i10 && e10.push(t107.value), t107.next();
}
let hw = class {
  constructor(t107, e10, i10) {
    this.gutter = t107, this.height = i10, this.i = 0, this.cursor = tG.iter(t107.markers, e10.from);
  }
  addElement(t107, e10, i10) {
    let { gutter: s10 } = this, n10 = (e10.top - this.height) / t107.scaleY, o10 = e10.height / t107.scaleY;
    if (this.i == s10.elements.length) {
      let e11 = new hy(t107, o10, n10, i10);
      s10.elements.push(e11), s10.dom.appendChild(e11.dom);
    } else s10.elements[this.i].update(t107, o10, n10, i10);
    this.height = e10.bottom, this.i++;
  }
  line(t107, e10, i10) {
    let s10 = [];
    hv(this.cursor, s10, e10.from), i10.length && (s10 = s10.concat(i10));
    let n10 = this.gutter.config.lineMarker(t107, e10, s10);
    n10 && s10.unshift(n10);
    let o10 = this.gutter;
    (0 != s10.length || o10.config.renderEmptyElements) && this.addElement(t107, e10, s10);
  }
  widget(t107, e10) {
    let i10 = this.gutter.config.widgetMarker(t107, e10.widget, e10);
    i10 && this.addElement(t107, e10, [i10]);
  }
  finish() {
    let t107 = this.gutter;
    for (; t107.elements.length > this.i; ) {
      let e10 = t107.elements.pop();
      t107.dom.removeChild(e10.dom), e10.destroy();
    }
  }
}, hb = class {
  constructor(t107, e10) {
    for (let i10 in this.view = t107, this.config = e10, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : ""), e10.domEventHandlers) this.dom.addEventListener(i10, (s10) => {
      let n10 = s10.target, o10;
      if (n10 != this.dom && this.dom.contains(n10)) {
        for (; n10.parentNode != this.dom; ) n10 = n10.parentNode;
        let t108 = n10.getBoundingClientRect();
        o10 = (t108.top + t108.bottom) / 2;
      } else o10 = s10.clientY;
      let r10 = t107.lineBlockAtHeight(o10 - t107.documentTop);
      e10.domEventHandlers[i10](t107, r10, s10) && s10.preventDefault();
    });
    this.markers = hm(e10.markers(t107)), e10.initialSpacer && (this.spacer = new hy(t107, 0, 0, [e10.initialSpacer(t107)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(t107) {
    let e10 = this.markers;
    if (this.markers = hm(this.config.markers(t107.view)), this.spacer && this.config.updateSpacer) {
      let e11 = this.config.updateSpacer(this.spacer.markers[0], t107);
      e11 != this.spacer.markers[0] && this.spacer.update(t107.view, 0, 0, [e11]);
    }
    let i10 = t107.view.viewport;
    return !tG.eq(this.markers, e10, i10.from, i10.to) || !!this.config.lineMarkerChange && this.config.lineMarkerChange(t107);
  }
  destroy() {
    for (let t107 of this.elements) t107.destroy();
  }
}, hy = class {
  constructor(t107, e10, i10, s10) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(t107, e10, i10, s10);
  }
  update(t107, e10, i10, s10) {
    this.height != e10 && (this.height = e10, this.dom.style.height = e10 + "px"), this.above != i10 && (this.dom.style.marginTop = (this.above = i10) ? i10 + "px" : ""), !function(t108, e11) {
      if (t108.length != e11.length) return false;
      for (let i11 = 0; i11 < t108.length; i11++) if (!t108[i11].compare(e11[i11])) return false;
      return true;
    }(this.markers, s10) && this.setMarkers(t107, s10);
  }
  setMarkers(t107, e10) {
    let i10 = "cm-gutterElement", s10 = this.dom.firstChild;
    for (let n10 = 0, o10 = 0; ; ) {
      let r10 = o10, l10 = n10 < e10.length ? e10[n10++] : null, h10 = false;
      if (l10) {
        let t108 = l10.elementClass;
        t108 && (i10 += " " + t108);
        for (let t109 = o10; t109 < this.markers.length; t109++) if (this.markers[t109].compare(l10)) {
          r10 = t109, h10 = true;
          break;
        }
      } else r10 = this.markers.length;
      for (; o10 < r10; ) {
        let t108 = this.markers[o10++];
        if (t108.toDOM) {
          t108.destroy(s10);
          let e11 = s10.nextSibling;
          s10.remove(), s10 = e11;
        }
      }
      if (!l10) break;
      l10.toDOM && (h10 ? s10 = s10.nextSibling : this.dom.insertBefore(l10.toDOM(t107), s10)), h10 && o10++;
    }
    this.dom.className = i10, this.markers = e10;
  }
  destroy() {
    this.setMarkers(null, []);
  }
};
function hx() {
  var t107 = arguments[0];
  "string" == typeof t107 && (t107 = document.createElement(t107));
  var e10 = 1, i10 = arguments[1];
  if (i10 && "object" == typeof i10 && null == i10.nodeType && !Array.isArray(i10)) {
    for (var s10 in i10) if (Object.prototype.hasOwnProperty.call(i10, s10)) {
      var n10 = i10[s10];
      "string" == typeof n10 ? t107.setAttribute(s10, n10) : null != n10 && (t107[s10] = n10);
    }
    e10++;
  }
  for (; e10 < arguments.length; e10++) !function t108(e11, i11) {
    if ("string" == typeof i11) e11.appendChild(document.createTextNode(i11));
    else if (null == i11) ;
    else if (null != i11.nodeType) e11.appendChild(i11);
    else if (Array.isArray(i11)) for (var s11 = 0; s11 < i11.length; s11++) t108(e11, i11[s11]);
    else throw RangeError("Unsupported child node: " + i11);
  }(t107, arguments[e10]);
  return t107;
}
class hS {
  constructor(t107, e10, i10) {
    this.from = t107, this.to = e10, this.diagnostic = i10;
  }
}
class hk {
  constructor(t107, e10, i10) {
    this.diagnostics = t107, this.panel = e10, this.selected = i10;
  }
  static init(t107, e10, i10) {
    let s10 = t107, n10 = i10.facet(hH).markerFilter;
    n10 && (s10 = n10(s10, i10));
    let o10 = oq.set(s10.map((t108) => t108.from == t108.to || t108.from == t108.to - 1 && i10.doc.lineAt(t108.from).to == t108.from ? oq.widget({ widget: new hK(t108), diagnostic: t108 }).range(t108.from) : oq.mark({ attributes: { class: "cm-lintRange cm-lintRange-" + t108.severity + (t108.markClass ? " " + t108.markClass : "") }, diagnostic: t108 }).range(t108.from, t108.to)), true);
    return new hk(o10, e10, hM(o10));
  }
}
function hM(t107) {
  let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, s10 = null;
  return t107.between(i10, 1e9, (t108, i11, n10) => {
    let { spec: o10 } = n10;
    if (!e10 || o10.diagnostic == e10) return s10 = new hS(t108, i11, o10.diagnostic), false;
  }), s10;
}
function hC(t107, e10) {
  let i10 = e10.pos, s10 = e10.end || i10, n10 = t107.state.facet(hH).hideOn(t107, i10, s10);
  if (null != n10) return n10;
  let o10 = t107.startState.doc.lineAt(e10.pos);
  return !!(t107.effects.some((t108) => t108.is(hD)) || t107.changes.touchesRange(o10.from, Math.max(o10.to, s10)));
}
function hA(t107, e10) {
  return t107.field(hE, false) ? e10 : e10.concat(tR.appendConfig.of(h1));
}
let hD = tR.define(), hO = tR.define(), hT = tR.define(), hE = td.define({ create: () => new hk(oq.none, null, null), update(t107, e10) {
  if (e10.docChanged && t107.diagnostics.size) {
    let i10 = t107.diagnostics.map(e10.changes), s10 = null, n10 = t107.panel;
    if (t107.selected) {
      let n11 = e10.changes.mapPos(t107.selected.from, 1);
      s10 = hM(i10, t107.selected.diagnostic, n11) || hM(i10, null, n11);
    }
    !i10.size && n10 && e10.state.facet(hH).autoPanel && (n10 = null), t107 = new hk(i10, n10, s10);
  }
  for (let i10 of e10.effects) if (i10.is(hD)) {
    let s10 = e10.state.facet(hH).autoPanel ? i10.value.length ? h_.open : null : t107.panel;
    t107 = hk.init(i10.value, s10, e10.state);
  } else i10.is(hO) ? t107 = new hk(t107.diagnostics, i10.value ? h_.open : null, t107.selected) : i10.is(hT) && (t107 = new hk(t107.diagnostics, t107.panel, i10.value));
  return t107;
}, provide: (t107) => [hc.from(t107, (t108) => t108.panel), l$.decorations.from(t107, (t108) => t108.diagnostics)] });
function hR(t107) {
  let e10 = t107.field(hE, false);
  return e10 ? e10.diagnostics.size : 0;
}
let hB = oq.mark({ class: "cm-lintRange cm-lintRange-active" });
function hL(t107, e10) {
  return hx("ul", { class: "cm-tooltip-lint" }, e10.map((e11) => hz(t107, e11, false)));
}
let hP = (t107) => {
  let e10 = t107.state.field(hE, false);
  return !!e10 && !!e10.panel && (t107.dispatch({ effects: hO.of(false) }), true);
}, hN = [{ key: "Mod-Shift-m", run: (t107) => {
  var e10;
  let i10, s10, n10 = t107.state.field(hE, false);
  n10 && n10.panel || t107.dispatch({ effects: hA(t107.state, [hO.of(true)]) });
  let o10 = (e10 = h_.open, (s10 = (i10 = t107.plugin(hl)) ? i10.specs.indexOf(e10) : -1) > -1 ? i10.panels[s10] : null);
  return o10 && o10.dom.querySelector(".cm-panel-lint ul").focus(), true;
}, preventDefault: true }, { key: "F8", run: (t107) => {
  let e10 = t107.state.field(hE, false);
  if (!e10) return false;
  let i10 = t107.state.selection.main, s10 = e10.diagnostics.iter(i10.to + 1);
  return (!!s10.value || !!(s10 = e10.diagnostics.iter(0)).value && (s10.from != i10.from || s10.to != i10.to)) && (t107.dispatch({ selection: { anchor: s10.from, head: s10.to }, scrollIntoView: true }), true);
} }], hV = rb.fromClass(class {
  constructor(t107) {
    this.view = t107, this.timeout = -1, this.set = true;
    let { delay: e10 } = t107.state.facet(hH);
    this.lintTime = Date.now() + e10, this.run = this.run.bind(this), this.timeout = setTimeout(this.run, e10);
  }
  run() {
    clearTimeout(this.timeout);
    let t107 = Date.now();
    if (t107 < this.lintTime - 10) this.timeout = setTimeout(this.run, this.lintTime - t107);
    else {
      this.set = false;
      let { state: t108 } = this.view, { sources: e10 } = t108.facet(hH);
      e10.length && Promise.all(e10.map((t109) => Promise.resolve(t109(this.view)))).then((e11) => {
        let i10 = e11.reduce((t109, e12) => t109.concat(e12));
        this.view.state.doc == t108.doc && this.view.dispatch({ effects: hA(this.view.state, [hD.of(i10)]) });
      }, (t109) => {
        rp(this.view.state, t109);
      });
    }
  }
  update(t107) {
    let e10 = t107.state.facet(hH);
    (t107.docChanged || e10 != t107.startState.facet(hH) || e10.needsRefresh && e10.needsRefresh(t107)) && (this.lintTime = Date.now() + e10.delay, this.set || (this.set = true, this.timeout = setTimeout(this.run, e10.delay)));
  }
  force() {
    this.set && (this.lintTime = Date.now(), this.run());
  }
  destroy() {
    clearTimeout(this.timeout);
  }
}), hH = to.define({ combine: (t107) => Object.assign({ sources: t107.map((t108) => t108.source).filter((t108) => null != t108) }, tI(t107.map((t108) => t108.config), { delay: 750, markerFilter: null, tooltipFilter: null, needsRefresh: null, hideOn: () => null }, { needsRefresh: (t108, e10) => t108 ? e10 ? (i10) => t108(i10) || e10(i10) : t108 : e10 })) });
function hF(t107) {
  let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  return [hH.of({ source: t107, config: e10 }), hV, h1];
}
function hW(t107) {
  let e10 = t107.plugin(hV);
  e10 && e10.force();
}
function hI(t107) {
  let e10 = [];
  if (t107) i: for (let { name: i10 } of t107) {
    for (let t108 = 0; t108 < i10.length; t108++) {
      let s10 = i10[t108];
      if (/[a-zA-Z]/.test(s10) && !e10.some((t109) => t109.toLowerCase() == s10.toLowerCase())) {
        e10.push(s10);
        continue i;
      }
    }
    e10.push("");
  }
  return e10;
}
function hz(t107, e10, i10) {
  var s10;
  let n10 = i10 ? hI(e10.actions) : [];
  return hx("li", { class: "cm-diagnostic cm-diagnostic-" + e10.severity }, hx("span", { class: "cm-diagnosticText" }, e10.renderMessage ? e10.renderMessage(t107) : e10.message), null === (s10 = e10.actions) || void 0 === s10 ? void 0 : s10.map((i11, s11) => {
    let o10 = false, r10 = (s12) => {
      if (s12.preventDefault(), o10) return;
      o10 = true;
      let n11 = hM(t107.state.field(hE).diagnostics, e10);
      n11 && i11.apply(t107, n11.from, n11.to);
    }, { name: l10 } = i11, h10 = n10[s11] ? l10.indexOf(n10[s11]) : -1, a10 = h10 < 0 ? l10 : [l10.slice(0, h10), hx("u", l10.slice(h10, h10 + 1)), l10.slice(h10 + 1)];
    return hx("button", { type: "button", class: "cm-diagnosticAction", onclick: r10, onmousedown: r10, "aria-label": ` Action: ${l10}${h10 < 0 ? "" : ` (access key "${n10[s11]})"`}.` }, a10);
  }), e10.source && hx("div", { class: "cm-diagnosticSource" }, e10.source));
}
class hK extends oz {
  constructor(t107) {
    super(), this.diagnostic = t107;
  }
  eq(t107) {
    return t107.diagnostic == this.diagnostic;
  }
  toDOM() {
    return hx("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
}
class hq {
  constructor(t107, e10) {
    this.diagnostic = e10, this.id = "item_" + Math.floor(4294967295 * Math.random()).toString(16), this.dom = hz(t107, e10, true), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class h_ {
  constructor(t107) {
    this.view = t107, this.items = [], this.list = hx("ul", { tabIndex: 0, role: "listbox", "aria-label": this.view.state.phrase("Diagnostics"), onkeydown: (e10) => {
      if (27 == e10.keyCode) hP(this.view), this.view.focus();
      else if (38 == e10.keyCode || 33 == e10.keyCode) this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (40 == e10.keyCode || 34 == e10.keyCode) this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (36 == e10.keyCode) this.moveSelection(0);
      else if (35 == e10.keyCode) this.moveSelection(this.items.length - 1);
      else if (13 == e10.keyCode) this.view.focus();
      else {
        if (!(e10.keyCode >= 65) || !(e10.keyCode <= 90) || !(this.selectedIndex >= 0)) return;
        let { diagnostic: i10 } = this.items[this.selectedIndex], s10 = hI(i10.actions);
        for (let n10 = 0; n10 < s10.length; n10++) if (s10[n10].toUpperCase().charCodeAt(0) == e10.keyCode) {
          let e11 = hM(this.view.state.field(hE).diagnostics, i10);
          e11 && i10.actions[n10].apply(t107, e11.from, e11.to);
        }
      }
      e10.preventDefault();
    }, onclick: (t108) => {
      for (let e10 = 0; e10 < this.items.length; e10++) this.items[e10].dom.contains(t108.target) && this.moveSelection(e10);
    } }), this.dom = hx("div", { class: "cm-panel-lint" }, this.list, hx("button", { type: "button", name: "close", "aria-label": this.view.state.phrase("close"), onclick: () => hP(this.view) }, "")), this.update();
  }
  get selectedIndex() {
    let t107 = this.view.state.field(hE).selected;
    if (!t107) return -1;
    for (let e10 = 0; e10 < this.items.length; e10++) if (this.items[e10].diagnostic == t107.diagnostic) return e10;
    return -1;
  }
  update() {
    let { diagnostics: t107, selected: e10 } = this.view.state.field(hE), i10 = 0, s10 = false, n10 = null;
    for (t107.between(0, this.view.state.doc.length, (t108, o10, r10) => {
      let { spec: l10 } = r10, h10 = -1, a10;
      for (let t109 = i10; t109 < this.items.length; t109++) if (this.items[t109].diagnostic == l10.diagnostic) {
        h10 = t109;
        break;
      }
      h10 < 0 ? (a10 = new hq(this.view, l10.diagnostic), this.items.splice(i10, 0, a10), s10 = true) : (a10 = this.items[h10], h10 > i10 && (this.items.splice(i10, h10 - i10), s10 = true)), e10 && a10.diagnostic == e10.diagnostic ? a10.dom.hasAttribute("aria-selected") || (a10.dom.setAttribute("aria-selected", "true"), n10 = a10) : a10.dom.hasAttribute("aria-selected") && a10.dom.removeAttribute("aria-selected"), i10++;
    }); i10 < this.items.length && !(1 == this.items.length && this.items[0].diagnostic.from < 0); ) s10 = true, this.items.pop();
    0 == this.items.length && (this.items.push(new hq(this.view, { from: -1, to: -1, severity: "info", message: this.view.state.phrase("No diagnostics") })), s10 = true), n10 ? (this.list.setAttribute("aria-activedescendant", n10.id), this.view.requestMeasure({ key: this, read: () => ({ sel: n10.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }), write: (t108) => {
      let { sel: e11, panel: i11 } = t108, s11 = i11.height / this.list.offsetHeight;
      e11.top < i11.top ? this.list.scrollTop -= (i11.top - e11.top) / s11 : e11.bottom > i11.bottom && (this.list.scrollTop += (e11.bottom - i11.bottom) / s11);
    } })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), s10 && this.sync();
  }
  sync() {
    let t107 = this.list.firstChild;
    function e10() {
      let e11 = t107;
      t107 = e11.nextSibling, e11.remove();
    }
    for (let i10 of this.items) if (i10.dom.parentNode == this.list) {
      for (; t107 != i10.dom; ) e10();
      t107 = i10.dom.nextSibling;
    } else this.list.insertBefore(i10.dom, t107);
    for (; t107; ) e10();
  }
  moveSelection(t107) {
    if (this.selectedIndex < 0) return;
    let e10 = hM(this.view.state.field(hE).diagnostics, this.items[t107].diagnostic);
    e10 && this.view.dispatch({ selection: { anchor: e10.from, head: e10.to }, scrollIntoView: true, effects: hT.of(e10) });
  }
  static open(t107) {
    return new h_(t107);
  }
}
function hG(t107) {
  let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'viewBox="0 0 40 40"';
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e10}>${encodeURIComponent(t107)}</svg>')`;
}
function hj(t107) {
  return hG(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${t107}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
let hU = l$.baseTheme({ ".cm-diagnostic": { padding: "3px 6px 3px 8px", marginLeft: "-1px", display: "block", whiteSpace: "pre-wrap" }, ".cm-diagnostic-error": { borderLeft: "5px solid #d11" }, ".cm-diagnostic-warning": { borderLeft: "5px solid orange" }, ".cm-diagnostic-info": { borderLeft: "5px solid #999" }, ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" }, ".cm-diagnosticAction": { font: "inherit", border: "none", padding: "2px 4px", backgroundColor: "#444", color: "white", borderRadius: "3px", marginLeft: "8px", cursor: "pointer" }, ".cm-diagnosticSource": { fontSize: "70%", opacity: 0.7 }, ".cm-lintRange": { backgroundPosition: "left bottom", backgroundRepeat: "repeat-x", paddingBottom: "0.7px" }, ".cm-lintRange-error": { backgroundImage: hj("#d11") }, ".cm-lintRange-warning": { backgroundImage: hj("orange") }, ".cm-lintRange-info": { backgroundImage: hj("#999") }, ".cm-lintRange-hint": { backgroundImage: hj("#66d") }, ".cm-lintRange-active": { backgroundColor: "#ffdd9980" }, ".cm-tooltip-lint": { padding: 0, margin: 0 }, ".cm-lintPoint": { position: "relative", "&:after": { content: '""', position: "absolute", bottom: 0, left: "-2px", borderLeft: "3px solid transparent", borderRight: "3px solid transparent", borderBottom: "4px solid #d11" } }, ".cm-lintPoint-warning": { "&:after": { borderBottomColor: "orange" } }, ".cm-lintPoint-info": { "&:after": { borderBottomColor: "#999" } }, ".cm-lintPoint-hint": { "&:after": { borderBottomColor: "#66d" } }, ".cm-panel.cm-panel-lint": { position: "relative", "& ul": { maxHeight: "100px", overflowY: "auto", "& [aria-selected]": { backgroundColor: "#ddd", "& u": { textDecoration: "underline" } }, "&:focus [aria-selected]": { background_fallback: "#bdf", backgroundColor: "Highlight", color_fallback: "white", color: "HighlightText" }, "& u": { textDecoration: "none" }, padding: 0, margin: 0 }, "& [name=close]": { position: "absolute", top: "0", right: "2px", background: "inherit", border: "none", font: "inherit", padding: 0, margin: 0 } } });
function hY(t107) {
  return "error" == t107 ? 4 : "warning" == t107 ? 3 : "info" == t107 ? 2 : 1;
}
class h$ extends hd {
  constructor(t107) {
    super(), this.diagnostics = t107, this.severity = t107.reduce((t108, e10) => hY(t108) < hY(e10.severity) ? e10.severity : t108, "hint");
  }
  toDOM(t107) {
    let e10 = document.createElement("div");
    e10.className = "cm-lint-marker cm-lint-marker-" + this.severity;
    let i10 = this.diagnostics, s10 = t107.state.facet(h2).tooltipFilter;
    return s10 && (i10 = s10(i10, t107.state)), i10.length && (e10.onmouseover = () => function(t108, e11, i11) {
      function s11() {
        let s12, n11 = t108.elementAtHeight(e11.getBoundingClientRect().top + 5 - t108.documentTop);
        t108.coordsAtPos(n11.from) && t108.dispatch({ effects: hQ.of({ pos: n11.from, above: false, create: () => ({ dom: hL(t108, i11), getCoords: () => e11.getBoundingClientRect() }) }) }), e11.onmouseout = e11.onmousemove = null, s12 = (i12) => {
          let n12 = e11.getBoundingClientRect();
          if (!(i12.clientX > n12.left - 10) || !(i12.clientX < n12.right + 10) || !(i12.clientY > n12.top - 10) || !(i12.clientY < n12.bottom + 10)) {
            for (let t109 = i12.target; t109; t109 = t109.parentNode) if (1 == t109.nodeType && t109.classList.contains("cm-tooltip-lint")) return;
            window.removeEventListener("mousemove", s12), t108.state.field(hZ) && t108.dispatch({ effects: hQ.of(null) });
          }
        }, window.addEventListener("mousemove", s12);
      }
      let { hoverTime: n10 } = t108.state.facet(h2), o10 = setTimeout(s11, n10);
      e11.onmouseout = () => {
        clearTimeout(o10), e11.onmouseout = e11.onmousemove = null;
      }, e11.onmousemove = () => {
        clearTimeout(o10), o10 = setTimeout(s11, n10);
      };
    }(t107, e10, i10)), e10;
  }
}
let hX = (B = { class: "cm-gutter-lint", markers: (t107) => t107.state.field(hJ) }, [[hp], hf.of(Object.assign(Object.assign({}, { class: "", renderEmptyElements: false, elementStyle: "", markers: () => tG.empty, lineMarker: () => null, widgetMarker: () => null, lineMarkerChange: null, initialSpacer: null, updateSpacer: null, domEventHandlers: {} }), B))]), hJ = td.define({ create: () => tG.empty, update(t107, e10) {
  t107 = t107.map(e10.changes);
  let i10 = e10.state.facet(h2).markerFilter;
  for (let s10 of e10.effects) if (s10.is(hD)) {
    let n10 = s10.value;
    i10 && (n10 = i10(n10 || [], e10.state)), t107 = function(t108, e11) {
      let i11 = /* @__PURE__ */ Object.create(null);
      for (let s12 of e11) {
        let e12 = t108.lineAt(s12.from);
        (i11[e12.from] || (i11[e12.from] = [])).push(s12);
      }
      let s11 = [];
      for (let t109 in i11) s11.push(new h$(i11[t109]).range(+t109));
      return tG.of(s11, true);
    }(e10.state.doc, n10.slice(0));
  }
  return t107;
} }), hQ = tR.define(), hZ = td.define({ create: () => null, update: (t107, e10) => (t107 && e10.docChanged && (t107 = hC(e10, t107) ? null : Object.assign(Object.assign({}, t107), { pos: e10.changes.mapPos(t107.pos) })), e10.effects.reduce((t108, e11) => e11.is(hQ) ? e11.value : t108, t107)), provide: (t107) => ht.from(t107) }), h0 = l$.baseTheme({ ".cm-gutter-lint": { width: "1.4em", "& .cm-gutterElement": { padding: ".2em" } }, ".cm-lint-marker": { width: "1em", height: "1em" }, ".cm-lint-marker-info": { content: hG('<path fill="#aaf" stroke="#77e" stroke-width="6" stroke-linejoin="round" d="M5 5L35 5L35 35L5 35Z"/>') }, ".cm-lint-marker-warning": { content: hG('<path fill="#fe8" stroke="#fd7" stroke-width="6" stroke-linejoin="round" d="M20 6L37 35L3 35Z"/>') }, ".cm-lint-marker-error": { content: hG('<circle cx="20" cy="20" r="15" fill="#f87" stroke="#f43" stroke-width="6"/>') } }), h1 = [hE, l$.decorations.compute([hE], (t107) => {
  let { selected: e10, panel: i10 } = t107.field(hE);
  return e10 && i10 && e10.from != e10.to ? oq.set([hB.range(e10.from, e10.to)]) : oq.none;
}), function(t107) {
  let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i10 = tR.define(), s10 = td.define({ create: () => [], update(t108, s11) {
    if (t108.length && (e10.hideOnChange && (s11.docChanged || s11.selection) ? t108 = [] : e10.hideOn && (t108 = t108.filter((t109) => !e10.hideOn(s11, t109))), s11.docChanged)) {
      let e11 = [];
      for (let i11 of t108) {
        let t109 = s11.changes.mapPos(i11.pos, -1, j.TrackDel);
        if (null != t109) {
          let n10 = Object.assign(/* @__PURE__ */ Object.create(null), i11);
          n10.pos = t109, null != n10.end && (n10.end = s11.changes.mapPos(n10.end)), e11.push(n10);
        }
      }
      t108 = e11;
    }
    for (let e11 of s11.effects) e11.is(i10) && (t108 = e11.value), e11.is(ho) && (t108 = []);
    return t108;
  }, provide: (t108) => he.from(t108) });
  return [s10, rb.define((n10) => new hn(n10, t107, s10, i10, e10.hoverTime || 300)), hs];
}(function(t107, e10, i10) {
  let { diagnostics: s10 } = t107.state.field(hE), n10 = [], o10 = 2e8, r10 = 0;
  s10.between(e10 - (i10 < 0 ? 1 : 0), e10 + (i10 > 0 ? 1 : 0), (t108, s11, l11) => {
    let { spec: h10 } = l11;
    e10 >= t108 && e10 <= s11 && (t108 == s11 || (e10 > t108 || i10 > 0) && (e10 < s11 || i10 < 0)) && (n10.push(h10.diagnostic), o10 = Math.min(t108, o10), r10 = Math.max(s11, r10));
  });
  let l10 = t107.state.facet(hH).tooltipFilter;
  return (l10 && (n10 = l10(n10, t107.state)), n10.length) ? { pos: o10, end: r10, above: t107.state.doc.lineAt(o10).to < r10, create: () => ({ dom: hL(t107, n10) }) } : null;
}, { hideOn: hC }), hU], h2 = to.define({ combine: (t107) => tI(t107, { hoverTime: 300, markerFilter: null, tooltipFilter: null }) });
function h8() {
  let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
  return [h2.of(t107), hJ, hX, h0, hZ];
}
function h3(t107) {
  return (11 == t107.nodeType ? t107.getSelection ? t107 : t107.ownerDocument : t107).getSelection();
}
function h4(t107, e10) {
  return !!e10 && (t107 == e10 || t107.contains(1 != e10.nodeType ? e10.parentNode : e10));
}
function h9(t107, e10) {
  if (!e10.anchorNode) return false;
  try {
    return h4(t107, e10.anchorNode);
  } catch (t108) {
    return false;
  }
}
function h5(t107) {
  return 3 == t107.nodeType ? ah(t107, 0, t107.nodeValue.length).getClientRects() : 1 == t107.nodeType ? t107.getClientRects() : [];
}
function h6(t107, e10, i10, s10) {
  return !!i10 && (ae(t107, e10, i10, s10, -1) || ae(t107, e10, i10, s10, 1));
}
function h7(t107) {
  for (var e10 = 0; ; e10++) if (!(t107 = t107.previousSibling)) return e10;
}
function at(t107) {
  return 1 == t107.nodeType && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t107.nodeName);
}
function ae(t107, e10, i10, s10, n10) {
  for (; ; ) {
    if (t107 == i10 && e10 == s10) return true;
    if (e10 == (n10 < 0 ? 0 : ai(t107))) {
      if ("DIV" == t107.nodeName) return false;
      let i11 = t107.parentNode;
      if (!i11 || 1 != i11.nodeType) return false;
      e10 = h7(t107) + (n10 < 0 ? 0 : 1), t107 = i11;
    } else {
      if (1 != t107.nodeType || 1 == (t107 = t107.childNodes[e10 + (n10 < 0 ? -1 : 0)]).nodeType && "false" == t107.contentEditable) return false;
      e10 = n10 < 0 ? ai(t107) : 0;
    }
  }
}
function ai(t107) {
  return 3 == t107.nodeType ? t107.nodeValue.length : t107.childNodes.length;
}
function as(t107, e10) {
  let i10 = e10 ? t107.left : t107.right;
  return { left: i10, right: i10, top: t107.top, bottom: t107.bottom };
}
function an(t107, e10) {
  let i10 = e10.width / t107.offsetWidth, s10 = e10.height / t107.offsetHeight;
  return (i10 > 0.995 && i10 < 1.005 || !isFinite(i10) || 1 > Math.abs(e10.width - t107.offsetWidth)) && (i10 = 1), (s10 > 0.995 && s10 < 1.005 || !isFinite(s10) || 1 > Math.abs(e10.height - t107.offsetHeight)) && (s10 = 1), { scaleX: i10, scaleY: s10 };
}
let ao = class {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(t107) {
    return this.anchorNode == t107.anchorNode && this.anchorOffset == t107.anchorOffset && this.focusNode == t107.focusNode && this.focusOffset == t107.focusOffset;
  }
  setRange(t107) {
    let { anchorNode: e10, focusNode: i10 } = t107;
    this.set(e10, Math.min(t107.anchorOffset, e10 ? ai(e10) : 0), i10, Math.min(t107.focusOffset, i10 ? ai(i10) : 0));
  }
  set(t107, e10, i10, s10) {
    this.anchorNode = t107, this.anchorOffset = e10, this.focusNode = i10, this.focusOffset = s10;
  }
}, ar = null;
function al(t107) {
  if (t107.setActive) return t107.setActive();
  if (ar) return t107.focus(ar);
  let e10 = [];
  for (let i10 = t107; i10 && (e10.push(i10, i10.scrollTop, i10.scrollLeft), i10 != i10.ownerDocument); i10 = i10.parentNode) ;
  if (t107.focus(null == ar ? { get preventScroll() {
    return ar = { preventScroll: true }, true;
  } } : void 0), !ar) {
    ar = false;
    for (let t108 = 0; t108 < e10.length; ) {
      let i10 = e10[t108++], s10 = e10[t108++], n10 = e10[t108++];
      i10.scrollTop != s10 && (i10.scrollTop = s10), i10.scrollLeft != n10 && (i10.scrollLeft = n10);
    }
  }
}
function ah(t107, e10) {
  let i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e10, n10 = s || (s = document.createRange());
  return n10.setEnd(t107, i10), n10.setStart(t107, e10), n10;
}
function aa(t107, e10, i10, s10) {
  let n10 = { key: e10, code: e10, keyCode: i10, which: i10, cancelable: true };
  s10 && ({ altKey: n10.altKey, ctrlKey: n10.ctrlKey, shiftKey: n10.shiftKey, metaKey: n10.metaKey } = s10);
  let o10 = new KeyboardEvent("keydown", n10);
  o10.synthetic = true, t107.dispatchEvent(o10);
  let r10 = new KeyboardEvent("keyup", n10);
  return r10.synthetic = true, t107.dispatchEvent(r10), o10.defaultPrevented || r10.defaultPrevented;
}
function ac(t107) {
  for (; t107.attributes.length; ) t107.removeAttributeNode(t107.attributes[0]);
}
function ad(t107) {
  return t107.scrollTop > Math.max(1, t107.scrollHeight - t107.clientHeight - 4);
}
function au(t107, e10) {
  for (let i10 = t107, s10 = e10; ; ) {
    if (3 == i10.nodeType && s10 > 0) return { node: i10, offset: s10 };
    if (1 == i10.nodeType && s10 > 0) {
      if ("false" == i10.contentEditable) return null;
      s10 = ai(i10 = i10.childNodes[s10 - 1]);
    } else {
      if (!i10.parentNode || at(i10)) return null;
      s10 = h7(i10), i10 = i10.parentNode;
    }
  }
}
function af(t107, e10) {
  for (let i10 = t107, s10 = e10; ; ) {
    if (3 == i10.nodeType && s10 < i10.nodeValue.length) return { node: i10, offset: s10 };
    if (1 == i10.nodeType && s10 < i10.childNodes.length) {
      if ("false" == i10.contentEditable) return null;
      i10 = i10.childNodes[s10], s10 = 0;
    } else {
      if (!i10.parentNode || at(i10)) return null;
      s10 = h7(i10) + 1, i10 = i10.parentNode;
    }
  }
}
let ag = class t59 {
  constructor(t107, e10, i10 = true) {
    this.node = t107, this.offset = e10, this.precise = i10;
  }
  static before(e10, i10) {
    return new t59(e10.parentNode, h7(e10), i10);
  }
  static after(e10, i10) {
    return new t59(e10.parentNode, h7(e10) + 1, i10);
  }
}, ap = [], am = class t60 {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(t107) {
    let e10 = this.posAtStart;
    for (let i10 of this.children) {
      if (i10 == t107) return e10;
      e10 += i10.length + i10.breakAfter;
    }
    throw RangeError("Invalid child in posBefore");
  }
  posAfter(t107) {
    return this.posBefore(t107) + t107.length;
  }
  sync(e10, i10) {
    if (2 & this.flags) {
      let s10 = this.dom, n10 = null, o10;
      for (let r10 of this.children) {
        if (7 & r10.flags) {
          if (!r10.dom && (o10 = n10 ? n10.nextSibling : s10.firstChild)) {
            let e11 = t60.get(o10);
            (!e11 || !e11.parent && e11.canReuseDOM(r10)) && r10.reuseDOM(o10);
          }
          r10.sync(e10, i10), r10.flags &= -8;
        }
        if (o10 = n10 ? n10.nextSibling : s10.firstChild, i10 && !i10.written && i10.node == s10 && o10 != r10.dom && (i10.written = true), r10.dom.parentNode == s10) for (; o10 && o10 != r10.dom; ) o10 = av(o10);
        else s10.insertBefore(r10.dom, o10);
        n10 = r10.dom;
      }
      for ((o10 = n10 ? n10.nextSibling : s10.firstChild) && i10 && i10.node == s10 && (i10.written = true); o10; ) o10 = av(o10);
    } else if (1 & this.flags) for (let t107 of this.children) 7 & t107.flags && (t107.sync(e10, i10), t107.flags &= -8);
  }
  reuseDOM(t107) {
  }
  localPosFromDOM(e10, i10) {
    let s10;
    if (e10 == this.dom) s10 = this.dom.childNodes[i10];
    else {
      let t107 = 0 == ai(e10) ? 0 : 0 == i10 ? -1 : 1;
      for (; ; ) {
        let i11 = e10.parentNode;
        if (i11 == this.dom) break;
        0 == t107 && i11.firstChild != i11.lastChild && (t107 = e10 == i11.firstChild ? -1 : 1), e10 = i11;
      }
      s10 = t107 < 0 ? e10 : e10.nextSibling;
    }
    if (s10 == this.dom.firstChild) return 0;
    for (; s10 && !t60.get(s10); ) s10 = s10.nextSibling;
    if (!s10) return this.length;
    for (let t107 = 0, e11 = 0; ; t107++) {
      let i11 = this.children[t107];
      if (i11.dom == s10) return e11;
      e11 += i11.length + i11.breakAfter;
    }
  }
  domBoundsAround(t107, e10) {
    let i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, s10 = -1, n10 = -1, o10 = -1, r10 = -1;
    for (let l10 = 0, h10 = i10, a10 = i10; l10 < this.children.length; l10++) {
      let i11 = this.children[l10], c10 = h10 + i11.length;
      if (h10 < t107 && c10 > e10) return i11.domBoundsAround(t107, e10, h10);
      if (c10 >= t107 && -1 == s10 && (s10 = l10, n10 = h10), h10 > e10 && i11.dom.parentNode == this.dom) {
        o10 = l10, r10 = a10;
        break;
      }
      a10 = c10, h10 = c10 + i11.breakAfter;
    }
    return { from: n10, to: r10 < 0 ? i10 + this.length : r10, startDOM: (s10 ? this.children[s10 - 1].dom.nextSibling : null) || this.dom.firstChild, endDOM: o10 < this.children.length && o10 >= 0 ? this.children[o10].dom : null };
  }
  markDirty() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
    this.flags |= 2, this.markParentsDirty(t107);
  }
  markParentsDirty(t107) {
    for (let e10 = this.parent; e10; e10 = e10.parent) {
      if (t107 && (e10.flags |= 2), 1 & e10.flags) return;
      e10.flags |= 1, t107 = false;
    }
  }
  setParent(t107) {
    this.parent != t107 && (this.parent = t107, 7 & this.flags && this.markParentsDirty(true));
  }
  setDOM(t107) {
    this.dom != t107 && (this.dom && (this.dom.cmView = null), this.dom = t107, t107.cmView = this);
  }
  get rootView() {
    for (let t107 = this; ; ) {
      let e10 = t107.parent;
      if (!e10) return t107;
      t107 = e10;
    }
  }
  replaceChildren(t107, e10) {
    let i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ap;
    this.markDirty();
    for (let s10 = t107; s10 < e10; s10++) {
      let t108 = this.children[s10];
      t108.parent == this && 0 > i10.indexOf(t108) && t108.destroy();
    }
    this.children.splice(t107, e10 - t107, ...i10);
    for (let t108 = 0; t108 < i10.length; t108++) i10[t108].setParent(this);
  }
  ignoreMutation(t107) {
    return false;
  }
  ignoreEvent(t107) {
    return false;
  }
  childCursor() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.length;
    return new aw(this.children, t107, this.children.length);
  }
  childPos(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
    return this.childCursor().findPos(t107, e10);
  }
  toString() {
    let t107 = this.constructor.name.replace("View", "");
    return t107 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + ("Text" == t107 ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(t107) {
    return t107.cmView;
  }
  get isEditable() {
    return true;
  }
  get isWidget() {
    return false;
  }
  get isHidden() {
    return false;
  }
  merge(t107, e10, i10, s10, n10, o10) {
    return false;
  }
  become(t107) {
    return false;
  }
  canReuseDOM(t107) {
    return t107.constructor == this.constructor && !((this.flags | t107.flags) & 8);
  }
  getSide() {
    return 0;
  }
  destroy() {
    for (let t107 of this.children) t107.parent == this && t107.destroy();
    this.parent = null;
  }
};
function av(t107) {
  let e10 = t107.nextSibling;
  return t107.parentNode.removeChild(t107), e10;
}
am.prototype.breakAfter = 0;
let aw = class {
  constructor(t107, e10, i10) {
    this.children = t107, this.pos = e10, this.i = i10, this.off = 0;
  }
  findPos(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
    for (; ; ) {
      if (t107 > this.pos || t107 == this.pos && (e10 > 0 || 0 == this.i || this.children[this.i - 1].breakAfter)) return this.off = t107 - this.pos, this;
      let i10 = this.children[--this.i];
      this.pos -= i10.length + i10.breakAfter;
    }
  }
};
function ab(t107, e10, i10, s10, n10, o10, r10, l10, h10) {
  let { children: a10 } = t107, c10 = a10.length ? a10[e10] : null, d10 = o10.length ? o10[o10.length - 1] : null, u10 = d10 ? d10.breakAfter : r10;
  if (!(e10 == s10 && c10 && !r10 && !u10 && o10.length < 2 && c10.merge(i10, n10, o10.length ? d10 : null, 0 == i10, l10, h10))) {
    if (s10 < a10.length) {
      let t108 = a10[s10];
      t108 && (n10 < t108.length || t108.breakAfter && (null == d10 ? void 0 : d10.breakAfter)) ? (e10 == s10 && (t108 = t108.split(n10), n10 = 0), !u10 && d10 && t108.merge(0, n10, d10, true, 0, h10) ? o10[o10.length - 1] = t108 : ((n10 || t108.children.length && !t108.children[0].length) && t108.merge(0, n10, null, false, 0, h10), o10.push(t108))) : (null == t108 ? void 0 : t108.breakAfter) && (d10 ? d10.breakAfter = 1 : r10 = 1), s10++;
    }
    for (c10 && (c10.breakAfter = r10, i10 > 0 && (!r10 && o10.length && c10.merge(i10, c10.length, o10[0], false, l10, 0) ? c10.breakAfter = o10.shift().breakAfter : (i10 < c10.length || c10.children.length && 0 == c10.children[c10.children.length - 1].length) && c10.merge(i10, c10.length, null, false, l10, 0), e10++)); e10 < s10 && o10.length; ) if (a10[s10 - 1].become(o10[o10.length - 1])) s10--, o10.pop(), h10 = o10.length ? 0 : l10;
    else if (a10[e10].become(o10[0])) e10++, o10.shift(), l10 = o10.length ? 0 : h10;
    else break;
    !o10.length && e10 && s10 < a10.length && !a10[e10 - 1].breakAfter && a10[s10].merge(0, 0, a10[e10 - 1], false, l10, h10) && e10--, (e10 < s10 || o10.length) && t107.replaceChildren(e10, s10, o10);
  }
}
function ay(t107, e10, i10, s10, n10, o10) {
  let r10 = t107.childCursor(), { i: l10, off: h10 } = r10.findPos(i10, 1), { i: a10, off: c10 } = r10.findPos(e10, -1), d10 = e10 - i10;
  for (let t108 of s10) d10 += t108.length;
  t107.length += d10, ab(t107, a10, c10, l10, h10, s10, 0, n10, o10);
}
let ax = "undefined" != typeof navigator ? navigator : { userAgent: "", vendor: "", platform: "" }, aS = "undefined" != typeof document ? document : { documentElement: { style: {} } }, ak = /Edge\/(\d+)/.exec(ax.userAgent), aM = /MSIE \d/.test(ax.userAgent), aC = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ax.userAgent), aA = !!(aM || aC || ak), aD = !aA && /gecko\/(\d+)/i.test(ax.userAgent), aO = !aA && /Chrome\/(\d+)/.exec(ax.userAgent), aT = "webkitFontSmoothing" in aS.documentElement.style, aE = !aA && /Apple Computer/.test(ax.vendor), aR = aE && (/Mobile\/\w+/.test(ax.userAgent) || ax.maxTouchPoints > 2);
var aB = { mac: aR || /Mac/.test(ax.platform), windows: /Win/.test(ax.platform), linux: /Linux|X11/.test(ax.platform), ie: aA, ie_version: aM ? aS.documentMode || 6 : aC ? +aC[1] : ak ? +ak[1] : 0, gecko: aD, gecko_version: aD ? +(/Firefox\/(\d+)/.exec(ax.userAgent) || [0, 0])[1] : 0, chrome: !!aO, chrome_version: aO ? +aO[1] : 0, ios: aR, android: /Android\b/.test(ax.userAgent), webkit: aT, safari: aE, webkit_version: aT ? +(/\bAppleWebKit\/(\d+)/.exec(ax.userAgent) || [0, 0])[1] : 0, tabSize: null != aS.documentElement.style.tabSize ? "tab-size" : "-moz-tab-size" };
let aL = class t61 extends am {
  constructor(t107) {
    super(), this.text = t107;
  }
  get length() {
    return this.text.length;
  }
  createDOM(t107) {
    this.setDOM(t107 || document.createTextNode(this.text));
  }
  sync(t107, e10) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (e10 && e10.node == this.dom && (e10.written = true), this.dom.nodeValue = this.text);
  }
  reuseDOM(t107) {
    3 == t107.nodeType && this.createDOM(t107);
  }
  merge(e10, i10, s10) {
    return !(8 & this.flags) && (!s10 || s10 instanceof t61 && !(this.length - (i10 - e10) + s10.length > 256) && !(8 & s10.flags)) && (this.text = this.text.slice(0, e10) + (s10 ? s10.text : "") + this.text.slice(i10), this.markDirty(), true);
  }
  split(e10) {
    let i10 = new t61(this.text.slice(e10));
    return this.text = this.text.slice(0, e10), this.markDirty(), i10.flags |= 8 & this.flags, i10;
  }
  localPosFromDOM(t107, e10) {
    return t107 == this.dom ? e10 : e10 ? this.text.length : 0;
  }
  domAtPos(t107) {
    return new ag(this.dom, t107);
  }
  domBoundsAround(t107, e10, i10) {
    return { from: i10, to: i10 + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(t107, e10) {
    return function(t108, e11, i10) {
      let s10 = t108.nodeValue.length;
      e11 > s10 && (e11 = s10);
      let n10 = e11, o10 = e11, r10 = 0;
      0 == e11 && i10 < 0 || e11 == s10 && i10 >= 0 ? !(aB.chrome || aB.gecko) && (e11 ? (n10--, r10 = 1) : o10 < s10 && (o10++, r10 = -1)) : i10 < 0 ? n10-- : o10 < s10 && o10++;
      let l10 = ah(t108, n10, o10).getClientRects();
      if (!l10.length) return null;
      let h10 = l10[(r10 ? r10 < 0 : i10 >= 0) ? 0 : l10.length - 1];
      return aB.safari && !r10 && 0 == h10.width && (h10 = Array.prototype.find.call(l10, (t109) => t109.width) || h10), r10 ? as(h10, r10 < 0) : h10 || null;
    }(this.dom, t107, e10);
  }
}, aP = class t62 extends am {
  constructor(t107, e10 = [], i10 = 0) {
    for (let s10 of (super(), this.mark = t107, this.children = e10, this.length = i10, e10)) s10.setParent(this);
  }
  setAttrs(t107) {
    if (ac(t107), this.mark.class && (t107.className = this.mark.class), this.mark.attrs) for (let e10 in this.mark.attrs) t107.setAttribute(e10, this.mark.attrs[e10]);
    return t107;
  }
  canReuseDOM(t107) {
    return super.canReuseDOM(t107) && !((this.flags | t107.flags) & 8);
  }
  reuseDOM(t107) {
    t107.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(t107), this.flags |= 6);
  }
  sync(t107, e10) {
    this.dom ? 4 & this.flags && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(t107, e10);
  }
  merge(e10, i10, s10, n10, o10, r10) {
    return (!s10 || !!(s10 instanceof t62 && s10.mark.eq(this.mark)) && (!e10 || !(o10 <= 0)) && (!(i10 < this.length) || !(r10 <= 0))) && (ay(this, e10, i10, s10 ? s10.children.slice() : [], o10 - 1, r10 - 1), this.markDirty(), true);
  }
  split(e10) {
    let i10 = [], s10 = 0, n10 = -1, o10 = 0;
    for (let t107 of this.children) {
      let r11 = s10 + t107.length;
      r11 > e10 && i10.push(s10 < e10 ? t107.split(e10 - s10) : t107), n10 < 0 && s10 >= e10 && (n10 = o10), s10 = r11, o10++;
    }
    let r10 = this.length - e10;
    return this.length = e10, n10 > -1 && (this.children.length = n10, this.markDirty()), new t62(this.mark, i10, r10);
  }
  domAtPos(t107) {
    return aH(this, t107);
  }
  coordsAt(t107, e10) {
    return aF(this, t107, e10);
  }
}, aN = class t63 extends am {
  static create(e10, i10, s10) {
    return new t63(e10, i10, s10);
  }
  constructor(t107, e10, i10) {
    super(), this.widget = t107, this.length = e10, this.side = i10, this.prevWidget = null;
  }
  split(e10) {
    let i10 = t63.create(this.widget, this.length - e10, this.side);
    return this.length -= e10, i10;
  }
  sync(t107) {
    this.dom && this.widget.updateDOM(this.dom, t107) || (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t107)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e10, i10, s10, n10, o10, r10) {
    return (!s10 || s10 instanceof t63 && !!this.widget.compare(s10.widget) && (!(e10 > 0) || !(o10 <= 0)) && (!(i10 < this.length) || !(r10 <= 0))) && (this.length = e10 + (s10 ? s10.length : 0) + (this.length - i10), true);
  }
  become(e10) {
    return e10 instanceof t63 && e10.side == this.side && this.widget.constructor == e10.widget.constructor && (this.widget.compare(e10.widget) || this.markDirty(true), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e10.widget, this.length = e10.length, true);
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(t107) {
    return this.widget.ignoreEvent(t107);
  }
  get overrideDOMText() {
    if (0 == this.length) return r.empty;
    let t107 = this;
    for (; t107.parent; ) t107 = t107.parent;
    let { view: e10 } = t107, i10 = e10 && e10.state.doc, s10 = this.posAtStart;
    return i10 ? i10.slice(s10, s10 + this.length) : r.empty;
  }
  domAtPos(t107) {
    return (this.length ? 0 == t107 : this.side > 0) ? ag.before(this.dom) : ag.after(this.dom, t107 == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(t107, e10) {
    let i10 = this.widget.coordsAt(this.dom, t107, e10);
    if (i10) return i10;
    let s10 = this.dom.getClientRects(), n10 = null;
    if (!s10.length) return null;
    let o10 = this.side ? this.side < 0 : t107 > 0;
    for (let e11 = o10 ? s10.length - 1 : 0; n10 = s10[e11], t107 > 0 ? 0 != e11 : e11 != s10.length - 1 && !(n10.top < n10.bottom); e11 += o10 ? -1 : 1) ;
    return as(n10, !o10);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}, aV = class t64 extends am {
  constructor(t107) {
    super(), this.side = t107;
  }
  get length() {
    return 0;
  }
  merge() {
    return false;
  }
  become(e10) {
    return e10 instanceof t64 && e10.side == this.side;
  }
  split() {
    return new t64(this.side);
  }
  sync() {
    if (!this.dom) {
      let t107 = document.createElement("img");
      t107.className = "cm-widgetBuffer", t107.setAttribute("aria-hidden", "true"), this.setDOM(t107);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(t107) {
    return this.side > 0 ? ag.before(this.dom) : ag.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(t107) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return r.empty;
  }
  get isHidden() {
    return true;
  }
};
function aH(t107, e10) {
  let i10 = t107.dom, { children: s10 } = t107, n10 = 0;
  for (let t108 = 0; n10 < s10.length; n10++) {
    let o10 = s10[n10], r10 = t108 + o10.length;
    if (!(r10 == t108 && 0 >= o10.getSide())) {
      if (e10 > t108 && e10 < r10 && o10.dom.parentNode == i10) return o10.domAtPos(e10 - t108);
      if (e10 <= t108) break;
      t108 = r10;
    }
  }
  for (let t108 = n10; t108 > 0; t108--) {
    let e11 = s10[t108 - 1];
    if (e11.dom.parentNode == i10) return e11.domAtPos(e11.length);
  }
  for (let t108 = n10; t108 < s10.length; t108++) {
    let e11 = s10[t108];
    if (e11.dom.parentNode == i10) return e11.domAtPos(0);
  }
  return new ag(i10, 0);
}
function aF(t107, e10, i10) {
  let s10 = null, n10 = -1, o10 = null, r10 = -1;
  !function t108(e11, l11) {
    for (let h10 = 0, a10 = 0; h10 < e11.children.length && a10 <= l11; h10++) {
      let c10 = e11.children[h10], d10 = a10 + c10.length;
      d10 >= l11 && (c10.children.length ? t108(c10, l11 - a10) : (!o10 || o10.isHidden && i10 > 0) && (d10 > l11 || a10 == d10 && c10.getSide() > 0) ? (o10 = c10, r10 = l11 - a10) : (a10 < l11 || a10 == d10 && 0 > c10.getSide() && !c10.isHidden) && (s10 = c10, n10 = l11 - a10)), a10 = d10;
    }
  }(t107, e10);
  let l10 = (i10 < 0 ? s10 : o10) || s10 || o10;
  return l10 ? l10.coordsAt(Math.max(0, l10 == s10 ? n10 : r10), i10) : function(t108) {
    let e11 = t108.dom.lastChild;
    if (!e11) return t108.dom.getBoundingClientRect();
    let i11 = h5(e11);
    return i11[i11.length - 1] || null;
  }(t107);
}
function aW(t107, e10) {
  for (let i10 in t107) "class" == i10 && e10.class ? e10.class += " " + t107.class : "style" == i10 && e10.style ? e10.style += ";" + t107.style : e10[i10] = t107[i10];
  return e10;
}
aL.prototype.children = aN.prototype.children = aV.prototype.children = ap;
let aI = /* @__PURE__ */ Object.create(null);
function az(t107, e10, i10) {
  if (t107 == e10) return true;
  t107 || (t107 = aI), e10 || (e10 = aI);
  let s10 = Object.keys(t107), n10 = Object.keys(e10);
  if (s10.length - (i10 && s10.indexOf(i10) > -1 ? 1 : 0) != n10.length - (i10 && n10.indexOf(i10) > -1 ? 1 : 0)) return false;
  for (let o10 of s10) if (o10 != i10 && (-1 == n10.indexOf(o10) || t107[o10] !== e10[o10])) return false;
  return true;
}
function aK(t107, e10, i10) {
  let s10 = false;
  if (e10) for (let n10 in e10) i10 && n10 in i10 || (s10 = true, "style" == n10 ? t107.style.cssText = "" : t107.removeAttribute(n10));
  if (i10) for (let n10 in i10) e10 && e10[n10] == i10[n10] || (s10 = true, "style" == n10 ? t107.style.cssText = i10[n10] : t107.setAttribute(n10, i10[n10]));
  return s10;
}
let aq = class t65 extends am {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  merge(e10, i10, s10, n10, o10, r10) {
    if (s10) {
      if (!(s10 instanceof t65)) return false;
      this.dom || s10.transferDOM(this);
    }
    return n10 && this.setDeco(s10 ? s10.attrs : null), ay(this, e10, i10, s10 ? s10.children.slice() : [], o10, r10), true;
  }
  split(e10) {
    let i10 = new t65();
    if (i10.breakAfter = this.breakAfter, 0 == this.length) return i10;
    let { i: s10, off: n10 } = this.childPos(e10);
    n10 && (i10.append(this.children[s10].split(n10), 0), this.children[s10].merge(n10, this.children[s10].length, null, false, 0, 0), s10++);
    for (let t107 = s10; t107 < this.children.length; t107++) i10.append(this.children[t107], 0);
    for (; s10 > 0 && 0 == this.children[s10 - 1].length; ) this.children[--s10].destroy();
    return this.children.length = s10, this.markDirty(), this.length = e10, i10;
  }
  transferDOM(t107) {
    this.dom && (this.markDirty(), t107.setDOM(this.dom), t107.prevAttrs = void 0 === this.prevAttrs ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(t107) {
    az(this.attrs, t107) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = t107);
  }
  append(t107, e10) {
    !function t108(e11, i10, s10) {
      let n10, { children: o10 } = e11;
      s10 > 0 && i10 instanceof aP && o10.length && (n10 = o10[o10.length - 1]) instanceof aP && n10.mark.eq(i10.mark) ? t108(n10, i10.children[0], s10 - 1) : (o10.push(i10), i10.setParent(e11)), e11.length += i10.length;
    }(this, t107, e10);
  }
  addLineDeco(t107) {
    let e10 = t107.spec.attributes, i10 = t107.spec.class;
    e10 && (this.attrs = aW(e10, this.attrs || {})), i10 && (this.attrs = aW({ class: i10 }, this.attrs || {}));
  }
  domAtPos(t107) {
    return aH(this, t107);
  }
  reuseDOM(t107) {
    "DIV" == t107.nodeName && (this.setDOM(t107), this.flags |= 6);
  }
  sync(t107, e10) {
    var i10;
    this.dom ? 4 & this.flags && (ac(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), void 0 !== this.prevAttrs && (aK(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(t107, e10);
    let s10 = this.dom.lastChild;
    for (; s10 && am.get(s10) instanceof aP; ) s10 = s10.lastChild;
    if (!s10 || !this.length || "BR" != s10.nodeName && (null === (i10 = am.get(s10)) || void 0 === i10 ? void 0 : i10.isEditable) == false && (!aB.ios || !this.children.some((t108) => t108 instanceof aL))) {
      let t108 = document.createElement("BR");
      t108.cmIgnore = true, this.dom.appendChild(t108);
    }
  }
  measureTextSize() {
    if (0 == this.children.length || this.length > 20) return null;
    let t107 = 0, e10;
    for (let i10 of this.children) {
      if (!(i10 instanceof aL) || /[^ -~]/.test(i10.text)) return null;
      let s10 = h5(i10.dom);
      if (1 != s10.length) return null;
      t107 += s10[0].width, e10 = s10[0].height;
    }
    return t107 ? { lineHeight: this.dom.getBoundingClientRect().height, charWidth: t107 / this.length, textHeight: e10 } : null;
  }
  coordsAt(t107, e10) {
    let i10 = aF(this, t107, e10);
    if (!this.children.length && i10 && this.parent) {
      let { heightOracle: t108 } = this.parent.view.viewState, e11 = i10.bottom - i10.top;
      if (2 > Math.abs(e11 - t108.lineHeight) && t108.textHeight < e11) {
        let s10 = (e11 - t108.textHeight) / 2;
        return { top: i10.top + s10, bottom: i10.bottom - s10, left: i10.left, right: i10.left };
      }
    }
    return i10;
  }
  become(e10) {
    return e10 instanceof t65 && 0 == this.children.length && 0 == e10.children.length && az(this.attrs, e10.attrs) && this.breakAfter == e10.breakAfter;
  }
  covers() {
    return true;
  }
  static find(e10, i10) {
    for (let s10 = 0, n10 = 0; s10 < e10.children.length; s10++) {
      let o10 = e10.children[s10], r10 = n10 + o10.length;
      if (r10 >= i10) {
        if (o10 instanceof t65) return o10;
        if (r10 > i10) break;
      }
      n10 = r10 + o10.breakAfter;
    }
    return null;
  }
}, a_ = class t66 extends am {
  constructor(t107, e10, i10) {
    super(), this.widget = t107, this.length = e10, this.deco = i10, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e10, i10, s10, n10, o10, r10) {
    return (!s10 || s10 instanceof t66 && !!this.widget.compare(s10.widget) && (!(e10 > 0) || !(o10 <= 0)) && (!(i10 < this.length) || !(r10 <= 0))) && (this.length = e10 + (s10 ? s10.length : 0) + (this.length - i10), true);
  }
  domAtPos(t107) {
    return 0 == t107 ? ag.before(this.dom) : ag.after(this.dom, t107 == this.length);
  }
  split(e10) {
    let i10 = this.length - e10;
    this.length = e10;
    let s10 = new t66(this.widget, i10, this.deco);
    return s10.breakAfter = this.breakAfter, s10;
  }
  get children() {
    return ap;
  }
  sync(t107) {
    this.dom && this.widget.updateDOM(this.dom, t107) || (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t107)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : r.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e10) {
    return e10 instanceof t66 && e10.widget.constructor == this.widget.constructor && (e10.widget.compare(this.widget) || this.markDirty(true), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e10.widget, this.length = e10.length, this.deco = e10.deco, this.breakAfter = e10.breakAfter, true);
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(t107) {
    return this.widget.ignoreEvent(t107);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  coordsAt(t107, e10) {
    return this.widget.coordsAt(this.dom, t107, e10);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(t107) {
    let { startSide: e10, endSide: i10 } = this.deco;
    return e10 != i10 && (t107 < 0 ? e10 < 0 : i10 > 0);
  }
}, aG = class {
  eq(t107) {
    return false;
  }
  updateDOM(t107, e10) {
    return false;
  }
  compare(t107) {
    return this == t107 || this.constructor == t107.constructor && this.eq(t107);
  }
  get estimatedHeight() {
    return -1;
  }
  get lineBreaks() {
    return 0;
  }
  ignoreEvent(t107) {
    return true;
  }
  coordsAt(t107, e10, i10) {
    return null;
  }
  get isHidden() {
    return false;
  }
  get editable() {
    return false;
  }
  destroy(t107) {
  }
};
var aj = ((L = aj || (aj = {}))[L.Text = 0] = "Text", L[L.WidgetBefore = 1] = "WidgetBefore", L[L.WidgetAfter = 2] = "WidgetAfter", L[L.WidgetRange = 3] = "WidgetRange", L);
let aU = class extends tz {
  constructor(t107, e10, i10, s10) {
    super(), this.startSide = t107, this.endSide = e10, this.widget = i10, this.spec = s10;
  }
  get heightRelevant() {
    return false;
  }
  static mark(t107) {
    return new aY(t107);
  }
  static widget(t107) {
    let e10 = Math.max(-1e4, Math.min(1e4, t107.side || 0)), i10 = !!t107.block;
    return e10 += i10 && !t107.inlineOrder ? e10 > 0 ? 3e8 : -4e8 : e10 > 0 ? 1e8 : -1e8, new aX(t107, e10, e10, i10, t107.widget || null, false);
  }
  static replace(t107) {
    let e10 = !!t107.block, i10, s10;
    if (t107.isBlockGap) i10 = -5e8, s10 = 4e8;
    else {
      let { start: n10, end: o10 } = aJ(t107, e10);
      i10 = (n10 ? e10 ? -3e8 : -1 : 5e8) - 1, s10 = (o10 ? e10 ? 2e8 : 1 : -6e8) + 1;
    }
    return new aX(t107, i10, s10, e10, t107.widget || null, true);
  }
  static line(t107) {
    return new a$(t107);
  }
  static set(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return tG.of(t107, e10);
  }
  hasHeight() {
    return !!this.widget && this.widget.estimatedHeight > -1;
  }
};
aU.none = tG.empty;
let aY = class t67 extends aU {
  constructor(t107) {
    let { start: e10, end: i10 } = aJ(t107);
    super(e10 ? -1 : 5e8, i10 ? 1 : -6e8, null, t107), this.tagName = t107.tagName || "span", this.class = t107.class || "", this.attrs = t107.attributes || null;
  }
  eq(e10) {
    var i10, s10;
    return this == e10 || e10 instanceof t67 && this.tagName == e10.tagName && (this.class || (null === (i10 = this.attrs) || void 0 === i10 ? void 0 : i10.class)) == (e10.class || (null === (s10 = e10.attrs) || void 0 === s10 ? void 0 : s10.class)) && az(this.attrs, e10.attrs, "class");
  }
  range(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t107;
    if (t107 >= e10) throw RangeError("Mark decorations may not be empty");
    return super.range(t107, e10);
  }
};
aY.prototype.point = false;
let a$ = class t68 extends aU {
  constructor(t107) {
    super(-2e8, -2e8, null, t107);
  }
  eq(e10) {
    return e10 instanceof t68 && this.spec.class == e10.spec.class && az(this.spec.attributes, e10.spec.attributes);
  }
  range(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t107;
    if (e10 != t107) throw RangeError("Line decoration ranges must be zero-length");
    return super.range(t107, e10);
  }
};
a$.prototype.mapMode = j.TrackBefore, a$.prototype.point = true;
let aX = class t69 extends aU {
  constructor(t107, e10, i10, s10, n10, o10) {
    super(e10, i10, n10, t107), this.block = s10, this.isReplace = o10, this.mapMode = s10 ? e10 <= 0 ? j.TrackBefore : j.TrackAfter : j.TrackDel;
  }
  get type() {
    return this.startSide != this.endSide ? aj.WidgetRange : this.startSide <= 0 ? aj.WidgetBefore : aj.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e10) {
    var i10, s10;
    return e10 instanceof t69 && ((i10 = this.widget) == (s10 = e10.widget) || !!(i10 && s10 && i10.compare(s10))) && this.block == e10.block && this.startSide == e10.startSide && this.endSide == e10.endSide;
  }
  range(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t107;
    if (this.isReplace && (t107 > e10 || t107 == e10 && this.startSide > 0 && this.endSide <= 0)) throw RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && e10 != t107) throw RangeError("Widget decorations can only have zero-length ranges");
    return super.range(t107, e10);
  }
};
function aJ(t107) {
  let e10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], { inclusiveStart: i10, inclusiveEnd: s10 } = t107;
  return null == i10 && (i10 = t107.inclusive), null == s10 && (s10 = t107.inclusive), { start: null != i10 ? i10 : e10, end: null != s10 ? s10 : e10 };
}
function aQ(t107, e10, i10) {
  let s10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, n10 = i10.length - 1;
  n10 >= 0 && i10[n10] + s10 >= t107 ? i10[n10] = Math.max(i10[n10], e10) : i10.push(t107, e10);
}
aX.prototype.point = true;
let aZ = class t70 {
  constructor(t107, e10, i10, s10) {
    this.doc = t107, this.pos = e10, this.end = i10, this.disallowBlockEffectsFor = s10, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = true, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = t107.iter(), this.skip = e10;
  }
  posCovered() {
    if (0 == this.content.length) return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let t107 = this.content[this.content.length - 1];
    return !(t107.breakAfter || t107 instanceof a_ && t107.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new aq()), this.atCursorPos = true), this.curLine;
  }
  flushBuffer() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.bufferMarks;
    this.pendingBuffer && (this.curLine.append(a0(new aV(-1), t107), t107.length), this.pendingBuffer = 0);
  }
  addBlockWidget(t107) {
    this.flushBuffer(), this.curLine = null, this.content.push(t107);
  }
  finish(t107) {
    this.pendingBuffer && t107 <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, this.posCovered() || t107 && this.content.length && this.content[this.content.length - 1] instanceof a_ || this.getLine();
  }
  buildText(t107, e10, i10) {
    for (; t107 > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: e11, lineBreak: i11, done: s11 } = this.cursor.next(this.skip);
        if (this.skip = 0, s11) throw Error("Ran out of text content when drawing inline views");
        if (i11) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = true, t107--;
          continue;
        }
        this.text = e11, this.textOff = 0;
      }
      let s10 = Math.min(this.text.length - this.textOff, t107, 512);
      this.flushBuffer(e10.slice(e10.length - i10)), this.getLine().append(a0(new aL(this.text.slice(this.textOff, this.textOff + s10)), e10), i10), this.atCursorPos = true, this.textOff += s10, t107 -= s10, i10 = 0;
    }
  }
  span(t107, e10, i10, s10) {
    this.buildText(e10 - t107, i10, s10), this.pos = e10, this.openStart < 0 && (this.openStart = s10);
  }
  point(t107, e10, i10, s10, n10, o10) {
    if (this.disallowBlockEffectsFor[o10] && i10 instanceof aX) {
      if (i10.block) throw RangeError("Block decorations may not be specified via plugins");
      if (e10 > this.doc.lineAt(this.pos).to) throw RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let r10 = e10 - t107;
    if (i10 instanceof aX) {
      if (i10.block) i10.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new a_(i10.widget || a1.block, r10, i10));
      else {
        let o11 = aN.create(i10.widget || a1.inline, r10, r10 ? 0 : i10.startSide), l10 = this.atCursorPos && !o11.isEditable && n10 <= s10.length && (t107 < e10 || i10.startSide > 0), h10 = !o11.isEditable && (t107 < e10 || n10 > s10.length || i10.startSide <= 0), a10 = this.getLine();
        2 != this.pendingBuffer || l10 || o11.isEditable || (this.pendingBuffer = 0), this.flushBuffer(s10), l10 && (a10.append(a0(new aV(1), s10), n10), n10 = s10.length + Math.max(0, n10 - s10.length)), a10.append(a0(o11, s10), n10), this.atCursorPos = h10, this.pendingBuffer = h10 ? t107 < e10 || n10 > s10.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = s10.slice());
      }
    } else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i10);
    r10 && (this.textOff + r10 <= this.text.length ? this.textOff += r10 : (this.skip += r10 - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = e10), this.openStart < 0 && (this.openStart = n10);
  }
  static build(e10, i10, s10, n10, o10) {
    let r10 = new t70(e10, i10, s10, o10);
    return r10.openEnd = tG.spans(n10, i10, s10, r10), r10.openStart < 0 && (r10.openStart = r10.openEnd), r10.finish(r10.openEnd), r10;
  }
};
function a0(t107, e10) {
  for (let i10 of e10) t107 = new aP(i10, [t107], t107.length);
  return t107;
}
let a1 = class extends aG {
  constructor(t107) {
    super(), this.tag = t107;
  }
  eq(t107) {
    return t107.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(t107) {
    return t107.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return true;
  }
};
a1.inline = new a1("span"), a1.block = new a1("div");
var a2 = ((P = a2 || (a2 = {}))[P.LTR = 0] = "LTR", P[P.RTL = 1] = "RTL", P);
let a8 = a2.LTR, a3 = a2.RTL;
function a4(t107) {
  let e10 = [];
  for (let i10 = 0; i10 < t107.length; i10++) e10.push(1 << +t107[i10]);
  return e10;
}
let a9 = a4("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), a5 = a4("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), a6 = /* @__PURE__ */ Object.create(null), a7 = [];
for (let t107 of ["()", "[]", "{}"]) {
  let e10 = t107.charCodeAt(0), i10 = t107.charCodeAt(1);
  a6[e10] = i10, a6[i10] = -e10;
}
function ct(t107) {
  return t107 <= 247 ? a9[t107] : 1424 <= t107 && t107 <= 1524 ? 2 : 1536 <= t107 && t107 <= 1785 ? a5[t107 - 1536] : 1774 <= t107 && t107 <= 2220 ? 4 : 8192 <= t107 && t107 <= 8204 ? 256 : 64336 <= t107 && t107 <= 65023 ? 4 : 1;
}
let ce = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/, ci = class {
  get dir() {
    return this.level % 2 ? a3 : a8;
  }
  constructor(t107, e10, i10) {
    this.from = t107, this.to = e10, this.level = i10;
  }
  side(t107, e10) {
    return this.dir == e10 == t107 ? this.to : this.from;
  }
  forward(t107, e10) {
    return t107 == (this.dir == e10);
  }
  static find(t107, e10, i10, s10) {
    let n10 = -1;
    for (let o10 = 0; o10 < t107.length; o10++) {
      let r10 = t107[o10];
      if (r10.from <= e10 && r10.to >= e10) {
        if (r10.level == i10) return o10;
        (n10 < 0 || (0 != s10 ? s10 < 0 ? r10.from < e10 : r10.to > e10 : t107[n10].level > r10.level)) && (n10 = o10);
      }
    }
    if (n10 < 0) throw RangeError("Index out of range");
    return n10;
  }
}, cs = [];
function cn(t107) {
  return [new ci(0, t107, 0)];
}
let co = "", cr = to.define(), cl = to.define(), ch = to.define(), ca = to.define(), cc = to.define(), cd = to.define(), cu = to.define(), cf = to.define({ combine: (t107) => t107.some((t108) => t108) }), cg = to.define({ combine: (t107) => t107.some((t108) => t108) }), cp = to.define(), cm = class t71 {
  constructor(t107, e10 = "nearest", i10 = "nearest", s10 = 5, n10 = 5, o10 = false) {
    this.range = t107, this.y = e10, this.x = i10, this.yMargin = s10, this.xMargin = n10, this.isSnapshot = o10;
  }
  map(e10) {
    return e10.empty ? this : new t71(this.range.map(e10), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e10) {
    return this.range.to <= e10.doc.length ? this : new t71(ti.cursor(e10.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}, cv = tR.define({ map: (t107, e10) => t107.map(e10) }), cw = tR.define();
function cb(t107, e10, i10) {
  let s10 = t107.facet(ca);
  s10.length ? s10[0](e10) : window.onerror ? window.onerror(String(e10), i10, void 0, void 0, e10) : i10 ? console.error(i10 + ":", e10) : console.error(e10);
}
let cy = to.define({ combine: (t107) => !t107.length || t107[0] }), cx = 0, cS = to.define(), ck = class t72 {
  constructor(t107, e10, i10, s10, n10) {
    this.id = t107, this.create = e10, this.domEventHandlers = i10, this.domEventObservers = s10, this.extension = n10(this);
  }
  static define(e10, i10) {
    let { eventHandlers: s10, eventObservers: n10, provide: o10, decorations: r10 } = i10 || {};
    return new t72(cx++, e10, s10, n10, (t107) => {
      let e11 = [cS.of(t107)];
      return r10 && e11.push(cD.of((e12) => {
        let i11 = e12.plugin(t107);
        return i11 ? r10(i11) : aU.none;
      })), o10 && e11.push(o10(t107)), e11;
    });
  }
  static fromClass(e10, i10) {
    return t72.define((t107) => new e10(t107), i10);
  }
}, cM = class {
  constructor(t107) {
    this.spec = t107, this.mustUpdate = null, this.value = null;
  }
  update(t107) {
    if (this.value) {
      if (this.mustUpdate) {
        let t108 = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update) try {
          this.value.update(t108);
        } catch (e10) {
          if (cb(t108.state, e10, "CodeMirror plugin crashed"), this.value.destroy) try {
            this.value.destroy();
          } catch (t109) {
          }
          this.deactivate();
        }
      }
    } else if (this.spec) try {
      this.value = this.spec.create(t107);
    } catch (e10) {
      cb(t107.state, e10, "CodeMirror plugin crashed"), this.deactivate();
    }
    return this;
  }
  destroy(t107) {
    var e10;
    if (null === (e10 = this.value) || void 0 === e10 ? void 0 : e10.destroy) try {
      this.value.destroy();
    } catch (e11) {
      cb(t107.state, e11, "CodeMirror plugin crashed");
    }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}, cC = to.define(), cA = to.define(), cD = to.define(), cO = to.define(), cT = to.define(), cE = to.define();
function cR(t107, e10) {
  let i10 = t107.state.facet(cE);
  if (!i10.length) return i10;
  let s10 = i10.map((e11) => e11 instanceof Function ? e11(t107) : e11), n10 = [];
  return tG.spans(s10, e10.from, e10.to, { point() {
  }, span(t108, i11, s11, o10) {
    let r10 = t108 - e10.from, l10 = i11 - e10.from, h10 = n10;
    for (let t109 = s11.length - 1; t109 >= 0; t109--, o10--) {
      let i12 = s11[t109].spec.bidiIsolate, n11;
      if (null == i12 && (i12 = function(t110, e11, i13) {
        for (let s12 = e11; s12 < i13; s12++) {
          let e12 = ct(t110.charCodeAt(s12));
          if (1 == e12) break;
          if (2 == e12 || 4 == e12) return a3;
        }
        return a8;
      }(e10.text, r10, l10)), o10 > 0 && h10.length && (n11 = h10[h10.length - 1]).to == r10 && n11.direction == i12) n11.to = l10, h10 = n11.inner;
      else {
        let t110 = { from: r10, to: l10, direction: i12, inner: [] };
        h10.push(t110), h10 = t110.inner;
      }
    }
  } }), n10;
}
let cB = to.define();
function cL(t107) {
  let e10 = 0, i10 = 0, s10 = 0, n10 = 0;
  for (let o10 of t107.state.facet(cB)) {
    let r10 = o10(t107);
    r10 && (null != r10.left && (e10 = Math.max(e10, r10.left)), null != r10.right && (i10 = Math.max(i10, r10.right)), null != r10.top && (s10 = Math.max(s10, r10.top)), null != r10.bottom && (n10 = Math.max(n10, r10.bottom)));
  }
  return { left: e10, right: i10, top: s10, bottom: n10 };
}
let cP = to.define(), cN = class t73 {
  constructor(t107, e10, i10, s10) {
    this.fromA = t107, this.toA = e10, this.fromB = i10, this.toB = s10;
  }
  join(e10) {
    return new t73(Math.min(this.fromA, e10.fromA), Math.max(this.toA, e10.toA), Math.min(this.fromB, e10.fromB), Math.max(this.toB, e10.toB));
  }
  addToSet(t107) {
    let e10 = t107.length, i10 = this;
    for (; e10 > 0; e10--) {
      let s10 = t107[e10 - 1];
      if (!(s10.fromA > i10.toA)) {
        if (s10.toA < i10.fromA) break;
        i10 = i10.join(s10), t107.splice(e10 - 1, 1);
      }
    }
    return t107.splice(e10, 0, i10), t107;
  }
  static extendWithRanges(e10, i10) {
    if (0 == i10.length) return e10;
    let s10 = [];
    for (let n10 = 0, o10 = 0, r10 = 0, l10 = 0; ; n10++) {
      let h10 = n10 == e10.length ? null : e10[n10], a10 = r10 - l10, c10 = h10 ? h10.fromB : 1e9;
      for (; o10 < i10.length && i10[o10] < c10; ) {
        let e11 = i10[o10], n11 = i10[o10 + 1], r11 = Math.max(l10, e11), h11 = Math.min(c10, n11);
        if (r11 <= h11 && new t73(r11 + a10, h11 + a10, r11, h11).addToSet(s10), n11 > c10) break;
        o10 += 2;
      }
      if (!h10) return s10;
      new t73(h10.fromA, h10.toA, h10.fromB, h10.toB).addToSet(s10), r10 = h10.toA, l10 = h10.toB;
    }
  }
}, cV = class t74 {
  constructor(t107, e10, i10) {
    for (let s11 of (this.view = t107, this.state = e10, this.transactions = i10, this.flags = 0, this.startState = t107.state, this.changes = Y.empty(this.startState.doc.length), i10)) this.changes = this.changes.compose(s11.changes);
    let s10 = [];
    this.changes.iterChangedRanges((t108, e11, i11, n10) => s10.push(new cN(t108, e11, i11, n10))), this.changedRanges = s10;
  }
  static create(e10, i10, s10) {
    return new t74(e10, i10, s10);
  }
  get viewportChanged() {
    return (4 & this.flags) > 0;
  }
  get heightChanged() {
    return (2 & this.flags) > 0;
  }
  get geometryChanged() {
    return this.docChanged || (10 & this.flags) > 0;
  }
  get focusChanged() {
    return (1 & this.flags) > 0;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get selectionSet() {
    return this.transactions.some((t107) => t107.selection);
  }
  get empty() {
    return 0 == this.flags && 0 == this.transactions.length;
  }
}, cH = class extends am {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(t107) {
    super(), this.view = t107, this.decorations = [], this.dynamicDecorationMap = [false], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.editContextFormatting = aU.none, this.lastCompositionAfterCursor = false, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = false, this.lastUpdate = Date.now(), this.setDOM(t107.contentDOM), this.children = [new aq()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new cN(0, 0, 0, t107.state.doc.length)], 0, null);
  }
  update(t107) {
    var e10, i10, s10, n10, o10, r10;
    let l10, h10;
    let a10 = t107.changedRanges;
    this.minWidth > 0 && a10.length && (a10.every((t108) => {
      let { fromA: e11, toA: i11 } = t108;
      return i11 < this.minWidthFrom || e11 > this.minWidthTo;
    }) ? (this.minWidthFrom = t107.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = t107.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.updateEditContextFormatting(t107);
    let c10 = -1;
    !(this.view.inputState.composing >= 0) || this.view.observer.editContext || ((null === (e10 = this.domChanged) || void 0 === e10 ? void 0 : e10.newSel) ? c10 = this.domChanged.newSel.head : (i10 = t107.changes, s10 = this.hasComposition, l10 = false, s10 && i10.iterChangedRanges((t108, e11) => {
      t108 < s10.to && e11 > s10.from && (l10 = true);
    }), l10 || t107.selectionSet || (c10 = t107.state.selection.main.head)));
    let d10 = c10 > -1 ? function(t108, e11, i11) {
      let s11 = cW(t108, i11);
      if (!s11) return null;
      let { node: n11, from: o11, to: r11 } = s11, l11 = n11.nodeValue;
      if (/[\n\r]/.test(l11) || t108.state.doc.sliceString(s11.from, s11.to) != l11) return null;
      let h11 = e11.invertedDesc, a11 = new cN(h11.mapPos(o11), h11.mapPos(r11), o11, r11), c11 = [];
      for (let e12 = n11.parentNode; ; e12 = e12.parentNode) {
        let i12 = am.get(e12);
        if (i12 instanceof aP) c11.push({ node: e12, deco: i12.mark });
        else {
          if (i12 instanceof aq || "DIV" == e12.nodeName && e12.parentNode == t108.contentDOM) return { range: a11, text: n11, marks: c11, line: e12 };
          if (e12 == t108.contentDOM) return null;
          c11.push({ node: e12, deco: new aY({ inclusive: true, attributes: function(t109) {
            let e13 = /* @__PURE__ */ Object.create(null);
            for (let i13 = 0; i13 < t109.attributes.length; i13++) {
              let s12 = t109.attributes[i13];
              e13[s12.name] = s12.value;
            }
            return e13;
          }(e12), tagName: e12.tagName.toLowerCase() }) });
        }
      }
    }(this.view, t107.changes, c10) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: e11, to: i11 } = this.hasComposition;
      a10 = new cN(e11, i11, t107.changes.mapPos(e11, -1), t107.changes.mapPos(i11, 1)).addToSet(a10.slice());
    }
    this.hasComposition = d10 ? { from: d10.range.fromB, to: d10.range.toB } : null, (aB.ie || aB.chrome) && !d10 && t107 && t107.state.doc.lines != t107.startState.doc.lines && (this.forceSelection = true);
    let u10 = (n10 = this.decorations, o10 = this.updateDeco(), r10 = t107.changes, h10 = new cI(), tG.compare(n10, o10, r10, h10), h10.changes);
    return a10 = cN.extendWithRanges(a10, u10), (!!(7 & this.flags) || 0 != a10.length) && (this.updateInner(a10, t107.startState.doc.length, d10), t107.transactions.length && (this.lastUpdate = Date.now()), true);
  }
  updateInner(t107, e10, i10) {
    this.view.viewState.mustMeasureContent = true, this.updateChildren(t107, e10, i10);
    let { observer: s10 } = this.view;
    s10.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let t108 = aB.chrome || aB.ios ? { node: s10.selectionRange.focusNode, written: false } : void 0;
      this.sync(this.view, t108), this.flags &= -8, t108 && (t108.written || s10.selectionRange.focusNode != t108.node) && (this.forceSelection = true), this.dom.style.height = "";
    }), this.markedForComposition.forEach((t108) => t108.flags &= -9);
    let n10 = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) for (let t108 of this.children) t108 instanceof a_ && t108.widget instanceof cF && n10.push(t108.dom);
    s10.updateGaps(n10);
  }
  updateChildren(t107, e10, i10) {
    let s10 = i10 ? i10.range.addToSet(t107.slice()) : t107, n10 = this.childCursor(e10);
    for (let t108 = s10.length - 1; ; t108--) {
      let e11 = t108 >= 0 ? s10[t108] : null;
      if (!e11) break;
      let { fromA: o10, toA: r10, fromB: l10, toB: h10 } = e11, a10, c10, d10, u10;
      if (i10 && i10.range.fromB < h10 && i10.range.toB > l10) {
        let t109 = aZ.build(this.view.state.doc, l10, i10.range.fromB, this.decorations, this.dynamicDecorationMap), e12 = aZ.build(this.view.state.doc, i10.range.toB, h10, this.decorations, this.dynamicDecorationMap);
        c10 = t109.breakAtStart, d10 = t109.openStart, u10 = e12.openEnd;
        let s11 = this.compositionView(i10);
        e12.breakAtStart ? s11.breakAfter = 1 : e12.content.length && s11.merge(s11.length, s11.length, e12.content[0], false, e12.openStart, 0) && (s11.breakAfter = e12.content[0].breakAfter, e12.content.shift()), t109.content.length && s11.merge(0, 0, t109.content[t109.content.length - 1], true, 0, t109.openEnd) && t109.content.pop(), a10 = t109.content.concat(s11).concat(e12.content);
      } else ({ content: a10, breakAtStart: c10, openStart: d10, openEnd: u10 } = aZ.build(this.view.state.doc, l10, h10, this.decorations, this.dynamicDecorationMap));
      let { i: f10, off: g10 } = n10.findPos(r10, 1), { i: p10, off: m10 } = n10.findPos(o10, -1);
      ab(this, p10, m10, f10, g10, a10, c10, d10, u10);
    }
    i10 && this.fixCompositionDOM(i10);
  }
  updateEditContextFormatting(t107) {
    for (let e10 of (this.editContextFormatting = this.editContextFormatting.map(t107.changes), t107.transactions)) for (let t108 of e10.effects) t108.is(cw) && (this.editContextFormatting = t108.value);
  }
  compositionView(t107) {
    let e10 = new aL(t107.text.nodeValue);
    for (let { deco: i11 } of (e10.flags |= 8, t107.marks)) e10 = new aP(i11, [e10], e10.length);
    let i10 = new aq();
    return i10.append(e10, 0), i10;
  }
  fixCompositionDOM(t107) {
    let e10 = (t108, e11) => {
      e11.flags |= 8 | (e11.children.some((t109) => 7 & t109.flags) ? 1 : 0), this.markedForComposition.add(e11);
      let i11 = am.get(t108);
      i11 && i11 != e11 && (i11.dom = null), e11.setDOM(t108);
    }, i10 = this.childPos(t107.range.fromB, 1), s10 = this.children[i10.i];
    e10(t107.line, s10);
    for (let n10 = t107.marks.length - 1; n10 >= -1; n10--) i10 = s10.childPos(i10.off, 1), s10 = s10.children[i10.i], e10(n10 >= 0 ? t107.marks[n10].node : t107.text, s10);
  }
  updateSelection() {
    var t107;
    let e10 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], i10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    (e10 || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let s10 = this.view.root.activeElement, n10 = s10 == this.dom, o10 = !n10 && h9(this.dom, this.view.observer.selectionRange) && !(s10 && this.dom.contains(s10));
    if (!(n10 || i10 || o10)) return;
    let r10 = this.forceSelection;
    this.forceSelection = false;
    let l10 = this.view.state.selection.main, h10 = this.moveToLine(this.domAtPos(l10.anchor)), a10 = l10.empty ? h10 : this.moveToLine(this.domAtPos(l10.head));
    if (aB.gecko && l10.empty && !this.hasComposition && 1 == (t107 = h10).node.nodeType && t107.node.firstChild && (0 == t107.offset || "false" == t107.node.childNodes[t107.offset - 1].contentEditable) && (t107.offset == t107.node.childNodes.length || "false" == t107.node.childNodes[t107.offset].contentEditable)) {
      let t108 = document.createTextNode("");
      this.view.observer.ignore(() => h10.node.insertBefore(t108, h10.node.childNodes[h10.offset] || null)), h10 = a10 = new ag(t108, 0), r10 = true;
    }
    let c10 = this.view.observer.selectionRange;
    !r10 && c10.focusNode && (h6(h10.node, h10.offset, c10.anchorNode, c10.anchorOffset) && h6(a10.node, a10.offset, c10.focusNode, c10.focusOffset) || this.suppressWidgetCursorChange(c10, l10)) || (this.view.observer.ignore(() => {
      aB.android && aB.chrome && this.dom.contains(c10.focusNode) && function(t109, e12) {
        for (let i12 = t109; i12 && i12 != e12; i12 = i12.assignedSlot || i12.parentNode) if (1 == i12.nodeType && "false" == i12.contentEditable) return true;
        return false;
      }(c10.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: true }));
      let t108 = h3(this.view.root);
      if (t108) {
        if (l10.empty) {
          if (aB.gecko) {
            var e11, i11;
            let t109 = (e11 = h10.node, i11 = h10.offset, 1 != e11.nodeType ? 0 : (i11 && "false" == e11.childNodes[i11 - 1].contentEditable ? 1 : 0) | (i11 < e11.childNodes.length && "false" == e11.childNodes[i11].contentEditable ? 2 : 0));
            if (t109 && 3 != t109) {
              let e12 = (1 == t109 ? au : af)(h10.node, h10.offset);
              e12 && (h10 = new ag(e12.node, e12.offset));
            }
          }
          t108.collapse(h10.node, h10.offset), null != l10.bidiLevel && void 0 !== t108.caretBidiLevel && (t108.caretBidiLevel = l10.bidiLevel);
        } else if (t108.extend) {
          t108.collapse(h10.node, h10.offset);
          try {
            t108.extend(a10.node, a10.offset);
          } catch (t109) {
          }
        } else {
          let e12 = document.createRange();
          l10.anchor > l10.head && ([h10, a10] = [a10, h10]), e12.setEnd(a10.node, a10.offset), e12.setStart(h10.node, h10.offset), t108.removeAllRanges(), t108.addRange(e12);
        }
      }
      o10 && this.view.root.activeElement == this.dom && (this.dom.blur(), s10 && s10.focus());
    }), this.view.observer.setSelectionRange(h10, a10)), this.impreciseAnchor = h10.precise ? null : new ag(c10.anchorNode, c10.anchorOffset), this.impreciseHead = a10.precise ? null : new ag(c10.focusNode, c10.focusOffset);
  }
  suppressWidgetCursorChange(t107, e10) {
    return this.hasComposition && e10.empty && h6(t107.focusNode, t107.focusOffset, t107.anchorNode, t107.anchorOffset) && this.posFromDOM(t107.focusNode, t107.focusOffset) == e10.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition) return;
    let { view: t107 } = this, e10 = t107.state.selection.main, i10 = h3(t107.root), { anchorNode: s10, anchorOffset: n10 } = t107.observer.selectionRange;
    if (!i10 || !e10.empty || !e10.assoc || !i10.modify) return;
    let o10 = aq.find(this, e10.head);
    if (!o10) return;
    let r10 = o10.posAtStart;
    if (e10.head == r10 || e10.head == r10 + o10.length) return;
    let l10 = this.coordsAt(e10.head, -1), h10 = this.coordsAt(e10.head, 1);
    if (!l10 || !h10 || l10.bottom > h10.top) return;
    let a10 = this.domAtPos(e10.head + e10.assoc);
    i10.collapse(a10.node, a10.offset), i10.modify("move", e10.assoc < 0 ? "forward" : "backward", "lineboundary"), t107.observer.readSelectionRange();
    let c10 = t107.observer.selectionRange;
    t107.docView.posFromDOM(c10.anchorNode, c10.anchorOffset) != e10.from && i10.collapse(s10, n10);
  }
  moveToLine(t107) {
    let e10 = this.dom, i10;
    if (t107.node != e10) return t107;
    for (let s10 = t107.offset; !i10 && s10 < e10.childNodes.length; s10++) {
      let t108 = am.get(e10.childNodes[s10]);
      t108 instanceof aq && (i10 = t108.domAtPos(0));
    }
    for (let s10 = t107.offset - 1; !i10 && s10 >= 0; s10--) {
      let t108 = am.get(e10.childNodes[s10]);
      t108 instanceof aq && (i10 = t108.domAtPos(t108.length));
    }
    return i10 ? new ag(i10.node, i10.offset, true) : t107;
  }
  nearest(t107) {
    for (let e10 = t107; e10; ) {
      let t108 = am.get(e10);
      if (t108 && t108.rootView == this) return t108;
      e10 = e10.parentNode;
    }
    return null;
  }
  posFromDOM(t107, e10) {
    let i10 = this.nearest(t107);
    if (!i10) throw RangeError("Trying to find position for a DOM position outside of the document");
    return i10.localPosFromDOM(t107, e10) + i10.posAtStart;
  }
  domAtPos(t107) {
    let { i: e10, off: i10 } = this.childCursor().findPos(t107, -1);
    for (; e10 < this.children.length - 1; ) {
      let t108 = this.children[e10];
      if (i10 < t108.length || t108 instanceof aq) break;
      e10++, i10 = 0;
    }
    return this.children[e10].domAtPos(i10);
  }
  coordsAt(t107, e10) {
    let i10 = null, s10 = 0;
    for (let n10 = this.length, o10 = this.children.length - 1; o10 >= 0; o10--) {
      let r10 = this.children[o10], l10 = n10 - r10.breakAfter, h10 = l10 - r10.length;
      if (l10 < t107) break;
      if (h10 <= t107 && (h10 < t107 || r10.covers(-1)) && (l10 > t107 || r10.covers(1)) && (!i10 || r10 instanceof aq && !(i10 instanceof aq && e10 >= 0))) i10 = r10, s10 = h10;
      else if (i10 && h10 == t107 && l10 == t107 && r10 instanceof a_ && 2 > Math.abs(e10)) {
        if (r10.deco.startSide < 0) break;
        o10 && (i10 = null);
      }
      n10 = h10;
    }
    return i10 ? i10.coordsAt(t107 - s10, e10) : null;
  }
  coordsForChar(t107) {
    let { i: e10, off: i10 } = this.childPos(t107, 1), s10 = this.children[e10];
    if (!(s10 instanceof aq)) return null;
    for (; s10.children.length; ) {
      let { i: t108, off: e11 } = s10.childPos(i10, 1);
      for (; ; t108++) {
        if (t108 == s10.children.length) return null;
        if ((s10 = s10.children[t108]).length) break;
      }
      i10 = e11;
    }
    if (!(s10 instanceof aL)) return null;
    let n10 = v(s10.text, i10);
    if (n10 == i10) return null;
    let o10 = ah(s10.dom, i10, n10).getClientRects();
    for (let t108 = 0; t108 < o10.length; t108++) {
      let e11 = o10[t108];
      if (t108 == o10.length - 1 || e11.top < e11.bottom && e11.left < e11.right) return e11;
    }
    return null;
  }
  measureVisibleLineHeights(t107) {
    let e10 = [], { from: i10, to: s10 } = t107, n10 = this.view.contentDOM.clientWidth, o10 = n10 > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, r10 = -1, l10 = this.view.textDirection == a2.LTR;
    for (let t108 = 0, h10 = 0; h10 < this.children.length; h10++) {
      let a10 = this.children[h10], c10 = t108 + a10.length;
      if (c10 > s10) break;
      if (t108 >= i10) {
        let i11 = a10.dom.getBoundingClientRect();
        if (e10.push(i11.height), o10) {
          let e11 = a10.dom.lastChild, s11 = e11 ? h5(e11) : [];
          if (s11.length) {
            let e12 = s11[s11.length - 1], o11 = l10 ? e12.right - i11.left : i11.right - e12.left;
            o11 > r10 && (r10 = o11, this.minWidth = n10, this.minWidthFrom = t108, this.minWidthTo = c10);
          }
        }
      }
      t108 = c10 + a10.breakAfter;
    }
    return e10;
  }
  textDirectionAt(t107) {
    let { i: e10 } = this.childPos(t107, 1);
    return "rtl" == getComputedStyle(this.children[e10].dom).direction ? a2.RTL : a2.LTR;
  }
  measureTextSize() {
    for (let t108 of this.children) if (t108 instanceof aq) {
      let e11 = t108.measureTextSize();
      if (e11) return e11;
    }
    let t107 = document.createElement("div"), e10, i10, s10;
    return t107.className = "cm-line", t107.style.width = "99999px", t107.style.position = "absolute", t107.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(t107);
      let n10 = h5(t107.firstChild)[0];
      e10 = t107.getBoundingClientRect().height, i10 = n10 ? n10.width / 27 : 7, s10 = n10 ? n10.height : e10, t107.remove();
    }), { lineHeight: e10, charWidth: i10, textHeight: s10 };
  }
  childCursor() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.length, e10 = this.children.length;
    return e10 && (t107 -= this.children[--e10].length), new aw(this.children, t107, e10);
  }
  computeBlockGapDeco() {
    let t107 = [], e10 = this.view.viewState;
    for (let i10 = 0, s10 = 0; ; s10++) {
      let n10 = s10 == e10.viewports.length ? null : e10.viewports[s10], o10 = n10 ? n10.from - 1 : this.length;
      if (o10 > i10) {
        let s11 = (e10.lineBlockAt(o10).bottom - e10.lineBlockAt(i10).top) / this.view.scaleY;
        t107.push(aU.replace({ widget: new cF(s11), block: true, inclusive: true, isBlockGap: true }).range(i10, o10));
      }
      if (!n10) break;
      i10 = n10.to + 1;
    }
    return aU.set(t107);
  }
  updateDeco() {
    let t107 = 1, e10 = this.view.state.facet(cD).map((e11) => (this.dynamicDecorationMap[t107++] = "function" == typeof e11) ? e11(this.view) : e11), i10 = false, s10 = this.view.state.facet(cO).map((t108, e11) => {
      let s11 = "function" == typeof t108;
      return s11 && (i10 = true), s11 ? t108(this.view) : t108;
    });
    for (s10.length && (this.dynamicDecorationMap[t107++] = i10, e10.push(tG.join(s10))), this.decorations = [this.editContextFormatting, ...e10, this.computeBlockGapDeco(), this.view.viewState.lineGapDeco]; t107 < this.decorations.length; ) this.dynamicDecorationMap[t107++] = false;
    return this.decorations;
  }
  scrollIntoView(t107) {
    if (t107.isSnapshot) {
      let e11 = this.view.viewState.lineBlockAt(t107.range.head);
      this.view.scrollDOM.scrollTop = e11.top - t107.yMargin, this.view.scrollDOM.scrollLeft = t107.xMargin;
      return;
    }
    for (let e11 of this.view.state.facet(cp)) try {
      if (e11(this.view, t107.range, t107)) return true;
    } catch (t108) {
      cb(this.view.state, t108, "scroll handler");
    }
    let { range: e10 } = t107, i10 = this.coordsAt(e10.head, e10.empty ? e10.assoc : e10.head > e10.anchor ? -1 : 1), s10;
    if (!i10) return;
    !e10.empty && (s10 = this.coordsAt(e10.anchor, e10.anchor > e10.head ? -1 : 1)) && (i10 = { left: Math.min(i10.left, s10.left), top: Math.min(i10.top, s10.top), right: Math.max(i10.right, s10.right), bottom: Math.max(i10.bottom, s10.bottom) });
    let n10 = cL(this.view), o10 = { left: i10.left - n10.left, top: i10.top - n10.top, right: i10.right + n10.right, bottom: i10.bottom + n10.bottom }, { offsetWidth: r10, offsetHeight: l10 } = this.view.scrollDOM;
    !function(t108, e11, i11, s11, n11, o11, r11, l11) {
      let h10 = t108.ownerDocument, a10 = h10.defaultView || window;
      for (let c10 = t108, d10 = false; c10 && !d10; ) if (1 == c10.nodeType) {
        let t109, u10 = c10 == h10.body, f10 = 1, g10 = 1;
        if (u10) t109 = function(t110) {
          let e12 = t110.visualViewport;
          return e12 ? { left: 0, right: e12.width, top: 0, bottom: e12.height } : { left: 0, right: t110.innerWidth, top: 0, bottom: t110.innerHeight };
        }(a10);
        else {
          if (/^(fixed|sticky)$/.test(getComputedStyle(c10).position) && (d10 = true), c10.scrollHeight <= c10.clientHeight && c10.scrollWidth <= c10.clientWidth) {
            c10 = c10.assignedSlot || c10.parentNode;
            continue;
          }
          let e12 = c10.getBoundingClientRect();
          ({ scaleX: f10, scaleY: g10 } = an(c10, e12)), t109 = { left: e12.left, right: e12.left + c10.clientWidth * f10, top: e12.top, bottom: e12.top + c10.clientHeight * g10 };
        }
        let p10 = 0, m10 = 0;
        if ("nearest" == n11) e11.top < t109.top ? (m10 = -(t109.top - e11.top + r11), i11 > 0 && e11.bottom > t109.bottom + m10 && (m10 = e11.bottom - t109.bottom + m10 + r11)) : e11.bottom > t109.bottom && (m10 = e11.bottom - t109.bottom + r11, i11 < 0 && e11.top - m10 < t109.top && (m10 = -(t109.top + m10 - e11.top + r11)));
        else {
          let s12 = e11.bottom - e11.top, o12 = t109.bottom - t109.top;
          m10 = ("center" == n11 && s12 <= o12 ? e11.top + s12 / 2 - o12 / 2 : "start" == n11 || "center" == n11 && i11 < 0 ? e11.top - r11 : e11.bottom - o12 + r11) - t109.top;
        }
        if ("nearest" == s11 ? e11.left < t109.left ? (p10 = -(t109.left - e11.left + o11), i11 > 0 && e11.right > t109.right + p10 && (p10 = e11.right - t109.right + p10 + o11)) : e11.right > t109.right && (p10 = e11.right - t109.right + o11, i11 < 0 && e11.left < t109.left + p10 && (p10 = -(t109.left + p10 - e11.left + o11))) : p10 = ("center" == s11 ? e11.left + (e11.right - e11.left) / 2 - (t109.right - t109.left) / 2 : "start" == s11 == l11 ? e11.left - o11 : e11.right - (t109.right - t109.left) + o11) - t109.left, p10 || m10) {
          if (u10) a10.scrollBy(p10, m10);
          else {
            let t110 = 0, i12 = 0;
            if (m10) {
              let t111 = c10.scrollTop;
              c10.scrollTop += m10 / g10, i12 = (c10.scrollTop - t111) * g10;
            }
            if (p10) {
              let e12 = c10.scrollLeft;
              c10.scrollLeft += p10 / f10, t110 = (c10.scrollLeft - e12) * f10;
            }
            e11 = { left: e11.left - t110, top: e11.top - i12, right: e11.right - t110, bottom: e11.bottom - i12 }, t110 && 1 > Math.abs(t110 - p10) && (s11 = "nearest"), i12 && 1 > Math.abs(i12 - m10) && (n11 = "nearest");
          }
        }
        if (u10) break;
        c10 = c10.assignedSlot || c10.parentNode;
      } else if (11 == c10.nodeType) c10 = c10.host;
      else break;
    }(this.view.scrollDOM, o10, e10.head < e10.anchor ? -1 : 1, t107.x, t107.y, Math.max(Math.min(t107.xMargin, r10), -r10), Math.max(Math.min(t107.yMargin, l10), -l10), this.view.textDirection == a2.LTR);
  }
}, cF = class extends aG {
  constructor(t107) {
    super(), this.height = t107;
  }
  toDOM() {
    let t107 = document.createElement("div");
    return t107.className = "cm-gap", this.updateDOM(t107), t107;
  }
  eq(t107) {
    return t107.height == this.height;
  }
  updateDOM(t107) {
    return t107.style.height = this.height + "px", true;
  }
  get editable() {
    return true;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return false;
  }
};
function cW(t107, e10) {
  let i10 = t107.observer.selectionRange;
  if (!i10.focusNode) return null;
  let s10 = au(i10.focusNode, i10.focusOffset), n10 = af(i10.focusNode, i10.focusOffset), o10 = s10 || n10;
  if (n10 && s10 && n10.node != s10.node) {
    let e11 = am.get(n10.node);
    if (!e11 || e11 instanceof aL && e11.text != n10.node.nodeValue) o10 = n10;
    else if (t107.docView.lastCompositionAfterCursor) {
      let t108 = am.get(s10.node);
      !t108 || t108 instanceof aL && t108.text != s10.node.nodeValue || (o10 = n10);
    }
  }
  if (t107.docView.lastCompositionAfterCursor = o10 != s10, !o10) return null;
  let r10 = e10 - o10.offset;
  return { from: r10, to: r10 + o10.node.nodeValue.length, node: o10.node };
}
let cI = class {
  constructor() {
    this.changes = [];
  }
  compareRange(t107, e10) {
    aQ(t107, e10, this.changes);
  }
  comparePoint(t107, e10) {
    aQ(t107, e10, this.changes);
  }
};
function cz(t107, e10) {
  return t107.top < e10.bottom - 1 && t107.bottom > e10.top + 1;
}
function cK(t107, e10) {
  return e10 < t107.top ? { top: e10, left: t107.left, right: t107.right, bottom: t107.bottom } : t107;
}
function cq(t107, e10) {
  return e10 > t107.bottom ? { top: t107.top, left: t107.left, right: t107.right, bottom: e10 } : t107;
}
function c_(t107, e10, i10) {
  let s10 = t107.nodeValue.length, n10 = -1, o10 = 1e9, r10 = 0;
  for (let l10 = 0; l10 < s10; l10++) {
    let s11 = ah(t107, l10, l10 + 1).getClientRects();
    for (let h10 = 0; h10 < s11.length; h10++) {
      let a10 = s11[h10];
      if (a10.top == a10.bottom) continue;
      r10 || (r10 = e10 - a10.left);
      let c10 = (a10.top > i10 ? a10.top - i10 : i10 - a10.bottom) - 1;
      if (a10.left - 1 <= e10 && a10.right + 1 >= e10 && c10 < o10) {
        let i11 = e10 >= (a10.left + a10.right) / 2, s12 = i11;
        if ((aB.chrome || aB.gecko) && ah(t107, l10).getBoundingClientRect().left == a10.right && (s12 = !i11), c10 <= 0) return { node: t107, offset: l10 + (s12 ? 1 : 0) };
        n10 = l10 + (s12 ? 1 : 0), o10 = c10;
      }
    }
  }
  return { node: t107, offset: n10 > -1 ? n10 : r10 > 0 ? t107.nodeValue.length : 0 };
}
function cG(t107, e10, i10) {
  var s10, n10;
  let o10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : -1, r10 = t107.contentDOM.getBoundingClientRect(), l10 = r10.top + t107.viewState.paddingTop, h10, { docHeight: a10 } = t107.viewState, { x: c10, y: d10 } = e10, u10 = d10 - l10;
  if (u10 < 0) return 0;
  if (u10 > a10) return t107.state.doc.length;
  for (let e11 = t107.viewState.heightOracle.textHeight / 2, s11 = false; (h10 = t107.elementAtHeight(u10)).type != aj.Text; ) for (; !((u10 = o10 > 0 ? h10.bottom + e11 : h10.top - e11) >= 0) || !(u10 <= a10); ) {
    if (s11) return i10 ? null : 0;
    s11 = true, o10 = -o10;
  }
  d10 = l10 + u10;
  let f10 = h10.from;
  if (f10 < t107.viewport.from) return 0 == t107.viewport.from ? 0 : i10 ? null : cj(t107, r10, h10, c10, d10);
  if (f10 > t107.viewport.to) return t107.viewport.to == t107.state.doc.length ? t107.state.doc.length : i10 ? null : cj(t107, r10, h10, c10, d10);
  let g10 = t107.dom.ownerDocument, p10 = t107.root.elementFromPoint ? t107.root : g10, m10 = p10.elementFromPoint(c10, d10);
  m10 && !t107.contentDOM.contains(m10) && (m10 = null), !m10 && (c10 = Math.max(r10.left + 1, Math.min(r10.right - 1, c10)), (m10 = p10.elementFromPoint(c10, d10)) && !t107.contentDOM.contains(m10) && (m10 = null));
  let v10, w10 = -1;
  if (m10 && (null === (s10 = t107.docView.nearest(m10)) || void 0 === s10 ? void 0 : s10.isEditable) != false) {
    if (g10.caretPositionFromPoint) {
      let t108 = g10.caretPositionFromPoint(c10, d10);
      t108 && ({ offsetNode: v10, offset: w10 } = t108);
    } else if (g10.caretRangeFromPoint) {
      let e11 = g10.caretRangeFromPoint(c10, d10);
      e11 && ({ startContainer: v10, startOffset: w10 } = e11, (!t107.contentDOM.contains(v10) || aB.safari && function(t108, e12, i11) {
        let s11;
        if (3 != t108.nodeType || e12 != (s11 = t108.nodeValue.length)) return false;
        for (let e13 = t108.nextSibling; e13; e13 = e13.nextSibling) if (1 != e13.nodeType || "BR" != e13.nodeName) return false;
        return ah(t108, s11 - 1, s11).getBoundingClientRect().left > i11;
      }(v10, w10, c10) || aB.chrome && function(t108, e12, i11) {
        if (0 != e12) return false;
        for (let e13 = t108; ; ) {
          let t109 = e13.parentNode;
          if (!t109 || 1 != t109.nodeType || t109.firstChild != e13) return false;
          if (t109.classList.contains("cm-line")) break;
          e13 = t109;
        }
        return i11 - (1 == t108.nodeType ? t108.getBoundingClientRect() : ah(t108, 0, Math.max(t108.nodeValue.length, 1)).getBoundingClientRect()).left > 5;
      }(v10, w10, c10)) && (v10 = void 0));
    }
  }
  if (!v10 || !t107.docView.dom.contains(v10)) {
    let e11 = aq.find(t107.docView, f10);
    if (!e11) return u10 > h10.top + h10.height / 2 ? h10.to : h10.from;
    ({ node: v10, offset: w10 } = function t108(e12, i11, s11) {
      let n11, o11, r11, l11, h11, a11, c11, d11, u11 = false;
      for (let p12 = e12.firstChild; p12; p12 = p12.nextSibling) {
        let e13 = h5(p12);
        for (let m12 = 0; m12 < e13.length; m12++) {
          var f11, g11;
          let v11 = e13[m12];
          a11 && cz(a11, v11) && (v11 = cK(cq(v11, a11.bottom), a11.top));
          let w11 = (f11 = v11).left > i11 ? f11.left - i11 : Math.max(0, i11 - f11.right), b11 = (g11 = v11).top > s11 ? g11.top - s11 : Math.max(0, s11 - g11.bottom);
          if (0 == w11 && 0 == b11) return 3 == p12.nodeType ? c_(p12, i11, s11) : t108(p12, i11, s11);
          if (!h11 || d11 > b11 || d11 == b11 && c11 > w11) {
            h11 = p12, a11 = v11, c11 = w11, d11 = b11;
            let t109 = b11 ? s11 < v11.top ? -1 : 1 : w11 ? i11 < v11.left ? -1 : 1 : 0;
            u11 = !t109 || (t109 > 0 ? m12 < e13.length - 1 : m12 > 0);
          }
          0 == w11 ? s11 > v11.bottom && (!r11 || r11.bottom < v11.bottom) ? (n11 = p12, r11 = v11) : s11 < v11.top && (!l11 || l11.top > v11.top) && (o11 = p12, l11 = v11) : r11 && cz(r11, v11) ? r11 = cq(r11, v11.bottom) : l11 && cz(l11, v11) && (l11 = cK(l11, v11.top));
        }
      }
      if (r11 && r11.bottom >= s11 ? (h11 = n11, a11 = r11) : l11 && l11.top <= s11 && (h11 = o11, a11 = l11), !h11) return { node: e12, offset: 0 };
      let p11 = Math.max(a11.left, Math.min(a11.right, i11));
      if (3 == h11.nodeType) return c_(h11, p11, s11);
      if (u11 && "false" != h11.contentEditable) return t108(h11, p11, s11);
      let m11 = Array.prototype.indexOf.call(e12.childNodes, h11) + (i11 >= (a11.left + a11.right) / 2 ? 1 : 0);
      return { node: e12, offset: m11 };
    }(e11.dom, c10, d10));
  }
  let b10 = t107.docView.nearest(v10);
  if (!b10) return null;
  if (!b10.isWidget || (null === (n10 = b10.dom) || void 0 === n10 ? void 0 : n10.nodeType) != 1) return b10.localPosFromDOM(v10, w10) + b10.posAtStart;
  {
    let t108 = b10.dom.getBoundingClientRect();
    return e10.y < t108.top || e10.y <= t108.bottom && e10.x <= (t108.left + t108.right) / 2 ? b10.posAtStart : b10.posAtEnd;
  }
}
function cj(t107, e10, i10, s10, n10) {
  let o10 = Math.round((s10 - e10.left) * t107.defaultCharacterWidth);
  if (t107.lineWrapping && i10.height > 1.5 * t107.defaultLineHeight) {
    let e11 = t107.viewState.heightOracle.textHeight;
    o10 += Math.floor((n10 - i10.top - (t107.defaultLineHeight - e11) * 0.5) / e11) * t107.viewState.heightOracle.lineLength;
  }
  let r10 = t107.state.sliceDoc(i10.from, i10.to);
  return i10.from + t3(r10, o10, t107.state.tabSize);
}
function cU(t107, e10, i10, s10) {
  let n10 = t107.state.doc.lineAt(e10.head), o10 = t107.bidiSpans(n10), r10 = t107.textDirectionAt(n10.from);
  for (let l10 = e10, h10 = null; ; ) {
    let e11 = function(t108, e12, i11, s11, n11) {
      var o11;
      let r11 = s11.head - t108.from, l11 = ci.find(e12, r11, null !== (o11 = s11.bidiLevel) && void 0 !== o11 ? o11 : -1, s11.assoc), h11 = e12[l11], a11 = h11.side(n11, i11);
      if (r11 == a11) {
        let t109 = l11 += n11 ? 1 : -1;
        if (t109 < 0 || t109 >= e12.length) return null;
        r11 = (h11 = e12[l11 = t109]).side(!n11, i11), a11 = h11.side(n11, i11);
      }
      let c10 = v(t108.text, r11, h11.forward(n11, i11));
      (c10 < h11.from || c10 > h11.to) && (c10 = a11), co = t108.text.slice(Math.min(r11, c10), Math.max(r11, c10));
      let d10 = l11 == (n11 ? e12.length - 1 : 0) ? null : e12[l11 + (n11 ? 1 : -1)];
      return d10 && c10 == a11 && d10.level + (n11 ? 0 : 1) < h11.level ? ti.cursor(d10.side(!n11, i11) + t108.from, d10.forward(n11, i11) ? 1 : -1, d10.level) : ti.cursor(c10 + t108.from, h11.forward(n11, i11) ? -1 : 1, h11.level);
    }(n10, o10, r10, l10, i10), a10 = co;
    if (!e11) {
      if (n10.number == (i10 ? t107.state.doc.lines : 1)) return l10;
      a10 = "\n", n10 = t107.state.doc.line(n10.number + (i10 ? 1 : -1)), o10 = t107.bidiSpans(n10), e11 = t107.visualLineSide(n10, !i10);
    }
    if (h10) {
      if (!h10(a10)) return l10;
    } else {
      if (!s10) return e11;
      h10 = s10(a10);
    }
    l10 = e11;
  }
}
function cY(t107, e10, i10) {
  for (; ; ) {
    let s10 = 0;
    for (let n10 of t107) n10.between(e10 - 1, e10 + 1, (t108, n11, o10) => {
      if (e10 > t108 && e10 < n11) {
        let o11 = s10 || i10 || (e10 - t108 < n11 - e10 ? -1 : 1);
        e10 = o11 < 0 ? t108 : n11, s10 = o11;
      }
    });
    if (!s10) return e10;
  }
}
function c$(t107, e10, i10) {
  let s10 = cY(t107.state.facet(cT).map((e11) => e11(t107)), i10.from, e10.head > i10.from ? -1 : 1);
  return s10 == i10.from ? i10 : ti.cursor(s10, s10 < i10.from ? 1 : -1);
}
let cX = class {
  setSelectionOrigin(t107) {
    this.lastSelectionOrigin = t107, this.lastSelectionTime = Date.now();
  }
  constructor(t107) {
    var e10;
    this.view = t107, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = false, this.compositionPendingChange = false, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = t107.hasFocus, aB.safari && t107.contentDOM.addEventListener("input", () => null), aB.gecko && (e10 = t107.contentDOM.ownerDocument, du.has(e10) || (du.add(e10), e10.addEventListener("copy", () => {
    }), e10.addEventListener("cut", () => {
    })));
  }
  handleEvent(t107) {
    !(!function(t108, e10) {
      if (!e10.bubbles) return true;
      if (e10.defaultPrevented) return false;
      for (let i10 = e10.target, s10; i10 != t108.contentDOM; i10 = i10.parentNode) if (!i10 || 11 == i10.nodeType || (s10 = am.get(i10)) && s10.ignoreEvent(e10)) return false;
      return true;
    }(this.view, t107) || this.ignoreDuringComposition(t107)) && ("keydown" == t107.type && this.keydown(t107) || this.runHandlers(t107.type, t107));
  }
  runHandlers(t107, e10) {
    let i10 = this.handlers[t107];
    if (i10) {
      for (let t108 of i10.observers) t108(this.view, e10);
      for (let t108 of i10.handlers) {
        if (e10.defaultPrevented) break;
        if (t108(this.view, e10)) {
          e10.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(t107) {
    let e10 = function(t108) {
      let e11 = /* @__PURE__ */ Object.create(null);
      function i11(t109) {
        return e11[t109] || (e11[t109] = { observers: [], handlers: [] });
      }
      for (let e12 of t108) {
        let t109 = e12.spec;
        if (t109 && t109.domEventHandlers) for (let s11 in t109.domEventHandlers) {
          let n10 = t109.domEventHandlers[s11];
          n10 && i11(s11).handlers.push(cJ(e12.value, n10));
        }
        if (t109 && t109.domEventObservers) for (let s11 in t109.domEventObservers) {
          let n10 = t109.domEventObservers[s11];
          n10 && i11(s11).observers.push(cJ(e12.value, n10));
        }
      }
      for (let t109 in c8) i11(t109).handlers.push(c8[t109]);
      for (let t109 in c3) i11(t109).observers.push(c3[t109]);
      return e11;
    }(t107), i10 = this.handlers, s10 = this.view.contentDOM;
    for (let t108 in e10) if ("scroll" != t108) {
      let n10 = !e10[t108].handlers.length, o10 = i10[t108];
      o10 && !o10.handlers.length != n10 && (s10.removeEventListener(t108, this.handleEvent), o10 = null), o10 || s10.addEventListener(t108, this.handleEvent, { passive: n10 });
    }
    for (let t108 in i10) "scroll" == t108 || e10[t108] || s10.removeEventListener(t108, this.handleEvent);
    this.handlers = e10;
  }
  keydown(t107) {
    let e10;
    return this.lastKeyCode = t107.keyCode, this.lastKeyTime = Date.now(), !!(9 == t107.keyCode && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode)) || ((this.tabFocusMode > 0 && 27 != t107.keyCode && 0 > c0.indexOf(t107.keyCode) && (this.tabFocusMode = -1), aB.android && aB.chrome && !t107.synthetic && (13 == t107.keyCode || 8 == t107.keyCode)) ? (this.view.observer.delayAndroidKey(t107.key, t107.keyCode), true) : aB.ios && !t107.synthetic && !t107.altKey && !t107.metaKey && ((e10 = cQ.find((e11) => e11.keyCode == t107.keyCode)) && !t107.ctrlKey || cZ.indexOf(t107.key) > -1 && t107.ctrlKey && !t107.shiftKey) ? (this.pendingIOSKey = e10 || t107, setTimeout(() => this.flushIOSKey(), 250), true) : (229 != t107.keyCode && this.view.observer.forceFlush(), false));
  }
  flushIOSKey(t107) {
    let e10 = this.pendingIOSKey;
    return !(!e10 || "Enter" == e10.key && t107 && t107.from < t107.to && /^\S+$/.test(t107.insert.toString())) && (this.pendingIOSKey = void 0, aa(this.view.contentDOM, e10.key, e10.keyCode, e10 instanceof KeyboardEvent ? e10 : void 0));
  }
  ignoreDuringComposition(t107) {
    return !!/^key/.test(t107.type) && (this.composing > 0 || !!(aB.safari && !aB.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) && (this.compositionPendingKey = false, true));
  }
  startMouseSelection(t107) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = t107;
  }
  update(t107) {
    this.view.observer.update(t107), this.mouseSelection && this.mouseSelection.update(t107), this.draggedContent && t107.docChanged && (this.draggedContent = this.draggedContent.map(t107.changes)), t107.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
};
function cJ(t107, e10) {
  return (i10, s10) => {
    try {
      return e10.call(t107, s10, i10);
    } catch (t108) {
      cb(i10.state, t108);
    }
  };
}
let cQ = [{ key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" }, { key: "Enter", keyCode: 13, inputType: "insertParagraph" }, { key: "Enter", keyCode: 13, inputType: "insertLineBreak" }, { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }], cZ = "dthko", c0 = [16, 17, 18, 20, 91, 92, 224, 225];
function c1(t107) {
  return 0.7 * Math.max(0, t107) + 8;
}
let c2 = class {
  constructor(t107, e10, i10, s10) {
    let n10;
    this.view = t107, this.startEvent = e10, this.style = i10, this.mustSelect = s10, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = e10, this.scrollParents = function(t108) {
      let e11 = t108.ownerDocument, i11, s11;
      for (let n11 = t108.parentNode; n11 && n11 != e11.body && (!i11 || !s11); ) if (1 == n11.nodeType) !s11 && n11.scrollHeight > n11.clientHeight && (s11 = n11), !i11 && n11.scrollWidth > n11.clientWidth && (i11 = n11), n11 = n11.assignedSlot || n11.parentNode;
      else if (11 == n11.nodeType) n11 = n11.host;
      else break;
      return { x: i11, y: s11 };
    }(t107.contentDOM), this.atoms = t107.state.facet(cT).map((e11) => e11(t107));
    let o10 = t107.contentDOM.ownerDocument;
    o10.addEventListener("mousemove", this.move = this.move.bind(this)), o10.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = e10.shiftKey, this.multiple = t107.state.facet(tW.allowMultipleSelections) && ((n10 = t107.state.facet(cr)).length ? n10[0](e10) : aB.mac ? e10.metaKey : e10.ctrlKey), this.dragging = !!function(t108, e11) {
      let { main: i11 } = t108.state.selection;
      if (i11.empty) return false;
      let s11 = h3(t108.root);
      if (!s11 || 0 == s11.rangeCount) return true;
      let n11 = s11.getRangeAt(0).getClientRects();
      for (let t109 = 0; t109 < n11.length; t109++) {
        let i12 = n11[t109];
        if (i12.left <= e11.clientX && i12.right >= e11.clientX && i12.top <= e11.clientY && i12.bottom >= e11.clientY) return true;
      }
      return false;
    }(t107, e10) && 1 == dr(e10) && null;
  }
  start(t107) {
    false === this.dragging && this.select(t107);
  }
  move(t107) {
    var e10;
    if (0 == t107.buttons) return this.destroy();
    if (this.dragging || null == this.dragging && 10 > Math.max(Math.abs((e10 = this.startEvent).clientX - t107.clientX), Math.abs(e10.clientY - t107.clientY))) return;
    this.select(this.lastEvent = t107);
    let i10 = 0, s10 = 0, n10 = 0, o10 = 0, r10 = this.view.win.innerWidth, l10 = this.view.win.innerHeight;
    this.scrollParents.x && ({ left: n10, right: r10 } = this.scrollParents.x.getBoundingClientRect()), this.scrollParents.y && ({ top: o10, bottom: l10 } = this.scrollParents.y.getBoundingClientRect());
    let h10 = cL(this.view);
    t107.clientX - h10.left <= n10 + 6 ? i10 = -c1(n10 - t107.clientX) : t107.clientX + h10.right >= r10 - 6 && (i10 = c1(t107.clientX - r10)), t107.clientY - h10.top <= o10 + 6 ? s10 = -c1(o10 - t107.clientY) : t107.clientY + h10.bottom >= l10 - 6 && (s10 = c1(t107.clientY - l10)), this.setScrollSpeed(i10, s10);
  }
  up(t107) {
    null == this.dragging && this.select(this.lastEvent), this.dragging || t107.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let t107 = this.view.contentDOM.ownerDocument;
    t107.removeEventListener("mousemove", this.move), t107.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(t107, e10) {
    this.scrollSpeed = { x: t107, y: e10 }, t107 || e10 ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    let { x: t107, y: e10 } = this.scrollSpeed;
    t107 && this.scrollParents.x && (this.scrollParents.x.scrollLeft += t107, t107 = 0), e10 && this.scrollParents.y && (this.scrollParents.y.scrollTop += e10, e10 = 0), (t107 || e10) && this.view.win.scrollBy(t107, e10), false === this.dragging && this.select(this.lastEvent);
  }
  skipAtoms(t107) {
    let e10 = null;
    for (let i10 = 0; i10 < t107.ranges.length; i10++) {
      let s10 = t107.ranges[i10], n10 = null;
      if (s10.empty) {
        let t108 = cY(this.atoms, s10.from, 0);
        t108 != s10.from && (n10 = ti.cursor(t108, -1));
      } else {
        let t108 = cY(this.atoms, s10.from, -1), e11 = cY(this.atoms, s10.to, 1);
        (t108 != s10.from || e11 != s10.to) && (n10 = ti.range(s10.from == s10.anchor ? t108 : e11, s10.from == s10.head ? t108 : e11));
      }
      n10 && (e10 || (e10 = t107.ranges.slice()), e10[i10] = n10);
    }
    return e10 ? ti.create(e10, t107.mainIndex) : t107;
  }
  select(t107) {
    let { view: e10 } = this, i10 = this.skipAtoms(this.style.get(t107, this.extend, this.multiple));
    (this.mustSelect || !i10.eq(e10.state.selection, false === this.dragging)) && this.view.dispatch({ selection: i10, userEvent: "select.pointer" }), this.mustSelect = false;
  }
  update(t107) {
    t107.transactions.some((t108) => t108.isUserEvent("input.type")) ? this.destroy() : this.style.update(t107) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}, c8 = /* @__PURE__ */ Object.create(null), c3 = /* @__PURE__ */ Object.create(null), c4 = aB.ie && aB.ie_version < 15 || aB.ios && aB.webkit_version < 604;
function c9(t107, e10) {
  let { state: i10 } = t107, s10, n10 = 1, o10 = i10.toText(e10), r10 = o10.lines == i10.selection.ranges.length;
  if (null != dh && i10.selection.ranges.every((t108) => t108.empty) && dh == o10.toString()) {
    let t108 = -1;
    s10 = i10.changeByRange((s11) => {
      let l10 = i10.doc.lineAt(s11.from);
      if (l10.from == t108) return { range: s11 };
      t108 = l10.from;
      let h10 = i10.toText((r10 ? o10.line(n10++).text : e10) + i10.lineBreak);
      return { changes: { from: l10.from, insert: h10 }, range: ti.cursor(s11.from + h10.length) };
    });
  } else s10 = r10 ? i10.changeByRange((t108) => {
    let e11 = o10.line(n10++);
    return { changes: { from: t108.from, to: t108.to, insert: e11.text }, range: ti.cursor(t108.from + e11.length) };
  }) : i10.replaceSelection(o10);
  t107.dispatch(s10, { userEvent: "input.paste", scrollIntoView: true });
}
function c5(t107, e10, i10, s10) {
  if (1 == s10) return ti.cursor(e10, i10);
  if (2 == s10) return function(t108, e11) {
    let i11 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, s11 = t108.charCategorizer(e11), n10 = t108.doc.lineAt(e11), o10 = e11 - n10.from;
    if (0 == n10.length) return ti.cursor(e11);
    0 == o10 ? i11 = 1 : o10 == n10.length && (i11 = -1);
    let r10 = o10, l10 = o10;
    i11 < 0 ? r10 = v(n10.text, o10, false) : l10 = v(n10.text, o10);
    let h10 = s11(n10.text.slice(r10, l10));
    for (; r10 > 0; ) {
      let t109 = v(n10.text, r10, false);
      if (s11(n10.text.slice(t109, r10)) != h10) break;
      r10 = t109;
    }
    for (; l10 < n10.length; ) {
      let t109 = v(n10.text, l10);
      if (s11(n10.text.slice(l10, t109)) != h10) break;
      l10 = t109;
    }
    return ti.range(r10 + n10.from, l10 + n10.from);
  }(t107.state, e10, i10);
  {
    let i11 = aq.find(t107.docView, e10), s11 = t107.state.doc.lineAt(i11 ? i11.posAtEnd : e10), n10 = i11 ? i11.posAtStart : s11.from, o10 = i11 ? i11.posAtEnd : s11.to;
    return o10 < t107.state.doc.length && o10 == s11.to && o10++, ti.range(n10, o10);
  }
}
c3.scroll = (t107) => {
  t107.inputState.lastScrollTop = t107.scrollDOM.scrollTop, t107.inputState.lastScrollLeft = t107.scrollDOM.scrollLeft;
}, c8.keydown = (t107, e10) => (t107.inputState.setSelectionOrigin("select"), 27 == e10.keyCode && 0 != t107.inputState.tabFocusMode && (t107.inputState.tabFocusMode = Date.now() + 2e3), false), c3.touchstart = (t107, e10) => {
  t107.inputState.lastTouchTime = Date.now(), t107.inputState.setSelectionOrigin("select.pointer");
}, c3.touchmove = (t107) => {
  t107.inputState.setSelectionOrigin("select.pointer");
}, c8.mousedown = (t107, e10) => {
  let i10, s10, n10;
  if (t107.observer.flush(), t107.inputState.lastTouchTime > Date.now() - 2e3) return false;
  let o10 = null;
  for (let i11 of t107.state.facet(ch)) if (o10 = i11(t107, e10)) break;
  if (o10 || 0 != e10.button || (i10 = dt(t107, e10), s10 = dr(e10), n10 = t107.state.selection, o10 = { update(t108) {
    t108.docChanged && (i10.pos = t108.changes.mapPos(i10.pos), n10 = n10.map(t108.changes));
  }, get(e11, o11, r10) {
    let l10 = dt(t107, e11), h10, a10 = c5(t107, l10.pos, l10.bias, s10);
    if (i10.pos != l10.pos && !o11) {
      let e12 = c5(t107, i10.pos, i10.bias, s10), n11 = Math.min(e12.from, a10.from), o12 = Math.max(e12.to, a10.to);
      a10 = n11 < a10.from ? ti.range(n11, o12) : ti.range(o12, n11);
    }
    return o11 ? n10.replaceRange(n10.main.extend(a10.from, a10.to)) : r10 && 1 == s10 && n10.ranges.length > 1 && (h10 = function(t108, e12) {
      for (let i11 = 0; i11 < t108.ranges.length; i11++) {
        let { from: s11, to: n11 } = t108.ranges[i11];
        if (s11 <= e12 && n11 >= e12) return ti.create(t108.ranges.slice(0, i11).concat(t108.ranges.slice(i11 + 1)), t108.mainIndex == i11 ? 0 : t108.mainIndex - (t108.mainIndex > i11 ? 1 : 0));
      }
      return null;
    }(n10, l10.pos)) ? h10 : r10 ? n10.addRange(a10) : ti.create([a10]);
  } }), o10) {
    let i11 = !t107.hasFocus;
    t107.inputState.startMouseSelection(new c2(t107, e10, o10, i11)), i11 && t107.observer.ignore(() => {
      al(t107.contentDOM);
      let e11 = t107.root.activeElement;
      e11 && !e11.contains(t107.contentDOM) && e11.blur();
    });
    let s11 = t107.inputState.mouseSelection;
    if (s11) return s11.start(e10), false === s11.dragging;
  }
  return false;
};
let c6 = (t107, e10) => t107 >= e10.top && t107 <= e10.bottom, c7 = (t107, e10, i10) => c6(e10, i10) && t107 >= i10.left && t107 <= i10.right;
function dt(t107, e10) {
  let i10 = t107.posAtCoords({ x: e10.clientX, y: e10.clientY }, false);
  return { pos: i10, bias: function(t108, e11, i11, s10) {
    let n10 = aq.find(t108.docView, e11);
    if (!n10) return 1;
    let o10 = e11 - n10.posAtStart;
    if (0 == o10) return 1;
    if (o10 == n10.length) return -1;
    let r10 = n10.coordsAt(o10, -1);
    if (r10 && c7(i11, s10, r10)) return -1;
    let l10 = n10.coordsAt(o10, 1);
    return l10 && c7(i11, s10, l10) ? 1 : r10 && c6(s10, r10) ? -1 : 1;
  }(t107, i10, e10.clientX, e10.clientY) };
}
let de = aB.ie && aB.ie_version <= 11, di = null, ds = 0, dn = 0;
function dr(t107) {
  if (!de) return t107.detail;
  let e10 = di, i10 = dn;
  return di = t107, dn = Date.now(), ds = !e10 || i10 > Date.now() - 400 && 2 > Math.abs(e10.clientX - t107.clientX) && 2 > Math.abs(e10.clientY - t107.clientY) ? (ds + 1) % 3 : 1;
}
function dl(t107, e10, i10, s10) {
  let n10;
  if (!i10) return;
  let o10 = t107.posAtCoords({ x: e10.clientX, y: e10.clientY }, false), { draggedContent: r10 } = t107.inputState, l10 = s10 && r10 && ((n10 = t107.state.facet(cl)).length ? n10[0](e10) : aB.mac ? !e10.altKey : !e10.ctrlKey) ? { from: r10.from, to: r10.to } : null, h10 = { from: o10, insert: i10 }, a10 = t107.state.changes(l10 ? [l10, h10] : h10);
  t107.focus(), t107.dispatch({ changes: a10, selection: { anchor: a10.mapPos(o10, -1), head: a10.mapPos(o10, 1) }, userEvent: l10 ? "move.drop" : "input.drop" }), t107.inputState.draggedContent = null;
}
c8.dragstart = (t107, e10) => {
  let { selection: { main: i10 } } = t107.state;
  if (e10.target.draggable) {
    let s11 = t107.docView.nearest(e10.target);
    if (s11 && s11.isWidget) {
      let t108 = s11.posAtStart, e11 = t108 + s11.length;
      (t108 >= i10.to || e11 <= i10.from) && (i10 = ti.range(t108, e11));
    }
  }
  let { inputState: s10 } = t107;
  return s10.mouseSelection && (s10.mouseSelection.dragging = true), s10.draggedContent = i10, e10.dataTransfer && (e10.dataTransfer.setData("Text", t107.state.sliceDoc(i10.from, i10.to)), e10.dataTransfer.effectAllowed = "copyMove"), false;
}, c8.dragend = (t107) => (t107.inputState.draggedContent = null, false), c8.drop = (t107, e10) => {
  if (!e10.dataTransfer) return false;
  if (t107.state.readOnly) return true;
  let i10 = e10.dataTransfer.files;
  if (i10 && i10.length) {
    let s10 = Array(i10.length), n10 = 0, o10 = () => {
      ++n10 == i10.length && dl(t107, e10, s10.filter((t108) => null != t108).join(t107.state.lineBreak), false);
    };
    for (let t108 = 0; t108 < i10.length; t108++) {
      let e11 = new FileReader();
      e11.onerror = o10, e11.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(e11.result) || (s10[t108] = e11.result), o10();
      }, e11.readAsText(i10[t108]);
    }
    return true;
  }
  {
    let i11 = e10.dataTransfer.getData("Text");
    if (i11) return dl(t107, e10, i11, true), true;
  }
  return false;
}, c8.paste = (t107, e10) => {
  if (t107.state.readOnly) return true;
  t107.observer.flush();
  let i10 = c4 ? null : e10.clipboardData;
  return i10 ? (c9(t107, i10.getData("text/plain") || i10.getData("text/uri-list")), true) : (function(t108) {
    let e11 = t108.dom.parentNode;
    if (!e11) return;
    let i11 = e11.appendChild(document.createElement("textarea"));
    i11.style.cssText = "position: fixed; left: -10000px; top: 10px", i11.focus(), setTimeout(() => {
      t108.focus(), i11.remove(), c9(t108, i11.value);
    }, 50);
  }(t107), false);
};
let dh = null;
c8.copy = c8.cut = (t107, e10) => {
  let { text: i10, ranges: s10, linewise: n10 } = function(t108) {
    let e11 = [], i11 = [], s11 = false;
    for (let s12 of t108.selection.ranges) s12.empty || (e11.push(t108.sliceDoc(s12.from, s12.to)), i11.push(s12));
    if (!e11.length) {
      let n11 = -1;
      for (let { from: s12 } of t108.selection.ranges) {
        let o11 = t108.doc.lineAt(s12);
        o11.number > n11 && (e11.push(o11.text), i11.push({ from: o11.from, to: Math.min(t108.doc.length, o11.to + 1) })), n11 = o11.number;
      }
      s11 = true;
    }
    return { text: e11.join(t108.lineBreak), ranges: i11, linewise: s11 };
  }(t107.state);
  if (!i10 && !n10) return false;
  dh = n10 ? i10 : null, "cut" != e10.type || t107.state.readOnly || t107.dispatch({ changes: s10, scrollIntoView: true, userEvent: "delete.cut" });
  let o10 = c4 ? null : e10.clipboardData;
  return o10 ? (o10.clearData(), o10.setData("text/plain", i10), true) : (!function(t108, e11) {
    let i11 = t108.dom.parentNode;
    if (!i11) return;
    let s11 = i11.appendChild(document.createElement("textarea"));
    s11.style.cssText = "position: fixed; left: -10000px; top: 10px", s11.value = e11, s11.focus(), s11.selectionEnd = e11.length, s11.selectionStart = 0, setTimeout(() => {
      s11.remove(), t108.focus();
    }, 50);
  }(t107, i10), false);
};
let da = tO.define();
function dc(t107, e10) {
  let i10 = [];
  for (let s10 of t107.facet(cu)) {
    let n10 = s10(t107, e10);
    n10 && i10.push(n10);
  }
  return i10 ? t107.update({ effects: i10, annotations: da.of(true) }) : null;
}
function dd(t107) {
  setTimeout(() => {
    let e10 = t107.hasFocus;
    if (e10 != t107.inputState.notifiedFocused) {
      let i10 = dc(t107.state, e10);
      i10 ? t107.dispatch(i10) : t107.update([]);
    }
  }, 10);
}
c3.focus = (t107) => {
  t107.inputState.lastFocusTime = Date.now(), !t107.scrollDOM.scrollTop && (t107.inputState.lastScrollTop || t107.inputState.lastScrollLeft) && (t107.scrollDOM.scrollTop = t107.inputState.lastScrollTop, t107.scrollDOM.scrollLeft = t107.inputState.lastScrollLeft), dd(t107);
}, c3.blur = (t107) => {
  t107.observer.clearSelectionRange(), dd(t107);
}, c3.compositionstart = c3.compositionupdate = (t107) => {
  !t107.observer.editContext && (null == t107.inputState.compositionFirstChange && (t107.inputState.compositionFirstChange = true), t107.inputState.composing < 0 && (t107.inputState.composing = 0));
}, c3.compositionend = (t107) => {
  t107.observer.editContext || (t107.inputState.composing = -1, t107.inputState.compositionEndedAt = Date.now(), t107.inputState.compositionPendingKey = true, t107.inputState.compositionPendingChange = t107.observer.pendingRecords().length > 0, t107.inputState.compositionFirstChange = null, aB.chrome && aB.android ? t107.observer.flushSoon() : t107.inputState.compositionPendingChange ? Promise.resolve().then(() => t107.observer.flush()) : setTimeout(() => {
    t107.inputState.composing < 0 && t107.docView.hasComposition && t107.update([]);
  }, 50));
}, c3.contextmenu = (t107) => {
  t107.inputState.lastContextMenu = Date.now();
}, c8.beforeinput = (t107, e10) => {
  var i10;
  let s10;
  if (aB.chrome && aB.android && (s10 = cQ.find((t108) => t108.inputType == e10.inputType)) && (t107.observer.delayAndroidKey(s10.key, s10.keyCode), "Backspace" == s10.key || "Delete" == s10.key)) {
    let e11 = (null === (i10 = window.visualViewport) || void 0 === i10 ? void 0 : i10.height) || 0;
    setTimeout(() => {
      var i11;
      ((null === (i11 = window.visualViewport) || void 0 === i11 ? void 0 : i11.height) || 0) > e11 + 10 && t107.hasFocus && (t107.contentDOM.blur(), t107.focus());
    }, 100);
  }
  return aB.ios && "deleteContentForward" == e10.inputType && t107.observer.flushSoon(), aB.safari && "insertText" == e10.inputType && t107.inputState.composing >= 0 && setTimeout(() => c3.compositionend(t107, e10), 20), false;
};
let du = /* @__PURE__ */ new Set(), df = ["pre-wrap", "normal", "pre-line", "break-spaces"], dg = class {
  constructor(t107) {
    this.lineWrapping = t107, this.doc = r.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30, this.heightChanged = false;
  }
  heightForGap(t107, e10) {
    let i10 = this.doc.lineAt(e10).number - this.doc.lineAt(t107).number + 1;
    return this.lineWrapping && (i10 += Math.max(0, Math.ceil((e10 - t107 - i10 * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * i10;
  }
  heightForLine(t107) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((t107 - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(t107) {
    return this.doc = t107, this;
  }
  mustRefreshForWrapping(t107) {
    return df.indexOf(t107) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(t107) {
    let e10 = false;
    for (let i10 = 0; i10 < t107.length; i10++) {
      let s10 = t107[i10];
      s10 < 0 ? i10++ : this.heightSamples[Math.floor(10 * s10)] || (e10 = true, this.heightSamples[Math.floor(10 * s10)] = true);
    }
    return e10;
  }
  refresh(t107, e10, i10, s10, n10, o10) {
    let r10 = df.indexOf(t107) > -1, l10 = Math.round(e10) != Math.round(this.lineHeight) || this.lineWrapping != r10;
    if (this.lineWrapping = r10, this.lineHeight = e10, this.charWidth = i10, this.textHeight = s10, this.lineLength = n10, l10) {
      this.heightSamples = {};
      for (let t108 = 0; t108 < o10.length; t108++) {
        let e11 = o10[t108];
        e11 < 0 ? t108++ : this.heightSamples[Math.floor(10 * e11)] = true;
      }
    }
    return l10;
  }
}, dp = class {
  constructor(t107, e10) {
    this.from = t107, this.heights = e10, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}, dm = class t75 {
  constructor(t107, e10, i10, s10, n10) {
    this.from = t107, this.length = e10, this.top = i10, this.height = s10, this._content = n10;
  }
  get type() {
    return "number" == typeof this._content ? aj.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  get to() {
    return this.from + this.length;
  }
  get bottom() {
    return this.top + this.height;
  }
  get widget() {
    return this._content instanceof aX ? this._content.widget : null;
  }
  get widgetLineBreaks() {
    return "number" == typeof this._content ? this._content : 0;
  }
  join(e10) {
    let i10 = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e10._content) ? e10._content : [e10]);
    return new t75(this.from, this.length + e10.length, this.top, this.height + e10.height, i10);
  }
};
var dv = ((N = dv || (dv = {}))[N.ByPos = 0] = "ByPos", N[N.ByHeight = 1] = "ByHeight", N[N.ByPosNoHeight = 2] = "ByPosNoHeight", N);
let dw = class t76 {
  constructor(t107, e10, i10 = 2) {
    this.length = t107, this.height = e10, this.flags = i10;
  }
  get outdated() {
    return (2 & this.flags) > 0;
  }
  set outdated(t107) {
    this.flags = (t107 ? 2 : 0) | -3 & this.flags;
  }
  setHeight(t107, e10) {
    this.height != e10 && (Math.abs(this.height - e10) > 1e-3 && (t107.heightChanged = true), this.height = e10);
  }
  replace(e10, i10, s10) {
    return t76.of(s10);
  }
  decomposeLeft(t107, e10) {
    e10.push(this);
  }
  decomposeRight(t107, e10) {
    e10.push(this);
  }
  applyChanges(t107, e10, i10, s10) {
    let n10 = this, o10 = i10.doc;
    for (let r10 = s10.length - 1; r10 >= 0; r10--) {
      let { fromA: l10, toA: h10, fromB: a10, toB: c10 } = s10[r10], d10 = n10.lineAt(l10, dv.ByPosNoHeight, i10.setDoc(e10), 0, 0), u10 = d10.to >= h10 ? d10 : n10.lineAt(h10, dv.ByPosNoHeight, i10, 0, 0);
      for (c10 += u10.to - h10, h10 = u10.to; r10 > 0 && d10.from <= s10[r10 - 1].toA; ) l10 = s10[r10 - 1].fromA, a10 = s10[r10 - 1].fromB, r10--, l10 < d10.from && (d10 = n10.lineAt(l10, dv.ByPosNoHeight, i10, 0, 0));
      a10 += d10.from - l10, l10 = d10.from;
      let f10 = dM.build(i10.setDoc(o10), t107, a10, c10);
      n10 = n10.replace(l10, h10, f10);
    }
    return n10.updateHeight(i10, 0);
  }
  static empty() {
    return new dy(0, 0);
  }
  static of(e10) {
    if (1 == e10.length) return e10[0];
    let i10 = 0, s10 = e10.length, n10 = 0, o10 = 0;
    for (; ; ) if (i10 == s10) {
      if (n10 > 2 * o10) {
        let t107 = e10[i10 - 1];
        t107.break ? e10.splice(--i10, 1, t107.left, null, t107.right) : e10.splice(--i10, 1, t107.left, t107.right), s10 += 1 + t107.break, n10 -= t107.size;
      } else if (o10 > 2 * n10) {
        let t107 = e10[s10];
        t107.break ? e10.splice(s10, 1, t107.left, null, t107.right) : e10.splice(s10, 1, t107.left, t107.right), s10 += 2 + t107.break, o10 -= t107.size;
      } else break;
    } else if (n10 < o10) {
      let t107 = e10[i10++];
      t107 && (n10 += t107.size);
    } else {
      let t107 = e10[--s10];
      t107 && (o10 += t107.size);
    }
    let r10 = 0;
    return null == e10[i10 - 1] ? (r10 = 1, i10--) : null == e10[i10] && (r10 = 1, s10++), new dS(t76.of(e10.slice(0, i10)), r10, t76.of(e10.slice(s10)));
  }
};
dw.prototype.size = 1;
let db = class extends dw {
  constructor(t107, e10, i10) {
    super(t107, e10), this.deco = i10;
  }
  blockAt(t107, e10, i10, s10) {
    return new dm(s10, this.length, i10, this.height, this.deco || 0);
  }
  lineAt(t107, e10, i10, s10, n10) {
    return this.blockAt(0, i10, s10, n10);
  }
  forEachLine(t107, e10, i10, s10, n10, o10) {
    t107 <= n10 + this.length && e10 >= n10 && o10(this.blockAt(0, i10, s10, n10));
  }
  updateHeight(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i10 = (arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 ? arguments[3] : void 0);
    return i10 && i10.from <= e10 && i10.more && this.setHeight(t107, i10.heights[i10.index++]), this.outdated = false, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}, dy = class t77 extends db {
  constructor(t107, e10) {
    super(t107, e10, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(t107, e10, i10, s10) {
    return new dm(s10, this.length, i10, this.height, this.breaks);
  }
  replace(e10, i10, s10) {
    let n10 = s10[0];
    return 1 == s10.length && (n10 instanceof t77 || n10 instanceof dx && 4 & n10.flags) && 10 > Math.abs(this.length - n10.length) ? (n10 instanceof dx ? n10 = new t77(n10.length, this.height) : n10.height = this.height, this.outdated || (n10.outdated = false), n10) : dw.of(s10);
  }
  updateHeight(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], s10 = arguments.length > 3 ? arguments[3] : void 0;
    return s10 && s10.from <= e10 && s10.more ? this.setHeight(t107, s10.heights[s10.index++]) : (i10 || this.outdated) && this.setHeight(t107, Math.max(this.widgetHeight, t107.heightForLine(this.length - this.collapsed)) + this.breaks * t107.lineHeight), this.outdated = false, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}, dx = class t78 extends dw {
  constructor(t107) {
    super(t107, 0);
  }
  heightMetrics(t107, e10) {
    let i10 = t107.doc.lineAt(e10).number, s10 = t107.doc.lineAt(e10 + this.length).number, n10 = s10 - i10 + 1, o10, r10 = 0;
    if (t107.lineWrapping) {
      let e11 = Math.min(this.height, t107.lineHeight * n10);
      o10 = e11 / n10, this.length > n10 + 1 && (r10 = (this.height - e11) / (this.length - n10 - 1));
    } else o10 = this.height / n10;
    return { firstLine: i10, lastLine: s10, perLine: o10, perChar: r10 };
  }
  blockAt(t107, e10, i10, s10) {
    let { firstLine: n10, lastLine: o10, perLine: r10, perChar: l10 } = this.heightMetrics(e10, s10);
    if (e10.lineWrapping) {
      let n11 = s10 + (t107 < e10.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (t107 - i10) / this.height)) * this.length)), o11 = e10.doc.lineAt(n11), h10 = r10 + o11.length * l10, a10 = Math.max(i10, t107 - h10 / 2);
      return new dm(o11.from, o11.length, a10, h10, 0);
    }
    {
      let s11 = Math.max(0, Math.min(o10 - n10, Math.floor((t107 - i10) / r10))), { from: l11, length: h10 } = e10.doc.line(n10 + s11);
      return new dm(l11, h10, i10 + r10 * s11, r10, 0);
    }
  }
  lineAt(t107, e10, i10, s10, n10) {
    if (e10 == dv.ByHeight) return this.blockAt(t107, i10, s10, n10);
    if (e10 == dv.ByPosNoHeight) {
      let { from: e11, to: s11 } = i10.doc.lineAt(t107);
      return new dm(e11, s11 - e11, 0, 0, 0);
    }
    let { firstLine: o10, perLine: r10, perChar: l10 } = this.heightMetrics(i10, n10), h10 = i10.doc.lineAt(t107), a10 = r10 + h10.length * l10, c10 = h10.number - o10, d10 = s10 + r10 * c10 + l10 * (h10.from - n10 - c10);
    return new dm(h10.from, h10.length, Math.max(s10, Math.min(d10, s10 + this.height - a10)), a10, 0);
  }
  forEachLine(t107, e10, i10, s10, n10, o10) {
    t107 = Math.max(t107, n10), e10 = Math.min(e10, n10 + this.length);
    let { firstLine: r10, perLine: l10, perChar: h10 } = this.heightMetrics(i10, n10);
    for (let a10 = t107, c10 = s10; a10 <= e10; ) {
      let e11 = i10.doc.lineAt(a10);
      if (a10 == t107) {
        let i11 = e11.number - r10;
        c10 += l10 * i11 + h10 * (t107 - n10 - i11);
      }
      let s11 = l10 + h10 * e11.length;
      o10(new dm(e11.from, e11.length, c10, s11, 0)), c10 += s11, a10 = e11.to + 1;
    }
  }
  replace(e10, i10, s10) {
    let n10 = this.length - i10;
    if (n10 > 0) {
      let e11 = s10[s10.length - 1];
      e11 instanceof t78 ? s10[s10.length - 1] = new t78(e11.length + n10) : s10.push(null, new t78(n10 - 1));
    }
    if (e10 > 0) {
      let i11 = s10[0];
      i11 instanceof t78 ? s10[0] = new t78(e10 + i11.length) : s10.unshift(new t78(e10 - 1), null);
    }
    return dw.of(s10);
  }
  decomposeLeft(e10, i10) {
    i10.push(new t78(e10 - 1), null);
  }
  decomposeRight(e10, i10) {
    i10.push(null, new t78(this.length - e10 - 1));
  }
  updateHeight(e10) {
    let i10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, s10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n10 = arguments.length > 3 ? arguments[3] : void 0, o10 = i10 + this.length;
    if (n10 && n10.from <= i10 + this.length && n10.more) {
      let s11 = [], r10 = Math.max(i10, n10.from), l10 = -1;
      for (n10.from > i10 && s11.push(new t78(n10.from - i10 - 1).updateHeight(e10, i10)); r10 <= o10 && n10.more; ) {
        let t107 = e10.doc.lineAt(r10).length;
        s11.length && s11.push(null);
        let i11 = n10.heights[n10.index++];
        -1 == l10 ? l10 = i11 : Math.abs(i11 - l10) >= 1e-3 && (l10 = -2);
        let o11 = new dy(t107, i11);
        o11.outdated = false, s11.push(o11), r10 += t107 + 1;
      }
      r10 <= o10 && s11.push(null, new t78(o10 - r10).updateHeight(e10, r10));
      let h10 = dw.of(s11);
      return (l10 < 0 || Math.abs(h10.height - this.height) >= 1e-3 || Math.abs(l10 - this.heightMetrics(e10, i10).perLine) >= 1e-3) && (e10.heightChanged = true), h10;
    }
    return (s10 || this.outdated) && (this.setHeight(e10, e10.heightForGap(i10, i10 + this.length)), this.outdated = false), this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}, dS = class extends dw {
  constructor(t107, e10, i10) {
    super(t107.length + e10 + i10.length, t107.height + i10.height, e10 | (t107.outdated || i10.outdated ? 2 : 0)), this.left = t107, this.right = i10, this.size = t107.size + i10.size;
  }
  get break() {
    return 1 & this.flags;
  }
  blockAt(t107, e10, i10, s10) {
    let n10 = i10 + this.left.height;
    return t107 < n10 ? this.left.blockAt(t107, e10, i10, s10) : this.right.blockAt(t107, e10, n10, s10 + this.left.length + this.break);
  }
  lineAt(t107, e10, i10, s10, n10) {
    let o10 = s10 + this.left.height, r10 = n10 + this.left.length + this.break, l10 = e10 == dv.ByHeight ? t107 < o10 : t107 < r10, h10 = l10 ? this.left.lineAt(t107, e10, i10, s10, n10) : this.right.lineAt(t107, e10, i10, o10, r10);
    if (this.break || (l10 ? h10.to < r10 : h10.from > r10)) return h10;
    let a10 = e10 == dv.ByPosNoHeight ? dv.ByPosNoHeight : dv.ByPos;
    return l10 ? h10.join(this.right.lineAt(r10, a10, i10, o10, r10)) : this.left.lineAt(r10, a10, i10, s10, n10).join(h10);
  }
  forEachLine(t107, e10, i10, s10, n10, o10) {
    let r10 = s10 + this.left.height, l10 = n10 + this.left.length + this.break;
    if (this.break) t107 < l10 && this.left.forEachLine(t107, e10, i10, s10, n10, o10), e10 >= l10 && this.right.forEachLine(t107, e10, i10, r10, l10, o10);
    else {
      let h10 = this.lineAt(l10, dv.ByPos, i10, s10, n10);
      t107 < h10.from && this.left.forEachLine(t107, h10.from - 1, i10, s10, n10, o10), h10.to >= t107 && h10.from <= e10 && o10(h10), e10 > h10.to && this.right.forEachLine(h10.to + 1, e10, i10, r10, l10, o10);
    }
  }
  replace(t107, e10, i10) {
    let s10 = this.left.length + this.break;
    if (e10 < s10) return this.balanced(this.left.replace(t107, e10, i10), this.right);
    if (t107 > this.left.length) return this.balanced(this.left, this.right.replace(t107 - s10, e10 - s10, i10));
    let n10 = [];
    t107 > 0 && this.decomposeLeft(t107, n10);
    let o10 = n10.length;
    for (let t108 of i10) n10.push(t108);
    if (t107 > 0 && dk(n10, o10 - 1), e10 < this.length) {
      let t108 = n10.length;
      this.decomposeRight(e10, n10), dk(n10, t108);
    }
    return dw.of(n10);
  }
  decomposeLeft(t107, e10) {
    let i10 = this.left.length;
    if (t107 <= i10) return this.left.decomposeLeft(t107, e10);
    e10.push(this.left), this.break && t107 >= ++i10 && e10.push(null), t107 > i10 && this.right.decomposeLeft(t107 - i10, e10);
  }
  decomposeRight(t107, e10) {
    let i10 = this.left.length, s10 = i10 + this.break;
    if (t107 >= s10) return this.right.decomposeRight(t107 - s10, e10);
    t107 < i10 && this.left.decomposeRight(t107, e10), this.break && t107 < s10 && e10.push(null), e10.push(this.right);
  }
  balanced(t107, e10) {
    return t107.size > 2 * e10.size || e10.size > 2 * t107.size ? dw.of(this.break ? [t107, null, e10] : [t107, e10]) : (this.left = t107, this.right = e10, this.height = t107.height + e10.height, this.outdated = t107.outdated || e10.outdated, this.size = t107.size + e10.size, this.length = t107.length + this.break + e10.length, this);
  }
  updateHeight(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], s10 = arguments.length > 3 ? arguments[3] : void 0, { left: n10, right: o10 } = this, r10 = e10 + n10.length + this.break, l10 = null;
    return (s10 && s10.from <= e10 + n10.length && s10.more ? l10 = n10 = n10.updateHeight(t107, e10, i10, s10) : n10.updateHeight(t107, e10, i10), s10 && s10.from <= r10 + o10.length && s10.more ? l10 = o10 = o10.updateHeight(t107, r10, i10, s10) : o10.updateHeight(t107, r10, i10), l10) ? this.balanced(n10, o10) : (this.height = this.left.height + this.right.height, this.outdated = false, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
};
function dk(t107, e10) {
  let i10, s10;
  null == t107[e10] && (i10 = t107[e10 - 1]) instanceof dx && (s10 = t107[e10 + 1]) instanceof dx && t107.splice(e10 - 1, 3, new dx(i10.length + 1 + s10.length));
}
let dM = class t79 {
  constructor(t107, e10) {
    this.pos = t107, this.oracle = e10, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = t107;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(t107, e10) {
    if (this.lineStart > -1) {
      let t108 = Math.min(e10, this.lineEnd), i10 = this.nodes[this.nodes.length - 1];
      i10 instanceof dy ? i10.length += t108 - this.pos : (t108 > this.pos || !this.isCovered) && this.nodes.push(new dy(t108 - this.pos, -1)), this.writtenTo = t108, e10 > t108 && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = e10;
  }
  point(t107, e10, i10) {
    if (t107 < e10 || i10.heightRelevant) {
      let s10 = i10.widget ? i10.widget.estimatedHeight : 0, n10 = i10.widget ? i10.widget.lineBreaks : 0;
      s10 < 0 && (s10 = this.oracle.lineHeight);
      let o10 = e10 - t107;
      i10.block ? this.addBlock(new db(o10, s10, i10)) : (o10 || n10 || s10 >= 5) && this.addLineDeco(s10, n10, o10);
    } else e10 > t107 && this.span(t107, e10);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1) return;
    let { from: t107, to: e10 } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = t107, this.lineEnd = e10, this.writtenTo < t107 && ((this.writtenTo < t107 - 1 || null == this.nodes[this.nodes.length - 1]) && this.nodes.push(this.blankContent(this.writtenTo, t107 - 1)), this.nodes.push(null)), this.pos > t107 && this.nodes.push(new dy(this.pos - t107, -1)), this.writtenTo = this.pos;
  }
  blankContent(t107, e10) {
    let i10 = new dx(e10 - t107);
    return this.oracle.doc.lineAt(t107).to == e10 && (i10.flags |= 4), i10;
  }
  ensureLine() {
    this.enterLine();
    let t107 = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (t107 instanceof dy) return t107;
    let e10 = new dy(0, -1);
    return this.nodes.push(e10), e10;
  }
  addBlock(t107) {
    this.enterLine();
    let e10 = t107.deco;
    e10 && e10.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(t107), this.writtenTo = this.pos = this.pos + t107.length, e10 && e10.endSide > 0 && (this.covering = t107);
  }
  addLineDeco(t107, e10, i10) {
    let s10 = this.ensureLine();
    s10.length += i10, s10.collapsed += i10, s10.widgetHeight = Math.max(s10.widgetHeight, t107), s10.breaks += e10, this.writtenTo = this.pos = this.pos + i10;
  }
  finish(t107) {
    let e10 = 0 == this.nodes.length ? null : this.nodes[this.nodes.length - 1];
    !(this.lineStart > -1) || e10 instanceof dy || this.isCovered ? (this.writtenTo < this.pos || null == e10) && this.nodes.push(this.blankContent(this.writtenTo, this.pos)) : this.nodes.push(new dy(0, -1));
    let i10 = t107;
    for (let t108 of this.nodes) t108 instanceof dy && t108.updateHeight(this.oracle, i10), i10 += t108 ? t108.length : 1;
    return this.nodes;
  }
  static build(e10, i10, s10, n10) {
    let o10 = new t79(s10, e10);
    return tG.spans(i10, s10, n10, o10, 0), o10.finish(s10);
  }
}, dC = class {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(t107, e10, i10, s10) {
    (t107 < e10 || i10 && i10.heightRelevant || s10 && s10.heightRelevant) && aQ(t107, e10, this.changes, 5);
  }
}, dA = class {
  constructor(t107, e10, i10) {
    this.from = t107, this.to = e10, this.size = i10;
  }
  static same(t107, e10) {
    if (t107.length != e10.length) return false;
    for (let i10 = 0; i10 < t107.length; i10++) {
      let s10 = t107[i10], n10 = e10[i10];
      if (s10.from != n10.from || s10.to != n10.to || s10.size != n10.size) return false;
    }
    return true;
  }
  draw(t107, e10) {
    return aU.replace({ widget: new dD(this.size * (e10 ? t107.scaleY : t107.scaleX), e10) }).range(this.from, this.to);
  }
}, dD = class extends aG {
  constructor(t107, e10) {
    super(), this.size = t107, this.vertical = e10;
  }
  eq(t107) {
    return t107.size == this.size && t107.vertical == this.vertical;
  }
  toDOM() {
    let t107 = document.createElement("div");
    return this.vertical ? t107.style.height = this.size + "px" : (t107.style.width = this.size + "px", t107.style.height = "2px", t107.style.display = "inline-block"), t107;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}, dO = class {
  constructor(t107) {
    this.state = t107, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = true, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = false, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = dB, this.scrollTarget = null, this.printing = false, this.mustMeasureContent = true, this.defaultTextDirection = a2.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = false;
    let e10 = t107.facet(cA).some((t108) => "function" != typeof t108 && "cm-lineWrapping" == t108.class);
    this.heightOracle = new dg(e10), this.stateDeco = t107.facet(cD).filter((t108) => "function" != typeof t108), this.heightMap = dw.empty().applyChanges(this.stateDeco, r.empty, this.heightOracle.setDoc(t107.doc), [new cN(0, 0, 0, t107.doc.length)]);
    for (let t108 = 0; t108 < 2 && (this.viewport = this.getViewport(0, null), this.updateForViewport()); t108++) ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = aU.set(this.lineGaps.map((t108) => t108.draw(this, false))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let t107 = [this.viewport], { main: e10 } = this.state.selection;
    for (let i10 = 0; i10 <= 1; i10++) {
      let s10 = i10 ? e10.head : e10.anchor;
      if (!t107.some((t108) => {
        let { from: e11, to: i11 } = t108;
        return s10 >= e11 && s10 <= i11;
      })) {
        let { from: e11, to: i11 } = this.lineBlockAt(s10);
        t107.push(new dT(e11, i11));
      }
    }
    return this.viewports = t107.sort((t108, e11) => t108.from - e11.from), this.updateScaler();
  }
  updateScaler() {
    let t107 = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? dB : new dL(this.heightOracle, this.heightMap, this.viewports), t107.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (t107) => {
      this.viewportLines.push(dP(t107, this.scaler));
    });
  }
  update(t107) {
    var e10, i10;
    let s10, n10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    this.state = t107.state;
    let o10 = this.stateDeco;
    this.stateDeco = this.state.facet(cD).filter((t108) => "function" != typeof t108);
    let r10 = t107.changedRanges, l10 = cN.extendWithRanges(r10, (e10 = this.stateDeco, i10 = t107 ? t107.changes : Y.empty(this.state.doc.length), s10 = new dC(), tG.compare(o10, e10, i10, s10, 0), s10.changes)), h10 = this.heightMap.height, a10 = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, t107.startState.doc, this.heightOracle.setDoc(this.state.doc), l10), this.heightMap.height != h10 && (t107.flags |= 2), a10 ? (this.scrollAnchorPos = t107.changes.mapPos(a10.from, -1), this.scrollAnchorHeight = a10.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let c10 = l10.length ? this.mapViewport(this.viewport, t107.changes) : this.viewport;
    (n10 && (n10.range.head < c10.from || n10.range.head > c10.to) || !this.viewportIsAppropriate(c10)) && (c10 = this.getViewport(0, n10));
    let d10 = c10.from != this.viewport.from || c10.to != this.viewport.to;
    this.viewport = c10, t107.flags |= this.updateForViewport(), (d10 || !t107.changes.empty || 2 & t107.flags) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, t107.changes))), t107.flags |= this.computeVisibleRanges(), n10 && (this.scrollTarget = n10), !this.mustEnforceCursorAssoc && t107.selectionSet && t107.view.lineWrapping && t107.state.selection.main.empty && t107.state.selection.main.assoc && !t107.state.facet(cg) && (this.mustEnforceCursorAssoc = true);
  }
  measure(t107) {
    let e10 = t107.contentDOM, i10 = window.getComputedStyle(e10), s10 = this.heightOracle, n10 = i10.whiteSpace;
    this.defaultTextDirection = "rtl" == i10.direction ? a2.RTL : a2.LTR;
    let o10 = this.heightOracle.mustRefreshForWrapping(n10), l10 = e10.getBoundingClientRect(), h10 = o10 || this.mustMeasureContent || this.contentDOMHeight != l10.height;
    this.contentDOMHeight = l10.height, this.mustMeasureContent = false;
    let a10 = 0, c10 = 0;
    if (l10.width && l10.height) {
      let { scaleX: t108, scaleY: i11 } = an(e10, l10);
      (t108 > 5e-3 && Math.abs(this.scaleX - t108) > 5e-3 || i11 > 5e-3 && Math.abs(this.scaleY - i11) > 5e-3) && (this.scaleX = t108, this.scaleY = i11, a10 |= 8, o10 = h10 = true);
    }
    let d10 = (parseInt(i10.paddingTop) || 0) * this.scaleY, u10 = (parseInt(i10.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != d10 || this.paddingBottom != u10) && (this.paddingTop = d10, this.paddingBottom = u10, a10 |= 10), this.editorWidth != t107.scrollDOM.clientWidth && (s10.lineWrapping && (h10 = true), this.editorWidth = t107.scrollDOM.clientWidth, a10 |= 8);
    let f10 = t107.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != f10 && (this.scrollAnchorHeight = -1, this.scrollTop = f10), this.scrolledToBottom = ad(t107.scrollDOM);
    let g10 = (this.printing ? function(t108, e11) {
      let i11 = t108.getBoundingClientRect();
      return { left: 0, right: i11.right - i11.left, top: e11, bottom: i11.bottom - (i11.top + e11) };
    } : function(t108, e11) {
      let i11 = t108.getBoundingClientRect(), s11 = t108.ownerDocument, n11 = s11.defaultView || window, o11 = Math.max(0, i11.left), r10 = Math.min(n11.innerWidth, i11.right), l11 = Math.max(0, i11.top), h11 = Math.min(n11.innerHeight, i11.bottom);
      for (let e12 = t108.parentNode; e12 && e12 != s11.body; ) if (1 == e12.nodeType) {
        let i12 = e12, s12 = window.getComputedStyle(i12);
        if ((i12.scrollHeight > i12.clientHeight || i12.scrollWidth > i12.clientWidth) && "visible" != s12.overflow) {
          let s13 = i12.getBoundingClientRect();
          o11 = Math.max(o11, s13.left), r10 = Math.min(r10, s13.right), l11 = Math.max(l11, s13.top), h11 = e12 == t108.parentNode ? s13.bottom : Math.min(h11, s13.bottom);
        }
        e12 = "absolute" == s12.position || "fixed" == s12.position ? i12.offsetParent : i12.parentNode;
      } else if (11 == e12.nodeType) e12 = e12.host;
      else break;
      return { left: o11 - i11.left, right: Math.max(o11, r10) - i11.left, top: l11 - (i11.top + e11), bottom: Math.max(l11, h11) - (i11.top + e11) };
    })(e10, this.paddingTop), p10 = g10.top - this.pixelViewport.top, m10 = g10.bottom - this.pixelViewport.bottom;
    this.pixelViewport = g10;
    let v10 = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (v10 != this.inView && (this.inView = v10, v10 && (h10 = true)), !this.inView && !this.scrollTarget) return 0;
    let w10 = l10.width;
    if ((this.contentDOMWidth != w10 || this.editorHeight != t107.scrollDOM.clientHeight) && (this.contentDOMWidth = l10.width, this.editorHeight = t107.scrollDOM.clientHeight, a10 |= 8), h10) {
      let e11 = t107.docView.measureVisibleLineHeights(this.viewport);
      if (s10.mustRefreshForHeights(e11) && (o10 = true), o10 || s10.lineWrapping && Math.abs(w10 - this.contentDOMWidth) > s10.charWidth) {
        let { lineHeight: i11, charWidth: r10, textHeight: l11 } = t107.docView.measureTextSize();
        (o10 = i11 > 0 && s10.refresh(n10, i11, r10, l11, w10 / r10, e11)) && (t107.docView.minWidth = 0, a10 |= 8);
      }
      for (let i11 of (p10 > 0 && m10 > 0 ? c10 = Math.max(p10, m10) : p10 < 0 && m10 < 0 && (c10 = Math.min(p10, m10)), s10.heightChanged = false, this.viewports)) {
        let n11 = i11.from == this.viewport.from ? e11 : t107.docView.measureVisibleLineHeights(i11);
        this.heightMap = (o10 ? dw.empty().applyChanges(this.stateDeco, r.empty, this.heightOracle, [new cN(0, 0, 0, t107.state.doc.length)]) : this.heightMap).updateHeight(s10, 0, o10, new dp(i11.from, n11));
      }
      s10.heightChanged && (a10 |= 2);
    }
    let b10 = !this.viewportIsAppropriate(this.viewport, c10) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return b10 && (2 & a10 && (a10 |= this.updateScaler()), this.viewport = this.getViewport(c10, this.scrollTarget), a10 |= this.updateForViewport()), (2 & a10 || b10) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(o10 ? [] : this.lineGaps, t107)), a10 |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = false, t107.docView.enforceCursorAssoc()), a10;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(t107, e10) {
    let i10 = 0.5 - Math.max(-0.5, Math.min(0.5, t107 / 1e3 / 2)), s10 = this.heightMap, n10 = this.heightOracle, { visibleTop: o10, visibleBottom: r10 } = this, l10 = new dT(s10.lineAt(o10 - 1e3 * i10, dv.ByHeight, n10, 0, 0).from, s10.lineAt(r10 + (1 - i10) * 1e3, dv.ByHeight, n10, 0, 0).to);
    if (e10) {
      let { head: t108 } = e10.range;
      if (t108 < l10.from || t108 > l10.to) {
        let i11 = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), o11 = s10.lineAt(t108, dv.ByPos, n10, 0, 0), r11;
        r11 = "center" == e10.y ? (o11.top + o11.bottom) / 2 - i11 / 2 : "start" == e10.y || "nearest" == e10.y && t108 < l10.from ? o11.top : o11.bottom - i11, l10 = new dT(s10.lineAt(r11 - 500, dv.ByHeight, n10, 0, 0).from, s10.lineAt(r11 + i11 + 500, dv.ByHeight, n10, 0, 0).to);
      }
    }
    return l10;
  }
  mapViewport(t107, e10) {
    let i10 = e10.mapPos(t107.from, -1), s10 = e10.mapPos(t107.to, 1);
    return new dT(this.heightMap.lineAt(i10, dv.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(s10, dv.ByPos, this.heightOracle, 0, 0).to);
  }
  viewportIsAppropriate(t107) {
    let { from: e10, to: i10 } = t107, s10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    if (!this.inView) return true;
    let { top: n10 } = this.heightMap.lineAt(e10, dv.ByPos, this.heightOracle, 0, 0), { bottom: o10 } = this.heightMap.lineAt(i10, dv.ByPos, this.heightOracle, 0, 0), { visibleTop: r10, visibleBottom: l10 } = this;
    return (0 == e10 || n10 <= r10 - Math.max(10, Math.min(-s10, 250))) && (i10 == this.state.doc.length || o10 >= l10 + Math.max(10, Math.min(s10, 250))) && n10 > r10 - 2e3 && o10 < l10 + 2e3;
  }
  mapLineGaps(t107, e10) {
    if (!t107.length || e10.empty) return t107;
    let i10 = [];
    for (let s10 of t107) e10.touchesRange(s10.from, s10.to) || i10.push(new dA(e10.mapPos(s10.from), e10.mapPos(s10.to), s10.size));
    return i10;
  }
  ensureLineGaps(t107, e10) {
    let i10 = this.heightOracle.lineWrapping, s10 = i10 ? 1e4 : 2e3, n10 = s10 >> 1, o10 = s10 << 1;
    if (this.defaultTextDirection != a2.LTR && !i10) return [];
    let r10 = [], l10 = (s11, o11, h11, a10) => {
      if (o11 - s11 < n10) return;
      let c10 = this.state.selection.main, d10 = [c10.from];
      for (let t108 of (c10.empty || d10.push(c10.to), d10)) if (t108 > s11 && t108 < o11) {
        l10(s11, t108 - 10, h11, a10), l10(t108 + 10, o11, h11, a10);
        return;
      }
      let u10 = function(t108, e11) {
        for (let i11 of t108) if (e11(i11)) return i11;
      }(t107, (t108) => t108.from >= h11.from && t108.to <= h11.to && Math.abs(t108.from - s11) < n10 && Math.abs(t108.to - o11) < n10 && !d10.some((e11) => t108.from < e11 && t108.to > e11));
      if (!u10) {
        if (o11 < h11.to && e10 && i10 && e10.visibleRanges.some((t108) => t108.from <= o11 && t108.to >= o11)) {
          let t108 = e10.moveToLineBoundary(ti.cursor(o11), false, true).head;
          t108 > s11 && (o11 = t108);
        }
        u10 = new dA(s11, o11, this.gapSize(h11, s11, o11, a10));
      }
      r10.push(u10);
    }, h10 = (t108) => {
      var e11, n11, r11;
      let h11, a10, c10, d10, u10;
      if (t108.length < o10 || t108.type != aj.Text) return;
      let f10 = (e11 = t108.from, n11 = t108.to, r11 = this.stateDeco, c10 = [], d10 = e11, u10 = 0, tG.spans(r11, e11, n11, { span() {
      }, point(t109, e12) {
        t109 > d10 && (c10.push({ from: d10, to: t109 }), u10 += t109 - d10), d10 = e12;
      } }, 20), d10 < n11 && (c10.push({ from: d10, to: n11 }), u10 += n11 - d10), { total: u10, ranges: c10 });
      if (f10.total < o10) return;
      let g10 = this.scrollTarget ? this.scrollTarget.range.head : null;
      if (i10) {
        let e12, i11, n12 = s10 / this.heightOracle.lineLength * this.heightOracle.lineHeight;
        if (null != g10) {
          let s11 = dR(f10, g10), o11 = ((this.visibleBottom - this.visibleTop) / 2 + n12) / t108.height;
          e12 = s11 - o11, i11 = s11 + o11;
        } else e12 = (this.visibleTop - t108.top - n12) / t108.height, i11 = (this.visibleBottom - t108.top + n12) / t108.height;
        h11 = dE(f10, e12), a10 = dE(f10, i11);
      } else {
        let t109, e12, i11 = f10.total * this.heightOracle.charWidth, n12 = s10 * this.heightOracle.charWidth;
        if (null != g10) {
          let s11 = dR(f10, g10), o11 = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + n12) / i11;
          t109 = s11 - o11, e12 = s11 + o11;
        } else t109 = (this.pixelViewport.left - n12) / i11, e12 = (this.pixelViewport.right + n12) / i11;
        h11 = dE(f10, t109), a10 = dE(f10, e12);
      }
      h11 > t108.from && l10(t108.from, h11, t108, f10), a10 < t108.to && l10(a10, t108.to, t108, f10);
    };
    for (let t108 of this.viewportLines) Array.isArray(t108.type) ? t108.type.forEach(h10) : h10(t108);
    return r10;
  }
  gapSize(t107, e10, i10, s10) {
    let n10 = dR(s10, i10) - dR(s10, e10);
    return this.heightOracle.lineWrapping ? t107.height * n10 : s10.total * this.heightOracle.charWidth * n10;
  }
  updateLineGaps(t107) {
    dA.same(t107, this.lineGaps) || (this.lineGaps = t107, this.lineGapDeco = aU.set(t107.map((t108) => t108.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let t107 = this.stateDeco;
    this.lineGaps.length && (t107 = t107.concat(this.lineGapDeco));
    let e10 = [];
    tG.spans(t107, this.viewport.from, this.viewport.to, { span(t108, i11) {
      e10.push({ from: t108, to: i11 });
    }, point() {
    } }, 20);
    let i10 = e10.length != this.visibleRanges.length || this.visibleRanges.some((t108, i11) => t108.from != e10[i11].from || t108.to != e10[i11].to);
    return this.visibleRanges = e10, i10 ? 4 : 0;
  }
  lineBlockAt(t107) {
    return t107 >= this.viewport.from && t107 <= this.viewport.to && this.viewportLines.find((e10) => e10.from <= t107 && e10.to >= t107) || dP(this.heightMap.lineAt(t107, dv.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(t107) {
    return t107 >= this.viewportLines[0].top && t107 <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((e10) => e10.top <= t107 && e10.bottom >= t107) || dP(this.heightMap.lineAt(this.scaler.fromDOM(t107), dv.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(t107) {
    let e10 = this.lineBlockAtHeight(t107 + 8);
    return e10.from >= this.viewport.from || this.viewportLines[0].top - t107 > 200 ? e10 : this.viewportLines[0];
  }
  elementAtHeight(t107) {
    return dP(this.heightMap.blockAt(this.scaler.fromDOM(t107), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}, dT = class {
  constructor(t107, e10) {
    this.from = t107, this.to = e10;
  }
};
function dE(t107, e10) {
  let { total: i10, ranges: s10 } = t107;
  if (e10 <= 0) return s10[0].from;
  if (e10 >= 1) return s10[s10.length - 1].to;
  let n10 = Math.floor(i10 * e10);
  for (let t108 = 0; ; t108++) {
    let { from: e11, to: i11 } = s10[t108], o10 = i11 - e11;
    if (n10 <= o10) return e11 + n10;
    n10 -= o10;
  }
}
function dR(t107, e10) {
  let i10 = 0;
  for (let { from: s10, to: n10 } of t107.ranges) {
    if (e10 <= n10) {
      i10 += e10 - s10;
      break;
    }
    i10 += n10 - s10;
  }
  return i10 / t107.total;
}
let dB = { toDOM: (t107) => t107, fromDOM: (t107) => t107, scale: 1, eq(t107) {
  return t107 == this;
} }, dL = class t80 {
  constructor(t107, e10, i10) {
    let s10 = 0, n10 = 0, o10 = 0;
    for (let r10 of (this.viewports = i10.map((i11) => {
      let { from: n11, to: o11 } = i11, r11 = e10.lineAt(n11, dv.ByPos, t107, 0, 0).top, l10 = e10.lineAt(o11, dv.ByPos, t107, 0, 0).bottom;
      return s10 += l10 - r11, { from: n11, to: o11, top: r11, bottom: l10, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - s10) / (e10.height - s10), this.viewports)) r10.domTop = o10 + (r10.top - n10) * this.scale, o10 = r10.domBottom = r10.domTop + (r10.bottom - r10.top), n10 = r10.bottom;
  }
  toDOM(t107) {
    for (let e10 = 0, i10 = 0, s10 = 0; ; e10++) {
      let n10 = e10 < this.viewports.length ? this.viewports[e10] : null;
      if (!n10 || t107 < n10.top) return s10 + (t107 - i10) * this.scale;
      if (t107 <= n10.bottom) return n10.domTop + (t107 - n10.top);
      i10 = n10.bottom, s10 = n10.domBottom;
    }
  }
  fromDOM(t107) {
    for (let e10 = 0, i10 = 0, s10 = 0; ; e10++) {
      let n10 = e10 < this.viewports.length ? this.viewports[e10] : null;
      if (!n10 || t107 < n10.domTop) return i10 + (t107 - s10) / this.scale;
      if (t107 <= n10.domBottom) return n10.top + (t107 - n10.domTop);
      i10 = n10.bottom, s10 = n10.domBottom;
    }
  }
  eq(e10) {
    return e10 instanceof t80 && this.scale == e10.scale && this.viewports.length == e10.viewports.length && this.viewports.every((t107, i10) => t107.from == e10.viewports[i10].from && t107.to == e10.viewports[i10].to);
  }
};
function dP(t107, e10) {
  if (1 == e10.scale) return t107;
  let i10 = e10.toDOM(t107.top), s10 = e10.toDOM(t107.bottom);
  return new dm(t107.from, t107.length, i10, s10 - i10, Array.isArray(t107._content) ? t107._content.map((t108) => dP(t108, e10)) : t107._content);
}
let dN = to.define({ combine: (t107) => t107.join(" ") }), dV = to.define({ combine: (t107) => t107.indexOf(true) > -1 }), dH = t6.newName(), dF = t6.newName(), dW = t6.newName(), dI = { "&light": "." + dF, "&dark": "." + dW };
function dz(t107, e10, i10) {
  return new t6(e10, { finish: (e11) => /&/.test(e11) ? e11.replace(/&\w*/, (e12) => {
    if ("&" == e12) return t107;
    if (!i10 || !i10[e12]) throw RangeError(`Unsupported selector: ${e12}`);
    return i10[e12];
  }) : t107 + " " + e11 });
}
let dK = dz("." + dH, { "&": { position: "relative !important", boxSizing: "border-box", "&.cm-focused": { outline: "1px dotted #212121" }, display: "flex !important", flexDirection: "column" }, ".cm-scroller": { display: "flex !important", alignItems: "flex-start !important", fontFamily: "monospace", lineHeight: 1.4, height: "100%", overflowX: "auto", position: "relative", zIndex: 0 }, ".cm-content": { margin: 0, flexGrow: 2, flexShrink: 0, display: "block", whiteSpace: "pre", wordWrap: "normal", boxSizing: "border-box", minHeight: "100%", padding: "4px 0", outline: "none", "&[contenteditable=true]": { WebkitUserModify: "read-write-plaintext-only" } }, ".cm-lineWrapping": { whiteSpace_fallback: "pre-wrap", whiteSpace: "break-spaces", wordBreak: "break-word", overflowWrap: "anywhere", flexShrink: 1 }, "&light .cm-content": { caretColor: "black" }, "&dark .cm-content": { caretColor: "white" }, ".cm-line": { display: "block", padding: "0 2px 0 6px" }, ".cm-layer": { position: "absolute", left: 0, top: 0, contain: "size style", "& > *": { position: "absolute" } }, "&light .cm-selectionBackground": { background: "#d9d9d9" }, "&dark .cm-selectionBackground": { background: "#222" }, "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": { background: "#d7d4f0" }, "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": { background: "#233" }, ".cm-cursorLayer": { pointerEvents: "none" }, "&.cm-focused > .cm-scroller > .cm-cursorLayer": { animation: "steps(1) cm-blink 1.2s infinite" }, "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} }, "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} }, ".cm-cursor, .cm-dropCursor": { borderLeft: "1.2px solid black", marginLeft: "-0.6px", pointerEvents: "none" }, ".cm-cursor": { display: "none" }, "&dark .cm-cursor": { borderLeftColor: "#444" }, ".cm-dropCursor": { position: "absolute" }, "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": { display: "block" }, ".cm-iso": { unicodeBidi: "isolate" }, ".cm-announced": { position: "fixed", top: "-10000px" }, "@media print": { ".cm-announced": { display: "none" } }, "&light .cm-activeLine": { backgroundColor: "#cceeff44" }, "&dark .cm-activeLine": { backgroundColor: "#99eeff33" }, "&light .cm-specialChar": { color: "red" }, "&dark .cm-specialChar": { color: "#f78" }, ".cm-gutters": { flexShrink: 0, display: "flex", height: "100%", boxSizing: "border-box", insetInlineStart: 0, zIndex: 200 }, "&light .cm-gutters": { backgroundColor: "#f5f5f5", color: "#6c6c6c", borderRight: "1px solid #ddd" }, "&dark .cm-gutters": { backgroundColor: "#333338", color: "#ccc" }, ".cm-gutter": { display: "flex !important", flexDirection: "column", flexShrink: 0, boxSizing: "border-box", minHeight: "100%", overflow: "hidden" }, ".cm-gutterElement": { boxSizing: "border-box" }, ".cm-lineNumbers .cm-gutterElement": { padding: "0 3px 0 5px", minWidth: "20px", textAlign: "right", whiteSpace: "nowrap" }, "&light .cm-activeLineGutter": { backgroundColor: "#e2f2ff" }, "&dark .cm-activeLineGutter": { backgroundColor: "#222227" }, ".cm-panels": { boxSizing: "border-box", position: "sticky", left: 0, right: 0 }, "&light .cm-panels": { backgroundColor: "#f5f5f5", color: "black" }, "&light .cm-panels-top": { borderBottom: "1px solid #ddd" }, "&light .cm-panels-bottom": { borderTop: "1px solid #ddd" }, "&dark .cm-panels": { backgroundColor: "#333338", color: "white" }, ".cm-tab": { display: "inline-block", overflow: "hidden", verticalAlign: "bottom" }, ".cm-widgetBuffer": { verticalAlign: "text-top", height: "1em", width: 0, display: "inline" }, ".cm-placeholder": { color: "#888", display: "inline-block", verticalAlign: "top" }, ".cm-highlightSpace:before": { content: "attr(data-display)", position: "absolute", pointerEvents: "none", color: "#888" }, ".cm-highlightTab": { backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`, backgroundSize: "auto 100%", backgroundPosition: "right 90%", backgroundRepeat: "no-repeat" }, ".cm-trailingSpace": { backgroundColor: "#ff332255" }, ".cm-button": { verticalAlign: "middle", color: "inherit", fontSize: "70%", padding: ".2em 1em", borderRadius: "1px" }, "&light .cm-button": { backgroundImage: "linear-gradient(#eff1f5, #d9d9df)", border: "1px solid #888", "&:active": { backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)" } }, "&dark .cm-button": { backgroundImage: "linear-gradient(#393939, #111)", border: "1px solid #888", "&:active": { backgroundImage: "linear-gradient(#111, #333)" } }, ".cm-textfield": { verticalAlign: "middle", color: "inherit", fontSize: "70%", border: "1px solid silver", padding: ".2em .5em" }, "&light .cm-textfield": { backgroundColor: "white" }, "&dark .cm-textfield": { border: "1px solid #555", backgroundColor: "inherit" } }, dI), dq = class {
  constructor(t107, e10) {
    this.points = t107, this.text = "", this.lineSeparator = e10.facet(tW.lineSeparator);
  }
  append(t107) {
    this.text += t107;
  }
  lineBreak() {
    this.text += "";
  }
  readRange(t107, e10) {
    if (!t107) return this;
    let i10 = t107.parentNode;
    for (let s10 = t107; ; ) {
      this.findPointBefore(i10, s10);
      let t108 = this.text.length;
      this.readNode(s10);
      let n10 = s10.nextSibling;
      if (n10 == e10) break;
      let o10 = am.get(s10), r10 = am.get(n10);
      (o10 && r10 ? o10.breakAfter : (o10 ? o10.breakAfter : at(s10)) || at(n10) && ("BR" != s10.nodeName || s10.cmIgnore) && this.text.length > t108) && this.lineBreak(), s10 = n10;
    }
    return this.findPointBefore(i10, e10), this;
  }
  readTextNode(t107) {
    let e10 = t107.nodeValue;
    for (let i10 of this.points) i10.node == t107 && (i10.pos = this.text.length + Math.min(i10.offset, e10.length));
    for (let i10 = 0, s10 = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let n10 = -1, o10 = 1, r10;
      if (this.lineSeparator ? (n10 = e10.indexOf(this.lineSeparator, i10), o10 = this.lineSeparator.length) : (r10 = s10.exec(e10)) && (n10 = r10.index, o10 = r10[0].length), this.append(e10.slice(i10, n10 < 0 ? e10.length : n10)), n10 < 0) break;
      if (this.lineBreak(), o10 > 1) for (let e11 of this.points) e11.node == t107 && e11.pos > this.text.length && (e11.pos -= o10 - 1);
      i10 = n10 + o10;
    }
  }
  readNode(t107) {
    if (t107.cmIgnore) return;
    let e10 = am.get(t107), i10 = e10 && e10.overrideDOMText;
    if (null != i10) {
      this.findPointInside(t107, i10.length);
      for (let t108 = i10.iter(); !t108.next().done; ) t108.lineBreak ? this.lineBreak() : this.append(t108.value);
    } else 3 == t107.nodeType ? this.readTextNode(t107) : "BR" == t107.nodeName ? t107.nextSibling && this.lineBreak() : 1 == t107.nodeType && this.readRange(t107.firstChild, null);
  }
  findPointBefore(t107, e10) {
    for (let i10 of this.points) i10.node == t107 && t107.childNodes[i10.offset] == e10 && (i10.pos = this.text.length);
  }
  findPointInside(t107, e10) {
    for (let i10 of this.points) (3 == t107.nodeType ? i10.node == t107 : t107.contains(i10.node)) && (i10.pos = this.text.length + (!function(t108, e11, i11) {
      for (; ; ) {
        if (!e11 || i11 < ai(e11)) return false;
        if (e11 == t108) return true;
        i11 = h7(e11) + 1, e11 = e11.parentNode;
      }
    }(t107, i10.node, i10.offset) ? 0 : e10));
  }
}, d_ = class {
  constructor(t107, e10) {
    this.node = t107, this.offset = e10, this.pos = -1;
  }
}, dG = class {
  constructor(t107, e10, i10, s10) {
    this.typeOver = s10, this.bounds = null, this.text = "", this.domChanged = e10 > -1;
    let { impreciseHead: n10, impreciseAnchor: o10 } = t107.docView;
    if (t107.state.readOnly && e10 > -1) this.newSel = null;
    else if (e10 > -1 && (this.bounds = t107.docView.domBoundsAround(e10, i10, 0))) {
      let e11 = n10 || o10 ? [] : function(t108) {
        let e12 = [];
        if (t108.root.activeElement != t108.contentDOM) return e12;
        let { anchorNode: i12, anchorOffset: s11, focusNode: n11, focusOffset: o11 } = t108.observer.selectionRange;
        return i12 && (e12.push(new d_(i12, s11)), (n11 != i12 || o11 != s11) && e12.push(new d_(n11, o11))), e12;
      }(t107), i11 = new dq(e11, t107.state);
      i11.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = i11.text, this.newSel = function(t108, e12) {
        if (0 == t108.length) return null;
        let i12 = t108[0].pos, s11 = 2 == t108.length ? t108[1].pos : i12;
        return i12 > -1 && s11 > -1 ? ti.single(i12 + e12, s11 + e12) : null;
      }(e11, this.bounds.from);
    } else {
      let e11 = t107.observer.selectionRange, i11 = n10 && n10.node == e11.focusNode && n10.offset == e11.focusOffset || !h4(t107.contentDOM, e11.focusNode) ? t107.state.selection.main.head : t107.docView.posFromDOM(e11.focusNode, e11.focusOffset), s11 = o10 && o10.node == e11.anchorNode && o10.offset == e11.anchorOffset || !h4(t107.contentDOM, e11.anchorNode) ? t107.state.selection.main.anchor : t107.docView.posFromDOM(e11.anchorNode, e11.anchorOffset), r10 = t107.viewport;
      if ((aB.ios || aB.chrome) && t107.state.selection.main.empty && i11 != s11 && (r10.from > 0 || r10.to < t107.state.doc.length)) {
        let e12 = Math.min(i11, s11), n11 = Math.max(i11, s11), o11 = r10.from - e12, l10 = r10.to - n11;
        (0 == o11 || 1 == o11 || 0 == e12) && (0 == l10 || -1 == l10 || n11 == t107.state.doc.length) && (i11 = 0, s11 = t107.state.doc.length);
      }
      this.newSel = ti.single(s11, i11);
    }
  }
};
function dj(t107, e10) {
  let i10;
  let { newSel: s10 } = e10, n10 = t107.state.selection.main, o10 = t107.inputState.lastKeyTime > Date.now() - 100 ? t107.inputState.lastKeyCode : -1;
  if (e10.bounds) {
    let { from: s11, to: l10 } = e10.bounds, h10 = n10.from, a10 = null;
    (8 === o10 || aB.android && e10.text.length < l10 - s11) && (h10 = n10.to, a10 = "end");
    let c10 = function(t108, e11, i11, s12) {
      let n11 = Math.min(t108.length, e11.length), o11 = 0;
      for (; o11 < n11 && t108.charCodeAt(o11) == e11.charCodeAt(o11); ) o11++;
      if (o11 == n11 && t108.length == e11.length) return null;
      let r10 = t108.length, l11 = e11.length;
      for (; r10 > 0 && l11 > 0 && t108.charCodeAt(r10 - 1) == e11.charCodeAt(l11 - 1); ) r10--, l11--;
      if ("end" == s12) {
        let t109 = Math.max(0, o11 - Math.min(r10, l11));
        i11 -= r10 + t109 - o11;
      }
      if (r10 < o11 && t108.length < e11.length) {
        let t109 = i11 <= o11 && i11 >= r10 ? o11 - i11 : 0;
        o11 -= t109, l11 = o11 + (l11 - r10), r10 = o11;
      } else if (l11 < o11) {
        let t109 = i11 <= o11 && i11 >= l11 ? o11 - i11 : 0;
        o11 -= t109, r10 = o11 + (r10 - l11), l11 = o11;
      }
      return { from: o11, toA: r10, toB: l11 };
    }(t107.state.doc.sliceString(s11, l10, ""), e10.text, h10 - s11, a10);
    c10 && (aB.chrome && 13 == o10 && c10.toB == c10.from + 2 && "" == e10.text.slice(c10.from, c10.toB) && c10.toB--, i10 = { from: s11 + c10.from, to: s11 + c10.toA, insert: r.of(e10.text.slice(c10.from, c10.toB).split("")) });
  } else s10 && (!t107.hasFocus && t107.state.facet(cy) || s10.main.eq(n10)) && (s10 = null);
  if (!i10 && !s10) return false;
  if (!i10 && e10.typeOver && !n10.empty && s10 && s10.main.empty ? i10 = { from: n10.from, to: n10.to, insert: t107.state.doc.slice(n10.from, n10.to) } : i10 && i10.from >= n10.from && i10.to <= n10.to && (i10.from != n10.from || i10.to != n10.to) && n10.to - n10.from - (i10.to - i10.from) <= 4 ? i10 = { from: n10.from, to: n10.to, insert: t107.state.doc.slice(n10.from, i10.from).append(i10.insert).append(t107.state.doc.slice(i10.to, n10.to)) } : (aB.mac || aB.android) && i10 && i10.from == i10.to && i10.from == n10.head - 1 && /^\. ?$/.test(i10.insert.toString()) && "off" == t107.contentDOM.getAttribute("autocorrect") ? (s10 && 2 == i10.insert.length && (s10 = ti.single(s10.main.anchor - 1, s10.main.head - 1)), i10 = { from: n10.from, to: n10.to, insert: r.of([" "]) }) : aB.chrome && i10 && i10.from == i10.to && i10.from == n10.head && "\n " == i10.insert.toString() && t107.lineWrapping && (s10 && (s10 = ti.single(s10.main.anchor - 1, s10.main.head - 1)), i10 = { from: n10.from, to: n10.to, insert: r.of([" "]) }), i10) return dU(t107, i10, s10, o10);
  if (!s10 || s10.main.eq(n10)) return false;
  {
    let e11 = false, i11 = "select";
    return t107.inputState.lastSelectionTime > Date.now() - 50 && ("select" == t107.inputState.lastSelectionOrigin && (e11 = true), i11 = t107.inputState.lastSelectionOrigin), t107.dispatch({ selection: s10, scrollIntoView: e11, userEvent: i11 }), true;
  }
}
function dU(t107, e10, i10) {
  let s10, n10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : -1;
  if (aB.ios && t107.inputState.flushIOSKey(e10)) return true;
  let o10 = t107.state.selection.main;
  if (aB.android && (e10.to == o10.to && (e10.from == o10.from || e10.from == o10.from - 1 && " " == t107.state.sliceDoc(e10.from, o10.from)) && 1 == e10.insert.length && 2 == e10.insert.lines && aa(t107.contentDOM, "Enter", 13) || (e10.from == o10.from - 1 && e10.to == o10.to && 0 == e10.insert.length || 8 == n10 && e10.insert.length < e10.to - e10.from && e10.to > o10.head) && aa(t107.contentDOM, "Backspace", 8) || e10.from == o10.from && e10.to == o10.to + 1 && 0 == e10.insert.length && aa(t107.contentDOM, "Delete", 46))) return true;
  let r10 = e10.insert.toString();
  t107.inputState.composing >= 0 && t107.inputState.composing++;
  let l10 = () => s10 || (s10 = function(t108, e11, i11) {
    let s11, n11 = t108.state, o11 = n11.selection.main;
    if (e11.from >= o11.from && e11.to <= o11.to && e11.to - e11.from >= (o11.to - o11.from) / 3 && (!i11 || i11.main.empty && i11.main.from == e11.from + e11.insert.length) && t108.inputState.composing < 0) {
      let i12 = o11.from < e11.from ? n11.sliceDoc(o11.from, e11.from) : "", r12 = o11.to > e11.to ? n11.sliceDoc(e11.to, o11.to) : "";
      s11 = n11.replaceSelection(t108.state.toText(i12 + e11.insert.sliceString(0, void 0, t108.state.lineBreak) + r12));
    } else {
      let r12 = n11.changes(e11), l11 = i11 && i11.main.to <= r12.newLength ? i11.main : void 0;
      if (n11.selection.ranges.length > 1 && t108.inputState.composing >= 0 && e11.to <= o11.to && e11.to >= o11.to - 10) {
        let h10 = t108.state.sliceDoc(e11.from, e11.to), a10, c10 = i11 && cW(t108, i11.main.head);
        if (c10) {
          let t109 = e11.insert.length - (e11.to - e11.from);
          a10 = { from: c10.from, to: c10.to - t109 };
        } else a10 = t108.state.doc.lineAt(o11.head);
        let d10 = o11.to - e11.to, u10 = o11.to - o11.from;
        s11 = n11.changeByRange((i12) => {
          if (i12.from == o11.from && i12.to == o11.to) return { changes: r12, range: l11 || i12.map(r12) };
          let s12 = i12.to - d10, c11 = s12 - h10.length;
          if (i12.to - i12.from != u10 || t108.state.sliceDoc(c11, s12) != h10 || i12.to >= a10.from && i12.from <= a10.to) return { range: i12 };
          let f10 = n11.changes({ from: c11, to: s12, insert: e11.insert }), g10 = i12.to - o11.to;
          return { changes: f10, range: l11 ? ti.range(Math.max(0, l11.anchor + g10), Math.max(0, l11.head + g10)) : i12.map(f10) };
        });
      } else s11 = { changes: r12, selection: l11 && n11.selection.replaceRange(l11) };
    }
    let r11 = "input.type";
    return (t108.composing || t108.inputState.compositionPendingChange && t108.inputState.compositionEndedAt > Date.now() - 50) && (t108.inputState.compositionPendingChange = false, r11 += ".compose", t108.inputState.compositionFirstChange && (r11 += ".start", t108.inputState.compositionFirstChange = false)), n11.update(s11, { userEvent: r11, scrollIntoView: true });
  }(t107, e10, i10));
  return t107.state.facet(cd).some((i11) => i11(t107, e10.from, e10.to, r10, l10)) || t107.dispatch(l10()), true;
}
let dY = { childList: true, characterData: true, subtree: true, attributes: true, characterDataOldValue: true }, d$ = aB.ie && aB.ie_version <= 11, dX = class {
  constructor(t107) {
    this.view = t107, this.active = false, this.editContext = null, this.selectionRange = new ao(), this.selectionChanged = false, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = false, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = t107.contentDOM, this.observer = new MutationObserver((e10) => {
      for (let t108 of e10) this.queue.push(t108);
      (aB.ie && aB.ie_version <= 11 || aB.ios && t107.composing) && e10.some((t108) => "childList" == t108.type && t108.removedNodes.length || "characterData" == t108.type && t108.oldValue.length > t108.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), window.EditContext && false !== t107.constructor.EDIT_CONTEXT && !(aB.chrome && aB.chrome_version < 126) && (this.editContext = new dZ(t107), t107.state.facet(cy) && (t107.contentDOM.editContext = this.editContext.editContext)), d$ && (this.onCharData = (t108) => {
      this.queue.push({ target: t108.target, type: "characterData", oldValue: t108.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), "function" == typeof ResizeObserver && (this.resizeScroll = new ResizeObserver(() => {
      var t108;
      (null === (t108 = this.view.docView) || void 0 === t108 ? void 0 : t108.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(t107.scrollDOM)), this.addWindowListeners(this.win = t107.win), this.start(), "function" == typeof IntersectionObserver && (this.intersection = new IntersectionObserver((t108) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), t108.length > 0 && t108[t108.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((t108) => {
      t108.length > 0 && t108[t108.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(t107) {
    this.view.inputState.runHandlers("scroll", t107), this.intersecting && this.view.measure();
  }
  onScroll(t107) {
    this.intersecting && this.flush(false), this.editContext && this.view.requestMeasure(this.editContext.measureReq), this.onScrollChanged(t107);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(t107) {
    ("change" != t107.type || t107.matches) && (this.view.viewState.printing = true, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = false, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(t107) {
    if (this.gapIntersection && (t107.length != this.gaps.length || this.gaps.some((e10, i10) => e10 != t107[i10]))) {
      for (let e10 of (this.gapIntersection.disconnect(), t107)) this.gapIntersection.observe(e10);
      this.gaps = t107;
    }
  }
  onSelectionChange(t107) {
    let e10 = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey) return;
    let { view: i10 } = this, s10 = this.selectionRange;
    if (i10.state.facet(cy) ? i10.root.activeElement != this.dom : !h9(i10.dom, s10)) return;
    let n10 = s10.anchorNode && i10.docView.nearest(s10.anchorNode);
    if (n10 && n10.ignoreEvent(t107)) {
      e10 || (this.selectionChanged = false);
      return;
    }
    (aB.ie && aB.ie_version <= 11 || aB.android && aB.chrome) && !i10.state.selection.main.empty && s10.focusNode && h6(s10.focusNode, s10.focusOffset, s10.anchorNode, s10.anchorOffset) ? this.flushSoon() : this.flush(false);
  }
  readSelectionRange() {
    let { view: t107 } = this, e10 = h3(t107.root);
    if (!e10) return false;
    let i10 = aB.safari && 11 == t107.root.nodeType && function(t108) {
      let e11 = t108.activeElement;
      for (; e11 && e11.shadowRoot; ) e11 = e11.shadowRoot.activeElement;
      return e11;
    }(this.dom.ownerDocument) == this.dom && function(t108, e11) {
      if (e11.getComposedRanges) {
        let i12 = e11.getComposedRanges(t108.root)[0];
        if (i12) return dQ(t108, i12);
      }
      let i11 = null;
      function s11(t109) {
        t109.preventDefault(), t109.stopImmediatePropagation(), i11 = t109.getTargetRanges()[0];
      }
      return t108.contentDOM.addEventListener("beforeinput", s11, true), t108.dom.ownerDocument.execCommand("indent"), t108.contentDOM.removeEventListener("beforeinput", s11, true), i11 ? dQ(t108, i11) : null;
    }(this.view, e10) || e10;
    if (!i10 || this.selectionRange.eq(i10)) return false;
    let s10 = h9(this.dom, i10);
    return s10 && !this.selectionChanged && t107.inputState.lastFocusTime > Date.now() - 200 && t107.inputState.lastTouchTime < Date.now() - 300 && function(t108, e11) {
      let i11 = e11.focusNode, s11 = e11.focusOffset;
      if (!i11 || e11.anchorNode != i11 || e11.anchorOffset != s11) return false;
      for (s11 = Math.min(s11, ai(i11)); ; ) if (s11) {
        if (1 != i11.nodeType) return false;
        let t109 = i11.childNodes[s11 - 1];
        "false" == t109.contentEditable ? s11-- : s11 = ai(i11 = t109);
      } else {
        if (i11 == t108) return true;
        s11 = h7(i11), i11 = i11.parentNode;
      }
    }(this.dom, i10) ? (this.view.inputState.lastFocusTime = 0, t107.docView.updateSelection(), false) : (this.selectionRange.setRange(i10), s10 && (this.selectionChanged = true), true);
  }
  setSelectionRange(t107, e10) {
    this.selectionRange.set(t107.node, t107.offset, e10.node, e10.offset), this.selectionChanged = false;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let t107 = 0, e10 = null;
    for (let i10 = this.dom; i10; ) if (1 == i10.nodeType) !e10 && t107 < this.scrollTargets.length && this.scrollTargets[t107] == i10 ? t107++ : e10 || (e10 = this.scrollTargets.slice(0, t107)), e10 && e10.push(i10), i10 = i10.assignedSlot || i10.parentNode;
    else if (11 == i10.nodeType) i10 = i10.host;
    else break;
    if (t107 < this.scrollTargets.length && !e10 && (e10 = this.scrollTargets.slice(0, t107)), e10) {
      for (let t108 of this.scrollTargets) t108.removeEventListener("scroll", this.onScroll);
      for (let t108 of this.scrollTargets = e10) t108.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(t107) {
    if (!this.active) return t107();
    try {
      return this.stop(), t107();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, dY), d$ && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = true);
  }
  stop() {
    this.active && (this.active = false, this.observer.disconnect(), d$ && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = false;
  }
  delayAndroidKey(t107, e10) {
    var i10;
    this.delayedAndroidKey || (this.flushingAndroidKey = this.view.win.requestAnimationFrame(() => {
      let t108 = this.delayedAndroidKey;
      t108 && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = t108.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && t108.force && aa(this.dom, t108.key, t108.keyCode));
    })), this.delayedAndroidKey && "Enter" != t107 || (this.delayedAndroidKey = { key: t107, keyCode: e10, force: this.lastChange < Date.now() - 50 || !!(null === (i10 = this.delayedAndroidKey) || void 0 === i10 ? void 0 : i10.force) });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let t107 of this.observer.takeRecords()) this.queue.push(t107);
    return this.queue;
  }
  processRecords() {
    let t107 = this.pendingRecords();
    t107.length && (this.queue = []);
    let e10 = -1, i10 = -1, s10 = false;
    for (let n10 of t107) {
      let t108 = this.readMutation(n10);
      t108 && (t108.typeOver && (s10 = true), -1 == e10 ? { from: e10, to: i10 } = t108 : (e10 = Math.min(t108.from, e10), i10 = Math.max(t108.to, i10)));
    }
    return { from: e10, to: i10, typeOver: s10 };
  }
  readChange() {
    let { from: t107, to: e10, typeOver: i10 } = this.processRecords(), s10 = this.selectionChanged && h9(this.dom, this.selectionRange);
    if (t107 < 0 && !s10) return null;
    t107 > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = false;
    let n10 = new dG(this.view, t107, e10, i10);
    return this.view.docView.domChanged = { newSel: n10.newSel ? n10.newSel.main : null }, n10;
  }
  flush() {
    let t107 = !(arguments.length > 0) || void 0 === arguments[0] || arguments[0];
    if (this.delayedFlush >= 0 || this.delayedAndroidKey) return false;
    t107 && this.readSelectionRange();
    let e10 = this.readChange();
    if (!e10) return this.view.requestMeasure(), false;
    let i10 = this.view.state, s10 = dj(this.view, e10);
    return this.view.state == i10 && (e10.domChanged || e10.newSel && !e10.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), s10;
  }
  readMutation(t107) {
    let e10 = this.view.docView.nearest(t107.target);
    if (!e10 || e10.ignoreMutation(t107)) return null;
    if (e10.markDirty("attributes" == t107.type), "attributes" == t107.type && (e10.flags |= 4), "childList" == t107.type) {
      let i10 = dJ(e10, t107.previousSibling || t107.target.previousSibling, -1), s10 = dJ(e10, t107.nextSibling || t107.target.nextSibling, 1);
      return { from: i10 ? e10.posAfter(i10) : e10.posAtStart, to: s10 ? e10.posBefore(s10) : e10.posAtEnd, typeOver: false };
    }
    return "characterData" == t107.type ? { from: e10.posAtStart, to: e10.posAtEnd, typeOver: t107.target.nodeValue == t107.oldValue } : null;
  }
  setWindow(t107) {
    t107 != this.win && (this.removeWindowListeners(this.win), this.win = t107, this.addWindowListeners(this.win));
  }
  addWindowListeners(t107) {
    t107.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener("change", this.onPrint) : t107.addEventListener("beforeprint", this.onPrint), t107.addEventListener("scroll", this.onScroll), t107.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(t107) {
    t107.removeEventListener("scroll", this.onScroll), t107.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener("change", this.onPrint) : t107.removeEventListener("beforeprint", this.onPrint), t107.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(t107) {
    this.editContext && (this.editContext.update(t107), t107.startState.facet(cy) != t107.state.facet(cy) && (t107.view.contentDOM.editContext = t107.state.facet(cy) ? this.editContext.editContext : null));
  }
  destroy() {
    var t107, e10, i10;
    for (let s10 of (this.stop(), null === (t107 = this.intersection) || void 0 === t107 || t107.disconnect(), null === (e10 = this.gapIntersection) || void 0 === e10 || e10.disconnect(), null === (i10 = this.resizeScroll) || void 0 === i10 || i10.disconnect(), this.scrollTargets)) s10.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey), this.editContext && (this.view.contentDOM.editContext = null, this.editContext.destroy());
  }
};
function dJ(t107, e10, i10) {
  for (; e10; ) {
    let s10 = am.get(e10);
    if (s10 && s10.parent == t107) return s10;
    let n10 = e10.parentNode;
    e10 = n10 != t107.dom ? n10 : i10 > 0 ? e10.nextSibling : e10.previousSibling;
  }
  return null;
}
function dQ(t107, e10) {
  let i10 = e10.startContainer, s10 = e10.startOffset, n10 = e10.endContainer, o10 = e10.endOffset, r10 = t107.docView.domAtPos(t107.state.selection.main.anchor);
  return h6(r10.node, r10.offset, n10, o10) && ([i10, s10, n10, o10] = [n10, o10, i10, s10]), { anchorNode: i10, anchorOffset: s10, focusNode: n10, focusOffset: o10 };
}
class dZ {
  constructor(t107) {
    this.from = 0, this.to = 0, this.pendingContextChange = null, this.handlers = /* @__PURE__ */ Object.create(null), this.resetRange(t107.state);
    let e10 = this.editContext = new window.EditContext({ text: t107.state.doc.sliceString(this.from, this.to), selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, t107.state.selection.main.anchor))), selectionEnd: this.toContextPos(t107.state.selection.main.head) });
    for (let i10 in this.handlers.textupdate = (e11) => {
      let { anchor: i11 } = t107.state.selection.main, s10 = { from: this.toEditorPos(e11.updateRangeStart), to: this.toEditorPos(e11.updateRangeEnd), insert: r.of(e11.text.split("\n")) };
      s10.from == this.from && i11 < this.from ? s10.from = i11 : s10.to == this.to && i11 > this.to && (s10.to = i11), (s10.from != s10.to || s10.insert.length) && (this.pendingContextChange = s10, dU(t107, s10, ti.single(this.toEditorPos(e11.selectionStart), this.toEditorPos(e11.selectionEnd))), this.pendingContextChange && (this.revertPending(t107.state), this.setSelection(t107.state)));
    }, this.handlers.characterboundsupdate = (i11) => {
      let s10 = [], n10 = null;
      for (let e11 = this.toEditorPos(i11.rangeStart), o10 = this.toEditorPos(i11.rangeEnd); e11 < o10; e11++) {
        let i12 = t107.coordsForChar(e11);
        n10 = i12 && new DOMRect(i12.left, i12.top, i12.right - i12.left, i12.bottom - i12.top) || n10 || new DOMRect(), s10.push(n10);
      }
      e10.updateCharacterBounds(i11.rangeStart, s10);
    }, this.handlers.textformatupdate = (e11) => {
      let i11 = [];
      for (let t108 of e11.getTextFormats()) {
        let e12 = t108.underlineStyle, s10 = t108.underlineThickness;
        if ("None" != e12 && "None" != s10) {
          let n10 = `text-decoration: underline ${"Dashed" == e12 ? "dashed " : "Squiggle" == e12 ? "wavy " : ""}${"Thin" == s10 ? 1 : 2}px`;
          i11.push(aU.mark({ attributes: { style: n10 } }).range(this.toEditorPos(t108.rangeStart), this.toEditorPos(t108.rangeEnd)));
        }
      }
      t107.dispatch({ effects: cw.of(aU.set(i11)) });
    }, this.handlers.compositionstart = () => {
      t107.inputState.composing < 0 && (t107.inputState.composing = 0, t107.inputState.compositionFirstChange = true);
    }, this.handlers.compositionend = () => {
      t107.inputState.composing = -1, t107.inputState.compositionFirstChange = null;
    }, this.handlers) e10.addEventListener(i10, this.handlers[i10]);
    this.measureReq = { read: (t108) => {
      this.editContext.updateControlBounds(t108.contentDOM.getBoundingClientRect());
      let e11 = h3(t108.root);
      e11 && e11.rangeCount && this.editContext.updateSelectionBounds(e11.getRangeAt(0).getBoundingClientRect());
    } };
  }
  applyEdits(t107) {
    let e10 = 0, i10 = false, s10 = this.pendingContextChange;
    return t107.changes.iterChanges((n10, o10, r10, l10, h10) => {
      if (i10) return;
      let a10 = h10.length - (o10 - n10);
      if (s10 && o10 >= s10.to) {
        if (s10.from == n10 && s10.to == o10 && s10.insert.eq(h10)) {
          s10 = this.pendingContextChange = null, e10 += a10, this.to += a10;
          return;
        }
        s10 = null, this.revertPending(t107.state);
      }
      if (n10 += e10, (o10 += e10) <= this.from) this.from += a10, this.to += a10;
      else if (n10 < this.to) {
        if (n10 < this.from || o10 > this.to || this.to - this.from + h10.length > 3e4) {
          i10 = true;
          return;
        }
        this.editContext.updateText(this.toContextPos(n10), this.toContextPos(o10), h10.toString()), this.to += a10;
      }
      e10 += a10;
    }), s10 && !i10 && this.revertPending(t107.state), !i10;
  }
  update(t107) {
    let e10 = this.pendingContextChange;
    this.applyEdits(t107) && this.rangeIsValid(t107.state) ? (t107.docChanged || t107.selectionSet || e10) && this.setSelection(t107.state) : (this.pendingContextChange = null, this.resetRange(t107.state), this.editContext.updateText(0, this.editContext.text.length, t107.state.doc.sliceString(this.from, this.to)), this.setSelection(t107.state)), (t107.geometryChanged || t107.docChanged || t107.selectionSet) && t107.view.requestMeasure(this.measureReq);
  }
  resetRange(t107) {
    let { head: e10 } = t107.selection.main;
    this.from = Math.max(0, e10 - 1e4), this.to = Math.min(t107.doc.length, e10 + 1e4);
  }
  revertPending(t107) {
    let e10 = this.pendingContextChange;
    this.pendingContextChange = null, this.editContext.updateText(this.toContextPos(e10.from), this.toContextPos(e10.from + e10.insert.length), t107.doc.sliceString(e10.from, e10.to));
  }
  setSelection(t107) {
    let { main: e10 } = t107.selection, i10 = this.toContextPos(Math.max(this.from, Math.min(this.to, e10.anchor))), s10 = this.toContextPos(e10.head);
    (this.editContext.selectionStart != i10 || this.editContext.selectionEnd != s10) && this.editContext.updateSelection(i10, s10);
  }
  rangeIsValid(t107) {
    let { head: e10 } = t107.selection.main;
    return !(this.from > 0 && e10 - this.from < 500 || this.to < t107.doc.length && this.to - e10 < 500 || this.to - this.from > 3e4);
  }
  toEditorPos(t107) {
    return t107 + this.from;
  }
  toContextPos(t107) {
    return t107 - this.from;
  }
  destroy() {
    for (let t107 in this.handlers) this.editContext.removeEventListener(t107, this.handlers[t107]);
  }
}
let d0 = class t81 {
  get state() {
    return this.viewState.state;
  }
  get viewport() {
    return this.viewState.viewport;
  }
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  get inView() {
    return this.viewState.inView;
  }
  get composing() {
    return this.inputState.composing > 0;
  }
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  get root() {
    return this._root;
  }
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  constructor(t107 = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = false, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), t107.parent && t107.parent.appendChild(this.dom);
    let { dispatch: e10 } = t107;
    for (let i10 of (this.dispatchTransactions = t107.dispatchTransactions || e10 && ((t108) => t108.forEach((t109) => e10(t109, this))) || ((t108) => this.update(t108)), this.dispatch = this.dispatch.bind(this), this._root = t107.root || function(t108) {
      for (; t108; ) {
        if (t108 && (9 == t108.nodeType || 11 == t108.nodeType && t108.host)) return t108;
        t108 = t108.assignedSlot || t108.parentNode;
      }
      return null;
    }(t107.parent) || document, this.viewState = new dO(t107.state || tW.create(t107)), t107.scrollTo && t107.scrollTo.is(cv) && (this.viewState.scrollTarget = t107.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(cS).map((t108) => new cM(t108)), this.plugins)) i10.update(this);
    this.observer = new dX(this), this.inputState = new cX(this), this.inputState.ensureHandlers(this.plugins), this.docView = new cH(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure();
  }
  dispatch() {
    for (var t107 = arguments.length, e10 = Array(t107), i10 = 0; i10 < t107; i10++) e10[i10] = arguments[i10];
    let s10 = 1 == e10.length && e10[0] instanceof tB ? e10 : 1 == e10.length && Array.isArray(e10[0]) ? e10[0] : [this.state.update(...e10)];
    this.dispatchTransactions(s10, this);
  }
  update(t107) {
    if (0 != this.updateState) throw Error("Calls to EditorView.update are not allowed while an update is in progress");
    let e10 = false, i10 = false, s10, n10 = this.state;
    for (let e11 of t107) {
      if (e11.startState != n10) throw RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      n10 = e11.state;
    }
    if (this.destroyed) {
      this.viewState.state = n10;
      return;
    }
    let o10 = this.hasFocus, r10 = 0, l10 = null;
    t107.some((t108) => t108.annotation(da)) ? (this.inputState.notifiedFocused = o10, r10 = 1) : o10 == this.inputState.notifiedFocused || (this.inputState.notifiedFocused = o10, (l10 = dc(n10, o10)) || (r10 = 1));
    let h10 = this.observer.delayedAndroidKey, a10 = null;
    if (h10 ? (this.observer.clearDelayedAndroidKey(), ((a10 = this.observer.readChange()) && !this.state.doc.eq(n10.doc) || !this.state.selection.eq(n10.selection)) && (a10 = null)) : this.observer.clear(), n10.facet(tW.phrases) != this.state.facet(tW.phrases)) return this.setState(n10);
    s10 = cV.create(this, n10, t107), s10.flags |= r10;
    let c10 = this.viewState.scrollTarget;
    try {
      for (let e11 of (this.updateState = 2, t107)) {
        if (c10 && (c10 = c10.map(e11.changes)), e11.scrollIntoView) {
          let { main: t108 } = e11.state.selection;
          c10 = new cm(t108.empty ? t108 : ti.cursor(t108.head, t108.head > t108.anchor ? -1 : 1));
        }
        for (let t108 of e11.effects) t108.is(cv) && (c10 = t108.value.clip(this.state));
      }
      this.viewState.update(s10, c10), this.bidiCache = d8.update(this.bidiCache, s10.changes), s10.empty || (this.updatePlugins(s10), this.inputState.update(s10)), e10 = this.docView.update(s10), this.state.facet(cP) != this.styleModules && this.mountStyles(), i10 = this.updateAttrs(), this.showAnnouncements(t107), this.docView.updateSelection(e10, t107.some((t108) => t108.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (s10.startState.facet(dN) != s10.state.facet(dN) && (this.viewState.mustMeasureContent = true), (e10 || i10 || c10 || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), e10 && this.docViewUpdate(), !s10.empty) for (let t108 of this.state.facet(cc)) try {
      t108(s10);
    } catch (t109) {
      cb(this.state, t109, "update listener");
    }
    (l10 || a10) && Promise.resolve().then(() => {
      l10 && this.state == l10.startState && this.dispatch(l10), a10 && !dj(this, a10) && h10.force && aa(this.contentDOM, h10.key, h10.keyCode);
    });
  }
  setState(t107) {
    if (0 != this.updateState) throw Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = t107;
      return;
    }
    this.updateState = 2;
    let e10 = this.hasFocus;
    try {
      for (let t108 of this.plugins) t108.destroy(this);
      for (let e11 of (this.viewState = new dO(t107), this.plugins = t107.facet(cS).map((t108) => new cM(t108)), this.pluginMap.clear(), this.plugins)) e11.update(this);
      this.docView.destroy(), this.docView = new cH(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    e10 && this.focus(), this.requestMeasure();
  }
  updatePlugins(t107) {
    let e10 = t107.startState.facet(cS), i10 = t107.state.facet(cS);
    if (e10 != i10) {
      let s10 = [];
      for (let n10 of i10) {
        let i11 = e10.indexOf(n10);
        if (i11 < 0) s10.push(new cM(n10));
        else {
          let e11 = this.plugins[i11];
          e11.mustUpdate = t107, s10.push(e11);
        }
      }
      for (let e11 of this.plugins) e11.mustUpdate != t107 && e11.destroy(this);
      this.plugins = s10, this.pluginMap.clear();
    } else for (let e11 of this.plugins) e11.mustUpdate = t107;
    for (let t108 = 0; t108 < this.plugins.length; t108++) this.plugins[t108].update(this);
    e10 != i10 && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let t107 of this.plugins) {
      let e10 = t107.value;
      if (e10 && e10.docViewUpdate) try {
        e10.docViewUpdate(this);
      } catch (t108) {
        cb(this.state, t108, "doc view update listener");
      }
    }
  }
  measure() {
    let t107 = !(arguments.length > 0) || void 0 === arguments[0] || arguments[0];
    if (this.destroyed) return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, t107 && this.observer.forceFlush();
    let e10 = null, i10 = this.scrollDOM, s10 = i10.scrollTop * this.scaleY, { scrollAnchorPos: n10, scrollAnchorHeight: o10 } = this.viewState;
    Math.abs(s10 - this.viewState.scrollTop) > 1 && (o10 = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let t108 = 0; ; t108++) {
        if (o10 < 0) {
          if (ad(i10)) n10 = -1, o10 = this.viewState.heightMap.height;
          else {
            let t109 = this.viewState.scrollAnchorAt(s10);
            n10 = t109.from, o10 = t109.top;
          }
        }
        this.updateState = 1;
        let r10 = this.viewState.measure(this);
        if (!r10 && !this.measureRequests.length && null == this.viewState.scrollTarget) break;
        if (t108 > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let l10 = [];
        4 & r10 || ([this.measureRequests, l10] = [l10, this.measureRequests]);
        let h10 = l10.map((t109) => {
          try {
            return t109.read(this);
          } catch (t110) {
            return cb(this.state, t110), d2;
          }
        }), a10 = cV.create(this, this.state, []), c10 = false;
        a10.flags |= r10, e10 ? e10.flags |= r10 : e10 = a10, this.updateState = 2, !a10.empty && (this.updatePlugins(a10), this.inputState.update(a10), this.updateAttrs(), (c10 = this.docView.update(a10)) && this.docViewUpdate());
        for (let t109 = 0; t109 < l10.length; t109++) if (h10[t109] != d2) try {
          let e11 = l10[t109];
          e11.write && e11.write(h10[t109], this);
        } catch (t110) {
          cb(this.state, t110);
        }
        if (c10 && this.docView.updateSelection(true), !a10.viewportChanged && 0 == this.measureRequests.length) {
          if (this.viewState.editorHeight) {
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, o10 = -1;
              continue;
            }
            {
              let t109 = (n10 < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(n10).top) - o10;
              if (t109 > 1 || t109 < -1) {
                s10 += t109, i10.scrollTop = s10 / this.scaleY, o10 = -1;
                continue;
              }
            }
          }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (e10 && !e10.empty) for (let t108 of this.state.facet(cc)) t108(e10);
  }
  get themeClasses() {
    return dH + " " + (this.state.facet(dV) ? dW : dF) + " " + this.state.facet(dN);
  }
  updateAttrs() {
    let t107 = d3(this, cC, { class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses }), e10 = { spellcheck: "false", autocorrect: "off", autocapitalize: "off", translate: "no", contenteditable: this.state.facet(cy) ? "true" : "false", class: "cm-content", style: `${aB.tabSize}: ${this.state.tabSize}`, role: "textbox", "aria-multiline": "true" };
    this.state.readOnly && (e10["aria-readonly"] = "true"), d3(this, cA, e10);
    let i10 = this.observer.ignore(() => {
      let i11 = aK(this.contentDOM, this.contentAttrs, e10), s10 = aK(this.dom, this.editorAttrs, t107);
      return i11 || s10;
    });
    return this.editorAttrs = t107, this.contentAttrs = e10, i10;
  }
  showAnnouncements(e10) {
    let i10 = true;
    for (let s10 of e10) for (let e11 of s10.effects) e11.is(t81.announce) && (i10 && (this.announceDOM.textContent = ""), i10 = false, this.announceDOM.appendChild(document.createElement("div")).textContent = e11.value);
  }
  mountStyles() {
    this.styleModules = this.state.facet(cP);
    let e10 = this.state.facet(t81.cspNonce);
    t6.mount(this.root, this.styleModules.concat(dK).reverse(), e10 ? { nonce: e10 } : void 0);
  }
  readMeasured() {
    if (2 == this.updateState) throw Error("Reading the editor layout isn't allowed during an update");
    0 == this.updateState && this.measureScheduled > -1 && this.measure(false);
  }
  requestMeasure(t107) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), t107 && !(this.measureRequests.indexOf(t107) > -1)) {
      if (null != t107.key) {
        for (let e10 = 0; e10 < this.measureRequests.length; e10++) if (this.measureRequests[e10].key === t107.key) {
          this.measureRequests[e10] = t107;
          return;
        }
      }
      this.measureRequests.push(t107);
    }
  }
  plugin(t107) {
    let e10 = this.pluginMap.get(t107);
    return (void 0 === e10 || e10 && e10.spec != t107) && this.pluginMap.set(t107, e10 = this.plugins.find((e11) => e11.spec == t107) || null), e10 && e10.update(this).value;
  }
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  get scaleX() {
    return this.viewState.scaleX;
  }
  get scaleY() {
    return this.viewState.scaleY;
  }
  elementAtHeight(t107) {
    return this.readMeasured(), this.viewState.elementAtHeight(t107);
  }
  lineBlockAtHeight(t107) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(t107);
  }
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  lineBlockAt(t107) {
    return this.viewState.lineBlockAt(t107);
  }
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  moveByChar(t107, e10, i10) {
    return c$(this, t107, cU(this, t107, e10, i10));
  }
  moveByGroup(t107, e10) {
    return c$(this, t107, cU(this, t107, e10, (e11) => {
      var i10;
      let s10, n10;
      return i10 = t107.head, n10 = (s10 = this.state.charCategorizer(i10))(e11), (t108) => {
        let e12 = s10(t108);
        return n10 == tH.Space && (n10 = e12), n10 == e12;
      };
    }));
  }
  visualLineSide(t107, e10) {
    let i10 = this.bidiSpans(t107), s10 = this.textDirectionAt(t107.from), n10 = i10[e10 ? i10.length - 1 : 0];
    return ti.cursor(n10.side(e10, s10) + t107.from, n10.forward(!e10, s10) ? 1 : -1);
  }
  moveToLineBoundary(t107, e10) {
    let i10 = !(arguments.length > 2) || void 0 === arguments[2] || arguments[2];
    return function(t108, e11, i11, s10) {
      let n10 = function(t109, e12) {
        let i12 = t109.lineBlockAt(e12);
        if (Array.isArray(i12.type)) {
          for (let t110 of i12.type) if (t110.to > e12 || t110.to == e12 && (t110.to == i12.to || t110.type == aj.Text)) return t110;
        }
        return i12;
      }(t108, e11.head), o10 = s10 && n10.type == aj.Text && (t108.lineWrapping || n10.widgetLineBreaks) ? t108.coordsAtPos(e11.assoc < 0 && e11.head > n10.from ? e11.head - 1 : e11.head) : null;
      if (o10) {
        let e12 = t108.dom.getBoundingClientRect(), s11 = t108.textDirectionAt(n10.from), r10 = t108.posAtCoords({ x: i11 == (s11 == a2.LTR) ? e12.right - 1 : e12.left + 1, y: (o10.top + o10.bottom) / 2 });
        if (null != r10) return ti.cursor(r10, i11 ? -1 : 1);
      }
      return ti.cursor(i11 ? n10.to : n10.from, i11 ? -1 : 1);
    }(this, t107, e10, i10);
  }
  moveVertically(t107, e10, i10) {
    return c$(this, t107, function(t108, e11, i11, s10) {
      let n10 = e11.head, o10 = i11 ? 1 : -1;
      if (n10 == (i11 ? t108.state.doc.length : 0)) return ti.cursor(n10, e11.assoc);
      let r10 = e11.goalColumn, l10, h10 = t108.contentDOM.getBoundingClientRect(), a10 = t108.coordsAtPos(n10, e11.assoc || -1), c10 = t108.documentTop;
      if (a10) null == r10 && (r10 = a10.left - h10.left), l10 = o10 < 0 ? a10.top : a10.bottom;
      else {
        let e12 = t108.viewState.lineBlockAt(n10);
        null == r10 && (r10 = Math.min(h10.right - h10.left, t108.defaultCharacterWidth * (n10 - e12.from))), l10 = (o10 < 0 ? e12.top : e12.bottom) + c10;
      }
      let d10 = h10.left + r10, u10 = null != s10 ? s10 : t108.viewState.heightOracle.textHeight >> 1;
      for (let e12 = 0; ; e12 += 10) {
        let i12 = l10 + (u10 + e12) * o10, s11 = cG(t108, { x: d10, y: i12 }, false, o10);
        if (i12 < h10.top || i12 > h10.bottom || (o10 < 0 ? s11 < n10 : s11 > n10)) {
          let e13 = t108.docView.coordsForChar(s11), n11 = !e13 || i12 < e13.top ? -1 : 1;
          return ti.cursor(s11, n11, void 0, r10);
        }
      }
    }(this, t107, e10, i10));
  }
  domAtPos(t107) {
    return this.docView.domAtPos(t107);
  }
  posAtDOM(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    return this.docView.posFromDOM(t107, e10);
  }
  posAtCoords(t107) {
    let e10 = !(arguments.length > 1) || void 0 === arguments[1] || arguments[1];
    return this.readMeasured(), cG(this, t107, e10);
  }
  coordsAtPos(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
    this.readMeasured();
    let i10 = this.docView.coordsAt(t107, e10);
    if (!i10 || i10.left == i10.right) return i10;
    let s10 = this.state.doc.lineAt(t107), n10 = this.bidiSpans(s10);
    return as(i10, n10[ci.find(n10, t107 - s10.from, -1, e10)].dir == a2.LTR == e10 > 0);
  }
  coordsForChar(t107) {
    return this.readMeasured(), this.docView.coordsForChar(t107);
  }
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  textDirectionAt(t107) {
    return !this.state.facet(cf) || t107 < this.viewport.from || t107 > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(t107));
  }
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  bidiSpans(t107) {
    if (t107.length > d1) return cn(t107.length);
    let e10 = this.textDirectionAt(t107.from), i10;
    for (let s11 of this.bidiCache) if (s11.from == t107.from && s11.dir == e10 && (s11.fresh || function t108(e11, i11) {
      if (e11.length != i11.length) return false;
      for (let s12 = 0; s12 < e11.length; s12++) {
        let n10 = e11[s12], o10 = i11[s12];
        if (n10.from != o10.from || n10.to != o10.to || n10.direction != o10.direction || !t108(n10.inner, o10.inner)) return false;
      }
      return true;
    }(s11.isolates, i10 = cR(this, t107)))) return s11.order;
    i10 || (i10 = cR(this, t107));
    let s10 = function(t108, e11, i11) {
      if (!t108) return [new ci(0, 0, e11 == a3 ? 1 : 0)];
      if (e11 == a8 && !i11.length && !ce.test(t108)) return cn(t108.length);
      if (i11.length) for (; t108.length > cs.length; ) cs[cs.length] = 256;
      let s11 = [], n10 = e11 == a8 ? 0 : 1;
      return function t109(e12, i12, s12, n11, o10, r10, l10) {
        let h10 = i12 % 2 ? 2 : 1;
        (function(t110, e13, i13, s13, n12) {
          for (let o11 = 0; o11 <= s13.length; o11++) {
            let r11 = o11 ? s13[o11 - 1].to : e13, l11 = o11 < s13.length ? s13[o11].from : i13, h11 = o11 ? 256 : n12;
            for (let e14 = r11, i14 = h11, s14 = h11; e14 < l11; e14++) {
              let n13 = ct(t110.charCodeAt(e14));
              512 == n13 ? n13 = i14 : 8 == n13 && 4 == s14 && (n13 = 16), cs[e14] = 4 == n13 ? 2 : n13, 7 & n13 && (s14 = n13), i14 = n13;
            }
            for (let t111 = r11, e14 = h11, s14 = h11; t111 < l11; t111++) {
              let n13 = cs[t111];
              if (128 == n13) t111 < l11 - 1 && e14 == cs[t111 + 1] && 24 & e14 ? n13 = cs[t111] = e14 : cs[t111] = 256;
              else if (64 == n13) {
                let n14 = t111 + 1;
                for (; n14 < l11 && 64 == cs[n14]; ) n14++;
                let o12 = t111 && 8 == e14 || n14 < i13 && 8 == cs[n14] ? 1 == s14 ? 1 : 8 : 256;
                for (let e15 = t111; e15 < n14; e15++) cs[e15] = o12;
                t111 = n14 - 1;
              } else 8 == n13 && 1 == s14 && (cs[t111] = 1);
              e14 = n13, 7 & n13 && (s14 = n13);
            }
          }
        })(e12, o10, r10, n11, h10), function(t110, e13, i13, s13, n12) {
          let o11 = 1 == n12 ? 2 : 1;
          for (let r11 = 0, l11 = 0, h11 = 0; r11 <= s13.length; r11++) {
            let a10 = r11 ? s13[r11 - 1].to : e13, c10 = r11 < s13.length ? s13[r11].from : i13;
            for (let e14 = a10, i14, s14, r12; e14 < c10; e14++) if (s14 = a6[i14 = t110.charCodeAt(e14)]) {
              if (s14 < 0) {
                for (let t111 = l11 - 3; t111 >= 0; t111 -= 3) if (a7[t111 + 1] == -s14) {
                  let i15 = a7[t111 + 2], s15 = 2 & i15 ? n12 : 4 & i15 ? 1 & i15 ? o11 : n12 : 0;
                  s15 && (cs[e14] = cs[a7[t111]] = s15), l11 = t111;
                  break;
                }
              } else if (189 == a7.length) break;
              else a7[l11++] = e14, a7[l11++] = i14, a7[l11++] = h11;
            } else if (2 == (r12 = cs[e14]) || 1 == r12) {
              let t111 = r12 == n12;
              h11 = t111 ? 0 : 1;
              for (let e15 = l11 - 3; e15 >= 0; e15 -= 3) {
                let i15 = a7[e15 + 2];
                if (2 & i15) break;
                if (t111) a7[e15 + 2] |= 2;
                else {
                  if (4 & i15) break;
                  a7[e15 + 2] |= 4;
                }
              }
            }
          }
        }(e12, o10, r10, n11, h10), function(t110, e13, i13, s13) {
          for (let n12 = 0, o11 = s13; n12 <= i13.length; n12++) {
            let r11 = n12 ? i13[n12 - 1].to : t110, l11 = n12 < i13.length ? i13[n12].from : e13;
            for (let h11 = r11; h11 < l11; ) {
              let r12 = cs[h11];
              if (256 == r12) {
                let r13 = h11 + 1;
                for (; ; ) if (r13 == l11) {
                  if (n12 == i13.length) break;
                  r13 = i13[n12++].to, l11 = n12 < i13.length ? i13[n12].from : e13;
                } else if (256 == cs[r13]) r13++;
                else break;
                let a10 = 1 == o11, c10 = a10 == ((r13 < e13 ? cs[r13] : s13) == 1) ? a10 ? 1 : 2 : s13;
                for (let e14 = r13, s14 = n12, o12 = s14 ? i13[s14 - 1].to : t110; e14 > h11; ) e14 == o12 && (e14 = i13[--s14].from, o12 = s14 ? i13[s14 - 1].to : t110), cs[--e14] = c10;
                h11 = r13;
              } else o11 = r12, h11++;
            }
          }
        }(o10, r10, n11, h10), function e13(i13, s13, n12, o11, r11, l11, h11) {
          let a10 = o11 % 2 ? 2 : 1;
          if (o11 % 2 == r11 % 2) for (let c10 = s13, d10 = 0; c10 < n12; ) {
            let s14 = true, u10 = false;
            if (d10 == l11.length || c10 < l11[d10].from) {
              let t110 = cs[c10];
              t110 != a10 && (s14 = false, u10 = 16 == t110);
            }
            let f10 = s14 || 1 != a10 ? null : [], g10 = s14 ? o11 : o11 + 1, p10 = c10;
            e: for (; ; ) if (d10 < l11.length && p10 == l11[d10].from) {
              if (u10) break;
              let e14 = l11[d10];
              if (!s14) for (let t110 = e14.to, i14 = d10 + 1; ; ) {
                if (t110 == n12) break e;
                if (i14 < l11.length && l11[i14].from == t110) t110 = l11[i14++].to;
                else if (cs[t110] == a10) break e;
                else break;
              }
              d10++, f10 ? f10.push(e14) : (e14.from > c10 && h11.push(new ci(c10, e14.from, g10)), t109(i13, e14.direction == a8 != !(g10 % 2) ? o11 + 1 : o11, r11, e14.inner, e14.from, e14.to, h11), c10 = e14.to), p10 = e14.to;
            } else if (p10 == n12 || (s14 ? cs[p10] != a10 : cs[p10] == a10)) break;
            else p10++;
            f10 ? e13(i13, c10, p10, o11 + 1, r11, f10, h11) : c10 < p10 && h11.push(new ci(c10, p10, g10)), c10 = p10;
          }
          else for (let c10 = n12, d10 = l11.length; c10 > s13; ) {
            let n13 = true, u10 = false;
            if (!d10 || c10 > l11[d10 - 1].to) {
              let t110 = cs[c10 - 1];
              t110 != a10 && (n13 = false, u10 = 16 == t110);
            }
            let f10 = n13 || 1 != a10 ? null : [], g10 = n13 ? o11 : o11 + 1, p10 = c10;
            e: for (; ; ) if (d10 && p10 == l11[d10 - 1].to) {
              if (u10) break;
              let e14 = l11[--d10];
              if (!n13) for (let t110 = e14.from, i14 = d10; ; ) {
                if (t110 == s13) break e;
                if (i14 && l11[i14 - 1].to == t110) t110 = l11[--i14].from;
                else if (cs[t110 - 1] == a10) break e;
                else break;
              }
              f10 ? f10.push(e14) : (e14.to < c10 && h11.push(new ci(e14.to, c10, g10)), t109(i13, e14.direction == a8 != !(g10 % 2) ? o11 + 1 : o11, r11, e14.inner, e14.from, e14.to, h11), c10 = e14.from), p10 = e14.from;
            } else if (p10 == s13 || (n13 ? cs[p10 - 1] != a10 : cs[p10 - 1] == a10)) break;
            else p10--;
            f10 ? e13(i13, p10, c10, o11 + 1, r11, f10, h11) : p10 < c10 && h11.push(new ci(p10, c10, g10)), c10 = p10;
          }
        }(e12, o10, r10, i12, s12, n11, l10);
      }(t108, n10, n10, i11, 0, t108.length, s11), s11;
    }(t107.text, e10, i10);
    return this.bidiCache.push(new d8(t107.from, t107.to, e10, i10, true, s10)), s10;
  }
  get hasFocus() {
    var t107;
    return (this.dom.ownerDocument.hasFocus() || aB.safari && (null === (t107 = this.inputState) || void 0 === t107 ? void 0 : t107.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  focus() {
    this.observer.ignore(() => {
      al(this.contentDOM), this.docView.updateSelection();
    });
  }
  setRoot(t107) {
    this._root != t107 && (this._root = t107, this.observer.setWindow((9 == t107.nodeType ? t107 : t107.ownerDocument).defaultView || window), this.mountStyles());
  }
  destroy() {
    for (let t107 of (this.root.activeElement == this.contentDOM && this.contentDOM.blur(), this.plugins)) t107.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = true;
  }
  static scrollIntoView(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return cv.of(new cm("number" == typeof t107 ? ti.cursor(t107) : t107, e10.y, e10.x, e10.yMargin, e10.xMargin));
  }
  scrollSnapshot() {
    let { scrollTop: t107, scrollLeft: e10 } = this.scrollDOM, i10 = this.viewState.scrollAnchorAt(t107);
    return cv.of(new cm(ti.cursor(i10.from), "start", "start", i10.top - t107, e10, true));
  }
  setTabFocusMode(t107) {
    null == t107 ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : "boolean" == typeof t107 ? this.inputState.tabFocusMode = t107 ? 0 : -1 : 0 != this.inputState.tabFocusMode && (this.inputState.tabFocusMode = Date.now() + t107);
  }
  static domEventHandlers(t107) {
    return ck.define(() => ({}), { eventHandlers: t107 });
  }
  static domEventObservers(t107) {
    return ck.define(() => ({}), { eventObservers: t107 });
  }
  static theme(t107, e10) {
    let i10 = t6.newName(), s10 = [dN.of(i10), cP.of(dz(`.${i10}`, t107))];
    return e10 && e10.dark && s10.push(dV.of(true)), s10;
  }
  static baseTheme(t107) {
    return tg.lowest(cP.of(dz("." + dH, t107, dI)));
  }
  static findFromDOM(t107) {
    var e10;
    let i10 = t107.querySelector(".cm-content"), s10 = i10 && am.get(i10) || am.get(t107);
    return (null === (e10 = null == s10 ? void 0 : s10.rootView) || void 0 === e10 ? void 0 : e10.view) || null;
  }
};
d0.styleModule = cP, d0.inputHandler = cd, d0.scrollHandler = cp, d0.focusChangeEffect = cu, d0.perLineTextDirection = cf, d0.exceptionSink = ca, d0.updateListener = cc, d0.editable = cy, d0.mouseSelectionStyle = ch, d0.dragMovesSelection = cl, d0.clickAddsSelectionRange = cr, d0.decorations = cD, d0.outerDecorations = cO, d0.atomicRanges = cT, d0.bidiIsolatedRanges = cE, d0.scrollMargins = cB, d0.darkTheme = dV, d0.cspNonce = to.define({ combine: (t107) => t107.length ? t107[0] : "" }), d0.contentAttributes = cA, d0.editorAttributes = cC, d0.lineWrapping = d0.contentAttributes.of({ class: "cm-lineWrapping" }), d0.announce = tR.define();
let d1 = 4096, d2 = {}, d8 = class t82 {
  constructor(t107, e10, i10, s10, n10, o10) {
    this.from = t107, this.to = e10, this.dir = i10, this.isolates = s10, this.fresh = n10, this.order = o10;
  }
  static update(e10, i10) {
    if (i10.empty && !e10.some((t107) => t107.fresh)) return e10;
    let s10 = [], n10 = e10.length ? e10[e10.length - 1].dir : a2.LTR;
    for (let o10 = Math.max(0, e10.length - 10); o10 < e10.length; o10++) {
      let r10 = e10[o10];
      r10.dir != n10 || i10.touchesRange(r10.from, r10.to) || s10.push(new t82(i10.mapPos(r10.from, 1), i10.mapPos(r10.to, -1), r10.dir, r10.isolates, false, r10.order));
    }
    return s10;
  }
};
function d3(t107, e10, i10) {
  for (let s10 = t107.state.facet(e10), n10 = s10.length - 1; n10 >= 0; n10--) {
    let e11 = s10[n10], o10 = "function" == typeof e11 ? e11(t107) : e11;
    o10 && aW(o10, i10);
  }
  return i10;
}
let d4 = aB.mac ? "mac" : aB.windows ? "win" : aB.linux ? "linux" : "key";
function d9(t107, e10, i10) {
  return e10.altKey && (t107 = "Alt-" + t107), e10.ctrlKey && (t107 = "Ctrl-" + t107), e10.metaKey && (t107 = "Meta-" + t107), false !== i10 && e10.shiftKey && (t107 = "Shift-" + t107), t107;
}
let d5 = tg.default(d0.domEventHandlers({ keydown: (t107, e10) => {
  var i10, s10;
  let n10, o10, r10, l10, h10, a10, c10, d10, u10, f10, g10, p10, m10;
  return n10 = e10.state.facet(d6), (o10 = d7.get(n10)) || d7.set(n10, o10 = function(t108) {
    let e11 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : d4, i11 = /* @__PURE__ */ Object.create(null), s11 = /* @__PURE__ */ Object.create(null), n11 = (t109, e12) => {
      let i12 = s11[t109];
      if (null == i12) s11[t109] = e12;
      else if (i12 != e12) throw Error("Key binding " + t109 + " is used both as a regular binding and as a multi-stroke prefix");
    }, o11 = (t109, s12, o12, r11, l11) => {
      var h11, a11;
      let c11 = i11[t109] || (i11[t109] = /* @__PURE__ */ Object.create(null)), d11 = s12.split(/ (?!$)/).map((t110) => function(t111, e12) {
        let i12, s13, n12, o13;
        let r12 = t111.split(/-(?!$)/), l12 = r12[r12.length - 1];
        "Space" == l12 && (l12 = " ");
        for (let t112 = 0; t112 < r12.length - 1; ++t112) {
          let l13 = r12[t112];
          if (/^(cmd|meta|m)$/i.test(l13)) o13 = true;
          else if (/^a(lt)?$/i.test(l13)) i12 = true;
          else if (/^(c|ctrl|control)$/i.test(l13)) s13 = true;
          else if (/^s(hift)?$/i.test(l13)) n12 = true;
          else if (/^mod$/i.test(l13)) "mac" == e12 ? o13 = true : s13 = true;
          else throw Error("Unrecognized modifier name: " + l13);
        }
        return i12 && (l12 = "Alt-" + l12), s13 && (l12 = "Ctrl-" + l12), o13 && (l12 = "Meta-" + l12), n12 && (l12 = "Shift-" + l12), l12;
      }(t110, e11));
      for (let e12 = 1; e12 < d11.length; e12++) {
        let i12 = d11.slice(0, e12).join(" ");
        n11(i12, true), c11[i12] || (c11[i12] = { preventDefault: true, stopPropagation: false, run: [(e13) => {
          let s13 = ut = { view: e13, prefix: i12, scope: t109 };
          return setTimeout(() => {
            ut == s13 && (ut = null);
          }, 4e3), true;
        }] });
      }
      let u11 = d11.join(" ");
      n11(u11, false);
      let f11 = c11[u11] || (c11[u11] = { preventDefault: false, stopPropagation: false, run: (null === (a11 = null === (h11 = c11._any) || void 0 === h11 ? void 0 : h11.run) || void 0 === a11 ? void 0 : a11.slice()) || [] });
      o12 && f11.run.push(o12), r11 && (f11.preventDefault = true), l11 && (f11.stopPropagation = true);
    };
    for (let s12 of t108) {
      let t109 = s12.scope ? s12.scope.split(" ") : ["editor"];
      if (s12.any) for (let e12 of t109) {
        let t110 = i11[e12] || (i11[e12] = /* @__PURE__ */ Object.create(null));
        t110._any || (t110._any = { preventDefault: false, stopPropagation: false, run: [] });
        let { any: n13 } = s12;
        for (let e13 in t110) t110[e13].run.push((t111) => n13(t111, ue));
      }
      let n12 = s12[e11] || s12.key;
      if (n12) for (let e12 of t109) o11(e12, n12, s12.run, s12.preventDefault, s12.stopPropagation), s12.shift && o11(e12, "Shift-" + n12, s12.shift, s12.preventDefault, s12.stopPropagation);
    }
    return i11;
  }(n10.reduce((t108, e11) => t108.concat(e11), []))), i10 = o10, s10 = "editor", ue = t107, l10 = k(x(r10 = el(t107), 0)) == r10.length && " " != r10, h10 = "", a10 = false, c10 = false, d10 = false, ut && ut.view == e10 && ut.scope == s10 && (h10 = ut.prefix + " ", 0 > c0.indexOf(t107.keyCode) && (c10 = true, ut = null)), u10 = /* @__PURE__ */ new Set(), f10 = (t108) => {
    if (t108) {
      for (let i11 of t108.run) if (!u10.has(i11) && (u10.add(i11), i11(e10))) return t108.stopPropagation && (d10 = true), true;
      t108.preventDefault && (t108.stopPropagation && (d10 = true), c10 = true);
    }
    return false;
  }, (g10 = i10[s10]) && (f10(g10[h10 + d9(r10, t107, !l10)]) ? a10 = true : l10 && (t107.altKey || t107.metaKey || t107.ctrlKey) && !(aB.windows && t107.ctrlKey && t107.altKey) && (p10 = ee[t107.keyCode]) && p10 != r10 ? f10(g10[h10 + d9(p10, t107, true)]) ? a10 = true : t107.shiftKey && (m10 = ei[t107.keyCode]) != r10 && m10 != p10 && f10(g10[h10 + d9(m10, t107, false)]) && (a10 = true) : l10 && t107.shiftKey && f10(g10[h10 + d9(r10, t107, true)]) && (a10 = true), !a10 && f10(g10._any) && (a10 = true)), c10 && (a10 = true), a10 && d10 && t107.stopPropagation(), ue = null, a10;
} })), d6 = to.define({ enables: d5 }), d7 = /* @__PURE__ */ new WeakMap(), ut = null, ue = null, ui = !aB.ios, us = { ".cm-line": { "& ::selection, &::selection": { backgroundColor: "transparent !important" } }, ".cm-content": { "& :focus": { caretColor: "initial !important", "&::selection, & ::selection": { backgroundColor: "Highlight !important" } } } };
ui && (us[".cm-line"].caretColor = us[".cm-content"].caretColor = "transparent !important");
let un = "-10000px";
class uo {
  constructor(t107, e10, i10, s10) {
    this.facet = e10, this.createTooltipView = i10, this.removeTooltipView = s10, this.input = t107.state.facet(e10), this.tooltips = this.input.filter((t108) => t108);
    let n10 = null;
    this.tooltipViews = this.tooltips.map((t108) => n10 = i10(t108, n10));
  }
  update(t107, e10) {
    var i10;
    let s10 = t107.state.facet(this.facet), n10 = s10.filter((t108) => t108);
    if (s10 === this.input) {
      for (let e11 of this.tooltipViews) e11.update && e11.update(t107);
      return false;
    }
    let o10 = [], r10 = e10 ? [] : null;
    for (let i11 = 0; i11 < n10.length; i11++) {
      let s11 = n10[i11], l10 = -1;
      if (s11) {
        for (let t108 = 0; t108 < this.tooltips.length; t108++) {
          let e11 = this.tooltips[t108];
          e11 && e11.create == s11.create && (l10 = t108);
        }
        if (l10 < 0) o10[i11] = this.createTooltipView(s11, i11 ? o10[i11 - 1] : null), r10 && (r10[i11] = !!s11.above);
        else {
          let s12 = o10[i11] = this.tooltipViews[l10];
          r10 && (r10[i11] = e10[l10]), s12.update && s12.update(t107);
        }
      }
    }
    for (let t108 of this.tooltipViews) 0 > o10.indexOf(t108) && (this.removeTooltipView(t108), null === (i10 = t108.destroy) || void 0 === i10 || i10.call(t108));
    return e10 && (r10.forEach((t108, i11) => e10[i11] = t108), e10.length = r10.length), this.input = s10, this.tooltips = n10, this.tooltipViews = o10, true;
  }
}
function ur(t107) {
  let { win: e10 } = t107;
  return { top: 0, left: 0, bottom: e10.innerHeight, right: e10.innerWidth };
}
let ul = to.define({ combine: (t107) => {
  var e10, i10, s10;
  return { position: aB.ios ? "absolute" : (null === (e10 = t107.find((t108) => t108.position)) || void 0 === e10 ? void 0 : e10.position) || "fixed", parent: (null === (i10 = t107.find((t108) => t108.parent)) || void 0 === i10 ? void 0 : i10.parent) || null, tooltipSpace: (null === (s10 = t107.find((t108) => t108.tooltipSpace)) || void 0 === s10 ? void 0 : s10.tooltipSpace) || ur };
} }), uh = /* @__PURE__ */ new WeakMap(), ua = ck.fromClass(class {
  constructor(t107) {
    this.view = t107, this.above = [], this.inView = true, this.madeAbsolute = false, this.lastTransaction = 0, this.measureTimeout = -1;
    let e10 = t107.state.facet(ul);
    this.position = e10.position, this.parent = e10.parent, this.classes = t107.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = "function" == typeof ResizeObserver ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new uo(t107, uu, (t108, e11) => this.createTooltip(t108, e11), (t108) => {
      this.resizeObserver && this.resizeObserver.unobserve(t108.dom), t108.dom.remove();
    }), this.above = this.manager.tooltips.map((t108) => !!t108.above), this.intersectionObserver = "function" == typeof IntersectionObserver ? new IntersectionObserver((t108) => {
      Date.now() > this.lastTransaction - 50 && t108.length > 0 && t108[t108.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), t107.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) for (let t107 of (this.intersectionObserver.disconnect(), this.manager.tooltipViews)) this.intersectionObserver.observe(t107.dom);
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(t107) {
    t107.transactions.length && (this.lastTransaction = Date.now());
    let e10 = this.manager.update(t107, this.above);
    e10 && this.observeIntersection();
    let i10 = e10 || t107.geometryChanged, s10 = t107.state.facet(ul);
    if (s10.position != this.position && !this.madeAbsolute) {
      for (let t108 of (this.position = s10.position, this.manager.tooltipViews)) t108.dom.style.position = this.position;
      i10 = true;
    }
    if (s10.parent != this.parent) {
      for (let t108 of (this.parent && this.container.remove(), this.parent = s10.parent, this.createContainer(), this.manager.tooltipViews)) this.container.appendChild(t108.dom);
      i10 = true;
    } else this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    i10 && this.maybeMeasure();
  }
  createTooltip(t107, e10) {
    let i10 = t107.create(this.view), s10 = e10 ? e10.dom : null;
    if (i10.dom.classList.add("cm-tooltip"), t107.arrow && !i10.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let t108 = document.createElement("div");
      t108.className = "cm-tooltip-arrow", i10.dom.appendChild(t108);
    }
    return i10.dom.style.position = this.position, i10.dom.style.top = un, i10.dom.style.left = "0px", this.container.insertBefore(i10.dom, s10), i10.mount && i10.mount(this.view), this.resizeObserver && this.resizeObserver.observe(i10.dom), i10;
  }
  destroy() {
    var t107, e10, i10;
    for (let e11 of (this.view.win.removeEventListener("resize", this.measureSoon), this.manager.tooltipViews)) e11.dom.remove(), null === (t107 = e11.destroy) || void 0 === t107 || t107.call(e11);
    this.parent && this.container.remove(), null === (e10 = this.resizeObserver) || void 0 === e10 || e10.disconnect(), null === (i10 = this.intersectionObserver) || void 0 === i10 || i10.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let t107 = this.view.dom.getBoundingClientRect(), e10 = 1, i10 = 1, s10 = false;
    if ("fixed" == this.position && this.manager.tooltipViews.length) {
      let { dom: t108 } = this.manager.tooltipViews[0];
      if (aB.gecko) s10 = t108.offsetParent != this.container.ownerDocument.body;
      else if (t108.style.top == un && "0px" == t108.style.left) {
        let e11 = t108.getBoundingClientRect();
        s10 = Math.abs(e11.top + 1e4) > 1 || Math.abs(e11.left) > 1;
      }
    }
    if (s10 || "absolute" == this.position) {
      if (this.parent) {
        let t108 = this.parent.getBoundingClientRect();
        t108.width && t108.height && (e10 = t108.width / this.parent.offsetWidth, i10 = t108.height / this.parent.offsetHeight);
      } else ({ scaleX: e10, scaleY: i10 } = this.view.viewState);
    }
    return { editor: t107, parent: this.parent ? this.container.getBoundingClientRect() : t107, pos: this.manager.tooltips.map((t108, e11) => {
      let i11 = this.manager.tooltipViews[e11];
      return i11.getCoords ? i11.getCoords(t108.pos) : this.view.coordsAtPos(t108.pos);
    }), size: this.manager.tooltipViews.map((t108) => {
      let { dom: e11 } = t108;
      return e11.getBoundingClientRect();
    }), space: this.view.state.facet(ul).tooltipSpace(this.view), scaleX: e10, scaleY: i10, makeAbsolute: s10 };
  }
  writeMeasure(t107) {
    var e10;
    if (t107.makeAbsolute) for (let t108 of (this.madeAbsolute = true, this.position = "absolute", this.manager.tooltipViews)) t108.dom.style.position = "absolute";
    let { editor: i10, space: s10, scaleX: n10, scaleY: o10 } = t107, r10 = [];
    for (let l10 = 0; l10 < this.manager.tooltips.length; l10++) {
      let h10 = this.manager.tooltips[l10], a10 = this.manager.tooltipViews[l10], { dom: c10 } = a10, d10 = t107.pos[l10], u10 = t107.size[l10];
      if (!d10 || d10.bottom <= Math.max(i10.top, s10.top) || d10.top >= Math.min(i10.bottom, s10.bottom) || d10.right < Math.max(i10.left, s10.left) - 0.1 || d10.left > Math.min(i10.right, s10.right) + 0.1) {
        c10.style.top = un;
        continue;
      }
      let f10 = h10.arrow ? a10.dom.querySelector(".cm-tooltip-arrow") : null, g10 = f10 ? 7 : 0, p10 = u10.right - u10.left, m10 = null !== (e10 = uh.get(a10)) && void 0 !== e10 ? e10 : u10.bottom - u10.top, v10 = a10.offset || ud, w10 = this.view.textDirection == a2.LTR, b10 = u10.width > s10.right - s10.left ? w10 ? s10.left : s10.right - u10.width : w10 ? Math.min(d10.left - (f10 ? 14 : 0) + v10.x, s10.right - p10) : Math.max(s10.left, d10.left - p10 + (f10 ? 14 : 0) - v10.x), y10 = this.above[l10];
      !h10.strictSide && (y10 ? d10.top - (u10.bottom - u10.top) - v10.y < s10.top : d10.bottom + (u10.bottom - u10.top) + v10.y > s10.bottom) && y10 == s10.bottom - d10.bottom > d10.top - s10.top && (y10 = this.above[l10] = !y10);
      let x10 = (y10 ? d10.top - s10.top : s10.bottom - d10.bottom) - g10;
      if (x10 < m10 && false !== a10.resize) {
        if (x10 < this.view.defaultLineHeight) {
          c10.style.top = un;
          continue;
        }
        uh.set(a10, m10), c10.style.height = (m10 = x10) / o10 + "px";
      } else c10.style.height && (c10.style.height = "");
      let S2 = y10 ? d10.top - m10 - g10 - v10.y : d10.bottom + g10 + v10.y, k2 = b10 + p10;
      if (true !== a10.overlap) for (let t108 of r10) t108.left < k2 && t108.right > b10 && t108.top < S2 + m10 && t108.bottom > S2 && (S2 = y10 ? t108.top - m10 - 2 - g10 : t108.bottom + g10 + 2);
      if ("absolute" == this.position ? (c10.style.top = (S2 - t107.parent.top) / o10 + "px", c10.style.left = (b10 - t107.parent.left) / n10 + "px") : (c10.style.top = S2 / o10 + "px", c10.style.left = b10 / n10 + "px"), f10) {
        let t108 = d10.left + (w10 ? v10.x : -v10.x) - (b10 + 14 - 7);
        f10.style.left = t108 / n10 + "px";
      }
      true !== a10.overlap && r10.push({ left: b10, top: S2, right: k2, bottom: S2 + m10 }), c10.classList.toggle("cm-tooltip-above", y10), c10.classList.toggle("cm-tooltip-below", !y10), a10.positioned && a10.positioned(t107.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView))) for (let t107 of this.manager.tooltipViews) t107.dom.style.top = un;
  }
}, { eventObservers: { scroll() {
  this.maybeMeasure();
} } }), uc = d0.baseTheme({ ".cm-tooltip": { zIndex: 100, boxSizing: "border-box" }, "&light .cm-tooltip": { border: "1px solid #bbb", backgroundColor: "#f5f5f5" }, "&light .cm-tooltip-section:not(:first-child)": { borderTop: "1px solid #bbb" }, "&dark .cm-tooltip": { backgroundColor: "#333338", color: "white" }, ".cm-tooltip-arrow": { height: "7px", width: "14px", position: "absolute", zIndex: -1, overflow: "hidden", "&:before, &:after": { content: "''", position: "absolute", width: 0, height: 0, borderLeft: "7px solid transparent", borderRight: "7px solid transparent" }, ".cm-tooltip-above &": { bottom: "-7px", "&:before": { borderTop: "7px solid #bbb" }, "&:after": { borderTop: "7px solid #f5f5f5", bottom: "1px" } }, ".cm-tooltip-below &": { top: "-7px", "&:before": { borderBottom: "7px solid #bbb" }, "&:after": { borderBottom: "7px solid #f5f5f5", top: "1px" } } }, "&dark .cm-tooltip .cm-tooltip-arrow": { "&:before": { borderTopColor: "#333338", borderBottomColor: "#333338" }, "&:after": { borderTopColor: "transparent", borderBottomColor: "transparent" } } }), ud = { x: 0, y: 0 }, uu = to.define({ enables: [ua, uc] });
function uf(t107, e10) {
  let i10 = t107.plugin(ua);
  if (!i10) return null;
  let s10 = i10.manager.tooltips.indexOf(e10);
  return s10 < 0 ? null : i10.manager.tooltipViews[s10];
}
let ug = class extends tz {
  compare(t107) {
    return this == t107 || this.constructor == t107.constructor && this.eq(t107);
  }
  eq(t107) {
    return false;
  }
  destroy(t107) {
  }
};
ug.prototype.elementClass = "", ug.prototype.toDOM = void 0, ug.prototype.mapMode = j.TrackBefore, ug.prototype.startSide = ug.prototype.endSide = -1, ug.prototype.point = true;
let up = 1024, um = 0;
class uv {
  constructor(t107, e10) {
    this.from = t107, this.to = e10;
  }
}
class uw {
  constructor(t107 = {}) {
    this.id = um++, this.perNode = !!t107.perNode, this.deserialize = t107.deserialize || (() => {
      throw Error("This node type doesn't define a deserialize function");
    });
  }
  add(t107) {
    if (this.perNode) throw RangeError("Can't add per-node props to node types");
    return "function" != typeof t107 && (t107 = ux.match(t107)), (e10) => {
      let i10 = t107(e10);
      return void 0 === i10 ? null : [this, i10];
    };
  }
}
uw.closedBy = new uw({ deserialize: (t107) => t107.split(" ") }), uw.openedBy = new uw({ deserialize: (t107) => t107.split(" ") }), uw.group = new uw({ deserialize: (t107) => t107.split(" ") }), uw.isolate = new uw({ deserialize: (t107) => {
  if (t107 && "rtl" != t107 && "ltr" != t107 && "auto" != t107) throw RangeError("Invalid value for isolate: " + t107);
  return t107 || "auto";
} }), uw.contextHash = new uw({ perNode: true }), uw.lookAhead = new uw({ perNode: true }), uw.mounted = new uw({ perNode: true });
class ub {
  constructor(t107, e10, i10) {
    this.tree = t107, this.overlay = e10, this.parser = i10;
  }
  static get(t107) {
    return t107 && t107.props && t107.props[uw.mounted.id];
  }
}
let uy = /* @__PURE__ */ Object.create(null);
class ux {
  constructor(t107, e10, i10, s10 = 0) {
    this.name = t107, this.props = e10, this.id = i10, this.flags = s10;
  }
  static define(t107) {
    let e10 = t107.props && t107.props.length ? /* @__PURE__ */ Object.create(null) : uy, i10 = (t107.top ? 1 : 0) | (t107.skipped ? 2 : 0) | (t107.error ? 4 : 0) | (null == t107.name ? 8 : 0), s10 = new ux(t107.name || "", e10, t107.id, i10);
    if (t107.props) {
      for (let i11 of t107.props) if (Array.isArray(i11) || (i11 = i11(s10)), i11) {
        if (i11[0].perNode) throw RangeError("Can't store a per-node prop on a node type");
        e10[i11[0].id] = i11[1];
      }
    }
    return s10;
  }
  prop(t107) {
    return this.props[t107.id];
  }
  get isTop() {
    return (1 & this.flags) > 0;
  }
  get isSkipped() {
    return (2 & this.flags) > 0;
  }
  get isError() {
    return (4 & this.flags) > 0;
  }
  get isAnonymous() {
    return (8 & this.flags) > 0;
  }
  is(t107) {
    if ("string" == typeof t107) {
      if (this.name == t107) return true;
      let e10 = this.prop(uw.group);
      return !!e10 && e10.indexOf(t107) > -1;
    }
    return this.id == t107;
  }
  static match(t107) {
    let e10 = /* @__PURE__ */ Object.create(null);
    for (let i10 in t107) for (let s10 of i10.split(" ")) e10[s10] = t107[i10];
    return (t108) => {
      for (let i10 = t108.prop(uw.group), s10 = -1; s10 < (i10 ? i10.length : 0); s10++) {
        let n10 = e10[s10 < 0 ? t108.name : i10[s10]];
        if (n10) return n10;
      }
    };
  }
}
ux.none = new ux("", /* @__PURE__ */ Object.create(null), 0, 8);
class uS {
  constructor(t107) {
    this.types = t107;
    for (let e10 = 0; e10 < t107.length; e10++) if (t107[e10].id != e10) throw RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  extend() {
    for (var t107 = arguments.length, e10 = Array(t107), i10 = 0; i10 < t107; i10++) e10[i10] = arguments[i10];
    let s10 = [];
    for (let t108 of this.types) {
      let i11 = null;
      for (let s11 of e10) {
        let e11 = s11(t108);
        e11 && (i11 || (i11 = Object.assign({}, t108.props)), i11[e11[0].id] = e11[1]);
      }
      s10.push(i11 ? new ux(t108.name, i11, t108.id, t108.flags) : t108);
    }
    return new uS(s10);
  }
}
let uk = /* @__PURE__ */ new WeakMap(), uM = /* @__PURE__ */ new WeakMap();
(V = _ || (_ = {}))[V.ExcludeBuffers = 1] = "ExcludeBuffers", V[V.IncludeAnonymous = 2] = "IncludeAnonymous", V[V.IgnoreMounts = 4] = "IgnoreMounts", V[V.IgnoreOverlays = 8] = "IgnoreOverlays";
class uC {
  constructor(t107, e10, i10, s10, n10) {
    if (this.type = t107, this.children = e10, this.positions = i10, this.length = s10, this.props = null, n10 && n10.length) for (let [t108, e11] of (this.props = /* @__PURE__ */ Object.create(null), n10)) this.props["number" == typeof t108 ? t108 : t108.id] = e11;
  }
  toString() {
    let t107 = ub.get(this);
    if (t107 && !t107.overlay) return t107.tree.toString();
    let e10 = "";
    for (let t108 of this.children) {
      let i10 = t108.toString();
      i10 && (e10 && (e10 += ","), e10 += i10);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (e10.length ? "(" + e10 + ")" : "") : e10;
  }
  cursor() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
    return new uF(this.topNode, t107);
  }
  cursorAt(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    let i10 = new uF(uk.get(this) || this.topNode);
    return i10.moveTo(t107, e10), uk.set(this, i10._tree), i10;
  }
  get topNode() {
    return new uR(this, 0, 0, null);
  }
  resolve(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i10 = uT(uk.get(this) || this.topNode, t107, e10, false);
    return uk.set(this, i10), i10;
  }
  resolveInner(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i10 = uT(uM.get(this) || this.topNode, t107, e10, true);
    return uM.set(this, i10), i10;
  }
  resolveStack(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    return function(t108, e11, i10) {
      let s10 = t108.resolveInner(e11, i10), n10 = null;
      for (let t109 = s10 instanceof uR ? s10 : s10.context.parent; t109; t109 = t109.parent) if (t109.index < 0) {
        let o10 = t109.parent;
        (n10 || (n10 = [s10])).push(o10.resolve(e11, i10)), t109 = o10;
      } else {
        let o10 = ub.get(t109.tree);
        if (o10 && o10.overlay && o10.overlay[0].from <= e11 && o10.overlay[o10.overlay.length - 1].to >= e11) {
          let r10 = new uR(o10.tree, o10.overlay[0].from + t109.from, -1, t109);
          (n10 || (n10 = [s10])).push(uT(r10, e11, i10, false));
        }
      }
      return n10 ? uV(n10) : s10;
    }(this, t107, e10);
  }
  iterate(t107) {
    let { enter: e10, leave: i10, from: s10 = 0, to: n10 = this.length } = t107, o10 = t107.mode || 0, r10 = (o10 & _.IncludeAnonymous) > 0;
    for (let t108 = this.cursor(o10 | _.IncludeAnonymous); ; ) {
      let o11 = false;
      if (t108.from <= n10 && t108.to >= s10 && (!r10 && t108.type.isAnonymous || false !== e10(t108))) {
        if (t108.firstChild()) continue;
        o11 = true;
      }
      for (; o11 && i10 && (r10 || !t108.type.isAnonymous) && i10(t108), !t108.nextSibling(); ) {
        if (!t108.parent()) return;
        o11 = true;
      }
    }
  }
  prop(t107) {
    return t107.perNode ? this.props ? this.props[t107.id] : void 0 : this.type.prop(t107);
  }
  get propValues() {
    let t107 = [];
    if (this.props) for (let e10 in this.props) t107.push([+e10, this.props[e10]]);
    return t107;
  }
  balance() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    return this.children.length <= 8 ? this : uK(ux.none, this.children, this.positions, 0, this.children.length, 0, this.length, (t108, e10, i10) => new uC(this.type, t108, e10, i10, this.propValues), t107.makeTree || ((t108, e10, i10) => new uC(ux.none, t108, e10, i10)));
  }
  static build(t107) {
    return function(t108) {
      var e10;
      let { buffer: i10, nodeSet: s10, maxBufferLength: n10 = up, reused: o10 = [], minRepeatType: r10 = s10.types.length } = t108, l10 = Array.isArray(i10) ? new uA(i10, i10.length) : i10, h10 = s10.types, a10 = 0, c10 = 0;
      function d10(t109, e11, i11, n11, o11, r11, l11, h11) {
        let a11 = [], c11 = [];
        for (; t109.length > n11; ) a11.push(t109.pop()), c11.push(e11.pop() + i11 - o11);
        t109.push(u10(s10.types[l11], a11, c11, r11 - o11, h11 - r11)), e11.push(o11 - i11);
      }
      function u10(t109, e11, i11, s11) {
        let n11 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, o11 = arguments.length > 5 ? arguments[5] : void 0;
        if (a10) {
          let t110 = [uw.contextHash, a10];
          o11 = o11 ? [t110].concat(o11) : [t110];
        }
        if (n11 > 25) {
          let t110 = [uw.lookAhead, n11];
          o11 = o11 ? [t110].concat(o11) : [t110];
        }
        return new uC(t109, e11, i11, s11, o11);
      }
      let f10 = [], g10 = [];
      for (; l10.pos > 0; ) !function t109(e11, i11, f11, g11, p11, m10) {
        let { id: v10, start: w10, end: b10, size: y10 } = l10, x10 = c10;
        for (; y10 < 0; ) {
          if (l10.next(), -1 == y10) {
            let t110 = o10[v10];
            f11.push(t110), g11.push(w10 - e11);
            return;
          }
          if (-3 == y10) {
            a10 = v10;
            return;
          }
          if (-4 == y10) {
            c10 = v10;
            return;
          }
          throw RangeError(`Unrecognized record size: ${y10}`);
        }
        let S2 = h10[v10], k2, M2, C2 = w10 - e11;
        if (b10 - w10 <= n10 && (M2 = function(t110, e12) {
          let i12 = l10.fork(), s11 = 0, o11 = 0, h11 = 0, a11 = i12.end - n10, c11 = { size: 0, start: 0, skip: 0 };
          s: for (let n11 = i12.pos - t110; i12.pos > n11; ) {
            let t111 = i12.size;
            if (i12.id == e12 && t111 >= 0) {
              c11.size = s11, c11.start = o11, c11.skip = h11, h11 += 4, s11 += 4, i12.next();
              continue;
            }
            let l11 = i12.pos - t111;
            if (t111 < 0 || l11 < n11 || i12.start < a11) break;
            let d11 = i12.id >= r10 ? 4 : 0, u11 = i12.start;
            for (i12.next(); i12.pos > l11; ) {
              if (i12.size < 0) {
                if (-3 == i12.size) d11 += 4;
                else break s;
              } else i12.id >= r10 && (d11 += 4);
              i12.next();
            }
            o11 = u11, s11 += t111, h11 += d11;
          }
          return (e12 < 0 || s11 == t110) && (c11.size = s11, c11.start = o11, c11.skip = h11), c11.size > 4 ? c11 : void 0;
        }(l10.pos - i11, p11))) {
          let t110 = new Uint16Array(M2.size - M2.skip), i12 = l10.pos - M2.size, n11 = t110.length;
          for (; l10.pos > i12; ) n11 = function t111(e12, i13, s11) {
            let { id: n12, start: o11, end: h11, size: d11 } = l10;
            if (l10.next(), d11 >= 0 && n12 < r10) {
              let r11 = s11;
              if (d11 > 4) {
                let n13 = l10.pos - (d11 - 4);
                for (; l10.pos > n13; ) s11 = t111(e12, i13, s11);
              }
              i13[--s11] = r11, i13[--s11] = h11 - e12, i13[--s11] = o11 - e12, i13[--s11] = n12;
            } else -3 == d11 ? a10 = n12 : -4 == d11 && (c10 = n12);
            return s11;
          }(M2.start, t110, n11);
          k2 = new uD(t110, b10 - M2.start, s10), C2 = M2.start - e11;
        } else {
          let e12 = l10.pos - y10;
          l10.next();
          let i12 = [], o11 = [], h11 = v10 >= r10 ? v10 : -1, a11 = 0, c11 = b10;
          for (; l10.pos > e12; ) h11 >= 0 && l10.id == h11 && l10.size >= 0 ? (l10.end <= c11 - n10 && (d10(i12, o11, w10, a11, l10.end, c11, h11, x10), a11 = i12.length, c11 = l10.end), l10.next()) : m10 > 2500 ? function(t110, e13, i13, o12) {
            let r11 = [], h12 = 0, a12 = -1;
            for (; l10.pos > e13; ) {
              let { id: t111, start: e14, end: i14, size: s11 } = l10;
              if (s11 > 4) l10.next();
              else if (a12 > -1 && e14 < a12) break;
              else a12 < 0 && (a12 = i14 - n10), r11.push(t111, e14, i14), h12++, l10.next();
            }
            if (h12) {
              let e14 = new Uint16Array(4 * h12), n11 = r11[r11.length - 2];
              for (let t111 = r11.length - 3, i14 = 0; t111 >= 0; t111 -= 3) e14[i14++] = r11[t111], e14[i14++] = r11[t111 + 1] - n11, e14[i14++] = r11[t111 + 2] - n11, e14[i14++] = i14;
              i13.push(new uD(e14, r11[2] - n11, s10)), o12.push(n11 - t110);
            }
          }(w10, e12, i12, o11) : t109(w10, e12, i12, o11, h11, m10 + 1);
          if (h11 >= 0 && a11 > 0 && a11 < i12.length && d10(i12, o11, w10, a11, w10, c11, h11, x10), i12.reverse(), o11.reverse(), h11 > -1 && a11 > 0) {
            let t110 = /* @__PURE__ */ function(t111) {
              return (e13, i13, s11) => {
                let n11 = 0, o12 = e13.length - 1, r11, l11;
                if (o12 >= 0 && (r11 = e13[o12]) instanceof uC) {
                  if (!o12 && r11.type == t111 && r11.length == s11) return r11;
                  (l11 = r11.prop(uw.lookAhead)) && (n11 = i13[o12] + r11.length + l11);
                }
                return u10(t111, e13, i13, s11, n11);
              };
            }(S2);
            k2 = uK(S2, i12, o11, 0, i12.length, 0, b10 - w10, t110, t110);
          } else k2 = u10(S2, i12, o11, b10 - w10, x10 - b10);
        }
        f11.push(k2), g11.push(C2);
      }(t108.start || 0, t108.bufferStart || 0, f10, g10, -1, 0);
      let p10 = null !== (e10 = t108.length) && void 0 !== e10 ? e10 : f10.length ? g10[0] + f10[0].length : 0;
      return new uC(h10[t108.topID], f10.reverse(), g10.reverse(), p10);
    }(t107);
  }
}
uC.empty = new uC(ux.none, [], [], 0);
class uA {
  constructor(t107, e10) {
    this.buffer = t107, this.index = e10;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new uA(this.buffer, this.index);
  }
}
class uD {
  constructor(t107, e10, i10) {
    this.buffer = t107, this.length = e10, this.set = i10;
  }
  get type() {
    return ux.none;
  }
  toString() {
    let t107 = [];
    for (let e10 = 0; e10 < this.buffer.length; ) t107.push(this.childString(e10)), e10 = this.buffer[e10 + 3];
    return t107.join(",");
  }
  childString(t107) {
    let e10 = this.buffer[t107], i10 = this.buffer[t107 + 3], s10 = this.set.types[e10], n10 = s10.name;
    if (/\W/.test(n10) && !s10.isError && (n10 = JSON.stringify(n10)), i10 == (t107 += 4)) return n10;
    let o10 = [];
    for (; t107 < i10; ) o10.push(this.childString(t107)), t107 = this.buffer[t107 + 3];
    return n10 + "(" + o10.join(",") + ")";
  }
  findChild(t107, e10, i10, s10, n10) {
    let { buffer: o10 } = this, r10 = -1;
    for (let l10 = t107; l10 != e10 && (!uO(n10, s10, o10[l10 + 1], o10[l10 + 2]) || (r10 = l10, !(i10 > 0))); l10 = o10[l10 + 3]) ;
    return r10;
  }
  slice(t107, e10, i10) {
    let s10 = this.buffer, n10 = new Uint16Array(e10 - t107), o10 = 0;
    for (let r10 = t107, l10 = 0; r10 < e10; ) {
      n10[l10++] = s10[r10++], n10[l10++] = s10[r10++] - i10;
      let e11 = n10[l10++] = s10[r10++] - i10;
      n10[l10++] = s10[r10++] - t107, o10 = Math.max(o10, e11);
    }
    return new uD(n10, o10, this.set);
  }
}
function uO(t107, e10, i10, s10) {
  switch (t107) {
    case -2:
      return i10 < e10;
    case -1:
      return s10 >= e10 && i10 < e10;
    case 0:
      return i10 < e10 && s10 > e10;
    case 1:
      return i10 <= e10 && s10 > e10;
    case 2:
      return s10 > e10;
    case 4:
      return true;
  }
}
function uT(t107, e10, i10, s10) {
  for (var n10; t107.from == t107.to || (i10 < 1 ? t107.from >= e10 : t107.from > e10) || (i10 > -1 ? t107.to <= e10 : t107.to < e10); ) {
    let e11 = !s10 && t107 instanceof uR && t107.index < 0 ? null : t107.parent;
    if (!e11) return t107;
    t107 = e11;
  }
  let o10 = s10 ? 0 : _.IgnoreOverlays;
  if (s10) for (let s11 = t107, r10 = s11.parent; r10; r10 = (s11 = r10).parent) s11 instanceof uR && s11.index < 0 && (null === (n10 = r10.enter(e10, i10, o10)) || void 0 === n10 ? void 0 : n10.from) != s11.from && (t107 = r10);
  for (; ; ) {
    let s11 = t107.enter(e10, i10, o10);
    if (!s11) return t107;
    t107 = s11;
  }
}
class uE {
  cursor() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
    return new uF(this, t107);
  }
  getChild(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s10 = uB(this, t107, e10, i10);
    return s10.length ? s10[0] : null;
  }
  getChildren(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
    return uB(this, t107, e10, i10);
  }
  resolve(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    return uT(this, t107, e10, false);
  }
  resolveInner(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    return uT(this, t107, e10, true);
  }
  matchContext(t107) {
    return uL(this, t107);
  }
  enterUnfinishedNodesBefore(t107) {
    let e10 = this.childBefore(t107), i10 = this;
    for (; e10; ) {
      let t108 = e10.lastChild;
      if (!t108 || t108.to != e10.to) break;
      t108.type.isError && t108.from == t108.to ? (i10 = e10, e10 = t108.prevSibling) : e10 = t108;
    }
    return i10;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class uR extends uE {
  constructor(t107, e10, i10, s10) {
    super(), this._tree = t107, this.from = e10, this.index = i10, this._parent = s10;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(t107, e10, i10, s10) {
    let n10 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
    for (let o10 = this; ; ) {
      for (let { children: r10, positions: l10 } = o10._tree, h10 = e10 > 0 ? r10.length : -1; t107 != h10; t107 += e10) {
        let h11 = r10[t107], a10 = l10[t107] + o10.from;
        if (uO(s10, i10, a10, a10 + h11.length)) {
          if (h11 instanceof uD) {
            if (n10 & _.ExcludeBuffers) continue;
            let r11 = h11.findChild(0, h11.buffer.length, e10, i10 - a10, s10);
            if (r11 > -1) return new uN(new uP(o10, h11, t107, a10), null, r11);
          } else if (n10 & _.IncludeAnonymous || !h11.type.isAnonymous || uW(h11)) {
            let r11;
            if (!(n10 & _.IgnoreMounts) && (r11 = ub.get(h11)) && !r11.overlay) return new uR(r11.tree, a10, t107, o10);
            let l11 = new uR(h11, a10, t107, o10);
            return n10 & _.IncludeAnonymous || !l11.type.isAnonymous ? l11 : l11.nextChild(e10 < 0 ? h11.children.length - 1 : 0, e10, i10, s10);
          }
        }
      }
      if (n10 & _.IncludeAnonymous || !o10.type.isAnonymous || (t107 = o10.index >= 0 ? o10.index + e10 : e10 < 0 ? -1 : o10._parent._tree.children.length, !(o10 = o10._parent))) return null;
    }
  }
  get firstChild() {
    return this.nextChild(0, 1, 0, 4);
  }
  get lastChild() {
    return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
  }
  childAfter(t107) {
    return this.nextChild(0, 1, t107, 2);
  }
  childBefore(t107) {
    return this.nextChild(this._tree.children.length - 1, -1, t107, -2);
  }
  enter(t107, e10) {
    let i10, s10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    if (!(s10 & _.IgnoreOverlays) && (i10 = ub.get(this._tree)) && i10.overlay) {
      let s11 = t107 - this.from;
      for (let { from: t108, to: n10 } of i10.overlay) if ((e10 > 0 ? t108 <= s11 : t108 < s11) && (e10 < 0 ? n10 >= s11 : n10 > s11)) return new uR(i10.tree, i10.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, t107, e10, s10);
  }
  nextSignificantParent() {
    let t107 = this;
    for (; t107.type.isAnonymous && t107._parent; ) t107 = t107._parent;
    return t107;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  toString() {
    return this._tree.toString();
  }
}
function uB(t107, e10, i10, s10) {
  let n10 = t107.cursor(), o10 = [];
  if (!n10.firstChild()) return o10;
  if (null != i10) {
    for (let t108 = false; !t108; ) if (t108 = n10.type.is(i10), !n10.nextSibling()) return o10;
  }
  for (; ; ) {
    if (null != s10 && n10.type.is(s10)) return o10;
    if (n10.type.is(e10) && o10.push(n10.node), !n10.nextSibling()) return null == s10 ? o10 : [];
  }
}
function uL(t107, e10) {
  let i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e10.length - 1;
  for (let s10 = t107.parent; i10 >= 0; s10 = s10.parent) {
    if (!s10) return false;
    if (!s10.type.isAnonymous) {
      if (e10[i10] && e10[i10] != s10.name) return false;
      i10--;
    }
  }
  return true;
}
class uP {
  constructor(t107, e10, i10, s10) {
    this.parent = t107, this.buffer = e10, this.index = i10, this.start = s10;
  }
}
class uN extends uE {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(t107, e10, i10) {
    super(), this.context = t107, this._parent = e10, this.index = i10, this.type = t107.buffer.set.types[t107.buffer.buffer[i10]];
  }
  child(t107, e10, i10) {
    let { buffer: s10 } = this.context, n10 = s10.findChild(this.index + 4, s10.buffer[this.index + 3], t107, e10 - this.context.start, i10);
    return n10 < 0 ? null : new uN(this.context, this, n10);
  }
  get firstChild() {
    return this.child(1, 0, 4);
  }
  get lastChild() {
    return this.child(-1, 0, 4);
  }
  childAfter(t107) {
    return this.child(1, t107, 2);
  }
  childBefore(t107) {
    return this.child(-1, t107, -2);
  }
  enter(t107, e10) {
    let i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    if (i10 & _.ExcludeBuffers) return null;
    let { buffer: s10 } = this.context, n10 = s10.findChild(this.index + 4, s10.buffer[this.index + 3], e10 > 0 ? 1 : -1, t107 - this.context.start, e10);
    return n10 < 0 ? null : new uN(this.context, this, n10);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(t107) {
    return this._parent ? null : this.context.parent.nextChild(this.context.index + t107, t107, 0, 4);
  }
  get nextSibling() {
    let { buffer: t107 } = this.context, e10 = t107.buffer[this.index + 3];
    return e10 < (this._parent ? t107.buffer[this._parent.index + 3] : t107.buffer.length) ? new uN(this.context, this._parent, e10) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: t107 } = this.context, e10 = this._parent ? this._parent.index + 4 : 0;
    return this.index == e10 ? this.externalSibling(-1) : new uN(this.context, this._parent, t107.findChild(e10, this.index, -1, 0, 4));
  }
  get tree() {
    return null;
  }
  toTree() {
    let t107 = [], e10 = [], { buffer: i10 } = this.context, s10 = this.index + 4, n10 = i10.buffer[this.index + 3];
    if (n10 > s10) {
      let o10 = i10.buffer[this.index + 1];
      t107.push(i10.slice(s10, n10, o10)), e10.push(0);
    }
    return new uC(this.type, t107, e10, this.to - this.from);
  }
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function uV(t107) {
  if (!t107.length) return null;
  let e10 = 0, i10 = t107[0];
  for (let s11 = 1; s11 < t107.length; s11++) {
    let n11 = t107[s11];
    (n11.from > i10.from || n11.to < i10.to) && (i10 = n11, e10 = s11);
  }
  let s10 = i10 instanceof uR && i10.index < 0 ? null : i10.parent, n10 = t107.slice();
  return s10 ? n10[e10] = s10 : n10.splice(e10, 1), new uH(n10, i10);
}
class uH {
  constructor(t107, e10) {
    this.heads = t107, this.node = e10;
  }
  get next() {
    return uV(this.heads);
  }
}
class uF {
  get name() {
    return this.type.name;
  }
  constructor(t107, e10 = 0) {
    if (this.mode = e10, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, t107 instanceof uR) this.yieldNode(t107);
    else {
      this._tree = t107.context.parent, this.buffer = t107.context;
      for (let e11 = t107._parent; e11; e11 = e11._parent) this.stack.unshift(e11.index);
      this.bufferNode = t107, this.yieldBuf(t107.index);
    }
  }
  yieldNode(t107) {
    return !!t107 && (this._tree = t107, this.type = t107.type, this.from = t107.from, this.to = t107.to, true);
  }
  yieldBuf(t107, e10) {
    this.index = t107;
    let { start: i10, buffer: s10 } = this.buffer;
    return this.type = e10 || s10.set.types[s10.buffer[t107]], this.from = i10 + s10.buffer[t107 + 1], this.to = i10 + s10.buffer[t107 + 2], true;
  }
  yield(t107) {
    return !!t107 && (t107 instanceof uR ? (this.buffer = null, this.yieldNode(t107)) : (this.buffer = t107.context, this.yieldBuf(t107.index, t107.type)));
  }
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  enterChild(t107, e10, i10) {
    if (!this.buffer) return this.yield(this._tree.nextChild(t107 < 0 ? this._tree._tree.children.length - 1 : 0, t107, e10, i10, this.mode));
    let { buffer: s10 } = this.buffer, n10 = s10.findChild(this.index + 4, s10.buffer[this.index + 3], t107, e10 - this.buffer.start, i10);
    return !(n10 < 0) && (this.stack.push(this.index), this.yieldBuf(n10));
  }
  firstChild() {
    return this.enterChild(1, 0, 4);
  }
  lastChild() {
    return this.enterChild(-1, 0, 4);
  }
  childAfter(t107) {
    return this.enterChild(1, t107, 2);
  }
  childBefore(t107) {
    return this.enterChild(-1, t107, -2);
  }
  enter(t107, e10) {
    let i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.mode;
    return this.buffer ? !(i10 & _.ExcludeBuffers) && this.enterChild(1, t107, e10) : this.yield(this._tree.enter(t107, e10, i10));
  }
  parent() {
    if (!this.buffer) return this.yieldNode(this.mode & _.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length) return this.yieldBuf(this.stack.pop());
    let t107 = this.mode & _.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(t107);
  }
  sibling(t107) {
    if (!this.buffer) return !!this._tree._parent && this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + t107, t107, 0, 4, this.mode));
    let { buffer: e10 } = this.buffer, i10 = this.stack.length - 1;
    if (t107 < 0) {
      let t108 = i10 < 0 ? 0 : this.stack[i10] + 4;
      if (this.index != t108) return this.yieldBuf(e10.findChild(t108, this.index, -1, 0, 4));
    } else {
      let t108 = e10.buffer[this.index + 3];
      if (t108 < (i10 < 0 ? e10.buffer.length : e10.buffer[this.stack[i10] + 3])) return this.yieldBuf(t108);
    }
    return i10 < 0 && this.yield(this.buffer.parent.nextChild(this.buffer.index + t107, t107, 0, 4, this.mode));
  }
  nextSibling() {
    return this.sibling(1);
  }
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(t107) {
    let e10, i10, { buffer: s10 } = this;
    if (s10) {
      if (t107 > 0) {
        if (this.index < s10.buffer.buffer.length) return false;
      } else for (let t108 = 0; t108 < this.index; t108++) if (s10.buffer.buffer[t108 + 3] < this.index) return false;
      ({ index: e10, parent: i10 } = s10);
    } else ({ index: e10, _parent: i10 } = this._tree);
    for (; i10; { index: e10, _parent: i10 } = i10) if (e10 > -1) for (let s11 = e10 + t107, n10 = t107 < 0 ? -1 : i10._tree.children.length; s11 != n10; s11 += t107) {
      let t108 = i10._tree.children[s11];
      if (this.mode & _.IncludeAnonymous || t108 instanceof uD || !t108.type.isAnonymous || uW(t108)) return false;
    }
    return true;
  }
  move(t107, e10) {
    if (e10 && this.enterChild(t107, 0, 4)) return true;
    for (; ; ) {
      if (this.sibling(t107)) return true;
      if (this.atLastNode(t107) || !this.parent()) return false;
    }
  }
  next() {
    let t107 = !(arguments.length > 0) || void 0 === arguments[0] || arguments[0];
    return this.move(1, t107);
  }
  prev() {
    let t107 = !(arguments.length > 0) || void 0 === arguments[0] || arguments[0];
    return this.move(-1, t107);
  }
  moveTo(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    for (; (this.from == this.to || (e10 < 1 ? this.from >= t107 : this.from > t107) || (e10 > -1 ? this.to <= t107 : this.to < t107)) && this.parent(); ) ;
    for (; this.enterChild(1, t107, e10); ) ;
    return this;
  }
  get node() {
    if (!this.buffer) return this._tree;
    let t107 = this.bufferNode, e10 = null, i10 = 0;
    if (t107 && t107.context == this.buffer) s: for (let s10 = this.index, n10 = this.stack.length; n10 >= 0; ) {
      for (let o10 = t107; o10; o10 = o10._parent) if (o10.index == s10) {
        if (s10 == this.index) return o10;
        e10 = o10, i10 = n10 + 1;
        break s;
      }
      s10 = this.stack[--n10];
    }
    for (let t108 = i10; t108 < this.stack.length; t108++) e10 = new uN(this.buffer, e10, this.stack[t108]);
    return this.bufferNode = new uN(this.buffer, e10, this.index);
  }
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  iterate(t107, e10) {
    for (let i10 = 0; ; ) {
      let s10 = false;
      if (this.type.isAnonymous || false !== t107(this)) {
        if (this.firstChild()) {
          i10++;
          continue;
        }
        this.type.isAnonymous || (s10 = true);
      }
      for (; s10 && e10 && e10(this), s10 = this.type.isAnonymous, !this.nextSibling(); ) {
        if (!i10) return;
        this.parent(), i10--, s10 = true;
      }
    }
  }
  matchContext(t107) {
    if (!this.buffer) return uL(this.node, t107);
    let { buffer: e10 } = this.buffer, { types: i10 } = e10.set;
    for (let s10 = t107.length - 1, n10 = this.stack.length - 1; s10 >= 0; n10--) {
      if (n10 < 0) return uL(this.node, t107, s10);
      let o10 = i10[e10.buffer[this.stack[n10]]];
      if (!o10.isAnonymous) {
        if (t107[s10] && t107[s10] != o10.name) return false;
        s10--;
      }
    }
    return true;
  }
}
function uW(t107) {
  return t107.children.some((t108) => t108 instanceof uD || !t108.type.isAnonymous || uW(t108));
}
let uI = /* @__PURE__ */ new WeakMap();
function uz(t107, e10) {
  if (!t107.isAnonymous || e10 instanceof uD || e10.type != t107) return 1;
  let i10 = uI.get(e10);
  if (null == i10) {
    for (let s10 of (i10 = 1, e10.children)) {
      if (s10.type != t107 || !(s10 instanceof uC)) {
        i10 = 1;
        break;
      }
      i10 += uz(t107, s10);
    }
    uI.set(e10, i10);
  }
  return i10;
}
function uK(t107, e10, i10, s10, n10, o10, r10, l10, h10) {
  let a10 = 0;
  for (let i11 = s10; i11 < n10; i11++) a10 += uz(t107, e10[i11]);
  let c10 = Math.ceil(1.5 * a10 / 8), d10 = [], u10 = [];
  return !function e11(i11, s11, n11, r11, l11) {
    for (let a11 = n11; a11 < r11; ) {
      let n12 = a11, f10 = s11[a11], g10 = uz(t107, i11[a11]);
      for (a11++; a11 < r11; a11++) {
        let e12 = uz(t107, i11[a11]);
        if (g10 + e12 >= c10) break;
        g10 += e12;
      }
      if (a11 == n12 + 1) {
        if (g10 > c10) {
          let t108 = i11[n12];
          e11(t108.children, t108.positions, 0, t108.children.length, s11[n12] + l11);
          continue;
        }
        d10.push(i11[n12]);
      } else {
        let e12 = s11[a11 - 1] + i11[a11 - 1].length - f10;
        d10.push(uK(t107, i11, s11, n12, a11, f10, e12, null, h10));
      }
      u10.push(f10 + l11 - o10);
    }
  }(e10, i10, s10, n10, 0), (l10 || h10)(d10, u10, r10);
}
class uq {
  constructor(t107, e10, i10, s10, n10 = false, o10 = false) {
    this.from = t107, this.to = e10, this.tree = i10, this.offset = s10, this.open = (n10 ? 1 : 0) | (o10 ? 2 : 0);
  }
  get openStart() {
    return (1 & this.open) > 0;
  }
  get openEnd() {
    return (2 & this.open) > 0;
  }
  static addTree(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], i10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], s10 = [new uq(0, t107.length, t107, 0, false, i10)];
    for (let i11 of e10) i11.to > t107.length && s10.push(i11);
    return s10;
  }
  static applyChanges(t107, e10) {
    let i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 128;
    if (!e10.length) return t107;
    let s10 = [], n10 = 1, o10 = t107.length ? t107[0] : null;
    for (let r10 = 0, l10 = 0, h10 = 0; ; r10++) {
      let a10 = r10 < e10.length ? e10[r10] : null, c10 = a10 ? a10.fromA : 1e9;
      if (c10 - l10 >= i10) for (; o10 && o10.from < c10; ) {
        let e11 = o10;
        if (l10 >= e11.from || c10 <= e11.to || h10) {
          let t108 = Math.max(e11.from, l10) - h10, i11 = Math.min(e11.to, c10) - h10;
          e11 = t108 >= i11 ? null : new uq(t108, i11, e11.tree, e11.offset + h10, r10 > 0, !!a10);
        }
        if (e11 && s10.push(e11), o10.to > c10) break;
        o10 = n10 < t107.length ? t107[n10++] : null;
      }
      if (!a10) break;
      l10 = a10.toA, h10 = a10.toA - a10.toB;
    }
    return s10;
  }
}
class u_ {
  startParse(t107, e10, i10) {
    return "string" == typeof t107 && (t107 = new uG(t107)), i10 = i10 ? i10.length ? i10.map((t108) => new uv(t108.from, t108.to)) : [new uv(0, 0)] : [new uv(0, t107.length)], this.createParse(t107, e10 || [], i10);
  }
  parse(t107, e10, i10) {
    let s10 = this.startParse(t107, e10, i10);
    for (; ; ) {
      let t108 = s10.advance();
      if (t108) return t108;
    }
  }
}
class uG {
  constructor(t107) {
    this.string = t107;
  }
  get length() {
    return this.string.length;
  }
  chunk(t107) {
    return this.string.slice(t107);
  }
  get lineChunks() {
    return false;
  }
  read(t107, e10) {
    return this.string.slice(t107, e10);
  }
}
function uj(t107) {
  return (11 == t107.nodeType ? t107.getSelection ? t107 : t107.ownerDocument : t107).getSelection();
}
function uU(t107, e10) {
  return !!e10 && (t107 == e10 || t107.contains(1 != e10.nodeType ? e10.parentNode : e10));
}
function uY(t107, e10) {
  if (!e10.anchorNode) return false;
  try {
    return uU(t107, e10.anchorNode);
  } catch (t108) {
    return false;
  }
}
function u$(t107) {
  return 3 == t107.nodeType ? u9(t107, 0, t107.nodeValue.length).getClientRects() : 1 == t107.nodeType ? t107.getClientRects() : [];
}
function uX(t107, e10, i10, s10) {
  return !!i10 && (uZ(t107, e10, i10, s10, -1) || uZ(t107, e10, i10, s10, 1));
}
function uJ(t107) {
  for (var e10 = 0; ; e10++) if (!(t107 = t107.previousSibling)) return e10;
}
function uQ(t107) {
  return 1 == t107.nodeType && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t107.nodeName);
}
function uZ(t107, e10, i10, s10, n10) {
  for (; ; ) {
    if (t107 == i10 && e10 == s10) return true;
    if (e10 == (n10 < 0 ? 0 : u0(t107))) {
      if ("DIV" == t107.nodeName) return false;
      let i11 = t107.parentNode;
      if (!i11 || 1 != i11.nodeType) return false;
      e10 = uJ(t107) + (n10 < 0 ? 0 : 1), t107 = i11;
    } else {
      if (1 != t107.nodeType || 1 == (t107 = t107.childNodes[e10 + (n10 < 0 ? -1 : 0)]).nodeType && "false" == t107.contentEditable) return false;
      e10 = n10 < 0 ? u0(t107) : 0;
    }
  }
}
function u0(t107) {
  return 3 == t107.nodeType ? t107.nodeValue.length : t107.childNodes.length;
}
function u1(t107, e10) {
  let i10 = e10 ? t107.left : t107.right;
  return { left: i10, right: i10, top: t107.top, bottom: t107.bottom };
}
function u2(t107, e10) {
  let i10 = e10.width / t107.offsetWidth, s10 = e10.height / t107.offsetHeight;
  return (i10 > 0.995 && i10 < 1.005 || !isFinite(i10) || 1 > Math.abs(e10.width - t107.offsetWidth)) && (i10 = 1), (s10 > 0.995 && s10 < 1.005 || !isFinite(s10) || 1 > Math.abs(e10.height - t107.offsetHeight)) && (s10 = 1), { scaleX: i10, scaleY: s10 };
}
new uw({ perNode: true });
let u8 = class {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(t107) {
    return this.anchorNode == t107.anchorNode && this.anchorOffset == t107.anchorOffset && this.focusNode == t107.focusNode && this.focusOffset == t107.focusOffset;
  }
  setRange(t107) {
    let { anchorNode: e10, focusNode: i10 } = t107;
    this.set(e10, Math.min(t107.anchorOffset, e10 ? u0(e10) : 0), i10, Math.min(t107.focusOffset, i10 ? u0(i10) : 0));
  }
  set(t107, e10, i10, s10) {
    this.anchorNode = t107, this.anchorOffset = e10, this.focusNode = i10, this.focusOffset = s10;
  }
}, u3 = null;
function u4(t107) {
  if (t107.setActive) return t107.setActive();
  if (u3) return t107.focus(u3);
  let e10 = [];
  for (let i10 = t107; i10 && (e10.push(i10, i10.scrollTop, i10.scrollLeft), i10 != i10.ownerDocument); i10 = i10.parentNode) ;
  if (t107.focus(null == u3 ? { get preventScroll() {
    return u3 = { preventScroll: true }, true;
  } } : void 0), !u3) {
    u3 = false;
    for (let t108 = 0; t108 < e10.length; ) {
      let i10 = e10[t108++], s10 = e10[t108++], n10 = e10[t108++];
      i10.scrollTop != s10 && (i10.scrollTop = s10), i10.scrollLeft != n10 && (i10.scrollLeft = n10);
    }
  }
}
function u9(t107, e10) {
  let i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e10, s10 = n || (n = document.createRange());
  return s10.setEnd(t107, i10), s10.setStart(t107, e10), s10;
}
function u5(t107, e10, i10, s10) {
  let n10 = { key: e10, code: e10, keyCode: i10, which: i10, cancelable: true };
  s10 && ({ altKey: n10.altKey, ctrlKey: n10.ctrlKey, shiftKey: n10.shiftKey, metaKey: n10.metaKey } = s10);
  let o10 = new KeyboardEvent("keydown", n10);
  o10.synthetic = true, t107.dispatchEvent(o10);
  let r10 = new KeyboardEvent("keyup", n10);
  return r10.synthetic = true, t107.dispatchEvent(r10), o10.defaultPrevented || r10.defaultPrevented;
}
function u6(t107) {
  for (; t107.attributes.length; ) t107.removeAttributeNode(t107.attributes[0]);
}
function u7(t107) {
  return t107.scrollTop > Math.max(1, t107.scrollHeight - t107.clientHeight - 4);
}
function ft(t107, e10) {
  for (let i10 = t107, s10 = e10; ; ) {
    if (3 == i10.nodeType && s10 > 0) return { node: i10, offset: s10 };
    if (1 == i10.nodeType && s10 > 0) {
      if ("false" == i10.contentEditable) return null;
      s10 = u0(i10 = i10.childNodes[s10 - 1]);
    } else {
      if (!i10.parentNode || uQ(i10)) return null;
      s10 = uJ(i10), i10 = i10.parentNode;
    }
  }
}
function fe(t107, e10) {
  for (let i10 = t107, s10 = e10; ; ) {
    if (3 == i10.nodeType && s10 < i10.nodeValue.length) return { node: i10, offset: s10 };
    if (1 == i10.nodeType && s10 < i10.childNodes.length) {
      if ("false" == i10.contentEditable) return null;
      i10 = i10.childNodes[s10], s10 = 0;
    } else {
      if (!i10.parentNode || uQ(i10)) return null;
      s10 = uJ(i10) + 1, i10 = i10.parentNode;
    }
  }
}
let fi = class t83 {
  constructor(t107, e10, i10 = true) {
    this.node = t107, this.offset = e10, this.precise = i10;
  }
  static before(e10, i10) {
    return new t83(e10.parentNode, uJ(e10), i10);
  }
  static after(e10, i10) {
    return new t83(e10.parentNode, uJ(e10) + 1, i10);
  }
}, fs = [], fn = class t84 {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(t107) {
    let e10 = this.posAtStart;
    for (let i10 of this.children) {
      if (i10 == t107) return e10;
      e10 += i10.length + i10.breakAfter;
    }
    throw RangeError("Invalid child in posBefore");
  }
  posAfter(t107) {
    return this.posBefore(t107) + t107.length;
  }
  sync(e10, i10) {
    if (2 & this.flags) {
      let s10 = this.dom, n10 = null, o10;
      for (let r10 of this.children) {
        if (7 & r10.flags) {
          if (!r10.dom && (o10 = n10 ? n10.nextSibling : s10.firstChild)) {
            let e11 = t84.get(o10);
            (!e11 || !e11.parent && e11.canReuseDOM(r10)) && r10.reuseDOM(o10);
          }
          r10.sync(e10, i10), r10.flags &= -8;
        }
        if (o10 = n10 ? n10.nextSibling : s10.firstChild, i10 && !i10.written && i10.node == s10 && o10 != r10.dom && (i10.written = true), r10.dom.parentNode == s10) for (; o10 && o10 != r10.dom; ) o10 = fo(o10);
        else s10.insertBefore(r10.dom, o10);
        n10 = r10.dom;
      }
      for ((o10 = n10 ? n10.nextSibling : s10.firstChild) && i10 && i10.node == s10 && (i10.written = true); o10; ) o10 = fo(o10);
    } else if (1 & this.flags) for (let t107 of this.children) 7 & t107.flags && (t107.sync(e10, i10), t107.flags &= -8);
  }
  reuseDOM(t107) {
  }
  localPosFromDOM(e10, i10) {
    let s10;
    if (e10 == this.dom) s10 = this.dom.childNodes[i10];
    else {
      let t107 = 0 == u0(e10) ? 0 : 0 == i10 ? -1 : 1;
      for (; ; ) {
        let i11 = e10.parentNode;
        if (i11 == this.dom) break;
        0 == t107 && i11.firstChild != i11.lastChild && (t107 = e10 == i11.firstChild ? -1 : 1), e10 = i11;
      }
      s10 = t107 < 0 ? e10 : e10.nextSibling;
    }
    if (s10 == this.dom.firstChild) return 0;
    for (; s10 && !t84.get(s10); ) s10 = s10.nextSibling;
    if (!s10) return this.length;
    for (let t107 = 0, e11 = 0; ; t107++) {
      let i11 = this.children[t107];
      if (i11.dom == s10) return e11;
      e11 += i11.length + i11.breakAfter;
    }
  }
  domBoundsAround(t107, e10) {
    let i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, s10 = -1, n10 = -1, o10 = -1, r10 = -1;
    for (let l10 = 0, h10 = i10, a10 = i10; l10 < this.children.length; l10++) {
      let i11 = this.children[l10], c10 = h10 + i11.length;
      if (h10 < t107 && c10 > e10) return i11.domBoundsAround(t107, e10, h10);
      if (c10 >= t107 && -1 == s10 && (s10 = l10, n10 = h10), h10 > e10 && i11.dom.parentNode == this.dom) {
        o10 = l10, r10 = a10;
        break;
      }
      a10 = c10, h10 = c10 + i11.breakAfter;
    }
    return { from: n10, to: r10 < 0 ? i10 + this.length : r10, startDOM: (s10 ? this.children[s10 - 1].dom.nextSibling : null) || this.dom.firstChild, endDOM: o10 < this.children.length && o10 >= 0 ? this.children[o10].dom : null };
  }
  markDirty() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
    this.flags |= 2, this.markParentsDirty(t107);
  }
  markParentsDirty(t107) {
    for (let e10 = this.parent; e10; e10 = e10.parent) {
      if (t107 && (e10.flags |= 2), 1 & e10.flags) return;
      e10.flags |= 1, t107 = false;
    }
  }
  setParent(t107) {
    this.parent != t107 && (this.parent = t107, 7 & this.flags && this.markParentsDirty(true));
  }
  setDOM(t107) {
    this.dom != t107 && (this.dom && (this.dom.cmView = null), this.dom = t107, t107.cmView = this);
  }
  get rootView() {
    for (let t107 = this; ; ) {
      let e10 = t107.parent;
      if (!e10) return t107;
      t107 = e10;
    }
  }
  replaceChildren(t107, e10) {
    let i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : fs;
    this.markDirty();
    for (let s10 = t107; s10 < e10; s10++) {
      let t108 = this.children[s10];
      t108.parent == this && 0 > i10.indexOf(t108) && t108.destroy();
    }
    this.children.splice(t107, e10 - t107, ...i10);
    for (let t108 = 0; t108 < i10.length; t108++) i10[t108].setParent(this);
  }
  ignoreMutation(t107) {
    return false;
  }
  ignoreEvent(t107) {
    return false;
  }
  childCursor() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.length;
    return new fr(this.children, t107, this.children.length);
  }
  childPos(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
    return this.childCursor().findPos(t107, e10);
  }
  toString() {
    let t107 = this.constructor.name.replace("View", "");
    return t107 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + ("Text" == t107 ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(t107) {
    return t107.cmView;
  }
  get isEditable() {
    return true;
  }
  get isWidget() {
    return false;
  }
  get isHidden() {
    return false;
  }
  merge(t107, e10, i10, s10, n10, o10) {
    return false;
  }
  become(t107) {
    return false;
  }
  canReuseDOM(t107) {
    return t107.constructor == this.constructor && !((this.flags | t107.flags) & 8);
  }
  getSide() {
    return 0;
  }
  destroy() {
    for (let t107 of this.children) t107.parent == this && t107.destroy();
    this.parent = null;
  }
};
function fo(t107) {
  let e10 = t107.nextSibling;
  return t107.parentNode.removeChild(t107), e10;
}
fn.prototype.breakAfter = 0;
let fr = class {
  constructor(t107, e10, i10) {
    this.children = t107, this.pos = e10, this.i = i10, this.off = 0;
  }
  findPos(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
    for (; ; ) {
      if (t107 > this.pos || t107 == this.pos && (e10 > 0 || 0 == this.i || this.children[this.i - 1].breakAfter)) return this.off = t107 - this.pos, this;
      let i10 = this.children[--this.i];
      this.pos -= i10.length + i10.breakAfter;
    }
  }
};
function fl(t107, e10, i10, s10, n10, o10, r10, l10, h10) {
  let { children: a10 } = t107, c10 = a10.length ? a10[e10] : null, d10 = o10.length ? o10[o10.length - 1] : null, u10 = d10 ? d10.breakAfter : r10;
  if (!(e10 == s10 && c10 && !r10 && !u10 && o10.length < 2 && c10.merge(i10, n10, o10.length ? d10 : null, 0 == i10, l10, h10))) {
    if (s10 < a10.length) {
      let t108 = a10[s10];
      t108 && (n10 < t108.length || t108.breakAfter && (null == d10 ? void 0 : d10.breakAfter)) ? (e10 == s10 && (t108 = t108.split(n10), n10 = 0), !u10 && d10 && t108.merge(0, n10, d10, true, 0, h10) ? o10[o10.length - 1] = t108 : ((n10 || t108.children.length && !t108.children[0].length) && t108.merge(0, n10, null, false, 0, h10), o10.push(t108))) : (null == t108 ? void 0 : t108.breakAfter) && (d10 ? d10.breakAfter = 1 : r10 = 1), s10++;
    }
    for (c10 && (c10.breakAfter = r10, i10 > 0 && (!r10 && o10.length && c10.merge(i10, c10.length, o10[0], false, l10, 0) ? c10.breakAfter = o10.shift().breakAfter : (i10 < c10.length || c10.children.length && 0 == c10.children[c10.children.length - 1].length) && c10.merge(i10, c10.length, null, false, l10, 0), e10++)); e10 < s10 && o10.length; ) if (a10[s10 - 1].become(o10[o10.length - 1])) s10--, o10.pop(), h10 = o10.length ? 0 : l10;
    else if (a10[e10].become(o10[0])) e10++, o10.shift(), l10 = o10.length ? 0 : h10;
    else break;
    !o10.length && e10 && s10 < a10.length && !a10[e10 - 1].breakAfter && a10[s10].merge(0, 0, a10[e10 - 1], false, l10, h10) && e10--, (e10 < s10 || o10.length) && t107.replaceChildren(e10, s10, o10);
  }
}
function fh(t107, e10, i10, s10, n10, o10) {
  let r10 = t107.childCursor(), { i: l10, off: h10 } = r10.findPos(i10, 1), { i: a10, off: c10 } = r10.findPos(e10, -1), d10 = e10 - i10;
  for (let t108 of s10) d10 += t108.length;
  t107.length += d10, fl(t107, a10, c10, l10, h10, s10, 0, n10, o10);
}
let fa = "undefined" != typeof navigator ? navigator : { userAgent: "", vendor: "", platform: "" }, fc = "undefined" != typeof document ? document : { documentElement: { style: {} } }, fd = /Edge\/(\d+)/.exec(fa.userAgent), fu = /MSIE \d/.test(fa.userAgent), ff = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(fa.userAgent), fg = !!(fu || ff || fd), fp = !fg && /gecko\/(\d+)/i.test(fa.userAgent), fm = !fg && /Chrome\/(\d+)/.exec(fa.userAgent), fv = "webkitFontSmoothing" in fc.documentElement.style, fw = !fg && /Apple Computer/.test(fa.vendor), fb = fw && (/Mobile\/\w+/.test(fa.userAgent) || fa.maxTouchPoints > 2);
var fy = { mac: fb || /Mac/.test(fa.platform), windows: /Win/.test(fa.platform), linux: /Linux|X11/.test(fa.platform), ie: fg, ie_version: fu ? fc.documentMode || 6 : ff ? +ff[1] : fd ? +fd[1] : 0, gecko: fp, gecko_version: fp ? +(/Firefox\/(\d+)/.exec(fa.userAgent) || [0, 0])[1] : 0, chrome: !!fm, chrome_version: fm ? +fm[1] : 0, ios: fb, android: /Android\b/.test(fa.userAgent), webkit: fv, safari: fw, webkit_version: fv ? +(/\bAppleWebKit\/(\d+)/.exec(fa.userAgent) || [0, 0])[1] : 0, tabSize: null != fc.documentElement.style.tabSize ? "tab-size" : "-moz-tab-size" };
let fx = class t85 extends fn {
  constructor(t107) {
    super(), this.text = t107;
  }
  get length() {
    return this.text.length;
  }
  createDOM(t107) {
    this.setDOM(t107 || document.createTextNode(this.text));
  }
  sync(t107, e10) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (e10 && e10.node == this.dom && (e10.written = true), this.dom.nodeValue = this.text);
  }
  reuseDOM(t107) {
    3 == t107.nodeType && this.createDOM(t107);
  }
  merge(e10, i10, s10) {
    return !(8 & this.flags) && (!s10 || s10 instanceof t85 && !(this.length - (i10 - e10) + s10.length > 256) && !(8 & s10.flags)) && (this.text = this.text.slice(0, e10) + (s10 ? s10.text : "") + this.text.slice(i10), this.markDirty(), true);
  }
  split(e10) {
    let i10 = new t85(this.text.slice(e10));
    return this.text = this.text.slice(0, e10), this.markDirty(), i10.flags |= 8 & this.flags, i10;
  }
  localPosFromDOM(t107, e10) {
    return t107 == this.dom ? e10 : e10 ? this.text.length : 0;
  }
  domAtPos(t107) {
    return new fi(this.dom, t107);
  }
  domBoundsAround(t107, e10, i10) {
    return { from: i10, to: i10 + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(t107, e10) {
    return function(t108, e11, i10) {
      let s10 = t108.nodeValue.length;
      e11 > s10 && (e11 = s10);
      let n10 = e11, o10 = e11, r10 = 0;
      0 == e11 && i10 < 0 || e11 == s10 && i10 >= 0 ? !(fy.chrome || fy.gecko) && (e11 ? (n10--, r10 = 1) : o10 < s10 && (o10++, r10 = -1)) : i10 < 0 ? n10-- : o10 < s10 && o10++;
      let l10 = u9(t108, n10, o10).getClientRects();
      if (!l10.length) return null;
      let h10 = l10[(r10 ? r10 < 0 : i10 >= 0) ? 0 : l10.length - 1];
      return fy.safari && !r10 && 0 == h10.width && (h10 = Array.prototype.find.call(l10, (t109) => t109.width) || h10), r10 ? u1(h10, r10 < 0) : h10 || null;
    }(this.dom, t107, e10);
  }
}, fS = class t86 extends fn {
  constructor(t107, e10 = [], i10 = 0) {
    for (let s10 of (super(), this.mark = t107, this.children = e10, this.length = i10, e10)) s10.setParent(this);
  }
  setAttrs(t107) {
    if (u6(t107), this.mark.class && (t107.className = this.mark.class), this.mark.attrs) for (let e10 in this.mark.attrs) t107.setAttribute(e10, this.mark.attrs[e10]);
    return t107;
  }
  canReuseDOM(t107) {
    return super.canReuseDOM(t107) && !((this.flags | t107.flags) & 8);
  }
  reuseDOM(t107) {
    t107.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(t107), this.flags |= 6);
  }
  sync(t107, e10) {
    this.dom ? 4 & this.flags && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(t107, e10);
  }
  merge(e10, i10, s10, n10, o10, r10) {
    return (!s10 || !!(s10 instanceof t86 && s10.mark.eq(this.mark)) && (!e10 || !(o10 <= 0)) && (!(i10 < this.length) || !(r10 <= 0))) && (fh(this, e10, i10, s10 ? s10.children.slice() : [], o10 - 1, r10 - 1), this.markDirty(), true);
  }
  split(e10) {
    let i10 = [], s10 = 0, n10 = -1, o10 = 0;
    for (let t107 of this.children) {
      let r11 = s10 + t107.length;
      r11 > e10 && i10.push(s10 < e10 ? t107.split(e10 - s10) : t107), n10 < 0 && s10 >= e10 && (n10 = o10), s10 = r11, o10++;
    }
    let r10 = this.length - e10;
    return this.length = e10, n10 > -1 && (this.children.length = n10, this.markDirty()), new t86(this.mark, i10, r10);
  }
  domAtPos(t107) {
    return fC(this, t107);
  }
  coordsAt(t107, e10) {
    return fA(this, t107, e10);
  }
}, fk = class t87 extends fn {
  static create(e10, i10, s10) {
    return new t87(e10, i10, s10);
  }
  constructor(t107, e10, i10) {
    super(), this.widget = t107, this.length = e10, this.side = i10, this.prevWidget = null;
  }
  split(e10) {
    let i10 = t87.create(this.widget, this.length - e10, this.side);
    return this.length -= e10, i10;
  }
  sync(t107) {
    this.dom && this.widget.updateDOM(this.dom, t107) || (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t107)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e10, i10, s10, n10, o10, r10) {
    return (!s10 || s10 instanceof t87 && !!this.widget.compare(s10.widget) && (!(e10 > 0) || !(o10 <= 0)) && (!(i10 < this.length) || !(r10 <= 0))) && (this.length = e10 + (s10 ? s10.length : 0) + (this.length - i10), true);
  }
  become(e10) {
    return e10 instanceof t87 && e10.side == this.side && this.widget.constructor == e10.widget.constructor && (this.widget.compare(e10.widget) || this.markDirty(true), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e10.widget, this.length = e10.length, true);
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(t107) {
    return this.widget.ignoreEvent(t107);
  }
  get overrideDOMText() {
    if (0 == this.length) return r.empty;
    let t107 = this;
    for (; t107.parent; ) t107 = t107.parent;
    let { view: e10 } = t107, i10 = e10 && e10.state.doc, s10 = this.posAtStart;
    return i10 ? i10.slice(s10, s10 + this.length) : r.empty;
  }
  domAtPos(t107) {
    return (this.length ? 0 == t107 : this.side > 0) ? fi.before(this.dom) : fi.after(this.dom, t107 == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(t107, e10) {
    let i10 = this.widget.coordsAt(this.dom, t107, e10);
    if (i10) return i10;
    let s10 = this.dom.getClientRects(), n10 = null;
    if (!s10.length) return null;
    let o10 = this.side ? this.side < 0 : t107 > 0;
    for (let e11 = o10 ? s10.length - 1 : 0; n10 = s10[e11], t107 > 0 ? 0 != e11 : e11 != s10.length - 1 && !(n10.top < n10.bottom); e11 += o10 ? -1 : 1) ;
    return u1(n10, !o10);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}, fM = class t88 extends fn {
  constructor(t107) {
    super(), this.side = t107;
  }
  get length() {
    return 0;
  }
  merge() {
    return false;
  }
  become(e10) {
    return e10 instanceof t88 && e10.side == this.side;
  }
  split() {
    return new t88(this.side);
  }
  sync() {
    if (!this.dom) {
      let t107 = document.createElement("img");
      t107.className = "cm-widgetBuffer", t107.setAttribute("aria-hidden", "true"), this.setDOM(t107);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(t107) {
    return this.side > 0 ? fi.before(this.dom) : fi.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(t107) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return r.empty;
  }
  get isHidden() {
    return true;
  }
};
function fC(t107, e10) {
  let i10 = t107.dom, { children: s10 } = t107, n10 = 0;
  for (let t108 = 0; n10 < s10.length; n10++) {
    let o10 = s10[n10], r10 = t108 + o10.length;
    if (!(r10 == t108 && 0 >= o10.getSide())) {
      if (e10 > t108 && e10 < r10 && o10.dom.parentNode == i10) return o10.domAtPos(e10 - t108);
      if (e10 <= t108) break;
      t108 = r10;
    }
  }
  for (let t108 = n10; t108 > 0; t108--) {
    let e11 = s10[t108 - 1];
    if (e11.dom.parentNode == i10) return e11.domAtPos(e11.length);
  }
  for (let t108 = n10; t108 < s10.length; t108++) {
    let e11 = s10[t108];
    if (e11.dom.parentNode == i10) return e11.domAtPos(0);
  }
  return new fi(i10, 0);
}
function fA(t107, e10, i10) {
  let s10 = null, n10 = -1, o10 = null, r10 = -1;
  !function t108(e11, l11) {
    for (let h10 = 0, a10 = 0; h10 < e11.children.length && a10 <= l11; h10++) {
      let c10 = e11.children[h10], d10 = a10 + c10.length;
      d10 >= l11 && (c10.children.length ? t108(c10, l11 - a10) : (!o10 || o10.isHidden && i10 > 0) && (d10 > l11 || a10 == d10 && c10.getSide() > 0) ? (o10 = c10, r10 = l11 - a10) : (a10 < l11 || a10 == d10 && 0 > c10.getSide() && !c10.isHidden) && (s10 = c10, n10 = l11 - a10)), a10 = d10;
    }
  }(t107, e10);
  let l10 = (i10 < 0 ? s10 : o10) || s10 || o10;
  return l10 ? l10.coordsAt(Math.max(0, l10 == s10 ? n10 : r10), i10) : function(t108) {
    let e11 = t108.dom.lastChild;
    if (!e11) return t108.dom.getBoundingClientRect();
    let i11 = u$(e11);
    return i11[i11.length - 1] || null;
  }(t107);
}
function fD(t107, e10) {
  for (let i10 in t107) "class" == i10 && e10.class ? e10.class += " " + t107.class : "style" == i10 && e10.style ? e10.style += ";" + t107.style : e10[i10] = t107[i10];
  return e10;
}
fx.prototype.children = fk.prototype.children = fM.prototype.children = fs;
let fO = /* @__PURE__ */ Object.create(null);
function fT(t107, e10, i10) {
  if (t107 == e10) return true;
  t107 || (t107 = fO), e10 || (e10 = fO);
  let s10 = Object.keys(t107), n10 = Object.keys(e10);
  if (s10.length - (i10 && s10.indexOf(i10) > -1 ? 1 : 0) != n10.length - (i10 && n10.indexOf(i10) > -1 ? 1 : 0)) return false;
  for (let o10 of s10) if (o10 != i10 && (-1 == n10.indexOf(o10) || t107[o10] !== e10[o10])) return false;
  return true;
}
function fE(t107, e10, i10) {
  let s10 = false;
  if (e10) for (let n10 in e10) i10 && n10 in i10 || (s10 = true, "style" == n10 ? t107.style.cssText = "" : t107.removeAttribute(n10));
  if (i10) for (let n10 in i10) e10 && e10[n10] == i10[n10] || (s10 = true, "style" == n10 ? t107.style.cssText = i10[n10] : t107.setAttribute(n10, i10[n10]));
  return s10;
}
let fR = class t89 extends fn {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  merge(e10, i10, s10, n10, o10, r10) {
    if (s10) {
      if (!(s10 instanceof t89)) return false;
      this.dom || s10.transferDOM(this);
    }
    return n10 && this.setDeco(s10 ? s10.attrs : null), fh(this, e10, i10, s10 ? s10.children.slice() : [], o10, r10), true;
  }
  split(e10) {
    let i10 = new t89();
    if (i10.breakAfter = this.breakAfter, 0 == this.length) return i10;
    let { i: s10, off: n10 } = this.childPos(e10);
    n10 && (i10.append(this.children[s10].split(n10), 0), this.children[s10].merge(n10, this.children[s10].length, null, false, 0, 0), s10++);
    for (let t107 = s10; t107 < this.children.length; t107++) i10.append(this.children[t107], 0);
    for (; s10 > 0 && 0 == this.children[s10 - 1].length; ) this.children[--s10].destroy();
    return this.children.length = s10, this.markDirty(), this.length = e10, i10;
  }
  transferDOM(t107) {
    this.dom && (this.markDirty(), t107.setDOM(this.dom), t107.prevAttrs = void 0 === this.prevAttrs ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(t107) {
    fT(this.attrs, t107) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = t107);
  }
  append(t107, e10) {
    !function t108(e11, i10, s10) {
      let n10, { children: o10 } = e11;
      s10 > 0 && i10 instanceof fS && o10.length && (n10 = o10[o10.length - 1]) instanceof fS && n10.mark.eq(i10.mark) ? t108(n10, i10.children[0], s10 - 1) : (o10.push(i10), i10.setParent(e11)), e11.length += i10.length;
    }(this, t107, e10);
  }
  addLineDeco(t107) {
    let e10 = t107.spec.attributes, i10 = t107.spec.class;
    e10 && (this.attrs = fD(e10, this.attrs || {})), i10 && (this.attrs = fD({ class: i10 }, this.attrs || {}));
  }
  domAtPos(t107) {
    return fC(this, t107);
  }
  reuseDOM(t107) {
    "DIV" == t107.nodeName && (this.setDOM(t107), this.flags |= 6);
  }
  sync(t107, e10) {
    var i10;
    this.dom ? 4 & this.flags && (u6(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), void 0 !== this.prevAttrs && (fE(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(t107, e10);
    let s10 = this.dom.lastChild;
    for (; s10 && fn.get(s10) instanceof fS; ) s10 = s10.lastChild;
    if (!s10 || !this.length || "BR" != s10.nodeName && (null === (i10 = fn.get(s10)) || void 0 === i10 ? void 0 : i10.isEditable) == false && (!fy.ios || !this.children.some((t108) => t108 instanceof fx))) {
      let t108 = document.createElement("BR");
      t108.cmIgnore = true, this.dom.appendChild(t108);
    }
  }
  measureTextSize() {
    if (0 == this.children.length || this.length > 20) return null;
    let t107 = 0, e10;
    for (let i10 of this.children) {
      if (!(i10 instanceof fx) || /[^ -~]/.test(i10.text)) return null;
      let s10 = u$(i10.dom);
      if (1 != s10.length) return null;
      t107 += s10[0].width, e10 = s10[0].height;
    }
    return t107 ? { lineHeight: this.dom.getBoundingClientRect().height, charWidth: t107 / this.length, textHeight: e10 } : null;
  }
  coordsAt(t107, e10) {
    let i10 = fA(this, t107, e10);
    if (!this.children.length && i10 && this.parent) {
      let { heightOracle: t108 } = this.parent.view.viewState, e11 = i10.bottom - i10.top;
      if (2 > Math.abs(e11 - t108.lineHeight) && t108.textHeight < e11) {
        let s10 = (e11 - t108.textHeight) / 2;
        return { top: i10.top + s10, bottom: i10.bottom - s10, left: i10.left, right: i10.left };
      }
    }
    return i10;
  }
  become(t107) {
    return false;
  }
  covers() {
    return true;
  }
  static find(e10, i10) {
    for (let s10 = 0, n10 = 0; s10 < e10.children.length; s10++) {
      let o10 = e10.children[s10], r10 = n10 + o10.length;
      if (r10 >= i10) {
        if (o10 instanceof t89) return o10;
        if (r10 > i10) break;
      }
      n10 = r10 + o10.breakAfter;
    }
    return null;
  }
}, fB = class t90 extends fn {
  constructor(t107, e10, i10) {
    super(), this.widget = t107, this.length = e10, this.deco = i10, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e10, i10, s10, n10, o10, r10) {
    return (!s10 || s10 instanceof t90 && !!this.widget.compare(s10.widget) && (!(e10 > 0) || !(o10 <= 0)) && (!(i10 < this.length) || !(r10 <= 0))) && (this.length = e10 + (s10 ? s10.length : 0) + (this.length - i10), true);
  }
  domAtPos(t107) {
    return 0 == t107 ? fi.before(this.dom) : fi.after(this.dom, t107 == this.length);
  }
  split(e10) {
    let i10 = this.length - e10;
    this.length = e10;
    let s10 = new t90(this.widget, i10, this.deco);
    return s10.breakAfter = this.breakAfter, s10;
  }
  get children() {
    return fs;
  }
  sync(t107) {
    this.dom && this.widget.updateDOM(this.dom, t107) || (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t107)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : r.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e10) {
    return e10 instanceof t90 && e10.widget.constructor == this.widget.constructor && (e10.widget.compare(this.widget) || this.markDirty(true), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e10.widget, this.length = e10.length, this.deco = e10.deco, this.breakAfter = e10.breakAfter, true);
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(t107) {
    return this.widget.ignoreEvent(t107);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  coordsAt(t107, e10) {
    return this.widget.coordsAt(this.dom, t107, e10);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(t107) {
    let { startSide: e10, endSide: i10 } = this.deco;
    return e10 != i10 && (t107 < 0 ? e10 < 0 : i10 > 0);
  }
}, fL = class {
  eq(t107) {
    return false;
  }
  updateDOM(t107, e10) {
    return false;
  }
  compare(t107) {
    return this == t107 || this.constructor == t107.constructor && this.eq(t107);
  }
  get estimatedHeight() {
    return -1;
  }
  get lineBreaks() {
    return 0;
  }
  ignoreEvent(t107) {
    return true;
  }
  coordsAt(t107, e10, i10) {
    return null;
  }
  get isHidden() {
    return false;
  }
  get editable() {
    return false;
  }
  destroy(t107) {
  }
};
var fP = ((H = fP || (fP = {}))[H.Text = 0] = "Text", H[H.WidgetBefore = 1] = "WidgetBefore", H[H.WidgetAfter = 2] = "WidgetAfter", H[H.WidgetRange = 3] = "WidgetRange", H);
let fN = class extends tz {
  constructor(t107, e10, i10, s10) {
    super(), this.startSide = t107, this.endSide = e10, this.widget = i10, this.spec = s10;
  }
  get heightRelevant() {
    return false;
  }
  static mark(t107) {
    return new fV(t107);
  }
  static widget(t107) {
    let e10 = Math.max(-1e4, Math.min(1e4, t107.side || 0)), i10 = !!t107.block;
    return e10 += i10 && !t107.inlineOrder ? e10 > 0 ? 3e8 : -4e8 : e10 > 0 ? 1e8 : -1e8, new fF(t107, e10, e10, i10, t107.widget || null, false);
  }
  static replace(t107) {
    let e10 = !!t107.block, i10, s10;
    if (t107.isBlockGap) i10 = -5e8, s10 = 4e8;
    else {
      let { start: n10, end: o10 } = fW(t107, e10);
      i10 = (n10 ? e10 ? -3e8 : -1 : 5e8) - 1, s10 = (o10 ? e10 ? 2e8 : 1 : -6e8) + 1;
    }
    return new fF(t107, i10, s10, e10, t107.widget || null, true);
  }
  static line(t107) {
    return new fH(t107);
  }
  static set(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return tG.of(t107, e10);
  }
  hasHeight() {
    return !!this.widget && this.widget.estimatedHeight > -1;
  }
};
fN.none = tG.empty;
let fV = class t91 extends fN {
  constructor(t107) {
    let { start: e10, end: i10 } = fW(t107);
    super(e10 ? -1 : 5e8, i10 ? 1 : -6e8, null, t107), this.tagName = t107.tagName || "span", this.class = t107.class || "", this.attrs = t107.attributes || null;
  }
  eq(e10) {
    var i10, s10;
    return this == e10 || e10 instanceof t91 && this.tagName == e10.tagName && (this.class || (null === (i10 = this.attrs) || void 0 === i10 ? void 0 : i10.class)) == (e10.class || (null === (s10 = e10.attrs) || void 0 === s10 ? void 0 : s10.class)) && fT(this.attrs, e10.attrs, "class");
  }
  range(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t107;
    if (t107 >= e10) throw RangeError("Mark decorations may not be empty");
    return super.range(t107, e10);
  }
};
fV.prototype.point = false;
let fH = class t92 extends fN {
  constructor(t107) {
    super(-2e8, -2e8, null, t107);
  }
  eq(e10) {
    return e10 instanceof t92 && this.spec.class == e10.spec.class && fT(this.spec.attributes, e10.spec.attributes);
  }
  range(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t107;
    if (e10 != t107) throw RangeError("Line decoration ranges must be zero-length");
    return super.range(t107, e10);
  }
};
fH.prototype.mapMode = j.TrackBefore, fH.prototype.point = true;
let fF = class t93 extends fN {
  constructor(t107, e10, i10, s10, n10, o10) {
    super(e10, i10, n10, t107), this.block = s10, this.isReplace = o10, this.mapMode = s10 ? e10 <= 0 ? j.TrackBefore : j.TrackAfter : j.TrackDel;
  }
  get type() {
    return this.startSide != this.endSide ? fP.WidgetRange : this.startSide <= 0 ? fP.WidgetBefore : fP.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e10) {
    var i10, s10;
    return e10 instanceof t93 && ((i10 = this.widget) == (s10 = e10.widget) || !!(i10 && s10 && i10.compare(s10))) && this.block == e10.block && this.startSide == e10.startSide && this.endSide == e10.endSide;
  }
  range(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t107;
    if (this.isReplace && (t107 > e10 || t107 == e10 && this.startSide > 0 && this.endSide <= 0)) throw RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && e10 != t107) throw RangeError("Widget decorations can only have zero-length ranges");
    return super.range(t107, e10);
  }
};
function fW(t107) {
  let e10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], { inclusiveStart: i10, inclusiveEnd: s10 } = t107;
  return null == i10 && (i10 = t107.inclusive), null == s10 && (s10 = t107.inclusive), { start: null != i10 ? i10 : e10, end: null != s10 ? s10 : e10 };
}
function fI(t107, e10, i10) {
  let s10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, n10 = i10.length - 1;
  n10 >= 0 && i10[n10] + s10 >= t107 ? i10[n10] = Math.max(i10[n10], e10) : i10.push(t107, e10);
}
fF.prototype.point = true;
let fz = class t94 {
  constructor(t107, e10, i10, s10) {
    this.doc = t107, this.pos = e10, this.end = i10, this.disallowBlockEffectsFor = s10, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = true, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = t107.iter(), this.skip = e10;
  }
  posCovered() {
    if (0 == this.content.length) return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let t107 = this.content[this.content.length - 1];
    return !(t107.breakAfter || t107 instanceof fB && t107.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new fR()), this.atCursorPos = true), this.curLine;
  }
  flushBuffer() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.bufferMarks;
    this.pendingBuffer && (this.curLine.append(fK(new fM(-1), t107), t107.length), this.pendingBuffer = 0);
  }
  addBlockWidget(t107) {
    this.flushBuffer(), this.curLine = null, this.content.push(t107);
  }
  finish(t107) {
    this.pendingBuffer && t107 <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, this.posCovered() || t107 && this.content.length && this.content[this.content.length - 1] instanceof fB || this.getLine();
  }
  buildText(t107, e10, i10) {
    for (; t107 > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: e11, lineBreak: i11, done: s11 } = this.cursor.next(this.skip);
        if (this.skip = 0, s11) throw Error("Ran out of text content when drawing inline views");
        if (i11) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = true, t107--;
          continue;
        }
        this.text = e11, this.textOff = 0;
      }
      let s10 = Math.min(this.text.length - this.textOff, t107, 512);
      this.flushBuffer(e10.slice(e10.length - i10)), this.getLine().append(fK(new fx(this.text.slice(this.textOff, this.textOff + s10)), e10), i10), this.atCursorPos = true, this.textOff += s10, t107 -= s10, i10 = 0;
    }
  }
  span(t107, e10, i10, s10) {
    this.buildText(e10 - t107, i10, s10), this.pos = e10, this.openStart < 0 && (this.openStart = s10);
  }
  point(t107, e10, i10, s10, n10, o10) {
    if (this.disallowBlockEffectsFor[o10] && i10 instanceof fF) {
      if (i10.block) throw RangeError("Block decorations may not be specified via plugins");
      if (e10 > this.doc.lineAt(this.pos).to) throw RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let r10 = e10 - t107;
    if (i10 instanceof fF) {
      if (i10.block) i10.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new fB(i10.widget || fq.block, r10, i10));
      else {
        let o11 = fk.create(i10.widget || fq.inline, r10, r10 ? 0 : i10.startSide), l10 = this.atCursorPos && !o11.isEditable && n10 <= s10.length && (t107 < e10 || i10.startSide > 0), h10 = !o11.isEditable && (t107 < e10 || n10 > s10.length || i10.startSide <= 0), a10 = this.getLine();
        2 != this.pendingBuffer || l10 || o11.isEditable || (this.pendingBuffer = 0), this.flushBuffer(s10), l10 && (a10.append(fK(new fM(1), s10), n10), n10 = s10.length + Math.max(0, n10 - s10.length)), a10.append(fK(o11, s10), n10), this.atCursorPos = h10, this.pendingBuffer = h10 ? t107 < e10 || n10 > s10.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = s10.slice());
      }
    } else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i10);
    r10 && (this.textOff + r10 <= this.text.length ? this.textOff += r10 : (this.skip += r10 - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = e10), this.openStart < 0 && (this.openStart = n10);
  }
  static build(e10, i10, s10, n10, o10) {
    let r10 = new t94(e10, i10, s10, o10);
    return r10.openEnd = tG.spans(n10, i10, s10, r10), r10.openStart < 0 && (r10.openStart = r10.openEnd), r10.finish(r10.openEnd), r10;
  }
};
function fK(t107, e10) {
  for (let i10 of e10) t107 = new fS(i10, [t107], t107.length);
  return t107;
}
let fq = class extends fL {
  constructor(t107) {
    super(), this.tag = t107;
  }
  eq(t107) {
    return t107.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(t107) {
    return t107.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return true;
  }
};
fq.inline = new fq("span"), fq.block = new fq("div");
var f_ = ((F = f_ || (f_ = {}))[F.LTR = 0] = "LTR", F[F.RTL = 1] = "RTL", F);
let fG = f_.LTR, fj = f_.RTL;
function fU(t107) {
  let e10 = [];
  for (let i10 = 0; i10 < t107.length; i10++) e10.push(1 << +t107[i10]);
  return e10;
}
let fY = fU("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), f$ = fU("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), fX = /* @__PURE__ */ Object.create(null), fJ = [];
for (let t107 of ["()", "[]", "{}"]) {
  let e10 = t107.charCodeAt(0), i10 = t107.charCodeAt(1);
  fX[e10] = i10, fX[i10] = -e10;
}
function fQ(t107) {
  return t107 <= 247 ? fY[t107] : 1424 <= t107 && t107 <= 1524 ? 2 : 1536 <= t107 && t107 <= 1785 ? f$[t107 - 1536] : 1774 <= t107 && t107 <= 2220 ? 4 : 8192 <= t107 && t107 <= 8204 ? 256 : 64336 <= t107 && t107 <= 65023 ? 4 : 1;
}
let fZ = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/, f0 = class {
  get dir() {
    return this.level % 2 ? fj : fG;
  }
  constructor(t107, e10, i10) {
    this.from = t107, this.to = e10, this.level = i10;
  }
  side(t107, e10) {
    return this.dir == e10 == t107 ? this.to : this.from;
  }
  forward(t107, e10) {
    return t107 == (this.dir == e10);
  }
  static find(t107, e10, i10, s10) {
    let n10 = -1;
    for (let o10 = 0; o10 < t107.length; o10++) {
      let r10 = t107[o10];
      if (r10.from <= e10 && r10.to >= e10) {
        if (r10.level == i10) return o10;
        (n10 < 0 || (0 != s10 ? s10 < 0 ? r10.from < e10 : r10.to > e10 : t107[n10].level > r10.level)) && (n10 = o10);
      }
    }
    if (n10 < 0) throw RangeError("Index out of range");
    return n10;
  }
}, f1 = [];
function f2(t107) {
  return [new f0(0, t107, 0)];
}
let f8 = "", f3 = to.define(), f4 = to.define(), f9 = to.define(), f5 = to.define(), f6 = to.define(), f7 = to.define(), gt = to.define(), ge = to.define({ combine: (t107) => t107.some((t108) => t108) }), gi = to.define({ combine: (t107) => t107.some((t108) => t108) }), gs = to.define(), gn = class t95 {
  constructor(t107, e10 = "nearest", i10 = "nearest", s10 = 5, n10 = 5, o10 = false) {
    this.range = t107, this.y = e10, this.x = i10, this.yMargin = s10, this.xMargin = n10, this.isSnapshot = o10;
  }
  map(e10) {
    return e10.empty ? this : new t95(this.range.map(e10), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e10) {
    return this.range.to <= e10.doc.length ? this : new t95(ti.cursor(e10.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}, go = tR.define({ map: (t107, e10) => t107.map(e10) });
function gr(t107, e10, i10) {
  let s10 = t107.facet(f5);
  s10.length ? s10[0](e10) : window.onerror ? window.onerror(String(e10), i10, void 0, void 0, e10) : i10 ? console.error(i10 + ":", e10) : console.error(e10);
}
let gl = to.define({ combine: (t107) => !t107.length || t107[0] }), gh = 0, ga = to.define(), gc = class t96 {
  constructor(t107, e10, i10, s10, n10) {
    this.id = t107, this.create = e10, this.domEventHandlers = i10, this.domEventObservers = s10, this.extension = n10(this);
  }
  static define(e10, i10) {
    let { eventHandlers: s10, eventObservers: n10, provide: o10, decorations: r10 } = i10 || {};
    return new t96(gh++, e10, s10, n10, (t107) => {
      let e11 = [ga.of(t107)];
      return r10 && e11.push(gg.of((e12) => {
        let i11 = e12.plugin(t107);
        return i11 ? r10(i11) : fN.none;
      })), o10 && e11.push(o10(t107)), e11;
    });
  }
  static fromClass(e10, i10) {
    return t96.define((t107) => new e10(t107), i10);
  }
}, gd = class {
  constructor(t107) {
    this.spec = t107, this.mustUpdate = null, this.value = null;
  }
  update(t107) {
    if (this.value) {
      if (this.mustUpdate) {
        let t108 = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update) try {
          this.value.update(t108);
        } catch (e10) {
          if (gr(t108.state, e10, "CodeMirror plugin crashed"), this.value.destroy) try {
            this.value.destroy();
          } catch (t109) {
          }
          this.deactivate();
        }
      }
    } else if (this.spec) try {
      this.value = this.spec.create(t107);
    } catch (e10) {
      gr(t107.state, e10, "CodeMirror plugin crashed"), this.deactivate();
    }
    return this;
  }
  destroy(t107) {
    var e10;
    if (null === (e10 = this.value) || void 0 === e10 ? void 0 : e10.destroy) try {
      this.value.destroy();
    } catch (e11) {
      gr(t107.state, e11, "CodeMirror plugin crashed");
    }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}, gu = to.define(), gf = to.define(), gg = to.define(), gp = to.define(), gm = to.define(), gv = to.define();
function gw(t107, e10) {
  let i10 = t107.state.facet(gv);
  if (!i10.length) return i10;
  let s10 = i10.map((e11) => e11 instanceof Function ? e11(t107) : e11), n10 = [];
  return tG.spans(s10, e10.from, e10.to, { point() {
  }, span(t108, i11, s11, o10) {
    let r10 = t108 - e10.from, l10 = i11 - e10.from, h10 = n10;
    for (let t109 = s11.length - 1; t109 >= 0; t109--, o10--) {
      let i12 = s11[t109].spec.bidiIsolate, n11;
      if (null == i12 && (i12 = function(t110, e11, i13) {
        for (let s12 = e11; s12 < i13; s12++) {
          let e12 = fQ(t110.charCodeAt(s12));
          if (1 == e12) break;
          if (2 == e12 || 4 == e12) return fj;
        }
        return fG;
      }(e10.text, r10, l10)), o10 > 0 && h10.length && (n11 = h10[h10.length - 1]).to == r10 && n11.direction == i12) n11.to = l10, h10 = n11.inner;
      else {
        let t110 = { from: r10, to: l10, direction: i12, inner: [] };
        h10.push(t110), h10 = t110.inner;
      }
    }
  } }), n10;
}
let gb = to.define();
function gy(t107) {
  let e10 = 0, i10 = 0, s10 = 0, n10 = 0;
  for (let o10 of t107.state.facet(gb)) {
    let r10 = o10(t107);
    r10 && (null != r10.left && (e10 = Math.max(e10, r10.left)), null != r10.right && (i10 = Math.max(i10, r10.right)), null != r10.top && (s10 = Math.max(s10, r10.top)), null != r10.bottom && (n10 = Math.max(n10, r10.bottom)));
  }
  return { left: e10, right: i10, top: s10, bottom: n10 };
}
let gx = to.define(), gS = class t97 {
  constructor(t107, e10, i10, s10) {
    this.fromA = t107, this.toA = e10, this.fromB = i10, this.toB = s10;
  }
  join(e10) {
    return new t97(Math.min(this.fromA, e10.fromA), Math.max(this.toA, e10.toA), Math.min(this.fromB, e10.fromB), Math.max(this.toB, e10.toB));
  }
  addToSet(t107) {
    let e10 = t107.length, i10 = this;
    for (; e10 > 0; e10--) {
      let s10 = t107[e10 - 1];
      if (!(s10.fromA > i10.toA)) {
        if (s10.toA < i10.fromA) break;
        i10 = i10.join(s10), t107.splice(e10 - 1, 1);
      }
    }
    return t107.splice(e10, 0, i10), t107;
  }
  static extendWithRanges(e10, i10) {
    if (0 == i10.length) return e10;
    let s10 = [];
    for (let n10 = 0, o10 = 0, r10 = 0, l10 = 0; ; n10++) {
      let h10 = n10 == e10.length ? null : e10[n10], a10 = r10 - l10, c10 = h10 ? h10.fromB : 1e9;
      for (; o10 < i10.length && i10[o10] < c10; ) {
        let e11 = i10[o10], n11 = i10[o10 + 1], r11 = Math.max(l10, e11), h11 = Math.min(c10, n11);
        if (r11 <= h11 && new t97(r11 + a10, h11 + a10, r11, h11).addToSet(s10), n11 > c10) break;
        o10 += 2;
      }
      if (!h10) return s10;
      new t97(h10.fromA, h10.toA, h10.fromB, h10.toB).addToSet(s10), r10 = h10.toA, l10 = h10.toB;
    }
  }
}, gk = class t98 {
  constructor(t107, e10, i10) {
    for (let s11 of (this.view = t107, this.state = e10, this.transactions = i10, this.flags = 0, this.startState = t107.state, this.changes = Y.empty(this.startState.doc.length), i10)) this.changes = this.changes.compose(s11.changes);
    let s10 = [];
    this.changes.iterChangedRanges((t108, e11, i11, n10) => s10.push(new gS(t108, e11, i11, n10))), this.changedRanges = s10;
  }
  static create(e10, i10, s10) {
    return new t98(e10, i10, s10);
  }
  get viewportChanged() {
    return (4 & this.flags) > 0;
  }
  get heightChanged() {
    return (2 & this.flags) > 0;
  }
  get geometryChanged() {
    return this.docChanged || (10 & this.flags) > 0;
  }
  get focusChanged() {
    return (1 & this.flags) > 0;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get selectionSet() {
    return this.transactions.some((t107) => t107.selection);
  }
  get empty() {
    return 0 == this.flags && 0 == this.transactions.length;
  }
}, gM = class extends fn {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(t107) {
    super(), this.view = t107, this.decorations = [], this.dynamicDecorationMap = [], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.lastCompositionAfterCursor = false, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = false, this.lastUpdate = Date.now(), this.setDOM(t107.contentDOM), this.children = [new fR()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new gS(0, 0, 0, t107.state.doc.length)], 0, null);
  }
  update(t107) {
    var e10, i10, s10, n10, o10, r10;
    let l10, h10;
    let a10 = t107.changedRanges;
    this.minWidth > 0 && a10.length && (a10.every((t108) => {
      let { fromA: e11, toA: i11 } = t108;
      return i11 < this.minWidthFrom || e11 > this.minWidthTo;
    }) ? (this.minWidthFrom = t107.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = t107.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0);
    let c10 = -1;
    !(this.view.inputState.composing >= 0) || ((null === (e10 = this.domChanged) || void 0 === e10 ? void 0 : e10.newSel) ? c10 = this.domChanged.newSel.head : (i10 = t107.changes, s10 = this.hasComposition, l10 = false, s10 && i10.iterChangedRanges((t108, e11) => {
      t108 < s10.to && e11 > s10.from && (l10 = true);
    }), l10 || t107.selectionSet || (c10 = t107.state.selection.main.head)));
    let d10 = c10 > -1 ? function(t108, e11, i11) {
      let s11 = gA(t108, i11);
      if (!s11) return null;
      let { node: n11, from: o11, to: r11 } = s11, l11 = n11.nodeValue;
      if (/[\n\r]/.test(l11) || t108.state.doc.sliceString(s11.from, s11.to) != l11) return null;
      let h11 = e11.invertedDesc, a11 = new gS(h11.mapPos(o11), h11.mapPos(r11), o11, r11), c11 = [];
      for (let e12 = n11.parentNode; ; e12 = e12.parentNode) {
        let i12 = fn.get(e12);
        if (i12 instanceof fS) c11.push({ node: e12, deco: i12.mark });
        else {
          if (i12 instanceof fR || "DIV" == e12.nodeName && e12.parentNode == t108.contentDOM) return { range: a11, text: n11, marks: c11, line: e12 };
          if (e12 == t108.contentDOM) return null;
          c11.push({ node: e12, deco: new fV({ inclusive: true, attributes: function(t109) {
            let e13 = /* @__PURE__ */ Object.create(null);
            for (let i13 = 0; i13 < t109.attributes.length; i13++) {
              let s12 = t109.attributes[i13];
              e13[s12.name] = s12.value;
            }
            return e13;
          }(e12), tagName: e12.tagName.toLowerCase() }) });
        }
      }
    }(this.view, t107.changes, c10) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: e11, to: i11 } = this.hasComposition;
      a10 = new gS(e11, i11, t107.changes.mapPos(e11, -1), t107.changes.mapPos(i11, 1)).addToSet(a10.slice());
    }
    this.hasComposition = d10 ? { from: d10.range.fromB, to: d10.range.toB } : null, (fy.ie || fy.chrome) && !d10 && t107 && t107.state.doc.lines != t107.startState.doc.lines && (this.forceSelection = true);
    let u10 = (n10 = this.decorations, o10 = this.updateDeco(), r10 = t107.changes, h10 = new gD(), tG.compare(n10, o10, r10, h10), h10.changes);
    return a10 = gS.extendWithRanges(a10, u10), (!!(7 & this.flags) || 0 != a10.length) && (this.updateInner(a10, t107.startState.doc.length, d10), t107.transactions.length && (this.lastUpdate = Date.now()), true);
  }
  updateInner(t107, e10, i10) {
    this.view.viewState.mustMeasureContent = true, this.updateChildren(t107, e10, i10);
    let { observer: s10 } = this.view;
    s10.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let t108 = fy.chrome || fy.ios ? { node: s10.selectionRange.focusNode, written: false } : void 0;
      this.sync(this.view, t108), this.flags &= -8, t108 && (t108.written || s10.selectionRange.focusNode != t108.node) && (this.forceSelection = true), this.dom.style.height = "";
    }), this.markedForComposition.forEach((t108) => t108.flags &= -9);
    let n10 = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) for (let t108 of this.children) t108 instanceof fB && t108.widget instanceof gC && n10.push(t108.dom);
    s10.updateGaps(n10);
  }
  updateChildren(t107, e10, i10) {
    let s10 = i10 ? i10.range.addToSet(t107.slice()) : t107, n10 = this.childCursor(e10);
    for (let t108 = s10.length - 1; ; t108--) {
      let e11 = t108 >= 0 ? s10[t108] : null;
      if (!e11) break;
      let { fromA: o10, toA: r10, fromB: l10, toB: h10 } = e11, a10, c10, d10, u10;
      if (i10 && i10.range.fromB < h10 && i10.range.toB > l10) {
        let t109 = fz.build(this.view.state.doc, l10, i10.range.fromB, this.decorations, this.dynamicDecorationMap), e12 = fz.build(this.view.state.doc, i10.range.toB, h10, this.decorations, this.dynamicDecorationMap);
        c10 = t109.breakAtStart, d10 = t109.openStart, u10 = e12.openEnd;
        let s11 = this.compositionView(i10);
        e12.breakAtStart ? s11.breakAfter = 1 : e12.content.length && s11.merge(s11.length, s11.length, e12.content[0], false, e12.openStart, 0) && (s11.breakAfter = e12.content[0].breakAfter, e12.content.shift()), t109.content.length && s11.merge(0, 0, t109.content[t109.content.length - 1], true, 0, t109.openEnd) && t109.content.pop(), a10 = t109.content.concat(s11).concat(e12.content);
      } else ({ content: a10, breakAtStart: c10, openStart: d10, openEnd: u10 } = fz.build(this.view.state.doc, l10, h10, this.decorations, this.dynamicDecorationMap));
      let { i: f10, off: g10 } = n10.findPos(r10, 1), { i: p10, off: m10 } = n10.findPos(o10, -1);
      fl(this, p10, m10, f10, g10, a10, c10, d10, u10);
    }
    i10 && this.fixCompositionDOM(i10);
  }
  compositionView(t107) {
    let e10 = new fx(t107.text.nodeValue);
    for (let { deco: i11 } of (e10.flags |= 8, t107.marks)) e10 = new fS(i11, [e10], e10.length);
    let i10 = new fR();
    return i10.append(e10, 0), i10;
  }
  fixCompositionDOM(t107) {
    let e10 = (t108, e11) => {
      e11.flags |= 8 | (e11.children.some((t109) => 7 & t109.flags) ? 1 : 0), this.markedForComposition.add(e11);
      let i11 = fn.get(t108);
      i11 && i11 != e11 && (i11.dom = null), e11.setDOM(t108);
    }, i10 = this.childPos(t107.range.fromB, 1), s10 = this.children[i10.i];
    e10(t107.line, s10);
    for (let n10 = t107.marks.length - 1; n10 >= -1; n10--) i10 = s10.childPos(i10.off, 1), s10 = s10.children[i10.i], e10(n10 >= 0 ? t107.marks[n10].node : t107.text, s10);
  }
  updateSelection() {
    var t107;
    let e10 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], i10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    (e10 || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let s10 = this.view.root.activeElement, n10 = s10 == this.dom, o10 = !n10 && uY(this.dom, this.view.observer.selectionRange) && !(s10 && this.dom.contains(s10));
    if (!(n10 || i10 || o10)) return;
    let r10 = this.forceSelection;
    this.forceSelection = false;
    let l10 = this.view.state.selection.main, h10 = this.moveToLine(this.domAtPos(l10.anchor)), a10 = l10.empty ? h10 : this.moveToLine(this.domAtPos(l10.head));
    if (fy.gecko && l10.empty && !this.hasComposition && 1 == (t107 = h10).node.nodeType && t107.node.firstChild && (0 == t107.offset || "false" == t107.node.childNodes[t107.offset - 1].contentEditable) && (t107.offset == t107.node.childNodes.length || "false" == t107.node.childNodes[t107.offset].contentEditable)) {
      let t108 = document.createTextNode("");
      this.view.observer.ignore(() => h10.node.insertBefore(t108, h10.node.childNodes[h10.offset] || null)), h10 = a10 = new fi(t108, 0), r10 = true;
    }
    let c10 = this.view.observer.selectionRange;
    !r10 && c10.focusNode && (uX(h10.node, h10.offset, c10.anchorNode, c10.anchorOffset) && uX(a10.node, a10.offset, c10.focusNode, c10.focusOffset) || this.suppressWidgetCursorChange(c10, l10)) || (this.view.observer.ignore(() => {
      fy.android && fy.chrome && this.dom.contains(c10.focusNode) && function(t109, e12) {
        for (let i12 = t109; i12 && i12 != e12; i12 = i12.assignedSlot || i12.parentNode) if (1 == i12.nodeType && "false" == i12.contentEditable) return true;
        return false;
      }(c10.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: true }));
      let t108 = uj(this.view.root);
      if (t108) {
        if (l10.empty) {
          if (fy.gecko) {
            var e11, i11;
            let t109 = (e11 = h10.node, i11 = h10.offset, 1 != e11.nodeType ? 0 : (i11 && "false" == e11.childNodes[i11 - 1].contentEditable ? 1 : 0) | (i11 < e11.childNodes.length && "false" == e11.childNodes[i11].contentEditable ? 2 : 0));
            if (t109 && 3 != t109) {
              let e12 = (1 == t109 ? ft : fe)(h10.node, h10.offset);
              e12 && (h10 = new fi(e12.node, e12.offset));
            }
          }
          t108.collapse(h10.node, h10.offset), null != l10.bidiLevel && void 0 !== t108.caretBidiLevel && (t108.caretBidiLevel = l10.bidiLevel);
        } else if (t108.extend) {
          t108.collapse(h10.node, h10.offset);
          try {
            t108.extend(a10.node, a10.offset);
          } catch (t109) {
          }
        } else {
          let e12 = document.createRange();
          l10.anchor > l10.head && ([h10, a10] = [a10, h10]), e12.setEnd(a10.node, a10.offset), e12.setStart(h10.node, h10.offset), t108.removeAllRanges(), t108.addRange(e12);
        }
      }
      o10 && this.view.root.activeElement == this.dom && (this.dom.blur(), s10 && s10.focus());
    }), this.view.observer.setSelectionRange(h10, a10)), this.impreciseAnchor = h10.precise ? null : new fi(c10.anchorNode, c10.anchorOffset), this.impreciseHead = a10.precise ? null : new fi(c10.focusNode, c10.focusOffset);
  }
  suppressWidgetCursorChange(t107, e10) {
    return this.hasComposition && e10.empty && uX(t107.focusNode, t107.focusOffset, t107.anchorNode, t107.anchorOffset) && this.posFromDOM(t107.focusNode, t107.focusOffset) == e10.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition) return;
    let { view: t107 } = this, e10 = t107.state.selection.main, i10 = uj(t107.root), { anchorNode: s10, anchorOffset: n10 } = t107.observer.selectionRange;
    if (!i10 || !e10.empty || !e10.assoc || !i10.modify) return;
    let o10 = fR.find(this, e10.head);
    if (!o10) return;
    let r10 = o10.posAtStart;
    if (e10.head == r10 || e10.head == r10 + o10.length) return;
    let l10 = this.coordsAt(e10.head, -1), h10 = this.coordsAt(e10.head, 1);
    if (!l10 || !h10 || l10.bottom > h10.top) return;
    let a10 = this.domAtPos(e10.head + e10.assoc);
    i10.collapse(a10.node, a10.offset), i10.modify("move", e10.assoc < 0 ? "forward" : "backward", "lineboundary"), t107.observer.readSelectionRange();
    let c10 = t107.observer.selectionRange;
    t107.docView.posFromDOM(c10.anchorNode, c10.anchorOffset) != e10.from && i10.collapse(s10, n10);
  }
  moveToLine(t107) {
    let e10 = this.dom, i10;
    if (t107.node != e10) return t107;
    for (let s10 = t107.offset; !i10 && s10 < e10.childNodes.length; s10++) {
      let t108 = fn.get(e10.childNodes[s10]);
      t108 instanceof fR && (i10 = t108.domAtPos(0));
    }
    for (let s10 = t107.offset - 1; !i10 && s10 >= 0; s10--) {
      let t108 = fn.get(e10.childNodes[s10]);
      t108 instanceof fR && (i10 = t108.domAtPos(t108.length));
    }
    return i10 ? new fi(i10.node, i10.offset, true) : t107;
  }
  nearest(t107) {
    for (let e10 = t107; e10; ) {
      let t108 = fn.get(e10);
      if (t108 && t108.rootView == this) return t108;
      e10 = e10.parentNode;
    }
    return null;
  }
  posFromDOM(t107, e10) {
    let i10 = this.nearest(t107);
    if (!i10) throw RangeError("Trying to find position for a DOM position outside of the document");
    return i10.localPosFromDOM(t107, e10) + i10.posAtStart;
  }
  domAtPos(t107) {
    let { i: e10, off: i10 } = this.childCursor().findPos(t107, -1);
    for (; e10 < this.children.length - 1; ) {
      let t108 = this.children[e10];
      if (i10 < t108.length || t108 instanceof fR) break;
      e10++, i10 = 0;
    }
    return this.children[e10].domAtPos(i10);
  }
  coordsAt(t107, e10) {
    let i10 = null, s10 = 0;
    for (let n10 = this.length, o10 = this.children.length - 1; o10 >= 0; o10--) {
      let r10 = this.children[o10], l10 = n10 - r10.breakAfter, h10 = l10 - r10.length;
      if (l10 < t107) break;
      if (h10 <= t107 && (h10 < t107 || r10.covers(-1)) && (l10 > t107 || r10.covers(1)) && (!i10 || r10 instanceof fR && !(i10 instanceof fR && e10 >= 0))) i10 = r10, s10 = h10;
      else if (i10 && h10 == t107 && l10 == t107 && r10 instanceof fB && 2 > Math.abs(e10)) {
        if (r10.deco.startSide < 0) break;
        o10 && (i10 = null);
      }
      n10 = h10;
    }
    return i10 ? i10.coordsAt(t107 - s10, e10) : null;
  }
  coordsForChar(t107) {
    let { i: e10, off: i10 } = this.childPos(t107, 1), s10 = this.children[e10];
    if (!(s10 instanceof fR)) return null;
    for (; s10.children.length; ) {
      let { i: t108, off: e11 } = s10.childPos(i10, 1);
      for (; ; t108++) {
        if (t108 == s10.children.length) return null;
        if ((s10 = s10.children[t108]).length) break;
      }
      i10 = e11;
    }
    if (!(s10 instanceof fx)) return null;
    let n10 = v(s10.text, i10);
    if (n10 == i10) return null;
    let o10 = u9(s10.dom, i10, n10).getClientRects();
    for (let t108 = 0; t108 < o10.length; t108++) {
      let e11 = o10[t108];
      if (t108 == o10.length - 1 || e11.top < e11.bottom && e11.left < e11.right) return e11;
    }
    return null;
  }
  measureVisibleLineHeights(t107) {
    let e10 = [], { from: i10, to: s10 } = t107, n10 = this.view.contentDOM.clientWidth, o10 = n10 > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, r10 = -1, l10 = this.view.textDirection == f_.LTR;
    for (let t108 = 0, h10 = 0; h10 < this.children.length; h10++) {
      let a10 = this.children[h10], c10 = t108 + a10.length;
      if (c10 > s10) break;
      if (t108 >= i10) {
        let i11 = a10.dom.getBoundingClientRect();
        if (e10.push(i11.height), o10) {
          let e11 = a10.dom.lastChild, s11 = e11 ? u$(e11) : [];
          if (s11.length) {
            let e12 = s11[s11.length - 1], o11 = l10 ? e12.right - i11.left : i11.right - e12.left;
            o11 > r10 && (r10 = o11, this.minWidth = n10, this.minWidthFrom = t108, this.minWidthTo = c10);
          }
        }
      }
      t108 = c10 + a10.breakAfter;
    }
    return e10;
  }
  textDirectionAt(t107) {
    let { i: e10 } = this.childPos(t107, 1);
    return "rtl" == getComputedStyle(this.children[e10].dom).direction ? f_.RTL : f_.LTR;
  }
  measureTextSize() {
    for (let t108 of this.children) if (t108 instanceof fR) {
      let e11 = t108.measureTextSize();
      if (e11) return e11;
    }
    let t107 = document.createElement("div"), e10, i10, s10;
    return t107.className = "cm-line", t107.style.width = "99999px", t107.style.position = "absolute", t107.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(t107);
      let n10 = u$(t107.firstChild)[0];
      e10 = t107.getBoundingClientRect().height, i10 = n10 ? n10.width / 27 : 7, s10 = n10 ? n10.height : e10, t107.remove();
    }), { lineHeight: e10, charWidth: i10, textHeight: s10 };
  }
  childCursor() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.length, e10 = this.children.length;
    return e10 && (t107 -= this.children[--e10].length), new fr(this.children, t107, e10);
  }
  computeBlockGapDeco() {
    let t107 = [], e10 = this.view.viewState;
    for (let i10 = 0, s10 = 0; ; s10++) {
      let n10 = s10 == e10.viewports.length ? null : e10.viewports[s10], o10 = n10 ? n10.from - 1 : this.length;
      if (o10 > i10) {
        let s11 = (e10.lineBlockAt(o10).bottom - e10.lineBlockAt(i10).top) / this.view.scaleY;
        t107.push(fN.replace({ widget: new gC(s11), block: true, inclusive: true, isBlockGap: true }).range(i10, o10));
      }
      if (!n10) break;
      i10 = n10.to + 1;
    }
    return fN.set(t107);
  }
  updateDeco() {
    let t107 = 0, e10 = this.view.state.facet(gg).map((e11) => (this.dynamicDecorationMap[t107++] = "function" == typeof e11) ? e11(this.view) : e11), i10 = false, s10 = this.view.state.facet(gp).map((t108, e11) => {
      let s11 = "function" == typeof t108;
      return s11 && (i10 = true), s11 ? t108(this.view) : t108;
    });
    for (s10.length && (this.dynamicDecorationMap[t107++] = i10, e10.push(tG.join(s10))), this.decorations = [...e10, this.computeBlockGapDeco(), this.view.viewState.lineGapDeco]; t107 < this.decorations.length; ) this.dynamicDecorationMap[t107++] = false;
    return this.decorations;
  }
  scrollIntoView(t107) {
    if (t107.isSnapshot) {
      let e11 = this.view.viewState.lineBlockAt(t107.range.head);
      this.view.scrollDOM.scrollTop = e11.top - t107.yMargin, this.view.scrollDOM.scrollLeft = t107.xMargin;
      return;
    }
    for (let e11 of this.view.state.facet(gs)) try {
      if (e11(this.view, t107.range, t107)) return true;
    } catch (t108) {
      gr(this.view.state, t108, "scroll handler");
    }
    let { range: e10 } = t107, i10 = this.coordsAt(e10.head, e10.empty ? e10.assoc : e10.head > e10.anchor ? -1 : 1), s10;
    if (!i10) return;
    !e10.empty && (s10 = this.coordsAt(e10.anchor, e10.anchor > e10.head ? -1 : 1)) && (i10 = { left: Math.min(i10.left, s10.left), top: Math.min(i10.top, s10.top), right: Math.max(i10.right, s10.right), bottom: Math.max(i10.bottom, s10.bottom) });
    let n10 = gy(this.view), o10 = { left: i10.left - n10.left, top: i10.top - n10.top, right: i10.right + n10.right, bottom: i10.bottom + n10.bottom }, { offsetWidth: r10, offsetHeight: l10 } = this.view.scrollDOM;
    !function(t108, e11, i11, s11, n11, o11, r11, l11) {
      let h10 = t108.ownerDocument, a10 = h10.defaultView || window;
      for (let c10 = t108, d10 = false; c10 && !d10; ) if (1 == c10.nodeType) {
        let t109, u10 = c10 == h10.body, f10 = 1, g10 = 1;
        if (u10) t109 = function(t110) {
          let e12 = t110.visualViewport;
          return e12 ? { left: 0, right: e12.width, top: 0, bottom: e12.height } : { left: 0, right: t110.innerWidth, top: 0, bottom: t110.innerHeight };
        }(a10);
        else {
          if (/^(fixed|sticky)$/.test(getComputedStyle(c10).position) && (d10 = true), c10.scrollHeight <= c10.clientHeight && c10.scrollWidth <= c10.clientWidth) {
            c10 = c10.assignedSlot || c10.parentNode;
            continue;
          }
          let e12 = c10.getBoundingClientRect();
          ({ scaleX: f10, scaleY: g10 } = u2(c10, e12)), t109 = { left: e12.left, right: e12.left + c10.clientWidth * f10, top: e12.top, bottom: e12.top + c10.clientHeight * g10 };
        }
        let p10 = 0, m10 = 0;
        if ("nearest" == n11) e11.top < t109.top ? (m10 = -(t109.top - e11.top + r11), i11 > 0 && e11.bottom > t109.bottom + m10 && (m10 = e11.bottom - t109.bottom + m10 + r11)) : e11.bottom > t109.bottom && (m10 = e11.bottom - t109.bottom + r11, i11 < 0 && e11.top - m10 < t109.top && (m10 = -(t109.top + m10 - e11.top + r11)));
        else {
          let s12 = e11.bottom - e11.top, o12 = t109.bottom - t109.top;
          m10 = ("center" == n11 && s12 <= o12 ? e11.top + s12 / 2 - o12 / 2 : "start" == n11 || "center" == n11 && i11 < 0 ? e11.top - r11 : e11.bottom - o12 + r11) - t109.top;
        }
        if ("nearest" == s11 ? e11.left < t109.left ? (p10 = -(t109.left - e11.left + o11), i11 > 0 && e11.right > t109.right + p10 && (p10 = e11.right - t109.right + p10 + o11)) : e11.right > t109.right && (p10 = e11.right - t109.right + o11, i11 < 0 && e11.left < t109.left + p10 && (p10 = -(t109.left + p10 - e11.left + o11))) : p10 = ("center" == s11 ? e11.left + (e11.right - e11.left) / 2 - (t109.right - t109.left) / 2 : "start" == s11 == l11 ? e11.left - o11 : e11.right - (t109.right - t109.left) + o11) - t109.left, p10 || m10) {
          if (u10) a10.scrollBy(p10, m10);
          else {
            let t110 = 0, i12 = 0;
            if (m10) {
              let t111 = c10.scrollTop;
              c10.scrollTop += m10 / g10, i12 = (c10.scrollTop - t111) * g10;
            }
            if (p10) {
              let e12 = c10.scrollLeft;
              c10.scrollLeft += p10 / f10, t110 = (c10.scrollLeft - e12) * f10;
            }
            e11 = { left: e11.left - t110, top: e11.top - i12, right: e11.right - t110, bottom: e11.bottom - i12 }, t110 && 1 > Math.abs(t110 - p10) && (s11 = "nearest"), i12 && 1 > Math.abs(i12 - m10) && (n11 = "nearest");
          }
        }
        if (u10) break;
        c10 = c10.assignedSlot || c10.parentNode;
      } else if (11 == c10.nodeType) c10 = c10.host;
      else break;
    }(this.view.scrollDOM, o10, e10.head < e10.anchor ? -1 : 1, t107.x, t107.y, Math.max(Math.min(t107.xMargin, r10), -r10), Math.max(Math.min(t107.yMargin, l10), -l10), this.view.textDirection == f_.LTR);
  }
}, gC = class extends fL {
  constructor(t107) {
    super(), this.height = t107;
  }
  toDOM() {
    let t107 = document.createElement("div");
    return t107.className = "cm-gap", this.updateDOM(t107), t107;
  }
  eq(t107) {
    return t107.height == this.height;
  }
  updateDOM(t107) {
    return t107.style.height = this.height + "px", true;
  }
  get editable() {
    return true;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return false;
  }
};
function gA(t107, e10) {
  let i10 = t107.observer.selectionRange;
  if (!i10.focusNode) return null;
  let s10 = ft(i10.focusNode, i10.focusOffset), n10 = fe(i10.focusNode, i10.focusOffset), o10 = s10 || n10;
  if (n10 && s10 && n10.node != s10.node) {
    let e11 = fn.get(n10.node);
    if (!e11 || e11 instanceof fx && e11.text != n10.node.nodeValue) o10 = n10;
    else if (t107.docView.lastCompositionAfterCursor) {
      let t108 = fn.get(s10.node);
      !t108 || t108 instanceof fx && t108.text != s10.node.nodeValue || (o10 = n10);
    }
  }
  if (t107.docView.lastCompositionAfterCursor = o10 != s10, !o10) return null;
  let r10 = e10 - o10.offset;
  return { from: r10, to: r10 + o10.node.nodeValue.length, node: o10.node };
}
let gD = class {
  constructor() {
    this.changes = [];
  }
  compareRange(t107, e10) {
    fI(t107, e10, this.changes);
  }
  comparePoint(t107, e10) {
    fI(t107, e10, this.changes);
  }
};
function gO(t107, e10) {
  return t107.top < e10.bottom - 1 && t107.bottom > e10.top + 1;
}
function gT(t107, e10) {
  return e10 < t107.top ? { top: e10, left: t107.left, right: t107.right, bottom: t107.bottom } : t107;
}
function gE(t107, e10) {
  return e10 > t107.bottom ? { top: t107.top, left: t107.left, right: t107.right, bottom: e10 } : t107;
}
function gR(t107, e10, i10) {
  let s10 = t107.nodeValue.length, n10 = -1, o10 = 1e9, r10 = 0;
  for (let l10 = 0; l10 < s10; l10++) {
    let s11 = u9(t107, l10, l10 + 1).getClientRects();
    for (let h10 = 0; h10 < s11.length; h10++) {
      let a10 = s11[h10];
      if (a10.top == a10.bottom) continue;
      r10 || (r10 = e10 - a10.left);
      let c10 = (a10.top > i10 ? a10.top - i10 : i10 - a10.bottom) - 1;
      if (a10.left - 1 <= e10 && a10.right + 1 >= e10 && c10 < o10) {
        let i11 = e10 >= (a10.left + a10.right) / 2, s12 = i11;
        if ((fy.chrome || fy.gecko) && u9(t107, l10).getBoundingClientRect().left == a10.right && (s12 = !i11), c10 <= 0) return { node: t107, offset: l10 + (s12 ? 1 : 0) };
        n10 = l10 + (s12 ? 1 : 0), o10 = c10;
      }
    }
  }
  return { node: t107, offset: n10 > -1 ? n10 : r10 > 0 ? t107.nodeValue.length : 0 };
}
function gB(t107, e10, i10) {
  var s10, n10;
  let o10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : -1, r10 = t107.contentDOM.getBoundingClientRect(), l10 = r10.top + t107.viewState.paddingTop, h10, { docHeight: a10 } = t107.viewState, { x: c10, y: d10 } = e10, u10 = d10 - l10;
  if (u10 < 0) return 0;
  if (u10 > a10) return t107.state.doc.length;
  for (let e11 = t107.viewState.heightOracle.textHeight / 2, s11 = false; (h10 = t107.elementAtHeight(u10)).type != fP.Text; ) for (; !((u10 = o10 > 0 ? h10.bottom + e11 : h10.top - e11) >= 0) || !(u10 <= a10); ) {
    if (s11) return i10 ? null : 0;
    s11 = true, o10 = -o10;
  }
  d10 = l10 + u10;
  let f10 = h10.from;
  if (f10 < t107.viewport.from) return 0 == t107.viewport.from ? 0 : i10 ? null : gL(t107, r10, h10, c10, d10);
  if (f10 > t107.viewport.to) return t107.viewport.to == t107.state.doc.length ? t107.state.doc.length : i10 ? null : gL(t107, r10, h10, c10, d10);
  let g10 = t107.dom.ownerDocument, p10 = t107.root.elementFromPoint ? t107.root : g10, m10 = p10.elementFromPoint(c10, d10);
  m10 && !t107.contentDOM.contains(m10) && (m10 = null), !m10 && (c10 = Math.max(r10.left + 1, Math.min(r10.right - 1, c10)), (m10 = p10.elementFromPoint(c10, d10)) && !t107.contentDOM.contains(m10) && (m10 = null));
  let v10, w10 = -1;
  if (m10 && (null === (s10 = t107.docView.nearest(m10)) || void 0 === s10 ? void 0 : s10.isEditable) != false) {
    if (g10.caretPositionFromPoint) {
      let t108 = g10.caretPositionFromPoint(c10, d10);
      t108 && ({ offsetNode: v10, offset: w10 } = t108);
    } else if (g10.caretRangeFromPoint) {
      let e11 = g10.caretRangeFromPoint(c10, d10);
      e11 && ({ startContainer: v10, startOffset: w10 } = e11, (!t107.contentDOM.contains(v10) || fy.safari && function(t108, e12, i11) {
        let s11;
        if (3 != t108.nodeType || e12 != (s11 = t108.nodeValue.length)) return false;
        for (let e13 = t108.nextSibling; e13; e13 = e13.nextSibling) if (1 != e13.nodeType || "BR" != e13.nodeName) return false;
        return u9(t108, s11 - 1, s11).getBoundingClientRect().left > i11;
      }(v10, w10, c10) || fy.chrome && function(t108, e12, i11) {
        if (0 != e12) return false;
        for (let e13 = t108; ; ) {
          let t109 = e13.parentNode;
          if (!t109 || 1 != t109.nodeType || t109.firstChild != e13) return false;
          if (t109.classList.contains("cm-line")) break;
          e13 = t109;
        }
        return i11 - (1 == t108.nodeType ? t108.getBoundingClientRect() : u9(t108, 0, Math.max(t108.nodeValue.length, 1)).getBoundingClientRect()).left > 5;
      }(v10, w10, c10)) && (v10 = void 0));
    }
  }
  if (!v10 || !t107.docView.dom.contains(v10)) {
    let e11 = fR.find(t107.docView, f10);
    if (!e11) return u10 > h10.top + h10.height / 2 ? h10.to : h10.from;
    ({ node: v10, offset: w10 } = function t108(e12, i11, s11) {
      let n11, o11, r11, l11, h11, a11, c11, d11, u11 = false;
      for (let p12 = e12.firstChild; p12; p12 = p12.nextSibling) {
        let e13 = u$(p12);
        for (let m12 = 0; m12 < e13.length; m12++) {
          var f11, g11;
          let v11 = e13[m12];
          a11 && gO(a11, v11) && (v11 = gT(gE(v11, a11.bottom), a11.top));
          let w11 = (f11 = v11).left > i11 ? f11.left - i11 : Math.max(0, i11 - f11.right), b11 = (g11 = v11).top > s11 ? g11.top - s11 : Math.max(0, s11 - g11.bottom);
          if (0 == w11 && 0 == b11) return 3 == p12.nodeType ? gR(p12, i11, s11) : t108(p12, i11, s11);
          if (!h11 || d11 > b11 || d11 == b11 && c11 > w11) {
            h11 = p12, a11 = v11, c11 = w11, d11 = b11;
            let t109 = b11 ? s11 < v11.top ? -1 : 1 : w11 ? i11 < v11.left ? -1 : 1 : 0;
            u11 = !t109 || (t109 > 0 ? m12 < e13.length - 1 : m12 > 0);
          }
          0 == w11 ? s11 > v11.bottom && (!r11 || r11.bottom < v11.bottom) ? (n11 = p12, r11 = v11) : s11 < v11.top && (!l11 || l11.top > v11.top) && (o11 = p12, l11 = v11) : r11 && gO(r11, v11) ? r11 = gE(r11, v11.bottom) : l11 && gO(l11, v11) && (l11 = gT(l11, v11.top));
        }
      }
      if (r11 && r11.bottom >= s11 ? (h11 = n11, a11 = r11) : l11 && l11.top <= s11 && (h11 = o11, a11 = l11), !h11) return { node: e12, offset: 0 };
      let p11 = Math.max(a11.left, Math.min(a11.right, i11));
      if (3 == h11.nodeType) return gR(h11, p11, s11);
      if (u11 && "false" != h11.contentEditable) return t108(h11, p11, s11);
      let m11 = Array.prototype.indexOf.call(e12.childNodes, h11) + (i11 >= (a11.left + a11.right) / 2 ? 1 : 0);
      return { node: e12, offset: m11 };
    }(e11.dom, c10, d10));
  }
  let b10 = t107.docView.nearest(v10);
  if (!b10) return null;
  if (!b10.isWidget || (null === (n10 = b10.dom) || void 0 === n10 ? void 0 : n10.nodeType) != 1) return b10.localPosFromDOM(v10, w10) + b10.posAtStart;
  {
    let t108 = b10.dom.getBoundingClientRect();
    return e10.y < t108.top || e10.y <= t108.bottom && e10.x <= (t108.left + t108.right) / 2 ? b10.posAtStart : b10.posAtEnd;
  }
}
function gL(t107, e10, i10, s10, n10) {
  let o10 = Math.round((s10 - e10.left) * t107.defaultCharacterWidth);
  if (t107.lineWrapping && i10.height > 1.5 * t107.defaultLineHeight) {
    let e11 = t107.viewState.heightOracle.textHeight;
    o10 += Math.floor((n10 - i10.top - (t107.defaultLineHeight - e11) * 0.5) / e11) * t107.viewState.heightOracle.lineLength;
  }
  let r10 = t107.state.sliceDoc(i10.from, i10.to);
  return i10.from + t3(r10, o10, t107.state.tabSize);
}
function gP(t107, e10, i10, s10) {
  let n10 = t107.state.doc.lineAt(e10.head), o10 = t107.bidiSpans(n10), r10 = t107.textDirectionAt(n10.from);
  for (let l10 = e10, h10 = null; ; ) {
    let e11 = function(t108, e12, i11, s11, n11) {
      var o11;
      let r11 = s11.head - t108.from, l11 = f0.find(e12, r11, null !== (o11 = s11.bidiLevel) && void 0 !== o11 ? o11 : -1, s11.assoc), h11 = e12[l11], a11 = h11.side(n11, i11);
      if (r11 == a11) {
        let t109 = l11 += n11 ? 1 : -1;
        if (t109 < 0 || t109 >= e12.length) return null;
        r11 = (h11 = e12[l11 = t109]).side(!n11, i11), a11 = h11.side(n11, i11);
      }
      let c10 = v(t108.text, r11, h11.forward(n11, i11));
      (c10 < h11.from || c10 > h11.to) && (c10 = a11), f8 = t108.text.slice(Math.min(r11, c10), Math.max(r11, c10));
      let d10 = l11 == (n11 ? e12.length - 1 : 0) ? null : e12[l11 + (n11 ? 1 : -1)];
      return d10 && c10 == a11 && d10.level + (n11 ? 0 : 1) < h11.level ? ti.cursor(d10.side(!n11, i11) + t108.from, d10.forward(n11, i11) ? 1 : -1, d10.level) : ti.cursor(c10 + t108.from, h11.forward(n11, i11) ? -1 : 1, h11.level);
    }(n10, o10, r10, l10, i10), a10 = f8;
    if (!e11) {
      if (n10.number == (i10 ? t107.state.doc.lines : 1)) return l10;
      a10 = "\n", n10 = t107.state.doc.line(n10.number + (i10 ? 1 : -1)), o10 = t107.bidiSpans(n10), e11 = t107.visualLineSide(n10, !i10);
    }
    if (h10) {
      if (!h10(a10)) return l10;
    } else {
      if (!s10) return e11;
      h10 = s10(a10);
    }
    l10 = e11;
  }
}
function gN(t107, e10, i10) {
  for (; ; ) {
    let s10 = 0;
    for (let n10 of t107) n10.between(e10 - 1, e10 + 1, (t108, n11, o10) => {
      if (e10 > t108 && e10 < n11) {
        let o11 = s10 || i10 || (e10 - t108 < n11 - e10 ? -1 : 1);
        e10 = o11 < 0 ? t108 : n11, s10 = o11;
      }
    });
    if (!s10) return e10;
  }
}
function gV(t107, e10, i10) {
  let s10 = gN(t107.state.facet(gm).map((e11) => e11(t107)), i10.from, e10.head > i10.from ? -1 : 1);
  return s10 == i10.from ? i10 : ti.cursor(s10, s10 < i10.from ? 1 : -1);
}
let gH = class {
  setSelectionOrigin(t107) {
    this.lastSelectionOrigin = t107, this.lastSelectionTime = Date.now();
  }
  constructor(t107) {
    var e10;
    this.view = t107, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = false, this.compositionPendingChange = false, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = t107.hasFocus, fy.safari && t107.contentDOM.addEventListener("input", () => null), fy.gecko && (e10 = t107.contentDOM.ownerDocument, g6.has(e10) || (g6.add(e10), e10.addEventListener("copy", () => {
    }), e10.addEventListener("cut", () => {
    })));
  }
  handleEvent(t107) {
    !(!function(t108, e10) {
      if (!e10.bubbles) return true;
      if (e10.defaultPrevented) return false;
      for (let i10 = e10.target, s10; i10 != t108.contentDOM; i10 = i10.parentNode) if (!i10 || 11 == i10.nodeType || (s10 = fn.get(i10)) && s10.ignoreEvent(e10)) return false;
      return true;
    }(this.view, t107) || this.ignoreDuringComposition(t107)) && ("keydown" == t107.type && this.keydown(t107) || this.runHandlers(t107.type, t107));
  }
  runHandlers(t107, e10) {
    let i10 = this.handlers[t107];
    if (i10) {
      for (let t108 of i10.observers) t108(this.view, e10);
      for (let t108 of i10.handlers) {
        if (e10.defaultPrevented) break;
        if (t108(this.view, e10)) {
          e10.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(t107) {
    let e10 = function(t108) {
      let e11 = /* @__PURE__ */ Object.create(null);
      function i11(t109) {
        return e11[t109] || (e11[t109] = { observers: [], handlers: [] });
      }
      for (let e12 of t108) {
        let t109 = e12.spec;
        if (t109 && t109.domEventHandlers) for (let s11 in t109.domEventHandlers) {
          let n10 = t109.domEventHandlers[s11];
          n10 && i11(s11).handlers.push(gF(e12.value, n10));
        }
        if (t109 && t109.domEventObservers) for (let s11 in t109.domEventObservers) {
          let n10 = t109.domEventObservers[s11];
          n10 && i11(s11).observers.push(gF(e12.value, n10));
        }
      }
      for (let t109 in g_) i11(t109).handlers.push(g_[t109]);
      for (let t109 in gG) i11(t109).observers.push(gG[t109]);
      return e11;
    }(t107), i10 = this.handlers, s10 = this.view.contentDOM;
    for (let t108 in e10) if ("scroll" != t108) {
      let n10 = !e10[t108].handlers.length, o10 = i10[t108];
      o10 && !o10.handlers.length != n10 && (s10.removeEventListener(t108, this.handleEvent), o10 = null), o10 || s10.addEventListener(t108, this.handleEvent, { passive: n10 });
    }
    for (let t108 in i10) "scroll" == t108 || e10[t108] || s10.removeEventListener(t108, this.handleEvent);
    this.handlers = e10;
  }
  keydown(t107) {
    let e10;
    return this.lastKeyCode = t107.keyCode, this.lastKeyTime = Date.now(), !!(9 == t107.keyCode && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode)) || ((this.tabFocusMode > 0 && 27 != t107.keyCode && 0 > gz.indexOf(t107.keyCode) && (this.tabFocusMode = -1), fy.android && fy.chrome && !t107.synthetic && (13 == t107.keyCode || 8 == t107.keyCode)) ? (this.view.observer.delayAndroidKey(t107.key, t107.keyCode), true) : fy.ios && !t107.synthetic && !t107.altKey && !t107.metaKey && ((e10 = gW.find((e11) => e11.keyCode == t107.keyCode)) && !t107.ctrlKey || gI.indexOf(t107.key) > -1 && t107.ctrlKey && !t107.shiftKey) ? (this.pendingIOSKey = e10 || t107, setTimeout(() => this.flushIOSKey(), 250), true) : (229 != t107.keyCode && this.view.observer.forceFlush(), false));
  }
  flushIOSKey(t107) {
    let e10 = this.pendingIOSKey;
    return !(!e10 || "Enter" == e10.key && t107 && t107.from < t107.to && /^\S+$/.test(t107.insert.toString())) && (this.pendingIOSKey = void 0, u5(this.view.contentDOM, e10.key, e10.keyCode, e10 instanceof KeyboardEvent ? e10 : void 0));
  }
  ignoreDuringComposition(t107) {
    return !!/^key/.test(t107.type) && (this.composing > 0 || !!(fy.safari && !fy.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) && (this.compositionPendingKey = false, true));
  }
  startMouseSelection(t107) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = t107;
  }
  update(t107) {
    this.mouseSelection && this.mouseSelection.update(t107), this.draggedContent && t107.docChanged && (this.draggedContent = this.draggedContent.map(t107.changes)), t107.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
};
function gF(t107, e10) {
  return (i10, s10) => {
    try {
      return e10.call(t107, s10, i10);
    } catch (t108) {
      gr(i10.state, t108);
    }
  };
}
let gW = [{ key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" }, { key: "Enter", keyCode: 13, inputType: "insertParagraph" }, { key: "Enter", keyCode: 13, inputType: "insertLineBreak" }, { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }], gI = "dthko", gz = [16, 17, 18, 20, 91, 92, 224, 225];
function gK(t107) {
  return 0.7 * Math.max(0, t107) + 8;
}
let gq = class {
  constructor(t107, e10, i10, s10) {
    let n10;
    this.view = t107, this.startEvent = e10, this.style = i10, this.mustSelect = s10, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = e10, this.scrollParent = function(t108) {
      let e11 = t108.ownerDocument;
      for (let i11 = t108.parentNode; i11 && i11 != e11.body; ) if (1 == i11.nodeType) {
        if (i11.scrollHeight > i11.clientHeight || i11.scrollWidth > i11.clientWidth) return i11;
        i11 = i11.assignedSlot || i11.parentNode;
      } else if (11 == i11.nodeType) i11 = i11.host;
      else break;
      return null;
    }(t107.contentDOM), this.atoms = t107.state.facet(gm).map((e11) => e11(t107));
    let o10 = t107.contentDOM.ownerDocument;
    o10.addEventListener("mousemove", this.move = this.move.bind(this)), o10.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = e10.shiftKey, this.multiple = t107.state.facet(tW.allowMultipleSelections) && ((n10 = t107.state.facet(f3)).length ? n10[0](e10) : fy.mac ? e10.metaKey : e10.ctrlKey), this.dragging = !!function(t108, e11) {
      let { main: i11 } = t108.state.selection;
      if (i11.empty) return false;
      let s11 = uj(t108.root);
      if (!s11 || 0 == s11.rangeCount) return true;
      let n11 = s11.getRangeAt(0).getClientRects();
      for (let t109 = 0; t109 < n11.length; t109++) {
        let i12 = n11[t109];
        if (i12.left <= e11.clientX && i12.right >= e11.clientX && i12.top <= e11.clientY && i12.bottom >= e11.clientY) return true;
      }
      return false;
    }(t107, e10) && 1 == g2(e10) && null;
  }
  start(t107) {
    false === this.dragging && this.select(t107);
  }
  move(t107) {
    var e10, i10;
    if (0 == t107.buttons) return this.destroy();
    if (this.dragging || null == this.dragging && 10 > Math.max(Math.abs((i10 = this.startEvent).clientX - t107.clientX), Math.abs(i10.clientY - t107.clientY))) return;
    this.select(this.lastEvent = t107);
    let s10 = 0, n10 = 0, o10 = (null === (e10 = this.scrollParent) || void 0 === e10 ? void 0 : e10.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight }, r10 = gy(this.view);
    t107.clientX - r10.left <= o10.left + 6 ? s10 = -gK(o10.left - t107.clientX) : t107.clientX + r10.right >= o10.right - 6 && (s10 = gK(t107.clientX - o10.right)), t107.clientY - r10.top <= o10.top + 6 ? n10 = -gK(o10.top - t107.clientY) : t107.clientY + r10.bottom >= o10.bottom - 6 && (n10 = gK(t107.clientY - o10.bottom)), this.setScrollSpeed(s10, n10);
  }
  up(t107) {
    null == this.dragging && this.select(this.lastEvent), this.dragging || t107.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let t107 = this.view.contentDOM.ownerDocument;
    t107.removeEventListener("mousemove", this.move), t107.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(t107, e10) {
    this.scrollSpeed = { x: t107, y: e10 }, t107 || e10 ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x, this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y), false === this.dragging && this.select(this.lastEvent);
  }
  skipAtoms(t107) {
    let e10 = null;
    for (let i10 = 0; i10 < t107.ranges.length; i10++) {
      let s10 = t107.ranges[i10], n10 = null;
      if (s10.empty) {
        let t108 = gN(this.atoms, s10.from, 0);
        t108 != s10.from && (n10 = ti.cursor(t108, -1));
      } else {
        let t108 = gN(this.atoms, s10.from, -1), e11 = gN(this.atoms, s10.to, 1);
        (t108 != s10.from || e11 != s10.to) && (n10 = ti.range(s10.from == s10.anchor ? t108 : e11, s10.from == s10.head ? t108 : e11));
      }
      n10 && (e10 || (e10 = t107.ranges.slice()), e10[i10] = n10);
    }
    return e10 ? ti.create(e10, t107.mainIndex) : t107;
  }
  select(t107) {
    let { view: e10 } = this, i10 = this.skipAtoms(this.style.get(t107, this.extend, this.multiple));
    (this.mustSelect || !i10.eq(e10.state.selection, false === this.dragging)) && this.view.dispatch({ selection: i10, userEvent: "select.pointer" }), this.mustSelect = false;
  }
  update(t107) {
    t107.transactions.some((t108) => t108.isUserEvent("input.type")) ? this.destroy() : this.style.update(t107) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}, g_ = /* @__PURE__ */ Object.create(null), gG = /* @__PURE__ */ Object.create(null), gj = fy.ie && fy.ie_version < 15 || fy.ios && fy.webkit_version < 604;
function gU(t107, e10) {
  let { state: i10 } = t107, s10, n10 = 1, o10 = i10.toText(e10), r10 = o10.lines == i10.selection.ranges.length;
  if (null != g3 && i10.selection.ranges.every((t108) => t108.empty) && g3 == o10.toString()) {
    let t108 = -1;
    s10 = i10.changeByRange((s11) => {
      let l10 = i10.doc.lineAt(s11.from);
      if (l10.from == t108) return { range: s11 };
      t108 = l10.from;
      let h10 = i10.toText((r10 ? o10.line(n10++).text : e10) + i10.lineBreak);
      return { changes: { from: l10.from, insert: h10 }, range: ti.cursor(s11.from + h10.length) };
    });
  } else s10 = r10 ? i10.changeByRange((t108) => {
    let e11 = o10.line(n10++);
    return { changes: { from: t108.from, to: t108.to, insert: e11.text }, range: ti.cursor(t108.from + e11.length) };
  }) : i10.replaceSelection(o10);
  t107.dispatch(s10, { userEvent: "input.paste", scrollIntoView: true });
}
function gY(t107, e10, i10, s10) {
  if (1 == s10) return ti.cursor(e10, i10);
  if (2 == s10) return function(t108, e11) {
    let i11 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, s11 = t108.charCategorizer(e11), n10 = t108.doc.lineAt(e11), o10 = e11 - n10.from;
    if (0 == n10.length) return ti.cursor(e11);
    0 == o10 ? i11 = 1 : o10 == n10.length && (i11 = -1);
    let r10 = o10, l10 = o10;
    i11 < 0 ? r10 = v(n10.text, o10, false) : l10 = v(n10.text, o10);
    let h10 = s11(n10.text.slice(r10, l10));
    for (; r10 > 0; ) {
      let t109 = v(n10.text, r10, false);
      if (s11(n10.text.slice(t109, r10)) != h10) break;
      r10 = t109;
    }
    for (; l10 < n10.length; ) {
      let t109 = v(n10.text, l10);
      if (s11(n10.text.slice(l10, t109)) != h10) break;
      l10 = t109;
    }
    return ti.range(r10 + n10.from, l10 + n10.from);
  }(t107.state, e10, i10);
  {
    let i11 = fR.find(t107.docView, e10), s11 = t107.state.doc.lineAt(i11 ? i11.posAtEnd : e10), n10 = i11 ? i11.posAtStart : s11.from, o10 = i11 ? i11.posAtEnd : s11.to;
    return o10 < t107.state.doc.length && o10 == s11.to && o10++, ti.range(n10, o10);
  }
}
gG.scroll = (t107) => {
  t107.inputState.lastScrollTop = t107.scrollDOM.scrollTop, t107.inputState.lastScrollLeft = t107.scrollDOM.scrollLeft;
}, g_.keydown = (t107, e10) => (t107.inputState.setSelectionOrigin("select"), 27 == e10.keyCode && 0 != t107.inputState.tabFocusMode && (t107.inputState.tabFocusMode = Date.now() + 2e3), false), gG.touchstart = (t107, e10) => {
  t107.inputState.lastTouchTime = Date.now(), t107.inputState.setSelectionOrigin("select.pointer");
}, gG.touchmove = (t107) => {
  t107.inputState.setSelectionOrigin("select.pointer");
}, g_.mousedown = (t107, e10) => {
  let i10, s10, n10;
  if (t107.observer.flush(), t107.inputState.lastTouchTime > Date.now() - 2e3) return false;
  let o10 = null;
  for (let i11 of t107.state.facet(f9)) if (o10 = i11(t107, e10)) break;
  if (o10 || 0 != e10.button || (i10 = gJ(t107, e10), s10 = g2(e10), n10 = t107.state.selection, o10 = { update(t108) {
    t108.docChanged && (i10.pos = t108.changes.mapPos(i10.pos), n10 = n10.map(t108.changes));
  }, get(e11, o11, r10) {
    let l10 = gJ(t107, e11), h10, a10 = gY(t107, l10.pos, l10.bias, s10);
    if (i10.pos != l10.pos && !o11) {
      let e12 = gY(t107, i10.pos, i10.bias, s10), n11 = Math.min(e12.from, a10.from), o12 = Math.max(e12.to, a10.to);
      a10 = n11 < a10.from ? ti.range(n11, o12) : ti.range(o12, n11);
    }
    return o11 ? n10.replaceRange(n10.main.extend(a10.from, a10.to)) : r10 && 1 == s10 && n10.ranges.length > 1 && (h10 = function(t108, e12) {
      for (let i11 = 0; i11 < t108.ranges.length; i11++) {
        let { from: s11, to: n11 } = t108.ranges[i11];
        if (s11 <= e12 && n11 >= e12) return ti.create(t108.ranges.slice(0, i11).concat(t108.ranges.slice(i11 + 1)), t108.mainIndex == i11 ? 0 : t108.mainIndex - (t108.mainIndex > i11 ? 1 : 0));
      }
      return null;
    }(n10, l10.pos)) ? h10 : r10 ? n10.addRange(a10) : ti.create([a10]);
  } }), o10) {
    let i11 = !t107.hasFocus;
    t107.inputState.startMouseSelection(new gq(t107, e10, o10, i11)), i11 && t107.observer.ignore(() => {
      u4(t107.contentDOM);
      let e11 = t107.root.activeElement;
      e11 && !e11.contains(t107.contentDOM) && e11.blur();
    });
    let s11 = t107.inputState.mouseSelection;
    if (s11) return s11.start(e10), false === s11.dragging;
  }
  return false;
};
let g$ = (t107, e10) => t107 >= e10.top && t107 <= e10.bottom, gX = (t107, e10, i10) => g$(e10, i10) && t107 >= i10.left && t107 <= i10.right;
function gJ(t107, e10) {
  let i10 = t107.posAtCoords({ x: e10.clientX, y: e10.clientY }, false);
  return { pos: i10, bias: function(t108, e11, i11, s10) {
    let n10 = fR.find(t108.docView, e11);
    if (!n10) return 1;
    let o10 = e11 - n10.posAtStart;
    if (0 == o10) return 1;
    if (o10 == n10.length) return -1;
    let r10 = n10.coordsAt(o10, -1);
    if (r10 && gX(i11, s10, r10)) return -1;
    let l10 = n10.coordsAt(o10, 1);
    return l10 && gX(i11, s10, l10) ? 1 : r10 && g$(s10, r10) ? -1 : 1;
  }(t107, i10, e10.clientX, e10.clientY) };
}
let gQ = fy.ie && fy.ie_version <= 11, gZ = null, g0 = 0, g1 = 0;
function g2(t107) {
  if (!gQ) return t107.detail;
  let e10 = gZ, i10 = g1;
  return gZ = t107, g1 = Date.now(), g0 = !e10 || i10 > Date.now() - 400 && 2 > Math.abs(e10.clientX - t107.clientX) && 2 > Math.abs(e10.clientY - t107.clientY) ? (g0 + 1) % 3 : 1;
}
function g8(t107, e10, i10, s10) {
  let n10;
  if (!i10) return;
  let o10 = t107.posAtCoords({ x: e10.clientX, y: e10.clientY }, false), { draggedContent: r10 } = t107.inputState, l10 = s10 && r10 && ((n10 = t107.state.facet(f4)).length ? n10[0](e10) : fy.mac ? !e10.altKey : !e10.ctrlKey) ? { from: r10.from, to: r10.to } : null, h10 = { from: o10, insert: i10 }, a10 = t107.state.changes(l10 ? [l10, h10] : h10);
  t107.focus(), t107.dispatch({ changes: a10, selection: { anchor: a10.mapPos(o10, -1), head: a10.mapPos(o10, 1) }, userEvent: l10 ? "move.drop" : "input.drop" }), t107.inputState.draggedContent = null;
}
g_.dragstart = (t107, e10) => {
  let { selection: { main: i10 } } = t107.state;
  if (e10.target.draggable) {
    let s11 = t107.docView.nearest(e10.target);
    if (s11 && s11.isWidget) {
      let t108 = s11.posAtStart, e11 = t108 + s11.length;
      (t108 >= i10.to || e11 <= i10.from) && (i10 = ti.range(t108, e11));
    }
  }
  let { inputState: s10 } = t107;
  return s10.mouseSelection && (s10.mouseSelection.dragging = true), s10.draggedContent = i10, e10.dataTransfer && (e10.dataTransfer.setData("Text", t107.state.sliceDoc(i10.from, i10.to)), e10.dataTransfer.effectAllowed = "copyMove"), false;
}, g_.dragend = (t107) => (t107.inputState.draggedContent = null, false), g_.drop = (t107, e10) => {
  if (!e10.dataTransfer) return false;
  if (t107.state.readOnly) return true;
  let i10 = e10.dataTransfer.files;
  if (i10 && i10.length) {
    let s10 = Array(i10.length), n10 = 0, o10 = () => {
      ++n10 == i10.length && g8(t107, e10, s10.filter((t108) => null != t108).join(t107.state.lineBreak), false);
    };
    for (let t108 = 0; t108 < i10.length; t108++) {
      let e11 = new FileReader();
      e11.onerror = o10, e11.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(e11.result) || (s10[t108] = e11.result), o10();
      }, e11.readAsText(i10[t108]);
    }
    return true;
  }
  {
    let i11 = e10.dataTransfer.getData("Text");
    if (i11) return g8(t107, e10, i11, true), true;
  }
  return false;
}, g_.paste = (t107, e10) => {
  if (t107.state.readOnly) return true;
  t107.observer.flush();
  let i10 = gj ? null : e10.clipboardData;
  return i10 ? (gU(t107, i10.getData("text/plain") || i10.getData("text/uri-list")), true) : (function(t108) {
    let e11 = t108.dom.parentNode;
    if (!e11) return;
    let i11 = e11.appendChild(document.createElement("textarea"));
    i11.style.cssText = "position: fixed; left: -10000px; top: 10px", i11.focus(), setTimeout(() => {
      t108.focus(), i11.remove(), gU(t108, i11.value);
    }, 50);
  }(t107), false);
};
let g3 = null;
g_.copy = g_.cut = (t107, e10) => {
  let { text: i10, ranges: s10, linewise: n10 } = function(t108) {
    let e11 = [], i11 = [], s11 = false;
    for (let s12 of t108.selection.ranges) s12.empty || (e11.push(t108.sliceDoc(s12.from, s12.to)), i11.push(s12));
    if (!e11.length) {
      let n11 = -1;
      for (let { from: s12 } of t108.selection.ranges) {
        let o11 = t108.doc.lineAt(s12);
        o11.number > n11 && (e11.push(o11.text), i11.push({ from: o11.from, to: Math.min(t108.doc.length, o11.to + 1) })), n11 = o11.number;
      }
      s11 = true;
    }
    return { text: e11.join(t108.lineBreak), ranges: i11, linewise: s11 };
  }(t107.state);
  if (!i10 && !n10) return false;
  g3 = n10 ? i10 : null, "cut" != e10.type || t107.state.readOnly || t107.dispatch({ changes: s10, scrollIntoView: true, userEvent: "delete.cut" });
  let o10 = gj ? null : e10.clipboardData;
  return o10 ? (o10.clearData(), o10.setData("text/plain", i10), true) : (!function(t108, e11) {
    let i11 = t108.dom.parentNode;
    if (!i11) return;
    let s11 = i11.appendChild(document.createElement("textarea"));
    s11.style.cssText = "position: fixed; left: -10000px; top: 10px", s11.value = e11, s11.focus(), s11.selectionEnd = e11.length, s11.selectionStart = 0, setTimeout(() => {
      s11.remove(), t108.focus();
    }, 50);
  }(t107, i10), false);
};
let g4 = tO.define();
function g9(t107, e10) {
  let i10 = [];
  for (let s10 of t107.facet(gt)) {
    let n10 = s10(t107, e10);
    n10 && i10.push(n10);
  }
  return i10 ? t107.update({ effects: i10, annotations: g4.of(true) }) : null;
}
function g5(t107) {
  setTimeout(() => {
    let e10 = t107.hasFocus;
    if (e10 != t107.inputState.notifiedFocused) {
      let i10 = g9(t107.state, e10);
      i10 ? t107.dispatch(i10) : t107.update([]);
    }
  }, 10);
}
gG.focus = (t107) => {
  t107.inputState.lastFocusTime = Date.now(), !t107.scrollDOM.scrollTop && (t107.inputState.lastScrollTop || t107.inputState.lastScrollLeft) && (t107.scrollDOM.scrollTop = t107.inputState.lastScrollTop, t107.scrollDOM.scrollLeft = t107.inputState.lastScrollLeft), g5(t107);
}, gG.blur = (t107) => {
  t107.observer.clearSelectionRange(), g5(t107);
}, gG.compositionstart = gG.compositionupdate = (t107) => {
  null == t107.inputState.compositionFirstChange && (t107.inputState.compositionFirstChange = true), t107.inputState.composing < 0 && (t107.inputState.composing = 0);
}, gG.compositionend = (t107) => {
  t107.inputState.composing = -1, t107.inputState.compositionEndedAt = Date.now(), t107.inputState.compositionPendingKey = true, t107.inputState.compositionPendingChange = t107.observer.pendingRecords().length > 0, t107.inputState.compositionFirstChange = null, fy.chrome && fy.android ? t107.observer.flushSoon() : t107.inputState.compositionPendingChange ? Promise.resolve().then(() => t107.observer.flush()) : setTimeout(() => {
    t107.inputState.composing < 0 && t107.docView.hasComposition && t107.update([]);
  }, 50);
}, gG.contextmenu = (t107) => {
  t107.inputState.lastContextMenu = Date.now();
}, g_.beforeinput = (t107, e10) => {
  var i10;
  let s10;
  if (fy.chrome && fy.android && (s10 = gW.find((t108) => t108.inputType == e10.inputType)) && (t107.observer.delayAndroidKey(s10.key, s10.keyCode), "Backspace" == s10.key || "Delete" == s10.key)) {
    let e11 = (null === (i10 = window.visualViewport) || void 0 === i10 ? void 0 : i10.height) || 0;
    setTimeout(() => {
      var i11;
      ((null === (i11 = window.visualViewport) || void 0 === i11 ? void 0 : i11.height) || 0) > e11 + 10 && t107.hasFocus && (t107.contentDOM.blur(), t107.focus());
    }, 100);
  }
  return fy.ios && "deleteContentForward" == e10.inputType && t107.observer.flushSoon(), fy.safari && "insertText" == e10.inputType && t107.inputState.composing >= 0 && setTimeout(() => gG.compositionend(t107, e10), 20), false;
};
let g6 = /* @__PURE__ */ new Set(), g7 = ["pre-wrap", "normal", "pre-line", "break-spaces"], pt = class {
  constructor(t107) {
    this.lineWrapping = t107, this.doc = r.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30, this.heightChanged = false;
  }
  heightForGap(t107, e10) {
    let i10 = this.doc.lineAt(e10).number - this.doc.lineAt(t107).number + 1;
    return this.lineWrapping && (i10 += Math.max(0, Math.ceil((e10 - t107 - i10 * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * i10;
  }
  heightForLine(t107) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((t107 - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(t107) {
    return this.doc = t107, this;
  }
  mustRefreshForWrapping(t107) {
    return g7.indexOf(t107) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(t107) {
    let e10 = false;
    for (let i10 = 0; i10 < t107.length; i10++) {
      let s10 = t107[i10];
      s10 < 0 ? i10++ : this.heightSamples[Math.floor(10 * s10)] || (e10 = true, this.heightSamples[Math.floor(10 * s10)] = true);
    }
    return e10;
  }
  refresh(t107, e10, i10, s10, n10, o10) {
    let r10 = g7.indexOf(t107) > -1, l10 = Math.round(e10) != Math.round(this.lineHeight) || this.lineWrapping != r10;
    if (this.lineWrapping = r10, this.lineHeight = e10, this.charWidth = i10, this.textHeight = s10, this.lineLength = n10, l10) {
      this.heightSamples = {};
      for (let t108 = 0; t108 < o10.length; t108++) {
        let e11 = o10[t108];
        e11 < 0 ? t108++ : this.heightSamples[Math.floor(10 * e11)] = true;
      }
    }
    return l10;
  }
}, pe = class {
  constructor(t107, e10) {
    this.from = t107, this.heights = e10, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}, pi = class t99 {
  constructor(t107, e10, i10, s10, n10) {
    this.from = t107, this.length = e10, this.top = i10, this.height = s10, this._content = n10;
  }
  get type() {
    return "number" == typeof this._content ? fP.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  get to() {
    return this.from + this.length;
  }
  get bottom() {
    return this.top + this.height;
  }
  get widget() {
    return this._content instanceof fF ? this._content.widget : null;
  }
  get widgetLineBreaks() {
    return "number" == typeof this._content ? this._content : 0;
  }
  join(e10) {
    let i10 = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e10._content) ? e10._content : [e10]);
    return new t99(this.from, this.length + e10.length, this.top, this.height + e10.height, i10);
  }
};
var ps = ((W = ps || (ps = {}))[W.ByPos = 0] = "ByPos", W[W.ByHeight = 1] = "ByHeight", W[W.ByPosNoHeight = 2] = "ByPosNoHeight", W);
let pn = class t100 {
  constructor(t107, e10, i10 = 2) {
    this.length = t107, this.height = e10, this.flags = i10;
  }
  get outdated() {
    return (2 & this.flags) > 0;
  }
  set outdated(t107) {
    this.flags = (t107 ? 2 : 0) | -3 & this.flags;
  }
  setHeight(t107, e10) {
    this.height != e10 && (Math.abs(this.height - e10) > 1e-3 && (t107.heightChanged = true), this.height = e10);
  }
  replace(e10, i10, s10) {
    return t100.of(s10);
  }
  decomposeLeft(t107, e10) {
    e10.push(this);
  }
  decomposeRight(t107, e10) {
    e10.push(this);
  }
  applyChanges(t107, e10, i10, s10) {
    let n10 = this, o10 = i10.doc;
    for (let r10 = s10.length - 1; r10 >= 0; r10--) {
      let { fromA: l10, toA: h10, fromB: a10, toB: c10 } = s10[r10], d10 = n10.lineAt(l10, ps.ByPosNoHeight, i10.setDoc(e10), 0, 0), u10 = d10.to >= h10 ? d10 : n10.lineAt(h10, ps.ByPosNoHeight, i10, 0, 0);
      for (c10 += u10.to - h10, h10 = u10.to; r10 > 0 && d10.from <= s10[r10 - 1].toA; ) l10 = s10[r10 - 1].fromA, a10 = s10[r10 - 1].fromB, r10--, l10 < d10.from && (d10 = n10.lineAt(l10, ps.ByPosNoHeight, i10, 0, 0));
      a10 += d10.from - l10, l10 = d10.from;
      let f10 = pc.build(i10.setDoc(o10), t107, a10, c10);
      n10 = n10.replace(l10, h10, f10);
    }
    return n10.updateHeight(i10, 0);
  }
  static empty() {
    return new pr(0, 0);
  }
  static of(e10) {
    if (1 == e10.length) return e10[0];
    let i10 = 0, s10 = e10.length, n10 = 0, o10 = 0;
    for (; ; ) if (i10 == s10) {
      if (n10 > 2 * o10) {
        let t107 = e10[i10 - 1];
        t107.break ? e10.splice(--i10, 1, t107.left, null, t107.right) : e10.splice(--i10, 1, t107.left, t107.right), s10 += 1 + t107.break, n10 -= t107.size;
      } else if (o10 > 2 * n10) {
        let t107 = e10[s10];
        t107.break ? e10.splice(s10, 1, t107.left, null, t107.right) : e10.splice(s10, 1, t107.left, t107.right), s10 += 2 + t107.break, o10 -= t107.size;
      } else break;
    } else if (n10 < o10) {
      let t107 = e10[i10++];
      t107 && (n10 += t107.size);
    } else {
      let t107 = e10[--s10];
      t107 && (o10 += t107.size);
    }
    let r10 = 0;
    return null == e10[i10 - 1] ? (r10 = 1, i10--) : null == e10[i10] && (r10 = 1, s10++), new ph(t100.of(e10.slice(0, i10)), r10, t100.of(e10.slice(s10)));
  }
};
pn.prototype.size = 1;
let po = class extends pn {
  constructor(t107, e10, i10) {
    super(t107, e10), this.deco = i10;
  }
  blockAt(t107, e10, i10, s10) {
    return new pi(s10, this.length, i10, this.height, this.deco || 0);
  }
  lineAt(t107, e10, i10, s10, n10) {
    return this.blockAt(0, i10, s10, n10);
  }
  forEachLine(t107, e10, i10, s10, n10, o10) {
    t107 <= n10 + this.length && e10 >= n10 && o10(this.blockAt(0, i10, s10, n10));
  }
  updateHeight(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i10 = (arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 ? arguments[3] : void 0);
    return i10 && i10.from <= e10 && i10.more && this.setHeight(t107, i10.heights[i10.index++]), this.outdated = false, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}, pr = class t101 extends po {
  constructor(t107, e10) {
    super(t107, e10, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(t107, e10, i10, s10) {
    return new pi(s10, this.length, i10, this.height, this.breaks);
  }
  replace(e10, i10, s10) {
    let n10 = s10[0];
    return 1 == s10.length && (n10 instanceof t101 || n10 instanceof pl && 4 & n10.flags) && 10 > Math.abs(this.length - n10.length) ? (n10 instanceof pl ? n10 = new t101(n10.length, this.height) : n10.height = this.height, this.outdated || (n10.outdated = false), n10) : pn.of(s10);
  }
  updateHeight(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], s10 = arguments.length > 3 ? arguments[3] : void 0;
    return s10 && s10.from <= e10 && s10.more ? this.setHeight(t107, s10.heights[s10.index++]) : (i10 || this.outdated) && this.setHeight(t107, Math.max(this.widgetHeight, t107.heightForLine(this.length - this.collapsed)) + this.breaks * t107.lineHeight), this.outdated = false, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}, pl = class t102 extends pn {
  constructor(t107) {
    super(t107, 0);
  }
  heightMetrics(t107, e10) {
    let i10 = t107.doc.lineAt(e10).number, s10 = t107.doc.lineAt(e10 + this.length).number, n10 = s10 - i10 + 1, o10, r10 = 0;
    if (t107.lineWrapping) {
      let e11 = Math.min(this.height, t107.lineHeight * n10);
      o10 = e11 / n10, this.length > n10 + 1 && (r10 = (this.height - e11) / (this.length - n10 - 1));
    } else o10 = this.height / n10;
    return { firstLine: i10, lastLine: s10, perLine: o10, perChar: r10 };
  }
  blockAt(t107, e10, i10, s10) {
    let { firstLine: n10, lastLine: o10, perLine: r10, perChar: l10 } = this.heightMetrics(e10, s10);
    if (e10.lineWrapping) {
      let n11 = s10 + (t107 < e10.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (t107 - i10) / this.height)) * this.length)), o11 = e10.doc.lineAt(n11), h10 = r10 + o11.length * l10, a10 = Math.max(i10, t107 - h10 / 2);
      return new pi(o11.from, o11.length, a10, h10, 0);
    }
    {
      let s11 = Math.max(0, Math.min(o10 - n10, Math.floor((t107 - i10) / r10))), { from: l11, length: h10 } = e10.doc.line(n10 + s11);
      return new pi(l11, h10, i10 + r10 * s11, r10, 0);
    }
  }
  lineAt(t107, e10, i10, s10, n10) {
    if (e10 == ps.ByHeight) return this.blockAt(t107, i10, s10, n10);
    if (e10 == ps.ByPosNoHeight) {
      let { from: e11, to: s11 } = i10.doc.lineAt(t107);
      return new pi(e11, s11 - e11, 0, 0, 0);
    }
    let { firstLine: o10, perLine: r10, perChar: l10 } = this.heightMetrics(i10, n10), h10 = i10.doc.lineAt(t107), a10 = r10 + h10.length * l10, c10 = h10.number - o10, d10 = s10 + r10 * c10 + l10 * (h10.from - n10 - c10);
    return new pi(h10.from, h10.length, Math.max(s10, Math.min(d10, s10 + this.height - a10)), a10, 0);
  }
  forEachLine(t107, e10, i10, s10, n10, o10) {
    t107 = Math.max(t107, n10), e10 = Math.min(e10, n10 + this.length);
    let { firstLine: r10, perLine: l10, perChar: h10 } = this.heightMetrics(i10, n10);
    for (let a10 = t107, c10 = s10; a10 <= e10; ) {
      let e11 = i10.doc.lineAt(a10);
      if (a10 == t107) {
        let i11 = e11.number - r10;
        c10 += l10 * i11 + h10 * (t107 - n10 - i11);
      }
      let s11 = l10 + h10 * e11.length;
      o10(new pi(e11.from, e11.length, c10, s11, 0)), c10 += s11, a10 = e11.to + 1;
    }
  }
  replace(e10, i10, s10) {
    let n10 = this.length - i10;
    if (n10 > 0) {
      let e11 = s10[s10.length - 1];
      e11 instanceof t102 ? s10[s10.length - 1] = new t102(e11.length + n10) : s10.push(null, new t102(n10 - 1));
    }
    if (e10 > 0) {
      let i11 = s10[0];
      i11 instanceof t102 ? s10[0] = new t102(e10 + i11.length) : s10.unshift(new t102(e10 - 1), null);
    }
    return pn.of(s10);
  }
  decomposeLeft(e10, i10) {
    i10.push(new t102(e10 - 1), null);
  }
  decomposeRight(e10, i10) {
    i10.push(null, new t102(this.length - e10 - 1));
  }
  updateHeight(e10) {
    let i10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, s10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], n10 = arguments.length > 3 ? arguments[3] : void 0, o10 = i10 + this.length;
    if (n10 && n10.from <= i10 + this.length && n10.more) {
      let s11 = [], r10 = Math.max(i10, n10.from), l10 = -1;
      for (n10.from > i10 && s11.push(new t102(n10.from - i10 - 1).updateHeight(e10, i10)); r10 <= o10 && n10.more; ) {
        let t107 = e10.doc.lineAt(r10).length;
        s11.length && s11.push(null);
        let i11 = n10.heights[n10.index++];
        -1 == l10 ? l10 = i11 : Math.abs(i11 - l10) >= 1e-3 && (l10 = -2);
        let o11 = new pr(t107, i11);
        o11.outdated = false, s11.push(o11), r10 += t107 + 1;
      }
      r10 <= o10 && s11.push(null, new t102(o10 - r10).updateHeight(e10, r10));
      let h10 = pn.of(s11);
      return (l10 < 0 || Math.abs(h10.height - this.height) >= 1e-3 || Math.abs(l10 - this.heightMetrics(e10, i10).perLine) >= 1e-3) && (e10.heightChanged = true), h10;
    }
    return (s10 || this.outdated) && (this.setHeight(e10, e10.heightForGap(i10, i10 + this.length)), this.outdated = false), this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}, ph = class extends pn {
  constructor(t107, e10, i10) {
    super(t107.length + e10 + i10.length, t107.height + i10.height, e10 | (t107.outdated || i10.outdated ? 2 : 0)), this.left = t107, this.right = i10, this.size = t107.size + i10.size;
  }
  get break() {
    return 1 & this.flags;
  }
  blockAt(t107, e10, i10, s10) {
    let n10 = i10 + this.left.height;
    return t107 < n10 ? this.left.blockAt(t107, e10, i10, s10) : this.right.blockAt(t107, e10, n10, s10 + this.left.length + this.break);
  }
  lineAt(t107, e10, i10, s10, n10) {
    let o10 = s10 + this.left.height, r10 = n10 + this.left.length + this.break, l10 = e10 == ps.ByHeight ? t107 < o10 : t107 < r10, h10 = l10 ? this.left.lineAt(t107, e10, i10, s10, n10) : this.right.lineAt(t107, e10, i10, o10, r10);
    if (this.break || (l10 ? h10.to < r10 : h10.from > r10)) return h10;
    let a10 = e10 == ps.ByPosNoHeight ? ps.ByPosNoHeight : ps.ByPos;
    return l10 ? h10.join(this.right.lineAt(r10, a10, i10, o10, r10)) : this.left.lineAt(r10, a10, i10, s10, n10).join(h10);
  }
  forEachLine(t107, e10, i10, s10, n10, o10) {
    let r10 = s10 + this.left.height, l10 = n10 + this.left.length + this.break;
    if (this.break) t107 < l10 && this.left.forEachLine(t107, e10, i10, s10, n10, o10), e10 >= l10 && this.right.forEachLine(t107, e10, i10, r10, l10, o10);
    else {
      let h10 = this.lineAt(l10, ps.ByPos, i10, s10, n10);
      t107 < h10.from && this.left.forEachLine(t107, h10.from - 1, i10, s10, n10, o10), h10.to >= t107 && h10.from <= e10 && o10(h10), e10 > h10.to && this.right.forEachLine(h10.to + 1, e10, i10, r10, l10, o10);
    }
  }
  replace(t107, e10, i10) {
    let s10 = this.left.length + this.break;
    if (e10 < s10) return this.balanced(this.left.replace(t107, e10, i10), this.right);
    if (t107 > this.left.length) return this.balanced(this.left, this.right.replace(t107 - s10, e10 - s10, i10));
    let n10 = [];
    t107 > 0 && this.decomposeLeft(t107, n10);
    let o10 = n10.length;
    for (let t108 of i10) n10.push(t108);
    if (t107 > 0 && pa(n10, o10 - 1), e10 < this.length) {
      let t108 = n10.length;
      this.decomposeRight(e10, n10), pa(n10, t108);
    }
    return pn.of(n10);
  }
  decomposeLeft(t107, e10) {
    let i10 = this.left.length;
    if (t107 <= i10) return this.left.decomposeLeft(t107, e10);
    e10.push(this.left), this.break && t107 >= ++i10 && e10.push(null), t107 > i10 && this.right.decomposeLeft(t107 - i10, e10);
  }
  decomposeRight(t107, e10) {
    let i10 = this.left.length, s10 = i10 + this.break;
    if (t107 >= s10) return this.right.decomposeRight(t107 - s10, e10);
    t107 < i10 && this.left.decomposeRight(t107, e10), this.break && t107 < s10 && e10.push(null), e10.push(this.right);
  }
  balanced(t107, e10) {
    return t107.size > 2 * e10.size || e10.size > 2 * t107.size ? pn.of(this.break ? [t107, null, e10] : [t107, e10]) : (this.left = t107, this.right = e10, this.height = t107.height + e10.height, this.outdated = t107.outdated || e10.outdated, this.size = t107.size + e10.size, this.length = t107.length + this.break + e10.length, this);
  }
  updateHeight(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], s10 = arguments.length > 3 ? arguments[3] : void 0, { left: n10, right: o10 } = this, r10 = e10 + n10.length + this.break, l10 = null;
    return (s10 && s10.from <= e10 + n10.length && s10.more ? l10 = n10 = n10.updateHeight(t107, e10, i10, s10) : n10.updateHeight(t107, e10, i10), s10 && s10.from <= r10 + o10.length && s10.more ? l10 = o10 = o10.updateHeight(t107, r10, i10, s10) : o10.updateHeight(t107, r10, i10), l10) ? this.balanced(n10, o10) : (this.height = this.left.height + this.right.height, this.outdated = false, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
};
function pa(t107, e10) {
  let i10, s10;
  null == t107[e10] && (i10 = t107[e10 - 1]) instanceof pl && (s10 = t107[e10 + 1]) instanceof pl && t107.splice(e10 - 1, 3, new pl(i10.length + 1 + s10.length));
}
let pc = class t103 {
  constructor(t107, e10) {
    this.pos = t107, this.oracle = e10, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = t107;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(t107, e10) {
    if (this.lineStart > -1) {
      let t108 = Math.min(e10, this.lineEnd), i10 = this.nodes[this.nodes.length - 1];
      i10 instanceof pr ? i10.length += t108 - this.pos : (t108 > this.pos || !this.isCovered) && this.nodes.push(new pr(t108 - this.pos, -1)), this.writtenTo = t108, e10 > t108 && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = e10;
  }
  point(t107, e10, i10) {
    if (t107 < e10 || i10.heightRelevant) {
      let s10 = i10.widget ? i10.widget.estimatedHeight : 0, n10 = i10.widget ? i10.widget.lineBreaks : 0;
      s10 < 0 && (s10 = this.oracle.lineHeight);
      let o10 = e10 - t107;
      i10.block ? this.addBlock(new po(o10, s10, i10)) : (o10 || n10 || s10 >= 5) && this.addLineDeco(s10, n10, o10);
    } else e10 > t107 && this.span(t107, e10);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1) return;
    let { from: t107, to: e10 } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = t107, this.lineEnd = e10, this.writtenTo < t107 && ((this.writtenTo < t107 - 1 || null == this.nodes[this.nodes.length - 1]) && this.nodes.push(this.blankContent(this.writtenTo, t107 - 1)), this.nodes.push(null)), this.pos > t107 && this.nodes.push(new pr(this.pos - t107, -1)), this.writtenTo = this.pos;
  }
  blankContent(t107, e10) {
    let i10 = new pl(e10 - t107);
    return this.oracle.doc.lineAt(t107).to == e10 && (i10.flags |= 4), i10;
  }
  ensureLine() {
    this.enterLine();
    let t107 = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (t107 instanceof pr) return t107;
    let e10 = new pr(0, -1);
    return this.nodes.push(e10), e10;
  }
  addBlock(t107) {
    this.enterLine();
    let e10 = t107.deco;
    e10 && e10.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(t107), this.writtenTo = this.pos = this.pos + t107.length, e10 && e10.endSide > 0 && (this.covering = t107);
  }
  addLineDeco(t107, e10, i10) {
    let s10 = this.ensureLine();
    s10.length += i10, s10.collapsed += i10, s10.widgetHeight = Math.max(s10.widgetHeight, t107), s10.breaks += e10, this.writtenTo = this.pos = this.pos + i10;
  }
  finish(t107) {
    let e10 = 0 == this.nodes.length ? null : this.nodes[this.nodes.length - 1];
    !(this.lineStart > -1) || e10 instanceof pr || this.isCovered ? (this.writtenTo < this.pos || null == e10) && this.nodes.push(this.blankContent(this.writtenTo, this.pos)) : this.nodes.push(new pr(0, -1));
    let i10 = t107;
    for (let t108 of this.nodes) t108 instanceof pr && t108.updateHeight(this.oracle, i10), i10 += t108 ? t108.length : 1;
    return this.nodes;
  }
  static build(e10, i10, s10, n10) {
    let o10 = new t103(s10, e10);
    return tG.spans(i10, s10, n10, o10, 0), o10.finish(s10);
  }
}, pd = class {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(t107, e10, i10, s10) {
    (t107 < e10 || i10 && i10.heightRelevant || s10 && s10.heightRelevant) && fI(t107, e10, this.changes, 5);
  }
}, pu = class {
  constructor(t107, e10, i10) {
    this.from = t107, this.to = e10, this.size = i10;
  }
  static same(t107, e10) {
    if (t107.length != e10.length) return false;
    for (let i10 = 0; i10 < t107.length; i10++) {
      let s10 = t107[i10], n10 = e10[i10];
      if (s10.from != n10.from || s10.to != n10.to || s10.size != n10.size) return false;
    }
    return true;
  }
  draw(t107, e10) {
    return fN.replace({ widget: new pf(this.size * (e10 ? t107.scaleY : t107.scaleX), e10) }).range(this.from, this.to);
  }
}, pf = class extends fL {
  constructor(t107, e10) {
    super(), this.size = t107, this.vertical = e10;
  }
  eq(t107) {
    return t107.size == this.size && t107.vertical == this.vertical;
  }
  toDOM() {
    let t107 = document.createElement("div");
    return this.vertical ? t107.style.height = this.size + "px" : (t107.style.width = this.size + "px", t107.style.height = "2px", t107.style.display = "inline-block"), t107;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}, pg = class {
  constructor(t107) {
    this.state = t107, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = true, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = false, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = pw, this.scrollTarget = null, this.printing = false, this.mustMeasureContent = true, this.defaultTextDirection = f_.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = false;
    let e10 = t107.facet(gf).some((t108) => "function" != typeof t108 && "cm-lineWrapping" == t108.class);
    this.heightOracle = new pt(e10), this.stateDeco = t107.facet(gg).filter((t108) => "function" != typeof t108), this.heightMap = pn.empty().applyChanges(this.stateDeco, r.empty, this.heightOracle.setDoc(t107.doc), [new gS(0, 0, 0, t107.doc.length)]);
    for (let t108 = 0; t108 < 2 && (this.viewport = this.getViewport(0, null), this.updateForViewport()); t108++) ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = fN.set(this.lineGaps.map((t108) => t108.draw(this, false))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let t107 = [this.viewport], { main: e10 } = this.state.selection;
    for (let i10 = 0; i10 <= 1; i10++) {
      let s10 = i10 ? e10.head : e10.anchor;
      if (!t107.some((t108) => {
        let { from: e11, to: i11 } = t108;
        return s10 >= e11 && s10 <= i11;
      })) {
        let { from: e11, to: i11 } = this.lineBlockAt(s10);
        t107.push(new pp(e11, i11));
      }
    }
    return this.viewports = t107.sort((t108, e11) => t108.from - e11.from), this.updateScaler();
  }
  updateScaler() {
    let t107 = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? pw : new pb(this.heightOracle, this.heightMap, this.viewports), t107.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (t107) => {
      this.viewportLines.push(py(t107, this.scaler));
    });
  }
  update(t107) {
    var e10, i10;
    let s10, n10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    this.state = t107.state;
    let o10 = this.stateDeco;
    this.stateDeco = this.state.facet(gg).filter((t108) => "function" != typeof t108);
    let r10 = t107.changedRanges, l10 = gS.extendWithRanges(r10, (e10 = this.stateDeco, i10 = t107 ? t107.changes : Y.empty(this.state.doc.length), s10 = new pd(), tG.compare(o10, e10, i10, s10, 0), s10.changes)), h10 = this.heightMap.height, a10 = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, t107.startState.doc, this.heightOracle.setDoc(this.state.doc), l10), this.heightMap.height != h10 && (t107.flags |= 2), a10 ? (this.scrollAnchorPos = t107.changes.mapPos(a10.from, -1), this.scrollAnchorHeight = a10.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let c10 = l10.length ? this.mapViewport(this.viewport, t107.changes) : this.viewport;
    (n10 && (n10.range.head < c10.from || n10.range.head > c10.to) || !this.viewportIsAppropriate(c10)) && (c10 = this.getViewport(0, n10));
    let d10 = c10.from != this.viewport.from || c10.to != this.viewport.to;
    this.viewport = c10, t107.flags |= this.updateForViewport(), (d10 || !t107.changes.empty || 2 & t107.flags) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, t107.changes))), t107.flags |= this.computeVisibleRanges(), n10 && (this.scrollTarget = n10), !this.mustEnforceCursorAssoc && t107.selectionSet && t107.view.lineWrapping && t107.state.selection.main.empty && t107.state.selection.main.assoc && !t107.state.facet(gi) && (this.mustEnforceCursorAssoc = true);
  }
  measure(t107) {
    let e10 = t107.contentDOM, i10 = window.getComputedStyle(e10), s10 = this.heightOracle, n10 = i10.whiteSpace;
    this.defaultTextDirection = "rtl" == i10.direction ? f_.RTL : f_.LTR;
    let o10 = this.heightOracle.mustRefreshForWrapping(n10), l10 = e10.getBoundingClientRect(), h10 = o10 || this.mustMeasureContent || this.contentDOMHeight != l10.height;
    this.contentDOMHeight = l10.height, this.mustMeasureContent = false;
    let a10 = 0, c10 = 0;
    if (l10.width && l10.height) {
      let { scaleX: t108, scaleY: i11 } = u2(e10, l10);
      (t108 > 5e-3 && Math.abs(this.scaleX - t108) > 5e-3 || i11 > 5e-3 && Math.abs(this.scaleY - i11) > 5e-3) && (this.scaleX = t108, this.scaleY = i11, a10 |= 8, o10 = h10 = true);
    }
    let d10 = (parseInt(i10.paddingTop) || 0) * this.scaleY, u10 = (parseInt(i10.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != d10 || this.paddingBottom != u10) && (this.paddingTop = d10, this.paddingBottom = u10, a10 |= 10), this.editorWidth != t107.scrollDOM.clientWidth && (s10.lineWrapping && (h10 = true), this.editorWidth = t107.scrollDOM.clientWidth, a10 |= 8);
    let f10 = t107.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != f10 && (this.scrollAnchorHeight = -1, this.scrollTop = f10), this.scrolledToBottom = u7(t107.scrollDOM);
    let g10 = (this.printing ? function(t108, e11) {
      let i11 = t108.getBoundingClientRect();
      return { left: 0, right: i11.right - i11.left, top: e11, bottom: i11.bottom - (i11.top + e11) };
    } : function(t108, e11) {
      let i11 = t108.getBoundingClientRect(), s11 = t108.ownerDocument, n11 = s11.defaultView || window, o11 = Math.max(0, i11.left), r10 = Math.min(n11.innerWidth, i11.right), l11 = Math.max(0, i11.top), h11 = Math.min(n11.innerHeight, i11.bottom);
      for (let e12 = t108.parentNode; e12 && e12 != s11.body; ) if (1 == e12.nodeType) {
        let i12 = e12, s12 = window.getComputedStyle(i12);
        if ((i12.scrollHeight > i12.clientHeight || i12.scrollWidth > i12.clientWidth) && "visible" != s12.overflow) {
          let s13 = i12.getBoundingClientRect();
          o11 = Math.max(o11, s13.left), r10 = Math.min(r10, s13.right), l11 = Math.max(l11, s13.top), h11 = e12 == t108.parentNode ? s13.bottom : Math.min(h11, s13.bottom);
        }
        e12 = "absolute" == s12.position || "fixed" == s12.position ? i12.offsetParent : i12.parentNode;
      } else if (11 == e12.nodeType) e12 = e12.host;
      else break;
      return { left: o11 - i11.left, right: Math.max(o11, r10) - i11.left, top: l11 - (i11.top + e11), bottom: Math.max(l11, h11) - (i11.top + e11) };
    })(e10, this.paddingTop), p10 = g10.top - this.pixelViewport.top, m10 = g10.bottom - this.pixelViewport.bottom;
    this.pixelViewport = g10;
    let v10 = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (v10 != this.inView && (this.inView = v10, v10 && (h10 = true)), !this.inView && !this.scrollTarget) return 0;
    let w10 = l10.width;
    if ((this.contentDOMWidth != w10 || this.editorHeight != t107.scrollDOM.clientHeight) && (this.contentDOMWidth = l10.width, this.editorHeight = t107.scrollDOM.clientHeight, a10 |= 8), h10) {
      let e11 = t107.docView.measureVisibleLineHeights(this.viewport);
      if (s10.mustRefreshForHeights(e11) && (o10 = true), o10 || s10.lineWrapping && Math.abs(w10 - this.contentDOMWidth) > s10.charWidth) {
        let { lineHeight: i11, charWidth: r10, textHeight: l11 } = t107.docView.measureTextSize();
        (o10 = i11 > 0 && s10.refresh(n10, i11, r10, l11, w10 / r10, e11)) && (t107.docView.minWidth = 0, a10 |= 8);
      }
      for (let i11 of (p10 > 0 && m10 > 0 ? c10 = Math.max(p10, m10) : p10 < 0 && m10 < 0 && (c10 = Math.min(p10, m10)), s10.heightChanged = false, this.viewports)) {
        let n11 = i11.from == this.viewport.from ? e11 : t107.docView.measureVisibleLineHeights(i11);
        this.heightMap = (o10 ? pn.empty().applyChanges(this.stateDeco, r.empty, this.heightOracle, [new gS(0, 0, 0, t107.state.doc.length)]) : this.heightMap).updateHeight(s10, 0, o10, new pe(i11.from, n11));
      }
      s10.heightChanged && (a10 |= 2);
    }
    let b10 = !this.viewportIsAppropriate(this.viewport, c10) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return b10 && (2 & a10 && (a10 |= this.updateScaler()), this.viewport = this.getViewport(c10, this.scrollTarget), a10 |= this.updateForViewport()), (2 & a10 || b10) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(o10 ? [] : this.lineGaps, t107)), a10 |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = false, t107.docView.enforceCursorAssoc()), a10;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(t107, e10) {
    let i10 = 0.5 - Math.max(-0.5, Math.min(0.5, t107 / 1e3 / 2)), s10 = this.heightMap, n10 = this.heightOracle, { visibleTop: o10, visibleBottom: r10 } = this, l10 = new pp(s10.lineAt(o10 - 1e3 * i10, ps.ByHeight, n10, 0, 0).from, s10.lineAt(r10 + (1 - i10) * 1e3, ps.ByHeight, n10, 0, 0).to);
    if (e10) {
      let { head: t108 } = e10.range;
      if (t108 < l10.from || t108 > l10.to) {
        let i11 = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), o11 = s10.lineAt(t108, ps.ByPos, n10, 0, 0), r11;
        r11 = "center" == e10.y ? (o11.top + o11.bottom) / 2 - i11 / 2 : "start" == e10.y || "nearest" == e10.y && t108 < l10.from ? o11.top : o11.bottom - i11, l10 = new pp(s10.lineAt(r11 - 500, ps.ByHeight, n10, 0, 0).from, s10.lineAt(r11 + i11 + 500, ps.ByHeight, n10, 0, 0).to);
      }
    }
    return l10;
  }
  mapViewport(t107, e10) {
    let i10 = e10.mapPos(t107.from, -1), s10 = e10.mapPos(t107.to, 1);
    return new pp(this.heightMap.lineAt(i10, ps.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(s10, ps.ByPos, this.heightOracle, 0, 0).to);
  }
  viewportIsAppropriate(t107) {
    let { from: e10, to: i10 } = t107, s10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    if (!this.inView) return true;
    let { top: n10 } = this.heightMap.lineAt(e10, ps.ByPos, this.heightOracle, 0, 0), { bottom: o10 } = this.heightMap.lineAt(i10, ps.ByPos, this.heightOracle, 0, 0), { visibleTop: r10, visibleBottom: l10 } = this;
    return (0 == e10 || n10 <= r10 - Math.max(10, Math.min(-s10, 250))) && (i10 == this.state.doc.length || o10 >= l10 + Math.max(10, Math.min(s10, 250))) && n10 > r10 - 2e3 && o10 < l10 + 2e3;
  }
  mapLineGaps(t107, e10) {
    if (!t107.length || e10.empty) return t107;
    let i10 = [];
    for (let s10 of t107) e10.touchesRange(s10.from, s10.to) || i10.push(new pu(e10.mapPos(s10.from), e10.mapPos(s10.to), s10.size));
    return i10;
  }
  ensureLineGaps(t107, e10) {
    let i10 = this.heightOracle.lineWrapping, s10 = i10 ? 1e4 : 2e3, n10 = s10 >> 1, o10 = s10 << 1;
    if (this.defaultTextDirection != f_.LTR && !i10) return [];
    let r10 = [], l10 = (s11, o11, h10, a10) => {
      if (o11 - s11 < n10) return;
      let c10 = this.state.selection.main, d10 = [c10.from];
      for (let t108 of (c10.empty || d10.push(c10.to), d10)) if (t108 > s11 && t108 < o11) {
        l10(s11, t108 - 10, h10, a10), l10(t108 + 10, o11, h10, a10);
        return;
      }
      let u10 = function(t108, e11) {
        for (let i11 of t108) if (e11(i11)) return i11;
      }(t107, (t108) => t108.from >= h10.from && t108.to <= h10.to && Math.abs(t108.from - s11) < n10 && Math.abs(t108.to - o11) < n10 && !d10.some((e11) => t108.from < e11 && t108.to > e11));
      if (!u10) {
        if (o11 < h10.to && e10 && i10 && e10.visibleRanges.some((t108) => t108.from <= o11 && t108.to >= o11)) {
          let t108 = e10.moveToLineBoundary(ti.cursor(o11), false, true).head;
          t108 > s11 && (o11 = t108);
        }
        u10 = new pu(s11, o11, this.gapSize(h10, s11, o11, a10));
      }
      r10.push(u10);
    };
    for (let t108 of this.viewportLines) {
      let e11, n11;
      if (t108.length < o10) continue;
      let r11 = function(t109, e12, i11) {
        let s11 = [], n12 = t109, o11 = 0;
        return tG.spans(i11, t109, e12, { span() {
        }, point(t110, e13) {
          t110 > n12 && (s11.push({ from: n12, to: t110 }), o11 += t110 - n12), n12 = e13;
        } }, 20), n12 < e12 && (s11.push({ from: n12, to: e12 }), o11 += e12 - n12), { total: o11, ranges: s11 };
      }(t108.from, t108.to, this.stateDeco);
      if (r11.total < o10) continue;
      let h10 = this.scrollTarget ? this.scrollTarget.range.head : null;
      if (i10) {
        let i11, o11, l11 = s10 / this.heightOracle.lineLength * this.heightOracle.lineHeight;
        if (null != h10) {
          let e12 = pv(r11, h10), s11 = ((this.visibleBottom - this.visibleTop) / 2 + l11) / t108.height;
          i11 = e12 - s11, o11 = e12 + s11;
        } else i11 = (this.visibleTop - t108.top - l11) / t108.height, o11 = (this.visibleBottom - t108.top + l11) / t108.height;
        e11 = pm(r11, i11), n11 = pm(r11, o11);
      } else {
        let t109, i11, o11 = r11.total * this.heightOracle.charWidth, l11 = s10 * this.heightOracle.charWidth;
        if (null != h10) {
          let e12 = pv(r11, h10), s11 = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + l11) / o11;
          t109 = e12 - s11, i11 = e12 + s11;
        } else t109 = (this.pixelViewport.left - l11) / o11, i11 = (this.pixelViewport.right + l11) / o11;
        e11 = pm(r11, t109), n11 = pm(r11, i11);
      }
      e11 > t108.from && l10(t108.from, e11, t108, r11), n11 < t108.to && l10(n11, t108.to, t108, r11);
    }
    return r10;
  }
  gapSize(t107, e10, i10, s10) {
    let n10 = pv(s10, i10) - pv(s10, e10);
    return this.heightOracle.lineWrapping ? t107.height * n10 : s10.total * this.heightOracle.charWidth * n10;
  }
  updateLineGaps(t107) {
    pu.same(t107, this.lineGaps) || (this.lineGaps = t107, this.lineGapDeco = fN.set(t107.map((t108) => t108.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let t107 = this.stateDeco;
    this.lineGaps.length && (t107 = t107.concat(this.lineGapDeco));
    let e10 = [];
    tG.spans(t107, this.viewport.from, this.viewport.to, { span(t108, i11) {
      e10.push({ from: t108, to: i11 });
    }, point() {
    } }, 20);
    let i10 = e10.length != this.visibleRanges.length || this.visibleRanges.some((t108, i11) => t108.from != e10[i11].from || t108.to != e10[i11].to);
    return this.visibleRanges = e10, i10 ? 4 : 0;
  }
  lineBlockAt(t107) {
    return t107 >= this.viewport.from && t107 <= this.viewport.to && this.viewportLines.find((e10) => e10.from <= t107 && e10.to >= t107) || py(this.heightMap.lineAt(t107, ps.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(t107) {
    return t107 >= this.viewportLines[0].top && t107 <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((e10) => e10.top <= t107 && e10.bottom >= t107) || py(this.heightMap.lineAt(this.scaler.fromDOM(t107), ps.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(t107) {
    let e10 = this.lineBlockAtHeight(t107 + 8);
    return e10.from >= this.viewport.from || this.viewportLines[0].top - t107 > 200 ? e10 : this.viewportLines[0];
  }
  elementAtHeight(t107) {
    return py(this.heightMap.blockAt(this.scaler.fromDOM(t107), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}, pp = class {
  constructor(t107, e10) {
    this.from = t107, this.to = e10;
  }
};
function pm(t107, e10) {
  let { total: i10, ranges: s10 } = t107;
  if (e10 <= 0) return s10[0].from;
  if (e10 >= 1) return s10[s10.length - 1].to;
  let n10 = Math.floor(i10 * e10);
  for (let t108 = 0; ; t108++) {
    let { from: e11, to: i11 } = s10[t108], o10 = i11 - e11;
    if (n10 <= o10) return e11 + n10;
    n10 -= o10;
  }
}
function pv(t107, e10) {
  let i10 = 0;
  for (let { from: s10, to: n10 } of t107.ranges) {
    if (e10 <= n10) {
      i10 += e10 - s10;
      break;
    }
    i10 += n10 - s10;
  }
  return i10 / t107.total;
}
let pw = { toDOM: (t107) => t107, fromDOM: (t107) => t107, scale: 1, eq(t107) {
  return t107 == this;
} }, pb = class t104 {
  constructor(t107, e10, i10) {
    let s10 = 0, n10 = 0, o10 = 0;
    for (let r10 of (this.viewports = i10.map((i11) => {
      let { from: n11, to: o11 } = i11, r11 = e10.lineAt(n11, ps.ByPos, t107, 0, 0).top, l10 = e10.lineAt(o11, ps.ByPos, t107, 0, 0).bottom;
      return s10 += l10 - r11, { from: n11, to: o11, top: r11, bottom: l10, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - s10) / (e10.height - s10), this.viewports)) r10.domTop = o10 + (r10.top - n10) * this.scale, o10 = r10.domBottom = r10.domTop + (r10.bottom - r10.top), n10 = r10.bottom;
  }
  toDOM(t107) {
    for (let e10 = 0, i10 = 0, s10 = 0; ; e10++) {
      let n10 = e10 < this.viewports.length ? this.viewports[e10] : null;
      if (!n10 || t107 < n10.top) return s10 + (t107 - i10) * this.scale;
      if (t107 <= n10.bottom) return n10.domTop + (t107 - n10.top);
      i10 = n10.bottom, s10 = n10.domBottom;
    }
  }
  fromDOM(t107) {
    for (let e10 = 0, i10 = 0, s10 = 0; ; e10++) {
      let n10 = e10 < this.viewports.length ? this.viewports[e10] : null;
      if (!n10 || t107 < n10.domTop) return i10 + (t107 - s10) / this.scale;
      if (t107 <= n10.domBottom) return n10.top + (t107 - n10.domTop);
      i10 = n10.bottom, s10 = n10.domBottom;
    }
  }
  eq(e10) {
    return e10 instanceof t104 && this.scale == e10.scale && this.viewports.length == e10.viewports.length && this.viewports.every((t107, i10) => t107.from == e10.viewports[i10].from && t107.to == e10.viewports[i10].to);
  }
};
function py(t107, e10) {
  if (1 == e10.scale) return t107;
  let i10 = e10.toDOM(t107.top), s10 = e10.toDOM(t107.bottom);
  return new pi(t107.from, t107.length, i10, s10 - i10, Array.isArray(t107._content) ? t107._content.map((t108) => py(t108, e10)) : t107._content);
}
let px = to.define({ combine: (t107) => t107.join(" ") }), pS = to.define({ combine: (t107) => t107.indexOf(true) > -1 }), pk = t6.newName(), pM = t6.newName(), pC = t6.newName(), pA = { "&light": "." + pM, "&dark": "." + pC };
function pD(t107, e10, i10) {
  return new t6(e10, { finish: (e11) => /&/.test(e11) ? e11.replace(/&\w*/, (e12) => {
    if ("&" == e12) return t107;
    if (!i10 || !i10[e12]) throw RangeError(`Unsupported selector: ${e12}`);
    return i10[e12];
  }) : t107 + " " + e11 });
}
let pO = pD("." + pk, { "&": { position: "relative !important", boxSizing: "border-box", "&.cm-focused": { outline: "1px dotted #212121" }, display: "flex !important", flexDirection: "column" }, ".cm-scroller": { display: "flex !important", alignItems: "flex-start !important", fontFamily: "monospace", lineHeight: 1.4, height: "100%", overflowX: "auto", position: "relative", zIndex: 0 }, ".cm-content": { margin: 0, flexGrow: 2, flexShrink: 0, display: "block", whiteSpace: "pre", wordWrap: "normal", boxSizing: "border-box", minHeight: "100%", padding: "4px 0", outline: "none", "&[contenteditable=true]": { WebkitUserModify: "read-write-plaintext-only" } }, ".cm-lineWrapping": { whiteSpace_fallback: "pre-wrap", whiteSpace: "break-spaces", wordBreak: "break-word", overflowWrap: "anywhere", flexShrink: 1 }, "&light .cm-content": { caretColor: "black" }, "&dark .cm-content": { caretColor: "white" }, ".cm-line": { display: "block", padding: "0 2px 0 6px" }, ".cm-layer": { position: "absolute", left: 0, top: 0, contain: "size style", "& > *": { position: "absolute" } }, "&light .cm-selectionBackground": { background: "#d9d9d9" }, "&dark .cm-selectionBackground": { background: "#222" }, "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": { background: "#d7d4f0" }, "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": { background: "#233" }, ".cm-cursorLayer": { pointerEvents: "none" }, "&.cm-focused > .cm-scroller > .cm-cursorLayer": { animation: "steps(1) cm-blink 1.2s infinite" }, "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} }, "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} }, ".cm-cursor, .cm-dropCursor": { borderLeft: "1.2px solid black", marginLeft: "-0.6px", pointerEvents: "none" }, ".cm-cursor": { display: "none" }, "&dark .cm-cursor": { borderLeftColor: "#444" }, ".cm-dropCursor": { position: "absolute" }, "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": { display: "block" }, ".cm-iso": { unicodeBidi: "isolate" }, ".cm-announced": { position: "fixed", top: "-10000px" }, "@media print": { ".cm-announced": { display: "none" } }, "&light .cm-activeLine": { backgroundColor: "#cceeff44" }, "&dark .cm-activeLine": { backgroundColor: "#99eeff33" }, "&light .cm-specialChar": { color: "red" }, "&dark .cm-specialChar": { color: "#f78" }, ".cm-gutters": { flexShrink: 0, display: "flex", height: "100%", boxSizing: "border-box", insetInlineStart: 0, zIndex: 200 }, "&light .cm-gutters": { backgroundColor: "#f5f5f5", color: "#6c6c6c", borderRight: "1px solid #ddd" }, "&dark .cm-gutters": { backgroundColor: "#333338", color: "#ccc" }, ".cm-gutter": { display: "flex !important", flexDirection: "column", flexShrink: 0, boxSizing: "border-box", minHeight: "100%", overflow: "hidden" }, ".cm-gutterElement": { boxSizing: "border-box" }, ".cm-lineNumbers .cm-gutterElement": { padding: "0 3px 0 5px", minWidth: "20px", textAlign: "right", whiteSpace: "nowrap" }, "&light .cm-activeLineGutter": { backgroundColor: "#e2f2ff" }, "&dark .cm-activeLineGutter": { backgroundColor: "#222227" }, ".cm-panels": { boxSizing: "border-box", position: "sticky", left: 0, right: 0 }, "&light .cm-panels": { backgroundColor: "#f5f5f5", color: "black" }, "&light .cm-panels-top": { borderBottom: "1px solid #ddd" }, "&light .cm-panels-bottom": { borderTop: "1px solid #ddd" }, "&dark .cm-panels": { backgroundColor: "#333338", color: "white" }, ".cm-tab": { display: "inline-block", overflow: "hidden", verticalAlign: "bottom" }, ".cm-widgetBuffer": { verticalAlign: "text-top", height: "1em", width: 0, display: "inline" }, ".cm-placeholder": { color: "#888", display: "inline-block", verticalAlign: "top" }, ".cm-highlightSpace:before": { content: "attr(data-display)", position: "absolute", pointerEvents: "none", color: "#888" }, ".cm-highlightTab": { backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`, backgroundSize: "auto 100%", backgroundPosition: "right 90%", backgroundRepeat: "no-repeat" }, ".cm-trailingSpace": { backgroundColor: "#ff332255" }, ".cm-button": { verticalAlign: "middle", color: "inherit", fontSize: "70%", padding: ".2em 1em", borderRadius: "1px" }, "&light .cm-button": { backgroundImage: "linear-gradient(#eff1f5, #d9d9df)", border: "1px solid #888", "&:active": { backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)" } }, "&dark .cm-button": { backgroundImage: "linear-gradient(#393939, #111)", border: "1px solid #888", "&:active": { backgroundImage: "linear-gradient(#111, #333)" } }, ".cm-textfield": { verticalAlign: "middle", color: "inherit", fontSize: "70%", border: "1px solid silver", padding: ".2em .5em" }, "&light .cm-textfield": { backgroundColor: "white" }, "&dark .cm-textfield": { border: "1px solid #555", backgroundColor: "inherit" } }, pA), pT = class {
  constructor(t107, e10) {
    this.points = t107, this.text = "", this.lineSeparator = e10.facet(tW.lineSeparator);
  }
  append(t107) {
    this.text += t107;
  }
  lineBreak() {
    this.text += "";
  }
  readRange(t107, e10) {
    if (!t107) return this;
    let i10 = t107.parentNode;
    for (let s10 = t107; ; ) {
      this.findPointBefore(i10, s10);
      let t108 = this.text.length;
      this.readNode(s10);
      let n10 = s10.nextSibling;
      if (n10 == e10) break;
      let o10 = fn.get(s10), r10 = fn.get(n10);
      (o10 && r10 ? o10.breakAfter : (o10 ? o10.breakAfter : uQ(s10)) || uQ(n10) && ("BR" != s10.nodeName || s10.cmIgnore) && this.text.length > t108) && this.lineBreak(), s10 = n10;
    }
    return this.findPointBefore(i10, e10), this;
  }
  readTextNode(t107) {
    let e10 = t107.nodeValue;
    for (let i10 of this.points) i10.node == t107 && (i10.pos = this.text.length + Math.min(i10.offset, e10.length));
    for (let i10 = 0, s10 = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let n10 = -1, o10 = 1, r10;
      if (this.lineSeparator ? (n10 = e10.indexOf(this.lineSeparator, i10), o10 = this.lineSeparator.length) : (r10 = s10.exec(e10)) && (n10 = r10.index, o10 = r10[0].length), this.append(e10.slice(i10, n10 < 0 ? e10.length : n10)), n10 < 0) break;
      if (this.lineBreak(), o10 > 1) for (let e11 of this.points) e11.node == t107 && e11.pos > this.text.length && (e11.pos -= o10 - 1);
      i10 = n10 + o10;
    }
  }
  readNode(t107) {
    if (t107.cmIgnore) return;
    let e10 = fn.get(t107), i10 = e10 && e10.overrideDOMText;
    if (null != i10) {
      this.findPointInside(t107, i10.length);
      for (let t108 = i10.iter(); !t108.next().done; ) t108.lineBreak ? this.lineBreak() : this.append(t108.value);
    } else 3 == t107.nodeType ? this.readTextNode(t107) : "BR" == t107.nodeName ? t107.nextSibling && this.lineBreak() : 1 == t107.nodeType && this.readRange(t107.firstChild, null);
  }
  findPointBefore(t107, e10) {
    for (let i10 of this.points) i10.node == t107 && t107.childNodes[i10.offset] == e10 && (i10.pos = this.text.length);
  }
  findPointInside(t107, e10) {
    for (let i10 of this.points) (3 == t107.nodeType ? i10.node == t107 : t107.contains(i10.node)) && (i10.pos = this.text.length + (!function(t108, e11, i11) {
      for (; ; ) {
        if (!e11 || i11 < u0(e11)) return false;
        if (e11 == t108) return true;
        i11 = uJ(e11) + 1, e11 = e11.parentNode;
      }
    }(t107, i10.node, i10.offset) ? 0 : e10));
  }
}, pE = class {
  constructor(t107, e10) {
    this.node = t107, this.offset = e10, this.pos = -1;
  }
}, pR = class {
  constructor(t107, e10, i10, s10) {
    this.typeOver = s10, this.bounds = null, this.text = "", this.domChanged = e10 > -1;
    let { impreciseHead: n10, impreciseAnchor: o10 } = t107.docView;
    if (t107.state.readOnly && e10 > -1) this.newSel = null;
    else if (e10 > -1 && (this.bounds = t107.docView.domBoundsAround(e10, i10, 0))) {
      let e11 = n10 || o10 ? [] : function(t108) {
        let e12 = [];
        if (t108.root.activeElement != t108.contentDOM) return e12;
        let { anchorNode: i12, anchorOffset: s11, focusNode: n11, focusOffset: o11 } = t108.observer.selectionRange;
        return i12 && (e12.push(new pE(i12, s11)), (n11 != i12 || o11 != s11) && e12.push(new pE(n11, o11))), e12;
      }(t107), i11 = new pT(e11, t107.state);
      i11.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = i11.text, this.newSel = function(t108, e12) {
        if (0 == t108.length) return null;
        let i12 = t108[0].pos, s11 = 2 == t108.length ? t108[1].pos : i12;
        return i12 > -1 && s11 > -1 ? ti.single(i12 + e12, s11 + e12) : null;
      }(e11, this.bounds.from);
    } else {
      let e11 = t107.observer.selectionRange, i11 = n10 && n10.node == e11.focusNode && n10.offset == e11.focusOffset || !uU(t107.contentDOM, e11.focusNode) ? t107.state.selection.main.head : t107.docView.posFromDOM(e11.focusNode, e11.focusOffset), s11 = o10 && o10.node == e11.anchorNode && o10.offset == e11.anchorOffset || !uU(t107.contentDOM, e11.anchorNode) ? t107.state.selection.main.anchor : t107.docView.posFromDOM(e11.anchorNode, e11.anchorOffset), r10 = t107.viewport;
      if ((fy.ios || fy.chrome) && t107.state.selection.main.empty && i11 != s11 && (r10.from > 0 || r10.to < t107.state.doc.length)) {
        let e12 = Math.min(i11, s11), n11 = Math.max(i11, s11), o11 = r10.from - e12, l10 = r10.to - n11;
        (0 == o11 || 1 == o11 || 0 == e12) && (0 == l10 || -1 == l10 || n11 == t107.state.doc.length) && (i11 = 0, s11 = t107.state.doc.length);
      }
      this.newSel = ti.single(s11, i11);
    }
  }
};
function pB(t107, e10) {
  let i10;
  let { newSel: s10 } = e10, n10 = t107.state.selection.main, o10 = t107.inputState.lastKeyTime > Date.now() - 100 ? t107.inputState.lastKeyCode : -1;
  if (e10.bounds) {
    let { from: s11, to: l10 } = e10.bounds, h10 = n10.from, a10 = null;
    (8 === o10 || fy.android && e10.text.length < l10 - s11) && (h10 = n10.to, a10 = "end");
    let c10 = function(t108, e11, i11, s12) {
      let n11 = Math.min(t108.length, e11.length), o11 = 0;
      for (; o11 < n11 && t108.charCodeAt(o11) == e11.charCodeAt(o11); ) o11++;
      if (o11 == n11 && t108.length == e11.length) return null;
      let r10 = t108.length, l11 = e11.length;
      for (; r10 > 0 && l11 > 0 && t108.charCodeAt(r10 - 1) == e11.charCodeAt(l11 - 1); ) r10--, l11--;
      if ("end" == s12) {
        let t109 = Math.max(0, o11 - Math.min(r10, l11));
        i11 -= r10 + t109 - o11;
      }
      if (r10 < o11 && t108.length < e11.length) {
        let t109 = i11 <= o11 && i11 >= r10 ? o11 - i11 : 0;
        o11 -= t109, l11 = o11 + (l11 - r10), r10 = o11;
      } else if (l11 < o11) {
        let t109 = i11 <= o11 && i11 >= l11 ? o11 - i11 : 0;
        o11 -= t109, r10 = o11 + (r10 - l11), l11 = o11;
      }
      return { from: o11, toA: r10, toB: l11 };
    }(t107.state.doc.sliceString(s11, l10, ""), e10.text, h10 - s11, a10);
    c10 && (fy.chrome && 13 == o10 && c10.toB == c10.from + 2 && "" == e10.text.slice(c10.from, c10.toB) && c10.toB--, i10 = { from: s11 + c10.from, to: s11 + c10.toA, insert: r.of(e10.text.slice(c10.from, c10.toB).split("")) });
  } else s10 && (!t107.hasFocus && t107.state.facet(gl) || s10.main.eq(n10)) && (s10 = null);
  if (!i10 && !s10) return false;
  if (!i10 && e10.typeOver && !n10.empty && s10 && s10.main.empty ? i10 = { from: n10.from, to: n10.to, insert: t107.state.doc.slice(n10.from, n10.to) } : i10 && i10.from >= n10.from && i10.to <= n10.to && (i10.from != n10.from || i10.to != n10.to) && n10.to - n10.from - (i10.to - i10.from) <= 4 ? i10 = { from: n10.from, to: n10.to, insert: t107.state.doc.slice(n10.from, i10.from).append(i10.insert).append(t107.state.doc.slice(i10.to, n10.to)) } : (fy.mac || fy.android) && i10 && i10.from == i10.to && i10.from == n10.head - 1 && /^\. ?$/.test(i10.insert.toString()) && "off" == t107.contentDOM.getAttribute("autocorrect") ? (s10 && 2 == i10.insert.length && (s10 = ti.single(s10.main.anchor - 1, s10.main.head - 1)), i10 = { from: n10.from, to: n10.to, insert: r.of([" "]) }) : fy.chrome && i10 && i10.from == i10.to && i10.from == n10.head && "\n " == i10.insert.toString() && t107.lineWrapping && (s10 && (s10 = ti.single(s10.main.anchor - 1, s10.main.head - 1)), i10 = { from: n10.from, to: n10.to, insert: r.of([" "]) }), i10) {
    let e11;
    if (fy.ios && t107.inputState.flushIOSKey(i10) || fy.android && (i10.to == n10.to && (i10.from == n10.from || i10.from == n10.from - 1 && " " == t107.state.sliceDoc(i10.from, n10.from)) && 1 == i10.insert.length && 2 == i10.insert.lines && u5(t107.contentDOM, "Enter", 13) || (i10.from == n10.from - 1 && i10.to == n10.to && 0 == i10.insert.length || 8 == o10 && i10.insert.length < i10.to - i10.from && i10.to > n10.head) && u5(t107.contentDOM, "Backspace", 8) || i10.from == n10.from && i10.to == n10.to + 1 && 0 == i10.insert.length && u5(t107.contentDOM, "Delete", 46))) return true;
    let r10 = i10.insert.toString();
    t107.inputState.composing >= 0 && t107.inputState.composing++;
    let l10 = () => e11 || (e11 = function(t108, e12, i11) {
      let s11, n11 = t108.state, o11 = n11.selection.main;
      if (e12.from >= o11.from && e12.to <= o11.to && e12.to - e12.from >= (o11.to - o11.from) / 3 && (!i11 || i11.main.empty && i11.main.from == e12.from + e12.insert.length) && t108.inputState.composing < 0) {
        let i12 = o11.from < e12.from ? n11.sliceDoc(o11.from, e12.from) : "", r12 = o11.to > e12.to ? n11.sliceDoc(e12.to, o11.to) : "";
        s11 = n11.replaceSelection(t108.state.toText(i12 + e12.insert.sliceString(0, void 0, t108.state.lineBreak) + r12));
      } else {
        let r12 = n11.changes(e12), l11 = i11 && i11.main.to <= r12.newLength ? i11.main : void 0;
        if (n11.selection.ranges.length > 1 && t108.inputState.composing >= 0 && e12.to <= o11.to && e12.to >= o11.to - 10) {
          let h10 = t108.state.sliceDoc(e12.from, e12.to), a10, c10 = i11 && gA(t108, i11.main.head);
          if (c10) {
            let t109 = e12.insert.length - (e12.to - e12.from);
            a10 = { from: c10.from, to: c10.to - t109 };
          } else a10 = t108.state.doc.lineAt(o11.head);
          let d10 = o11.to - e12.to, u10 = o11.to - o11.from;
          s11 = n11.changeByRange((i12) => {
            if (i12.from == o11.from && i12.to == o11.to) return { changes: r12, range: l11 || i12.map(r12) };
            let s12 = i12.to - d10, c11 = s12 - h10.length;
            if (i12.to - i12.from != u10 || t108.state.sliceDoc(c11, s12) != h10 || i12.to >= a10.from && i12.from <= a10.to) return { range: i12 };
            let f10 = n11.changes({ from: c11, to: s12, insert: e12.insert }), g10 = i12.to - o11.to;
            return { changes: f10, range: l11 ? ti.range(Math.max(0, l11.anchor + g10), Math.max(0, l11.head + g10)) : i12.map(f10) };
          });
        } else s11 = { changes: r12, selection: l11 && n11.selection.replaceRange(l11) };
      }
      let r11 = "input.type";
      return (t108.composing || t108.inputState.compositionPendingChange && t108.inputState.compositionEndedAt > Date.now() - 50) && (t108.inputState.compositionPendingChange = false, r11 += ".compose", t108.inputState.compositionFirstChange && (r11 += ".start", t108.inputState.compositionFirstChange = false)), n11.update(s11, { userEvent: r11, scrollIntoView: true });
    }(t107, i10, s10));
    return t107.state.facet(f7).some((e12) => e12(t107, i10.from, i10.to, r10, l10)) || t107.dispatch(l10()), true;
  }
  if (!s10 || s10.main.eq(n10)) return false;
  {
    let e11 = false, i11 = "select";
    return t107.inputState.lastSelectionTime > Date.now() - 50 && ("select" == t107.inputState.lastSelectionOrigin && (e11 = true), i11 = t107.inputState.lastSelectionOrigin), t107.dispatch({ selection: s10, scrollIntoView: e11, userEvent: i11 }), true;
  }
}
let pL = { childList: true, characterData: true, subtree: true, attributes: true, characterDataOldValue: true }, pP = fy.ie && fy.ie_version <= 11, pN = class {
  constructor(t107) {
    this.view = t107, this.active = false, this.selectionRange = new u8(), this.selectionChanged = false, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = false, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = t107.contentDOM, this.observer = new MutationObserver((e10) => {
      for (let t108 of e10) this.queue.push(t108);
      (fy.ie && fy.ie_version <= 11 || fy.ios && t107.composing) && e10.some((t108) => "childList" == t108.type && t108.removedNodes.length || "characterData" == t108.type && t108.oldValue.length > t108.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), pP && (this.onCharData = (t108) => {
      this.queue.push({ target: t108.target, type: "characterData", oldValue: t108.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), "function" == typeof ResizeObserver && (this.resizeScroll = new ResizeObserver(() => {
      var t108;
      (null === (t108 = this.view.docView) || void 0 === t108 ? void 0 : t108.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(t107.scrollDOM)), this.addWindowListeners(this.win = t107.win), this.start(), "function" == typeof IntersectionObserver && (this.intersection = new IntersectionObserver((t108) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), t108.length > 0 && t108[t108.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((t108) => {
      t108.length > 0 && t108[t108.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(t107) {
    this.view.inputState.runHandlers("scroll", t107), this.intersecting && this.view.measure();
  }
  onScroll(t107) {
    this.intersecting && this.flush(false), this.onScrollChanged(t107);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(t107) {
    ("change" != t107.type || t107.matches) && (this.view.viewState.printing = true, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = false, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(t107) {
    if (this.gapIntersection && (t107.length != this.gaps.length || this.gaps.some((e10, i10) => e10 != t107[i10]))) {
      for (let e10 of (this.gapIntersection.disconnect(), t107)) this.gapIntersection.observe(e10);
      this.gaps = t107;
    }
  }
  onSelectionChange(t107) {
    let e10 = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey) return;
    let { view: i10 } = this, s10 = this.selectionRange;
    if (i10.state.facet(gl) ? i10.root.activeElement != this.dom : !uY(i10.dom, s10)) return;
    let n10 = s10.anchorNode && i10.docView.nearest(s10.anchorNode);
    if (n10 && n10.ignoreEvent(t107)) {
      e10 || (this.selectionChanged = false);
      return;
    }
    (fy.ie && fy.ie_version <= 11 || fy.android && fy.chrome) && !i10.state.selection.main.empty && s10.focusNode && uX(s10.focusNode, s10.focusOffset, s10.anchorNode, s10.anchorOffset) ? this.flushSoon() : this.flush(false);
  }
  readSelectionRange() {
    let { view: t107 } = this, e10 = uj(t107.root);
    if (!e10) return false;
    let i10 = fy.safari && 11 == t107.root.nodeType && function(t108) {
      let e11 = t108.activeElement;
      for (; e11 && e11.shadowRoot; ) e11 = e11.shadowRoot.activeElement;
      return e11;
    }(this.dom.ownerDocument) == this.dom && function(t108, e11) {
      if (e11.getComposedRanges) {
        let i12 = e11.getComposedRanges(t108.root)[0];
        if (i12) return pH(t108, i12);
      }
      let i11 = null;
      function s11(t109) {
        t109.preventDefault(), t109.stopImmediatePropagation(), i11 = t109.getTargetRanges()[0];
      }
      return t108.contentDOM.addEventListener("beforeinput", s11, true), t108.dom.ownerDocument.execCommand("indent"), t108.contentDOM.removeEventListener("beforeinput", s11, true), i11 ? pH(t108, i11) : null;
    }(this.view, e10) || e10;
    if (!i10 || this.selectionRange.eq(i10)) return false;
    let s10 = uY(this.dom, i10);
    return s10 && !this.selectionChanged && t107.inputState.lastFocusTime > Date.now() - 200 && t107.inputState.lastTouchTime < Date.now() - 300 && function(t108, e11) {
      let i11 = e11.focusNode, s11 = e11.focusOffset;
      if (!i11 || e11.anchorNode != i11 || e11.anchorOffset != s11) return false;
      for (s11 = Math.min(s11, u0(i11)); ; ) if (s11) {
        if (1 != i11.nodeType) return false;
        let t109 = i11.childNodes[s11 - 1];
        "false" == t109.contentEditable ? s11-- : s11 = u0(i11 = t109);
      } else {
        if (i11 == t108) return true;
        s11 = uJ(i11), i11 = i11.parentNode;
      }
    }(this.dom, i10) ? (this.view.inputState.lastFocusTime = 0, t107.docView.updateSelection(), false) : (this.selectionRange.setRange(i10), s10 && (this.selectionChanged = true), true);
  }
  setSelectionRange(t107, e10) {
    this.selectionRange.set(t107.node, t107.offset, e10.node, e10.offset), this.selectionChanged = false;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let t107 = 0, e10 = null;
    for (let i10 = this.dom; i10; ) if (1 == i10.nodeType) !e10 && t107 < this.scrollTargets.length && this.scrollTargets[t107] == i10 ? t107++ : e10 || (e10 = this.scrollTargets.slice(0, t107)), e10 && e10.push(i10), i10 = i10.assignedSlot || i10.parentNode;
    else if (11 == i10.nodeType) i10 = i10.host;
    else break;
    if (t107 < this.scrollTargets.length && !e10 && (e10 = this.scrollTargets.slice(0, t107)), e10) {
      for (let t108 of this.scrollTargets) t108.removeEventListener("scroll", this.onScroll);
      for (let t108 of this.scrollTargets = e10) t108.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(t107) {
    if (!this.active) return t107();
    try {
      return this.stop(), t107();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, pL), pP && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = true);
  }
  stop() {
    this.active && (this.active = false, this.observer.disconnect(), pP && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = false;
  }
  delayAndroidKey(t107, e10) {
    var i10;
    this.delayedAndroidKey || (this.flushingAndroidKey = this.view.win.requestAnimationFrame(() => {
      let t108 = this.delayedAndroidKey;
      t108 && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = t108.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && t108.force && u5(this.dom, t108.key, t108.keyCode));
    })), this.delayedAndroidKey && "Enter" != t107 || (this.delayedAndroidKey = { key: t107, keyCode: e10, force: this.lastChange < Date.now() - 50 || !!(null === (i10 = this.delayedAndroidKey) || void 0 === i10 ? void 0 : i10.force) });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let t107 of this.observer.takeRecords()) this.queue.push(t107);
    return this.queue;
  }
  processRecords() {
    let t107 = this.pendingRecords();
    t107.length && (this.queue = []);
    let e10 = -1, i10 = -1, s10 = false;
    for (let n10 of t107) {
      let t108 = this.readMutation(n10);
      t108 && (t108.typeOver && (s10 = true), -1 == e10 ? { from: e10, to: i10 } = t108 : (e10 = Math.min(t108.from, e10), i10 = Math.max(t108.to, i10)));
    }
    return { from: e10, to: i10, typeOver: s10 };
  }
  readChange() {
    let { from: t107, to: e10, typeOver: i10 } = this.processRecords(), s10 = this.selectionChanged && uY(this.dom, this.selectionRange);
    if (t107 < 0 && !s10) return null;
    t107 > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = false;
    let n10 = new pR(this.view, t107, e10, i10);
    return this.view.docView.domChanged = { newSel: n10.newSel ? n10.newSel.main : null }, n10;
  }
  flush() {
    let t107 = !(arguments.length > 0) || void 0 === arguments[0] || arguments[0];
    if (this.delayedFlush >= 0 || this.delayedAndroidKey) return false;
    t107 && this.readSelectionRange();
    let e10 = this.readChange();
    if (!e10) return this.view.requestMeasure(), false;
    let i10 = this.view.state, s10 = pB(this.view, e10);
    return this.view.state == i10 && (e10.domChanged || e10.newSel && !e10.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), s10;
  }
  readMutation(t107) {
    let e10 = this.view.docView.nearest(t107.target);
    if (!e10 || e10.ignoreMutation(t107)) return null;
    if (e10.markDirty("attributes" == t107.type), "attributes" == t107.type && (e10.flags |= 4), "childList" == t107.type) {
      let i10 = pV(e10, t107.previousSibling || t107.target.previousSibling, -1), s10 = pV(e10, t107.nextSibling || t107.target.nextSibling, 1);
      return { from: i10 ? e10.posAfter(i10) : e10.posAtStart, to: s10 ? e10.posBefore(s10) : e10.posAtEnd, typeOver: false };
    }
    return "characterData" == t107.type ? { from: e10.posAtStart, to: e10.posAtEnd, typeOver: t107.target.nodeValue == t107.oldValue } : null;
  }
  setWindow(t107) {
    t107 != this.win && (this.removeWindowListeners(this.win), this.win = t107, this.addWindowListeners(this.win));
  }
  addWindowListeners(t107) {
    t107.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener("change", this.onPrint) : t107.addEventListener("beforeprint", this.onPrint), t107.addEventListener("scroll", this.onScroll), t107.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(t107) {
    t107.removeEventListener("scroll", this.onScroll), t107.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener("change", this.onPrint) : t107.removeEventListener("beforeprint", this.onPrint), t107.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var t107, e10, i10;
    for (let s10 of (this.stop(), null === (t107 = this.intersection) || void 0 === t107 || t107.disconnect(), null === (e10 = this.gapIntersection) || void 0 === e10 || e10.disconnect(), null === (i10 = this.resizeScroll) || void 0 === i10 || i10.disconnect(), this.scrollTargets)) s10.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
};
function pV(t107, e10, i10) {
  for (; e10; ) {
    let s10 = fn.get(e10);
    if (s10 && s10.parent == t107) return s10;
    let n10 = e10.parentNode;
    e10 = n10 != t107.dom ? n10 : i10 > 0 ? e10.nextSibling : e10.previousSibling;
  }
  return null;
}
function pH(t107, e10) {
  let i10 = e10.startContainer, s10 = e10.startOffset, n10 = e10.endContainer, o10 = e10.endOffset, r10 = t107.docView.domAtPos(t107.state.selection.main.anchor);
  return uX(r10.node, r10.offset, n10, o10) && ([i10, s10, n10, o10] = [n10, o10, i10, s10]), { anchorNode: i10, anchorOffset: s10, focusNode: n10, focusOffset: o10 };
}
let pF = class t105 {
  get state() {
    return this.viewState.state;
  }
  get viewport() {
    return this.viewState.viewport;
  }
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  get inView() {
    return this.viewState.inView;
  }
  get composing() {
    return this.inputState.composing > 0;
  }
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  get root() {
    return this._root;
  }
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  constructor(t107 = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = false, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), t107.parent && t107.parent.appendChild(this.dom);
    let { dispatch: e10 } = t107;
    for (let i10 of (this.dispatchTransactions = t107.dispatchTransactions || e10 && ((t108) => t108.forEach((t109) => e10(t109, this))) || ((t108) => this.update(t108)), this.dispatch = this.dispatch.bind(this), this._root = t107.root || function(t108) {
      for (; t108; ) {
        if (t108 && (9 == t108.nodeType || 11 == t108.nodeType && t108.host)) return t108;
        t108 = t108.assignedSlot || t108.parentNode;
      }
      return null;
    }(t107.parent) || document, this.viewState = new pg(t107.state || tW.create(t107)), t107.scrollTo && t107.scrollTo.is(go) && (this.viewState.scrollTarget = t107.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(ga).map((t108) => new gd(t108)), this.plugins)) i10.update(this);
    this.observer = new pN(this), this.inputState = new gH(this), this.inputState.ensureHandlers(this.plugins), this.docView = new gM(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure();
  }
  dispatch() {
    for (var t107 = arguments.length, e10 = Array(t107), i10 = 0; i10 < t107; i10++) e10[i10] = arguments[i10];
    let s10 = 1 == e10.length && e10[0] instanceof tB ? e10 : 1 == e10.length && Array.isArray(e10[0]) ? e10[0] : [this.state.update(...e10)];
    this.dispatchTransactions(s10, this);
  }
  update(t107) {
    if (0 != this.updateState) throw Error("Calls to EditorView.update are not allowed while an update is in progress");
    let e10 = false, i10 = false, s10, n10 = this.state;
    for (let e11 of t107) {
      if (e11.startState != n10) throw RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      n10 = e11.state;
    }
    if (this.destroyed) {
      this.viewState.state = n10;
      return;
    }
    let o10 = this.hasFocus, r10 = 0, l10 = null;
    t107.some((t108) => t108.annotation(g4)) ? (this.inputState.notifiedFocused = o10, r10 = 1) : o10 == this.inputState.notifiedFocused || (this.inputState.notifiedFocused = o10, (l10 = g9(n10, o10)) || (r10 = 1));
    let h10 = this.observer.delayedAndroidKey, a10 = null;
    if (h10 ? (this.observer.clearDelayedAndroidKey(), ((a10 = this.observer.readChange()) && !this.state.doc.eq(n10.doc) || !this.state.selection.eq(n10.selection)) && (a10 = null)) : this.observer.clear(), n10.facet(tW.phrases) != this.state.facet(tW.phrases)) return this.setState(n10);
    s10 = gk.create(this, n10, t107), s10.flags |= r10;
    let c10 = this.viewState.scrollTarget;
    try {
      for (let e11 of (this.updateState = 2, t107)) {
        if (c10 && (c10 = c10.map(e11.changes)), e11.scrollIntoView) {
          let { main: t108 } = e11.state.selection;
          c10 = new gn(t108.empty ? t108 : ti.cursor(t108.head, t108.head > t108.anchor ? -1 : 1));
        }
        for (let t108 of e11.effects) t108.is(go) && (c10 = t108.value.clip(this.state));
      }
      this.viewState.update(s10, c10), this.bidiCache = pz.update(this.bidiCache, s10.changes), s10.empty || (this.updatePlugins(s10), this.inputState.update(s10)), e10 = this.docView.update(s10), this.state.facet(gx) != this.styleModules && this.mountStyles(), i10 = this.updateAttrs(), this.showAnnouncements(t107), this.docView.updateSelection(e10, t107.some((t108) => t108.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (s10.startState.facet(px) != s10.state.facet(px) && (this.viewState.mustMeasureContent = true), (e10 || i10 || c10 || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), e10 && this.docViewUpdate(), !s10.empty) for (let t108 of this.state.facet(f6)) try {
      t108(s10);
    } catch (t109) {
      gr(this.state, t109, "update listener");
    }
    (l10 || a10) && Promise.resolve().then(() => {
      l10 && this.state == l10.startState && this.dispatch(l10), a10 && !pB(this, a10) && h10.force && u5(this.contentDOM, h10.key, h10.keyCode);
    });
  }
  setState(t107) {
    if (0 != this.updateState) throw Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = t107;
      return;
    }
    this.updateState = 2;
    let e10 = this.hasFocus;
    try {
      for (let t108 of this.plugins) t108.destroy(this);
      for (let e11 of (this.viewState = new pg(t107), this.plugins = t107.facet(ga).map((t108) => new gd(t108)), this.pluginMap.clear(), this.plugins)) e11.update(this);
      this.docView.destroy(), this.docView = new gM(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    e10 && this.focus(), this.requestMeasure();
  }
  updatePlugins(t107) {
    let e10 = t107.startState.facet(ga), i10 = t107.state.facet(ga);
    if (e10 != i10) {
      let s10 = [];
      for (let n10 of i10) {
        let i11 = e10.indexOf(n10);
        if (i11 < 0) s10.push(new gd(n10));
        else {
          let e11 = this.plugins[i11];
          e11.mustUpdate = t107, s10.push(e11);
        }
      }
      for (let e11 of this.plugins) e11.mustUpdate != t107 && e11.destroy(this);
      this.plugins = s10, this.pluginMap.clear();
    } else for (let e11 of this.plugins) e11.mustUpdate = t107;
    for (let t108 = 0; t108 < this.plugins.length; t108++) this.plugins[t108].update(this);
    e10 != i10 && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let t107 of this.plugins) {
      let e10 = t107.value;
      if (e10 && e10.docViewUpdate) try {
        e10.docViewUpdate(this);
      } catch (t108) {
        gr(this.state, t108, "doc view update listener");
      }
    }
  }
  measure() {
    let t107 = !(arguments.length > 0) || void 0 === arguments[0] || arguments[0];
    if (this.destroyed) return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, t107 && this.observer.forceFlush();
    let e10 = null, i10 = this.scrollDOM, s10 = i10.scrollTop * this.scaleY, { scrollAnchorPos: n10, scrollAnchorHeight: o10 } = this.viewState;
    Math.abs(s10 - this.viewState.scrollTop) > 1 && (o10 = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let t108 = 0; ; t108++) {
        if (o10 < 0) {
          if (u7(i10)) n10 = -1, o10 = this.viewState.heightMap.height;
          else {
            let t109 = this.viewState.scrollAnchorAt(s10);
            n10 = t109.from, o10 = t109.top;
          }
        }
        this.updateState = 1;
        let r10 = this.viewState.measure(this);
        if (!r10 && !this.measureRequests.length && null == this.viewState.scrollTarget) break;
        if (t108 > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let l10 = [];
        4 & r10 || ([this.measureRequests, l10] = [l10, this.measureRequests]);
        let h10 = l10.map((t109) => {
          try {
            return t109.read(this);
          } catch (t110) {
            return gr(this.state, t110), pI;
          }
        }), a10 = gk.create(this, this.state, []), c10 = false;
        a10.flags |= r10, e10 ? e10.flags |= r10 : e10 = a10, this.updateState = 2, !a10.empty && (this.updatePlugins(a10), this.inputState.update(a10), this.updateAttrs(), (c10 = this.docView.update(a10)) && this.docViewUpdate());
        for (let t109 = 0; t109 < l10.length; t109++) if (h10[t109] != pI) try {
          let e11 = l10[t109];
          e11.write && e11.write(h10[t109], this);
        } catch (t110) {
          gr(this.state, t110);
        }
        if (c10 && this.docView.updateSelection(true), !a10.viewportChanged && 0 == this.measureRequests.length) {
          if (this.viewState.editorHeight) {
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, o10 = -1;
              continue;
            }
            {
              let t109 = (n10 < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(n10).top) - o10;
              if (t109 > 1 || t109 < -1) {
                s10 += t109, i10.scrollTop = s10 / this.scaleY, o10 = -1;
                continue;
              }
            }
          }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (e10 && !e10.empty) for (let t108 of this.state.facet(f6)) t108(e10);
  }
  get themeClasses() {
    return pk + " " + (this.state.facet(pS) ? pC : pM) + " " + this.state.facet(px);
  }
  updateAttrs() {
    let t107 = pK(this, gu, { class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses }), e10 = { spellcheck: "false", autocorrect: "off", autocapitalize: "off", translate: "no", contenteditable: this.state.facet(gl) ? "true" : "false", class: "cm-content", style: `${fy.tabSize}: ${this.state.tabSize}`, role: "textbox", "aria-multiline": "true" };
    this.state.readOnly && (e10["aria-readonly"] = "true"), pK(this, gf, e10);
    let i10 = this.observer.ignore(() => {
      let i11 = fE(this.contentDOM, this.contentAttrs, e10), s10 = fE(this.dom, this.editorAttrs, t107);
      return i11 || s10;
    });
    return this.editorAttrs = t107, this.contentAttrs = e10, i10;
  }
  showAnnouncements(e10) {
    let i10 = true;
    for (let s10 of e10) for (let e11 of s10.effects) e11.is(t105.announce) && (i10 && (this.announceDOM.textContent = ""), i10 = false, this.announceDOM.appendChild(document.createElement("div")).textContent = e11.value);
  }
  mountStyles() {
    this.styleModules = this.state.facet(gx);
    let e10 = this.state.facet(t105.cspNonce);
    t6.mount(this.root, this.styleModules.concat(pO).reverse(), e10 ? { nonce: e10 } : void 0);
  }
  readMeasured() {
    if (2 == this.updateState) throw Error("Reading the editor layout isn't allowed during an update");
    0 == this.updateState && this.measureScheduled > -1 && this.measure(false);
  }
  requestMeasure(t107) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), t107 && !(this.measureRequests.indexOf(t107) > -1)) {
      if (null != t107.key) {
        for (let e10 = 0; e10 < this.measureRequests.length; e10++) if (this.measureRequests[e10].key === t107.key) {
          this.measureRequests[e10] = t107;
          return;
        }
      }
      this.measureRequests.push(t107);
    }
  }
  plugin(t107) {
    let e10 = this.pluginMap.get(t107);
    return (void 0 === e10 || e10 && e10.spec != t107) && this.pluginMap.set(t107, e10 = this.plugins.find((e11) => e11.spec == t107) || null), e10 && e10.update(this).value;
  }
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  get scaleX() {
    return this.viewState.scaleX;
  }
  get scaleY() {
    return this.viewState.scaleY;
  }
  elementAtHeight(t107) {
    return this.readMeasured(), this.viewState.elementAtHeight(t107);
  }
  lineBlockAtHeight(t107) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(t107);
  }
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  lineBlockAt(t107) {
    return this.viewState.lineBlockAt(t107);
  }
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  moveByChar(t107, e10, i10) {
    return gV(this, t107, gP(this, t107, e10, i10));
  }
  moveByGroup(t107, e10) {
    return gV(this, t107, gP(this, t107, e10, (e11) => {
      var i10;
      let s10, n10;
      return i10 = t107.head, n10 = (s10 = this.state.charCategorizer(i10))(e11), (t108) => {
        let e12 = s10(t108);
        return n10 == tH.Space && (n10 = e12), n10 == e12;
      };
    }));
  }
  visualLineSide(t107, e10) {
    let i10 = this.bidiSpans(t107), s10 = this.textDirectionAt(t107.from), n10 = i10[e10 ? i10.length - 1 : 0];
    return ti.cursor(n10.side(e10, s10) + t107.from, n10.forward(!e10, s10) ? 1 : -1);
  }
  moveToLineBoundary(t107, e10) {
    let i10 = !(arguments.length > 2) || void 0 === arguments[2] || arguments[2];
    return function(t108, e11, i11, s10) {
      let n10 = function(t109, e12) {
        let i12 = t109.lineBlockAt(e12);
        if (Array.isArray(i12.type)) {
          for (let t110 of i12.type) if (t110.to > e12 || t110.to == e12 && (t110.to == i12.to || t110.type == fP.Text)) return t110;
        }
        return i12;
      }(t108, e11.head), o10 = s10 && n10.type == fP.Text && (t108.lineWrapping || n10.widgetLineBreaks) ? t108.coordsAtPos(e11.assoc < 0 && e11.head > n10.from ? e11.head - 1 : e11.head) : null;
      if (o10) {
        let e12 = t108.dom.getBoundingClientRect(), s11 = t108.textDirectionAt(n10.from), r10 = t108.posAtCoords({ x: i11 == (s11 == f_.LTR) ? e12.right - 1 : e12.left + 1, y: (o10.top + o10.bottom) / 2 });
        if (null != r10) return ti.cursor(r10, i11 ? -1 : 1);
      }
      return ti.cursor(i11 ? n10.to : n10.from, i11 ? -1 : 1);
    }(this, t107, e10, i10);
  }
  moveVertically(t107, e10, i10) {
    return gV(this, t107, function(t108, e11, i11, s10) {
      let n10 = e11.head, o10 = i11 ? 1 : -1;
      if (n10 == (i11 ? t108.state.doc.length : 0)) return ti.cursor(n10, e11.assoc);
      let r10 = e11.goalColumn, l10, h10 = t108.contentDOM.getBoundingClientRect(), a10 = t108.coordsAtPos(n10, e11.assoc || -1), c10 = t108.documentTop;
      if (a10) null == r10 && (r10 = a10.left - h10.left), l10 = o10 < 0 ? a10.top : a10.bottom;
      else {
        let e12 = t108.viewState.lineBlockAt(n10);
        null == r10 && (r10 = Math.min(h10.right - h10.left, t108.defaultCharacterWidth * (n10 - e12.from))), l10 = (o10 < 0 ? e12.top : e12.bottom) + c10;
      }
      let d10 = h10.left + r10, u10 = null != s10 ? s10 : t108.viewState.heightOracle.textHeight >> 1;
      for (let e12 = 0; ; e12 += 10) {
        let i12 = l10 + (u10 + e12) * o10, s11 = gB(t108, { x: d10, y: i12 }, false, o10);
        if (i12 < h10.top || i12 > h10.bottom || (o10 < 0 ? s11 < n10 : s11 > n10)) {
          let e13 = t108.docView.coordsForChar(s11), n11 = !e13 || i12 < e13.top ? -1 : 1;
          return ti.cursor(s11, n11, void 0, r10);
        }
      }
    }(this, t107, e10, i10));
  }
  domAtPos(t107) {
    return this.docView.domAtPos(t107);
  }
  posAtDOM(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    return this.docView.posFromDOM(t107, e10);
  }
  posAtCoords(t107) {
    let e10 = !(arguments.length > 1) || void 0 === arguments[1] || arguments[1];
    return this.readMeasured(), gB(this, t107, e10);
  }
  coordsAtPos(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
    this.readMeasured();
    let i10 = this.docView.coordsAt(t107, e10);
    if (!i10 || i10.left == i10.right) return i10;
    let s10 = this.state.doc.lineAt(t107), n10 = this.bidiSpans(s10);
    return u1(i10, n10[f0.find(n10, t107 - s10.from, -1, e10)].dir == f_.LTR == e10 > 0);
  }
  coordsForChar(t107) {
    return this.readMeasured(), this.docView.coordsForChar(t107);
  }
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  textDirectionAt(t107) {
    return !this.state.facet(ge) || t107 < this.viewport.from || t107 > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(t107));
  }
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  bidiSpans(t107) {
    if (t107.length > pW) return f2(t107.length);
    let e10 = this.textDirectionAt(t107.from), i10;
    for (let s11 of this.bidiCache) if (s11.from == t107.from && s11.dir == e10 && (s11.fresh || function t108(e11, i11) {
      if (e11.length != i11.length) return false;
      for (let s12 = 0; s12 < e11.length; s12++) {
        let n10 = e11[s12], o10 = i11[s12];
        if (n10.from != o10.from || n10.to != o10.to || n10.direction != o10.direction || !t108(n10.inner, o10.inner)) return false;
      }
      return true;
    }(s11.isolates, i10 = gw(this, t107)))) return s11.order;
    i10 || (i10 = gw(this, t107));
    let s10 = function(t108, e11, i11) {
      if (!t108) return [new f0(0, 0, e11 == fj ? 1 : 0)];
      if (e11 == fG && !i11.length && !fZ.test(t108)) return f2(t108.length);
      if (i11.length) for (; t108.length > f1.length; ) f1[f1.length] = 256;
      let s11 = [], n10 = e11 == fG ? 0 : 1;
      return function t109(e12, i12, s12, n11, o10, r10, l10) {
        let h10 = i12 % 2 ? 2 : 1;
        (function(t110, e13, i13, s13, n12) {
          for (let o11 = 0; o11 <= s13.length; o11++) {
            let r11 = o11 ? s13[o11 - 1].to : e13, l11 = o11 < s13.length ? s13[o11].from : i13, h11 = o11 ? 256 : n12;
            for (let e14 = r11, i14 = h11, s14 = h11; e14 < l11; e14++) {
              let n13 = fQ(t110.charCodeAt(e14));
              512 == n13 ? n13 = i14 : 8 == n13 && 4 == s14 && (n13 = 16), f1[e14] = 4 == n13 ? 2 : n13, 7 & n13 && (s14 = n13), i14 = n13;
            }
            for (let t111 = r11, e14 = h11, s14 = h11; t111 < l11; t111++) {
              let n13 = f1[t111];
              if (128 == n13) t111 < l11 - 1 && e14 == f1[t111 + 1] && 24 & e14 ? n13 = f1[t111] = e14 : f1[t111] = 256;
              else if (64 == n13) {
                let n14 = t111 + 1;
                for (; n14 < l11 && 64 == f1[n14]; ) n14++;
                let o12 = t111 && 8 == e14 || n14 < i13 && 8 == f1[n14] ? 1 == s14 ? 1 : 8 : 256;
                for (let e15 = t111; e15 < n14; e15++) f1[e15] = o12;
                t111 = n14 - 1;
              } else 8 == n13 && 1 == s14 && (f1[t111] = 1);
              e14 = n13, 7 & n13 && (s14 = n13);
            }
          }
        })(e12, o10, r10, n11, h10), function(t110, e13, i13, s13, n12) {
          let o11 = 1 == n12 ? 2 : 1;
          for (let r11 = 0, l11 = 0, h11 = 0; r11 <= s13.length; r11++) {
            let a10 = r11 ? s13[r11 - 1].to : e13, c10 = r11 < s13.length ? s13[r11].from : i13;
            for (let e14 = a10, i14, s14, r12; e14 < c10; e14++) if (s14 = fX[i14 = t110.charCodeAt(e14)]) {
              if (s14 < 0) {
                for (let t111 = l11 - 3; t111 >= 0; t111 -= 3) if (fJ[t111 + 1] == -s14) {
                  let i15 = fJ[t111 + 2], s15 = 2 & i15 ? n12 : 4 & i15 ? 1 & i15 ? o11 : n12 : 0;
                  s15 && (f1[e14] = f1[fJ[t111]] = s15), l11 = t111;
                  break;
                }
              } else if (189 == fJ.length) break;
              else fJ[l11++] = e14, fJ[l11++] = i14, fJ[l11++] = h11;
            } else if (2 == (r12 = f1[e14]) || 1 == r12) {
              let t111 = r12 == n12;
              h11 = t111 ? 0 : 1;
              for (let e15 = l11 - 3; e15 >= 0; e15 -= 3) {
                let i15 = fJ[e15 + 2];
                if (2 & i15) break;
                if (t111) fJ[e15 + 2] |= 2;
                else {
                  if (4 & i15) break;
                  fJ[e15 + 2] |= 4;
                }
              }
            }
          }
        }(e12, o10, r10, n11, h10), function(t110, e13, i13, s13) {
          for (let n12 = 0, o11 = s13; n12 <= i13.length; n12++) {
            let r11 = n12 ? i13[n12 - 1].to : t110, l11 = n12 < i13.length ? i13[n12].from : e13;
            for (let h11 = r11; h11 < l11; ) {
              let r12 = f1[h11];
              if (256 == r12) {
                let r13 = h11 + 1;
                for (; ; ) if (r13 == l11) {
                  if (n12 == i13.length) break;
                  r13 = i13[n12++].to, l11 = n12 < i13.length ? i13[n12].from : e13;
                } else if (256 == f1[r13]) r13++;
                else break;
                let a10 = 1 == o11, c10 = a10 == ((r13 < e13 ? f1[r13] : s13) == 1) ? a10 ? 1 : 2 : s13;
                for (let e14 = r13, s14 = n12, o12 = s14 ? i13[s14 - 1].to : t110; e14 > h11; ) e14 == o12 && (e14 = i13[--s14].from, o12 = s14 ? i13[s14 - 1].to : t110), f1[--e14] = c10;
                h11 = r13;
              } else o11 = r12, h11++;
            }
          }
        }(o10, r10, n11, h10), function e13(i13, s13, n12, o11, r11, l11, h11) {
          let a10 = o11 % 2 ? 2 : 1;
          if (o11 % 2 == r11 % 2) for (let c10 = s13, d10 = 0; c10 < n12; ) {
            let s14 = true, u10 = false;
            if (d10 == l11.length || c10 < l11[d10].from) {
              let t110 = f1[c10];
              t110 != a10 && (s14 = false, u10 = 16 == t110);
            }
            let f10 = s14 || 1 != a10 ? null : [], g10 = s14 ? o11 : o11 + 1, p10 = c10;
            e: for (; ; ) if (d10 < l11.length && p10 == l11[d10].from) {
              if (u10) break;
              let e14 = l11[d10];
              if (!s14) for (let t110 = e14.to, i14 = d10 + 1; ; ) {
                if (t110 == n12) break e;
                if (i14 < l11.length && l11[i14].from == t110) t110 = l11[i14++].to;
                else if (f1[t110] == a10) break e;
                else break;
              }
              d10++, f10 ? f10.push(e14) : (e14.from > c10 && h11.push(new f0(c10, e14.from, g10)), t109(i13, e14.direction == fG != !(g10 % 2) ? o11 + 1 : o11, r11, e14.inner, e14.from, e14.to, h11), c10 = e14.to), p10 = e14.to;
            } else if (p10 == n12 || (s14 ? f1[p10] != a10 : f1[p10] == a10)) break;
            else p10++;
            f10 ? e13(i13, c10, p10, o11 + 1, r11, f10, h11) : c10 < p10 && h11.push(new f0(c10, p10, g10)), c10 = p10;
          }
          else for (let c10 = n12, d10 = l11.length; c10 > s13; ) {
            let n13 = true, u10 = false;
            if (!d10 || c10 > l11[d10 - 1].to) {
              let t110 = f1[c10 - 1];
              t110 != a10 && (n13 = false, u10 = 16 == t110);
            }
            let f10 = n13 || 1 != a10 ? null : [], g10 = n13 ? o11 : o11 + 1, p10 = c10;
            e: for (; ; ) if (d10 && p10 == l11[d10 - 1].to) {
              if (u10) break;
              let e14 = l11[--d10];
              if (!n13) for (let t110 = e14.from, i14 = d10; ; ) {
                if (t110 == s13) break e;
                if (i14 && l11[i14 - 1].to == t110) t110 = l11[--i14].from;
                else if (f1[t110 - 1] == a10) break e;
                else break;
              }
              f10 ? f10.push(e14) : (e14.to < c10 && h11.push(new f0(e14.to, c10, g10)), t109(i13, e14.direction == fG != !(g10 % 2) ? o11 + 1 : o11, r11, e14.inner, e14.from, e14.to, h11), c10 = e14.from), p10 = e14.from;
            } else if (p10 == s13 || (n13 ? f1[p10 - 1] != a10 : f1[p10 - 1] == a10)) break;
            else p10--;
            f10 ? e13(i13, p10, c10, o11 + 1, r11, f10, h11) : p10 < c10 && h11.push(new f0(p10, c10, g10)), c10 = p10;
          }
        }(e12, o10, r10, i12, s12, n11, l10);
      }(t108, n10, n10, i11, 0, t108.length, s11), s11;
    }(t107.text, e10, i10);
    return this.bidiCache.push(new pz(t107.from, t107.to, e10, i10, true, s10)), s10;
  }
  get hasFocus() {
    var t107;
    return (this.dom.ownerDocument.hasFocus() || fy.safari && (null === (t107 = this.inputState) || void 0 === t107 ? void 0 : t107.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  focus() {
    this.observer.ignore(() => {
      u4(this.contentDOM), this.docView.updateSelection();
    });
  }
  setRoot(t107) {
    this._root != t107 && (this._root = t107, this.observer.setWindow((9 == t107.nodeType ? t107 : t107.ownerDocument).defaultView || window), this.mountStyles());
  }
  destroy() {
    for (let t107 of this.plugins) t107.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = true;
  }
  static scrollIntoView(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return go.of(new gn("number" == typeof t107 ? ti.cursor(t107) : t107, e10.y, e10.x, e10.yMargin, e10.xMargin));
  }
  scrollSnapshot() {
    let { scrollTop: t107, scrollLeft: e10 } = this.scrollDOM, i10 = this.viewState.scrollAnchorAt(t107);
    return go.of(new gn(ti.cursor(i10.from), "start", "start", i10.top - t107, e10, true));
  }
  setTabFocusMode(t107) {
    null == t107 ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : "boolean" == typeof t107 ? this.inputState.tabFocusMode = t107 ? 0 : -1 : 0 != this.inputState.tabFocusMode && (this.inputState.tabFocusMode = Date.now() + t107);
  }
  static domEventHandlers(t107) {
    return gc.define(() => ({}), { eventHandlers: t107 });
  }
  static domEventObservers(t107) {
    return gc.define(() => ({}), { eventObservers: t107 });
  }
  static theme(t107, e10) {
    let i10 = t6.newName(), s10 = [px.of(i10), gx.of(pD(`.${i10}`, t107))];
    return e10 && e10.dark && s10.push(pS.of(true)), s10;
  }
  static baseTheme(t107) {
    return tg.lowest(gx.of(pD("." + pk, t107, pA)));
  }
  static findFromDOM(t107) {
    var e10;
    let i10 = t107.querySelector(".cm-content"), s10 = i10 && fn.get(i10) || fn.get(t107);
    return (null === (e10 = null == s10 ? void 0 : s10.rootView) || void 0 === e10 ? void 0 : e10.view) || null;
  }
};
pF.styleModule = gx, pF.inputHandler = f7, pF.scrollHandler = gs, pF.focusChangeEffect = gt, pF.perLineTextDirection = ge, pF.exceptionSink = f5, pF.updateListener = f6, pF.editable = gl, pF.mouseSelectionStyle = f9, pF.dragMovesSelection = f4, pF.clickAddsSelectionRange = f3, pF.decorations = gg, pF.outerDecorations = gp, pF.atomicRanges = gm, pF.bidiIsolatedRanges = gv, pF.scrollMargins = gb, pF.darkTheme = pS, pF.cspNonce = to.define({ combine: (t107) => t107.length ? t107[0] : "" }), pF.contentAttributes = gf, pF.editorAttributes = gu, pF.lineWrapping = pF.contentAttributes.of({ class: "cm-lineWrapping" }), pF.announce = tR.define();
let pW = 4096, pI = {}, pz = class t106 {
  constructor(t107, e10, i10, s10, n10, o10) {
    this.from = t107, this.to = e10, this.dir = i10, this.isolates = s10, this.fresh = n10, this.order = o10;
  }
  static update(e10, i10) {
    if (i10.empty && !e10.some((t107) => t107.fresh)) return e10;
    let s10 = [], n10 = e10.length ? e10[e10.length - 1].dir : f_.LTR;
    for (let o10 = Math.max(0, e10.length - 10); o10 < e10.length; o10++) {
      let r10 = e10[o10];
      r10.dir != n10 || i10.touchesRange(r10.from, r10.to) || s10.push(new t106(i10.mapPos(r10.from, 1), i10.mapPos(r10.to, -1), r10.dir, r10.isolates, false, r10.order));
    }
    return s10;
  }
};
function pK(t107, e10, i10) {
  for (let s10 = t107.state.facet(e10), n10 = s10.length - 1; n10 >= 0; n10--) {
    let e11 = s10[n10], o10 = "function" == typeof e11 ? e11(t107) : e11;
    o10 && fD(o10, i10);
  }
  return i10;
}
let pq = !fy.ios, p_ = { ".cm-line": { "& ::selection, &::selection": { backgroundColor: "transparent !important" } }, ".cm-content": { "& :focus": { caretColor: "initial !important", "&::selection, & ::selection": { backgroundColor: "Highlight !important" } } } };
pq && (p_[".cm-line"].caretColor = p_[".cm-content"].caretColor = "transparent !important");
let pG = class extends tz {
  compare(t107) {
    return this == t107 || this.constructor == t107.constructor && this.eq(t107);
  }
  eq(t107) {
    return false;
  }
  destroy(t107) {
  }
};
pG.prototype.elementClass = "", pG.prototype.toDOM = void 0, pG.prototype.mapMode = j.TrackBefore, pG.prototype.startSide = pG.prototype.endSide = -1, pG.prototype.point = true;
let pj = to.define(), pU = { class: "", renderEmptyElements: false, elementStyle: "", markers: () => tG.empty, lineMarker: () => null, widgetMarker: () => null, lineMarkerChange: null, initialSpacer: null, updateSpacer: null, domEventHandlers: {} }, pY = to.define(), p$ = to.define({ combine: (t107) => t107.some((t108) => t108) }), pX = gc.fromClass(class {
  constructor(t107) {
    for (let e10 of (this.view = t107, this.prevViewport = t107.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = t107.state.facet(pY).map((e11) => new p0(t107, e11)), this.gutters)) this.dom.appendChild(e10.dom);
    this.fixed = !t107.state.facet(p$), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(false), t107.scrollDOM.insertBefore(this.dom, t107.contentDOM);
  }
  update(t107) {
    if (this.updateGutters(t107)) {
      let e10 = this.prevViewport, i10 = t107.view.viewport, s10 = Math.min(e10.to, i10.to) - Math.max(e10.from, i10.from);
      this.syncGutters(s10 < (i10.to - i10.from) * 0.8);
    }
    t107.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px"), this.view.state.facet(p$) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = t107.view.viewport;
  }
  syncGutters(t107) {
    let e10 = this.dom.nextSibling;
    t107 && this.dom.remove();
    let i10 = tG.iter(this.view.state.facet(pj), this.view.viewport.from), s10 = [], n10 = this.gutters.map((t108) => new pZ(t108, this.view.viewport, -this.view.documentPadding.top));
    for (let t108 of this.view.viewportLineBlocks) if (s10.length && (s10 = []), Array.isArray(t108.type)) {
      let e11 = true;
      for (let o10 of t108.type) if (o10.type == fP.Text && e11) {
        for (let t109 of (pQ(i10, s10, o10.from), n10)) t109.line(this.view, o10, s10);
        e11 = false;
      } else if (o10.widget) for (let t109 of n10) t109.widget(this.view, o10);
    } else if (t108.type == fP.Text) for (let e11 of (pQ(i10, s10, t108.from), n10)) e11.line(this.view, t108, s10);
    else if (t108.widget) for (let e11 of n10) e11.widget(this.view, t108);
    for (let t108 of n10) t108.finish();
    t107 && this.view.scrollDOM.insertBefore(this.dom, e10);
  }
  updateGutters(t107) {
    let e10 = t107.startState.facet(pY), i10 = t107.state.facet(pY), s10 = t107.docChanged || t107.heightChanged || t107.viewportChanged || !tG.eq(t107.startState.facet(pj), t107.state.facet(pj), t107.view.viewport.from, t107.view.viewport.to);
    if (e10 == i10) for (let e11 of this.gutters) e11.update(t107) && (s10 = true);
    else {
      s10 = true;
      let n10 = [];
      for (let s11 of i10) {
        let i11 = e10.indexOf(s11);
        i11 < 0 ? n10.push(new p0(this.view, s11)) : (this.gutters[i11].update(t107), n10.push(this.gutters[i11]));
      }
      for (let t108 of this.gutters) t108.dom.remove(), 0 > n10.indexOf(t108) && t108.destroy();
      for (let t108 of n10) this.dom.appendChild(t108.dom);
      this.gutters = n10;
    }
    return s10;
  }
  destroy() {
    for (let t107 of this.gutters) t107.destroy();
    this.dom.remove();
  }
}, { provide: (t107) => pF.scrollMargins.of((e10) => {
  let i10 = e10.plugin(t107);
  return i10 && 0 != i10.gutters.length && i10.fixed ? e10.textDirection == f_.LTR ? { left: i10.dom.offsetWidth * e10.scaleX } : { right: i10.dom.offsetWidth * e10.scaleX } : null;
}) });
function pJ(t107) {
  return Array.isArray(t107) ? t107 : [t107];
}
function pQ(t107, e10, i10) {
  for (; t107.value && t107.from <= i10; ) t107.from == i10 && e10.push(t107.value), t107.next();
}
class pZ {
  constructor(t107, e10, i10) {
    this.gutter = t107, this.height = i10, this.i = 0, this.cursor = tG.iter(t107.markers, e10.from);
  }
  addElement(t107, e10, i10) {
    let { gutter: s10 } = this, n10 = (e10.top - this.height) / t107.scaleY, o10 = e10.height / t107.scaleY;
    if (this.i == s10.elements.length) {
      let e11 = new p1(t107, o10, n10, i10);
      s10.elements.push(e11), s10.dom.appendChild(e11.dom);
    } else s10.elements[this.i].update(t107, o10, n10, i10);
    this.height = e10.bottom, this.i++;
  }
  line(t107, e10, i10) {
    let s10 = [];
    pQ(this.cursor, s10, e10.from), i10.length && (s10 = s10.concat(i10));
    let n10 = this.gutter.config.lineMarker(t107, e10, s10);
    n10 && s10.unshift(n10);
    let o10 = this.gutter;
    (0 != s10.length || o10.config.renderEmptyElements) && this.addElement(t107, e10, s10);
  }
  widget(t107, e10) {
    let i10 = this.gutter.config.widgetMarker(t107, e10.widget, e10);
    i10 && this.addElement(t107, e10, [i10]);
  }
  finish() {
    let t107 = this.gutter;
    for (; t107.elements.length > this.i; ) {
      let e10 = t107.elements.pop();
      t107.dom.removeChild(e10.dom), e10.destroy();
    }
  }
}
class p0 {
  constructor(t107, e10) {
    for (let i10 in this.view = t107, this.config = e10, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : ""), e10.domEventHandlers) this.dom.addEventListener(i10, (s10) => {
      let n10 = s10.target, o10;
      if (n10 != this.dom && this.dom.contains(n10)) {
        for (; n10.parentNode != this.dom; ) n10 = n10.parentNode;
        let t108 = n10.getBoundingClientRect();
        o10 = (t108.top + t108.bottom) / 2;
      } else o10 = s10.clientY;
      let r10 = t107.lineBlockAtHeight(o10 - t107.documentTop);
      e10.domEventHandlers[i10](t107, r10, s10) && s10.preventDefault();
    });
    this.markers = pJ(e10.markers(t107)), e10.initialSpacer && (this.spacer = new p1(t107, 0, 0, [e10.initialSpacer(t107)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(t107) {
    let e10 = this.markers;
    if (this.markers = pJ(this.config.markers(t107.view)), this.spacer && this.config.updateSpacer) {
      let e11 = this.config.updateSpacer(this.spacer.markers[0], t107);
      e11 != this.spacer.markers[0] && this.spacer.update(t107.view, 0, 0, [e11]);
    }
    let i10 = t107.view.viewport;
    return !tG.eq(this.markers, e10, i10.from, i10.to) || !!this.config.lineMarkerChange && this.config.lineMarkerChange(t107);
  }
  destroy() {
    for (let t107 of this.elements) t107.destroy();
  }
}
class p1 {
  constructor(t107, e10, i10, s10) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(t107, e10, i10, s10);
  }
  update(t107, e10, i10, s10) {
    this.height != e10 && (this.height = e10, this.dom.style.height = e10 + "px"), this.above != i10 && (this.dom.style.marginTop = (this.above = i10) ? i10 + "px" : ""), !function(t108, e11) {
      if (t108.length != e11.length) return false;
      for (let i11 = 0; i11 < t108.length; i11++) if (!t108[i11].compare(e11[i11])) return false;
      return true;
    }(this.markers, s10) && this.setMarkers(t107, s10);
  }
  setMarkers(t107, e10) {
    let i10 = "cm-gutterElement", s10 = this.dom.firstChild;
    for (let n10 = 0, o10 = 0; ; ) {
      let r10 = o10, l10 = n10 < e10.length ? e10[n10++] : null, h10 = false;
      if (l10) {
        let t108 = l10.elementClass;
        t108 && (i10 += " " + t108);
        for (let t109 = o10; t109 < this.markers.length; t109++) if (this.markers[t109].compare(l10)) {
          r10 = t109, h10 = true;
          break;
        }
      } else r10 = this.markers.length;
      for (; o10 < r10; ) {
        let t108 = this.markers[o10++];
        if (t108.toDOM) {
          t108.destroy(s10);
          let e11 = s10.nextSibling;
          s10.remove(), s10 = e11;
        }
      }
      if (!l10) break;
      l10.toDOM && (h10 ? s10 = s10.nextSibling : this.dom.insertBefore(l10.toDOM(t107), s10)), h10 && o10++;
    }
    this.dom.className = i10, this.markers = e10;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
let p2 = 0;
class p8 {
  constructor(t107, e10, i10) {
    this.set = t107, this.base = e10, this.modified = i10, this.id = p2++;
  }
  static define(t107) {
    if (null == t107 ? void 0 : t107.base) throw Error("Can not derive from a modified tag");
    let e10 = new p8([], null, []);
    if (e10.set.push(e10), t107) for (let i10 of t107.set) e10.set.push(i10);
    return e10;
  }
  static defineModifier() {
    let t107 = new p4();
    return (e10) => e10.modified.indexOf(t107) > -1 ? e10 : p4.get(e10.base || e10, e10.modified.concat(t107).sort((t108, e11) => t108.id - e11.id));
  }
}
let p3 = 0;
class p4 {
  constructor() {
    this.instances = [], this.id = p3++;
  }
  static get(t107, e10) {
    if (!e10.length) return t107;
    let i10 = e10[0].instances.find((i11) => {
      var s11;
      return i11.base == t107 && (s11 = i11.modified, e10.length == s11.length && e10.every((t108, e11) => t108 == s11[e11]));
    });
    if (i10) return i10;
    let s10 = [], n10 = new p8(s10, t107, e10);
    for (let t108 of e10) t108.instances.push(n10);
    let o10 = function(t108) {
      let e11 = [[]];
      for (let i11 = 0; i11 < t108.length; i11++) for (let s11 = 0, n11 = e11.length; s11 < n11; s11++) e11.push(e11[s11].concat(t108[i11]));
      return e11.sort((t109, e12) => e12.length - t109.length);
    }(e10);
    for (let e11 of t107.set) if (!e11.modified.length) for (let t108 of o10) s10.push(p4.get(e11, t108));
    return n10;
  }
}
function p9(t107) {
  let e10 = /* @__PURE__ */ Object.create(null);
  for (let i10 in t107) {
    let s10 = t107[i10];
    for (let t108 of (Array.isArray(s10) || (s10 = [s10]), i10.split(" "))) if (t108) {
      let i11 = [], n10 = 2, o10 = t108;
      for (let e11 = 0; ; ) {
        if ("..." == o10 && e11 > 0 && e11 + 3 == t108.length) {
          n10 = 1;
          break;
        }
        let s11 = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(o10);
        if (!s11) throw RangeError("Invalid path: " + t108);
        if (i11.push("*" == s11[0] ? "" : '"' == s11[0][0] ? JSON.parse(s11[0]) : s11[0]), (e11 += s11[0].length) == t108.length) break;
        let r11 = t108[e11++];
        if (e11 == t108.length && "!" == r11) {
          n10 = 0;
          break;
        }
        if ("/" != r11) throw RangeError("Invalid path: " + t108);
        o10 = t108.slice(e11);
      }
      let r10 = i11.length - 1, l10 = i11[r10];
      if (!l10) throw RangeError("Invalid path: " + t108);
      let h10 = new p6(s10, n10, r10 > 0 ? i11.slice(0, r10) : null);
      e10[l10] = h10.sort(e10[l10]);
    }
  }
  return p5.add(e10);
}
let p5 = new uw();
class p6 {
  constructor(t107, e10, i10, s10) {
    this.tags = t107, this.mode = e10, this.context = i10, this.next = s10;
  }
  get opaque() {
    return 0 == this.mode;
  }
  get inherit() {
    return 1 == this.mode;
  }
  sort(t107) {
    return !t107 || t107.depth < this.depth ? (this.next = t107, this) : (t107.next = this.sort(t107.next), t107);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
function p7(t107, e10) {
  let i10 = /* @__PURE__ */ Object.create(null);
  for (let e11 of t107) if (Array.isArray(e11.tag)) for (let t108 of e11.tag) i10[t108.id] = e11.class;
  else i10[e11.tag.id] = e11.class;
  let { scope: s10, all: n10 = null } = e10 || {};
  return { style: (t108) => {
    let e11 = n10;
    for (let s11 of t108) for (let t109 of s11.set) {
      let s12 = i10[t109.id];
      if (s12) {
        e11 = e11 ? e11 + " " + s12 : s12;
        break;
      }
    }
    return e11;
  }, scope: s10 };
}
p6.empty = new p6([], 2, null);
class mt {
  constructor(t107, e10, i10) {
    this.at = t107, this.highlighters = e10, this.span = i10, this.class = "";
  }
  startSpan(t107, e10) {
    e10 != this.class && (this.flush(t107), t107 > this.at && (this.at = t107), this.class = e10);
  }
  flush(t107) {
    t107 > this.at && this.class && this.span(this.at, t107, this.class);
  }
  highlightRange(t107, e10, i10, s10, n10) {
    let { type: o10, from: r10, to: l10 } = t107;
    if (r10 >= i10 || l10 <= e10) return;
    o10.isTop && (n10 = this.highlighters.filter((t108) => !t108.scope || t108.scope(o10)));
    let h10 = s10, a10 = function(t108) {
      let e11 = t108.type.prop(p5);
      for (; e11 && e11.context && !t108.matchContext(e11.context); ) e11 = e11.next;
      return e11 || null;
    }(t107) || p6.empty, c10 = function(t108, e11) {
      let i11 = null;
      for (let s11 of t108) {
        let t109 = s11.style(e11);
        t109 && (i11 = i11 ? i11 + " " + t109 : t109);
      }
      return i11;
    }(n10, a10.tags);
    if (c10 && (h10 && (h10 += " "), h10 += c10, 1 == a10.mode && (s10 += (s10 ? " " : "") + c10)), this.startSpan(Math.max(e10, r10), h10), a10.opaque) return;
    let d10 = t107.tree && t107.tree.prop(uw.mounted);
    if (d10 && d10.overlay) {
      let o11 = t107.node.enter(d10.overlay[0].from + r10, 1), a11 = this.highlighters.filter((t108) => !t108.scope || t108.scope(d10.tree.type)), c11 = t107.firstChild();
      for (let u10 = 0, f10 = r10; ; u10++) {
        let g10 = u10 < d10.overlay.length ? d10.overlay[u10] : null, p10 = g10 ? g10.from + r10 : l10, m10 = Math.max(e10, f10), v10 = Math.min(i10, p10);
        if (m10 < v10 && c11) for (; t107.from < v10 && (this.highlightRange(t107, m10, v10, s10, n10), this.startSpan(Math.min(v10, t107.to), h10), !(t107.to >= p10) && t107.nextSibling()); ) ;
        if (!g10 || p10 > i10) break;
        (f10 = g10.to + r10) > e10 && (this.highlightRange(o11.cursor(), Math.max(e10, g10.from + r10), Math.min(i10, f10), "", a11), this.startSpan(Math.min(i10, f10), h10));
      }
      c11 && t107.parent();
    } else if (t107.firstChild()) {
      d10 && (s10 = "");
      do {
        if (t107.to <= e10) continue;
        if (t107.from >= i10) break;
        this.highlightRange(t107, e10, i10, s10, n10), this.startSpan(Math.min(i10, t107.to), h10);
      } while (t107.nextSibling());
      t107.parent();
    }
  }
}
let me = p8.define, mi = me(), ms = me(), mn = me(ms), mo = me(ms), mr = me(), ml = me(mr), mh = me(mr), ma = me(), mc = me(ma), md = me(), mu = me(), mf = me(), mg = me(mf), mp = me(), mm = { comment: mi, lineComment: me(mi), blockComment: me(mi), docComment: me(mi), name: ms, variableName: me(ms), typeName: mn, tagName: me(mn), propertyName: mo, attributeName: me(mo), className: me(ms), labelName: me(ms), namespace: me(ms), macroName: me(ms), literal: mr, string: ml, docString: me(ml), character: me(ml), attributeValue: me(ml), number: mh, integer: me(mh), float: me(mh), bool: me(mr), regexp: me(mr), escape: me(mr), color: me(mr), url: me(mr), keyword: md, self: me(md), null: me(md), atom: me(md), unit: me(md), modifier: me(md), operatorKeyword: me(md), controlKeyword: me(md), definitionKeyword: me(md), moduleKeyword: me(md), operator: mu, derefOperator: me(mu), arithmeticOperator: me(mu), logicOperator: me(mu), bitwiseOperator: me(mu), compareOperator: me(mu), updateOperator: me(mu), definitionOperator: me(mu), typeOperator: me(mu), controlOperator: me(mu), punctuation: mf, separator: me(mf), bracket: mg, angleBracket: me(mg), squareBracket: me(mg), paren: me(mg), brace: me(mg), content: ma, heading: mc, heading1: me(mc), heading2: me(mc), heading3: me(mc), heading4: me(mc), heading5: me(mc), heading6: me(mc), contentSeparator: me(ma), list: me(ma), quote: me(ma), emphasis: me(ma), strong: me(ma), link: me(ma), monospace: me(ma), strikethrough: me(ma), inserted: me(), deleted: me(), changed: me(), invalid: me(), meta: mp, documentMeta: me(mp), annotation: me(mp), processingInstruction: me(mp), definition: p8.defineModifier(), constant: p8.defineModifier(), function: p8.defineModifier(), standard: p8.defineModifier(), local: p8.defineModifier(), special: p8.defineModifier() }, mv = p7([{ tag: mm.link, class: "tok-link" }, { tag: mm.heading, class: "tok-heading" }, { tag: mm.emphasis, class: "tok-emphasis" }, { tag: mm.strong, class: "tok-strong" }, { tag: mm.keyword, class: "tok-keyword" }, { tag: mm.atom, class: "tok-atom" }, { tag: mm.bool, class: "tok-bool" }, { tag: mm.url, class: "tok-url" }, { tag: mm.labelName, class: "tok-labelName" }, { tag: mm.inserted, class: "tok-inserted" }, { tag: mm.deleted, class: "tok-deleted" }, { tag: mm.literal, class: "tok-literal" }, { tag: mm.string, class: "tok-string" }, { tag: mm.number, class: "tok-number" }, { tag: [mm.regexp, mm.escape, mm.special(mm.string)], class: "tok-string2" }, { tag: mm.variableName, class: "tok-variableName" }, { tag: mm.local(mm.variableName), class: "tok-variableName tok-local" }, { tag: mm.definition(mm.variableName), class: "tok-variableName tok-definition" }, { tag: mm.special(mm.variableName), class: "tok-variableName2" }, { tag: mm.definition(mm.propertyName), class: "tok-propertyName tok-definition" }, { tag: mm.typeName, class: "tok-typeName" }, { tag: mm.namespace, class: "tok-namespace" }, { tag: mm.className, class: "tok-className" }, { tag: mm.macroName, class: "tok-macroName" }, { tag: mm.propertyName, class: "tok-propertyName" }, { tag: mm.operator, class: "tok-operator" }, { tag: mm.comment, class: "tok-comment" }, { tag: mm.meta, class: "tok-meta" }, { tag: mm.invalid, class: "tok-invalid" }, { tag: mm.punctuation, class: "tok-punctuation" }]), mw = new uw(), mb = new uw();
class my {
  constructor(t107, e10, i10 = [], s10 = "") {
    this.data = t107, this.name = s10, tW.prototype.hasOwnProperty("tree") || Object.defineProperty(tW.prototype, "tree", { get() {
      return mk(this);
    } }), this.parser = e10, this.extension = [mB.of(this), tW.languageData.of((t108, e11, i11) => {
      let s11 = mx(t108, e11, i11), n10 = s11.type.prop(mw);
      if (!n10) return [];
      let o10 = t108.facet(n10), r10 = s11.type.prop(mb);
      if (r10) {
        let n11 = s11.resolve(e11 - s11.from, i11);
        for (let e12 of r10) if (e12.test(n11, t108)) {
          let i12 = t108.facet(e12.facet);
          return "replace" == e12.type ? i12 : i12.concat(o10);
        }
      }
      return o10;
    })].concat(i10);
  }
  isActiveAt(t107, e10) {
    let i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -1;
    return mx(t107, e10, i10).type.prop(mw) == this.data;
  }
  findRegions(t107) {
    let e10 = t107.facet(mB);
    if ((null == e10 ? void 0 : e10.data) == this.data) return [{ from: 0, to: t107.doc.length }];
    if (!e10 || !e10.allowsNesting) return [];
    let i10 = [], s10 = (t108, e11) => {
      if (t108.prop(mw) == this.data) {
        i10.push({ from: e11, to: e11 + t108.length });
        return;
      }
      let n10 = t108.prop(uw.mounted);
      if (n10) {
        if (n10.tree.prop(mw) == this.data) {
          if (n10.overlay) for (let t109 of n10.overlay) i10.push({ from: t109.from + e11, to: t109.to + e11 });
          else i10.push({ from: e11, to: e11 + t108.length });
          return;
        }
        if (n10.overlay) {
          let t109 = i10.length;
          if (s10(n10.tree, n10.overlay[0].from + e11), i10.length > t109) return;
        }
      }
      for (let i11 = 0; i11 < t108.children.length; i11++) {
        let n11 = t108.children[i11];
        n11 instanceof uC && s10(n11, t108.positions[i11] + e11);
      }
    };
    return s10(mk(t107), 0), i10;
  }
  get allowsNesting() {
    return true;
  }
}
function mx(t107, e10, i10) {
  let s10 = t107.facet(mB), n10 = mk(t107).topNode;
  if (!s10 || s10.allowsNesting) for (let t108 = n10; t108; t108 = t108.enter(e10, i10, _.ExcludeBuffers)) t108.type.isTop && (n10 = t108);
  return n10;
}
my.setState = tR.define();
class mS extends my {
  constructor(t107, e10, i10) {
    super(t107, e10, [], i10), this.parser = e10;
  }
  static define(t107) {
    var e10;
    let i10 = (e10 = t107.languageData, to.define({ combine: e10 ? (t108) => t108.concat(e10) : void 0 }));
    return new mS(i10, t107.parser.configure({ props: [mw.add((t108) => t108.isTop ? i10 : void 0)] }), t107.name);
  }
  configure(t107, e10) {
    return new mS(this.data, this.parser.configure(t107), e10 || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function mk(t107) {
  let e10 = t107.field(my.state, false);
  return e10 ? e10.tree : uC.empty;
}
class mM {
  constructor(t107) {
    this.doc = t107, this.cursorPos = 0, this.string = "", this.cursor = t107.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(t107) {
    return this.string = this.cursor.next(t107 - this.cursorPos).value, this.cursorPos = t107 + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(t107) {
    return this.syncTo(t107), this.string;
  }
  get lineChunks() {
    return true;
  }
  read(t107, e10) {
    let i10 = this.cursorPos - this.string.length;
    return t107 < i10 || e10 >= this.cursorPos ? this.doc.sliceString(t107, e10) : this.string.slice(t107 - i10, e10 - i10);
  }
}
let mC = null;
class mA {
  constructor(t107, e10, i10 = [], s10, n10, o10, r10, l10) {
    this.parser = t107, this.state = e10, this.fragments = i10, this.tree = s10, this.treeLen = n10, this.viewport = o10, this.skipped = r10, this.scheduleOn = l10, this.parse = null, this.tempSkipped = [];
  }
  static create(t107, e10, i10) {
    return new mA(t107, e10, [], uC.empty, 0, i10, [], null);
  }
  startParse() {
    return this.parser.startParse(new mM(this.state.doc), this.fragments);
  }
  work(t107, e10) {
    return (null != e10 && e10 >= this.state.doc.length && (e10 = void 0), this.tree != uC.empty && this.isDone(null != e10 ? e10 : this.state.doc.length)) ? (this.takeTree(), true) : this.withContext(() => {
      var i10;
      if ("number" == typeof t107) {
        let e11 = Date.now() + t107;
        t107 = () => Date.now() > e11;
      }
      for (this.parse || (this.parse = this.startParse()), null != e10 && (null == this.parse.stoppedAt || this.parse.stoppedAt > e10) && e10 < this.state.doc.length && this.parse.stopAt(e10); ; ) {
        let s10 = this.parse.advance();
        if (s10) {
          if (this.fragments = this.withoutTempSkipped(uq.addTree(s10, this.fragments, null != this.parse.stoppedAt)), this.treeLen = null !== (i10 = this.parse.stoppedAt) && void 0 !== i10 ? i10 : this.state.doc.length, this.tree = s10, this.parse = null, !(this.treeLen < (null != e10 ? e10 : this.state.doc.length))) return true;
          this.parse = this.startParse();
        }
        if (t107()) return false;
      }
    });
  }
  takeTree() {
    let t107, e10;
    this.parse && (t107 = this.parse.parsedPos) >= this.treeLen && ((null == this.parse.stoppedAt || this.parse.stoppedAt > t107) && this.parse.stopAt(t107), this.withContext(() => {
      for (; !(e10 = this.parse.advance()); ) ;
    }), this.treeLen = t107, this.tree = e10, this.fragments = this.withoutTempSkipped(uq.addTree(this.tree, this.fragments, true)), this.parse = null);
  }
  withContext(t107) {
    let e10 = mC;
    mC = this;
    try {
      return t107();
    } finally {
      mC = e10;
    }
  }
  withoutTempSkipped(t107) {
    for (let e10; e10 = this.tempSkipped.pop(); ) t107 = mD(t107, e10.from, e10.to);
    return t107;
  }
  changes(t107, e10) {
    let { fragments: i10, tree: s10, treeLen: n10, viewport: o10, skipped: r10 } = this;
    if (this.takeTree(), !t107.empty) {
      let e11 = [];
      if (t107.iterChangedRanges((t108, i11, s11, n11) => e11.push({ fromA: t108, toA: i11, fromB: s11, toB: n11 })), i10 = uq.applyChanges(i10, e11), s10 = uC.empty, n10 = 0, o10 = { from: t107.mapPos(o10.from, -1), to: t107.mapPos(o10.to, 1) }, this.skipped.length) for (let e12 of (r10 = [], this.skipped)) {
        let i11 = t107.mapPos(e12.from, 1), s11 = t107.mapPos(e12.to, -1);
        i11 < s11 && r10.push({ from: i11, to: s11 });
      }
    }
    return new mA(this.parser, e10, i10, s10, n10, o10, r10, this.scheduleOn);
  }
  updateViewport(t107) {
    if (this.viewport.from == t107.from && this.viewport.to == t107.to) return false;
    this.viewport = t107;
    let e10 = this.skipped.length;
    for (let e11 = 0; e11 < this.skipped.length; e11++) {
      let { from: i10, to: s10 } = this.skipped[e11];
      i10 < t107.to && s10 > t107.from && (this.fragments = mD(this.fragments, i10, s10), this.skipped.splice(e11--, 1));
    }
    return !(this.skipped.length >= e10) && (this.reset(), true);
  }
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  skipUntilInView(t107, e10) {
    this.skipped.push({ from: t107, to: e10 });
  }
  static getSkippingParser(t107) {
    return new class extends u_ {
      createParse(e10, i10, s10) {
        let n10 = s10[0].from, o10 = s10[s10.length - 1].to;
        return { parsedPos: n10, advance() {
          let e11 = mC;
          if (e11) {
            for (let t108 of s10) e11.tempSkipped.push(t108);
            t107 && (e11.scheduleOn = e11.scheduleOn ? Promise.all([e11.scheduleOn, t107]) : t107);
          }
          return this.parsedPos = o10, new uC(ux.none, [], [], o10 - n10);
        }, stoppedAt: null, stopAt() {
        } };
      }
    }();
  }
  isDone(t107) {
    t107 = Math.min(t107, this.state.doc.length);
    let e10 = this.fragments;
    return this.treeLen >= t107 && e10.length && 0 == e10[0].from && e10[0].to >= t107;
  }
  static get() {
    return mC;
  }
}
function mD(t107, e10, i10) {
  return uq.applyChanges(t107, [{ fromA: e10, toA: i10, fromB: e10, toB: i10 }]);
}
class mO {
  constructor(t107) {
    this.context = t107, this.tree = t107.tree;
  }
  apply(t107) {
    if (!t107.docChanged && this.tree == this.context.tree) return this;
    let e10 = this.context.changes(t107.changes, t107.state), i10 = this.context.treeLen == t107.startState.doc.length ? void 0 : Math.max(t107.changes.mapPos(this.context.treeLen), e10.viewport.to);
    return e10.work(20, i10) || e10.takeTree(), new mO(e10);
  }
  static init(t107) {
    let e10 = Math.min(3e3, t107.doc.length), i10 = mA.create(t107.facet(mB).parser, t107, { from: 0, to: e10 });
    return i10.work(20, e10) || i10.takeTree(), new mO(i10);
  }
}
my.state = td.define({ create: mO.init, update(t107, e10) {
  for (let t108 of e10.effects) if (t108.is(my.setState)) return t108.value;
  return e10.startState.facet(mB) != e10.state.facet(mB) ? mO.init(e10.state) : t107.apply(e10);
} });
let mT = (t107) => {
  let e10 = setTimeout(() => t107(), 500);
  return () => clearTimeout(e10);
};
"undefined" != typeof requestIdleCallback && (mT = (t107) => {
  let e10 = -1, i10 = setTimeout(() => {
    e10 = requestIdleCallback(t107, { timeout: 400 });
  }, 100);
  return () => e10 < 0 ? clearTimeout(i10) : cancelIdleCallback(e10);
});
let mE = "undefined" != typeof navigator && (null === (G = navigator.scheduling) || void 0 === G ? void 0 : G.isInputPending) ? () => navigator.scheduling.isInputPending() : null, mR = gc.fromClass(class {
  constructor(t107) {
    this.view = t107, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(t107) {
    let e10 = this.view.state.field(my.state).context;
    (e10.updateViewport(t107.view.viewport) || this.view.viewport.to > e10.treeLen) && this.scheduleWork(), (t107.docChanged || t107.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(e10);
  }
  scheduleWork() {
    if (this.working) return;
    let { state: t107 } = this.view, e10 = t107.field(my.state);
    e10.tree == e10.context.tree && e10.context.isDone(t107.doc.length) || (this.working = mT(this.work));
  }
  work(t107) {
    this.working = null;
    let e10 = Date.now();
    if (this.chunkEnd < e10 && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = e10 + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0) return;
    let { state: i10, viewport: { to: s10 } } = this.view, n10 = i10.field(my.state);
    if (n10.tree == n10.context.tree && n10.context.isDone(s10 + 1e5)) return;
    let o10 = Date.now() + Math.min(this.chunkBudget, 100, t107 && !mE ? Math.max(25, t107.timeRemaining() - 5) : 1e9), r10 = n10.context.treeLen < s10 && i10.doc.length > s10 + 1e3, l10 = n10.context.work(() => mE && mE() || Date.now() > o10, s10 + (r10 ? 0 : 1e5));
    this.chunkBudget -= Date.now() - e10, (l10 || this.chunkBudget <= 0) && (n10.context.takeTree(), this.view.dispatch({ effects: my.setState.of(new mO(n10.context)) })), this.chunkBudget > 0 && !(l10 && !r10) && this.scheduleWork(), this.checkAsyncSchedule(n10.context);
  }
  checkAsyncSchedule(t107) {
    t107.scheduleOn && (this.workScheduled++, t107.scheduleOn.then(() => this.scheduleWork()).catch((t108) => gr(this.view.state, t108)).then(() => this.workScheduled--), t107.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, { eventHandlers: { focus() {
  this.scheduleWork();
} } }), mB = to.define({ combine: (t107) => t107.length ? t107[0] : null, enables: (t107) => [my.state, mR, pF.contentAttributes.compute([t107], (e10) => {
  let i10 = e10.facet(t107);
  return i10 && i10.name ? { "data-language": i10.name } : {};
})] });
class mL {
  constructor(t107, e10 = []) {
    this.language = t107, this.support = e10, this.extension = [t107, e10];
  }
}
let mP = to.define(), mN = to.define({ combine: (t107) => {
  if (!t107.length) return "  ";
  let e10 = t107[0];
  if (!e10 || /\S/.test(e10) || Array.from(e10).some((t108) => t108 != e10[0])) throw Error("Invalid indent unit: " + JSON.stringify(t107[0]));
  return e10;
} });
function mV(t107) {
  let e10 = t107.facet(mN);
  return 9 == e10.charCodeAt(0) ? t107.tabSize * e10.length : e10.length;
}
function mH(t107, e10) {
  let i10 = "", s10 = t107.tabSize, n10 = t107.facet(mN)[0];
  if ("	" == n10) {
    for (; e10 >= s10; ) i10 += "	", e10 -= s10;
    n10 = " ";
  }
  for (let t108 = 0; t108 < e10; t108++) i10 += n10;
  return i10;
}
function mF(t107, e10) {
  for (let i11 of (t107 instanceof tW && (t107 = new mW(t107)), t107.state.facet(mP))) {
    let s10 = i11(t107, e10);
    if (void 0 !== s10) return s10;
  }
  let i10 = mk(t107.state);
  return i10.length >= e10 ? function(t108, e11, i11) {
    let s10 = e11.resolveStack(i11), n10 = s10.node.enterUnfinishedNodesBefore(i11);
    if (n10 != s10.node) {
      let t109 = [];
      for (let e12 = n10; e12 != s10.node; e12 = e12.parent) t109.push(e12);
      for (let e12 = t109.length - 1; e12 >= 0; e12--) s10 = { node: t109[e12], next: s10 };
    }
    return mz(s10, t108, i11);
  }(t107, i10, e10) : null;
}
class mW {
  constructor(t107, e10 = {}) {
    this.state = t107, this.options = e10, this.unit = mV(t107);
  }
  lineAt(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, i10 = this.state.doc.lineAt(t107), { simulateBreak: s10, simulateDoubleBreak: n10 } = this.options;
    return null != s10 && s10 >= i10.from && s10 <= i10.to ? n10 && s10 == t107 ? { text: "", from: t107 } : (e10 < 0 ? s10 < t107 : s10 <= t107) ? { text: i10.text.slice(s10 - i10.from), from: s10 } : { text: i10.text.slice(0, s10 - i10.from), from: i10.from } : i10;
  }
  textAfterPos(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
    if (this.options.simulateDoubleBreak && t107 == this.options.simulateBreak) return "";
    let { text: i10, from: s10 } = this.lineAt(t107, e10);
    return i10.slice(t107 - s10, Math.min(i10.length, t107 + 100 - s10));
  }
  column(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, { text: i10, from: s10 } = this.lineAt(t107, e10), n10 = this.countColumn(i10, t107 - s10), o10 = this.options.overrideIndentation ? this.options.overrideIndentation(s10) : -1;
    return o10 > -1 && (n10 += o10 - this.countColumn(i10, i10.search(/\S|$/))), n10;
  }
  countColumn(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t107.length;
    return t8(t107, this.state.tabSize, e10);
  }
  lineIndent(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, { text: i10, from: s10 } = this.lineAt(t107, e10), n10 = this.options.overrideIndentation;
    if (n10) {
      let t108 = n10(s10);
      if (t108 > -1) return t108;
    }
    return this.countColumn(i10, i10.search(/\S|$/));
  }
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
let mI = new uw();
function mz(t107, e10, i10) {
  for (let s10 = t107; s10; s10 = s10.next) {
    let t108 = function(t109) {
      let e11 = t109.type.prop(mI);
      if (e11) return e11;
      let i11 = t109.firstChild, s11;
      if (i11 && (s11 = i11.type.prop(uw.closedBy))) {
        let e12 = t109.lastChild, i12 = e12 && s11.indexOf(e12.name) > -1;
        return (t110) => function(t111, e13, i13, s12, n10) {
          let o10 = t111.textAfter.match(/^\s*/)[0].length, r10 = n10 == t111.pos + o10, l10 = function(t112) {
            let e14 = t112.node, i14 = e14.childAfter(e14.from), s13 = e14.lastChild;
            if (!i14) return null;
            let n11 = t112.options.simulateBreak, o11 = t112.state.doc.lineAt(i14.from), r11 = null == n11 || n11 <= o11.from ? o11.to : Math.min(o11.to, n11);
            for (let t113 = i14.to; ; ) {
              let n12 = e14.childAfter(t113);
              if (!n12 || n12 == s13) return null;
              if (!n12.type.isSkipped) return n12.from < r11 ? i14 : null;
              t113 = n12.to;
            }
          }(t111);
          return l10 ? r10 ? t111.column(l10.from) : t111.column(l10.to) : t111.baseIndent + (r10 ? 0 : 1 * t111.unit);
        }(t110, 0, 0, 0, i12 && !(t110.pos == t110.options.simulateBreak && t110.options.simulateDoubleBreak) ? e12.from : void 0);
      }
      return null == t109.parent ? mK : null;
    }(s10.node);
    if (t108) return t108(mq.create(e10, i10, s10));
  }
  return 0;
}
function mK() {
  return 0;
}
class mq extends mW {
  constructor(t107, e10, i10) {
    super(t107.state, t107.options), this.base = t107, this.pos = e10, this.context = i10;
  }
  get node() {
    return this.context.node;
  }
  static create(t107, e10, i10) {
    return new mq(t107, e10, i10);
  }
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  baseIndentFor(t107) {
    let e10 = this.state.doc.lineAt(t107.from);
    for (; ; ) {
      let i10 = t107.resolve(e10.from);
      for (; i10.parent && i10.parent.from == i10.from; ) i10 = i10.parent;
      if (function(t108, e11) {
        for (let i11 = e11; i11; i11 = i11.parent) if (t108 == i11) return true;
        return false;
      }(i10, t107)) break;
      e10 = this.state.doc.lineAt(i10.from);
    }
    return this.lineIndent(e10.from);
  }
  continue() {
    return mz(this.context.next, this.base, this.pos);
  }
}
function m_() {
  let { except: t107, units: e10 = 1 } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
  return (i10) => {
    let s10 = t107 && t107.test(i10.textAfter);
    return i10.baseIndent + (s10 ? 0 : e10 * i10.unit);
  };
}
let mG = to.define(), mj = new uw();
function mU(t107) {
  let e10 = t107.firstChild, i10 = t107.lastChild;
  return e10 && e10.to < i10.from ? { from: e10.to, to: i10.type.isError ? t107.to : i10.from } : null;
}
function mY(t107, e10, i10) {
  for (let s10 of t107.facet(mG)) {
    let n10 = s10(t107, e10, i10);
    if (n10) return n10;
  }
  return function(t108, e11, i11) {
    let s10 = mk(t108);
    if (s10.length < i11) return null;
    let n10 = s10.resolveStack(i11, 1), o10 = null;
    for (let r10 = n10; r10; r10 = r10.next) {
      let n11 = r10.node;
      if (n11.to <= i11 || n11.from > i11) continue;
      if (o10 && n11.from < e11) break;
      let l10 = n11.type.prop(mj);
      if (l10 && (n11.to < s10.length - 50 || s10.length == t108.doc.length || !function(t109) {
        let e12 = t109.lastChild;
        return e12 && e12.to == t109.to && e12.type.isError;
      }(n11))) {
        let s11 = l10(n11, t108);
        s11 && s11.from <= i11 && s11.from >= e11 && s11.to > i11 && (o10 = s11);
      }
    }
    return o10;
  }(t107, e10, i10);
}
function m$(t107, e10) {
  let i10 = e10.mapPos(t107.from, 1), s10 = e10.mapPos(t107.to, -1);
  return i10 >= s10 ? void 0 : { from: i10, to: s10 };
}
let mX = tR.define({ map: m$ }), mJ = tR.define({ map: m$ });
function mQ(t107) {
  let e10 = [];
  for (let { head: i10 } of t107.state.selection.ranges) e10.some((t108) => t108.from <= i10 && t108.to >= i10) || e10.push(t107.lineBlockAt(i10));
  return e10;
}
let mZ = td.define({ create: () => fN.none, update(t107, e10) {
  for (let i10 of (t107 = t107.map(e10.changes), e10.effects)) if (i10.is(mX) && !function(t108, e11, i11) {
    let s10 = false;
    return t108.between(e11, e11, (t109, n10) => {
      t109 == e11 && n10 == i11 && (s10 = true);
    }), s10;
  }(t107, i10.value.from, i10.value.to)) {
    let { preparePlaceholder: s10 } = e10.state.facet(m4), n10 = s10 ? fN.replace({ widget: new m6(s10(e10.state, i10.value)) }) : m5;
    t107 = t107.update({ add: [n10.range(i10.value.from, i10.value.to)] });
  } else i10.is(mJ) && (t107 = t107.update({ filter: (t108, e11) => i10.value.from != t108 || i10.value.to != e11, filterFrom: i10.value.from, filterTo: i10.value.to }));
  if (e10.selection) {
    let i10 = false, { head: s10 } = e10.selection.main;
    t107.between(s10, s10, (t108, e11) => {
      t108 < s10 && e11 > s10 && (i10 = true);
    }), i10 && (t107 = t107.update({ filterFrom: s10, filterTo: s10, filter: (t108, e11) => e11 <= s10 || t108 >= s10 }));
  }
  return t107;
}, provide: (t107) => pF.decorations.from(t107), toJSON(t107, e10) {
  let i10 = [];
  return t107.between(0, e10.doc.length, (t108, e11) => {
    i10.push(t108, e11);
  }), i10;
}, fromJSON(t107) {
  if (!Array.isArray(t107) || t107.length % 2) throw RangeError("Invalid JSON for fold state");
  let e10 = [];
  for (let i10 = 0; i10 < t107.length; ) {
    let s10 = t107[i10++], n10 = t107[i10++];
    if ("number" != typeof s10 || "number" != typeof n10) throw RangeError("Invalid JSON for fold state");
    e10.push(m5.range(s10, n10));
  }
  return fN.set(e10, true);
} });
function m0(t107, e10, i10) {
  var s10;
  let n10 = null;
  return null === (s10 = t107.field(mZ, false)) || void 0 === s10 || s10.between(e10, i10, (t108, e11) => {
    (!n10 || n10.from > t108) && (n10 = { from: t108, to: e11 });
  }), n10;
}
function m1(t107, e10) {
  return t107.field(mZ, false) ? e10 : e10.concat(tR.appendConfig.of([mZ, vi]));
}
function m2(t107, e10) {
  let i10 = !(arguments.length > 2) || void 0 === arguments[2] || arguments[2], s10 = t107.state.doc.lineAt(e10.from).number, n10 = t107.state.doc.lineAt(e10.to).number;
  return pF.announce.of(`${t107.state.phrase(i10 ? "Folded lines" : "Unfolded lines")} ${s10} ${t107.state.phrase("to")} ${n10}.`);
}
let m8 = [{ key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: (t107) => {
  for (let e10 of mQ(t107)) {
    let i10 = mY(t107.state, e10.from, e10.to);
    if (i10) return t107.dispatch({ effects: m1(t107.state, [mX.of(i10), m2(t107, i10)]) }), true;
  }
  return false;
} }, { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: (t107) => {
  if (!t107.state.field(mZ, false)) return false;
  let e10 = [];
  for (let i10 of mQ(t107)) {
    let s10 = m0(t107.state, i10.from, i10.to);
    s10 && e10.push(mJ.of(s10), m2(t107, s10, false));
  }
  return e10.length && t107.dispatch({ effects: e10 }), e10.length > 0;
} }, { key: "Ctrl-Alt-[", run: (t107) => {
  let { state: e10 } = t107, i10 = [];
  for (let s10 = 0; s10 < e10.doc.length; ) {
    let n10 = t107.lineBlockAt(s10), o10 = mY(e10, n10.from, n10.to);
    o10 && i10.push(mX.of(o10)), s10 = (o10 ? t107.lineBlockAt(o10.to) : n10).to + 1;
  }
  return i10.length && t107.dispatch({ effects: m1(t107.state, i10) }), !!i10.length;
} }, { key: "Ctrl-Alt-]", run: (t107) => {
  let e10 = t107.state.field(mZ, false);
  if (!e10 || !e10.size) return false;
  let i10 = [];
  return e10.between(0, t107.state.doc.length, (t108, e11) => {
    i10.push(mJ.of({ from: t108, to: e11 }));
  }), t107.dispatch({ effects: i10 }), true;
} }], m3 = { placeholderDOM: null, preparePlaceholder: null, placeholderText: "" }, m4 = to.define({ combine: (t107) => tI(t107, m3) });
function m9(t107, e10) {
  let { state: i10 } = t107, s10 = i10.facet(m4), n10 = (e11) => {
    let i11 = t107.lineBlockAt(t107.posAtDOM(e11.target)), s11 = m0(t107.state, i11.from, i11.to);
    s11 && t107.dispatch({ effects: mJ.of(s11) }), e11.preventDefault();
  };
  if (s10.placeholderDOM) return s10.placeholderDOM(t107, n10, e10);
  let o10 = document.createElement("span");
  return o10.textContent = s10.placeholderText, o10.setAttribute("aria-label", i10.phrase("folded code")), o10.title = i10.phrase("unfold"), o10.className = "cm-foldPlaceholder", o10.onclick = n10, o10;
}
let m5 = fN.replace({ widget: new class extends fL {
  toDOM(t107) {
    return m9(t107, null);
  }
}() });
class m6 extends fL {
  constructor(t107) {
    super(), this.value = t107;
  }
  eq(t107) {
    return this.value == t107.value;
  }
  toDOM(t107) {
    return m9(t107, this.value);
  }
}
let m7 = { openText: "", closedText: "", markerDOM: null, domEventHandlers: {}, foldingChanged: () => false };
class vt extends pG {
  constructor(t107, e10) {
    super(), this.config = t107, this.open = e10;
  }
  eq(t107) {
    return this.config == t107.config && this.open == t107.open;
  }
  toDOM(t107) {
    if (this.config.markerDOM) return this.config.markerDOM(this.open);
    let e10 = document.createElement("span");
    return e10.textContent = this.open ? this.config.openText : this.config.closedText, e10.title = t107.state.phrase(this.open ? "Fold line" : "Unfold line"), e10;
  }
}
function ve() {
  var t107;
  let e10 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, i10 = Object.assign(Object.assign({}, m7), e10), s10 = new vt(i10, true), n10 = new vt(i10, false), o10 = gc.fromClass(class {
    constructor(t108) {
      this.from = t108.viewport.from, this.markers = this.buildMarkers(t108);
    }
    update(t108) {
      (t108.docChanged || t108.viewportChanged || t108.startState.facet(mB) != t108.state.facet(mB) || t108.startState.field(mZ, false) != t108.state.field(mZ, false) || mk(t108.startState) != mk(t108.state) || i10.foldingChanged(t108)) && (this.markers = this.buildMarkers(t108.view));
    }
    buildMarkers(t108) {
      let e11 = new tj();
      for (let i11 of t108.viewportLineBlocks) {
        let o11 = m0(t108.state, i11.from, i11.to) ? n10 : mY(t108.state, i11.from, i11.to) ? s10 : null;
        o11 && e11.add(i11.from, i11.from, o11);
      }
      return e11.finish();
    }
  }), { domEventHandlers: r10 } = i10;
  return [o10, (t107 = { class: "cm-foldGutter", markers(t108) {
    var e11;
    return (null === (e11 = t108.plugin(o10)) || void 0 === e11 ? void 0 : e11.markers) || tG.empty;
  }, initialSpacer: () => new vt(i10, false), domEventHandlers: Object.assign(Object.assign({}, r10), { click: (t108, e11, i11) => {
    if (r10.click && r10.click(t108, e11, i11)) return true;
    let s11 = m0(t108.state, e11.from, e11.to);
    if (s11) return t108.dispatch({ effects: mJ.of(s11) }), true;
    let n11 = mY(t108.state, e11.from, e11.to);
    return !!n11 && (t108.dispatch({ effects: mX.of(n11) }), true);
  } }) }, [[pX], pY.of(Object.assign(Object.assign({}, pU), t107))]), [mZ, vi]];
}
let vi = pF.baseTheme({ ".cm-foldPlaceholder": { backgroundColor: "#eee", border: "1px solid #ddd", color: "#888", borderRadius: ".2em", margin: "0 1px", padding: "0 1px", cursor: "pointer" }, ".cm-foldGutter span": { padding: "0 1px", cursor: "pointer" } });
class vs {
  constructor(t107, e10) {
    let i10;
    function s10(t108) {
      let e11 = t6.newName();
      return (i10 || (i10 = /* @__PURE__ */ Object.create(null)))["." + e11] = t108, e11;
    }
    this.specs = t107;
    let n10 = "string" == typeof e10.all ? e10.all : e10.all ? s10(e10.all) : void 0, o10 = e10.scope;
    this.scope = o10 instanceof my ? (t108) => t108.prop(mw) == o10.data : o10 ? (t108) => t108 == o10 : void 0, this.style = p7(t107.map((t108) => ({ tag: t108.tag, class: t108.class || s10(Object.assign({}, t108, { tag: null })) })), { all: n10 }).style, this.module = i10 ? new t6(i10) : null, this.themeType = e10.themeType;
  }
  static define(t107, e10) {
    return new vs(t107, e10 || {});
  }
}
let vn = to.define(), vo = to.define({ combine: (t107) => t107.length ? [t107[0]] : null });
function vr(t107) {
  let e10 = t107.facet(vn);
  return e10.length ? e10 : t107.facet(vo);
}
function vl(t107, e10) {
  let i10 = [vh], s10;
  return t107 instanceof vs && (t107.module && i10.push(pF.styleModule.of(t107.module)), s10 = t107.themeType), (null == e10 ? void 0 : e10.fallback) ? i10.push(vo.of(t107)) : s10 ? i10.push(vn.computeN([pF.darkTheme], (e11) => e11.facet(pF.darkTheme) == ("dark" == s10) ? [t107] : [])) : i10.push(vn.of(t107)), i10;
}
let vh = tg.high(gc.fromClass(class {
  constructor(t107) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = mk(t107.state), this.decorations = this.buildDeco(t107, vr(t107.state)), this.decoratedTo = t107.viewport.to;
  }
  update(t107) {
    let e10 = mk(t107.state), i10 = vr(t107.state), s10 = i10 != vr(t107.startState), { viewport: n10 } = t107.view, o10 = t107.changes.mapPos(this.decoratedTo, 1);
    e10.length < n10.to && !s10 && e10.type == this.tree.type && o10 >= n10.to ? (this.decorations = this.decorations.map(t107.changes), this.decoratedTo = o10) : (e10 != this.tree || t107.viewportChanged || s10) && (this.tree = e10, this.decorations = this.buildDeco(t107.view, i10), this.decoratedTo = n10.to);
  }
  buildDeco(t107, e10) {
    if (!e10 || !this.tree.length) return fN.none;
    let i10 = new tj();
    for (let { from: s10, to: n10 } of t107.visibleRanges) !function(t108, e11, i11) {
      let s11 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, n11 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : t108.length, o10 = new mt(s11, Array.isArray(e11) ? e11 : [e11], i11);
      o10.highlightRange(t108.cursor(), s11, n11, "", o10.highlighters), o10.flush(n11);
    }(this.tree, e10, (t108, e11, s11) => {
      i10.add(t108, e11, this.markCache[s11] || (this.markCache[s11] = fN.mark({ class: s11 })));
    }, s10, n10);
    return i10.finish();
  }
}, { decorations: (t107) => t107.decorations })), va = pF.baseTheme({ "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" }, "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" } }), vc = "()[]{}", vd = to.define({ combine: (t107) => tI(t107, { afterCursor: true, brackets: vc, maxScanDistance: 1e4, renderMatch: vg }) }), vu = fN.mark({ class: "cm-matchingBracket" }), vf = fN.mark({ class: "cm-nonmatchingBracket" });
function vg(t107) {
  let e10 = [], i10 = t107.matched ? vu : vf;
  return e10.push(i10.range(t107.start.from, t107.start.to)), t107.end && e10.push(i10.range(t107.end.from, t107.end.to)), e10;
}
let vp = [td.define({ create: () => fN.none, update(t107, e10) {
  if (!e10.docChanged && !e10.selection) return t107;
  let i10 = [], s10 = e10.state.facet(vd);
  for (let t108 of e10.state.selection.ranges) {
    if (!t108.empty) continue;
    let n10 = vy(e10.state, t108.head, -1, s10) || t108.head > 0 && vy(e10.state, t108.head - 1, 1, s10) || s10.afterCursor && (vy(e10.state, t108.head, 1, s10) || t108.head < e10.state.doc.length && vy(e10.state, t108.head + 1, -1, s10));
    n10 && (i10 = i10.concat(s10.renderMatch(n10, e10.state)));
  }
  return fN.set(i10, true);
}, provide: (t107) => pF.decorations.from(t107) }), va];
function vm() {
  let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
  return [vd.of(t107), vp];
}
let vv = new uw();
function vw(t107, e10, i10) {
  let s10 = t107.prop(e10 < 0 ? uw.openedBy : uw.closedBy);
  if (s10) return s10;
  if (1 == t107.name.length) {
    let s11 = i10.indexOf(t107.name);
    if (s11 > -1 && s11 % 2 == (e10 < 0 ? 1 : 0)) return [i10[s11 + e10]];
  }
  return null;
}
function vb(t107) {
  let e10 = t107.type.prop(vv);
  return e10 ? e10(t107.node) : t107;
}
function vy(t107, e10, i10) {
  let s10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, n10 = s10.maxScanDistance || 1e4, o10 = s10.brackets || vc, r10 = mk(t107), l10 = r10.resolveInner(e10, i10);
  for (let t108 = l10; t108; t108 = t108.parent) {
    let s11 = vw(t108.type, i10, o10);
    if (s11 && t108.from < t108.to) {
      let n11 = vb(t108);
      if (n11 && (i10 > 0 ? e10 >= n11.from && e10 < n11.to : e10 > n11.from && e10 <= n11.to)) return function(t109, e11, i11, s12, n12, o11, r11) {
        let l11 = s12.parent, h10 = { from: n12.from, to: n12.to }, a10 = 0, c10 = null == l11 ? void 0 : l11.cursor();
        if (c10 && (i11 < 0 ? c10.childBefore(s12.from) : c10.childAfter(s12.to))) do
          if (i11 < 0 ? c10.to <= s12.from : c10.from >= s12.to) {
            if (0 == a10 && o11.indexOf(c10.type.name) > -1 && c10.from < c10.to) {
              let t110 = vb(c10);
              return { start: h10, end: t110 ? { from: t110.from, to: t110.to } : void 0, matched: true };
            }
            if (vw(c10.type, i11, r11)) a10++;
            else if (vw(c10.type, -i11, r11)) {
              if (0 == a10) {
                let t110 = vb(c10);
                return { start: h10, end: t110 && t110.from < t110.to ? { from: t110.from, to: t110.to } : void 0, matched: false };
              }
              a10--;
            }
          }
        while (i11 < 0 ? c10.prevSibling() : c10.nextSibling());
        return { start: h10, matched: false };
      }(0, 0, i10, t108, n11, s11, o10);
    }
  }
  return function(t108, e11, i11, s11, n11, o11, r11) {
    let l11 = i11 < 0 ? t108.sliceDoc(e11 - 1, e11) : t108.sliceDoc(e11, e11 + 1), h10 = r11.indexOf(l11);
    if (h10 < 0 || h10 % 2 == 0 != i11 > 0) return null;
    let a10 = { from: i11 < 0 ? e11 - 1 : e11, to: i11 > 0 ? e11 + 1 : e11 }, c10 = t108.doc.iterRange(e11, i11 > 0 ? t108.doc.length : 0), d10 = 0;
    for (let t109 = 0; !c10.next().done && t109 <= o11; ) {
      let o12 = c10.value;
      i11 < 0 && (t109 += o12.length);
      let l12 = e11 + t109 * i11;
      for (let t110 = i11 > 0 ? 0 : o12.length - 1, e12 = i11 > 0 ? o12.length : -1; t110 != e12; t110 += i11) {
        let e13 = r11.indexOf(o12[t110]);
        if (!(e13 < 0) && s11.resolveInner(l12 + t110, 1).type == n11) {
          if (e13 % 2 == 0 == i11 > 0) d10++;
          else {
            if (1 == d10) return { start: a10, end: { from: l12 + t110, to: l12 + t110 + 1 }, matched: e13 >> 1 == h10 >> 1 };
            d10--;
          }
        }
      }
      i11 > 0 && (t109 += o12.length);
    }
    return c10.done ? { start: a10, matched: false } : null;
  }(t107, e10, i10, r10, l10.type, n10, o10);
}
let vx = /* @__PURE__ */ Object.create(null), vS = [ux.none], vk = [], vM = /* @__PURE__ */ Object.create(null), vC = /* @__PURE__ */ Object.create(null);
for (let [t107, e10] of [["variable", "variableName"], ["variable-2", "variableName.special"], ["string-2", "string.special"], ["def", "variableName.definition"], ["tag", "tagName"], ["attribute", "attributeName"], ["type", "typeName"], ["builtin", "variableName.standard"], ["qualifier", "modifier"], ["error", "invalid"], ["header", "heading"], ["property", "propertyName"]]) vC[t107] = function(t108, e11) {
  let i10 = [];
  for (let s11 of e11.split(" ")) {
    let e12 = [];
    for (let i11 of s11.split(".")) {
      let s12 = t108[i11] || mm[i11];
      s12 ? "function" == typeof s12 ? e12.length ? e12 = e12.map(s12) : vA(i11, `Modifier ${i11} used at start of tag`) : e12.length ? vA(i11, `Tag ${i11} used as modifier`) : e12 = Array.isArray(s12) ? s12 : [s12] : vA(i11, `Unknown highlighting tag ${i11}`);
    }
    for (let t109 of e12) i10.push(t109);
  }
  if (!i10.length) return 0;
  let s10 = e11.replace(/ /g, "_"), n10 = s10 + " " + i10.map((t109) => t109.id), o10 = vM[n10];
  if (o10) return o10.id;
  let r10 = vM[n10] = ux.define({ id: vS.length, name: s10, props: [p9({ [s10]: i10 })] });
  return vS.push(r10), r10.id;
}(vx, e10);
function vA(t107, e10) {
  vk.indexOf(t107) > -1 || (vk.push(t107), console.warn(e10));
}
f_.RTL, f_.LTR;
class vD {
  constructor(t107, e10, i10, s10) {
    this.state = t107, this.pos = e10, this.explicit = i10, this.view = s10, this.abortListeners = [];
  }
  tokenBefore(t107) {
    let e10 = mk(this.state).resolveInner(this.pos, -1);
    for (; e10 && 0 > t107.indexOf(e10.name); ) e10 = e10.parent;
    return e10 ? { from: e10.from, to: this.pos, text: this.state.sliceDoc(e10.from, this.pos), type: e10.type } : null;
  }
  matchBefore(t107) {
    let e10 = this.state.doc.lineAt(this.pos), i10 = Math.max(e10.from, this.pos - 250), s10 = e10.text.slice(i10 - e10.from, this.pos - e10.from), n10 = s10.search(vR(t107, false));
    return n10 < 0 ? null : { from: i10 + n10, to: this.pos, text: s10.slice(n10) };
  }
  get aborted() {
    return null == this.abortListeners;
  }
  addEventListener(t107, e10) {
    "abort" == t107 && this.abortListeners && this.abortListeners.push(e10);
  }
}
function vO(t107) {
  let e10 = Object.keys(t107).join(""), i10 = /\w/.test(e10);
  return i10 && (e10 = e10.replace(/\w/g, "")), `[${i10 ? "\\w" : ""}${e10.replace(/[^\w\s]/g, "\\$&")}]`;
}
class vT {
  constructor(t107, e10, i10, s10) {
    this.completion = t107, this.source = e10, this.match = i10, this.score = s10;
  }
}
function vE(t107) {
  return t107.selection.main.from;
}
function vR(t107, e10) {
  var i10;
  let { source: s10 } = t107, n10 = e10 && "^" != s10[0], o10 = "$" != s10[s10.length - 1];
  return n10 || o10 ? RegExp(`${n10 ? "^" : ""}(?:${s10})${o10 ? "$" : ""}`, null !== (i10 = t107.flags) && void 0 !== i10 ? i10 : t107.ignoreCase ? "i" : "") : t107;
}
let vB = tO.define(), vL = /* @__PURE__ */ new WeakMap();
function vP(t107) {
  if (!Array.isArray(t107)) return t107;
  let e10 = vL.get(t107);
  return e10 || vL.set(t107, e10 = function(t108) {
    let e11 = t108.map((t109) => "string" == typeof t109 ? { label: t109 } : t109), [i10, s10] = e11.every((t109) => /^\w+$/.test(t109.label)) ? [/\w*$/, /\w+$/] : function(t109) {
      let e12 = /* @__PURE__ */ Object.create(null), i11 = /* @__PURE__ */ Object.create(null);
      for (let { label: s12 } of t109) {
        e12[s12[0]] = true;
        for (let t110 = 1; t110 < s12.length; t110++) i11[s12[t110]] = true;
      }
      let s11 = vO(e12) + vO(i11) + "*$";
      return [RegExp("^" + s11), new RegExp(s11)];
    }(e11);
    return (t109) => {
      let n10 = t109.matchBefore(s10);
      return n10 || t109.explicit ? { from: n10 ? n10.from : t109.pos, options: e11, validFor: i10 } : null;
    };
  }(t107)), e10;
}
let vN = tR.define(), vV = tR.define();
class vH {
  constructor(t107) {
    this.pattern = t107, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let e10 = 0; e10 < t107.length; ) {
      let i10 = x(t107, e10), s10 = k(i10);
      this.chars.push(i10);
      let n10 = t107.slice(e10, e10 + s10), o10 = n10.toUpperCase();
      this.folded.push(x(o10 == n10 ? n10.toLowerCase() : o10, 0)), e10 += s10;
    }
    this.astral = t107.length != this.chars.length;
  }
  ret(t107, e10) {
    return this.score = t107, this.matched = e10, this;
  }
  match(t107) {
    if (0 == this.pattern.length) return this.ret(-100, []);
    if (t107.length < this.pattern.length) return null;
    let { chars: e10, folded: i10, any: s10, precise: n10, byWord: o10 } = this;
    if (1 == e10.length) {
      let s11 = x(t107, 0), n11 = k(s11), o11 = n11 == t107.length ? 0 : -100;
      if (s11 == e10[0]) ;
      else {
        if (s11 != i10[0]) return null;
        o11 += -200;
      }
      return this.ret(o11, [0, n11]);
    }
    let r10 = t107.indexOf(this.pattern);
    if (0 == r10) return this.ret(t107.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let l10 = e10.length, h10 = 0;
    if (r10 < 0) {
      for (let n11 = 0, o11 = Math.min(t107.length, 200); n11 < o11 && h10 < l10; ) {
        let o12 = x(t107, n11);
        (o12 == e10[h10] || o12 == i10[h10]) && (s10[h10++] = n11), n11 += k(o12);
      }
      if (h10 < l10) return null;
    }
    let a10 = 0, c10 = 0, d10 = false, u10 = 0, f10 = -1, g10 = -1, p10 = /[a-z]/.test(t107), m10 = true;
    for (let s11 = 0, h11 = Math.min(t107.length, 200), v10 = 0; s11 < h11 && c10 < l10; ) {
      let h12 = x(t107, s11);
      r10 < 0 && (a10 < l10 && h12 == e10[a10] && (n10[a10++] = s11), u10 < l10 && (h12 == e10[u10] || h12 == i10[u10] ? (0 == u10 && (f10 = s11), g10 = s11 + 1, u10++) : u10 = 0));
      let w10, b10 = h12 < 255 ? h12 >= 48 && h12 <= 57 || h12 >= 97 && h12 <= 122 ? 2 : h12 >= 65 && h12 <= 90 ? 1 : 0 : (w10 = S(h12)) != w10.toLowerCase() ? 1 : w10 != w10.toUpperCase() ? 2 : 0;
      (!s11 || 1 == b10 && p10 || 0 == v10 && 0 != b10) && (e10[c10] == h12 || i10[c10] == h12 && (d10 = true) ? o10[c10++] = s11 : o10.length && (m10 = false)), v10 = b10, s11 += k(h12);
    }
    return c10 == l10 && 0 == o10[0] && m10 ? this.result(-100 + (d10 ? -200 : 0), o10, t107) : u10 == l10 && 0 == f10 ? this.ret(-200 - t107.length + (g10 == t107.length ? 0 : -100), [0, g10]) : r10 > -1 ? this.ret(-700 - t107.length, [r10, r10 + this.pattern.length]) : u10 == l10 ? this.ret(-900 - t107.length, [f10, g10]) : c10 == l10 ? this.result(-100 + (d10 ? -200 : 0) + -700 + (m10 ? 0 : -1100), o10, t107) : 2 == e10.length ? null : this.result((s10[0] ? -700 : 0) + -200 + -1100, s10, t107);
  }
  result(t107, e10, i10) {
    let s10 = [], n10 = 0;
    for (let t108 of e10) {
      let e11 = t108 + (this.astral ? k(x(i10, t108)) : 1);
      n10 && s10[n10 - 1] == t108 ? s10[n10 - 1] = e11 : (s10[n10++] = t108, s10[n10++] = e11);
    }
    return this.ret(t107 - i10.length, s10);
  }
}
class vF {
  constructor(t107) {
    this.pattern = t107, this.matched = [], this.score = 0, this.folded = t107.toLowerCase();
  }
  match(t107) {
    if (t107.length < this.pattern.length) return null;
    let e10 = t107.slice(0, this.pattern.length), i10 = e10 == this.pattern ? 0 : e10.toLowerCase() == this.folded ? -200 : null;
    return null == i10 ? null : (this.matched = [0, e10.length], this.score = i10 + (t107.length == this.pattern.length ? 0 : -100), this);
  }
}
let vW = to.define({ combine: (t107) => tI(t107, { activateOnTyping: true, activateOnCompletion: () => false, activateOnTypingDelay: 100, selectOnOpen: true, override: null, closeOnBlur: true, maxRenderedOptions: 100, defaultKeymap: true, tooltipClass: () => "", optionClass: () => "", aboveCursor: false, icons: true, addToOptions: [], positionInfo: vz, filterStrict: false, compareCompletions: (t108, e10) => t108.label.localeCompare(e10.label), interactionDelay: 75, updateSyncTime: 100 }, { defaultKeymap: (t108, e10) => t108 && e10, closeOnBlur: (t108, e10) => t108 && e10, icons: (t108, e10) => t108 && e10, tooltipClass: (t108, e10) => (i10) => vI(t108(i10), e10(i10)), optionClass: (t108, e10) => (i10) => vI(t108(i10), e10(i10)), addToOptions: (t108, e10) => t108.concat(e10), filterStrict: (t108, e10) => t108 || e10 }) });
function vI(t107, e10) {
  return t107 ? e10 ? t107 + " " + e10 : t107 : e10;
}
function vz(t107, e10, i10, s10, n10, o10) {
  let r10 = t107.textDirection == a2.RTL, l10 = r10, h10 = false, a10 = "top", c10, d10, u10 = e10.left - n10.left, f10 = n10.right - e10.right, g10 = s10.right - s10.left, p10 = s10.bottom - s10.top;
  if (l10 && u10 < Math.min(g10, f10) ? l10 = false : !l10 && f10 < Math.min(g10, u10) && (l10 = true), g10 <= (l10 ? u10 : f10)) c10 = Math.max(n10.top, Math.min(i10.top, n10.bottom - p10)) - e10.top, d10 = Math.min(400, l10 ? u10 : f10);
  else {
    h10 = true, d10 = Math.min(400, (r10 ? e10.right : n10.right - e10.left) - 30);
    let t108 = n10.bottom - e10.bottom;
    t108 >= p10 || t108 > e10.top ? c10 = i10.bottom - e10.top : (a10 = "bottom", c10 = e10.bottom - i10.top);
  }
  let m10 = (e10.bottom - e10.top) / o10.offsetHeight, v10 = (e10.right - e10.left) / o10.offsetWidth;
  return { style: `${a10}: ${c10 / m10}px; max-width: ${d10 / v10}px`, class: "cm-completionInfo-" + (h10 ? r10 ? "left-narrow" : "right-narrow" : l10 ? "left" : "right") };
}
function vK(t107, e10, i10) {
  if (t107 <= i10) return { from: 0, to: t107 };
  if (e10 < 0 && (e10 = 0), e10 <= t107 >> 1) {
    let t108 = Math.floor(e10 / i10);
    return { from: t108 * i10, to: (t108 + 1) * i10 };
  }
  let s10 = Math.floor((t107 - e10) / i10);
  return { from: t107 - (s10 + 1) * i10, to: t107 - s10 * i10 };
}
class vq {
  constructor(t107, e10, i10) {
    let s10;
    this.view = t107, this.stateField = e10, this.applyCompletion = i10, this.info = null, this.infoDestroy = null, this.placeInfoReq = { read: () => this.measureInfo(), write: (t108) => this.placeInfo(t108), key: this }, this.space = null, this.currentClass = "";
    let n10 = t107.state.field(e10), { options: o10, selected: r10 } = n10.open, l10 = t107.state.facet(vW);
    this.optionContent = (s10 = l10.addToOptions.slice(), l10.icons && s10.push({ render(t108) {
      let e11 = document.createElement("div");
      return e11.classList.add("cm-completionIcon"), t108.type && e11.classList.add(...t108.type.split(/\s+/g).map((t109) => "cm-completionIcon-" + t109)), e11.setAttribute("aria-hidden", "true"), e11;
    }, position: 20 }), s10.push({ render(t108, e11, i11, s11) {
      let n11 = document.createElement("span");
      n11.className = "cm-completionLabel";
      let o11 = t108.displayLabel || t108.label, r11 = 0;
      for (let t109 = 0; t109 < s11.length; ) {
        let e12 = s11[t109++], i12 = s11[t109++];
        e12 > r11 && n11.appendChild(document.createTextNode(o11.slice(r11, e12)));
        let l11 = n11.appendChild(document.createElement("span"));
        l11.appendChild(document.createTextNode(o11.slice(e12, i12))), l11.className = "cm-completionMatchedText", r11 = i12;
      }
      return r11 < o11.length && n11.appendChild(document.createTextNode(o11.slice(r11))), n11;
    }, position: 50 }, { render(t108) {
      if (!t108.detail) return null;
      let e11 = document.createElement("span");
      return e11.className = "cm-completionDetail", e11.textContent = t108.detail, e11;
    }, position: 80 }), s10.sort((t108, e11) => t108.position - e11.position).map((t108) => t108.render)), this.optionClass = l10.optionClass, this.tooltipClass = l10.tooltipClass, this.range = vK(o10.length, r10, l10.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(t107.state), this.dom.addEventListener("mousedown", (i11) => {
      let { options: s11 } = t107.state.field(e10).open;
      for (let e11 = i11.target, n11; e11 && e11 != this.dom; e11 = e11.parentNode) if ("LI" == e11.nodeName && (n11 = /-(\d+)$/.exec(e11.id)) && +n11[1] < s11.length) {
        this.applyCompletion(t107, s11[+n11[1]]), i11.preventDefault();
        return;
      }
    }), this.dom.addEventListener("focusout", (e11) => {
      let i11 = t107.state.field(this.stateField, false);
      i11 && i11.tooltip && t107.state.facet(vW).closeOnBlur && e11.relatedTarget != t107.contentDOM && t107.dispatch({ effects: vV.of(null) });
    }), this.showOptions(o10, n10.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(t107, e10) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(t107, e10, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(t107) {
    var e10;
    let i10 = t107.state.field(this.stateField), s10 = t107.startState.field(this.stateField);
    if (this.updateTooltipClass(t107.state), i10 != s10) {
      let { options: n10, selected: o10, disabled: r10 } = i10.open;
      s10.open && s10.open.options == n10 || (this.range = vK(n10.length, o10, t107.state.facet(vW).maxRenderedOptions), this.showOptions(n10, i10.id)), this.updateSel(), r10 != (null === (e10 = s10.open) || void 0 === e10 ? void 0 : e10.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!r10);
    }
  }
  updateTooltipClass(t107) {
    let e10 = this.tooltipClass(t107);
    if (e10 != this.currentClass) {
      for (let t108 of this.currentClass.split(" ")) t108 && this.dom.classList.remove(t108);
      for (let t108 of e10.split(" ")) t108 && this.dom.classList.add(t108);
      this.currentClass = e10;
    }
  }
  positioned(t107) {
    this.space = t107, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let t107 = this.view.state.field(this.stateField), e10 = t107.open;
    if ((e10.selected > -1 && e10.selected < this.range.from || e10.selected >= this.range.to) && (this.range = vK(e10.options.length, e10.selected, this.view.state.facet(vW).maxRenderedOptions), this.showOptions(e10.options, t107.id)), this.updateSelectedOption(e10.selected)) {
      this.destroyInfo();
      let { completion: i10 } = e10.options[e10.selected], { info: s10 } = i10;
      if (!s10) return;
      let n10 = "string" == typeof s10 ? document.createTextNode(s10) : s10(i10);
      if (!n10) return;
      "then" in n10 ? n10.then((e11) => {
        e11 && this.view.state.field(this.stateField, false) == t107 && this.addInfoPane(e11, i10);
      }).catch((t108) => cb(this.view.state, t108, "completion info")) : this.addInfoPane(n10, i10);
    }
  }
  addInfoPane(t107, e10) {
    this.destroyInfo();
    let i10 = this.info = document.createElement("div");
    if (i10.className = "cm-tooltip cm-completionInfo", null != t107.nodeType) i10.appendChild(t107), this.infoDestroy = null;
    else {
      let { dom: e11, destroy: s10 } = t107;
      i10.appendChild(e11), this.infoDestroy = s10 || null;
    }
    this.dom.appendChild(i10), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(t107) {
    var e10, i10;
    let s10, n10, o10, r10 = null;
    for (let e11 = this.list.firstChild, i11 = this.range.from; e11; e11 = e11.nextSibling, i11++) "LI" == e11.nodeName && e11.id ? i11 == t107 ? e11.hasAttribute("aria-selected") || (e11.setAttribute("aria-selected", "true"), r10 = e11) : e11.hasAttribute("aria-selected") && e11.removeAttribute("aria-selected") : i11--;
    return r10 && (e10 = this.list, i10 = r10, s10 = e10.getBoundingClientRect(), n10 = i10.getBoundingClientRect(), o10 = s10.height / e10.offsetHeight, n10.top < s10.top ? e10.scrollTop -= (s10.top - n10.top) / o10 : n10.bottom > s10.bottom && (e10.scrollTop += (n10.bottom - s10.bottom) / o10)), r10;
  }
  measureInfo() {
    let t107 = this.dom.querySelector("[aria-selected]");
    if (!t107 || !this.info) return null;
    let e10 = this.dom.getBoundingClientRect(), i10 = this.info.getBoundingClientRect(), s10 = t107.getBoundingClientRect(), n10 = this.space;
    if (!n10) {
      let t108 = this.dom.ownerDocument.defaultView || window;
      n10 = { left: 0, top: 0, right: t108.innerWidth, bottom: t108.innerHeight };
    }
    return s10.top > Math.min(n10.bottom, e10.bottom) - 10 || s10.bottom < Math.max(n10.top, e10.top) + 10 ? null : this.view.state.facet(vW).positionInfo(this.view, e10, s10, i10, n10, this.dom);
  }
  placeInfo(t107) {
    this.info && (t107 ? (t107.style && (this.info.style.cssText = t107.style), this.info.className = "cm-tooltip cm-completionInfo " + (t107.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(t107, e10, i10) {
    let s10 = document.createElement("ul");
    s10.id = e10, s10.setAttribute("role", "listbox"), s10.setAttribute("aria-expanded", "true"), s10.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let n10 = null;
    for (let o10 = i10.from; o10 < i10.to; o10++) {
      let { completion: r10, match: l10 } = t107[o10], { section: h10 } = r10;
      if (h10) {
        let t108 = "string" == typeof h10 ? h10 : h10.name;
        t108 != n10 && (o10 > i10.from || 0 == i10.from) && (n10 = t108, "string" != typeof h10 && h10.header ? s10.appendChild(h10.header(h10)) : s10.appendChild(document.createElement("completion-section")).textContent = t108);
      }
      let a10 = s10.appendChild(document.createElement("li"));
      a10.id = e10 + "-" + o10, a10.setAttribute("role", "option");
      let c10 = this.optionClass(r10);
      for (let t108 of (c10 && (a10.className = c10), this.optionContent)) {
        let e11 = t108(r10, this.view.state, this.view, l10);
        e11 && a10.appendChild(e11);
      }
    }
    return i10.from && s10.classList.add("cm-completionListIncompleteTop"), i10.to < t107.length && s10.classList.add("cm-completionListIncompleteBottom"), s10;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function v_(t107) {
  return 100 * (t107.boost || 0) + (t107.apply ? 10 : 0) + (t107.info ? 5 : 0) + (t107.type ? 1 : 0);
}
class vG {
  constructor(t107, e10, i10, s10, n10, o10) {
    this.options = t107, this.attrs = e10, this.tooltip = i10, this.timestamp = s10, this.selected = n10, this.disabled = o10;
  }
  setSelected(t107, e10) {
    return t107 == this.selected || t107 >= this.options.length ? this : new vG(this.options, v$(e10, t107), this.tooltip, this.timestamp, t107, this.disabled);
  }
  static build(t107, e10, i10, s10, n10) {
    let o10 = function(t108, e11) {
      let i11 = [], s11 = null, n11 = (t109) => {
        i11.push(t109);
        let { section: e12 } = t109.completion;
        if (e12) {
          s11 || (s11 = []);
          let t110 = "string" == typeof e12 ? e12 : e12.name;
          s11.some((e13) => e13.name == t110) || s11.push("string" == typeof e12 ? { name: t110 } : e12);
        }
      }, o11 = e11.facet(vW);
      for (let s12 of t108) if (s12.hasResult()) {
        let t109 = s12.result.getMatch;
        if (false === s12.result.filter) for (let e12 of s12.result.options) n11(new vT(e12, s12.source, t109 ? t109(e12) : [], 1e9 - i11.length));
        else {
          let i12 = e11.sliceDoc(s12.from, s12.to), r12, l11 = o11.filterStrict ? new vF(i12) : new vH(i12);
          for (let e12 of s12.result.options) if (r12 = l11.match(e12.label)) {
            let i13 = e12.displayLabel ? t109 ? t109(e12, r12.matched) : [] : r12.matched;
            n11(new vT(e12, s12.source, i13, r12.score + (e12.boost || 0)));
          }
        }
      }
      if (s11) {
        let t109 = /* @__PURE__ */ Object.create(null), e12 = 0;
        for (let i12 of s11.sort((t110, e13) => {
          var i13, s12;
          return (null !== (i13 = t110.rank) && void 0 !== i13 ? i13 : 1e9) - (null !== (s12 = e13.rank) && void 0 !== s12 ? s12 : 1e9) || (t110.name < e13.name ? -1 : 1);
        })) e12 -= 1e5, t109[i12.name] = e12;
        for (let e13 of i11) {
          let { section: i12 } = e13.completion;
          i12 && (e13.score += t109["string" == typeof i12 ? i12 : i12.name]);
        }
      }
      let r11 = [], l10 = null, h10 = o11.compareCompletions;
      for (let t109 of i11.sort((t110, e12) => e12.score - t110.score || h10(t110.completion, e12.completion))) {
        let e12 = t109.completion;
        l10 && l10.label == e12.label && l10.detail == e12.detail && (null == l10.type || null == e12.type || l10.type == e12.type) && l10.apply == e12.apply && l10.boost == e12.boost ? v_(t109.completion) > v_(l10) && (r11[r11.length - 1] = t109) : r11.push(t109), l10 = t109.completion;
      }
      return r11;
    }(t107, e10);
    if (!o10.length) return s10 && t107.some((t108) => 1 == t108.state) ? new vG(s10.options, s10.attrs, s10.tooltip, s10.timestamp, s10.selected, true) : null;
    let r10 = e10.facet(vW).selectOnOpen ? 0 : -1;
    if (s10 && s10.selected != r10 && -1 != s10.selected) {
      let t108 = s10.options[s10.selected].completion;
      for (let e11 = 0; e11 < o10.length; e11++) if (o10[e11].completion == t108) {
        r10 = e11;
        break;
      }
    }
    return new vG(o10, v$(i10, r10), { pos: t107.reduce((t108, e11) => e11.hasResult() ? Math.min(t108, e11.from) : t108, 1e8), create: v3, above: n10.aboveCursor }, s10 ? s10.timestamp : Date.now(), r10, false);
  }
  map(t107) {
    return new vG(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: t107.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
}
class vj {
  constructor(t107, e10, i10) {
    this.active = t107, this.id = e10, this.open = i10;
  }
  static start() {
    return new vj(vX, "cm-ac-" + Math.floor(2e6 * Math.random()).toString(36), null);
  }
  update(t107) {
    let { state: e10 } = t107, i10 = e10.facet(vW), s10 = (i10.override || e10.languageDataAt("autocomplete", vE(e10)).map(vP)).map((e11) => (this.active.find((t108) => t108.source == e11) || new vQ(e11, this.active.some((t108) => 0 != t108.state) ? 1 : 0)).update(t107, i10));
    s10.length == this.active.length && s10.every((t108, e11) => t108 == this.active[e11]) && (s10 = this.active);
    let n10 = this.open;
    for (let o10 of (n10 && t107.docChanged && (n10 = n10.map(t107.changes)), t107.selection || s10.some((e11) => e11.hasResult() && t107.changes.touchesRange(e11.from, e11.to)) || !function(t108, e11) {
      if (t108 == e11) return true;
      for (let i11 = 0, s11 = 0; ; ) {
        for (; i11 < t108.length && !t108[i11].hasResult; ) i11++;
        for (; s11 < e11.length && !e11[s11].hasResult; ) s11++;
        let n11 = i11 == t108.length, o11 = s11 == e11.length;
        if (n11 || o11) return n11 == o11;
        if (t108[i11++].result != e11[s11++].result) return false;
      }
    }(s10, this.active) ? n10 = vG.build(s10, e10, this.id, n10, i10) : n10 && n10.disabled && !s10.some((t108) => 1 == t108.state) && (n10 = null), !n10 && s10.every((t108) => 1 != t108.state) && s10.some((t108) => t108.hasResult()) && (s10 = s10.map((t108) => t108.hasResult() ? new vQ(t108.source, 0) : t108)), t107.effects)) o10.is(v1) && (n10 = n10 && n10.setSelected(o10.value, this.id));
    return s10 == this.active && n10 == this.open ? this : new vj(s10, this.id, n10);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : this.active.length ? vU : vY;
  }
}
let vU = { "aria-autocomplete": "list" }, vY = {};
function v$(t107, e10) {
  let i10 = { "aria-autocomplete": "list", "aria-haspopup": "listbox", "aria-controls": t107 };
  return e10 > -1 && (i10["aria-activedescendant"] = t107 + "-" + e10), i10;
}
let vX = [];
function vJ(t107, e10) {
  if (t107.isUserEvent("input.complete")) {
    let i11 = t107.annotation(vB);
    if (i11 && e10.activateOnCompletion(i11)) return 12;
  }
  let i10 = t107.isUserEvent("input.type");
  return i10 && e10.activateOnTyping ? 5 : i10 ? 1 : t107.isUserEvent("delete.backward") ? 2 : t107.selection ? 8 : t107.docChanged ? 16 : 0;
}
class vQ {
  constructor(t107, e10, i10 = -1) {
    this.source = t107, this.state = e10, this.explicitPos = i10;
  }
  hasResult() {
    return false;
  }
  update(t107, e10) {
    let i10 = vJ(t107, e10), s10 = this;
    for (let e11 of ((8 & i10 || 16 & i10 && this.touches(t107)) && (s10 = new vQ(s10.source, 0)), 4 & i10 && 0 == s10.state && (s10 = new vQ(this.source, 1)), s10 = s10.updateFor(t107, i10), t107.effects)) if (e11.is(vN)) s10 = new vQ(s10.source, 1, e11.value ? vE(t107.state) : -1);
    else if (e11.is(vV)) s10 = new vQ(s10.source, 0);
    else if (e11.is(v0)) for (let t108 of e11.value) t108.source == s10.source && (s10 = t108);
    return s10;
  }
  updateFor(t107, e10) {
    return this.map(t107.changes);
  }
  map(t107) {
    return t107.empty || this.explicitPos < 0 ? this : new vQ(this.source, this.state, t107.mapPos(this.explicitPos));
  }
  touches(t107) {
    return t107.changes.touchesRange(vE(t107.state));
  }
}
class vZ extends vQ {
  constructor(t107, e10, i10, s10, n10) {
    super(t107, 2, e10), this.result = i10, this.from = s10, this.to = n10;
  }
  hasResult() {
    return true;
  }
  updateFor(t107, e10) {
    var i10;
    if (!(3 & e10)) return this.map(t107.changes);
    let s10 = this.result;
    s10.map && !t107.changes.empty && (s10 = s10.map(s10, t107.changes));
    let n10 = t107.changes.mapPos(this.from), o10 = t107.changes.mapPos(this.to, 1), r10 = vE(t107.state);
    if ((this.explicitPos < 0 ? r10 <= n10 : r10 < this.from) || r10 > o10 || !s10 || 2 & e10 && vE(t107.startState) == this.from) return new vQ(this.source, 4 & e10 ? 1 : 0);
    let l10 = this.explicitPos < 0 ? -1 : t107.changes.mapPos(this.explicitPos);
    return !function(t108, e11, i11, s11) {
      if (!t108) return false;
      let n11 = e11.sliceDoc(i11, s11);
      return "function" == typeof t108 ? t108(n11, i11, s11, e11) : vR(t108, true).test(n11);
    }(s10.validFor, t107.state, n10, o10) ? s10.update && (s10 = s10.update(s10, n10, o10, new vD(t107.state, r10, l10 >= 0))) ? new vZ(this.source, l10, s10, s10.from, null !== (i10 = s10.to) && void 0 !== i10 ? i10 : vE(t107.state)) : new vQ(this.source, 1, l10) : new vZ(this.source, l10, s10, n10, o10);
  }
  map(t107) {
    return t107.empty ? this : (this.result.map ? this.result.map(this.result, t107) : this.result) ? new vZ(this.source, this.explicitPos < 0 ? -1 : t107.mapPos(this.explicitPos), this.result, t107.mapPos(this.from), t107.mapPos(this.to, 1)) : new vQ(this.source, 0);
  }
  touches(t107) {
    return t107.changes.touchesRange(this.from, this.to);
  }
}
let v0 = tR.define({ map: (t107, e10) => t107.map((t108) => t108.map(e10)) }), v1 = tR.define(), v2 = td.define({ create: () => vj.start(), update: (t107, e10) => t107.update(e10), provide: (t107) => [uu.from(t107, (t108) => t108.tooltip), d0.contentAttributes.from(t107, (t108) => t108.attrs)] });
function v8(t107, e10) {
  let i10 = e10.completion.apply || e10.completion.label, s10 = t107.state.field(v2).active.find((t108) => t108.source == e10.source);
  return s10 instanceof vZ && ("string" == typeof i10 ? t107.dispatch(Object.assign(Object.assign({}, function(t108, e11, i11, s11) {
    let { main: n10 } = t108.selection, o10 = i11 - n10.from, r10 = s11 - n10.from;
    return Object.assign(Object.assign({}, t108.changeByRange((l10) => l10 != n10 && i11 != s11 && t108.sliceDoc(l10.from + o10, l10.from + r10) != t108.sliceDoc(i11, s11) ? { range: l10 } : { changes: { from: l10.from + o10, to: s11 == n10.from ? l10.to : l10.from + r10, insert: e11 }, range: ti.cursor(l10.from + o10 + e11.length) })), { scrollIntoView: true, userEvent: "input.complete" });
  }(t107.state, i10, s10.from, s10.to)), { annotations: vB.of(e10.completion) })) : i10(t107, e10.completion, s10.from, s10.to), true);
}
let v3 = (t107) => new vq(t107, v2, v8);
function v4(t107) {
  let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "option";
  return (i10) => {
    let s10 = i10.state.field(v2, false);
    if (!s10 || !s10.open || s10.open.disabled || Date.now() - s10.open.timestamp < i10.state.facet(vW).interactionDelay) return false;
    let n10 = 1, o10;
    "page" == e10 && (o10 = uf(i10, s10.open.tooltip)) && (n10 = Math.max(2, Math.floor(o10.dom.offsetHeight / o10.dom.querySelector("li").offsetHeight) - 1));
    let { length: r10 } = s10.open.options, l10 = s10.open.selected > -1 ? s10.open.selected + n10 * (t107 ? 1 : -1) : t107 ? 0 : r10 - 1;
    return l10 < 0 ? l10 = "page" == e10 ? 0 : r10 - 1 : l10 >= r10 && (l10 = "page" == e10 ? r10 - 1 : 0), i10.dispatch({ effects: v1.of(l10) }), true;
  };
}
let v9 = (t107) => !!t107.state.field(v2, false) && (t107.dispatch({ effects: vN.of(true) }), true);
class v5 {
  constructor(t107, e10) {
    this.active = t107, this.context = e10, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
let v6 = ck.fromClass(class {
  constructor(t107) {
    for (let e10 of (this.view = t107, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = false, this.composing = 0, t107.state.field(v2).active)) 1 == e10.state && this.startQuery(e10);
  }
  update(t107) {
    let e10 = t107.state.field(v2), i10 = t107.state.facet(vW);
    if (!t107.selectionSet && !t107.docChanged && t107.startState.field(v2) == e10) return;
    let s10 = t107.transactions.some((t108) => {
      let e11 = vJ(t108, i10);
      return 8 & e11 || (t108.selection || t108.docChanged) && !(3 & e11);
    });
    for (let e11 = 0; e11 < this.running.length; e11++) {
      let i11 = this.running[e11];
      if (s10 || i11.updates.length + t107.transactions.length > 50 && Date.now() - i11.time > 1e3) {
        for (let t108 of i11.context.abortListeners) try {
          t108();
        } catch (t109) {
          cb(this.view.state, t109);
        }
        i11.context.abortListeners = null, this.running.splice(e11--, 1);
      } else i11.updates.push(...t107.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), t107.transactions.some((t108) => t108.effects.some((t109) => t109.is(vN))) && (this.pendingStart = true);
    let n10 = this.pendingStart ? 50 : i10.activateOnTypingDelay;
    if (this.debounceUpdate = e10.active.some((t108) => 1 == t108.state && !this.running.some((e11) => e11.active.source == t108.source)) ? setTimeout(() => this.startUpdate(), n10) : -1, 0 != this.composing) for (let e11 of t107.transactions) e11.isUserEvent("input.type") ? this.composing = 2 : 2 == this.composing && e11.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = false;
    let { state: t107 } = this.view;
    for (let e10 of t107.field(v2).active) 1 != e10.state || this.running.some((t108) => t108.active.source == e10.source) || this.startQuery(e10);
  }
  startQuery(t107) {
    let { state: e10 } = this.view, i10 = vE(e10), s10 = new vD(e10, i10, t107.explicitPos == i10, this.view), n10 = new v5(t107, s10);
    this.running.push(n10), Promise.resolve(t107.source(s10)).then((t108) => {
      n10.context.aborted || (n10.done = t108 || null, this.scheduleAccept());
    }, (t108) => {
      this.view.dispatch({ effects: vV.of(null) }), cb(this.view.state, t108);
    });
  }
  scheduleAccept() {
    this.running.every((t107) => void 0 !== t107.done) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(vW).updateSyncTime));
  }
  accept() {
    var t107;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e10 = [], i10 = this.view.state.facet(vW);
    for (let s10 = 0; s10 < this.running.length; s10++) {
      let n10 = this.running[s10];
      if (void 0 === n10.done) continue;
      if (this.running.splice(s10--, 1), n10.done) {
        let s11 = new vZ(n10.active.source, n10.active.explicitPos, n10.done, n10.done.from, null !== (t107 = n10.done.to) && void 0 !== t107 ? t107 : vE(n10.updates.length ? n10.updates[0].startState : this.view.state));
        for (let t108 of n10.updates) s11 = s11.update(t108, i10);
        if (s11.hasResult()) {
          e10.push(s11);
          continue;
        }
      }
      let o10 = this.view.state.field(v2).active.find((t108) => t108.source == n10.active.source);
      if (o10 && 1 == o10.state) {
        if (null == n10.done) {
          let t108 = new vQ(n10.active.source, 0);
          for (let e11 of n10.updates) t108 = t108.update(e11, i10);
          1 != t108.state && e10.push(t108);
        } else this.startQuery(o10);
      }
    }
    e10.length && this.view.dispatch({ effects: v0.of(e10) });
  }
}, { eventHandlers: { blur(t107) {
  let e10 = this.view.state.field(v2, false);
  if (e10 && e10.tooltip && this.view.state.facet(vW).closeOnBlur) {
    let i10 = e10.open && uf(this.view, e10.open.tooltip);
    i10 && i10.dom.contains(t107.relatedTarget) || setTimeout(() => this.view.dispatch({ effects: vV.of(null) }), 10);
  }
}, compositionstart() {
  this.composing = 1;
}, compositionend() {
  3 == this.composing && setTimeout(() => this.view.dispatch({ effects: vN.of(false) }), 20), this.composing = 0;
} } }), v7 = "object" == typeof navigator && /Win/.test(navigator.platform), wt = tg.highest(d0.domEventHandlers({ keydown(t107, e10) {
  let i10 = e10.state.field(v2, false);
  if (!i10 || !i10.open || i10.open.disabled || i10.open.selected < 0 || t107.key.length > 1 || t107.ctrlKey && !(v7 && t107.altKey) || t107.metaKey) return false;
  let s10 = i10.open.options[i10.open.selected], n10 = i10.active.find((t108) => t108.source == s10.source), o10 = s10.completion.commitCharacters || n10.result.commitCharacters;
  return o10 && o10.indexOf(t107.key) > -1 && v8(e10, s10), false;
} })), we = d0.baseTheme({ ".cm-tooltip.cm-tooltip-autocomplete": { "& > ul": { fontFamily: "monospace", whiteSpace: "nowrap", overflow: "hidden auto", maxWidth_fallback: "700px", maxWidth: "min(700px, 95vw)", minWidth: "250px", maxHeight: "10em", height: "100%", listStyle: "none", margin: 0, padding: 0, "& > li, & > completion-section": { padding: "1px 3px", lineHeight: 1.2 }, "& > li": { overflowX: "hidden", textOverflow: "ellipsis", cursor: "pointer" }, "& > completion-section": { display: "list-item", borderBottom: "1px solid silver", paddingLeft: "0.5em", opacity: 0.7 } } }, "&light .cm-tooltip-autocomplete ul li[aria-selected]": { background: "#17c", color: "white" }, "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": { background: "#777" }, "&dark .cm-tooltip-autocomplete ul li[aria-selected]": { background: "#347", color: "white" }, "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": { background: "#444" }, ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": { content: '""', opacity: 0.5, display: "block", textAlign: "center" }, ".cm-tooltip.cm-completionInfo": { position: "absolute", padding: "3px 9px", width: "max-content", maxWidth: "400px", boxSizing: "border-box" }, ".cm-completionInfo.cm-completionInfo-left": { right: "100%" }, ".cm-completionInfo.cm-completionInfo-right": { left: "100%" }, ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" }, ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" }, "&light .cm-snippetField": { backgroundColor: "#00000022" }, "&dark .cm-snippetField": { backgroundColor: "#ffffff22" }, ".cm-snippetFieldPosition": { verticalAlign: "text-top", width: 0, height: "1.15em", display: "inline-block", margin: "0 -0.7px -.7em", borderLeft: "1.4px dotted #888" }, ".cm-completionMatchedText": { textDecoration: "underline" }, ".cm-completionDetail": { marginLeft: "0.5em", fontStyle: "italic" }, ".cm-completionIcon": { fontSize: "90%", width: ".8em", display: "inline-block", textAlign: "center", paddingRight: ".6em", opacity: "0.6", boxSizing: "content-box" }, ".cm-completionIcon-function, .cm-completionIcon-method": { "&:after": { content: "''" } }, ".cm-completionIcon-class": { "&:after": { content: "''" } }, ".cm-completionIcon-interface": { "&:after": { content: "''" } }, ".cm-completionIcon-variable": { "&:after": { content: "''" } }, ".cm-completionIcon-constant": { "&:after": { content: "''" } }, ".cm-completionIcon-type": { "&:after": { content: "''" } }, ".cm-completionIcon-enum": { "&:after": { content: "''" } }, ".cm-completionIcon-property": { "&:after": { content: "''" } }, ".cm-completionIcon-keyword": { "&:after": { content: "''" } }, ".cm-completionIcon-namespace": { "&:after": { content: "''" } }, ".cm-completionIcon-text": { "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" } } });
class wi {
  constructor(t107, e10, i10, s10) {
    this.field = t107, this.line = e10, this.from = i10, this.to = s10;
  }
}
class ws {
  constructor(t107, e10, i10) {
    this.field = t107, this.from = e10, this.to = i10;
  }
  map(t107) {
    let e10 = t107.mapPos(this.from, -1, j.TrackDel), i10 = t107.mapPos(this.to, 1, j.TrackDel);
    return null == e10 || null == i10 ? null : new ws(this.field, e10, i10);
  }
}
class wn {
  constructor(t107, e10) {
    this.lines = t107, this.fieldPositions = e10;
  }
  instantiate(t107, e10) {
    let i10 = [], s10 = [e10], n10 = t107.doc.lineAt(e10), o10 = /^\s*/.exec(n10.text)[0];
    for (let n11 of this.lines) {
      if (i10.length) {
        let i11 = o10, r10 = /^\t*/.exec(n11)[0].length;
        for (let e11 = 0; e11 < r10; e11++) i11 += t107.facet(mN);
        s10.push(e10 + i11.length - r10), n11 = i11 + n11.slice(r10);
      }
      i10.push(n11), e10 += n11.length + 1;
    }
    return { text: i10, ranges: this.fieldPositions.map((t108) => new ws(t108.field, s10[t108.line] + t108.from, s10[t108.line] + t108.to)) };
  }
  static parse(t107) {
    let e10 = [], i10 = [], s10 = [], n10;
    for (let o10 of t107.split(/\r\n?|\n/)) {
      for (; n10 = /[#$]\{(?:(\d+)(?::([^}]*))?|((?:\\[{}]|[^}])*))\}/.exec(o10); ) {
        let t108 = n10[1] ? +n10[1] : null, r10 = n10[2] || n10[3] || "", l10 = -1, h10 = r10.replace(/\\[{}]/g, (t109) => t109[1]);
        for (let i11 = 0; i11 < e10.length; i11++) (null != t108 ? e10[i11].seq == t108 : h10 && e10[i11].name == h10) && (l10 = i11);
        if (l10 < 0) {
          let i11 = 0;
          for (; i11 < e10.length && (null == t108 || null != e10[i11].seq && e10[i11].seq < t108); ) i11++;
          for (let n11 of (e10.splice(i11, 0, { seq: t108, name: h10 }), l10 = i11, s10)) n11.field >= l10 && n11.field++;
        }
        s10.push(new wi(l10, i10.length, n10.index, n10.index + h10.length)), o10 = o10.slice(0, n10.index) + r10 + o10.slice(n10.index + n10[0].length);
      }
      o10 = o10.replace(/\\([{}])/g, (t108, e11, n11) => {
        for (let t109 of s10) t109.line == i10.length && t109.from > n11 && (t109.from--, t109.to--);
        return e11;
      }), i10.push(o10);
    }
    return new wn(i10, s10);
  }
}
let wo = aU.widget({ widget: new class extends aG {
  toDOM() {
    let t107 = document.createElement("span");
    return t107.className = "cm-snippetFieldPosition", t107;
  }
  ignoreEvent() {
    return false;
  }
}() }), wr = aU.mark({ class: "cm-snippetField" });
class wl {
  constructor(t107, e10) {
    this.ranges = t107, this.active = e10, this.deco = aU.set(t107.map((t108) => (t108.from == t108.to ? wo : wr).range(t108.from, t108.to)));
  }
  map(t107) {
    let e10 = [];
    for (let i10 of this.ranges) {
      let s10 = i10.map(t107);
      if (!s10) return null;
      e10.push(s10);
    }
    return new wl(e10, this.active);
  }
  selectionInsideField(t107) {
    return t107.ranges.every((t108) => this.ranges.some((e10) => e10.field == this.active && e10.from <= t108.from && e10.to >= t108.to));
  }
}
let wh = tR.define({ map: (t107, e10) => t107 && t107.map(e10) }), wa = tR.define(), wc = td.define({ create: () => null, update(t107, e10) {
  for (let i10 of e10.effects) {
    if (i10.is(wh)) return i10.value;
    if (i10.is(wa) && t107) return new wl(t107.ranges, i10.value);
  }
  return t107 && e10.docChanged && (t107 = t107.map(e10.changes)), t107 && e10.selection && !t107.selectionInsideField(e10.selection) && (t107 = null), t107;
}, provide: (t107) => d0.decorations.from(t107, (t108) => t108 ? t108.deco : aU.none) });
function wd(t107, e10) {
  return ti.create(t107.filter((t108) => t108.field == e10).map((t108) => ti.range(t108.from, t108.to)));
}
function wu(t107) {
  return (e10) => {
    let { state: i10, dispatch: s10 } = e10, n10 = i10.field(wc, false);
    if (!n10 || t107 < 0 && 0 == n10.active) return false;
    let o10 = n10.active + t107, r10 = t107 > 0 && !n10.ranges.some((e11) => e11.field == o10 + t107);
    return s10(i10.update({ selection: wd(n10.ranges, o10), effects: wh.of(r10 ? null : new wl(n10.ranges, o10)), scrollIntoView: true })), true;
  };
}
let wf = [{ key: "Tab", run: wu(1), shift: wu(-1) }, { key: "Escape", run: (t107) => {
  let { state: e10, dispatch: i10 } = t107;
  return !!e10.field(wc, false) && (i10(e10.update({ effects: wh.of(null) })), true);
} }], wg = to.define({ combine: (t107) => t107.length ? t107[0] : wf }), wp = tg.highest(d6.compute([wg], (t107) => t107.facet(wg)));
function wm(t107, e10) {
  let i10;
  return Object.assign(Object.assign({}, e10), { apply: (i10 = wn.parse(t107), (t108, e11, s10, n10) => {
    let { text: o10, ranges: l10 } = i10.instantiate(t108.state, s10), h10 = { changes: { from: s10, to: n10, insert: r.of(o10) }, scrollIntoView: true, annotations: e11 ? [vB.of(e11), tB.userEvent.of("input.complete")] : void 0 };
    if (l10.length && (h10.selection = wd(l10, 0)), l10.some((t109) => t109.field > 0)) {
      let e12 = new wl(l10, 0), i11 = h10.effects = [wh.of(e12)];
      void 0 === t108.state.field(wc, false) && i11.push(tR.appendConfig.of([wc, wp, wv, we]));
    }
    t108.dispatch(t108.state.update(h10));
  }) });
}
let wv = d0.domEventHandlers({ mousedown(t107, e10) {
  let i10 = e10.state.field(wc, false), s10;
  if (!i10 || null == (s10 = e10.posAtCoords({ x: t107.clientX, y: t107.clientY }))) return false;
  let n10 = i10.ranges.find((t108) => t108.from <= s10 && t108.to >= s10);
  return !!n10 && n10.field != i10.active && (e10.dispatch({ selection: wd(i10.ranges, n10.field), effects: wh.of(i10.ranges.some((t108) => t108.field > n10.field) ? new wl(i10.ranges, n10.field) : null), scrollIntoView: true }), true);
} }), ww = { brackets: ["(", "[", "{", "'", '"'], before: ")]}:;>", stringPrefixes: [] }, wb = tR.define({ map(t107, e10) {
  let i10 = e10.mapPos(t107, -1, j.TrackAfter);
  return null == i10 ? void 0 : i10;
} }), wy = new class extends tz {
}();
wy.startSide = 1, wy.endSide = -1;
let wx = td.define({ create: () => tG.empty, update(t107, e10) {
  if (t107 = t107.map(e10.changes), e10.selection) {
    let i10 = e10.state.doc.lineAt(e10.selection.main.head);
    t107 = t107.update({ filter: (t108) => t108 >= i10.from && t108 <= i10.to });
  }
  for (let i10 of e10.effects) i10.is(wb) && (t107 = t107.update({ add: [wy.range(i10.value, i10.value + 1)] }));
  return t107;
} });
function wS() {
  return [wD, wx];
}
let wk = "()[]{}<>";
function wM(t107) {
  for (let e10 = 0; e10 < wk.length; e10 += 2) if (wk.charCodeAt(e10) == t107) return wk.charAt(e10 + 1);
  return S(t107 < 128 ? t107 : t107 + 1);
}
function wC(t107, e10) {
  return t107.languageDataAt("closeBrackets", e10)[0] || ww;
}
let wA = "object" == typeof navigator && /Android\b/.test(navigator.userAgent), wD = d0.inputHandler.of((t107, e10, i10, s10) => {
  if ((wA ? t107.composing : t107.compositionStarted) || t107.state.readOnly) return false;
  let n10 = t107.state.selection.main;
  if (s10.length > 2 || 2 == s10.length && 1 == k(x(s10, 0)) || e10 != n10.from || i10 != n10.to) return false;
  let o10 = function(t108, e11) {
    let i11 = wC(t108, t108.selection.main.head), s11 = i11.brackets || ww.brackets;
    for (let n11 of s11) {
      let o11 = wM(x(n11, 0));
      if (e11 == n11) return o11 == n11 ? function(t109, e12, i12, s12) {
        let n12 = s12.stringPrefixes || ww.stringPrefixes, o12 = null, r10 = t109.changeByRange((s13) => {
          if (!s13.empty) return { changes: [{ insert: e12, from: s13.from }, { insert: e12, from: s13.to }], effects: wb.of(s13.to + e12.length), range: ti.range(s13.anchor + e12.length, s13.head + e12.length) };
          let r11 = s13.head, l10 = wE(t109.doc, r11), h10;
          if (l10 == e12) {
            if (wR(t109, r11)) return { changes: { insert: e12 + e12, from: r11 }, effects: wb.of(r11 + e12.length), range: ti.cursor(r11 + e12.length) };
            if (wT(t109, r11)) {
              let s14 = i12 && t109.sliceDoc(r11, r11 + 3 * e12.length) == e12 + e12 + e12 ? e12 + e12 + e12 : e12;
              return { changes: { from: r11, to: r11 + s14.length, insert: s14 }, range: ti.cursor(r11 + s14.length) };
            }
          } else if (i12 && t109.sliceDoc(r11 - 2 * e12.length, r11) == e12 + e12 && (h10 = wB(t109, r11 - 2 * e12.length, n12)) > -1 && wR(t109, h10)) return { changes: { insert: e12 + e12 + e12 + e12, from: r11 }, effects: wb.of(r11 + e12.length), range: ti.cursor(r11 + e12.length) };
          else if (t109.charCategorizer(r11)(l10) != tH.Word && wB(t109, r11, n12) > -1 && !function(t110, e13, i13, s14) {
            let n13 = mk(t110).resolveInner(e13, -1), o13 = s14.reduce((t111, e14) => Math.max(t111, e14.length), 0);
            for (let r12 = 0; r12 < 5; r12++) {
              let r13 = t110.sliceDoc(n13.from, Math.min(n13.to, n13.from + i13.length + o13)), l11 = r13.indexOf(i13);
              if (!l11 || l11 > -1 && s14.indexOf(r13.slice(0, l11)) > -1) {
                let e14 = n13.firstChild;
                for (; e14 && e14.from == n13.from && e14.to - e14.from > i13.length + l11; ) {
                  if (t110.sliceDoc(e14.to - i13.length, e14.to) == i13) return false;
                  e14 = e14.firstChild;
                }
                return true;
              }
              let h11 = n13.to == e13 && n13.parent;
              if (!h11) break;
              n13 = h11;
            }
            return false;
          }(t109, r11, e12, n12)) return { changes: { insert: e12 + e12, from: r11 }, effects: wb.of(r11 + e12.length), range: ti.cursor(r11 + e12.length) };
          return { range: o12 = s13 };
        });
        return o12 ? null : t109.update(r10, { scrollIntoView: true, userEvent: "input.type" });
      }(t108, n11, s11.indexOf(n11 + n11 + n11) > -1, i11) : function(t109, e12, i12, s12) {
        let n12 = null, o12 = t109.changeByRange((o13) => {
          if (!o13.empty) return { changes: [{ insert: e12, from: o13.from }, { insert: i12, from: o13.to }], effects: wb.of(o13.to + e12.length), range: ti.range(o13.anchor + e12.length, o13.head + e12.length) };
          let r10 = wE(t109.doc, o13.head);
          return !r10 || /\s/.test(r10) || s12.indexOf(r10) > -1 ? { changes: { insert: e12 + i12, from: o13.head }, effects: wb.of(o13.head + e12.length), range: ti.cursor(o13.head + e12.length) } : { range: n12 = o13 };
        });
        return n12 ? null : t109.update(o12, { scrollIntoView: true, userEvent: "input.type" });
      }(t108, n11, o11, i11.before || ww.before);
      if (e11 == o11 && wT(t108, t108.selection.main.from)) return function(t109, e12, i12) {
        let s12 = null, n12 = t109.changeByRange((e13) => e13.empty && wE(t109.doc, e13.head) == i12 ? { changes: { from: e13.head, to: e13.head + i12.length, insert: i12 }, range: ti.cursor(e13.head + i12.length) } : s12 = { range: e13 });
        return s12 ? null : t109.update(n12, { scrollIntoView: true, userEvent: "input.type" });
      }(t108, 0, o11);
    }
    return null;
  }(t107.state, s10);
  return !!o10 && (t107.dispatch(o10), true);
}), wO = [{ key: "Backspace", run: (t107) => {
  let { state: e10, dispatch: i10 } = t107;
  if (e10.readOnly) return false;
  let s10 = wC(e10, e10.selection.main.head).brackets || ww.brackets, n10 = null, o10 = e10.changeByRange((t108) => {
    if (t108.empty) {
      var i11, o11;
      let n11;
      let r10 = (i11 = e10.doc, o11 = t108.head, k(x(n11 = i11.sliceString(o11 - 2, o11), 0)) == n11.length ? n11 : n11.slice(1));
      for (let i12 of s10) if (i12 == r10 && wE(e10.doc, t108.head) == wM(x(i12, 0))) return { changes: { from: t108.head - i12.length, to: t108.head + i12.length }, range: ti.cursor(t108.head - i12.length) };
    }
    return { range: n10 = t108 };
  });
  return n10 || i10(e10.update(o10, { scrollIntoView: true, userEvent: "delete.backward" })), !n10;
} }];
function wT(t107, e10) {
  let i10 = false;
  return t107.field(wx).between(0, t107.doc.length, (t108) => {
    t108 == e10 && (i10 = true);
  }), i10;
}
function wE(t107, e10) {
  let i10 = t107.sliceString(e10, e10 + 2);
  return i10.slice(0, k(x(i10, 0)));
}
function wR(t107, e10) {
  let i10 = mk(t107).resolveInner(e10 + 1);
  return i10.parent && i10.from == e10;
}
function wB(t107, e10, i10) {
  let s10 = t107.charCategorizer(e10);
  if (s10(t107.sliceDoc(e10 - 1, e10)) != tH.Word) return e10;
  for (let n10 of i10) {
    let i11 = e10 - n10.length;
    if (t107.sliceDoc(i11, e10) == n10 && s10(t107.sliceDoc(i11 - 1, i11)) != tH.Word) return i11;
  }
  return -1;
}
function wL() {
  let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
  return [wt, v2, vW.of(t107), v6, wN, we];
}
let wP = [{ key: "Ctrl-Space", run: v9 }, { key: "Escape", run: (t107) => {
  let e10 = t107.state.field(v2, false);
  return !!(e10 && e10.active.some((t108) => 0 != t108.state)) && (t107.dispatch({ effects: vV.of(null) }), true);
} }, { key: "ArrowDown", run: v4(true) }, { key: "ArrowUp", run: v4(false) }, { key: "PageDown", run: v4(true, "page") }, { key: "PageUp", run: v4(false, "page") }, { key: "Enter", run: (t107) => {
  let e10 = t107.state.field(v2, false);
  return !(t107.state.readOnly || !e10 || !e10.open || e10.open.selected < 0 || e10.open.disabled || Date.now() - e10.open.timestamp < t107.state.facet(vW).interactionDelay) && v8(t107, e10.open.options[e10.open.selected]);
} }], wN = tg.highest(d6.computeN([vW], (t107) => t107.facet(vW).defaultKeymap ? [wP] : []));
function wV(t107) {
  return (11 == t107.nodeType ? t107.getSelection ? t107 : t107.ownerDocument : t107).getSelection();
}
function wH(t107, e10) {
  return !!e10 && (t107 == e10 || t107.contains(1 != e10.nodeType ? e10.parentNode : e10));
}
function wF(t107, e10) {
  if (!e10.anchorNode) return false;
  try {
    return wH(t107, e10.anchorNode);
  } catch (t108) {
    return false;
  }
}
function wW(t107) {
  return 3 == t107.nodeType ? wX(t107, 0, t107.nodeValue.length).getClientRects() : 1 == t107.nodeType ? t107.getClientRects() : [];
}
function wI(t107, e10, i10, s10) {
  return !!i10 && (wq(t107, e10, i10, s10, -1) || wq(t107, e10, i10, s10, 1));
}
function wz(t107) {
  for (var e10 = 0; ; e10++) if (!(t107 = t107.previousSibling)) return e10;
}
function wK(t107) {
  return 1 == t107.nodeType && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t107.nodeName);
}
function wq(t107, e10, i10, s10, n10) {
  for (; ; ) {
    if (t107 == i10 && e10 == s10) return true;
    if (e10 == (n10 < 0 ? 0 : w_(t107))) {
      if ("DIV" == t107.nodeName) return false;
      let i11 = t107.parentNode;
      if (!i11 || 1 != i11.nodeType) return false;
      e10 = wz(t107) + (n10 < 0 ? 0 : 1), t107 = i11;
    } else {
      if (1 != t107.nodeType || 1 == (t107 = t107.childNodes[e10 + (n10 < 0 ? -1 : 0)]).nodeType && "false" == t107.contentEditable) return false;
      e10 = n10 < 0 ? w_(t107) : 0;
    }
  }
}
function w_(t107) {
  return 3 == t107.nodeType ? t107.nodeValue.length : t107.childNodes.length;
}
function wG(t107, e10) {
  let i10 = e10 ? t107.left : t107.right;
  return { left: i10, right: i10, top: t107.top, bottom: t107.bottom };
}
function wj(t107, e10) {
  let i10 = e10.width / t107.offsetWidth, s10 = e10.height / t107.offsetHeight;
  return (i10 > 0.995 && i10 < 1.005 || !isFinite(i10) || 1 > Math.abs(e10.width - t107.offsetWidth)) && (i10 = 1), (s10 > 0.995 && s10 < 1.005 || !isFinite(s10) || 1 > Math.abs(e10.height - t107.offsetHeight)) && (s10 = 1), { scaleX: i10, scaleY: s10 };
}
class wU {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(t107) {
    return this.anchorNode == t107.anchorNode && this.anchorOffset == t107.anchorOffset && this.focusNode == t107.focusNode && this.focusOffset == t107.focusOffset;
  }
  setRange(t107) {
    let { anchorNode: e10, focusNode: i10 } = t107;
    this.set(e10, Math.min(t107.anchorOffset, e10 ? w_(e10) : 0), i10, Math.min(t107.focusOffset, i10 ? w_(i10) : 0));
  }
  set(t107, e10, i10, s10) {
    this.anchorNode = t107, this.anchorOffset = e10, this.focusNode = i10, this.focusOffset = s10;
  }
}
let wY = null;
function w$(t107) {
  if (t107.setActive) return t107.setActive();
  if (wY) return t107.focus(wY);
  let e10 = [];
  for (let i10 = t107; i10 && (e10.push(i10, i10.scrollTop, i10.scrollLeft), i10 != i10.ownerDocument); i10 = i10.parentNode) ;
  if (t107.focus(null == wY ? { get preventScroll() {
    return wY = { preventScroll: true }, true;
  } } : void 0), !wY) {
    wY = false;
    for (let t108 = 0; t108 < e10.length; ) {
      let i10 = e10[t108++], s10 = e10[t108++], n10 = e10[t108++];
      i10.scrollTop != s10 && (i10.scrollTop = s10), i10.scrollLeft != n10 && (i10.scrollLeft = n10);
    }
  }
}
function wX(t107, e10) {
  let i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e10, s10 = o || (o = document.createRange());
  return s10.setEnd(t107, i10), s10.setStart(t107, e10), s10;
}
function wJ(t107, e10, i10, s10) {
  let n10 = { key: e10, code: e10, keyCode: i10, which: i10, cancelable: true };
  s10 && ({ altKey: n10.altKey, ctrlKey: n10.ctrlKey, shiftKey: n10.shiftKey, metaKey: n10.metaKey } = s10);
  let o10 = new KeyboardEvent("keydown", n10);
  o10.synthetic = true, t107.dispatchEvent(o10);
  let r10 = new KeyboardEvent("keyup", n10);
  return r10.synthetic = true, t107.dispatchEvent(r10), o10.defaultPrevented || r10.defaultPrevented;
}
function wQ(t107) {
  for (; t107.attributes.length; ) t107.removeAttributeNode(t107.attributes[0]);
}
function wZ(t107) {
  return t107.scrollTop > Math.max(1, t107.scrollHeight - t107.clientHeight - 4);
}
function w0(t107, e10) {
  for (let i10 = t107, s10 = e10; ; ) {
    if (3 == i10.nodeType && s10 > 0) return { node: i10, offset: s10 };
    if (1 == i10.nodeType && s10 > 0) {
      if ("false" == i10.contentEditable) return null;
      s10 = w_(i10 = i10.childNodes[s10 - 1]);
    } else {
      if (!i10.parentNode || wK(i10)) return null;
      s10 = wz(i10), i10 = i10.parentNode;
    }
  }
}
function w1(t107, e10) {
  for (let i10 = t107, s10 = e10; ; ) {
    if (3 == i10.nodeType && s10 < i10.nodeValue.length) return { node: i10, offset: s10 };
    if (1 == i10.nodeType && s10 < i10.childNodes.length) {
      if ("false" == i10.contentEditable) return null;
      i10 = i10.childNodes[s10], s10 = 0;
    } else {
      if (!i10.parentNode || wK(i10)) return null;
      s10 = wz(i10) + 1, i10 = i10.parentNode;
    }
  }
}
class w2 {
  constructor(t107, e10, i10 = true) {
    this.node = t107, this.offset = e10, this.precise = i10;
  }
  static before(t107, e10) {
    return new w2(t107.parentNode, wz(t107), e10);
  }
  static after(t107, e10) {
    return new w2(t107.parentNode, wz(t107) + 1, e10);
  }
}
let w8 = [];
class w3 {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(t107) {
    let e10 = this.posAtStart;
    for (let i10 of this.children) {
      if (i10 == t107) return e10;
      e10 += i10.length + i10.breakAfter;
    }
    throw RangeError("Invalid child in posBefore");
  }
  posAfter(t107) {
    return this.posBefore(t107) + t107.length;
  }
  sync(t107, e10) {
    if (2 & this.flags) {
      let i10 = this.dom, s10 = null, n10;
      for (let o10 of this.children) {
        if (7 & o10.flags) {
          if (!o10.dom && (n10 = s10 ? s10.nextSibling : i10.firstChild)) {
            let t108 = w3.get(n10);
            (!t108 || !t108.parent && t108.canReuseDOM(o10)) && o10.reuseDOM(n10);
          }
          o10.sync(t107, e10), o10.flags &= -8;
        }
        if (n10 = s10 ? s10.nextSibling : i10.firstChild, e10 && !e10.written && e10.node == i10 && n10 != o10.dom && (e10.written = true), o10.dom.parentNode == i10) for (; n10 && n10 != o10.dom; ) n10 = w4(n10);
        else i10.insertBefore(o10.dom, n10);
        s10 = o10.dom;
      }
      for ((n10 = s10 ? s10.nextSibling : i10.firstChild) && e10 && e10.node == i10 && (e10.written = true); n10; ) n10 = w4(n10);
    } else if (1 & this.flags) for (let i10 of this.children) 7 & i10.flags && (i10.sync(t107, e10), i10.flags &= -8);
  }
  reuseDOM(t107) {
  }
  localPosFromDOM(t107, e10) {
    let i10;
    if (t107 == this.dom) i10 = this.dom.childNodes[e10];
    else {
      let s10 = 0 == w_(t107) ? 0 : 0 == e10 ? -1 : 1;
      for (; ; ) {
        let e11 = t107.parentNode;
        if (e11 == this.dom) break;
        0 == s10 && e11.firstChild != e11.lastChild && (s10 = t107 == e11.firstChild ? -1 : 1), t107 = e11;
      }
      i10 = s10 < 0 ? t107 : t107.nextSibling;
    }
    if (i10 == this.dom.firstChild) return 0;
    for (; i10 && !w3.get(i10); ) i10 = i10.nextSibling;
    if (!i10) return this.length;
    for (let t108 = 0, e11 = 0; ; t108++) {
      let s10 = this.children[t108];
      if (s10.dom == i10) return e11;
      e11 += s10.length + s10.breakAfter;
    }
  }
  domBoundsAround(t107, e10) {
    let i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, s10 = -1, n10 = -1, o10 = -1, r10 = -1;
    for (let l10 = 0, h10 = i10, a10 = i10; l10 < this.children.length; l10++) {
      let i11 = this.children[l10], c10 = h10 + i11.length;
      if (h10 < t107 && c10 > e10) return i11.domBoundsAround(t107, e10, h10);
      if (c10 >= t107 && -1 == s10 && (s10 = l10, n10 = h10), h10 > e10 && i11.dom.parentNode == this.dom) {
        o10 = l10, r10 = a10;
        break;
      }
      a10 = c10, h10 = c10 + i11.breakAfter;
    }
    return { from: n10, to: r10 < 0 ? i10 + this.length : r10, startDOM: (s10 ? this.children[s10 - 1].dom.nextSibling : null) || this.dom.firstChild, endDOM: o10 < this.children.length && o10 >= 0 ? this.children[o10].dom : null };
  }
  markDirty() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
    this.flags |= 2, this.markParentsDirty(t107);
  }
  markParentsDirty(t107) {
    for (let e10 = this.parent; e10; e10 = e10.parent) {
      if (t107 && (e10.flags |= 2), 1 & e10.flags) return;
      e10.flags |= 1, t107 = false;
    }
  }
  setParent(t107) {
    this.parent != t107 && (this.parent = t107, 7 & this.flags && this.markParentsDirty(true));
  }
  setDOM(t107) {
    this.dom != t107 && (this.dom && (this.dom.cmView = null), this.dom = t107, t107.cmView = this);
  }
  get rootView() {
    for (let t107 = this; ; ) {
      let e10 = t107.parent;
      if (!e10) return t107;
      t107 = e10;
    }
  }
  replaceChildren(t107, e10) {
    let i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : w8;
    this.markDirty();
    for (let s10 = t107; s10 < e10; s10++) {
      let t108 = this.children[s10];
      t108.parent == this && 0 > i10.indexOf(t108) && t108.destroy();
    }
    this.children.splice(t107, e10 - t107, ...i10);
    for (let t108 = 0; t108 < i10.length; t108++) i10[t108].setParent(this);
  }
  ignoreMutation(t107) {
    return false;
  }
  ignoreEvent(t107) {
    return false;
  }
  childCursor() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.length;
    return new w9(this.children, t107, this.children.length);
  }
  childPos(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
    return this.childCursor().findPos(t107, e10);
  }
  toString() {
    let t107 = this.constructor.name.replace("View", "");
    return t107 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + ("Text" == t107 ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(t107) {
    return t107.cmView;
  }
  get isEditable() {
    return true;
  }
  get isWidget() {
    return false;
  }
  get isHidden() {
    return false;
  }
  merge(t107, e10, i10, s10, n10, o10) {
    return false;
  }
  become(t107) {
    return false;
  }
  canReuseDOM(t107) {
    return t107.constructor == this.constructor && !((this.flags | t107.flags) & 8);
  }
  getSide() {
    return 0;
  }
  destroy() {
    for (let t107 of this.children) t107.parent == this && t107.destroy();
    this.parent = null;
  }
}
function w4(t107) {
  let e10 = t107.nextSibling;
  return t107.parentNode.removeChild(t107), e10;
}
w3.prototype.breakAfter = 0;
class w9 {
  constructor(t107, e10, i10) {
    this.children = t107, this.pos = e10, this.i = i10, this.off = 0;
  }
  findPos(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
    for (; ; ) {
      if (t107 > this.pos || t107 == this.pos && (e10 > 0 || 0 == this.i || this.children[this.i - 1].breakAfter)) return this.off = t107 - this.pos, this;
      let i10 = this.children[--this.i];
      this.pos -= i10.length + i10.breakAfter;
    }
  }
}
function w5(t107, e10, i10, s10, n10, o10, r10, l10, h10) {
  let { children: a10 } = t107, c10 = a10.length ? a10[e10] : null, d10 = o10.length ? o10[o10.length - 1] : null, u10 = d10 ? d10.breakAfter : r10;
  if (!(e10 == s10 && c10 && !r10 && !u10 && o10.length < 2 && c10.merge(i10, n10, o10.length ? d10 : null, 0 == i10, l10, h10))) {
    if (s10 < a10.length) {
      let t108 = a10[s10];
      t108 && (n10 < t108.length || t108.breakAfter && (null == d10 ? void 0 : d10.breakAfter)) ? (e10 == s10 && (t108 = t108.split(n10), n10 = 0), !u10 && d10 && t108.merge(0, n10, d10, true, 0, h10) ? o10[o10.length - 1] = t108 : ((n10 || t108.children.length && !t108.children[0].length) && t108.merge(0, n10, null, false, 0, h10), o10.push(t108))) : (null == t108 ? void 0 : t108.breakAfter) && (d10 ? d10.breakAfter = 1 : r10 = 1), s10++;
    }
    for (c10 && (c10.breakAfter = r10, i10 > 0 && (!r10 && o10.length && c10.merge(i10, c10.length, o10[0], false, l10, 0) ? c10.breakAfter = o10.shift().breakAfter : (i10 < c10.length || c10.children.length && 0 == c10.children[c10.children.length - 1].length) && c10.merge(i10, c10.length, null, false, l10, 0), e10++)); e10 < s10 && o10.length; ) if (a10[s10 - 1].become(o10[o10.length - 1])) s10--, o10.pop(), h10 = o10.length ? 0 : l10;
    else if (a10[e10].become(o10[0])) e10++, o10.shift(), l10 = o10.length ? 0 : h10;
    else break;
    !o10.length && e10 && s10 < a10.length && !a10[e10 - 1].breakAfter && a10[s10].merge(0, 0, a10[e10 - 1], false, l10, h10) && e10--, (e10 < s10 || o10.length) && t107.replaceChildren(e10, s10, o10);
  }
}
function w6(t107, e10, i10, s10, n10, o10) {
  let r10 = t107.childCursor(), { i: l10, off: h10 } = r10.findPos(i10, 1), { i: a10, off: c10 } = r10.findPos(e10, -1), d10 = e10 - i10;
  for (let t108 of s10) d10 += t108.length;
  t107.length += d10, w5(t107, a10, c10, l10, h10, s10, 0, n10, o10);
}
let w7 = "undefined" != typeof navigator ? navigator : { userAgent: "", vendor: "", platform: "" }, bt = "undefined" != typeof document ? document : { documentElement: { style: {} } }, be = /Edge\/(\d+)/.exec(w7.userAgent), bi = /MSIE \d/.test(w7.userAgent), bs = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(w7.userAgent), bn = !!(bi || bs || be), bo = !bn && /gecko\/(\d+)/i.test(w7.userAgent), br = !bn && /Chrome\/(\d+)/.exec(w7.userAgent), bl = "webkitFontSmoothing" in bt.documentElement.style, bh = !bn && /Apple Computer/.test(w7.vendor), ba = bh && (/Mobile\/\w+/.test(w7.userAgent) || w7.maxTouchPoints > 2);
var bc = { mac: ba || /Mac/.test(w7.platform), windows: /Win/.test(w7.platform), linux: /Linux|X11/.test(w7.platform), ie: bn, ie_version: bi ? bt.documentMode || 6 : bs ? +bs[1] : be ? +be[1] : 0, gecko: bo, gecko_version: bo ? +(/Firefox\/(\d+)/.exec(w7.userAgent) || [0, 0])[1] : 0, chrome: !!br, chrome_version: br ? +br[1] : 0, ios: ba, android: /Android\b/.test(w7.userAgent), webkit: bl, safari: bh, webkit_version: bl ? +(/\bAppleWebKit\/(\d+)/.exec(w7.userAgent) || [0, 0])[1] : 0, tabSize: null != bt.documentElement.style.tabSize ? "tab-size" : "-moz-tab-size" };
class bd extends w3 {
  constructor(t107) {
    super(), this.text = t107;
  }
  get length() {
    return this.text.length;
  }
  createDOM(t107) {
    this.setDOM(t107 || document.createTextNode(this.text));
  }
  sync(t107, e10) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (e10 && e10.node == this.dom && (e10.written = true), this.dom.nodeValue = this.text);
  }
  reuseDOM(t107) {
    3 == t107.nodeType && this.createDOM(t107);
  }
  merge(t107, e10, i10) {
    return !(8 & this.flags) && (!i10 || i10 instanceof bd && !(this.length - (e10 - t107) + i10.length > 256) && !(8 & i10.flags)) && (this.text = this.text.slice(0, t107) + (i10 ? i10.text : "") + this.text.slice(e10), this.markDirty(), true);
  }
  split(t107) {
    let e10 = new bd(this.text.slice(t107));
    return this.text = this.text.slice(0, t107), this.markDirty(), e10.flags |= 8 & this.flags, e10;
  }
  localPosFromDOM(t107, e10) {
    return t107 == this.dom ? e10 : e10 ? this.text.length : 0;
  }
  domAtPos(t107) {
    return new w2(this.dom, t107);
  }
  domBoundsAround(t107, e10, i10) {
    return { from: i10, to: i10 + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(t107, e10) {
    return function(t108, e11, i10) {
      let s10 = t108.nodeValue.length;
      e11 > s10 && (e11 = s10);
      let n10 = e11, o10 = e11, r10 = 0;
      0 == e11 && i10 < 0 || e11 == s10 && i10 >= 0 ? !(bc.chrome || bc.gecko) && (e11 ? (n10--, r10 = 1) : o10 < s10 && (o10++, r10 = -1)) : i10 < 0 ? n10-- : o10 < s10 && o10++;
      let l10 = wX(t108, n10, o10).getClientRects();
      if (!l10.length) return null;
      let h10 = l10[(r10 ? r10 < 0 : i10 >= 0) ? 0 : l10.length - 1];
      return bc.safari && !r10 && 0 == h10.width && (h10 = Array.prototype.find.call(l10, (t109) => t109.width) || h10), r10 ? wG(h10, r10 < 0) : h10 || null;
    }(this.dom, t107, e10);
  }
}
class bu extends w3 {
  constructor(t107, e10 = [], i10 = 0) {
    for (let s10 of (super(), this.mark = t107, this.children = e10, this.length = i10, e10)) s10.setParent(this);
  }
  setAttrs(t107) {
    if (wQ(t107), this.mark.class && (t107.className = this.mark.class), this.mark.attrs) for (let e10 in this.mark.attrs) t107.setAttribute(e10, this.mark.attrs[e10]);
    return t107;
  }
  canReuseDOM(t107) {
    return super.canReuseDOM(t107) && !((this.flags | t107.flags) & 8);
  }
  reuseDOM(t107) {
    t107.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(t107), this.flags |= 6);
  }
  sync(t107, e10) {
    this.dom ? 4 & this.flags && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(t107, e10);
  }
  merge(t107, e10, i10, s10, n10, o10) {
    return (!i10 || !!(i10 instanceof bu && i10.mark.eq(this.mark)) && (!t107 || !(n10 <= 0)) && (!(e10 < this.length) || !(o10 <= 0))) && (w6(this, t107, e10, i10 ? i10.children.slice() : [], n10 - 1, o10 - 1), this.markDirty(), true);
  }
  split(t107) {
    let e10 = [], i10 = 0, s10 = -1, n10 = 0;
    for (let o11 of this.children) {
      let r10 = i10 + o11.length;
      r10 > t107 && e10.push(i10 < t107 ? o11.split(t107 - i10) : o11), s10 < 0 && i10 >= t107 && (s10 = n10), i10 = r10, n10++;
    }
    let o10 = this.length - t107;
    return this.length = t107, s10 > -1 && (this.children.length = s10, this.markDirty()), new bu(this.mark, e10, o10);
  }
  domAtPos(t107) {
    return bp(this, t107);
  }
  coordsAt(t107, e10) {
    return bm(this, t107, e10);
  }
}
class bf extends w3 {
  static create(t107, e10, i10) {
    return new bf(t107, e10, i10);
  }
  constructor(t107, e10, i10) {
    super(), this.widget = t107, this.length = e10, this.side = i10, this.prevWidget = null;
  }
  split(t107) {
    let e10 = bf.create(this.widget, this.length - t107, this.side);
    return this.length -= t107, e10;
  }
  sync(t107) {
    this.dom && this.widget.updateDOM(this.dom, t107) || (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t107)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(t107, e10, i10, s10, n10, o10) {
    return (!i10 || i10 instanceof bf && !!this.widget.compare(i10.widget) && (!(t107 > 0) || !(n10 <= 0)) && (!(e10 < this.length) || !(o10 <= 0))) && (this.length = t107 + (i10 ? i10.length : 0) + (this.length - e10), true);
  }
  become(t107) {
    return t107 instanceof bf && t107.side == this.side && this.widget.constructor == t107.widget.constructor && (this.widget.compare(t107.widget) || this.markDirty(true), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = t107.widget, this.length = t107.length, true);
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(t107) {
    return this.widget.ignoreEvent(t107);
  }
  get overrideDOMText() {
    if (0 == this.length) return r.empty;
    let t107 = this;
    for (; t107.parent; ) t107 = t107.parent;
    let { view: e10 } = t107, i10 = e10 && e10.state.doc, s10 = this.posAtStart;
    return i10 ? i10.slice(s10, s10 + this.length) : r.empty;
  }
  domAtPos(t107) {
    return (this.length ? 0 == t107 : this.side > 0) ? w2.before(this.dom) : w2.after(this.dom, t107 == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(t107, e10) {
    let i10 = this.widget.coordsAt(this.dom, t107, e10);
    if (i10) return i10;
    let s10 = this.dom.getClientRects(), n10 = null;
    if (!s10.length) return null;
    let o10 = this.side ? this.side < 0 : t107 > 0;
    for (let e11 = o10 ? s10.length - 1 : 0; n10 = s10[e11], t107 > 0 ? 0 != e11 : e11 != s10.length - 1 && !(n10.top < n10.bottom); e11 += o10 ? -1 : 1) ;
    return wG(n10, !o10);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class bg extends w3 {
  constructor(t107) {
    super(), this.side = t107;
  }
  get length() {
    return 0;
  }
  merge() {
    return false;
  }
  become(t107) {
    return t107 instanceof bg && t107.side == this.side;
  }
  split() {
    return new bg(this.side);
  }
  sync() {
    if (!this.dom) {
      let t107 = document.createElement("img");
      t107.className = "cm-widgetBuffer", t107.setAttribute("aria-hidden", "true"), this.setDOM(t107);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(t107) {
    return this.side > 0 ? w2.before(this.dom) : w2.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(t107) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return r.empty;
  }
  get isHidden() {
    return true;
  }
}
function bp(t107, e10) {
  let i10 = t107.dom, { children: s10 } = t107, n10 = 0;
  for (let t108 = 0; n10 < s10.length; n10++) {
    let o10 = s10[n10], r10 = t108 + o10.length;
    if (!(r10 == t108 && 0 >= o10.getSide())) {
      if (e10 > t108 && e10 < r10 && o10.dom.parentNode == i10) return o10.domAtPos(e10 - t108);
      if (e10 <= t108) break;
      t108 = r10;
    }
  }
  for (let t108 = n10; t108 > 0; t108--) {
    let e11 = s10[t108 - 1];
    if (e11.dom.parentNode == i10) return e11.domAtPos(e11.length);
  }
  for (let t108 = n10; t108 < s10.length; t108++) {
    let e11 = s10[t108];
    if (e11.dom.parentNode == i10) return e11.domAtPos(0);
  }
  return new w2(i10, 0);
}
function bm(t107, e10, i10) {
  let s10 = null, n10 = -1, o10 = null, r10 = -1;
  !function t108(e11, l11) {
    for (let h10 = 0, a10 = 0; h10 < e11.children.length && a10 <= l11; h10++) {
      let c10 = e11.children[h10], d10 = a10 + c10.length;
      d10 >= l11 && (c10.children.length ? t108(c10, l11 - a10) : (!o10 || o10.isHidden && i10 > 0) && (d10 > l11 || a10 == d10 && c10.getSide() > 0) ? (o10 = c10, r10 = l11 - a10) : (a10 < l11 || a10 == d10 && 0 > c10.getSide() && !c10.isHidden) && (s10 = c10, n10 = l11 - a10)), a10 = d10;
    }
  }(t107, e10);
  let l10 = (i10 < 0 ? s10 : o10) || s10 || o10;
  return l10 ? l10.coordsAt(Math.max(0, l10 == s10 ? n10 : r10), i10) : function(t108) {
    let e11 = t108.dom.lastChild;
    if (!e11) return t108.dom.getBoundingClientRect();
    let i11 = wW(e11);
    return i11[i11.length - 1] || null;
  }(t107);
}
function bv(t107, e10) {
  for (let i10 in t107) "class" == i10 && e10.class ? e10.class += " " + t107.class : "style" == i10 && e10.style ? e10.style += ";" + t107.style : e10[i10] = t107[i10];
  return e10;
}
bd.prototype.children = bf.prototype.children = bg.prototype.children = w8;
let bw = /* @__PURE__ */ Object.create(null);
function bb(t107, e10, i10) {
  if (t107 == e10) return true;
  t107 || (t107 = bw), e10 || (e10 = bw);
  let s10 = Object.keys(t107), n10 = Object.keys(e10);
  if (s10.length - (i10 && s10.indexOf(i10) > -1 ? 1 : 0) != n10.length - (i10 && n10.indexOf(i10) > -1 ? 1 : 0)) return false;
  for (let o10 of s10) if (o10 != i10 && (-1 == n10.indexOf(o10) || t107[o10] !== e10[o10])) return false;
  return true;
}
function by(t107, e10, i10) {
  let s10 = false;
  if (e10) for (let n10 in e10) i10 && n10 in i10 || (s10 = true, "style" == n10 ? t107.style.cssText = "" : t107.removeAttribute(n10));
  if (i10) for (let n10 in i10) e10 && e10[n10] == i10[n10] || (s10 = true, "style" == n10 ? t107.style.cssText = i10[n10] : t107.setAttribute(n10, i10[n10]));
  return s10;
}
class bx extends w3 {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  merge(t107, e10, i10, s10, n10, o10) {
    if (i10) {
      if (!(i10 instanceof bx)) return false;
      this.dom || i10.transferDOM(this);
    }
    return s10 && this.setDeco(i10 ? i10.attrs : null), w6(this, t107, e10, i10 ? i10.children.slice() : [], n10, o10), true;
  }
  split(t107) {
    let e10 = new bx();
    if (e10.breakAfter = this.breakAfter, 0 == this.length) return e10;
    let { i: i10, off: s10 } = this.childPos(t107);
    s10 && (e10.append(this.children[i10].split(s10), 0), this.children[i10].merge(s10, this.children[i10].length, null, false, 0, 0), i10++);
    for (let t108 = i10; t108 < this.children.length; t108++) e10.append(this.children[t108], 0);
    for (; i10 > 0 && 0 == this.children[i10 - 1].length; ) this.children[--i10].destroy();
    return this.children.length = i10, this.markDirty(), this.length = t107, e10;
  }
  transferDOM(t107) {
    this.dom && (this.markDirty(), t107.setDOM(this.dom), t107.prevAttrs = void 0 === this.prevAttrs ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(t107) {
    bb(this.attrs, t107) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = t107);
  }
  append(t107, e10) {
    !function t108(e11, i10, s10) {
      let n10, { children: o10 } = e11;
      s10 > 0 && i10 instanceof bu && o10.length && (n10 = o10[o10.length - 1]) instanceof bu && n10.mark.eq(i10.mark) ? t108(n10, i10.children[0], s10 - 1) : (o10.push(i10), i10.setParent(e11)), e11.length += i10.length;
    }(this, t107, e10);
  }
  addLineDeco(t107) {
    let e10 = t107.spec.attributes, i10 = t107.spec.class;
    e10 && (this.attrs = bv(e10, this.attrs || {})), i10 && (this.attrs = bv({ class: i10 }, this.attrs || {}));
  }
  domAtPos(t107) {
    return bp(this, t107);
  }
  reuseDOM(t107) {
    "DIV" == t107.nodeName && (this.setDOM(t107), this.flags |= 6);
  }
  sync(t107, e10) {
    var i10;
    this.dom ? 4 & this.flags && (wQ(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), void 0 !== this.prevAttrs && (by(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(t107, e10);
    let s10 = this.dom.lastChild;
    for (; s10 && w3.get(s10) instanceof bu; ) s10 = s10.lastChild;
    if (!s10 || !this.length || "BR" != s10.nodeName && (null === (i10 = w3.get(s10)) || void 0 === i10 ? void 0 : i10.isEditable) == false && (!bc.ios || !this.children.some((t108) => t108 instanceof bd))) {
      let t108 = document.createElement("BR");
      t108.cmIgnore = true, this.dom.appendChild(t108);
    }
  }
  measureTextSize() {
    if (0 == this.children.length || this.length > 20) return null;
    let t107 = 0, e10;
    for (let i10 of this.children) {
      if (!(i10 instanceof bd) || /[^ -~]/.test(i10.text)) return null;
      let s10 = wW(i10.dom);
      if (1 != s10.length) return null;
      t107 += s10[0].width, e10 = s10[0].height;
    }
    return t107 ? { lineHeight: this.dom.getBoundingClientRect().height, charWidth: t107 / this.length, textHeight: e10 } : null;
  }
  coordsAt(t107, e10) {
    let i10 = bm(this, t107, e10);
    if (!this.children.length && i10 && this.parent) {
      let { heightOracle: t108 } = this.parent.view.viewState, e11 = i10.bottom - i10.top;
      if (2 > Math.abs(e11 - t108.lineHeight) && t108.textHeight < e11) {
        let s10 = (e11 - t108.textHeight) / 2;
        return { top: i10.top + s10, bottom: i10.bottom - s10, left: i10.left, right: i10.left };
      }
    }
    return i10;
  }
  become(t107) {
    return false;
  }
  covers() {
    return true;
  }
  static find(t107, e10) {
    for (let i10 = 0, s10 = 0; i10 < t107.children.length; i10++) {
      let n10 = t107.children[i10], o10 = s10 + n10.length;
      if (o10 >= e10) {
        if (n10 instanceof bx) return n10;
        if (o10 > e10) break;
      }
      s10 = o10 + n10.breakAfter;
    }
    return null;
  }
}
class bS extends w3 {
  constructor(t107, e10, i10) {
    super(), this.widget = t107, this.length = e10, this.deco = i10, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(t107, e10, i10, s10, n10, o10) {
    return (!i10 || i10 instanceof bS && !!this.widget.compare(i10.widget) && (!(t107 > 0) || !(n10 <= 0)) && (!(e10 < this.length) || !(o10 <= 0))) && (this.length = t107 + (i10 ? i10.length : 0) + (this.length - e10), true);
  }
  domAtPos(t107) {
    return 0 == t107 ? w2.before(this.dom) : w2.after(this.dom, t107 == this.length);
  }
  split(t107) {
    let e10 = this.length - t107;
    this.length = t107;
    let i10 = new bS(this.widget, e10, this.deco);
    return i10.breakAfter = this.breakAfter, i10;
  }
  get children() {
    return w8;
  }
  sync(t107) {
    this.dom && this.widget.updateDOM(this.dom, t107) || (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t107)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : r.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(t107) {
    return t107 instanceof bS && t107.widget.constructor == this.widget.constructor && (t107.widget.compare(this.widget) || this.markDirty(true), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = t107.widget, this.length = t107.length, this.deco = t107.deco, this.breakAfter = t107.breakAfter, true);
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(t107) {
    return this.widget.ignoreEvent(t107);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  coordsAt(t107, e10) {
    return this.widget.coordsAt(this.dom, t107, e10);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(t107) {
    let { startSide: e10, endSide: i10 } = this.deco;
    return e10 != i10 && (t107 < 0 ? e10 < 0 : i10 > 0);
  }
}
class bk {
  eq(t107) {
    return false;
  }
  updateDOM(t107, e10) {
    return false;
  }
  compare(t107) {
    return this == t107 || this.constructor == t107.constructor && this.eq(t107);
  }
  get estimatedHeight() {
    return -1;
  }
  get lineBreaks() {
    return 0;
  }
  ignoreEvent(t107) {
    return true;
  }
  coordsAt(t107, e10, i10) {
    return null;
  }
  get isHidden() {
    return false;
  }
  get editable() {
    return false;
  }
  destroy(t107) {
  }
}
var bM = ((I = bM || (bM = {}))[I.Text = 0] = "Text", I[I.WidgetBefore = 1] = "WidgetBefore", I[I.WidgetAfter = 2] = "WidgetAfter", I[I.WidgetRange = 3] = "WidgetRange", I);
class bC extends tz {
  constructor(t107, e10, i10, s10) {
    super(), this.startSide = t107, this.endSide = e10, this.widget = i10, this.spec = s10;
  }
  get heightRelevant() {
    return false;
  }
  static mark(t107) {
    return new bA(t107);
  }
  static widget(t107) {
    let e10 = Math.max(-1e4, Math.min(1e4, t107.side || 0)), i10 = !!t107.block;
    return e10 += i10 && !t107.inlineOrder ? e10 > 0 ? 3e8 : -4e8 : e10 > 0 ? 1e8 : -1e8, new bO(t107, e10, e10, i10, t107.widget || null, false);
  }
  static replace(t107) {
    let e10 = !!t107.block, i10, s10;
    if (t107.isBlockGap) i10 = -5e8, s10 = 4e8;
    else {
      let { start: n10, end: o10 } = bT(t107, e10);
      i10 = (n10 ? e10 ? -3e8 : -1 : 5e8) - 1, s10 = (o10 ? e10 ? 2e8 : 1 : -6e8) + 1;
    }
    return new bO(t107, i10, s10, e10, t107.widget || null, true);
  }
  static line(t107) {
    return new bD(t107);
  }
  static set(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return tG.of(t107, e10);
  }
  hasHeight() {
    return !!this.widget && this.widget.estimatedHeight > -1;
  }
}
bC.none = tG.empty;
class bA extends bC {
  constructor(t107) {
    let { start: e10, end: i10 } = bT(t107);
    super(e10 ? -1 : 5e8, i10 ? 1 : -6e8, null, t107), this.tagName = t107.tagName || "span", this.class = t107.class || "", this.attrs = t107.attributes || null;
  }
  eq(t107) {
    var e10, i10;
    return this == t107 || t107 instanceof bA && this.tagName == t107.tagName && (this.class || (null === (e10 = this.attrs) || void 0 === e10 ? void 0 : e10.class)) == (t107.class || (null === (i10 = t107.attrs) || void 0 === i10 ? void 0 : i10.class)) && bb(this.attrs, t107.attrs, "class");
  }
  range(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t107;
    if (t107 >= e10) throw RangeError("Mark decorations may not be empty");
    return super.range(t107, e10);
  }
}
bA.prototype.point = false;
class bD extends bC {
  constructor(t107) {
    super(-2e8, -2e8, null, t107);
  }
  eq(t107) {
    return t107 instanceof bD && this.spec.class == t107.spec.class && bb(this.spec.attributes, t107.spec.attributes);
  }
  range(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t107;
    if (e10 != t107) throw RangeError("Line decoration ranges must be zero-length");
    return super.range(t107, e10);
  }
}
bD.prototype.mapMode = j.TrackBefore, bD.prototype.point = true;
class bO extends bC {
  constructor(t107, e10, i10, s10, n10, o10) {
    super(e10, i10, n10, t107), this.block = s10, this.isReplace = o10, this.mapMode = s10 ? e10 <= 0 ? j.TrackBefore : j.TrackAfter : j.TrackDel;
  }
  get type() {
    return this.startSide != this.endSide ? bM.WidgetRange : this.startSide <= 0 ? bM.WidgetBefore : bM.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(t107) {
    var e10, i10;
    return t107 instanceof bO && ((e10 = this.widget) == (i10 = t107.widget) || !!(e10 && i10 && e10.compare(i10))) && this.block == t107.block && this.startSide == t107.startSide && this.endSide == t107.endSide;
  }
  range(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t107;
    if (this.isReplace && (t107 > e10 || t107 == e10 && this.startSide > 0 && this.endSide <= 0)) throw RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && e10 != t107) throw RangeError("Widget decorations can only have zero-length ranges");
    return super.range(t107, e10);
  }
}
function bT(t107) {
  let e10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], { inclusiveStart: i10, inclusiveEnd: s10 } = t107;
  return null == i10 && (i10 = t107.inclusive), null == s10 && (s10 = t107.inclusive), { start: null != i10 ? i10 : e10, end: null != s10 ? s10 : e10 };
}
function bE(t107, e10, i10) {
  let s10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, n10 = i10.length - 1;
  n10 >= 0 && i10[n10] + s10 >= t107 ? i10[n10] = Math.max(i10[n10], e10) : i10.push(t107, e10);
}
bO.prototype.point = true;
class bR {
  constructor(t107, e10, i10, s10) {
    this.doc = t107, this.pos = e10, this.end = i10, this.disallowBlockEffectsFor = s10, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = true, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = t107.iter(), this.skip = e10;
  }
  posCovered() {
    if (0 == this.content.length) return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let t107 = this.content[this.content.length - 1];
    return !(t107.breakAfter || t107 instanceof bS && t107.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new bx()), this.atCursorPos = true), this.curLine;
  }
  flushBuffer() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.bufferMarks;
    this.pendingBuffer && (this.curLine.append(bB(new bg(-1), t107), t107.length), this.pendingBuffer = 0);
  }
  addBlockWidget(t107) {
    this.flushBuffer(), this.curLine = null, this.content.push(t107);
  }
  finish(t107) {
    this.pendingBuffer && t107 <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, this.posCovered() || t107 && this.content.length && this.content[this.content.length - 1] instanceof bS || this.getLine();
  }
  buildText(t107, e10, i10) {
    for (; t107 > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: e11, lineBreak: i11, done: s11 } = this.cursor.next(this.skip);
        if (this.skip = 0, s11) throw Error("Ran out of text content when drawing inline views");
        if (i11) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = true, t107--;
          continue;
        }
        this.text = e11, this.textOff = 0;
      }
      let s10 = Math.min(this.text.length - this.textOff, t107, 512);
      this.flushBuffer(e10.slice(e10.length - i10)), this.getLine().append(bB(new bd(this.text.slice(this.textOff, this.textOff + s10)), e10), i10), this.atCursorPos = true, this.textOff += s10, t107 -= s10, i10 = 0;
    }
  }
  span(t107, e10, i10, s10) {
    this.buildText(e10 - t107, i10, s10), this.pos = e10, this.openStart < 0 && (this.openStart = s10);
  }
  point(t107, e10, i10, s10, n10, o10) {
    if (this.disallowBlockEffectsFor[o10] && i10 instanceof bO) {
      if (i10.block) throw RangeError("Block decorations may not be specified via plugins");
      if (e10 > this.doc.lineAt(this.pos).to) throw RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let r10 = e10 - t107;
    if (i10 instanceof bO) {
      if (i10.block) i10.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new bS(i10.widget || bL.block, r10, i10));
      else {
        let o11 = bf.create(i10.widget || bL.inline, r10, r10 ? 0 : i10.startSide), l10 = this.atCursorPos && !o11.isEditable && n10 <= s10.length && (t107 < e10 || i10.startSide > 0), h10 = !o11.isEditable && (t107 < e10 || n10 > s10.length || i10.startSide <= 0), a10 = this.getLine();
        2 != this.pendingBuffer || l10 || o11.isEditable || (this.pendingBuffer = 0), this.flushBuffer(s10), l10 && (a10.append(bB(new bg(1), s10), n10), n10 = s10.length + Math.max(0, n10 - s10.length)), a10.append(bB(o11, s10), n10), this.atCursorPos = h10, this.pendingBuffer = h10 ? t107 < e10 || n10 > s10.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = s10.slice());
      }
    } else this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i10);
    r10 && (this.textOff + r10 <= this.text.length ? this.textOff += r10 : (this.skip += r10 - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = e10), this.openStart < 0 && (this.openStart = n10);
  }
  static build(t107, e10, i10, s10, n10) {
    let o10 = new bR(t107, e10, i10, n10);
    return o10.openEnd = tG.spans(s10, e10, i10, o10), o10.openStart < 0 && (o10.openStart = o10.openEnd), o10.finish(o10.openEnd), o10;
  }
}
function bB(t107, e10) {
  for (let i10 of e10) t107 = new bu(i10, [t107], t107.length);
  return t107;
}
class bL extends bk {
  constructor(t107) {
    super(), this.tag = t107;
  }
  eq(t107) {
    return t107.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(t107) {
    return t107.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return true;
  }
}
bL.inline = new bL("span"), bL.block = new bL("div");
var bP = ((z = bP || (bP = {}))[z.LTR = 0] = "LTR", z[z.RTL = 1] = "RTL", z);
let bN = bP.LTR, bV = bP.RTL;
function bH(t107) {
  let e10 = [];
  for (let i10 = 0; i10 < t107.length; i10++) e10.push(1 << +t107[i10]);
  return e10;
}
let bF = bH("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), bW = bH("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), bI = /* @__PURE__ */ Object.create(null), bz = [];
for (let t107 of ["()", "[]", "{}"]) {
  let e10 = t107.charCodeAt(0), i10 = t107.charCodeAt(1);
  bI[e10] = i10, bI[i10] = -e10;
}
function bK(t107) {
  return t107 <= 247 ? bF[t107] : 1424 <= t107 && t107 <= 1524 ? 2 : 1536 <= t107 && t107 <= 1785 ? bW[t107 - 1536] : 1774 <= t107 && t107 <= 2220 ? 4 : 8192 <= t107 && t107 <= 8204 ? 256 : 64336 <= t107 && t107 <= 65023 ? 4 : 1;
}
let bq = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class b_ {
  get dir() {
    return this.level % 2 ? bV : bN;
  }
  constructor(t107, e10, i10) {
    this.from = t107, this.to = e10, this.level = i10;
  }
  side(t107, e10) {
    return this.dir == e10 == t107 ? this.to : this.from;
  }
  forward(t107, e10) {
    return t107 == (this.dir == e10);
  }
  static find(t107, e10, i10, s10) {
    let n10 = -1;
    for (let o10 = 0; o10 < t107.length; o10++) {
      let r10 = t107[o10];
      if (r10.from <= e10 && r10.to >= e10) {
        if (r10.level == i10) return o10;
        (n10 < 0 || (0 != s10 ? s10 < 0 ? r10.from < e10 : r10.to > e10 : t107[n10].level > r10.level)) && (n10 = o10);
      }
    }
    if (n10 < 0) throw RangeError("Index out of range");
    return n10;
  }
}
let bG = [];
function bj(t107) {
  return [new b_(0, t107, 0)];
}
let bU = "", bY = to.define(), b$ = to.define(), bX = to.define(), bJ = to.define(), bQ = to.define(), bZ = to.define(), b0 = to.define(), b1 = to.define({ combine: (t107) => t107.some((t108) => t108) }), b2 = to.define({ combine: (t107) => t107.some((t108) => t108) }), b8 = to.define();
class b3 {
  constructor(t107, e10 = "nearest", i10 = "nearest", s10 = 5, n10 = 5, o10 = false) {
    this.range = t107, this.y = e10, this.x = i10, this.yMargin = s10, this.xMargin = n10, this.isSnapshot = o10;
  }
  map(t107) {
    return t107.empty ? this : new b3(this.range.map(t107), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(t107) {
    return this.range.to <= t107.doc.length ? this : new b3(ti.cursor(t107.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
let b4 = tR.define({ map: (t107, e10) => t107.map(e10) });
function b9(t107, e10, i10) {
  let s10 = t107.facet(bJ);
  s10.length ? s10[0](e10) : window.onerror ? window.onerror(String(e10), i10, void 0, void 0, e10) : i10 ? console.error(i10 + ":", e10) : console.error(e10);
}
let b5 = to.define({ combine: (t107) => !t107.length || t107[0] }), b6 = 0, b7 = to.define();
class yt {
  constructor(t107, e10, i10, s10, n10) {
    this.id = t107, this.create = e10, this.domEventHandlers = i10, this.domEventObservers = s10, this.extension = n10(this);
  }
  static define(t107, e10) {
    let { eventHandlers: i10, eventObservers: s10, provide: n10, decorations: o10 } = e10 || {};
    return new yt(b6++, t107, i10, s10, (t108) => {
      let e11 = [b7.of(t108)];
      return o10 && e11.push(yn.of((e12) => {
        let i11 = e12.plugin(t108);
        return i11 ? o10(i11) : bC.none;
      })), n10 && e11.push(n10(t108)), e11;
    });
  }
  static fromClass(t107, e10) {
    return yt.define((e11) => new t107(e11), e10);
  }
}
class ye {
  constructor(t107) {
    this.spec = t107, this.mustUpdate = null, this.value = null;
  }
  update(t107) {
    if (this.value) {
      if (this.mustUpdate) {
        let t108 = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update) try {
          this.value.update(t108);
        } catch (e10) {
          if (b9(t108.state, e10, "CodeMirror plugin crashed"), this.value.destroy) try {
            this.value.destroy();
          } catch (t109) {
          }
          this.deactivate();
        }
      }
    } else if (this.spec) try {
      this.value = this.spec.create(t107);
    } catch (e10) {
      b9(t107.state, e10, "CodeMirror plugin crashed"), this.deactivate();
    }
    return this;
  }
  destroy(t107) {
    var e10;
    if (null === (e10 = this.value) || void 0 === e10 ? void 0 : e10.destroy) try {
      this.value.destroy();
    } catch (e11) {
      b9(t107.state, e11, "CodeMirror plugin crashed");
    }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
let yi = to.define(), ys = to.define(), yn = to.define(), yo = to.define(), yr = to.define(), yl = to.define();
function yh(t107, e10) {
  let i10 = t107.state.facet(yl);
  if (!i10.length) return i10;
  let s10 = i10.map((e11) => e11 instanceof Function ? e11(t107) : e11), n10 = [];
  return tG.spans(s10, e10.from, e10.to, { point() {
  }, span(t108, i11, s11, o10) {
    let r10 = t108 - e10.from, l10 = i11 - e10.from, h10 = n10;
    for (let t109 = s11.length - 1; t109 >= 0; t109--, o10--) {
      let i12 = s11[t109].spec.bidiIsolate, n11;
      if (null == i12 && (i12 = function(t110, e11, i13) {
        for (let s12 = e11; s12 < i13; s12++) {
          let e12 = bK(t110.charCodeAt(s12));
          if (1 == e12) break;
          if (2 == e12 || 4 == e12) return bV;
        }
        return bN;
      }(e10.text, r10, l10)), o10 > 0 && h10.length && (n11 = h10[h10.length - 1]).to == r10 && n11.direction == i12) n11.to = l10, h10 = n11.inner;
      else {
        let t110 = { from: r10, to: l10, direction: i12, inner: [] };
        h10.push(t110), h10 = t110.inner;
      }
    }
  } }), n10;
}
let ya = to.define();
function yc(t107) {
  let e10 = 0, i10 = 0, s10 = 0, n10 = 0;
  for (let o10 of t107.state.facet(ya)) {
    let r10 = o10(t107);
    r10 && (null != r10.left && (e10 = Math.max(e10, r10.left)), null != r10.right && (i10 = Math.max(i10, r10.right)), null != r10.top && (s10 = Math.max(s10, r10.top)), null != r10.bottom && (n10 = Math.max(n10, r10.bottom)));
  }
  return { left: e10, right: i10, top: s10, bottom: n10 };
}
let yd = to.define();
class yu {
  constructor(t107, e10, i10, s10) {
    this.fromA = t107, this.toA = e10, this.fromB = i10, this.toB = s10;
  }
  join(t107) {
    return new yu(Math.min(this.fromA, t107.fromA), Math.max(this.toA, t107.toA), Math.min(this.fromB, t107.fromB), Math.max(this.toB, t107.toB));
  }
  addToSet(t107) {
    let e10 = t107.length, i10 = this;
    for (; e10 > 0; e10--) {
      let s10 = t107[e10 - 1];
      if (!(s10.fromA > i10.toA)) {
        if (s10.toA < i10.fromA) break;
        i10 = i10.join(s10), t107.splice(e10 - 1, 1);
      }
    }
    return t107.splice(e10, 0, i10), t107;
  }
  static extendWithRanges(t107, e10) {
    if (0 == e10.length) return t107;
    let i10 = [];
    for (let s10 = 0, n10 = 0, o10 = 0, r10 = 0; ; s10++) {
      let l10 = s10 == t107.length ? null : t107[s10], h10 = o10 - r10, a10 = l10 ? l10.fromB : 1e9;
      for (; n10 < e10.length && e10[n10] < a10; ) {
        let t108 = e10[n10], s11 = e10[n10 + 1], o11 = Math.max(r10, t108), l11 = Math.min(a10, s11);
        if (o11 <= l11 && new yu(o11 + h10, l11 + h10, o11, l11).addToSet(i10), s11 > a10) break;
        n10 += 2;
      }
      if (!l10) return i10;
      new yu(l10.fromA, l10.toA, l10.fromB, l10.toB).addToSet(i10), o10 = l10.toA, r10 = l10.toB;
    }
  }
}
class yf {
  constructor(t107, e10, i10) {
    for (let s11 of (this.view = t107, this.state = e10, this.transactions = i10, this.flags = 0, this.startState = t107.state, this.changes = Y.empty(this.startState.doc.length), i10)) this.changes = this.changes.compose(s11.changes);
    let s10 = [];
    this.changes.iterChangedRanges((t108, e11, i11, n10) => s10.push(new yu(t108, e11, i11, n10))), this.changedRanges = s10;
  }
  static create(t107, e10, i10) {
    return new yf(t107, e10, i10);
  }
  get viewportChanged() {
    return (4 & this.flags) > 0;
  }
  get heightChanged() {
    return (2 & this.flags) > 0;
  }
  get geometryChanged() {
    return this.docChanged || (10 & this.flags) > 0;
  }
  get focusChanged() {
    return (1 & this.flags) > 0;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get selectionSet() {
    return this.transactions.some((t107) => t107.selection);
  }
  get empty() {
    return 0 == this.flags && 0 == this.transactions.length;
  }
}
class yg extends w3 {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(t107) {
    super(), this.view = t107, this.decorations = [], this.dynamicDecorationMap = [], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.lastCompositionAfterCursor = false, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = false, this.lastUpdate = Date.now(), this.setDOM(t107.contentDOM), this.children = [new bx()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new yu(0, 0, 0, t107.state.doc.length)], 0, null);
  }
  update(t107) {
    var e10, i10, s10, n10, o10, r10;
    let l10, h10;
    let a10 = t107.changedRanges;
    this.minWidth > 0 && a10.length && (a10.every((t108) => {
      let { fromA: e11, toA: i11 } = t108;
      return i11 < this.minWidthFrom || e11 > this.minWidthTo;
    }) ? (this.minWidthFrom = t107.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = t107.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0);
    let c10 = -1;
    !(this.view.inputState.composing >= 0) || ((null === (e10 = this.domChanged) || void 0 === e10 ? void 0 : e10.newSel) ? c10 = this.domChanged.newSel.head : (i10 = t107.changes, s10 = this.hasComposition, l10 = false, s10 && i10.iterChangedRanges((t108, e11) => {
      t108 < s10.to && e11 > s10.from && (l10 = true);
    }), l10 || t107.selectionSet || (c10 = t107.state.selection.main.head)));
    let d10 = c10 > -1 ? function(t108, e11, i11) {
      let s11 = ym(t108, i11);
      if (!s11) return null;
      let { node: n11, from: o11, to: r11 } = s11, l11 = n11.nodeValue;
      if (/[\n\r]/.test(l11) || t108.state.doc.sliceString(s11.from, s11.to) != l11) return null;
      let h11 = e11.invertedDesc, a11 = new yu(h11.mapPos(o11), h11.mapPos(r11), o11, r11), c11 = [];
      for (let e12 = n11.parentNode; ; e12 = e12.parentNode) {
        let i12 = w3.get(e12);
        if (i12 instanceof bu) c11.push({ node: e12, deco: i12.mark });
        else {
          if (i12 instanceof bx || "DIV" == e12.nodeName && e12.parentNode == t108.contentDOM) return { range: a11, text: n11, marks: c11, line: e12 };
          if (e12 == t108.contentDOM) return null;
          c11.push({ node: e12, deco: new bA({ inclusive: true, attributes: function(t109) {
            let e13 = /* @__PURE__ */ Object.create(null);
            for (let i13 = 0; i13 < t109.attributes.length; i13++) {
              let s12 = t109.attributes[i13];
              e13[s12.name] = s12.value;
            }
            return e13;
          }(e12), tagName: e12.tagName.toLowerCase() }) });
        }
      }
    }(this.view, t107.changes, c10) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: e11, to: i11 } = this.hasComposition;
      a10 = new yu(e11, i11, t107.changes.mapPos(e11, -1), t107.changes.mapPos(i11, 1)).addToSet(a10.slice());
    }
    this.hasComposition = d10 ? { from: d10.range.fromB, to: d10.range.toB } : null, (bc.ie || bc.chrome) && !d10 && t107 && t107.state.doc.lines != t107.startState.doc.lines && (this.forceSelection = true);
    let u10 = (n10 = this.decorations, o10 = this.updateDeco(), r10 = t107.changes, h10 = new yv(), tG.compare(n10, o10, r10, h10), h10.changes);
    return a10 = yu.extendWithRanges(a10, u10), (!!(7 & this.flags) || 0 != a10.length) && (this.updateInner(a10, t107.startState.doc.length, d10), t107.transactions.length && (this.lastUpdate = Date.now()), true);
  }
  updateInner(t107, e10, i10) {
    this.view.viewState.mustMeasureContent = true, this.updateChildren(t107, e10, i10);
    let { observer: s10 } = this.view;
    s10.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let t108 = bc.chrome || bc.ios ? { node: s10.selectionRange.focusNode, written: false } : void 0;
      this.sync(this.view, t108), this.flags &= -8, t108 && (t108.written || s10.selectionRange.focusNode != t108.node) && (this.forceSelection = true), this.dom.style.height = "";
    }), this.markedForComposition.forEach((t108) => t108.flags &= -9);
    let n10 = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) for (let t108 of this.children) t108 instanceof bS && t108.widget instanceof yp && n10.push(t108.dom);
    s10.updateGaps(n10);
  }
  updateChildren(t107, e10, i10) {
    let s10 = i10 ? i10.range.addToSet(t107.slice()) : t107, n10 = this.childCursor(e10);
    for (let t108 = s10.length - 1; ; t108--) {
      let e11 = t108 >= 0 ? s10[t108] : null;
      if (!e11) break;
      let { fromA: o10, toA: r10, fromB: l10, toB: h10 } = e11, a10, c10, d10, u10;
      if (i10 && i10.range.fromB < h10 && i10.range.toB > l10) {
        let t109 = bR.build(this.view.state.doc, l10, i10.range.fromB, this.decorations, this.dynamicDecorationMap), e12 = bR.build(this.view.state.doc, i10.range.toB, h10, this.decorations, this.dynamicDecorationMap);
        c10 = t109.breakAtStart, d10 = t109.openStart, u10 = e12.openEnd;
        let s11 = this.compositionView(i10);
        e12.breakAtStart ? s11.breakAfter = 1 : e12.content.length && s11.merge(s11.length, s11.length, e12.content[0], false, e12.openStart, 0) && (s11.breakAfter = e12.content[0].breakAfter, e12.content.shift()), t109.content.length && s11.merge(0, 0, t109.content[t109.content.length - 1], true, 0, t109.openEnd) && t109.content.pop(), a10 = t109.content.concat(s11).concat(e12.content);
      } else ({ content: a10, breakAtStart: c10, openStart: d10, openEnd: u10 } = bR.build(this.view.state.doc, l10, h10, this.decorations, this.dynamicDecorationMap));
      let { i: f10, off: g10 } = n10.findPos(r10, 1), { i: p10, off: m10 } = n10.findPos(o10, -1);
      w5(this, p10, m10, f10, g10, a10, c10, d10, u10);
    }
    i10 && this.fixCompositionDOM(i10);
  }
  compositionView(t107) {
    let e10 = new bd(t107.text.nodeValue);
    for (let { deco: i11 } of (e10.flags |= 8, t107.marks)) e10 = new bu(i11, [e10], e10.length);
    let i10 = new bx();
    return i10.append(e10, 0), i10;
  }
  fixCompositionDOM(t107) {
    let e10 = (t108, e11) => {
      e11.flags |= 8 | (e11.children.some((t109) => 7 & t109.flags) ? 1 : 0), this.markedForComposition.add(e11);
      let i11 = w3.get(t108);
      i11 && i11 != e11 && (i11.dom = null), e11.setDOM(t108);
    }, i10 = this.childPos(t107.range.fromB, 1), s10 = this.children[i10.i];
    e10(t107.line, s10);
    for (let n10 = t107.marks.length - 1; n10 >= -1; n10--) i10 = s10.childPos(i10.off, 1), s10 = s10.children[i10.i], e10(n10 >= 0 ? t107.marks[n10].node : t107.text, s10);
  }
  updateSelection() {
    var t107;
    let e10 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], i10 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    (e10 || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let s10 = this.view.root.activeElement, n10 = s10 == this.dom, o10 = !n10 && wF(this.dom, this.view.observer.selectionRange) && !(s10 && this.dom.contains(s10));
    if (!(n10 || i10 || o10)) return;
    let r10 = this.forceSelection;
    this.forceSelection = false;
    let l10 = this.view.state.selection.main, h10 = this.moveToLine(this.domAtPos(l10.anchor)), a10 = l10.empty ? h10 : this.moveToLine(this.domAtPos(l10.head));
    if (bc.gecko && l10.empty && !this.hasComposition && 1 == (t107 = h10).node.nodeType && t107.node.firstChild && (0 == t107.offset || "false" == t107.node.childNodes[t107.offset - 1].contentEditable) && (t107.offset == t107.node.childNodes.length || "false" == t107.node.childNodes[t107.offset].contentEditable)) {
      let t108 = document.createTextNode("");
      this.view.observer.ignore(() => h10.node.insertBefore(t108, h10.node.childNodes[h10.offset] || null)), h10 = a10 = new w2(t108, 0), r10 = true;
    }
    let c10 = this.view.observer.selectionRange;
    !r10 && c10.focusNode && (wI(h10.node, h10.offset, c10.anchorNode, c10.anchorOffset) && wI(a10.node, a10.offset, c10.focusNode, c10.focusOffset) || this.suppressWidgetCursorChange(c10, l10)) || (this.view.observer.ignore(() => {
      bc.android && bc.chrome && this.dom.contains(c10.focusNode) && function(t109, e12) {
        for (let i12 = t109; i12 && i12 != e12; i12 = i12.assignedSlot || i12.parentNode) if (1 == i12.nodeType && "false" == i12.contentEditable) return true;
        return false;
      }(c10.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: true }));
      let t108 = wV(this.view.root);
      if (t108) {
        if (l10.empty) {
          if (bc.gecko) {
            var e11, i11;
            let t109 = (e11 = h10.node, i11 = h10.offset, 1 != e11.nodeType ? 0 : (i11 && "false" == e11.childNodes[i11 - 1].contentEditable ? 1 : 0) | (i11 < e11.childNodes.length && "false" == e11.childNodes[i11].contentEditable ? 2 : 0));
            if (t109 && 3 != t109) {
              let e12 = (1 == t109 ? w0 : w1)(h10.node, h10.offset);
              e12 && (h10 = new w2(e12.node, e12.offset));
            }
          }
          t108.collapse(h10.node, h10.offset), null != l10.bidiLevel && void 0 !== t108.caretBidiLevel && (t108.caretBidiLevel = l10.bidiLevel);
        } else if (t108.extend) {
          t108.collapse(h10.node, h10.offset);
          try {
            t108.extend(a10.node, a10.offset);
          } catch (t109) {
          }
        } else {
          let e12 = document.createRange();
          l10.anchor > l10.head && ([h10, a10] = [a10, h10]), e12.setEnd(a10.node, a10.offset), e12.setStart(h10.node, h10.offset), t108.removeAllRanges(), t108.addRange(e12);
        }
      }
      o10 && this.view.root.activeElement == this.dom && (this.dom.blur(), s10 && s10.focus());
    }), this.view.observer.setSelectionRange(h10, a10)), this.impreciseAnchor = h10.precise ? null : new w2(c10.anchorNode, c10.anchorOffset), this.impreciseHead = a10.precise ? null : new w2(c10.focusNode, c10.focusOffset);
  }
  suppressWidgetCursorChange(t107, e10) {
    return this.hasComposition && e10.empty && wI(t107.focusNode, t107.focusOffset, t107.anchorNode, t107.anchorOffset) && this.posFromDOM(t107.focusNode, t107.focusOffset) == e10.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition) return;
    let { view: t107 } = this, e10 = t107.state.selection.main, i10 = wV(t107.root), { anchorNode: s10, anchorOffset: n10 } = t107.observer.selectionRange;
    if (!i10 || !e10.empty || !e10.assoc || !i10.modify) return;
    let o10 = bx.find(this, e10.head);
    if (!o10) return;
    let r10 = o10.posAtStart;
    if (e10.head == r10 || e10.head == r10 + o10.length) return;
    let l10 = this.coordsAt(e10.head, -1), h10 = this.coordsAt(e10.head, 1);
    if (!l10 || !h10 || l10.bottom > h10.top) return;
    let a10 = this.domAtPos(e10.head + e10.assoc);
    i10.collapse(a10.node, a10.offset), i10.modify("move", e10.assoc < 0 ? "forward" : "backward", "lineboundary"), t107.observer.readSelectionRange();
    let c10 = t107.observer.selectionRange;
    t107.docView.posFromDOM(c10.anchorNode, c10.anchorOffset) != e10.from && i10.collapse(s10, n10);
  }
  moveToLine(t107) {
    let e10 = this.dom, i10;
    if (t107.node != e10) return t107;
    for (let s10 = t107.offset; !i10 && s10 < e10.childNodes.length; s10++) {
      let t108 = w3.get(e10.childNodes[s10]);
      t108 instanceof bx && (i10 = t108.domAtPos(0));
    }
    for (let s10 = t107.offset - 1; !i10 && s10 >= 0; s10--) {
      let t108 = w3.get(e10.childNodes[s10]);
      t108 instanceof bx && (i10 = t108.domAtPos(t108.length));
    }
    return i10 ? new w2(i10.node, i10.offset, true) : t107;
  }
  nearest(t107) {
    for (let e10 = t107; e10; ) {
      let t108 = w3.get(e10);
      if (t108 && t108.rootView == this) return t108;
      e10 = e10.parentNode;
    }
    return null;
  }
  posFromDOM(t107, e10) {
    let i10 = this.nearest(t107);
    if (!i10) throw RangeError("Trying to find position for a DOM position outside of the document");
    return i10.localPosFromDOM(t107, e10) + i10.posAtStart;
  }
  domAtPos(t107) {
    let { i: e10, off: i10 } = this.childCursor().findPos(t107, -1);
    for (; e10 < this.children.length - 1; ) {
      let t108 = this.children[e10];
      if (i10 < t108.length || t108 instanceof bx) break;
      e10++, i10 = 0;
    }
    return this.children[e10].domAtPos(i10);
  }
  coordsAt(t107, e10) {
    let i10 = null, s10 = 0;
    for (let n10 = this.length, o10 = this.children.length - 1; o10 >= 0; o10--) {
      let r10 = this.children[o10], l10 = n10 - r10.breakAfter, h10 = l10 - r10.length;
      if (l10 < t107) break;
      if (h10 <= t107 && (h10 < t107 || r10.covers(-1)) && (l10 > t107 || r10.covers(1)) && (!i10 || r10 instanceof bx && !(i10 instanceof bx && e10 >= 0))) i10 = r10, s10 = h10;
      else if (i10 && h10 == t107 && l10 == t107 && r10 instanceof bS && 2 > Math.abs(e10)) {
        if (r10.deco.startSide < 0) break;
        o10 && (i10 = null);
      }
      n10 = h10;
    }
    return i10 ? i10.coordsAt(t107 - s10, e10) : null;
  }
  coordsForChar(t107) {
    let { i: e10, off: i10 } = this.childPos(t107, 1), s10 = this.children[e10];
    if (!(s10 instanceof bx)) return null;
    for (; s10.children.length; ) {
      let { i: t108, off: e11 } = s10.childPos(i10, 1);
      for (; ; t108++) {
        if (t108 == s10.children.length) return null;
        if ((s10 = s10.children[t108]).length) break;
      }
      i10 = e11;
    }
    if (!(s10 instanceof bd)) return null;
    let n10 = v(s10.text, i10);
    if (n10 == i10) return null;
    let o10 = wX(s10.dom, i10, n10).getClientRects();
    for (let t108 = 0; t108 < o10.length; t108++) {
      let e11 = o10[t108];
      if (t108 == o10.length - 1 || e11.top < e11.bottom && e11.left < e11.right) return e11;
    }
    return null;
  }
  measureVisibleLineHeights(t107) {
    let e10 = [], { from: i10, to: s10 } = t107, n10 = this.view.contentDOM.clientWidth, o10 = n10 > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, r10 = -1, l10 = this.view.textDirection == bP.LTR;
    for (let t108 = 0, h10 = 0; h10 < this.children.length; h10++) {
      let a10 = this.children[h10], c10 = t108 + a10.length;
      if (c10 > s10) break;
      if (t108 >= i10) {
        let i11 = a10.dom.getBoundingClientRect();
        if (e10.push(i11.height), o10) {
          let e11 = a10.dom.lastChild, s11 = e11 ? wW(e11) : [];
          if (s11.length) {
            let e12 = s11[s11.length - 1], o11 = l10 ? e12.right - i11.left : i11.right - e12.left;
            o11 > r10 && (r10 = o11, this.minWidth = n10, this.minWidthFrom = t108, this.minWidthTo = c10);
          }
        }
      }
      t108 = c10 + a10.breakAfter;
    }
    return e10;
  }
  textDirectionAt(t107) {
    let { i: e10 } = this.childPos(t107, 1);
    return "rtl" == getComputedStyle(this.children[e10].dom).direction ? bP.RTL : bP.LTR;
  }
  measureTextSize() {
    for (let t108 of this.children) if (t108 instanceof bx) {
      let e11 = t108.measureTextSize();
      if (e11) return e11;
    }
    let t107 = document.createElement("div"), e10, i10, s10;
    return t107.className = "cm-line", t107.style.width = "99999px", t107.style.position = "absolute", t107.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(t107);
      let n10 = wW(t107.firstChild)[0];
      e10 = t107.getBoundingClientRect().height, i10 = n10 ? n10.width / 27 : 7, s10 = n10 ? n10.height : e10, t107.remove();
    }), { lineHeight: e10, charWidth: i10, textHeight: s10 };
  }
  childCursor() {
    let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.length, e10 = this.children.length;
    return e10 && (t107 -= this.children[--e10].length), new w9(this.children, t107, e10);
  }
  computeBlockGapDeco() {
    let t107 = [], e10 = this.view.viewState;
    for (let i10 = 0, s10 = 0; ; s10++) {
      let n10 = s10 == e10.viewports.length ? null : e10.viewports[s10], o10 = n10 ? n10.from - 1 : this.length;
      if (o10 > i10) {
        let s11 = (e10.lineBlockAt(o10).bottom - e10.lineBlockAt(i10).top) / this.view.scaleY;
        t107.push(bC.replace({ widget: new yp(s11), block: true, inclusive: true, isBlockGap: true }).range(i10, o10));
      }
      if (!n10) break;
      i10 = n10.to + 1;
    }
    return bC.set(t107);
  }
  updateDeco() {
    let t107 = 0, e10 = this.view.state.facet(yn).map((e11) => (this.dynamicDecorationMap[t107++] = "function" == typeof e11) ? e11(this.view) : e11), i10 = false, s10 = this.view.state.facet(yo).map((t108, e11) => {
      let s11 = "function" == typeof t108;
      return s11 && (i10 = true), s11 ? t108(this.view) : t108;
    });
    for (s10.length && (this.dynamicDecorationMap[t107++] = i10, e10.push(tG.join(s10))), this.decorations = [...e10, this.computeBlockGapDeco(), this.view.viewState.lineGapDeco]; t107 < this.decorations.length; ) this.dynamicDecorationMap[t107++] = false;
    return this.decorations;
  }
  scrollIntoView(t107) {
    if (t107.isSnapshot) {
      let e11 = this.view.viewState.lineBlockAt(t107.range.head);
      this.view.scrollDOM.scrollTop = e11.top - t107.yMargin, this.view.scrollDOM.scrollLeft = t107.xMargin;
      return;
    }
    for (let e11 of this.view.state.facet(b8)) try {
      if (e11(this.view, t107.range, t107)) return true;
    } catch (t108) {
      b9(this.view.state, t108, "scroll handler");
    }
    let { range: e10 } = t107, i10 = this.coordsAt(e10.head, e10.empty ? e10.assoc : e10.head > e10.anchor ? -1 : 1), s10;
    if (!i10) return;
    !e10.empty && (s10 = this.coordsAt(e10.anchor, e10.anchor > e10.head ? -1 : 1)) && (i10 = { left: Math.min(i10.left, s10.left), top: Math.min(i10.top, s10.top), right: Math.max(i10.right, s10.right), bottom: Math.max(i10.bottom, s10.bottom) });
    let n10 = yc(this.view), o10 = { left: i10.left - n10.left, top: i10.top - n10.top, right: i10.right + n10.right, bottom: i10.bottom + n10.bottom }, { offsetWidth: r10, offsetHeight: l10 } = this.view.scrollDOM;
    !function(t108, e11, i11, s11, n11, o11, r11, l11) {
      let h10 = t108.ownerDocument, a10 = h10.defaultView || window;
      for (let c10 = t108, d10 = false; c10 && !d10; ) if (1 == c10.nodeType) {
        let t109, u10 = c10 == h10.body, f10 = 1, g10 = 1;
        if (u10) t109 = function(t110) {
          let e12 = t110.visualViewport;
          return e12 ? { left: 0, right: e12.width, top: 0, bottom: e12.height } : { left: 0, right: t110.innerWidth, top: 0, bottom: t110.innerHeight };
        }(a10);
        else {
          if (/^(fixed|sticky)$/.test(getComputedStyle(c10).position) && (d10 = true), c10.scrollHeight <= c10.clientHeight && c10.scrollWidth <= c10.clientWidth) {
            c10 = c10.assignedSlot || c10.parentNode;
            continue;
          }
          let e12 = c10.getBoundingClientRect();
          ({ scaleX: f10, scaleY: g10 } = wj(c10, e12)), t109 = { left: e12.left, right: e12.left + c10.clientWidth * f10, top: e12.top, bottom: e12.top + c10.clientHeight * g10 };
        }
        let p10 = 0, m10 = 0;
        if ("nearest" == n11) e11.top < t109.top ? (m10 = -(t109.top - e11.top + r11), i11 > 0 && e11.bottom > t109.bottom + m10 && (m10 = e11.bottom - t109.bottom + m10 + r11)) : e11.bottom > t109.bottom && (m10 = e11.bottom - t109.bottom + r11, i11 < 0 && e11.top - m10 < t109.top && (m10 = -(t109.top + m10 - e11.top + r11)));
        else {
          let s12 = e11.bottom - e11.top, o12 = t109.bottom - t109.top;
          m10 = ("center" == n11 && s12 <= o12 ? e11.top + s12 / 2 - o12 / 2 : "start" == n11 || "center" == n11 && i11 < 0 ? e11.top - r11 : e11.bottom - o12 + r11) - t109.top;
        }
        if ("nearest" == s11 ? e11.left < t109.left ? (p10 = -(t109.left - e11.left + o11), i11 > 0 && e11.right > t109.right + p10 && (p10 = e11.right - t109.right + p10 + o11)) : e11.right > t109.right && (p10 = e11.right - t109.right + o11, i11 < 0 && e11.left < t109.left + p10 && (p10 = -(t109.left + p10 - e11.left + o11))) : p10 = ("center" == s11 ? e11.left + (e11.right - e11.left) / 2 - (t109.right - t109.left) / 2 : "start" == s11 == l11 ? e11.left - o11 : e11.right - (t109.right - t109.left) + o11) - t109.left, p10 || m10) {
          if (u10) a10.scrollBy(p10, m10);
          else {
            let t110 = 0, i12 = 0;
            if (m10) {
              let t111 = c10.scrollTop;
              c10.scrollTop += m10 / g10, i12 = (c10.scrollTop - t111) * g10;
            }
            if (p10) {
              let e12 = c10.scrollLeft;
              c10.scrollLeft += p10 / f10, t110 = (c10.scrollLeft - e12) * f10;
            }
            e11 = { left: e11.left - t110, top: e11.top - i12, right: e11.right - t110, bottom: e11.bottom - i12 }, t110 && 1 > Math.abs(t110 - p10) && (s11 = "nearest"), i12 && 1 > Math.abs(i12 - m10) && (n11 = "nearest");
          }
        }
        if (u10) break;
        c10 = c10.assignedSlot || c10.parentNode;
      } else if (11 == c10.nodeType) c10 = c10.host;
      else break;
    }(this.view.scrollDOM, o10, e10.head < e10.anchor ? -1 : 1, t107.x, t107.y, Math.max(Math.min(t107.xMargin, r10), -r10), Math.max(Math.min(t107.yMargin, l10), -l10), this.view.textDirection == bP.LTR);
  }
}
class yp extends bk {
  constructor(t107) {
    super(), this.height = t107;
  }
  toDOM() {
    let t107 = document.createElement("div");
    return t107.className = "cm-gap", this.updateDOM(t107), t107;
  }
  eq(t107) {
    return t107.height == this.height;
  }
  updateDOM(t107) {
    return t107.style.height = this.height + "px", true;
  }
  get editable() {
    return true;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return false;
  }
}
function ym(t107, e10) {
  let i10 = t107.observer.selectionRange;
  if (!i10.focusNode) return null;
  let s10 = w0(i10.focusNode, i10.focusOffset), n10 = w1(i10.focusNode, i10.focusOffset), o10 = s10 || n10;
  if (n10 && s10 && n10.node != s10.node) {
    let e11 = w3.get(n10.node);
    if (!e11 || e11 instanceof bd && e11.text != n10.node.nodeValue) o10 = n10;
    else if (t107.docView.lastCompositionAfterCursor) {
      let t108 = w3.get(s10.node);
      !t108 || t108 instanceof bd && t108.text != s10.node.nodeValue || (o10 = n10);
    }
  }
  if (t107.docView.lastCompositionAfterCursor = o10 != s10, !o10) return null;
  let r10 = e10 - o10.offset;
  return { from: r10, to: r10 + o10.node.nodeValue.length, node: o10.node };
}
let yv = class {
  constructor() {
    this.changes = [];
  }
  compareRange(t107, e10) {
    bE(t107, e10, this.changes);
  }
  comparePoint(t107, e10) {
    bE(t107, e10, this.changes);
  }
};
function yw(t107, e10) {
  return t107.top < e10.bottom - 1 && t107.bottom > e10.top + 1;
}
function yb(t107, e10) {
  return e10 < t107.top ? { top: e10, left: t107.left, right: t107.right, bottom: t107.bottom } : t107;
}
function yy(t107, e10) {
  return e10 > t107.bottom ? { top: t107.top, left: t107.left, right: t107.right, bottom: e10 } : t107;
}
function yx(t107, e10, i10) {
  let s10 = t107.nodeValue.length, n10 = -1, o10 = 1e9, r10 = 0;
  for (let l10 = 0; l10 < s10; l10++) {
    let s11 = wX(t107, l10, l10 + 1).getClientRects();
    for (let h10 = 0; h10 < s11.length; h10++) {
      let a10 = s11[h10];
      if (a10.top == a10.bottom) continue;
      r10 || (r10 = e10 - a10.left);
      let c10 = (a10.top > i10 ? a10.top - i10 : i10 - a10.bottom) - 1;
      if (a10.left - 1 <= e10 && a10.right + 1 >= e10 && c10 < o10) {
        let i11 = e10 >= (a10.left + a10.right) / 2, s12 = i11;
        if ((bc.chrome || bc.gecko) && wX(t107, l10).getBoundingClientRect().left == a10.right && (s12 = !i11), c10 <= 0) return { node: t107, offset: l10 + (s12 ? 1 : 0) };
        n10 = l10 + (s12 ? 1 : 0), o10 = c10;
      }
    }
  }
  return { node: t107, offset: n10 > -1 ? n10 : r10 > 0 ? t107.nodeValue.length : 0 };
}
function yS(t107, e10, i10) {
  var s10, n10;
  let o10 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : -1, r10 = t107.contentDOM.getBoundingClientRect(), l10 = r10.top + t107.viewState.paddingTop, h10, { docHeight: a10 } = t107.viewState, { x: c10, y: d10 } = e10, u10 = d10 - l10;
  if (u10 < 0) return 0;
  if (u10 > a10) return t107.state.doc.length;
  for (let e11 = t107.viewState.heightOracle.textHeight / 2, s11 = false; (h10 = t107.elementAtHeight(u10)).type != bM.Text; ) for (; !((u10 = o10 > 0 ? h10.bottom + e11 : h10.top - e11) >= 0) || !(u10 <= a10); ) {
    if (s11) return i10 ? null : 0;
    s11 = true, o10 = -o10;
  }
  d10 = l10 + u10;
  let f10 = h10.from;
  if (f10 < t107.viewport.from) return 0 == t107.viewport.from ? 0 : i10 ? null : yk(t107, r10, h10, c10, d10);
  if (f10 > t107.viewport.to) return t107.viewport.to == t107.state.doc.length ? t107.state.doc.length : i10 ? null : yk(t107, r10, h10, c10, d10);
  let g10 = t107.dom.ownerDocument, p10 = t107.root.elementFromPoint ? t107.root : g10, m10 = p10.elementFromPoint(c10, d10);
  m10 && !t107.contentDOM.contains(m10) && (m10 = null), !m10 && (c10 = Math.max(r10.left + 1, Math.min(r10.right - 1, c10)), (m10 = p10.elementFromPoint(c10, d10)) && !t107.contentDOM.contains(m10) && (m10 = null));
  let v10, w10 = -1;
  if (m10 && (null === (s10 = t107.docView.nearest(m10)) || void 0 === s10 ? void 0 : s10.isEditable) != false) {
    if (g10.caretPositionFromPoint) {
      let t108 = g10.caretPositionFromPoint(c10, d10);
      t108 && ({ offsetNode: v10, offset: w10 } = t108);
    } else if (g10.caretRangeFromPoint) {
      let e11 = g10.caretRangeFromPoint(c10, d10);
      e11 && ({ startContainer: v10, startOffset: w10 } = e11, (!t107.contentDOM.contains(v10) || bc.safari && function(t108, e12, i11) {
        let s11;
        if (3 != t108.nodeType || e12 != (s11 = t108.nodeValue.length)) return false;
        for (let e13 = t108.nextSibling; e13; e13 = e13.nextSibling) if (1 != e13.nodeType || "BR" != e13.nodeName) return false;
        return wX(t108, s11 - 1, s11).getBoundingClientRect().left > i11;
      }(v10, w10, c10) || bc.chrome && function(t108, e12, i11) {
        if (0 != e12) return false;
        for (let e13 = t108; ; ) {
          let t109 = e13.parentNode;
          if (!t109 || 1 != t109.nodeType || t109.firstChild != e13) return false;
          if (t109.classList.contains("cm-line")) break;
          e13 = t109;
        }
        return i11 - (1 == t108.nodeType ? t108.getBoundingClientRect() : wX(t108, 0, Math.max(t108.nodeValue.length, 1)).getBoundingClientRect()).left > 5;
      }(v10, w10, c10)) && (v10 = void 0));
    }
  }
  if (!v10 || !t107.docView.dom.contains(v10)) {
    let e11 = bx.find(t107.docView, f10);
    if (!e11) return u10 > h10.top + h10.height / 2 ? h10.to : h10.from;
    ({ node: v10, offset: w10 } = function t108(e12, i11, s11) {
      let n11, o11, r11, l11, h11, a11, c11, d11, u11 = false;
      for (let p12 = e12.firstChild; p12; p12 = p12.nextSibling) {
        let e13 = wW(p12);
        for (let m12 = 0; m12 < e13.length; m12++) {
          var f11, g11;
          let v11 = e13[m12];
          a11 && yw(a11, v11) && (v11 = yb(yy(v11, a11.bottom), a11.top));
          let w11 = (f11 = v11).left > i11 ? f11.left - i11 : Math.max(0, i11 - f11.right), b11 = (g11 = v11).top > s11 ? g11.top - s11 : Math.max(0, s11 - g11.bottom);
          if (0 == w11 && 0 == b11) return 3 == p12.nodeType ? yx(p12, i11, s11) : t108(p12, i11, s11);
          if (!h11 || d11 > b11 || d11 == b11 && c11 > w11) {
            h11 = p12, a11 = v11, c11 = w11, d11 = b11;
            let t109 = b11 ? s11 < v11.top ? -1 : 1 : w11 ? i11 < v11.left ? -1 : 1 : 0;
            u11 = !t109 || (t109 > 0 ? m12 < e13.length - 1 : m12 > 0);
          }
          0 == w11 ? s11 > v11.bottom && (!r11 || r11.bottom < v11.bottom) ? (n11 = p12, r11 = v11) : s11 < v11.top && (!l11 || l11.top > v11.top) && (o11 = p12, l11 = v11) : r11 && yw(r11, v11) ? r11 = yy(r11, v11.bottom) : l11 && yw(l11, v11) && (l11 = yb(l11, v11.top));
        }
      }
      if (r11 && r11.bottom >= s11 ? (h11 = n11, a11 = r11) : l11 && l11.top <= s11 && (h11 = o11, a11 = l11), !h11) return { node: e12, offset: 0 };
      let p11 = Math.max(a11.left, Math.min(a11.right, i11));
      if (3 == h11.nodeType) return yx(h11, p11, s11);
      if (u11 && "false" != h11.contentEditable) return t108(h11, p11, s11);
      let m11 = Array.prototype.indexOf.call(e12.childNodes, h11) + (i11 >= (a11.left + a11.right) / 2 ? 1 : 0);
      return { node: e12, offset: m11 };
    }(e11.dom, c10, d10));
  }
  let b10 = t107.docView.nearest(v10);
  if (!b10) return null;
  if (!b10.isWidget || (null === (n10 = b10.dom) || void 0 === n10 ? void 0 : n10.nodeType) != 1) return b10.localPosFromDOM(v10, w10) + b10.posAtStart;
  {
    let t108 = b10.dom.getBoundingClientRect();
    return e10.y < t108.top || e10.y <= t108.bottom && e10.x <= (t108.left + t108.right) / 2 ? b10.posAtStart : b10.posAtEnd;
  }
}
function yk(t107, e10, i10, s10, n10) {
  let o10 = Math.round((s10 - e10.left) * t107.defaultCharacterWidth);
  if (t107.lineWrapping && i10.height > 1.5 * t107.defaultLineHeight) {
    let e11 = t107.viewState.heightOracle.textHeight;
    o10 += Math.floor((n10 - i10.top - (t107.defaultLineHeight - e11) * 0.5) / e11) * t107.viewState.heightOracle.lineLength;
  }
  let r10 = t107.state.sliceDoc(i10.from, i10.to);
  return i10.from + t3(r10, o10, t107.state.tabSize);
}
function yM(t107, e10, i10, s10) {
  let n10 = t107.state.doc.lineAt(e10.head), o10 = t107.bidiSpans(n10), r10 = t107.textDirectionAt(n10.from);
  for (let l10 = e10, h10 = null; ; ) {
    let e11 = function(t108, e12, i11, s11, n11) {
      var o11;
      let r11 = s11.head - t108.from, l11 = b_.find(e12, r11, null !== (o11 = s11.bidiLevel) && void 0 !== o11 ? o11 : -1, s11.assoc), h11 = e12[l11], a11 = h11.side(n11, i11);
      if (r11 == a11) {
        let t109 = l11 += n11 ? 1 : -1;
        if (t109 < 0 || t109 >= e12.length) return null;
        r11 = (h11 = e12[l11 = t109]).side(!n11, i11), a11 = h11.side(n11, i11);
      }
      let c10 = v(t108.text, r11, h11.forward(n11, i11));
      (c10 < h11.from || c10 > h11.to) && (c10 = a11), bU = t108.text.slice(Math.min(r11, c10), Math.max(r11, c10));
      let d10 = l11 == (n11 ? e12.length - 1 : 0) ? null : e12[l11 + (n11 ? 1 : -1)];
      return d10 && c10 == a11 && d10.level + (n11 ? 0 : 1) < h11.level ? ti.cursor(d10.side(!n11, i11) + t108.from, d10.forward(n11, i11) ? 1 : -1, d10.level) : ti.cursor(c10 + t108.from, h11.forward(n11, i11) ? -1 : 1, h11.level);
    }(n10, o10, r10, l10, i10), a10 = bU;
    if (!e11) {
      if (n10.number == (i10 ? t107.state.doc.lines : 1)) return l10;
      a10 = "\n", n10 = t107.state.doc.line(n10.number + (i10 ? 1 : -1)), o10 = t107.bidiSpans(n10), e11 = t107.visualLineSide(n10, !i10);
    }
    if (h10) {
      if (!h10(a10)) return l10;
    } else {
      if (!s10) return e11;
      h10 = s10(a10);
    }
    l10 = e11;
  }
}
function yC(t107, e10, i10) {
  for (; ; ) {
    let s10 = 0;
    for (let n10 of t107) n10.between(e10 - 1, e10 + 1, (t108, n11, o10) => {
      if (e10 > t108 && e10 < n11) {
        let o11 = s10 || i10 || (e10 - t108 < n11 - e10 ? -1 : 1);
        e10 = o11 < 0 ? t108 : n11, s10 = o11;
      }
    });
    if (!s10) return e10;
  }
}
function yA(t107, e10, i10) {
  let s10 = yC(t107.state.facet(yr).map((e11) => e11(t107)), i10.from, e10.head > i10.from ? -1 : 1);
  return s10 == i10.from ? i10 : ti.cursor(s10, s10 < i10.from ? 1 : -1);
}
class yD {
  setSelectionOrigin(t107) {
    this.lastSelectionOrigin = t107, this.lastSelectionTime = Date.now();
  }
  constructor(t107) {
    var e10;
    this.view = t107, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.tabFocusMode = -1, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = false, this.compositionPendingChange = false, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = t107.hasFocus, bc.safari && t107.contentDOM.addEventListener("input", () => null), bc.gecko && (e10 = t107.contentDOM.ownerDocument, yQ.has(e10) || (yQ.add(e10), e10.addEventListener("copy", () => {
    }), e10.addEventListener("cut", () => {
    })));
  }
  handleEvent(t107) {
    !(!function(t108, e10) {
      if (!e10.bubbles) return true;
      if (e10.defaultPrevented) return false;
      for (let i10 = e10.target, s10; i10 != t108.contentDOM; i10 = i10.parentNode) if (!i10 || 11 == i10.nodeType || (s10 = w3.get(i10)) && s10.ignoreEvent(e10)) return false;
      return true;
    }(this.view, t107) || this.ignoreDuringComposition(t107)) && ("keydown" == t107.type && this.keydown(t107) || this.runHandlers(t107.type, t107));
  }
  runHandlers(t107, e10) {
    let i10 = this.handlers[t107];
    if (i10) {
      for (let t108 of i10.observers) t108(this.view, e10);
      for (let t108 of i10.handlers) {
        if (e10.defaultPrevented) break;
        if (t108(this.view, e10)) {
          e10.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(t107) {
    let e10 = function(t108) {
      let e11 = /* @__PURE__ */ Object.create(null);
      function i11(t109) {
        return e11[t109] || (e11[t109] = { observers: [], handlers: [] });
      }
      for (let e12 of t108) {
        let t109 = e12.spec;
        if (t109 && t109.domEventHandlers) for (let s11 in t109.domEventHandlers) {
          let n10 = t109.domEventHandlers[s11];
          n10 && i11(s11).handlers.push(yO(e12.value, n10));
        }
        if (t109 && t109.domEventObservers) for (let s11 in t109.domEventObservers) {
          let n10 = t109.domEventObservers[s11];
          n10 && i11(s11).observers.push(yO(e12.value, n10));
        }
      }
      for (let t109 in yP) i11(t109).handlers.push(yP[t109]);
      for (let t109 in yN) i11(t109).observers.push(yN[t109]);
      return e11;
    }(t107), i10 = this.handlers, s10 = this.view.contentDOM;
    for (let t108 in e10) if ("scroll" != t108) {
      let n10 = !e10[t108].handlers.length, o10 = i10[t108];
      o10 && !o10.handlers.length != n10 && (s10.removeEventListener(t108, this.handleEvent), o10 = null), o10 || s10.addEventListener(t108, this.handleEvent, { passive: n10 });
    }
    for (let t108 in i10) "scroll" == t108 || e10[t108] || s10.removeEventListener(t108, this.handleEvent);
    this.handlers = e10;
  }
  keydown(t107) {
    let e10;
    return this.lastKeyCode = t107.keyCode, this.lastKeyTime = Date.now(), !!(9 == t107.keyCode && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode)) || ((this.tabFocusMode > 0 && 27 != t107.keyCode && 0 > yR.indexOf(t107.keyCode) && (this.tabFocusMode = -1), bc.android && bc.chrome && !t107.synthetic && (13 == t107.keyCode || 8 == t107.keyCode)) ? (this.view.observer.delayAndroidKey(t107.key, t107.keyCode), true) : bc.ios && !t107.synthetic && !t107.altKey && !t107.metaKey && ((e10 = yT.find((e11) => e11.keyCode == t107.keyCode)) && !t107.ctrlKey || yE.indexOf(t107.key) > -1 && t107.ctrlKey && !t107.shiftKey) ? (this.pendingIOSKey = e10 || t107, setTimeout(() => this.flushIOSKey(), 250), true) : (229 != t107.keyCode && this.view.observer.forceFlush(), false));
  }
  flushIOSKey(t107) {
    let e10 = this.pendingIOSKey;
    return !(!e10 || "Enter" == e10.key && t107 && t107.from < t107.to && /^\S+$/.test(t107.insert.toString())) && (this.pendingIOSKey = void 0, wJ(this.view.contentDOM, e10.key, e10.keyCode, e10 instanceof KeyboardEvent ? e10 : void 0));
  }
  ignoreDuringComposition(t107) {
    return !!/^key/.test(t107.type) && (this.composing > 0 || !!(bc.safari && !bc.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) && (this.compositionPendingKey = false, true));
  }
  startMouseSelection(t107) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = t107;
  }
  update(t107) {
    this.mouseSelection && this.mouseSelection.update(t107), this.draggedContent && t107.docChanged && (this.draggedContent = this.draggedContent.map(t107.changes)), t107.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function yO(t107, e10) {
  return (i10, s10) => {
    try {
      return e10.call(t107, s10, i10);
    } catch (t108) {
      b9(i10.state, t108);
    }
  };
}
let yT = [{ key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" }, { key: "Enter", keyCode: 13, inputType: "insertParagraph" }, { key: "Enter", keyCode: 13, inputType: "insertLineBreak" }, { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }], yE = "dthko", yR = [16, 17, 18, 20, 91, 92, 224, 225];
function yB(t107) {
  return 0.7 * Math.max(0, t107) + 8;
}
class yL {
  constructor(t107, e10, i10, s10) {
    let n10;
    this.view = t107, this.startEvent = e10, this.style = i10, this.mustSelect = s10, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = e10, this.scrollParent = function(t108) {
      let e11 = t108.ownerDocument;
      for (let i11 = t108.parentNode; i11 && i11 != e11.body; ) if (1 == i11.nodeType) {
        if (i11.scrollHeight > i11.clientHeight || i11.scrollWidth > i11.clientWidth) return i11;
        i11 = i11.assignedSlot || i11.parentNode;
      } else if (11 == i11.nodeType) i11 = i11.host;
      else break;
      return null;
    }(t107.contentDOM), this.atoms = t107.state.facet(yr).map((e11) => e11(t107));
    let o10 = t107.contentDOM.ownerDocument;
    o10.addEventListener("mousemove", this.move = this.move.bind(this)), o10.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = e10.shiftKey, this.multiple = t107.state.facet(tW.allowMultipleSelections) && ((n10 = t107.state.facet(bY)).length ? n10[0](e10) : bc.mac ? e10.metaKey : e10.ctrlKey), this.dragging = !!function(t108, e11) {
      let { main: i11 } = t108.state.selection;
      if (i11.empty) return false;
      let s11 = wV(t108.root);
      if (!s11 || 0 == s11.rangeCount) return true;
      let n11 = s11.getRangeAt(0).getClientRects();
      for (let t109 = 0; t109 < n11.length; t109++) {
        let i12 = n11[t109];
        if (i12.left <= e11.clientX && i12.right >= e11.clientX && i12.top <= e11.clientY && i12.bottom >= e11.clientY) return true;
      }
      return false;
    }(t107, e10) && 1 == yj(e10) && null;
  }
  start(t107) {
    false === this.dragging && this.select(t107);
  }
  move(t107) {
    var e10, i10;
    if (0 == t107.buttons) return this.destroy();
    if (this.dragging || null == this.dragging && 10 > Math.max(Math.abs((i10 = this.startEvent).clientX - t107.clientX), Math.abs(i10.clientY - t107.clientY))) return;
    this.select(this.lastEvent = t107);
    let s10 = 0, n10 = 0, o10 = (null === (e10 = this.scrollParent) || void 0 === e10 ? void 0 : e10.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight }, r10 = yc(this.view);
    t107.clientX - r10.left <= o10.left + 6 ? s10 = -yB(o10.left - t107.clientX) : t107.clientX + r10.right >= o10.right - 6 && (s10 = yB(t107.clientX - o10.right)), t107.clientY - r10.top <= o10.top + 6 ? n10 = -yB(o10.top - t107.clientY) : t107.clientY + r10.bottom >= o10.bottom - 6 && (n10 = yB(t107.clientY - o10.bottom)), this.setScrollSpeed(s10, n10);
  }
  up(t107) {
    null == this.dragging && this.select(this.lastEvent), this.dragging || t107.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let t107 = this.view.contentDOM.ownerDocument;
    t107.removeEventListener("mousemove", this.move), t107.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(t107, e10) {
    this.scrollSpeed = { x: t107, y: e10 }, t107 || e10 ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x, this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y), false === this.dragging && this.select(this.lastEvent);
  }
  skipAtoms(t107) {
    let e10 = null;
    for (let i10 = 0; i10 < t107.ranges.length; i10++) {
      let s10 = t107.ranges[i10], n10 = null;
      if (s10.empty) {
        let t108 = yC(this.atoms, s10.from, 0);
        t108 != s10.from && (n10 = ti.cursor(t108, -1));
      } else {
        let t108 = yC(this.atoms, s10.from, -1), e11 = yC(this.atoms, s10.to, 1);
        (t108 != s10.from || e11 != s10.to) && (n10 = ti.range(s10.from == s10.anchor ? t108 : e11, s10.from == s10.head ? t108 : e11));
      }
      n10 && (e10 || (e10 = t107.ranges.slice()), e10[i10] = n10);
    }
    return e10 ? ti.create(e10, t107.mainIndex) : t107;
  }
  select(t107) {
    let { view: e10 } = this, i10 = this.skipAtoms(this.style.get(t107, this.extend, this.multiple));
    (this.mustSelect || !i10.eq(e10.state.selection, false === this.dragging)) && this.view.dispatch({ selection: i10, userEvent: "select.pointer" }), this.mustSelect = false;
  }
  update(t107) {
    t107.transactions.some((t108) => t108.isUserEvent("input.type")) ? this.destroy() : this.style.update(t107) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
let yP = /* @__PURE__ */ Object.create(null), yN = /* @__PURE__ */ Object.create(null), yV = bc.ie && bc.ie_version < 15 || bc.ios && bc.webkit_version < 604;
function yH(t107, e10) {
  let { state: i10 } = t107, s10, n10 = 1, o10 = i10.toText(e10), r10 = o10.lines == i10.selection.ranges.length;
  if (null != yY && i10.selection.ranges.every((t108) => t108.empty) && yY == o10.toString()) {
    let t108 = -1;
    s10 = i10.changeByRange((s11) => {
      let l10 = i10.doc.lineAt(s11.from);
      if (l10.from == t108) return { range: s11 };
      t108 = l10.from;
      let h10 = i10.toText((r10 ? o10.line(n10++).text : e10) + i10.lineBreak);
      return { changes: { from: l10.from, insert: h10 }, range: ti.cursor(s11.from + h10.length) };
    });
  } else s10 = r10 ? i10.changeByRange((t108) => {
    let e11 = o10.line(n10++);
    return { changes: { from: t108.from, to: t108.to, insert: e11.text }, range: ti.cursor(t108.from + e11.length) };
  }) : i10.replaceSelection(o10);
  t107.dispatch(s10, { userEvent: "input.paste", scrollIntoView: true });
}
function yF(t107, e10, i10, s10) {
  if (1 == s10) return ti.cursor(e10, i10);
  if (2 == s10) return function(t108, e11) {
    let i11 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, s11 = t108.charCategorizer(e11), n10 = t108.doc.lineAt(e11), o10 = e11 - n10.from;
    if (0 == n10.length) return ti.cursor(e11);
    0 == o10 ? i11 = 1 : o10 == n10.length && (i11 = -1);
    let r10 = o10, l10 = o10;
    i11 < 0 ? r10 = v(n10.text, o10, false) : l10 = v(n10.text, o10);
    let h10 = s11(n10.text.slice(r10, l10));
    for (; r10 > 0; ) {
      let t109 = v(n10.text, r10, false);
      if (s11(n10.text.slice(t109, r10)) != h10) break;
      r10 = t109;
    }
    for (; l10 < n10.length; ) {
      let t109 = v(n10.text, l10);
      if (s11(n10.text.slice(l10, t109)) != h10) break;
      l10 = t109;
    }
    return ti.range(r10 + n10.from, l10 + n10.from);
  }(t107.state, e10, i10);
  {
    let i11 = bx.find(t107.docView, e10), s11 = t107.state.doc.lineAt(i11 ? i11.posAtEnd : e10), n10 = i11 ? i11.posAtStart : s11.from, o10 = i11 ? i11.posAtEnd : s11.to;
    return o10 < t107.state.doc.length && o10 == s11.to && o10++, ti.range(n10, o10);
  }
}
yN.scroll = (t107) => {
  t107.inputState.lastScrollTop = t107.scrollDOM.scrollTop, t107.inputState.lastScrollLeft = t107.scrollDOM.scrollLeft;
}, yP.keydown = (t107, e10) => (t107.inputState.setSelectionOrigin("select"), 27 == e10.keyCode && 0 != t107.inputState.tabFocusMode && (t107.inputState.tabFocusMode = Date.now() + 2e3), false), yN.touchstart = (t107, e10) => {
  t107.inputState.lastTouchTime = Date.now(), t107.inputState.setSelectionOrigin("select.pointer");
}, yN.touchmove = (t107) => {
  t107.inputState.setSelectionOrigin("select.pointer");
}, yP.mousedown = (t107, e10) => {
  let i10, s10, n10;
  if (t107.observer.flush(), t107.inputState.lastTouchTime > Date.now() - 2e3) return false;
  let o10 = null;
  for (let i11 of t107.state.facet(bX)) if (o10 = i11(t107, e10)) break;
  if (o10 || 0 != e10.button || (i10 = yz(t107, e10), s10 = yj(e10), n10 = t107.state.selection, o10 = { update(t108) {
    t108.docChanged && (i10.pos = t108.changes.mapPos(i10.pos), n10 = n10.map(t108.changes));
  }, get(e11, o11, r10) {
    let l10 = yz(t107, e11), h10, a10 = yF(t107, l10.pos, l10.bias, s10);
    if (i10.pos != l10.pos && !o11) {
      let e12 = yF(t107, i10.pos, i10.bias, s10), n11 = Math.min(e12.from, a10.from), o12 = Math.max(e12.to, a10.to);
      a10 = n11 < a10.from ? ti.range(n11, o12) : ti.range(o12, n11);
    }
    return o11 ? n10.replaceRange(n10.main.extend(a10.from, a10.to)) : r10 && 1 == s10 && n10.ranges.length > 1 && (h10 = function(t108, e12) {
      for (let i11 = 0; i11 < t108.ranges.length; i11++) {
        let { from: s11, to: n11 } = t108.ranges[i11];
        if (s11 <= e12 && n11 >= e12) return ti.create(t108.ranges.slice(0, i11).concat(t108.ranges.slice(i11 + 1)), t108.mainIndex == i11 ? 0 : t108.mainIndex - (t108.mainIndex > i11 ? 1 : 0));
      }
      return null;
    }(n10, l10.pos)) ? h10 : r10 ? n10.addRange(a10) : ti.create([a10]);
  } }), o10) {
    let i11 = !t107.hasFocus;
    t107.inputState.startMouseSelection(new yL(t107, e10, o10, i11)), i11 && t107.observer.ignore(() => {
      w$(t107.contentDOM);
      let e11 = t107.root.activeElement;
      e11 && !e11.contains(t107.contentDOM) && e11.blur();
    });
    let s11 = t107.inputState.mouseSelection;
    if (s11) return s11.start(e10), false === s11.dragging;
  }
  return false;
};
let yW = (t107, e10) => t107 >= e10.top && t107 <= e10.bottom, yI = (t107, e10, i10) => yW(e10, i10) && t107 >= i10.left && t107 <= i10.right;
function yz(t107, e10) {
  let i10 = t107.posAtCoords({ x: e10.clientX, y: e10.clientY }, false);
  return { pos: i10, bias: function(t108, e11, i11, s10) {
    let n10 = bx.find(t108.docView, e11);
    if (!n10) return 1;
    let o10 = e11 - n10.posAtStart;
    if (0 == o10) return 1;
    if (o10 == n10.length) return -1;
    let r10 = n10.coordsAt(o10, -1);
    if (r10 && yI(i11, s10, r10)) return -1;
    let l10 = n10.coordsAt(o10, 1);
    return l10 && yI(i11, s10, l10) ? 1 : r10 && yW(s10, r10) ? -1 : 1;
  }(t107, i10, e10.clientX, e10.clientY) };
}
let yK = bc.ie && bc.ie_version <= 11, yq = null, y_ = 0, yG = 0;
function yj(t107) {
  if (!yK) return t107.detail;
  let e10 = yq, i10 = yG;
  return yq = t107, yG = Date.now(), y_ = !e10 || i10 > Date.now() - 400 && 2 > Math.abs(e10.clientX - t107.clientX) && 2 > Math.abs(e10.clientY - t107.clientY) ? (y_ + 1) % 3 : 1;
}
function yU(t107, e10, i10, s10) {
  let n10;
  if (!i10) return;
  let o10 = t107.posAtCoords({ x: e10.clientX, y: e10.clientY }, false), { draggedContent: r10 } = t107.inputState, l10 = s10 && r10 && ((n10 = t107.state.facet(b$)).length ? n10[0](e10) : bc.mac ? !e10.altKey : !e10.ctrlKey) ? { from: r10.from, to: r10.to } : null, h10 = { from: o10, insert: i10 }, a10 = t107.state.changes(l10 ? [l10, h10] : h10);
  t107.focus(), t107.dispatch({ changes: a10, selection: { anchor: a10.mapPos(o10, -1), head: a10.mapPos(o10, 1) }, userEvent: l10 ? "move.drop" : "input.drop" }), t107.inputState.draggedContent = null;
}
yP.dragstart = (t107, e10) => {
  let { selection: { main: i10 } } = t107.state;
  if (e10.target.draggable) {
    let s11 = t107.docView.nearest(e10.target);
    if (s11 && s11.isWidget) {
      let t108 = s11.posAtStart, e11 = t108 + s11.length;
      (t108 >= i10.to || e11 <= i10.from) && (i10 = ti.range(t108, e11));
    }
  }
  let { inputState: s10 } = t107;
  return s10.mouseSelection && (s10.mouseSelection.dragging = true), s10.draggedContent = i10, e10.dataTransfer && (e10.dataTransfer.setData("Text", t107.state.sliceDoc(i10.from, i10.to)), e10.dataTransfer.effectAllowed = "copyMove"), false;
}, yP.dragend = (t107) => (t107.inputState.draggedContent = null, false), yP.drop = (t107, e10) => {
  if (!e10.dataTransfer) return false;
  if (t107.state.readOnly) return true;
  let i10 = e10.dataTransfer.files;
  if (i10 && i10.length) {
    let s10 = Array(i10.length), n10 = 0, o10 = () => {
      ++n10 == i10.length && yU(t107, e10, s10.filter((t108) => null != t108).join(t107.state.lineBreak), false);
    };
    for (let t108 = 0; t108 < i10.length; t108++) {
      let e11 = new FileReader();
      e11.onerror = o10, e11.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(e11.result) || (s10[t108] = e11.result), o10();
      }, e11.readAsText(i10[t108]);
    }
    return true;
  }
  {
    let i11 = e10.dataTransfer.getData("Text");
    if (i11) return yU(t107, e10, i11, true), true;
  }
  return false;
}, yP.paste = (t107, e10) => {
  if (t107.state.readOnly) return true;
  t107.observer.flush();
  let i10 = yV ? null : e10.clipboardData;
  return i10 ? (yH(t107, i10.getData("text/plain") || i10.getData("text/uri-list")), true) : (function(t108) {
    let e11 = t108.dom.parentNode;
    if (!e11) return;
    let i11 = e11.appendChild(document.createElement("textarea"));
    i11.style.cssText = "position: fixed; left: -10000px; top: 10px", i11.focus(), setTimeout(() => {
      t108.focus(), i11.remove(), yH(t108, i11.value);
    }, 50);
  }(t107), false);
};
let yY = null;
yP.copy = yP.cut = (t107, e10) => {
  let { text: i10, ranges: s10, linewise: n10 } = function(t108) {
    let e11 = [], i11 = [], s11 = false;
    for (let s12 of t108.selection.ranges) s12.empty || (e11.push(t108.sliceDoc(s12.from, s12.to)), i11.push(s12));
    if (!e11.length) {
      let n11 = -1;
      for (let { from: s12 } of t108.selection.ranges) {
        let o11 = t108.doc.lineAt(s12);
        o11.number > n11 && (e11.push(o11.text), i11.push({ from: o11.from, to: Math.min(t108.doc.length, o11.to + 1) })), n11 = o11.number;
      }
      s11 = true;
    }
    return { text: e11.join(t108.lineBreak), ranges: i11, linewise: s11 };
  }(t107.state);
  if (!i10 && !n10) return false;
  yY = n10 ? i10 : null, "cut" != e10.type || t107.state.readOnly || t107.dispatch({ changes: s10, scrollIntoView: true, userEvent: "delete.cut" });
  let o10 = yV ? null : e10.clipboardData;
  return o10 ? (o10.clearData(), o10.setData("text/plain", i10), true) : (!function(t108, e11) {
    let i11 = t108.dom.parentNode;
    if (!i11) return;
    let s11 = i11.appendChild(document.createElement("textarea"));
    s11.style.cssText = "position: fixed; left: -10000px; top: 10px", s11.value = e11, s11.focus(), s11.selectionEnd = e11.length, s11.selectionStart = 0, setTimeout(() => {
      s11.remove(), t108.focus();
    }, 50);
  }(t107, i10), false);
};
let y$ = tO.define();
function yX(t107, e10) {
  let i10 = [];
  for (let s10 of t107.facet(b0)) {
    let n10 = s10(t107, e10);
    n10 && i10.push(n10);
  }
  return i10 ? t107.update({ effects: i10, annotations: y$.of(true) }) : null;
}
function yJ(t107) {
  setTimeout(() => {
    let e10 = t107.hasFocus;
    if (e10 != t107.inputState.notifiedFocused) {
      let i10 = yX(t107.state, e10);
      i10 ? t107.dispatch(i10) : t107.update([]);
    }
  }, 10);
}
yN.focus = (t107) => {
  t107.inputState.lastFocusTime = Date.now(), !t107.scrollDOM.scrollTop && (t107.inputState.lastScrollTop || t107.inputState.lastScrollLeft) && (t107.scrollDOM.scrollTop = t107.inputState.lastScrollTop, t107.scrollDOM.scrollLeft = t107.inputState.lastScrollLeft), yJ(t107);
}, yN.blur = (t107) => {
  t107.observer.clearSelectionRange(), yJ(t107);
}, yN.compositionstart = yN.compositionupdate = (t107) => {
  null == t107.inputState.compositionFirstChange && (t107.inputState.compositionFirstChange = true), t107.inputState.composing < 0 && (t107.inputState.composing = 0);
}, yN.compositionend = (t107) => {
  t107.inputState.composing = -1, t107.inputState.compositionEndedAt = Date.now(), t107.inputState.compositionPendingKey = true, t107.inputState.compositionPendingChange = t107.observer.pendingRecords().length > 0, t107.inputState.compositionFirstChange = null, bc.chrome && bc.android ? t107.observer.flushSoon() : t107.inputState.compositionPendingChange ? Promise.resolve().then(() => t107.observer.flush()) : setTimeout(() => {
    t107.inputState.composing < 0 && t107.docView.hasComposition && t107.update([]);
  }, 50);
}, yN.contextmenu = (t107) => {
  t107.inputState.lastContextMenu = Date.now();
}, yP.beforeinput = (t107, e10) => {
  var i10;
  let s10;
  if (bc.chrome && bc.android && (s10 = yT.find((t108) => t108.inputType == e10.inputType)) && (t107.observer.delayAndroidKey(s10.key, s10.keyCode), "Backspace" == s10.key || "Delete" == s10.key)) {
    let e11 = (null === (i10 = window.visualViewport) || void 0 === i10 ? void 0 : i10.height) || 0;
    setTimeout(() => {
      var i11;
      ((null === (i11 = window.visualViewport) || void 0 === i11 ? void 0 : i11.height) || 0) > e11 + 10 && t107.hasFocus && (t107.contentDOM.blur(), t107.focus());
    }, 100);
  }
  return bc.ios && "deleteContentForward" == e10.inputType && t107.observer.flushSoon(), bc.safari && "insertText" == e10.inputType && t107.inputState.composing >= 0 && setTimeout(() => yN.compositionend(t107, e10), 20), false;
};
let yQ = /* @__PURE__ */ new Set(), yZ = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class y0 {
  constructor(t107) {
    this.lineWrapping = t107, this.doc = r.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30, this.heightChanged = false;
  }
  heightForGap(t107, e10) {
    let i10 = this.doc.lineAt(e10).number - this.doc.lineAt(t107).number + 1;
    return this.lineWrapping && (i10 += Math.max(0, Math.ceil((e10 - t107 - i10 * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * i10;
  }
  heightForLine(t107) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((t107 - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(t107) {
    return this.doc = t107, this;
  }
  mustRefreshForWrapping(t107) {
    return yZ.indexOf(t107) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(t107) {
    let e10 = false;
    for (let i10 = 0; i10 < t107.length; i10++) {
      let s10 = t107[i10];
      s10 < 0 ? i10++ : this.heightSamples[Math.floor(10 * s10)] || (e10 = true, this.heightSamples[Math.floor(10 * s10)] = true);
    }
    return e10;
  }
  refresh(t107, e10, i10, s10, n10, o10) {
    let r10 = yZ.indexOf(t107) > -1, l10 = Math.round(e10) != Math.round(this.lineHeight) || this.lineWrapping != r10;
    if (this.lineWrapping = r10, this.lineHeight = e10, this.charWidth = i10, this.textHeight = s10, this.lineLength = n10, l10) {
      this.heightSamples = {};
      for (let t108 = 0; t108 < o10.length; t108++) {
        let e11 = o10[t108];
        e11 < 0 ? t108++ : this.heightSamples[Math.floor(10 * e11)] = true;
      }
    }
    return l10;
  }
}
class y1 {
  constructor(t107, e10) {
    this.from = t107, this.heights = e10, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class y2 {
  constructor(t107, e10, i10, s10, n10) {
    this.from = t107, this.length = e10, this.top = i10, this.height = s10, this._content = n10;
  }
  get type() {
    return "number" == typeof this._content ? bM.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  get to() {
    return this.from + this.length;
  }
  get bottom() {
    return this.top + this.height;
  }
  get widget() {
    return this._content instanceof bO ? this._content.widget : null;
  }
  get widgetLineBreaks() {
    return "number" == typeof this._content ? this._content : 0;
  }
  join(t107) {
    let e10 = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(t107._content) ? t107._content : [t107]);
    return new y2(this.from, this.length + t107.length, this.top, this.height + t107.height, e10);
  }
}
var y8 = ((K = y8 || (y8 = {}))[K.ByPos = 0] = "ByPos", K[K.ByHeight = 1] = "ByHeight", K[K.ByPosNoHeight = 2] = "ByPosNoHeight", K);
class y3 {
  constructor(t107, e10, i10 = 2) {
    this.length = t107, this.height = e10, this.flags = i10;
  }
  get outdated() {
    return (2 & this.flags) > 0;
  }
  set outdated(t107) {
    this.flags = (t107 ? 2 : 0) | -3 & this.flags;
  }
  setHeight(t107, e10) {
    this.height != e10 && (Math.abs(this.height - e10) > 1e-3 && (t107.heightChanged = true), this.height = e10);
  }
  replace(t107, e10, i10) {
    return y3.of(i10);
  }
  decomposeLeft(t107, e10) {
    e10.push(this);
  }
  decomposeRight(t107, e10) {
    e10.push(this);
  }
  applyChanges(t107, e10, i10, s10) {
    let n10 = this, o10 = i10.doc;
    for (let r10 = s10.length - 1; r10 >= 0; r10--) {
      let { fromA: l10, toA: h10, fromB: a10, toB: c10 } = s10[r10], d10 = n10.lineAt(l10, y8.ByPosNoHeight, i10.setDoc(e10), 0, 0), u10 = d10.to >= h10 ? d10 : n10.lineAt(h10, y8.ByPosNoHeight, i10, 0, 0);
      for (c10 += u10.to - h10, h10 = u10.to; r10 > 0 && d10.from <= s10[r10 - 1].toA; ) l10 = s10[r10 - 1].fromA, a10 = s10[r10 - 1].fromB, r10--, l10 < d10.from && (d10 = n10.lineAt(l10, y8.ByPosNoHeight, i10, 0, 0));
      a10 += d10.from - l10, l10 = d10.from;
      let f10 = xt.build(i10.setDoc(o10), t107, a10, c10);
      n10 = n10.replace(l10, h10, f10);
    }
    return n10.updateHeight(i10, 0);
  }
  static empty() {
    return new y9(0, 0);
  }
  static of(t107) {
    if (1 == t107.length) return t107[0];
    let e10 = 0, i10 = t107.length, s10 = 0, n10 = 0;
    for (; ; ) if (e10 == i10) {
      if (s10 > 2 * n10) {
        let n11 = t107[e10 - 1];
        n11.break ? t107.splice(--e10, 1, n11.left, null, n11.right) : t107.splice(--e10, 1, n11.left, n11.right), i10 += 1 + n11.break, s10 -= n11.size;
      } else if (n10 > 2 * s10) {
        let e11 = t107[i10];
        e11.break ? t107.splice(i10, 1, e11.left, null, e11.right) : t107.splice(i10, 1, e11.left, e11.right), i10 += 2 + e11.break, n10 -= e11.size;
      } else break;
    } else if (s10 < n10) {
      let i11 = t107[e10++];
      i11 && (s10 += i11.size);
    } else {
      let e11 = t107[--i10];
      e11 && (n10 += e11.size);
    }
    let o10 = 0;
    return null == t107[e10 - 1] ? (o10 = 1, e10--) : null == t107[e10] && (o10 = 1, i10++), new y6(y3.of(t107.slice(0, e10)), o10, y3.of(t107.slice(i10)));
  }
}
y3.prototype.size = 1;
class y4 extends y3 {
  constructor(t107, e10, i10) {
    super(t107, e10), this.deco = i10;
  }
  blockAt(t107, e10, i10, s10) {
    return new y2(s10, this.length, i10, this.height, this.deco || 0);
  }
  lineAt(t107, e10, i10, s10, n10) {
    return this.blockAt(0, i10, s10, n10);
  }
  forEachLine(t107, e10, i10, s10, n10, o10) {
    t107 <= n10 + this.length && e10 >= n10 && o10(this.blockAt(0, i10, s10, n10));
  }
  updateHeight(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i10 = (arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 ? arguments[3] : void 0);
    return i10 && i10.from <= e10 && i10.more && this.setHeight(t107, i10.heights[i10.index++]), this.outdated = false, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class y9 extends y4 {
  constructor(t107, e10) {
    super(t107, e10, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(t107, e10, i10, s10) {
    return new y2(s10, this.length, i10, this.height, this.breaks);
  }
  replace(t107, e10, i10) {
    let s10 = i10[0];
    return 1 == i10.length && (s10 instanceof y9 || s10 instanceof y5 && 4 & s10.flags) && 10 > Math.abs(this.length - s10.length) ? (s10 instanceof y5 ? s10 = new y9(s10.length, this.height) : s10.height = this.height, this.outdated || (s10.outdated = false), s10) : y3.of(i10);
  }
  updateHeight(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], s10 = arguments.length > 3 ? arguments[3] : void 0;
    return s10 && s10.from <= e10 && s10.more ? this.setHeight(t107, s10.heights[s10.index++]) : (i10 || this.outdated) && this.setHeight(t107, Math.max(this.widgetHeight, t107.heightForLine(this.length - this.collapsed)) + this.breaks * t107.lineHeight), this.outdated = false, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class y5 extends y3 {
  constructor(t107) {
    super(t107, 0);
  }
  heightMetrics(t107, e10) {
    let i10 = t107.doc.lineAt(e10).number, s10 = t107.doc.lineAt(e10 + this.length).number, n10 = s10 - i10 + 1, o10, r10 = 0;
    if (t107.lineWrapping) {
      let e11 = Math.min(this.height, t107.lineHeight * n10);
      o10 = e11 / n10, this.length > n10 + 1 && (r10 = (this.height - e11) / (this.length - n10 - 1));
    } else o10 = this.height / n10;
    return { firstLine: i10, lastLine: s10, perLine: o10, perChar: r10 };
  }
  blockAt(t107, e10, i10, s10) {
    let { firstLine: n10, lastLine: o10, perLine: r10, perChar: l10 } = this.heightMetrics(e10, s10);
    if (e10.lineWrapping) {
      let n11 = s10 + (t107 < e10.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (t107 - i10) / this.height)) * this.length)), o11 = e10.doc.lineAt(n11), h10 = r10 + o11.length * l10, a10 = Math.max(i10, t107 - h10 / 2);
      return new y2(o11.from, o11.length, a10, h10, 0);
    }
    {
      let s11 = Math.max(0, Math.min(o10 - n10, Math.floor((t107 - i10) / r10))), { from: l11, length: h10 } = e10.doc.line(n10 + s11);
      return new y2(l11, h10, i10 + r10 * s11, r10, 0);
    }
  }
  lineAt(t107, e10, i10, s10, n10) {
    if (e10 == y8.ByHeight) return this.blockAt(t107, i10, s10, n10);
    if (e10 == y8.ByPosNoHeight) {
      let { from: e11, to: s11 } = i10.doc.lineAt(t107);
      return new y2(e11, s11 - e11, 0, 0, 0);
    }
    let { firstLine: o10, perLine: r10, perChar: l10 } = this.heightMetrics(i10, n10), h10 = i10.doc.lineAt(t107), a10 = r10 + h10.length * l10, c10 = h10.number - o10, d10 = s10 + r10 * c10 + l10 * (h10.from - n10 - c10);
    return new y2(h10.from, h10.length, Math.max(s10, Math.min(d10, s10 + this.height - a10)), a10, 0);
  }
  forEachLine(t107, e10, i10, s10, n10, o10) {
    t107 = Math.max(t107, n10), e10 = Math.min(e10, n10 + this.length);
    let { firstLine: r10, perLine: l10, perChar: h10 } = this.heightMetrics(i10, n10);
    for (let a10 = t107, c10 = s10; a10 <= e10; ) {
      let e11 = i10.doc.lineAt(a10);
      if (a10 == t107) {
        let i11 = e11.number - r10;
        c10 += l10 * i11 + h10 * (t107 - n10 - i11);
      }
      let s11 = l10 + h10 * e11.length;
      o10(new y2(e11.from, e11.length, c10, s11, 0)), c10 += s11, a10 = e11.to + 1;
    }
  }
  replace(t107, e10, i10) {
    let s10 = this.length - e10;
    if (s10 > 0) {
      let t108 = i10[i10.length - 1];
      t108 instanceof y5 ? i10[i10.length - 1] = new y5(t108.length + s10) : i10.push(null, new y5(s10 - 1));
    }
    if (t107 > 0) {
      let e11 = i10[0];
      e11 instanceof y5 ? i10[0] = new y5(t107 + e11.length) : i10.unshift(new y5(t107 - 1), null);
    }
    return y3.of(i10);
  }
  decomposeLeft(t107, e10) {
    e10.push(new y5(t107 - 1), null);
  }
  decomposeRight(t107, e10) {
    e10.push(null, new y5(this.length - t107 - 1));
  }
  updateHeight(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], s10 = arguments.length > 3 ? arguments[3] : void 0, n10 = e10 + this.length;
    if (s10 && s10.from <= e10 + this.length && s10.more) {
      let i11 = [], o10 = Math.max(e10, s10.from), r10 = -1;
      for (s10.from > e10 && i11.push(new y5(s10.from - e10 - 1).updateHeight(t107, e10)); o10 <= n10 && s10.more; ) {
        let e11 = t107.doc.lineAt(o10).length;
        i11.length && i11.push(null);
        let n11 = s10.heights[s10.index++];
        -1 == r10 ? r10 = n11 : Math.abs(n11 - r10) >= 1e-3 && (r10 = -2);
        let l11 = new y9(e11, n11);
        l11.outdated = false, i11.push(l11), o10 += e11 + 1;
      }
      o10 <= n10 && i11.push(null, new y5(n10 - o10).updateHeight(t107, o10));
      let l10 = y3.of(i11);
      return (r10 < 0 || Math.abs(l10.height - this.height) >= 1e-3 || Math.abs(r10 - this.heightMetrics(t107, e10).perLine) >= 1e-3) && (t107.heightChanged = true), l10;
    }
    return (i10 || this.outdated) && (this.setHeight(t107, t107.heightForGap(e10, e10 + this.length)), this.outdated = false), this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class y6 extends y3 {
  constructor(t107, e10, i10) {
    super(t107.length + e10 + i10.length, t107.height + i10.height, e10 | (t107.outdated || i10.outdated ? 2 : 0)), this.left = t107, this.right = i10, this.size = t107.size + i10.size;
  }
  get break() {
    return 1 & this.flags;
  }
  blockAt(t107, e10, i10, s10) {
    let n10 = i10 + this.left.height;
    return t107 < n10 ? this.left.blockAt(t107, e10, i10, s10) : this.right.blockAt(t107, e10, n10, s10 + this.left.length + this.break);
  }
  lineAt(t107, e10, i10, s10, n10) {
    let o10 = s10 + this.left.height, r10 = n10 + this.left.length + this.break, l10 = e10 == y8.ByHeight ? t107 < o10 : t107 < r10, h10 = l10 ? this.left.lineAt(t107, e10, i10, s10, n10) : this.right.lineAt(t107, e10, i10, o10, r10);
    if (this.break || (l10 ? h10.to < r10 : h10.from > r10)) return h10;
    let a10 = e10 == y8.ByPosNoHeight ? y8.ByPosNoHeight : y8.ByPos;
    return l10 ? h10.join(this.right.lineAt(r10, a10, i10, o10, r10)) : this.left.lineAt(r10, a10, i10, s10, n10).join(h10);
  }
  forEachLine(t107, e10, i10, s10, n10, o10) {
    let r10 = s10 + this.left.height, l10 = n10 + this.left.length + this.break;
    if (this.break) t107 < l10 && this.left.forEachLine(t107, e10, i10, s10, n10, o10), e10 >= l10 && this.right.forEachLine(t107, e10, i10, r10, l10, o10);
    else {
      let h10 = this.lineAt(l10, y8.ByPos, i10, s10, n10);
      t107 < h10.from && this.left.forEachLine(t107, h10.from - 1, i10, s10, n10, o10), h10.to >= t107 && h10.from <= e10 && o10(h10), e10 > h10.to && this.right.forEachLine(h10.to + 1, e10, i10, r10, l10, o10);
    }
  }
  replace(t107, e10, i10) {
    let s10 = this.left.length + this.break;
    if (e10 < s10) return this.balanced(this.left.replace(t107, e10, i10), this.right);
    if (t107 > this.left.length) return this.balanced(this.left, this.right.replace(t107 - s10, e10 - s10, i10));
    let n10 = [];
    t107 > 0 && this.decomposeLeft(t107, n10);
    let o10 = n10.length;
    for (let t108 of i10) n10.push(t108);
    if (t107 > 0 && y7(n10, o10 - 1), e10 < this.length) {
      let t108 = n10.length;
      this.decomposeRight(e10, n10), y7(n10, t108);
    }
    return y3.of(n10);
  }
  decomposeLeft(t107, e10) {
    let i10 = this.left.length;
    if (t107 <= i10) return this.left.decomposeLeft(t107, e10);
    e10.push(this.left), this.break && t107 >= ++i10 && e10.push(null), t107 > i10 && this.right.decomposeLeft(t107 - i10, e10);
  }
  decomposeRight(t107, e10) {
    let i10 = this.left.length, s10 = i10 + this.break;
    if (t107 >= s10) return this.right.decomposeRight(t107 - s10, e10);
    t107 < i10 && this.left.decomposeRight(t107, e10), this.break && t107 < s10 && e10.push(null), e10.push(this.right);
  }
  balanced(t107, e10) {
    return t107.size > 2 * e10.size || e10.size > 2 * t107.size ? y3.of(this.break ? [t107, null, e10] : [t107, e10]) : (this.left = t107, this.right = e10, this.height = t107.height + e10.height, this.outdated = t107.outdated || e10.outdated, this.size = t107.size + e10.size, this.length = t107.length + this.break + e10.length, this);
  }
  updateHeight(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i10 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], s10 = arguments.length > 3 ? arguments[3] : void 0, { left: n10, right: o10 } = this, r10 = e10 + n10.length + this.break, l10 = null;
    return (s10 && s10.from <= e10 + n10.length && s10.more ? l10 = n10 = n10.updateHeight(t107, e10, i10, s10) : n10.updateHeight(t107, e10, i10), s10 && s10.from <= r10 + o10.length && s10.more ? l10 = o10 = o10.updateHeight(t107, r10, i10, s10) : o10.updateHeight(t107, r10, i10), l10) ? this.balanced(n10, o10) : (this.height = this.left.height + this.right.height, this.outdated = false, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function y7(t107, e10) {
  let i10, s10;
  null == t107[e10] && (i10 = t107[e10 - 1]) instanceof y5 && (s10 = t107[e10 + 1]) instanceof y5 && t107.splice(e10 - 1, 3, new y5(i10.length + 1 + s10.length));
}
class xt {
  constructor(t107, e10) {
    this.pos = t107, this.oracle = e10, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = t107;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(t107, e10) {
    if (this.lineStart > -1) {
      let t108 = Math.min(e10, this.lineEnd), i10 = this.nodes[this.nodes.length - 1];
      i10 instanceof y9 ? i10.length += t108 - this.pos : (t108 > this.pos || !this.isCovered) && this.nodes.push(new y9(t108 - this.pos, -1)), this.writtenTo = t108, e10 > t108 && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = e10;
  }
  point(t107, e10, i10) {
    if (t107 < e10 || i10.heightRelevant) {
      let s10 = i10.widget ? i10.widget.estimatedHeight : 0, n10 = i10.widget ? i10.widget.lineBreaks : 0;
      s10 < 0 && (s10 = this.oracle.lineHeight);
      let o10 = e10 - t107;
      i10.block ? this.addBlock(new y4(o10, s10, i10)) : (o10 || n10 || s10 >= 5) && this.addLineDeco(s10, n10, o10);
    } else e10 > t107 && this.span(t107, e10);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1) return;
    let { from: t107, to: e10 } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = t107, this.lineEnd = e10, this.writtenTo < t107 && ((this.writtenTo < t107 - 1 || null == this.nodes[this.nodes.length - 1]) && this.nodes.push(this.blankContent(this.writtenTo, t107 - 1)), this.nodes.push(null)), this.pos > t107 && this.nodes.push(new y9(this.pos - t107, -1)), this.writtenTo = this.pos;
  }
  blankContent(t107, e10) {
    let i10 = new y5(e10 - t107);
    return this.oracle.doc.lineAt(t107).to == e10 && (i10.flags |= 4), i10;
  }
  ensureLine() {
    this.enterLine();
    let t107 = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (t107 instanceof y9) return t107;
    let e10 = new y9(0, -1);
    return this.nodes.push(e10), e10;
  }
  addBlock(t107) {
    this.enterLine();
    let e10 = t107.deco;
    e10 && e10.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(t107), this.writtenTo = this.pos = this.pos + t107.length, e10 && e10.endSide > 0 && (this.covering = t107);
  }
  addLineDeco(t107, e10, i10) {
    let s10 = this.ensureLine();
    s10.length += i10, s10.collapsed += i10, s10.widgetHeight = Math.max(s10.widgetHeight, t107), s10.breaks += e10, this.writtenTo = this.pos = this.pos + i10;
  }
  finish(t107) {
    let e10 = 0 == this.nodes.length ? null : this.nodes[this.nodes.length - 1];
    !(this.lineStart > -1) || e10 instanceof y9 || this.isCovered ? (this.writtenTo < this.pos || null == e10) && this.nodes.push(this.blankContent(this.writtenTo, this.pos)) : this.nodes.push(new y9(0, -1));
    let i10 = t107;
    for (let t108 of this.nodes) t108 instanceof y9 && t108.updateHeight(this.oracle, i10), i10 += t108 ? t108.length : 1;
    return this.nodes;
  }
  static build(t107, e10, i10, s10) {
    let n10 = new xt(i10, t107);
    return tG.spans(e10, i10, s10, n10, 0), n10.finish(i10);
  }
}
class xe {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(t107, e10, i10, s10) {
    (t107 < e10 || i10 && i10.heightRelevant || s10 && s10.heightRelevant) && bE(t107, e10, this.changes, 5);
  }
}
class xi {
  constructor(t107, e10, i10) {
    this.from = t107, this.to = e10, this.size = i10;
  }
  static same(t107, e10) {
    if (t107.length != e10.length) return false;
    for (let i10 = 0; i10 < t107.length; i10++) {
      let s10 = t107[i10], n10 = e10[i10];
      if (s10.from != n10.from || s10.to != n10.to || s10.size != n10.size) return false;
    }
    return true;
  }
  draw(t107, e10) {
    return bC.replace({ widget: new xs(this.size * (e10 ? t107.scaleY : t107.scaleX), e10) }).range(this.from, this.to);
  }
}
class xs extends bk {
  constructor(t107, e10) {
    super(), this.size = t107, this.vertical = e10;
  }
  eq(t107) {
    return t107.size == this.size && t107.vertical == this.vertical;
  }
  toDOM() {
    let t107 = document.createElement("div");
    return this.vertical ? t107.style.height = this.size + "px" : (t107.style.width = this.size + "px", t107.style.height = "2px", t107.style.display = "inline-block"), t107;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class xn {
  constructor(t107) {
    this.state = t107, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = true, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = false, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = xh, this.scrollTarget = null, this.printing = false, this.mustMeasureContent = true, this.defaultTextDirection = bP.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = false;
    let e10 = t107.facet(ys).some((t108) => "function" != typeof t108 && "cm-lineWrapping" == t108.class);
    this.heightOracle = new y0(e10), this.stateDeco = t107.facet(yn).filter((t108) => "function" != typeof t108), this.heightMap = y3.empty().applyChanges(this.stateDeco, r.empty, this.heightOracle.setDoc(t107.doc), [new yu(0, 0, 0, t107.doc.length)]);
    for (let t108 = 0; t108 < 2 && (this.viewport = this.getViewport(0, null), this.updateForViewport()); t108++) ;
    this.updateViewportLines(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = bC.set(this.lineGaps.map((t108) => t108.draw(this, false))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let t107 = [this.viewport], { main: e10 } = this.state.selection;
    for (let i10 = 0; i10 <= 1; i10++) {
      let s10 = i10 ? e10.head : e10.anchor;
      if (!t107.some((t108) => {
        let { from: e11, to: i11 } = t108;
        return s10 >= e11 && s10 <= i11;
      })) {
        let { from: e11, to: i11 } = this.lineBlockAt(s10);
        t107.push(new xo(e11, i11));
      }
    }
    return this.viewports = t107.sort((t108, e11) => t108.from - e11.from), this.updateScaler();
  }
  updateScaler() {
    let t107 = this.scaler;
    return this.scaler = this.heightMap.height <= 7e6 ? xh : new xa(this.heightOracle, this.heightMap, this.viewports), t107.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (t107) => {
      this.viewportLines.push(xc(t107, this.scaler));
    });
  }
  update(t107) {
    var e10, i10;
    let s10, n10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    this.state = t107.state;
    let o10 = this.stateDeco;
    this.stateDeco = this.state.facet(yn).filter((t108) => "function" != typeof t108);
    let r10 = t107.changedRanges, l10 = yu.extendWithRanges(r10, (e10 = this.stateDeco, i10 = t107 ? t107.changes : Y.empty(this.state.doc.length), s10 = new xe(), tG.compare(o10, e10, i10, s10, 0), s10.changes)), h10 = this.heightMap.height, a10 = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, t107.startState.doc, this.heightOracle.setDoc(this.state.doc), l10), this.heightMap.height != h10 && (t107.flags |= 2), a10 ? (this.scrollAnchorPos = t107.changes.mapPos(a10.from, -1), this.scrollAnchorHeight = a10.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let c10 = l10.length ? this.mapViewport(this.viewport, t107.changes) : this.viewport;
    (n10 && (n10.range.head < c10.from || n10.range.head > c10.to) || !this.viewportIsAppropriate(c10)) && (c10 = this.getViewport(0, n10));
    let d10 = c10.from != this.viewport.from || c10.to != this.viewport.to;
    this.viewport = c10, t107.flags |= this.updateForViewport(), (d10 || !t107.changes.empty || 2 & t107.flags) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, t107.changes))), t107.flags |= this.computeVisibleRanges(), n10 && (this.scrollTarget = n10), !this.mustEnforceCursorAssoc && t107.selectionSet && t107.view.lineWrapping && t107.state.selection.main.empty && t107.state.selection.main.assoc && !t107.state.facet(b2) && (this.mustEnforceCursorAssoc = true);
  }
  measure(t107) {
    let e10 = t107.contentDOM, i10 = window.getComputedStyle(e10), s10 = this.heightOracle, n10 = i10.whiteSpace;
    this.defaultTextDirection = "rtl" == i10.direction ? bP.RTL : bP.LTR;
    let o10 = this.heightOracle.mustRefreshForWrapping(n10), l10 = e10.getBoundingClientRect(), h10 = o10 || this.mustMeasureContent || this.contentDOMHeight != l10.height;
    this.contentDOMHeight = l10.height, this.mustMeasureContent = false;
    let a10 = 0, c10 = 0;
    if (l10.width && l10.height) {
      let { scaleX: t108, scaleY: i11 } = wj(e10, l10);
      (t108 > 5e-3 && Math.abs(this.scaleX - t108) > 5e-3 || i11 > 5e-3 && Math.abs(this.scaleY - i11) > 5e-3) && (this.scaleX = t108, this.scaleY = i11, a10 |= 8, o10 = h10 = true);
    }
    let d10 = (parseInt(i10.paddingTop) || 0) * this.scaleY, u10 = (parseInt(i10.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != d10 || this.paddingBottom != u10) && (this.paddingTop = d10, this.paddingBottom = u10, a10 |= 10), this.editorWidth != t107.scrollDOM.clientWidth && (s10.lineWrapping && (h10 = true), this.editorWidth = t107.scrollDOM.clientWidth, a10 |= 8);
    let f10 = t107.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != f10 && (this.scrollAnchorHeight = -1, this.scrollTop = f10), this.scrolledToBottom = wZ(t107.scrollDOM);
    let g10 = (this.printing ? function(t108, e11) {
      let i11 = t108.getBoundingClientRect();
      return { left: 0, right: i11.right - i11.left, top: e11, bottom: i11.bottom - (i11.top + e11) };
    } : function(t108, e11) {
      let i11 = t108.getBoundingClientRect(), s11 = t108.ownerDocument, n11 = s11.defaultView || window, o11 = Math.max(0, i11.left), r10 = Math.min(n11.innerWidth, i11.right), l11 = Math.max(0, i11.top), h11 = Math.min(n11.innerHeight, i11.bottom);
      for (let e12 = t108.parentNode; e12 && e12 != s11.body; ) if (1 == e12.nodeType) {
        let i12 = e12, s12 = window.getComputedStyle(i12);
        if ((i12.scrollHeight > i12.clientHeight || i12.scrollWidth > i12.clientWidth) && "visible" != s12.overflow) {
          let s13 = i12.getBoundingClientRect();
          o11 = Math.max(o11, s13.left), r10 = Math.min(r10, s13.right), l11 = Math.max(l11, s13.top), h11 = e12 == t108.parentNode ? s13.bottom : Math.min(h11, s13.bottom);
        }
        e12 = "absolute" == s12.position || "fixed" == s12.position ? i12.offsetParent : i12.parentNode;
      } else if (11 == e12.nodeType) e12 = e12.host;
      else break;
      return { left: o11 - i11.left, right: Math.max(o11, r10) - i11.left, top: l11 - (i11.top + e11), bottom: Math.max(l11, h11) - (i11.top + e11) };
    })(e10, this.paddingTop), p10 = g10.top - this.pixelViewport.top, m10 = g10.bottom - this.pixelViewport.bottom;
    this.pixelViewport = g10;
    let v10 = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (v10 != this.inView && (this.inView = v10, v10 && (h10 = true)), !this.inView && !this.scrollTarget) return 0;
    let w10 = l10.width;
    if ((this.contentDOMWidth != w10 || this.editorHeight != t107.scrollDOM.clientHeight) && (this.contentDOMWidth = l10.width, this.editorHeight = t107.scrollDOM.clientHeight, a10 |= 8), h10) {
      let e11 = t107.docView.measureVisibleLineHeights(this.viewport);
      if (s10.mustRefreshForHeights(e11) && (o10 = true), o10 || s10.lineWrapping && Math.abs(w10 - this.contentDOMWidth) > s10.charWidth) {
        let { lineHeight: i11, charWidth: r10, textHeight: l11 } = t107.docView.measureTextSize();
        (o10 = i11 > 0 && s10.refresh(n10, i11, r10, l11, w10 / r10, e11)) && (t107.docView.minWidth = 0, a10 |= 8);
      }
      for (let i11 of (p10 > 0 && m10 > 0 ? c10 = Math.max(p10, m10) : p10 < 0 && m10 < 0 && (c10 = Math.min(p10, m10)), s10.heightChanged = false, this.viewports)) {
        let n11 = i11.from == this.viewport.from ? e11 : t107.docView.measureVisibleLineHeights(i11);
        this.heightMap = (o10 ? y3.empty().applyChanges(this.stateDeco, r.empty, this.heightOracle, [new yu(0, 0, 0, t107.state.doc.length)]) : this.heightMap).updateHeight(s10, 0, o10, new y1(i11.from, n11));
      }
      s10.heightChanged && (a10 |= 2);
    }
    let b10 = !this.viewportIsAppropriate(this.viewport, c10) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return b10 && (2 & a10 && (a10 |= this.updateScaler()), this.viewport = this.getViewport(c10, this.scrollTarget), a10 |= this.updateForViewport()), (2 & a10 || b10) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(o10 ? [] : this.lineGaps, t107)), a10 |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = false, t107.docView.enforceCursorAssoc()), a10;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(t107, e10) {
    let i10 = 0.5 - Math.max(-0.5, Math.min(0.5, t107 / 1e3 / 2)), s10 = this.heightMap, n10 = this.heightOracle, { visibleTop: o10, visibleBottom: r10 } = this, l10 = new xo(s10.lineAt(o10 - 1e3 * i10, y8.ByHeight, n10, 0, 0).from, s10.lineAt(r10 + (1 - i10) * 1e3, y8.ByHeight, n10, 0, 0).to);
    if (e10) {
      let { head: t108 } = e10.range;
      if (t108 < l10.from || t108 > l10.to) {
        let i11 = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), o11 = s10.lineAt(t108, y8.ByPos, n10, 0, 0), r11;
        r11 = "center" == e10.y ? (o11.top + o11.bottom) / 2 - i11 / 2 : "start" == e10.y || "nearest" == e10.y && t108 < l10.from ? o11.top : o11.bottom - i11, l10 = new xo(s10.lineAt(r11 - 500, y8.ByHeight, n10, 0, 0).from, s10.lineAt(r11 + i11 + 500, y8.ByHeight, n10, 0, 0).to);
      }
    }
    return l10;
  }
  mapViewport(t107, e10) {
    let i10 = e10.mapPos(t107.from, -1), s10 = e10.mapPos(t107.to, 1);
    return new xo(this.heightMap.lineAt(i10, y8.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(s10, y8.ByPos, this.heightOracle, 0, 0).to);
  }
  viewportIsAppropriate(t107) {
    let { from: e10, to: i10 } = t107, s10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    if (!this.inView) return true;
    let { top: n10 } = this.heightMap.lineAt(e10, y8.ByPos, this.heightOracle, 0, 0), { bottom: o10 } = this.heightMap.lineAt(i10, y8.ByPos, this.heightOracle, 0, 0), { visibleTop: r10, visibleBottom: l10 } = this;
    return (0 == e10 || n10 <= r10 - Math.max(10, Math.min(-s10, 250))) && (i10 == this.state.doc.length || o10 >= l10 + Math.max(10, Math.min(s10, 250))) && n10 > r10 - 2e3 && o10 < l10 + 2e3;
  }
  mapLineGaps(t107, e10) {
    if (!t107.length || e10.empty) return t107;
    let i10 = [];
    for (let s10 of t107) e10.touchesRange(s10.from, s10.to) || i10.push(new xi(e10.mapPos(s10.from), e10.mapPos(s10.to), s10.size));
    return i10;
  }
  ensureLineGaps(t107, e10) {
    let i10 = this.heightOracle.lineWrapping, s10 = i10 ? 1e4 : 2e3, n10 = s10 >> 1, o10 = s10 << 1;
    if (this.defaultTextDirection != bP.LTR && !i10) return [];
    let r10 = [], l10 = (s11, o11, h10, a10) => {
      if (o11 - s11 < n10) return;
      let c10 = this.state.selection.main, d10 = [c10.from];
      for (let t108 of (c10.empty || d10.push(c10.to), d10)) if (t108 > s11 && t108 < o11) {
        l10(s11, t108 - 10, h10, a10), l10(t108 + 10, o11, h10, a10);
        return;
      }
      let u10 = function(t108, e11) {
        for (let i11 of t108) if (e11(i11)) return i11;
      }(t107, (t108) => t108.from >= h10.from && t108.to <= h10.to && Math.abs(t108.from - s11) < n10 && Math.abs(t108.to - o11) < n10 && !d10.some((e11) => t108.from < e11 && t108.to > e11));
      if (!u10) {
        if (o11 < h10.to && e10 && i10 && e10.visibleRanges.some((t108) => t108.from <= o11 && t108.to >= o11)) {
          let t108 = e10.moveToLineBoundary(ti.cursor(o11), false, true).head;
          t108 > s11 && (o11 = t108);
        }
        u10 = new xi(s11, o11, this.gapSize(h10, s11, o11, a10));
      }
      r10.push(u10);
    };
    for (let t108 of this.viewportLines) {
      let e11, n11;
      if (t108.length < o10) continue;
      let r11 = function(t109, e12, i11) {
        let s11 = [], n12 = t109, o11 = 0;
        return tG.spans(i11, t109, e12, { span() {
        }, point(t110, e13) {
          t110 > n12 && (s11.push({ from: n12, to: t110 }), o11 += t110 - n12), n12 = e13;
        } }, 20), n12 < e12 && (s11.push({ from: n12, to: e12 }), o11 += e12 - n12), { total: o11, ranges: s11 };
      }(t108.from, t108.to, this.stateDeco);
      if (r11.total < o10) continue;
      let h10 = this.scrollTarget ? this.scrollTarget.range.head : null;
      if (i10) {
        let i11, o11, l11 = s10 / this.heightOracle.lineLength * this.heightOracle.lineHeight;
        if (null != h10) {
          let e12 = xl(r11, h10), s11 = ((this.visibleBottom - this.visibleTop) / 2 + l11) / t108.height;
          i11 = e12 - s11, o11 = e12 + s11;
        } else i11 = (this.visibleTop - t108.top - l11) / t108.height, o11 = (this.visibleBottom - t108.top + l11) / t108.height;
        e11 = xr(r11, i11), n11 = xr(r11, o11);
      } else {
        let t109, i11, o11 = r11.total * this.heightOracle.charWidth, l11 = s10 * this.heightOracle.charWidth;
        if (null != h10) {
          let e12 = xl(r11, h10), s11 = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + l11) / o11;
          t109 = e12 - s11, i11 = e12 + s11;
        } else t109 = (this.pixelViewport.left - l11) / o11, i11 = (this.pixelViewport.right + l11) / o11;
        e11 = xr(r11, t109), n11 = xr(r11, i11);
      }
      e11 > t108.from && l10(t108.from, e11, t108, r11), n11 < t108.to && l10(n11, t108.to, t108, r11);
    }
    return r10;
  }
  gapSize(t107, e10, i10, s10) {
    let n10 = xl(s10, i10) - xl(s10, e10);
    return this.heightOracle.lineWrapping ? t107.height * n10 : s10.total * this.heightOracle.charWidth * n10;
  }
  updateLineGaps(t107) {
    xi.same(t107, this.lineGaps) || (this.lineGaps = t107, this.lineGapDeco = bC.set(t107.map((t108) => t108.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let t107 = this.stateDeco;
    this.lineGaps.length && (t107 = t107.concat(this.lineGapDeco));
    let e10 = [];
    tG.spans(t107, this.viewport.from, this.viewport.to, { span(t108, i11) {
      e10.push({ from: t108, to: i11 });
    }, point() {
    } }, 20);
    let i10 = e10.length != this.visibleRanges.length || this.visibleRanges.some((t108, i11) => t108.from != e10[i11].from || t108.to != e10[i11].to);
    return this.visibleRanges = e10, i10 ? 4 : 0;
  }
  lineBlockAt(t107) {
    return t107 >= this.viewport.from && t107 <= this.viewport.to && this.viewportLines.find((e10) => e10.from <= t107 && e10.to >= t107) || xc(this.heightMap.lineAt(t107, y8.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(t107) {
    return t107 >= this.viewportLines[0].top && t107 <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find((e10) => e10.top <= t107 && e10.bottom >= t107) || xc(this.heightMap.lineAt(this.scaler.fromDOM(t107), y8.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(t107) {
    let e10 = this.lineBlockAtHeight(t107 + 8);
    return e10.from >= this.viewport.from || this.viewportLines[0].top - t107 > 200 ? e10 : this.viewportLines[0];
  }
  elementAtHeight(t107) {
    return xc(this.heightMap.blockAt(this.scaler.fromDOM(t107), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class xo {
  constructor(t107, e10) {
    this.from = t107, this.to = e10;
  }
}
function xr(t107, e10) {
  let { total: i10, ranges: s10 } = t107;
  if (e10 <= 0) return s10[0].from;
  if (e10 >= 1) return s10[s10.length - 1].to;
  let n10 = Math.floor(i10 * e10);
  for (let t108 = 0; ; t108++) {
    let { from: e11, to: i11 } = s10[t108], o10 = i11 - e11;
    if (n10 <= o10) return e11 + n10;
    n10 -= o10;
  }
}
function xl(t107, e10) {
  let i10 = 0;
  for (let { from: s10, to: n10 } of t107.ranges) {
    if (e10 <= n10) {
      i10 += e10 - s10;
      break;
    }
    i10 += n10 - s10;
  }
  return i10 / t107.total;
}
let xh = { toDOM: (t107) => t107, fromDOM: (t107) => t107, scale: 1, eq(t107) {
  return t107 == this;
} };
class xa {
  constructor(t107, e10, i10) {
    let s10 = 0, n10 = 0, o10 = 0;
    for (let r10 of (this.viewports = i10.map((i11) => {
      let { from: n11, to: o11 } = i11, r11 = e10.lineAt(n11, y8.ByPos, t107, 0, 0).top, l10 = e10.lineAt(o11, y8.ByPos, t107, 0, 0).bottom;
      return s10 += l10 - r11, { from: n11, to: o11, top: r11, bottom: l10, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - s10) / (e10.height - s10), this.viewports)) r10.domTop = o10 + (r10.top - n10) * this.scale, o10 = r10.domBottom = r10.domTop + (r10.bottom - r10.top), n10 = r10.bottom;
  }
  toDOM(t107) {
    for (let e10 = 0, i10 = 0, s10 = 0; ; e10++) {
      let n10 = e10 < this.viewports.length ? this.viewports[e10] : null;
      if (!n10 || t107 < n10.top) return s10 + (t107 - i10) * this.scale;
      if (t107 <= n10.bottom) return n10.domTop + (t107 - n10.top);
      i10 = n10.bottom, s10 = n10.domBottom;
    }
  }
  fromDOM(t107) {
    for (let e10 = 0, i10 = 0, s10 = 0; ; e10++) {
      let n10 = e10 < this.viewports.length ? this.viewports[e10] : null;
      if (!n10 || t107 < n10.domTop) return i10 + (t107 - s10) / this.scale;
      if (t107 <= n10.domBottom) return n10.top + (t107 - n10.domTop);
      i10 = n10.bottom, s10 = n10.domBottom;
    }
  }
  eq(t107) {
    return t107 instanceof xa && this.scale == t107.scale && this.viewports.length == t107.viewports.length && this.viewports.every((e10, i10) => e10.from == t107.viewports[i10].from && e10.to == t107.viewports[i10].to);
  }
}
function xc(t107, e10) {
  if (1 == e10.scale) return t107;
  let i10 = e10.toDOM(t107.top), s10 = e10.toDOM(t107.bottom);
  return new y2(t107.from, t107.length, i10, s10 - i10, Array.isArray(t107._content) ? t107._content.map((t108) => xc(t108, e10)) : t107._content);
}
let xd = to.define({ combine: (t107) => t107.join(" ") }), xu = to.define({ combine: (t107) => t107.indexOf(true) > -1 }), xf = t6.newName(), xg = t6.newName(), xp = t6.newName(), xm = { "&light": "." + xg, "&dark": "." + xp };
function xv(t107, e10, i10) {
  return new t6(e10, { finish: (e11) => /&/.test(e11) ? e11.replace(/&\w*/, (e12) => {
    if ("&" == e12) return t107;
    if (!i10 || !i10[e12]) throw RangeError(`Unsupported selector: ${e12}`);
    return i10[e12];
  }) : t107 + " " + e11 });
}
let xw = xv("." + xf, { "&": { position: "relative !important", boxSizing: "border-box", "&.cm-focused": { outline: "1px dotted #212121" }, display: "flex !important", flexDirection: "column" }, ".cm-scroller": { display: "flex !important", alignItems: "flex-start !important", fontFamily: "monospace", lineHeight: 1.4, height: "100%", overflowX: "auto", position: "relative", zIndex: 0 }, ".cm-content": { margin: 0, flexGrow: 2, flexShrink: 0, display: "block", whiteSpace: "pre", wordWrap: "normal", boxSizing: "border-box", minHeight: "100%", padding: "4px 0", outline: "none", "&[contenteditable=true]": { WebkitUserModify: "read-write-plaintext-only" } }, ".cm-lineWrapping": { whiteSpace_fallback: "pre-wrap", whiteSpace: "break-spaces", wordBreak: "break-word", overflowWrap: "anywhere", flexShrink: 1 }, "&light .cm-content": { caretColor: "black" }, "&dark .cm-content": { caretColor: "white" }, ".cm-line": { display: "block", padding: "0 2px 0 6px" }, ".cm-layer": { position: "absolute", left: 0, top: 0, contain: "size style", "& > *": { position: "absolute" } }, "&light .cm-selectionBackground": { background: "#d9d9d9" }, "&dark .cm-selectionBackground": { background: "#222" }, "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": { background: "#d7d4f0" }, "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": { background: "#233" }, ".cm-cursorLayer": { pointerEvents: "none" }, "&.cm-focused > .cm-scroller > .cm-cursorLayer": { animation: "steps(1) cm-blink 1.2s infinite" }, "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} }, "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} }, ".cm-cursor, .cm-dropCursor": { borderLeft: "1.2px solid black", marginLeft: "-0.6px", pointerEvents: "none" }, ".cm-cursor": { display: "none" }, "&dark .cm-cursor": { borderLeftColor: "#444" }, ".cm-dropCursor": { position: "absolute" }, "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": { display: "block" }, ".cm-iso": { unicodeBidi: "isolate" }, ".cm-announced": { position: "fixed", top: "-10000px" }, "@media print": { ".cm-announced": { display: "none" } }, "&light .cm-activeLine": { backgroundColor: "#cceeff44" }, "&dark .cm-activeLine": { backgroundColor: "#99eeff33" }, "&light .cm-specialChar": { color: "red" }, "&dark .cm-specialChar": { color: "#f78" }, ".cm-gutters": { flexShrink: 0, display: "flex", height: "100%", boxSizing: "border-box", insetInlineStart: 0, zIndex: 200 }, "&light .cm-gutters": { backgroundColor: "#f5f5f5", color: "#6c6c6c", borderRight: "1px solid #ddd" }, "&dark .cm-gutters": { backgroundColor: "#333338", color: "#ccc" }, ".cm-gutter": { display: "flex !important", flexDirection: "column", flexShrink: 0, boxSizing: "border-box", minHeight: "100%", overflow: "hidden" }, ".cm-gutterElement": { boxSizing: "border-box" }, ".cm-lineNumbers .cm-gutterElement": { padding: "0 3px 0 5px", minWidth: "20px", textAlign: "right", whiteSpace: "nowrap" }, "&light .cm-activeLineGutter": { backgroundColor: "#e2f2ff" }, "&dark .cm-activeLineGutter": { backgroundColor: "#222227" }, ".cm-panels": { boxSizing: "border-box", position: "sticky", left: 0, right: 0 }, "&light .cm-panels": { backgroundColor: "#f5f5f5", color: "black" }, "&light .cm-panels-top": { borderBottom: "1px solid #ddd" }, "&light .cm-panels-bottom": { borderTop: "1px solid #ddd" }, "&dark .cm-panels": { backgroundColor: "#333338", color: "white" }, ".cm-tab": { display: "inline-block", overflow: "hidden", verticalAlign: "bottom" }, ".cm-widgetBuffer": { verticalAlign: "text-top", height: "1em", width: 0, display: "inline" }, ".cm-placeholder": { color: "#888", display: "inline-block", verticalAlign: "top" }, ".cm-highlightSpace:before": { content: "attr(data-display)", position: "absolute", pointerEvents: "none", color: "#888" }, ".cm-highlightTab": { backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`, backgroundSize: "auto 100%", backgroundPosition: "right 90%", backgroundRepeat: "no-repeat" }, ".cm-trailingSpace": { backgroundColor: "#ff332255" }, ".cm-button": { verticalAlign: "middle", color: "inherit", fontSize: "70%", padding: ".2em 1em", borderRadius: "1px" }, "&light .cm-button": { backgroundImage: "linear-gradient(#eff1f5, #d9d9df)", border: "1px solid #888", "&:active": { backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)" } }, "&dark .cm-button": { backgroundImage: "linear-gradient(#393939, #111)", border: "1px solid #888", "&:active": { backgroundImage: "linear-gradient(#111, #333)" } }, ".cm-textfield": { verticalAlign: "middle", color: "inherit", fontSize: "70%", border: "1px solid silver", padding: ".2em .5em" }, "&light .cm-textfield": { backgroundColor: "white" }, "&dark .cm-textfield": { border: "1px solid #555", backgroundColor: "inherit" } }, xm);
class xb {
  constructor(t107, e10) {
    this.points = t107, this.text = "", this.lineSeparator = e10.facet(tW.lineSeparator);
  }
  append(t107) {
    this.text += t107;
  }
  lineBreak() {
    this.text += "";
  }
  readRange(t107, e10) {
    if (!t107) return this;
    let i10 = t107.parentNode;
    for (let s10 = t107; ; ) {
      this.findPointBefore(i10, s10);
      let t108 = this.text.length;
      this.readNode(s10);
      let n10 = s10.nextSibling;
      if (n10 == e10) break;
      let o10 = w3.get(s10), r10 = w3.get(n10);
      (o10 && r10 ? o10.breakAfter : (o10 ? o10.breakAfter : wK(s10)) || wK(n10) && ("BR" != s10.nodeName || s10.cmIgnore) && this.text.length > t108) && this.lineBreak(), s10 = n10;
    }
    return this.findPointBefore(i10, e10), this;
  }
  readTextNode(t107) {
    let e10 = t107.nodeValue;
    for (let i10 of this.points) i10.node == t107 && (i10.pos = this.text.length + Math.min(i10.offset, e10.length));
    for (let i10 = 0, s10 = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let n10 = -1, o10 = 1, r10;
      if (this.lineSeparator ? (n10 = e10.indexOf(this.lineSeparator, i10), o10 = this.lineSeparator.length) : (r10 = s10.exec(e10)) && (n10 = r10.index, o10 = r10[0].length), this.append(e10.slice(i10, n10 < 0 ? e10.length : n10)), n10 < 0) break;
      if (this.lineBreak(), o10 > 1) for (let e11 of this.points) e11.node == t107 && e11.pos > this.text.length && (e11.pos -= o10 - 1);
      i10 = n10 + o10;
    }
  }
  readNode(t107) {
    if (t107.cmIgnore) return;
    let e10 = w3.get(t107), i10 = e10 && e10.overrideDOMText;
    if (null != i10) {
      this.findPointInside(t107, i10.length);
      for (let t108 = i10.iter(); !t108.next().done; ) t108.lineBreak ? this.lineBreak() : this.append(t108.value);
    } else 3 == t107.nodeType ? this.readTextNode(t107) : "BR" == t107.nodeName ? t107.nextSibling && this.lineBreak() : 1 == t107.nodeType && this.readRange(t107.firstChild, null);
  }
  findPointBefore(t107, e10) {
    for (let i10 of this.points) i10.node == t107 && t107.childNodes[i10.offset] == e10 && (i10.pos = this.text.length);
  }
  findPointInside(t107, e10) {
    for (let i10 of this.points) (3 == t107.nodeType ? i10.node == t107 : t107.contains(i10.node)) && (i10.pos = this.text.length + (!function(t108, e11, i11) {
      for (; ; ) {
        if (!e11 || i11 < w_(e11)) return false;
        if (e11 == t108) return true;
        i11 = wz(e11) + 1, e11 = e11.parentNode;
      }
    }(t107, i10.node, i10.offset) ? 0 : e10));
  }
}
class xy {
  constructor(t107, e10) {
    this.node = t107, this.offset = e10, this.pos = -1;
  }
}
class xx {
  constructor(t107, e10, i10, s10) {
    this.typeOver = s10, this.bounds = null, this.text = "", this.domChanged = e10 > -1;
    let { impreciseHead: n10, impreciseAnchor: o10 } = t107.docView;
    if (t107.state.readOnly && e10 > -1) this.newSel = null;
    else if (e10 > -1 && (this.bounds = t107.docView.domBoundsAround(e10, i10, 0))) {
      let e11 = n10 || o10 ? [] : function(t108) {
        let e12 = [];
        if (t108.root.activeElement != t108.contentDOM) return e12;
        let { anchorNode: i12, anchorOffset: s11, focusNode: n11, focusOffset: o11 } = t108.observer.selectionRange;
        return i12 && (e12.push(new xy(i12, s11)), (n11 != i12 || o11 != s11) && e12.push(new xy(n11, o11))), e12;
      }(t107), i11 = new xb(e11, t107.state);
      i11.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = i11.text, this.newSel = function(t108, e12) {
        if (0 == t108.length) return null;
        let i12 = t108[0].pos, s11 = 2 == t108.length ? t108[1].pos : i12;
        return i12 > -1 && s11 > -1 ? ti.single(i12 + e12, s11 + e12) : null;
      }(e11, this.bounds.from);
    } else {
      let e11 = t107.observer.selectionRange, i11 = n10 && n10.node == e11.focusNode && n10.offset == e11.focusOffset || !wH(t107.contentDOM, e11.focusNode) ? t107.state.selection.main.head : t107.docView.posFromDOM(e11.focusNode, e11.focusOffset), s11 = o10 && o10.node == e11.anchorNode && o10.offset == e11.anchorOffset || !wH(t107.contentDOM, e11.anchorNode) ? t107.state.selection.main.anchor : t107.docView.posFromDOM(e11.anchorNode, e11.anchorOffset), r10 = t107.viewport;
      if ((bc.ios || bc.chrome) && t107.state.selection.main.empty && i11 != s11 && (r10.from > 0 || r10.to < t107.state.doc.length)) {
        let e12 = Math.min(i11, s11), n11 = Math.max(i11, s11), o11 = r10.from - e12, l10 = r10.to - n11;
        (0 == o11 || 1 == o11 || 0 == e12) && (0 == l10 || -1 == l10 || n11 == t107.state.doc.length) && (i11 = 0, s11 = t107.state.doc.length);
      }
      this.newSel = ti.single(s11, i11);
    }
  }
}
function xS(t107, e10) {
  let i10;
  let { newSel: s10 } = e10, n10 = t107.state.selection.main, o10 = t107.inputState.lastKeyTime > Date.now() - 100 ? t107.inputState.lastKeyCode : -1;
  if (e10.bounds) {
    let { from: s11, to: l10 } = e10.bounds, h10 = n10.from, a10 = null;
    (8 === o10 || bc.android && e10.text.length < l10 - s11) && (h10 = n10.to, a10 = "end");
    let c10 = function(t108, e11, i11, s12) {
      let n11 = Math.min(t108.length, e11.length), o11 = 0;
      for (; o11 < n11 && t108.charCodeAt(o11) == e11.charCodeAt(o11); ) o11++;
      if (o11 == n11 && t108.length == e11.length) return null;
      let r10 = t108.length, l11 = e11.length;
      for (; r10 > 0 && l11 > 0 && t108.charCodeAt(r10 - 1) == e11.charCodeAt(l11 - 1); ) r10--, l11--;
      if ("end" == s12) {
        let t109 = Math.max(0, o11 - Math.min(r10, l11));
        i11 -= r10 + t109 - o11;
      }
      if (r10 < o11 && t108.length < e11.length) {
        let t109 = i11 <= o11 && i11 >= r10 ? o11 - i11 : 0;
        o11 -= t109, l11 = o11 + (l11 - r10), r10 = o11;
      } else if (l11 < o11) {
        let t109 = i11 <= o11 && i11 >= l11 ? o11 - i11 : 0;
        o11 -= t109, r10 = o11 + (r10 - l11), l11 = o11;
      }
      return { from: o11, toA: r10, toB: l11 };
    }(t107.state.doc.sliceString(s11, l10, ""), e10.text, h10 - s11, a10);
    c10 && (bc.chrome && 13 == o10 && c10.toB == c10.from + 2 && "" == e10.text.slice(c10.from, c10.toB) && c10.toB--, i10 = { from: s11 + c10.from, to: s11 + c10.toA, insert: r.of(e10.text.slice(c10.from, c10.toB).split("")) });
  } else s10 && (!t107.hasFocus && t107.state.facet(b5) || s10.main.eq(n10)) && (s10 = null);
  if (!i10 && !s10) return false;
  if (!i10 && e10.typeOver && !n10.empty && s10 && s10.main.empty ? i10 = { from: n10.from, to: n10.to, insert: t107.state.doc.slice(n10.from, n10.to) } : i10 && i10.from >= n10.from && i10.to <= n10.to && (i10.from != n10.from || i10.to != n10.to) && n10.to - n10.from - (i10.to - i10.from) <= 4 ? i10 = { from: n10.from, to: n10.to, insert: t107.state.doc.slice(n10.from, i10.from).append(i10.insert).append(t107.state.doc.slice(i10.to, n10.to)) } : (bc.mac || bc.android) && i10 && i10.from == i10.to && i10.from == n10.head - 1 && /^\. ?$/.test(i10.insert.toString()) && "off" == t107.contentDOM.getAttribute("autocorrect") ? (s10 && 2 == i10.insert.length && (s10 = ti.single(s10.main.anchor - 1, s10.main.head - 1)), i10 = { from: n10.from, to: n10.to, insert: r.of([" "]) }) : bc.chrome && i10 && i10.from == i10.to && i10.from == n10.head && "\n " == i10.insert.toString() && t107.lineWrapping && (s10 && (s10 = ti.single(s10.main.anchor - 1, s10.main.head - 1)), i10 = { from: n10.from, to: n10.to, insert: r.of([" "]) }), i10) {
    let e11;
    if (bc.ios && t107.inputState.flushIOSKey(i10) || bc.android && (i10.to == n10.to && (i10.from == n10.from || i10.from == n10.from - 1 && " " == t107.state.sliceDoc(i10.from, n10.from)) && 1 == i10.insert.length && 2 == i10.insert.lines && wJ(t107.contentDOM, "Enter", 13) || (i10.from == n10.from - 1 && i10.to == n10.to && 0 == i10.insert.length || 8 == o10 && i10.insert.length < i10.to - i10.from && i10.to > n10.head) && wJ(t107.contentDOM, "Backspace", 8) || i10.from == n10.from && i10.to == n10.to + 1 && 0 == i10.insert.length && wJ(t107.contentDOM, "Delete", 46))) return true;
    let r10 = i10.insert.toString();
    t107.inputState.composing >= 0 && t107.inputState.composing++;
    let l10 = () => e11 || (e11 = function(t108, e12, i11) {
      let s11, n11 = t108.state, o11 = n11.selection.main;
      if (e12.from >= o11.from && e12.to <= o11.to && e12.to - e12.from >= (o11.to - o11.from) / 3 && (!i11 || i11.main.empty && i11.main.from == e12.from + e12.insert.length) && t108.inputState.composing < 0) {
        let i12 = o11.from < e12.from ? n11.sliceDoc(o11.from, e12.from) : "", r12 = o11.to > e12.to ? n11.sliceDoc(e12.to, o11.to) : "";
        s11 = n11.replaceSelection(t108.state.toText(i12 + e12.insert.sliceString(0, void 0, t108.state.lineBreak) + r12));
      } else {
        let r12 = n11.changes(e12), l11 = i11 && i11.main.to <= r12.newLength ? i11.main : void 0;
        if (n11.selection.ranges.length > 1 && t108.inputState.composing >= 0 && e12.to <= o11.to && e12.to >= o11.to - 10) {
          let h10 = t108.state.sliceDoc(e12.from, e12.to), a10, c10 = i11 && ym(t108, i11.main.head);
          if (c10) {
            let t109 = e12.insert.length - (e12.to - e12.from);
            a10 = { from: c10.from, to: c10.to - t109 };
          } else a10 = t108.state.doc.lineAt(o11.head);
          let d10 = o11.to - e12.to, u10 = o11.to - o11.from;
          s11 = n11.changeByRange((i12) => {
            if (i12.from == o11.from && i12.to == o11.to) return { changes: r12, range: l11 || i12.map(r12) };
            let s12 = i12.to - d10, c11 = s12 - h10.length;
            if (i12.to - i12.from != u10 || t108.state.sliceDoc(c11, s12) != h10 || i12.to >= a10.from && i12.from <= a10.to) return { range: i12 };
            let f10 = n11.changes({ from: c11, to: s12, insert: e12.insert }), g10 = i12.to - o11.to;
            return { changes: f10, range: l11 ? ti.range(Math.max(0, l11.anchor + g10), Math.max(0, l11.head + g10)) : i12.map(f10) };
          });
        } else s11 = { changes: r12, selection: l11 && n11.selection.replaceRange(l11) };
      }
      let r11 = "input.type";
      return (t108.composing || t108.inputState.compositionPendingChange && t108.inputState.compositionEndedAt > Date.now() - 50) && (t108.inputState.compositionPendingChange = false, r11 += ".compose", t108.inputState.compositionFirstChange && (r11 += ".start", t108.inputState.compositionFirstChange = false)), n11.update(s11, { userEvent: r11, scrollIntoView: true });
    }(t107, i10, s10));
    return t107.state.facet(bZ).some((e12) => e12(t107, i10.from, i10.to, r10, l10)) || t107.dispatch(l10()), true;
  }
  if (!s10 || s10.main.eq(n10)) return false;
  {
    let e11 = false, i11 = "select";
    return t107.inputState.lastSelectionTime > Date.now() - 50 && ("select" == t107.inputState.lastSelectionOrigin && (e11 = true), i11 = t107.inputState.lastSelectionOrigin), t107.dispatch({ selection: s10, scrollIntoView: e11, userEvent: i11 }), true;
  }
}
let xk = { childList: true, characterData: true, subtree: true, attributes: true, characterDataOldValue: true }, xM = bc.ie && bc.ie_version <= 11;
class xC {
  constructor(t107) {
    this.view = t107, this.active = false, this.selectionRange = new wU(), this.selectionChanged = false, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = false, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = t107.contentDOM, this.observer = new MutationObserver((e10) => {
      for (let t108 of e10) this.queue.push(t108);
      (bc.ie && bc.ie_version <= 11 || bc.ios && t107.composing) && e10.some((t108) => "childList" == t108.type && t108.removedNodes.length || "characterData" == t108.type && t108.oldValue.length > t108.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), xM && (this.onCharData = (t108) => {
      this.queue.push({ target: t108.target, type: "characterData", oldValue: t108.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), "function" == typeof ResizeObserver && (this.resizeScroll = new ResizeObserver(() => {
      var t108;
      (null === (t108 = this.view.docView) || void 0 === t108 ? void 0 : t108.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(t107.scrollDOM)), this.addWindowListeners(this.win = t107.win), this.start(), "function" == typeof IntersectionObserver && (this.intersection = new IntersectionObserver((t108) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), t108.length > 0 && t108[t108.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((t108) => {
      t108.length > 0 && t108[t108.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(t107) {
    this.view.inputState.runHandlers("scroll", t107), this.intersecting && this.view.measure();
  }
  onScroll(t107) {
    this.intersecting && this.flush(false), this.onScrollChanged(t107);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(t107) {
    ("change" != t107.type || t107.matches) && (this.view.viewState.printing = true, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = false, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(t107) {
    if (this.gapIntersection && (t107.length != this.gaps.length || this.gaps.some((e10, i10) => e10 != t107[i10]))) {
      for (let e10 of (this.gapIntersection.disconnect(), t107)) this.gapIntersection.observe(e10);
      this.gaps = t107;
    }
  }
  onSelectionChange(t107) {
    let e10 = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey) return;
    let { view: i10 } = this, s10 = this.selectionRange;
    if (i10.state.facet(b5) ? i10.root.activeElement != this.dom : !wF(i10.dom, s10)) return;
    let n10 = s10.anchorNode && i10.docView.nearest(s10.anchorNode);
    if (n10 && n10.ignoreEvent(t107)) {
      e10 || (this.selectionChanged = false);
      return;
    }
    (bc.ie && bc.ie_version <= 11 || bc.android && bc.chrome) && !i10.state.selection.main.empty && s10.focusNode && wI(s10.focusNode, s10.focusOffset, s10.anchorNode, s10.anchorOffset) ? this.flushSoon() : this.flush(false);
  }
  readSelectionRange() {
    let { view: t107 } = this, e10 = wV(t107.root);
    if (!e10) return false;
    let i10 = bc.safari && 11 == t107.root.nodeType && function(t108) {
      let e11 = t108.activeElement;
      for (; e11 && e11.shadowRoot; ) e11 = e11.shadowRoot.activeElement;
      return e11;
    }(this.dom.ownerDocument) == this.dom && function(t108, e11) {
      if (e11.getComposedRanges) {
        let i12 = e11.getComposedRanges(t108.root)[0];
        if (i12) return xD(t108, i12);
      }
      let i11 = null;
      function s11(t109) {
        t109.preventDefault(), t109.stopImmediatePropagation(), i11 = t109.getTargetRanges()[0];
      }
      return t108.contentDOM.addEventListener("beforeinput", s11, true), t108.dom.ownerDocument.execCommand("indent"), t108.contentDOM.removeEventListener("beforeinput", s11, true), i11 ? xD(t108, i11) : null;
    }(this.view, e10) || e10;
    if (!i10 || this.selectionRange.eq(i10)) return false;
    let s10 = wF(this.dom, i10);
    return s10 && !this.selectionChanged && t107.inputState.lastFocusTime > Date.now() - 200 && t107.inputState.lastTouchTime < Date.now() - 300 && function(t108, e11) {
      let i11 = e11.focusNode, s11 = e11.focusOffset;
      if (!i11 || e11.anchorNode != i11 || e11.anchorOffset != s11) return false;
      for (s11 = Math.min(s11, w_(i11)); ; ) if (s11) {
        if (1 != i11.nodeType) return false;
        let t109 = i11.childNodes[s11 - 1];
        "false" == t109.contentEditable ? s11-- : s11 = w_(i11 = t109);
      } else {
        if (i11 == t108) return true;
        s11 = wz(i11), i11 = i11.parentNode;
      }
    }(this.dom, i10) ? (this.view.inputState.lastFocusTime = 0, t107.docView.updateSelection(), false) : (this.selectionRange.setRange(i10), s10 && (this.selectionChanged = true), true);
  }
  setSelectionRange(t107, e10) {
    this.selectionRange.set(t107.node, t107.offset, e10.node, e10.offset), this.selectionChanged = false;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let t107 = 0, e10 = null;
    for (let i10 = this.dom; i10; ) if (1 == i10.nodeType) !e10 && t107 < this.scrollTargets.length && this.scrollTargets[t107] == i10 ? t107++ : e10 || (e10 = this.scrollTargets.slice(0, t107)), e10 && e10.push(i10), i10 = i10.assignedSlot || i10.parentNode;
    else if (11 == i10.nodeType) i10 = i10.host;
    else break;
    if (t107 < this.scrollTargets.length && !e10 && (e10 = this.scrollTargets.slice(0, t107)), e10) {
      for (let t108 of this.scrollTargets) t108.removeEventListener("scroll", this.onScroll);
      for (let t108 of this.scrollTargets = e10) t108.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(t107) {
    if (!this.active) return t107();
    try {
      return this.stop(), t107();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, xk), xM && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = true);
  }
  stop() {
    this.active && (this.active = false, this.observer.disconnect(), xM && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = false;
  }
  delayAndroidKey(t107, e10) {
    var i10;
    this.delayedAndroidKey || (this.flushingAndroidKey = this.view.win.requestAnimationFrame(() => {
      let t108 = this.delayedAndroidKey;
      t108 && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = t108.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && t108.force && wJ(this.dom, t108.key, t108.keyCode));
    })), this.delayedAndroidKey && "Enter" != t107 || (this.delayedAndroidKey = { key: t107, keyCode: e10, force: this.lastChange < Date.now() - 50 || !!(null === (i10 = this.delayedAndroidKey) || void 0 === i10 ? void 0 : i10.force) });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let t107 of this.observer.takeRecords()) this.queue.push(t107);
    return this.queue;
  }
  processRecords() {
    let t107 = this.pendingRecords();
    t107.length && (this.queue = []);
    let e10 = -1, i10 = -1, s10 = false;
    for (let n10 of t107) {
      let t108 = this.readMutation(n10);
      t108 && (t108.typeOver && (s10 = true), -1 == e10 ? { from: e10, to: i10 } = t108 : (e10 = Math.min(t108.from, e10), i10 = Math.max(t108.to, i10)));
    }
    return { from: e10, to: i10, typeOver: s10 };
  }
  readChange() {
    let { from: t107, to: e10, typeOver: i10 } = this.processRecords(), s10 = this.selectionChanged && wF(this.dom, this.selectionRange);
    if (t107 < 0 && !s10) return null;
    t107 > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = false;
    let n10 = new xx(this.view, t107, e10, i10);
    return this.view.docView.domChanged = { newSel: n10.newSel ? n10.newSel.main : null }, n10;
  }
  flush() {
    let t107 = !(arguments.length > 0) || void 0 === arguments[0] || arguments[0];
    if (this.delayedFlush >= 0 || this.delayedAndroidKey) return false;
    t107 && this.readSelectionRange();
    let e10 = this.readChange();
    if (!e10) return this.view.requestMeasure(), false;
    let i10 = this.view.state, s10 = xS(this.view, e10);
    return this.view.state == i10 && (e10.domChanged || e10.newSel && !e10.newSel.main.eq(this.view.state.selection.main)) && this.view.update([]), s10;
  }
  readMutation(t107) {
    let e10 = this.view.docView.nearest(t107.target);
    if (!e10 || e10.ignoreMutation(t107)) return null;
    if (e10.markDirty("attributes" == t107.type), "attributes" == t107.type && (e10.flags |= 4), "childList" == t107.type) {
      let i10 = xA(e10, t107.previousSibling || t107.target.previousSibling, -1), s10 = xA(e10, t107.nextSibling || t107.target.nextSibling, 1);
      return { from: i10 ? e10.posAfter(i10) : e10.posAtStart, to: s10 ? e10.posBefore(s10) : e10.posAtEnd, typeOver: false };
    }
    return "characterData" == t107.type ? { from: e10.posAtStart, to: e10.posAtEnd, typeOver: t107.target.nodeValue == t107.oldValue } : null;
  }
  setWindow(t107) {
    t107 != this.win && (this.removeWindowListeners(this.win), this.win = t107, this.addWindowListeners(this.win));
  }
  addWindowListeners(t107) {
    t107.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener("change", this.onPrint) : t107.addEventListener("beforeprint", this.onPrint), t107.addEventListener("scroll", this.onScroll), t107.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(t107) {
    t107.removeEventListener("scroll", this.onScroll), t107.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener("change", this.onPrint) : t107.removeEventListener("beforeprint", this.onPrint), t107.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var t107, e10, i10;
    for (let s10 of (this.stop(), null === (t107 = this.intersection) || void 0 === t107 || t107.disconnect(), null === (e10 = this.gapIntersection) || void 0 === e10 || e10.disconnect(), null === (i10 = this.resizeScroll) || void 0 === i10 || i10.disconnect(), this.scrollTargets)) s10.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
}
function xA(t107, e10, i10) {
  for (; e10; ) {
    let s10 = w3.get(e10);
    if (s10 && s10.parent == t107) return s10;
    let n10 = e10.parentNode;
    e10 = n10 != t107.dom ? n10 : i10 > 0 ? e10.nextSibling : e10.previousSibling;
  }
  return null;
}
function xD(t107, e10) {
  let i10 = e10.startContainer, s10 = e10.startOffset, n10 = e10.endContainer, o10 = e10.endOffset, r10 = t107.docView.domAtPos(t107.state.selection.main.anchor);
  return wI(r10.node, r10.offset, n10, o10) && ([i10, s10, n10, o10] = [n10, o10, i10, s10]), { anchorNode: i10, anchorOffset: s10, focusNode: n10, focusOffset: o10 };
}
class xO {
  get state() {
    return this.viewState.state;
  }
  get viewport() {
    return this.viewState.viewport;
  }
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  get inView() {
    return this.viewState.inView;
  }
  get composing() {
    return this.inputState.composing > 0;
  }
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  get root() {
    return this._root;
  }
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  constructor(t107 = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = false, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), t107.parent && t107.parent.appendChild(this.dom);
    let { dispatch: e10 } = t107;
    for (let i10 of (this.dispatchTransactions = t107.dispatchTransactions || e10 && ((t108) => t108.forEach((t109) => e10(t109, this))) || ((t108) => this.update(t108)), this.dispatch = this.dispatch.bind(this), this._root = t107.root || function(t108) {
      for (; t108; ) {
        if (t108 && (9 == t108.nodeType || 11 == t108.nodeType && t108.host)) return t108;
        t108 = t108.assignedSlot || t108.parentNode;
      }
      return null;
    }(t107.parent) || document, this.viewState = new xn(t107.state || tW.create(t107)), t107.scrollTo && t107.scrollTo.is(b4) && (this.viewState.scrollTarget = t107.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(b7).map((t108) => new ye(t108)), this.plugins)) i10.update(this);
    this.observer = new xC(this), this.inputState = new yD(this), this.inputState.ensureHandlers(this.plugins), this.docView = new yg(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure();
  }
  dispatch() {
    for (var t107 = arguments.length, e10 = Array(t107), i10 = 0; i10 < t107; i10++) e10[i10] = arguments[i10];
    let s10 = 1 == e10.length && e10[0] instanceof tB ? e10 : 1 == e10.length && Array.isArray(e10[0]) ? e10[0] : [this.state.update(...e10)];
    this.dispatchTransactions(s10, this);
  }
  update(t107) {
    if (0 != this.updateState) throw Error("Calls to EditorView.update are not allowed while an update is in progress");
    let e10 = false, i10 = false, s10, n10 = this.state;
    for (let e11 of t107) {
      if (e11.startState != n10) throw RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      n10 = e11.state;
    }
    if (this.destroyed) {
      this.viewState.state = n10;
      return;
    }
    let o10 = this.hasFocus, r10 = 0, l10 = null;
    t107.some((t108) => t108.annotation(y$)) ? (this.inputState.notifiedFocused = o10, r10 = 1) : o10 == this.inputState.notifiedFocused || (this.inputState.notifiedFocused = o10, (l10 = yX(n10, o10)) || (r10 = 1));
    let h10 = this.observer.delayedAndroidKey, a10 = null;
    if (h10 ? (this.observer.clearDelayedAndroidKey(), ((a10 = this.observer.readChange()) && !this.state.doc.eq(n10.doc) || !this.state.selection.eq(n10.selection)) && (a10 = null)) : this.observer.clear(), n10.facet(tW.phrases) != this.state.facet(tW.phrases)) return this.setState(n10);
    s10 = yf.create(this, n10, t107), s10.flags |= r10;
    let c10 = this.viewState.scrollTarget;
    try {
      for (let e11 of (this.updateState = 2, t107)) {
        if (c10 && (c10 = c10.map(e11.changes)), e11.scrollIntoView) {
          let { main: t108 } = e11.state.selection;
          c10 = new b3(t108.empty ? t108 : ti.cursor(t108.head, t108.head > t108.anchor ? -1 : 1));
        }
        for (let t108 of e11.effects) t108.is(b4) && (c10 = t108.value.clip(this.state));
      }
      this.viewState.update(s10, c10), this.bidiCache = xR.update(this.bidiCache, s10.changes), s10.empty || (this.updatePlugins(s10), this.inputState.update(s10)), e10 = this.docView.update(s10), this.state.facet(yd) != this.styleModules && this.mountStyles(), i10 = this.updateAttrs(), this.showAnnouncements(t107), this.docView.updateSelection(e10, t107.some((t108) => t108.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (s10.startState.facet(xd) != s10.state.facet(xd) && (this.viewState.mustMeasureContent = true), (e10 || i10 || c10 || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), e10 && this.docViewUpdate(), !s10.empty) for (let t108 of this.state.facet(bQ)) try {
      t108(s10);
    } catch (t109) {
      b9(this.state, t109, "update listener");
    }
    (l10 || a10) && Promise.resolve().then(() => {
      l10 && this.state == l10.startState && this.dispatch(l10), a10 && !xS(this, a10) && h10.force && wJ(this.contentDOM, h10.key, h10.keyCode);
    });
  }
  setState(t107) {
    if (0 != this.updateState) throw Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = t107;
      return;
    }
    this.updateState = 2;
    let e10 = this.hasFocus;
    try {
      for (let t108 of this.plugins) t108.destroy(this);
      for (let e11 of (this.viewState = new xn(t107), this.plugins = t107.facet(b7).map((t108) => new ye(t108)), this.pluginMap.clear(), this.plugins)) e11.update(this);
      this.docView.destroy(), this.docView = new yg(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    e10 && this.focus(), this.requestMeasure();
  }
  updatePlugins(t107) {
    let e10 = t107.startState.facet(b7), i10 = t107.state.facet(b7);
    if (e10 != i10) {
      let s10 = [];
      for (let n10 of i10) {
        let i11 = e10.indexOf(n10);
        if (i11 < 0) s10.push(new ye(n10));
        else {
          let e11 = this.plugins[i11];
          e11.mustUpdate = t107, s10.push(e11);
        }
      }
      for (let e11 of this.plugins) e11.mustUpdate != t107 && e11.destroy(this);
      this.plugins = s10, this.pluginMap.clear();
    } else for (let e11 of this.plugins) e11.mustUpdate = t107;
    for (let t108 = 0; t108 < this.plugins.length; t108++) this.plugins[t108].update(this);
    e10 != i10 && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let t107 of this.plugins) {
      let e10 = t107.value;
      if (e10 && e10.docViewUpdate) try {
        e10.docViewUpdate(this);
      } catch (t108) {
        b9(this.state, t108, "doc view update listener");
      }
    }
  }
  measure() {
    let t107 = !(arguments.length > 0) || void 0 === arguments[0] || arguments[0];
    if (this.destroyed) return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, t107 && this.observer.forceFlush();
    let e10 = null, i10 = this.scrollDOM, s10 = i10.scrollTop * this.scaleY, { scrollAnchorPos: n10, scrollAnchorHeight: o10 } = this.viewState;
    Math.abs(s10 - this.viewState.scrollTop) > 1 && (o10 = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let t108 = 0; ; t108++) {
        if (o10 < 0) {
          if (wZ(i10)) n10 = -1, o10 = this.viewState.heightMap.height;
          else {
            let t109 = this.viewState.scrollAnchorAt(s10);
            n10 = t109.from, o10 = t109.top;
          }
        }
        this.updateState = 1;
        let r10 = this.viewState.measure(this);
        if (!r10 && !this.measureRequests.length && null == this.viewState.scrollTarget) break;
        if (t108 > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let l10 = [];
        4 & r10 || ([this.measureRequests, l10] = [l10, this.measureRequests]);
        let h10 = l10.map((t109) => {
          try {
            return t109.read(this);
          } catch (t110) {
            return b9(this.state, t110), xE;
          }
        }), a10 = yf.create(this, this.state, []), c10 = false;
        a10.flags |= r10, e10 ? e10.flags |= r10 : e10 = a10, this.updateState = 2, !a10.empty && (this.updatePlugins(a10), this.inputState.update(a10), this.updateAttrs(), (c10 = this.docView.update(a10)) && this.docViewUpdate());
        for (let t109 = 0; t109 < l10.length; t109++) if (h10[t109] != xE) try {
          let e11 = l10[t109];
          e11.write && e11.write(h10[t109], this);
        } catch (t110) {
          b9(this.state, t110);
        }
        if (c10 && this.docView.updateSelection(true), !a10.viewportChanged && 0 == this.measureRequests.length) {
          if (this.viewState.editorHeight) {
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, o10 = -1;
              continue;
            }
            {
              let t109 = (n10 < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(n10).top) - o10;
              if (t109 > 1 || t109 < -1) {
                s10 += t109, i10.scrollTop = s10 / this.scaleY, o10 = -1;
                continue;
              }
            }
          }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (e10 && !e10.empty) for (let t108 of this.state.facet(bQ)) t108(e10);
  }
  get themeClasses() {
    return xf + " " + (this.state.facet(xu) ? xp : xg) + " " + this.state.facet(xd);
  }
  updateAttrs() {
    let t107 = xB(this, yi, { class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses }), e10 = { spellcheck: "false", autocorrect: "off", autocapitalize: "off", translate: "no", contenteditable: this.state.facet(b5) ? "true" : "false", class: "cm-content", style: `${bc.tabSize}: ${this.state.tabSize}`, role: "textbox", "aria-multiline": "true" };
    this.state.readOnly && (e10["aria-readonly"] = "true"), xB(this, ys, e10);
    let i10 = this.observer.ignore(() => {
      let i11 = by(this.contentDOM, this.contentAttrs, e10), s10 = by(this.dom, this.editorAttrs, t107);
      return i11 || s10;
    });
    return this.editorAttrs = t107, this.contentAttrs = e10, i10;
  }
  showAnnouncements(t107) {
    let e10 = true;
    for (let i10 of t107) for (let t108 of i10.effects) t108.is(xO.announce) && (e10 && (this.announceDOM.textContent = ""), e10 = false, this.announceDOM.appendChild(document.createElement("div")).textContent = t108.value);
  }
  mountStyles() {
    this.styleModules = this.state.facet(yd);
    let t107 = this.state.facet(xO.cspNonce);
    t6.mount(this.root, this.styleModules.concat(xw).reverse(), t107 ? { nonce: t107 } : void 0);
  }
  readMeasured() {
    if (2 == this.updateState) throw Error("Reading the editor layout isn't allowed during an update");
    0 == this.updateState && this.measureScheduled > -1 && this.measure(false);
  }
  requestMeasure(t107) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), t107 && !(this.measureRequests.indexOf(t107) > -1)) {
      if (null != t107.key) {
        for (let e10 = 0; e10 < this.measureRequests.length; e10++) if (this.measureRequests[e10].key === t107.key) {
          this.measureRequests[e10] = t107;
          return;
        }
      }
      this.measureRequests.push(t107);
    }
  }
  plugin(t107) {
    let e10 = this.pluginMap.get(t107);
    return (void 0 === e10 || e10 && e10.spec != t107) && this.pluginMap.set(t107, e10 = this.plugins.find((e11) => e11.spec == t107) || null), e10 && e10.update(this).value;
  }
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  get scaleX() {
    return this.viewState.scaleX;
  }
  get scaleY() {
    return this.viewState.scaleY;
  }
  elementAtHeight(t107) {
    return this.readMeasured(), this.viewState.elementAtHeight(t107);
  }
  lineBlockAtHeight(t107) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(t107);
  }
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  lineBlockAt(t107) {
    return this.viewState.lineBlockAt(t107);
  }
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  moveByChar(t107, e10, i10) {
    return yA(this, t107, yM(this, t107, e10, i10));
  }
  moveByGroup(t107, e10) {
    return yA(this, t107, yM(this, t107, e10, (e11) => {
      var i10;
      let s10, n10;
      return i10 = t107.head, n10 = (s10 = this.state.charCategorizer(i10))(e11), (t108) => {
        let e12 = s10(t108);
        return n10 == tH.Space && (n10 = e12), n10 == e12;
      };
    }));
  }
  visualLineSide(t107, e10) {
    let i10 = this.bidiSpans(t107), s10 = this.textDirectionAt(t107.from), n10 = i10[e10 ? i10.length - 1 : 0];
    return ti.cursor(n10.side(e10, s10) + t107.from, n10.forward(!e10, s10) ? 1 : -1);
  }
  moveToLineBoundary(t107, e10) {
    let i10 = !(arguments.length > 2) || void 0 === arguments[2] || arguments[2];
    return function(t108, e11, i11, s10) {
      let n10 = function(t109, e12) {
        let i12 = t109.lineBlockAt(e12);
        if (Array.isArray(i12.type)) {
          for (let t110 of i12.type) if (t110.to > e12 || t110.to == e12 && (t110.to == i12.to || t110.type == bM.Text)) return t110;
        }
        return i12;
      }(t108, e11.head), o10 = s10 && n10.type == bM.Text && (t108.lineWrapping || n10.widgetLineBreaks) ? t108.coordsAtPos(e11.assoc < 0 && e11.head > n10.from ? e11.head - 1 : e11.head) : null;
      if (o10) {
        let e12 = t108.dom.getBoundingClientRect(), s11 = t108.textDirectionAt(n10.from), r10 = t108.posAtCoords({ x: i11 == (s11 == bP.LTR) ? e12.right - 1 : e12.left + 1, y: (o10.top + o10.bottom) / 2 });
        if (null != r10) return ti.cursor(r10, i11 ? -1 : 1);
      }
      return ti.cursor(i11 ? n10.to : n10.from, i11 ? -1 : 1);
    }(this, t107, e10, i10);
  }
  moveVertically(t107, e10, i10) {
    return yA(this, t107, function(t108, e11, i11, s10) {
      let n10 = e11.head, o10 = i11 ? 1 : -1;
      if (n10 == (i11 ? t108.state.doc.length : 0)) return ti.cursor(n10, e11.assoc);
      let r10 = e11.goalColumn, l10, h10 = t108.contentDOM.getBoundingClientRect(), a10 = t108.coordsAtPos(n10, e11.assoc || -1), c10 = t108.documentTop;
      if (a10) null == r10 && (r10 = a10.left - h10.left), l10 = o10 < 0 ? a10.top : a10.bottom;
      else {
        let e12 = t108.viewState.lineBlockAt(n10);
        null == r10 && (r10 = Math.min(h10.right - h10.left, t108.defaultCharacterWidth * (n10 - e12.from))), l10 = (o10 < 0 ? e12.top : e12.bottom) + c10;
      }
      let d10 = h10.left + r10, u10 = null != s10 ? s10 : t108.viewState.heightOracle.textHeight >> 1;
      for (let e12 = 0; ; e12 += 10) {
        let i12 = l10 + (u10 + e12) * o10, s11 = yS(t108, { x: d10, y: i12 }, false, o10);
        if (i12 < h10.top || i12 > h10.bottom || (o10 < 0 ? s11 < n10 : s11 > n10)) {
          let e13 = t108.docView.coordsForChar(s11), n11 = !e13 || i12 < e13.top ? -1 : 1;
          return ti.cursor(s11, n11, void 0, r10);
        }
      }
    }(this, t107, e10, i10));
  }
  domAtPos(t107) {
    return this.docView.domAtPos(t107);
  }
  posAtDOM(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    return this.docView.posFromDOM(t107, e10);
  }
  posAtCoords(t107) {
    let e10 = !(arguments.length > 1) || void 0 === arguments[1] || arguments[1];
    return this.readMeasured(), yS(this, t107, e10);
  }
  coordsAtPos(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
    this.readMeasured();
    let i10 = this.docView.coordsAt(t107, e10);
    if (!i10 || i10.left == i10.right) return i10;
    let s10 = this.state.doc.lineAt(t107), n10 = this.bidiSpans(s10);
    return wG(i10, n10[b_.find(n10, t107 - s10.from, -1, e10)].dir == bP.LTR == e10 > 0);
  }
  coordsForChar(t107) {
    return this.readMeasured(), this.docView.coordsForChar(t107);
  }
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  textDirectionAt(t107) {
    return !this.state.facet(b1) || t107 < this.viewport.from || t107 > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(t107));
  }
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  bidiSpans(t107) {
    if (t107.length > xT) return bj(t107.length);
    let e10 = this.textDirectionAt(t107.from), i10;
    for (let s11 of this.bidiCache) if (s11.from == t107.from && s11.dir == e10 && (s11.fresh || function t108(e11, i11) {
      if (e11.length != i11.length) return false;
      for (let s12 = 0; s12 < e11.length; s12++) {
        let n10 = e11[s12], o10 = i11[s12];
        if (n10.from != o10.from || n10.to != o10.to || n10.direction != o10.direction || !t108(n10.inner, o10.inner)) return false;
      }
      return true;
    }(s11.isolates, i10 = yh(this, t107)))) return s11.order;
    i10 || (i10 = yh(this, t107));
    let s10 = function(t108, e11, i11) {
      if (!t108) return [new b_(0, 0, e11 == bV ? 1 : 0)];
      if (e11 == bN && !i11.length && !bq.test(t108)) return bj(t108.length);
      if (i11.length) for (; t108.length > bG.length; ) bG[bG.length] = 256;
      let s11 = [], n10 = e11 == bN ? 0 : 1;
      return function t109(e12, i12, s12, n11, o10, r10, l10) {
        let h10 = i12 % 2 ? 2 : 1;
        (function(t110, e13, i13, s13, n12) {
          for (let o11 = 0; o11 <= s13.length; o11++) {
            let r11 = o11 ? s13[o11 - 1].to : e13, l11 = o11 < s13.length ? s13[o11].from : i13, h11 = o11 ? 256 : n12;
            for (let e14 = r11, i14 = h11, s14 = h11; e14 < l11; e14++) {
              let n13 = bK(t110.charCodeAt(e14));
              512 == n13 ? n13 = i14 : 8 == n13 && 4 == s14 && (n13 = 16), bG[e14] = 4 == n13 ? 2 : n13, 7 & n13 && (s14 = n13), i14 = n13;
            }
            for (let t111 = r11, e14 = h11, s14 = h11; t111 < l11; t111++) {
              let n13 = bG[t111];
              if (128 == n13) t111 < l11 - 1 && e14 == bG[t111 + 1] && 24 & e14 ? n13 = bG[t111] = e14 : bG[t111] = 256;
              else if (64 == n13) {
                let n14 = t111 + 1;
                for (; n14 < l11 && 64 == bG[n14]; ) n14++;
                let o12 = t111 && 8 == e14 || n14 < i13 && 8 == bG[n14] ? 1 == s14 ? 1 : 8 : 256;
                for (let e15 = t111; e15 < n14; e15++) bG[e15] = o12;
                t111 = n14 - 1;
              } else 8 == n13 && 1 == s14 && (bG[t111] = 1);
              e14 = n13, 7 & n13 && (s14 = n13);
            }
          }
        })(e12, o10, r10, n11, h10), function(t110, e13, i13, s13, n12) {
          let o11 = 1 == n12 ? 2 : 1;
          for (let r11 = 0, l11 = 0, h11 = 0; r11 <= s13.length; r11++) {
            let a10 = r11 ? s13[r11 - 1].to : e13, c10 = r11 < s13.length ? s13[r11].from : i13;
            for (let e14 = a10, i14, s14, r12; e14 < c10; e14++) if (s14 = bI[i14 = t110.charCodeAt(e14)]) {
              if (s14 < 0) {
                for (let t111 = l11 - 3; t111 >= 0; t111 -= 3) if (bz[t111 + 1] == -s14) {
                  let i15 = bz[t111 + 2], s15 = 2 & i15 ? n12 : 4 & i15 ? 1 & i15 ? o11 : n12 : 0;
                  s15 && (bG[e14] = bG[bz[t111]] = s15), l11 = t111;
                  break;
                }
              } else if (189 == bz.length) break;
              else bz[l11++] = e14, bz[l11++] = i14, bz[l11++] = h11;
            } else if (2 == (r12 = bG[e14]) || 1 == r12) {
              let t111 = r12 == n12;
              h11 = t111 ? 0 : 1;
              for (let e15 = l11 - 3; e15 >= 0; e15 -= 3) {
                let i15 = bz[e15 + 2];
                if (2 & i15) break;
                if (t111) bz[e15 + 2] |= 2;
                else {
                  if (4 & i15) break;
                  bz[e15 + 2] |= 4;
                }
              }
            }
          }
        }(e12, o10, r10, n11, h10), function(t110, e13, i13, s13) {
          for (let n12 = 0, o11 = s13; n12 <= i13.length; n12++) {
            let r11 = n12 ? i13[n12 - 1].to : t110, l11 = n12 < i13.length ? i13[n12].from : e13;
            for (let h11 = r11; h11 < l11; ) {
              let r12 = bG[h11];
              if (256 == r12) {
                let r13 = h11 + 1;
                for (; ; ) if (r13 == l11) {
                  if (n12 == i13.length) break;
                  r13 = i13[n12++].to, l11 = n12 < i13.length ? i13[n12].from : e13;
                } else if (256 == bG[r13]) r13++;
                else break;
                let a10 = 1 == o11, c10 = a10 == ((r13 < e13 ? bG[r13] : s13) == 1) ? a10 ? 1 : 2 : s13;
                for (let e14 = r13, s14 = n12, o12 = s14 ? i13[s14 - 1].to : t110; e14 > h11; ) e14 == o12 && (e14 = i13[--s14].from, o12 = s14 ? i13[s14 - 1].to : t110), bG[--e14] = c10;
                h11 = r13;
              } else o11 = r12, h11++;
            }
          }
        }(o10, r10, n11, h10), function e13(i13, s13, n12, o11, r11, l11, h11) {
          let a10 = o11 % 2 ? 2 : 1;
          if (o11 % 2 == r11 % 2) for (let c10 = s13, d10 = 0; c10 < n12; ) {
            let s14 = true, u10 = false;
            if (d10 == l11.length || c10 < l11[d10].from) {
              let t110 = bG[c10];
              t110 != a10 && (s14 = false, u10 = 16 == t110);
            }
            let f10 = s14 || 1 != a10 ? null : [], g10 = s14 ? o11 : o11 + 1, p10 = c10;
            e: for (; ; ) if (d10 < l11.length && p10 == l11[d10].from) {
              if (u10) break;
              let e14 = l11[d10];
              if (!s14) for (let t110 = e14.to, i14 = d10 + 1; ; ) {
                if (t110 == n12) break e;
                if (i14 < l11.length && l11[i14].from == t110) t110 = l11[i14++].to;
                else if (bG[t110] == a10) break e;
                else break;
              }
              d10++, f10 ? f10.push(e14) : (e14.from > c10 && h11.push(new b_(c10, e14.from, g10)), t109(i13, e14.direction == bN != !(g10 % 2) ? o11 + 1 : o11, r11, e14.inner, e14.from, e14.to, h11), c10 = e14.to), p10 = e14.to;
            } else if (p10 == n12 || (s14 ? bG[p10] != a10 : bG[p10] == a10)) break;
            else p10++;
            f10 ? e13(i13, c10, p10, o11 + 1, r11, f10, h11) : c10 < p10 && h11.push(new b_(c10, p10, g10)), c10 = p10;
          }
          else for (let c10 = n12, d10 = l11.length; c10 > s13; ) {
            let n13 = true, u10 = false;
            if (!d10 || c10 > l11[d10 - 1].to) {
              let t110 = bG[c10 - 1];
              t110 != a10 && (n13 = false, u10 = 16 == t110);
            }
            let f10 = n13 || 1 != a10 ? null : [], g10 = n13 ? o11 : o11 + 1, p10 = c10;
            e: for (; ; ) if (d10 && p10 == l11[d10 - 1].to) {
              if (u10) break;
              let e14 = l11[--d10];
              if (!n13) for (let t110 = e14.from, i14 = d10; ; ) {
                if (t110 == s13) break e;
                if (i14 && l11[i14 - 1].to == t110) t110 = l11[--i14].from;
                else if (bG[t110 - 1] == a10) break e;
                else break;
              }
              f10 ? f10.push(e14) : (e14.to < c10 && h11.push(new b_(e14.to, c10, g10)), t109(i13, e14.direction == bN != !(g10 % 2) ? o11 + 1 : o11, r11, e14.inner, e14.from, e14.to, h11), c10 = e14.from), p10 = e14.from;
            } else if (p10 == s13 || (n13 ? bG[p10 - 1] != a10 : bG[p10 - 1] == a10)) break;
            else p10--;
            f10 ? e13(i13, p10, c10, o11 + 1, r11, f10, h11) : p10 < c10 && h11.push(new b_(p10, c10, g10)), c10 = p10;
          }
        }(e12, o10, r10, i12, s12, n11, l10);
      }(t108, n10, n10, i11, 0, t108.length, s11), s11;
    }(t107.text, e10, i10);
    return this.bidiCache.push(new xR(t107.from, t107.to, e10, i10, true, s10)), s10;
  }
  get hasFocus() {
    var t107;
    return (this.dom.ownerDocument.hasFocus() || bc.safari && (null === (t107 = this.inputState) || void 0 === t107 ? void 0 : t107.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  focus() {
    this.observer.ignore(() => {
      w$(this.contentDOM), this.docView.updateSelection();
    });
  }
  setRoot(t107) {
    this._root != t107 && (this._root = t107, this.observer.setWindow((9 == t107.nodeType ? t107 : t107.ownerDocument).defaultView || window), this.mountStyles());
  }
  destroy() {
    for (let t107 of this.plugins) t107.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = true;
  }
  static scrollIntoView(t107) {
    let e10 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return b4.of(new b3("number" == typeof t107 ? ti.cursor(t107) : t107, e10.y, e10.x, e10.yMargin, e10.xMargin));
  }
  scrollSnapshot() {
    let { scrollTop: t107, scrollLeft: e10 } = this.scrollDOM, i10 = this.viewState.scrollAnchorAt(t107);
    return b4.of(new b3(ti.cursor(i10.from), "start", "start", i10.top - t107, e10, true));
  }
  setTabFocusMode(t107) {
    null == t107 ? this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1 : "boolean" == typeof t107 ? this.inputState.tabFocusMode = t107 ? 0 : -1 : 0 != this.inputState.tabFocusMode && (this.inputState.tabFocusMode = Date.now() + t107);
  }
  static domEventHandlers(t107) {
    return yt.define(() => ({}), { eventHandlers: t107 });
  }
  static domEventObservers(t107) {
    return yt.define(() => ({}), { eventObservers: t107 });
  }
  static theme(t107, e10) {
    let i10 = t6.newName(), s10 = [xd.of(i10), yd.of(xv(`.${i10}`, t107))];
    return e10 && e10.dark && s10.push(xu.of(true)), s10;
  }
  static baseTheme(t107) {
    return tg.lowest(yd.of(xv("." + xf, t107, xm)));
  }
  static findFromDOM(t107) {
    var e10;
    let i10 = t107.querySelector(".cm-content"), s10 = i10 && w3.get(i10) || w3.get(t107);
    return (null === (e10 = null == s10 ? void 0 : s10.rootView) || void 0 === e10 ? void 0 : e10.view) || null;
  }
}
xO.styleModule = yd, xO.inputHandler = bZ, xO.scrollHandler = b8, xO.focusChangeEffect = b0, xO.perLineTextDirection = b1, xO.exceptionSink = bJ, xO.updateListener = bQ, xO.editable = b5, xO.mouseSelectionStyle = bX, xO.dragMovesSelection = b$, xO.clickAddsSelectionRange = bY, xO.decorations = yn, xO.outerDecorations = yo, xO.atomicRanges = yr, xO.bidiIsolatedRanges = yl, xO.scrollMargins = ya, xO.darkTheme = xu, xO.cspNonce = to.define({ combine: (t107) => t107.length ? t107[0] : "" }), xO.contentAttributes = ys, xO.editorAttributes = yi, xO.lineWrapping = xO.contentAttributes.of({ class: "cm-lineWrapping" }), xO.announce = tR.define();
let xT = 4096, xE = {};
class xR {
  constructor(t107, e10, i10, s10, n10, o10) {
    this.from = t107, this.to = e10, this.dir = i10, this.isolates = s10, this.fresh = n10, this.order = o10;
  }
  static update(t107, e10) {
    if (e10.empty && !t107.some((t108) => t108.fresh)) return t107;
    let i10 = [], s10 = t107.length ? t107[t107.length - 1].dir : bP.LTR;
    for (let n10 = Math.max(0, t107.length - 10); n10 < t107.length; n10++) {
      let o10 = t107[n10];
      o10.dir != s10 || e10.touchesRange(o10.from, o10.to) || i10.push(new xR(e10.mapPos(o10.from, 1), e10.mapPos(o10.to, -1), o10.dir, o10.isolates, false, o10.order));
    }
    return i10;
  }
}
function xB(t107, e10, i10) {
  for (let s10 = t107.state.facet(e10), n10 = s10.length - 1; n10 >= 0; n10--) {
    let e11 = s10[n10], o10 = "function" == typeof e11 ? e11(t107) : e11;
    o10 && bv(o10, i10);
  }
  return i10;
}
let xL = !bc.ios, xP = { ".cm-line": { "& ::selection, &::selection": { backgroundColor: "transparent !important" } }, ".cm-content": { "& :focus": { caretColor: "initial !important", "&::selection, & ::selection": { backgroundColor: "Highlight !important" } } } };
xL && (xP[".cm-line"].caretColor = xP[".cm-content"].caretColor = "transparent !important");
class xN extends tz {
  compare(t107) {
    return this == t107 || this.constructor == t107.constructor && this.eq(t107);
  }
  eq(t107) {
    return false;
  }
  destroy(t107) {
  }
}
function xV(t107, e10) {
  return (i10) => {
    let { state: s10, dispatch: n10 } = i10;
    if (s10.readOnly) return false;
    let o10 = t107(e10, s10);
    return !!o10 && (n10(s10.update(o10)), true);
  };
}
xN.prototype.elementClass = "", xN.prototype.toDOM = void 0, xN.prototype.mapMode = j.TrackBefore, xN.prototype.startSide = xN.prototype.endSide = -1, xN.prototype.point = true;
let xH = xV(function(t107, e10) {
  let i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e10.selection.ranges, s10 = [], n10 = -1;
  for (let { from: t108, to: o10 } of i10) {
    let i11 = s10.length, r10 = 1e9, l10 = xI(e10, t108).line;
    if (l10) {
      for (let i12 = t108; i12 <= o10; ) {
        let h10 = e10.doc.lineAt(i12);
        if (h10.from > n10 && (t108 == o10 || o10 > h10.from)) {
          n10 = h10.from;
          let t109 = /^\s*/.exec(h10.text)[0].length, e11 = t109 == h10.length, i13 = h10.text.slice(t109, t109 + l10.length) == l10 ? t109 : -1;
          t109 < h10.text.length && t109 < r10 && (r10 = t109), s10.push({ line: h10, comment: i13, token: l10, indent: t109, empty: e11, single: false });
        }
        i12 = h10.to + 1;
      }
      if (r10 < 1e9) for (let t109 = i11; t109 < s10.length; t109++) s10[t109].indent < s10[t109].line.text.length && (s10[t109].indent = r10);
      s10.length == i11 + 1 && (s10[i11].single = true);
    }
  }
  if (2 != t107 && s10.some((t108) => t108.comment < 0 && (!t108.empty || t108.single))) {
    let t108 = [];
    for (let { line: e11, token: i12, indent: n11, empty: o10, single: r10 } of s10) (r10 || !o10) && t108.push({ from: e11.from + n11, insert: i12 + " " });
    let i11 = e10.changes(t108);
    return { changes: i11, selection: e10.selection.map(i11, 1) };
  }
  if (1 != t107 && s10.some((t108) => t108.comment >= 0)) {
    let t108 = [];
    for (let { line: e11, comment: i11, token: n11 } of s10) if (i11 >= 0) {
      let s11 = e11.from + i11, o10 = s11 + n11.length;
      " " == e11.text[o10 - e11.from] && o10++, t108.push({ from: s11, to: o10 });
    }
    return { changes: t108 };
  }
  return null;
}, 0), xF = xV(xz, 0), xW = xV((t107, e10) => xz(t107, e10, function(t108) {
  let e11 = [];
  for (let i10 of t108.selection.ranges) {
    let s10 = t108.doc.lineAt(i10.from), n10 = i10.to <= s10.to ? s10 : t108.doc.lineAt(i10.to), o10 = e11.length - 1;
    o10 >= 0 && e11[o10].to > s10.from ? e11[o10].to = n10.to : e11.push({ from: s10.from + /^\s*/.exec(s10.text)[0].length, to: n10.to });
  }
  return e11;
}(e10)), 0);
function xI(t107, e10) {
  let i10 = t107.languageDataAt("commentTokens", e10);
  return i10.length ? i10[0] : {};
}
function xz(t107, e10) {
  let i10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e10.selection.ranges, s10 = i10.map((t108) => xI(e10, t108.from).block);
  if (!s10.every((t108) => t108)) return null;
  let n10 = i10.map((t108, i11) => function(t109, e11, i12, s11) {
    let n11, o10, { open: r10, close: l10 } = e11, h10 = t109.sliceDoc(i12 - 50, i12), a10 = t109.sliceDoc(s11, s11 + 50), c10 = /\s*$/.exec(h10)[0].length, d10 = /^\s*/.exec(a10)[0].length, u10 = h10.length - c10;
    if (h10.slice(u10 - r10.length, u10) == r10 && a10.slice(d10, d10 + l10.length) == l10) return { open: { pos: i12 - c10, margin: c10 && 1 }, close: { pos: s11 + d10, margin: d10 && 1 } };
    s11 - i12 <= 100 ? n11 = o10 = t109.sliceDoc(i12, s11) : (n11 = t109.sliceDoc(i12, i12 + 50), o10 = t109.sliceDoc(s11 - 50, s11));
    let f10 = /^\s*/.exec(n11)[0].length, g10 = /\s*$/.exec(o10)[0].length, p10 = o10.length - g10 - l10.length;
    return n11.slice(f10, f10 + r10.length) == r10 && o10.slice(p10, p10 + l10.length) == l10 ? { open: { pos: i12 + f10 + r10.length, margin: /\s/.test(n11.charAt(f10 + r10.length)) ? 1 : 0 }, close: { pos: s11 - g10 - l10.length, margin: /\s/.test(o10.charAt(p10 - 1)) ? 1 : 0 } } : null;
  }(e10, s10[i11], t108.from, t108.to));
  if (2 != t107 && !n10.every((t108) => t108)) return { changes: e10.changes(i10.map((t108, e11) => n10[e11] ? [] : [{ from: t108.from, insert: s10[e11].open + " " }, { from: t108.to, insert: " " + s10[e11].close }])) };
  if (1 != t107 && n10.some((t108) => t108)) {
    let t108 = [];
    for (let e11 = 0, i11; e11 < n10.length; e11++) if (i11 = n10[e11]) {
      let n11 = s10[e11], { open: o10, close: r10 } = i11;
      t108.push({ from: o10.pos - n11.open.length, to: o10.pos + o10.margin }, { from: r10.pos - r10.margin, to: r10.pos + n11.close.length });
    }
    return { changes: t108 };
  }
  return null;
}
let xK = tO.define(), xq = tO.define(), x_ = to.define(), xG = to.define({ combine: (t107) => tI(t107, { minDepth: 100, newGroupDelay: 500, joinToEvent: (t108, e10) => e10 }, { minDepth: Math.max, newGroupDelay: Math.min, joinToEvent: (t108, e10) => (i10, s10) => t108(i10, s10) || e10(i10, s10) }) }), xj = td.define({ create: () => x9.empty, update(t107, e10) {
  let i10 = e10.state.facet(xG), s10 = e10.annotation(xK);
  if (s10) {
    let n11 = xZ.fromTransaction(e10, s10.selection), o11 = s10.side, r11 = 0 == o11 ? t107.undone : t107.done;
    return r11 = n11 ? x0(r11, r11.length, i10.minDepth, n11) : x8(r11, e10.startState.selection), new x9(0 == o11 ? s10.rest : r11, 0 == o11 ? r11 : s10.rest);
  }
  let n10 = e10.annotation(xq);
  if (("full" == n10 || "before" == n10) && (t107 = t107.isolate()), false === e10.annotation(tB.addToHistory)) return e10.changes.empty ? t107 : t107.addMapping(e10.changes.desc);
  let o10 = xZ.fromTransaction(e10), r10 = e10.annotation(tB.time), l10 = e10.annotation(tB.userEvent);
  return o10 ? t107 = t107.addChanges(o10, r10, l10, i10, e10) : e10.selection && (t107 = t107.addSelection(e10.startState.selection, r10, l10, i10.newGroupDelay)), ("full" == n10 || "after" == n10) && (t107 = t107.isolate()), t107;
}, toJSON: (t107) => ({ done: t107.done.map((t108) => t108.toJSON()), undone: t107.undone.map((t108) => t108.toJSON()) }), fromJSON: (t107) => new x9(t107.done.map(xZ.fromJSON), t107.undone.map(xZ.fromJSON)) });
function xU() {
  let t107 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
  return [xj, xG.of(t107), xO.domEventHandlers({ beforeinput(t108, e10) {
    let i10 = "historyUndo" == t108.inputType ? x$ : "historyRedo" == t108.inputType ? xX : null;
    return !!i10 && (t108.preventDefault(), i10(e10));
  } })];
}
function xY(t107, e10) {
  return function(i10) {
    let { state: s10, dispatch: n10 } = i10;
    if (!e10 && s10.readOnly) return false;
    let o10 = s10.field(xj, false);
    if (!o10) return false;
    let r10 = o10.pop(t107, s10, e10);
    return !!r10 && (n10(r10), true);
  };
}
let x$ = xY(0, false), xX = xY(1, false), xJ = xY(0, true), xQ = xY(1, true);
class xZ {
  constructor(t107, e10, i10, s10, n10) {
    this.changes = t107, this.effects = e10, this.mapped = i10, this.startSelection = s10, this.selectionsAfter = n10;
  }
  setSelAfter(t107) {
    return new xZ(this.changes, this.effects, this.mapped, this.startSelection, t107);
  }
  toJSON() {
    var t107, e10, i10;
    return { changes: null === (t107 = this.changes) || void 0 === t107 ? void 0 : t107.toJSON(), mapped: null === (e10 = this.mapped) || void 0 === e10 ? void 0 : e10.toJSON(), startSelection: null === (i10 = this.startSelection) || void 0 === i10 ? void 0 : i10.toJSON(), selectionsAfter: this.selectionsAfter.map((t108) => t108.toJSON()) };
  }
  static fromJSON(t107) {
    return new xZ(t107.changes && Y.fromJSON(t107.changes), [], t107.mapped && U.fromJSON(t107.mapped), t107.startSelection && ti.fromJSON(t107.startSelection), t107.selectionsAfter.map(ti.fromJSON));
  }
  static fromTransaction(t107, e10) {
    let i10 = x2;
    for (let e11 of t107.startState.facet(x_)) {
      let s10 = e11(t107);
      s10.length && (i10 = i10.concat(s10));
    }
    return !i10.length && t107.changes.empty ? null : new xZ(t107.changes.invert(t107.startState.doc), i10, void 0, e10 || t107.startState.selection, x2);
  }
  static selection(t107) {
    return new xZ(void 0, x2, void 0, void 0, t107);
  }
}
function x0(t107, e10, i10, s10) {
  let n10 = t107.slice(e10 + 1 > i10 + 20 ? e10 - i10 - 1 : 0, e10);
  return n10.push(s10), n10;
}
function x1(t107, e10) {
  return t107.length ? e10.length ? t107.concat(e10) : t107 : e10;
}
let x2 = [];
function x8(t107, e10) {
  if (!t107.length) return [xZ.selection([e10])];
  {
    let i10 = t107[t107.length - 1], s10 = i10.selectionsAfter.slice(Math.max(0, i10.selectionsAfter.length - 200));
    return s10.length && s10[s10.length - 1].eq(e10) ? t107 : (s10.push(e10), x0(t107, t107.length - 1, 1e9, i10.setSelAfter(s10)));
  }
}
function x3(t107, e10) {
  if (!t107.length) return t107;
  let i10 = t107.length, s10 = x2;
  for (; i10; ) {
    let n10 = function(t108, e11, i11) {
      let s11 = x1(t108.selectionsAfter.length ? t108.selectionsAfter.map((t109) => t109.map(e11)) : x2, i11);
      if (!t108.changes) return xZ.selection(s11);
      let n11 = t108.changes.map(e11), o10 = e11.mapDesc(t108.changes, true), r10 = t108.mapped ? t108.mapped.composeDesc(o10) : o10;
      return new xZ(n11, tR.mapEffects(t108.effects, e11), r10, t108.startSelection.map(o10), s11);
    }(t107[i10 - 1], e10, s10);
    if (n10.changes && !n10.changes.empty || n10.effects.length) {
      let e11 = t107.slice(0, i10);
      return e11[i10 - 1] = n10, e11;
    }
    e10 = n10.mapped, i10--, s10 = n10.selectionsAfter;
  }
  return s10.length ? [xZ.selection(s10)] : x2;
}
let x4 = /^(input\.type|delete)($|\.)/;
class x9 {
  constructor(t107, e10, i10 = 0, s10) {
    this.done = t107, this.undone = e10, this.prevTime = i10, this.prevUserEvent = s10;
  }
  isolate() {
    return this.prevTime ? new x9(this.done, this.undone) : this;
  }
  addChanges(t107, e10, i10, s10, n10) {
    var o10, r10;
    let l10, h10, a10 = this.done, c10 = a10[a10.length - 1];
    return new x9(a10 = c10 && c10.changes && !c10.changes.empty && t107.changes && (!i10 || x4.test(i10)) && (!c10.selectionsAfter.length && e10 - this.prevTime < s10.newGroupDelay && s10.joinToEvent(n10, (o10 = c10.changes, r10 = t107.changes, l10 = [], h10 = false, o10.iterChangedRanges((t108, e11) => l10.push(t108, e11)), r10.iterChangedRanges((t108, e11, i11, s11) => {
      for (let t109 = 0; t109 < l10.length; ) {
        let e12 = l10[t109++], n11 = l10[t109++];
        s11 >= e12 && i11 <= n11 && (h10 = true);
      }
    }), h10)) || "input.type.compose" == i10) ? x0(a10, a10.length - 1, s10.minDepth, new xZ(t107.changes.compose(c10.changes), x1(t107.effects, c10.effects), c10.mapped, c10.startSelection, x2)) : x0(a10, a10.length, s10.minDepth, t107), x2, e10, i10);
  }
  addSelection(t107, e10, i10, s10) {
    var n10;
    let o10 = this.done.length ? this.done[this.done.length - 1].selectionsAfter : x2;
    return o10.length > 0 && e10 - this.prevTime < s10 && i10 == this.prevUserEvent && i10 && /^select($|\.)/.test(i10) && (n10 = o10[o10.length - 1]).ranges.length == t107.ranges.length && 0 === n10.ranges.filter((e11, i11) => e11.empty != t107.ranges[i11].empty).length ? this : new x9(x8(this.done, t107), this.undone, e10, i10);
  }
  addMapping(t107) {
    return new x9(x3(this.done, t107), x3(this.undone, t107), this.prevTime, this.prevUserEvent);
  }
  pop(t107, e10, i10) {
    let s10 = 0 == t107 ? this.done : this.undone;
    if (0 == s10.length) return null;
    let n10 = s10[s10.length - 1], o10 = n10.selectionsAfter[0] || e10.selection;
    if (i10 && n10.selectionsAfter.length) {
      let i11, r10;
      return e10.update({ selection: n10.selectionsAfter[n10.selectionsAfter.length - 1], annotations: xK.of({ side: t107, rest: (i11 = s10[s10.length - 1], (r10 = s10.slice())[s10.length - 1] = i11.setSelAfter(i11.selectionsAfter.slice(0, i11.selectionsAfter.length - 1)), r10), selection: o10 }), userEvent: 0 == t107 ? "select.undo" : "select.redo", scrollIntoView: true });
    }
    if (!n10.changes) return null;
    {
      let i11 = 1 == s10.length ? x2 : s10.slice(0, s10.length - 1);
      return n10.mapped && (i11 = x3(i11, n10.mapped)), e10.update({ changes: n10.changes, selection: n10.startSelection, effects: n10.effects, annotations: xK.of({ side: t107, rest: i11, selection: o10 }), filter: false, userEvent: 0 == t107 ? "undo" : "redo", scrollIntoView: true });
    }
  }
}
x9.empty = new x9(x2, x2);
let x5 = [{ key: "Mod-z", run: x$, preventDefault: true }, { key: "Mod-y", mac: "Mod-Shift-z", run: xX, preventDefault: true }, { linux: "Ctrl-Shift-z", run: xX, preventDefault: true }, { key: "Mod-u", run: xJ, preventDefault: true }, { key: "Alt-u", mac: "Mod-Shift-u", run: xQ, preventDefault: true }];
function x6(t107, e10) {
  return ti.create(t107.ranges.map(e10), t107.mainIndex);
}
function x7(t107, e10) {
  return t107.update({ selection: e10, scrollIntoView: true, userEvent: "select" });
}
function St(t107, e10) {
  let { state: i10, dispatch: s10 } = t107, n10 = x6(i10.selection, e10);
  return !n10.eq(i10.selection, true) && (s10(x7(i10, n10)), true);
}
function Se(t107, e10) {
  return ti.cursor(e10 ? t107.to : t107.from);
}
function Si(t107, e10) {
  return St(t107, (i10) => i10.empty ? t107.moveByChar(i10, e10) : Se(i10, e10));
}
function Ss(t107) {
  return t107.textDirectionAt(t107.state.selection.main.head) == bP.LTR;
}
let Sn = (t107) => Si(t107, !Ss(t107)), So = (t107) => Si(t107, Ss(t107));
function Sr(t107, e10) {
  return St(t107, (i10) => i10.empty ? t107.moveByGroup(i10, e10) : Se(i10, e10));
}
function Sl(t107, e10, i10) {
  let s10, n10, o10 = mk(t107).resolveInner(e10.head), r10 = i10 ? uw.closedBy : uw.openedBy;
  for (let s11 = e10.head; ; ) {
    let e11 = i10 ? o10.childAfter(s11) : o10.childBefore(s11);
    if (!e11) break;
    !function(t108, e12, i11) {
      if (e12.type.prop(i11)) return true;
      let s12 = e12.to - e12.from;
      return s12 && (s12 > 2 || /[^\s,.;:]/.test(t108.sliceDoc(e12.from, e12.to))) || e12.firstChild;
    }(t107, e11, r10) ? s11 = i10 ? e11.to : e11.from : o10 = e11;
  }
  return n10 = o10.type.prop(r10) && (s10 = i10 ? vy(t107, o10.from, 1) : vy(t107, o10.to, -1)) && s10.matched ? i10 ? s10.end.to : s10.end.from : i10 ? o10.to : o10.from, ti.cursor(n10, i10 ? -1 : 1);
}
function Sh(t107, e10) {
  return St(t107, (i10) => {
    if (!i10.empty) return Se(i10, e10);
    let s10 = t107.moveVertically(i10, e10);
    return s10.head != i10.head ? s10 : t107.moveToLineBoundary(i10, e10);
  });
}
let Sa = (t107) => Sh(t107, false), Sc = (t107) => Sh(t107, true);
function Sd(t107) {
  let e10 = t107.scrollDOM.clientHeight < t107.scrollDOM.scrollHeight - 2, i10 = 0, s10 = 0, n10;
  if (e10) {
    for (let e11 of t107.state.facet(xO.scrollMargins)) {
      let n11 = e11(t107);
      (null == n11 ? void 0 : n11.top) && (i10 = Math.max(null == n11 ? void 0 : n11.top, i10)), (null == n11 ? void 0 : n11.bottom) && (s10 = Math.max(null == n11 ? void 0 : n11.bottom, s10));
    }
    n10 = t107.scrollDOM.clientHeight - i10 - s10;
  } else n10 = (t107.dom.ownerDocument.defaultView || window).innerHeight;
  return { marginTop: i10, marginBottom: s10, selfScroll: e10, height: Math.max(t107.defaultLineHeight, n10 - 5) };
}
function Su(t107, e10) {
  let i10, s10 = Sd(t107), { state: n10 } = t107, o10 = x6(n10.selection, (i11) => i11.empty ? t107.moveVertically(i11, e10, s10.height) : Se(i11, e10));
  if (o10.eq(n10.selection)) return false;
  if (s10.selfScroll) {
    let e11 = t107.coordsAtPos(n10.selection.main.head), r10 = t107.scrollDOM.getBoundingClientRect(), l10 = r10.top + s10.marginTop, h10 = r10.bottom - s10.marginBottom;
    e11 && e11.top > l10 && e11.bottom < h10 && (i10 = xO.scrollIntoView(o10.main.head, { y: "start", yMargin: e11.top - l10 }));
  }
  return t107.dispatch(x7(n10, o10), { effects: i10 }), true;
}
let Sf = (t107) => Su(t107, false), Sg = (t107) => Su(t107, true);
function Sp(t107, e10, i10) {
  let s10 = t107.lineBlockAt(e10.head), n10 = t107.moveToLineBoundary(e10, i10);
  if (n10.head == e10.head && n10.head != (i10 ? s10.to : s10.from) && (n10 = t107.moveToLineBoundary(e10, i10, false)), !i10 && n10.head == s10.from && s10.length) {
    let i11 = /^\s*/.exec(t107.state.sliceDoc(s10.from, Math.min(s10.from + 100, s10.to)))[0].length;
    i11 && e10.head != s10.from + i11 && (n10 = ti.cursor(s10.from + i11));
  }
  return n10;
}
function Sm(t107, e10) {
  let i10 = x6(t107.state.selection, (t108) => {
    let i11 = e10(t108);
    return ti.range(t108.anchor, i11.head, i11.goalColumn, i11.bidiLevel || void 0);
  });
  return !i10.eq(t107.state.selection) && (t107.dispatch(x7(t107.state, i10)), true);
}
function Sv(t107, e10) {
  return Sm(t107, (i10) => t107.moveByChar(i10, e10));
}
let Sw = (t107) => Sv(t107, !Ss(t107)), Sb = (t107) => Sv(t107, Ss(t107));
function Sy(t107, e10) {
  return Sm(t107, (i10) => t107.moveByGroup(i10, e10));
}
function Sx(t107, e10) {
  return Sm(t107, (i10) => t107.moveVertically(i10, e10));
}
let SS = (t107) => Sx(t107, false), Sk = (t107) => Sx(t107, true);
function SM(t107, e10) {
  return Sm(t107, (i10) => t107.moveVertically(i10, e10, Sd(t107).height));
}
let SC = (t107) => SM(t107, false), SA = (t107) => SM(t107, true), SD = (t107) => {
  let { state: e10, dispatch: i10 } = t107;
  return i10(x7(e10, { anchor: 0 })), true;
}, SO = (t107) => {
  let { state: e10, dispatch: i10 } = t107;
  return i10(x7(e10, { anchor: e10.doc.length })), true;
}, ST = (t107) => {
  let { state: e10, dispatch: i10 } = t107;
  return i10(x7(e10, { anchor: e10.selection.main.anchor, head: 0 })), true;
}, SE = (t107) => {
  let { state: e10, dispatch: i10 } = t107;
  return i10(x7(e10, { anchor: e10.selection.main.anchor, head: e10.doc.length })), true;
};
function SR(t107, e10) {
  if (t107.state.readOnly) return false;
  let i10 = "delete.selection", { state: s10 } = t107, n10 = s10.changeByRange((s11) => {
    let { from: n11, to: o10 } = s11;
    if (n11 == o10) {
      let r10 = e10(s11);
      r10 < n11 ? (i10 = "delete.backward", r10 = SB(t107, r10, false)) : r10 > n11 && (i10 = "delete.forward", r10 = SB(t107, r10, true)), n11 = Math.min(n11, r10), o10 = Math.max(o10, r10);
    } else n11 = SB(t107, n11, false), o10 = SB(t107, o10, true);
    return n11 == o10 ? { range: s11 } : { changes: { from: n11, to: o10 }, range: ti.cursor(n11, n11 < s11.head ? -1 : 1) };
  });
  return !n10.changes.empty && (t107.dispatch(s10.update(n10, { scrollIntoView: true, userEvent: i10, effects: "delete.selection" == i10 ? xO.announce.of(s10.phrase("Selection deleted")) : void 0 })), true);
}
function SB(t107, e10, i10) {
  if (t107 instanceof xO) for (let s10 of t107.state.facet(xO.atomicRanges).map((e11) => e11(t107))) s10.between(e10, e10, (t108, s11) => {
    t108 < e10 && s11 > e10 && (e10 = i10 ? s11 : t108);
  });
  return e10;
}
let SL = (t107, e10, i10) => SR(t107, (s10) => {
  let n10 = s10.from, { state: o10 } = t107, r10 = o10.doc.lineAt(n10), l10, h10;
  if (i10 && !e10 && n10 > r10.from && n10 < r10.from + 200 && !/[^ \t]/.test(l10 = r10.text.slice(0, n10 - r10.from))) {
    if ("	" == l10[l10.length - 1]) return n10 - 1;
    let t108 = t8(l10, o10.tabSize) % mV(o10) || mV(o10);
    for (let e11 = 0; e11 < t108 && " " == l10[l10.length - 1 - e11]; e11++) n10--;
    h10 = n10;
  } else (h10 = v(r10.text, n10 - r10.from, e10, e10) + r10.from) == n10 && r10.number != (e10 ? o10.doc.lines : 1) ? h10 += e10 ? 1 : -1 : !e10 && /[\ufe00-\ufe0f]/.test(r10.text.slice(h10 - r10.from, n10 - r10.from)) && (h10 = v(r10.text, h10 - r10.from, false, false) + r10.from);
  return h10;
}), SP = (t107) => SL(t107, false, true), SN = (t107) => SL(t107, true, false), SV = (t107, e10) => SR(t107, (i10) => {
  let s10 = i10.head, { state: n10 } = t107, o10 = n10.doc.lineAt(s10), r10 = n10.charCategorizer(s10);
  for (let t108 = null; ; ) {
    if (s10 == (e10 ? o10.to : o10.from)) {
      s10 == i10.head && o10.number != (e10 ? n10.doc.lines : 1) && (s10 += e10 ? 1 : -1);
      break;
    }
    let l10 = v(o10.text, s10 - o10.from, e10) + o10.from, h10 = o10.text.slice(Math.min(s10, l10) - o10.from, Math.max(s10, l10) - o10.from), a10 = r10(h10);
    if (null != t108 && a10 != t108) break;
    (" " != h10 || s10 != i10.head) && (t108 = a10), s10 = l10;
  }
  return s10;
}), SH = (t107) => SV(t107, false);
function SF(t107) {
  let e10 = [], i10 = -1;
  for (let s10 of t107.selection.ranges) {
    let n10 = t107.doc.lineAt(s10.from), o10 = t107.doc.lineAt(s10.to);
    if (s10.empty || s10.to != o10.from || (o10 = t107.doc.lineAt(s10.to - 1)), i10 >= n10.number) {
      let t108 = e10[e10.length - 1];
      t108.to = o10.to, t108.ranges.push(s10);
    } else e10.push({ from: n10.from, to: o10.to, ranges: [s10] });
    i10 = o10.number + 1;
  }
  return e10;
}
function SW(t107, e10, i10) {
  if (t107.readOnly) return false;
  let s10 = [], n10 = [];
  for (let e11 of SF(t107)) {
    if (i10 ? e11.to == t107.doc.length : 0 == e11.from) continue;
    let o10 = t107.doc.lineAt(i10 ? e11.to + 1 : e11.from - 1), r10 = o10.length + 1;
    if (i10) for (let i11 of (s10.push({ from: e11.to, to: o10.to }, { from: e11.from, insert: o10.text + t107.lineBreak }), e11.ranges)) n10.push(ti.range(Math.min(t107.doc.length, i11.anchor + r10), Math.min(t107.doc.length, i11.head + r10)));
    else for (let i11 of (s10.push({ from: o10.from, to: e11.from }, { from: e11.to, insert: t107.lineBreak + o10.text }), e11.ranges)) n10.push(ti.range(i11.anchor - r10, i11.head - r10));
  }
  return !!s10.length && (e10(t107.update({ changes: s10, scrollIntoView: true, selection: ti.create(n10, t107.selection.mainIndex), userEvent: "move.line" })), true);
}
function SI(t107, e10, i10) {
  if (t107.readOnly) return false;
  let s10 = [];
  for (let e11 of SF(t107)) i10 ? s10.push({ from: e11.from, insert: t107.doc.slice(e11.from, e11.to) + t107.lineBreak }) : s10.push({ from: e11.to, insert: t107.lineBreak + t107.doc.slice(e11.from, e11.to) });
  return e10(t107.update({ changes: s10, scrollIntoView: true, userEvent: "input.copyline" })), true;
}
let Sz = Sq(false), SK = Sq(true);
function Sq(t107) {
  return (e10) => {
    let { state: i10, dispatch: s10 } = e10;
    if (i10.readOnly) return false;
    let n10 = i10.changeByRange((e11) => {
      let { from: s11, to: n11 } = e11, o10 = i10.doc.lineAt(s11), l10 = !t107 && s11 == n11 && function(t108, e12) {
        if (/\(\)|\[\]|\{\}/.test(t108.sliceDoc(e12 - 1, e12 + 1))) return { from: e12, to: e12 };
        let i11 = mk(t108).resolveInner(e12), s12 = i11.childBefore(e12), n12 = i11.childAfter(e12), o11;
        return s12 && n12 && s12.to <= e12 && n12.from >= e12 && (o11 = s12.type.prop(uw.closedBy)) && o11.indexOf(n12.name) > -1 && t108.doc.lineAt(s12.to).from == t108.doc.lineAt(n12.from).from && !/\S/.test(t108.sliceDoc(s12.to, n12.from)) ? { from: s12.to, to: n12.from } : null;
      }(i10, s11);
      t107 && (s11 = n11 = (n11 <= o10.to ? o10 : i10.doc.lineAt(n11)).to);
      let h10 = new mW(i10, { simulateBreak: s11, simulateDoubleBreak: !!l10 }), a10 = mF(h10, s11);
      for (null == a10 && (a10 = t8(/^\s*/.exec(i10.doc.lineAt(s11).text)[0], i10.tabSize)); n11 < o10.to && /\s/.test(o10.text[n11 - o10.from]); ) n11++;
      l10 ? { from: s11, to: n11 } = l10 : s11 > o10.from && s11 < o10.from + 100 && !/\S/.test(o10.text.slice(0, s11)) && (s11 = o10.from);
      let c10 = ["", mH(i10, a10)];
      return l10 && c10.push(mH(i10, h10.lineIndent(o10.from, -1))), { changes: { from: s11, to: n11, insert: r.of(c10) }, range: ti.cursor(s11 + 1 + c10[1].length) };
    });
    return s10(i10.update(n10, { scrollIntoView: true, userEvent: "input" })), true;
  };
}
function S_(t107, e10) {
  let i10 = -1;
  return t107.changeByRange((s10) => {
    let n10 = [];
    for (let o11 = s10.from; o11 <= s10.to; ) {
      let r10 = t107.doc.lineAt(o11);
      r10.number > i10 && (s10.empty || s10.to > r10.from) && (e10(r10, n10, s10), i10 = r10.number), o11 = r10.to + 1;
    }
    let o10 = t107.changes(n10);
    return { changes: n10, range: ti.range(o10.mapPos(s10.anchor, 1), o10.mapPos(s10.head, 1)) };
  });
}
let SG = (t107) => {
  let { state: e10, dispatch: i10 } = t107;
  return !e10.readOnly && (i10(e10.update(S_(e10, (t108, i11) => {
    i11.push({ from: t108.from, insert: e10.facet(mN) });
  }), { userEvent: "input.indent" })), true);
}, Sj = (t107) => {
  let { state: e10, dispatch: i10 } = t107;
  return !e10.readOnly && (i10(e10.update(S_(e10, (t108, i11) => {
    let s10 = /^\s*/.exec(t108.text)[0];
    if (!s10) return;
    let n10 = t8(s10, e10.tabSize), o10 = 0, r10 = mH(e10, Math.max(0, n10 - mV(e10)));
    for (; o10 < s10.length && o10 < r10.length && s10.charCodeAt(o10) == r10.charCodeAt(o10); ) o10++;
    i11.push({ from: t108.from + o10, to: t108.from + s10.length, insert: r10.slice(o10) });
  }), { userEvent: "delete.dedent" })), true);
}, SU = [{ key: "Ctrl-b", run: Sn, shift: Sw, preventDefault: true }, { key: "Ctrl-f", run: So, shift: Sb }, { key: "Ctrl-p", run: Sa, shift: SS }, { key: "Ctrl-n", run: Sc, shift: Sk }, { key: "Ctrl-a", run: (t107) => St(t107, (e10) => ti.cursor(t107.lineBlockAt(e10.head).from, 1)), shift: (t107) => Sm(t107, (e10) => ti.cursor(t107.lineBlockAt(e10.head).from)) }, { key: "Ctrl-e", run: (t107) => St(t107, (e10) => ti.cursor(t107.lineBlockAt(e10.head).to, -1)), shift: (t107) => Sm(t107, (e10) => ti.cursor(t107.lineBlockAt(e10.head).to)) }, { key: "Ctrl-d", run: SN }, { key: "Ctrl-h", run: SP }, { key: "Ctrl-k", run: (t107) => SR(t107, (e10) => {
  let i10 = t107.lineBlockAt(e10.head).to;
  return e10.head < i10 ? i10 : Math.min(t107.state.doc.length, e10.head + 1);
}) }, { key: "Ctrl-Alt-h", run: SH }, { key: "Ctrl-o", run: (t107) => {
  let { state: e10, dispatch: i10 } = t107;
  if (e10.readOnly) return false;
  let s10 = e10.changeByRange((t108) => ({ changes: { from: t108.from, to: t108.to, insert: r.of(["", ""]) }, range: ti.cursor(t108.from) }));
  return i10(e10.update(s10, { scrollIntoView: true, userEvent: "input" })), true;
} }, { key: "Ctrl-t", run: (t107) => {
  let { state: e10, dispatch: i10 } = t107;
  if (e10.readOnly) return false;
  let s10 = e10.changeByRange((t108) => {
    if (!t108.empty || 0 == t108.from || t108.from == e10.doc.length) return { range: t108 };
    let i11 = t108.from, s11 = e10.doc.lineAt(i11), n10 = i11 == s11.from ? i11 - 1 : v(s11.text, i11 - s11.from, false) + s11.from, o10 = i11 == s11.to ? i11 + 1 : v(s11.text, i11 - s11.from, true) + s11.from;
    return { changes: { from: n10, to: o10, insert: e10.doc.slice(i11, o10).append(e10.doc.slice(n10, i11)) }, range: ti.cursor(o10) };
  });
  return !s10.changes.empty && (i10(e10.update(s10, { scrollIntoView: true, userEvent: "move.character" })), true);
} }, { key: "Ctrl-v", run: Sg }], SY = [{ key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: (t107) => St(t107, (e10) => Sl(t107.state, e10, !Ss(t107))), shift: (t107) => Sm(t107, (e10) => Sl(t107.state, e10, !Ss(t107))) }, { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: (t107) => St(t107, (e10) => Sl(t107.state, e10, Ss(t107))), shift: (t107) => Sm(t107, (e10) => Sl(t107.state, e10, Ss(t107))) }, { key: "Alt-ArrowUp", run: (t107) => {
  let { state: e10, dispatch: i10 } = t107;
  return SW(e10, i10, false);
} }, { key: "Shift-Alt-ArrowUp", run: (t107) => {
  let { state: e10, dispatch: i10 } = t107;
  return SI(e10, i10, false);
} }, { key: "Alt-ArrowDown", run: (t107) => {
  let { state: e10, dispatch: i10 } = t107;
  return SW(e10, i10, true);
} }, { key: "Shift-Alt-ArrowDown", run: (t107) => {
  let { state: e10, dispatch: i10 } = t107;
  return SI(e10, i10, true);
} }, { key: "Escape", run: (t107) => {
  let { state: e10, dispatch: i10 } = t107, s10 = e10.selection, n10 = null;
  return s10.ranges.length > 1 ? n10 = ti.create([s10.main]) : s10.main.empty || (n10 = ti.create([ti.cursor(s10.main.head)])), !!n10 && (i10(x7(e10, n10)), true);
} }, { key: "Mod-Enter", run: SK }, { key: "Alt-l", mac: "Ctrl-l", run: (t107) => {
  let { state: e10, dispatch: i10 } = t107, s10 = SF(e10).map((t108) => {
    let { from: i11, to: s11 } = t108;
    return ti.range(i11, Math.min(s11 + 1, e10.doc.length));
  });
  return i10(e10.update({ selection: ti.create(s10), userEvent: "select" })), true;
} }, { key: "Mod-i", run: (t107) => {
  let { state: e10, dispatch: i10 } = t107, s10 = x6(e10.selection, (t108) => {
    var i11;
    let s11 = mk(e10).resolveStack(t108.from, 1);
    for (let e11 = s11; e11; e11 = e11.next) {
      let { node: s12 } = e11;
      if ((s12.from < t108.from && s12.to >= t108.to || s12.to > t108.to && s12.from <= t108.from) && (null === (i11 = s12.parent) || void 0 === i11 ? void 0 : i11.parent)) return ti.range(s12.to, s12.from);
    }
    return t108;
  });
  return i10(x7(e10, s10)), true;
}, preventDefault: true }, { key: "Mod-[", run: Sj }, { key: "Mod-]", run: SG }, { key: "Mod-Alt-\\", run: (t107) => {
  let { state: e10, dispatch: i10 } = t107;
  if (e10.readOnly) return false;
  let s10 = /* @__PURE__ */ Object.create(null), n10 = new mW(e10, { overrideIndentation: (t108) => {
    let e11 = s10[t108];
    return null == e11 ? -1 : e11;
  } }), o10 = S_(e10, (t108, i11, o11) => {
    let r10 = mF(n10, t108.from);
    if (null == r10) return;
    /\S/.test(t108.text) || (r10 = 0);
    let l10 = /^\s*/.exec(t108.text)[0], h10 = mH(e10, r10);
    (l10 != h10 || o11.from < t108.from + l10.length) && (s10[t108.from] = r10, i11.push({ from: t108.from, to: t108.from + l10.length, insert: h10 }));
  });
  return o10.changes.empty || i10(e10.update(o10, { userEvent: "indent" })), true;
} }, { key: "Shift-Mod-k", run: (t107) => {
  if (t107.state.readOnly) return false;
  let { state: e10 } = t107, i10 = e10.changes(SF(e10).map((t108) => {
    let { from: i11, to: s11 } = t108;
    return i11 > 0 ? i11-- : s11 < e10.doc.length && s11++, { from: i11, to: s11 };
  })), s10 = x6(e10.selection, (e11) => {
    let i11;
    if (t107.lineWrapping) {
      let s11 = t107.lineBlockAt(e11.head), n10 = t107.coordsAtPos(e11.head, e11.assoc || 1);
      n10 && (i11 = s11.bottom + t107.documentTop - n10.bottom + t107.defaultLineHeight / 2);
    }
    return t107.moveVertically(e11, true, i11);
  }).map(i10);
  return t107.dispatch({ changes: i10, selection: s10, scrollIntoView: true, userEvent: "delete.line" }), true;
} }, { key: "Shift-Mod-\\", run: (t107) => {
  let e10, i10, { state: s10, dispatch: n10 } = t107;
  return e10 = false, i10 = x6(s10.selection, (t108) => {
    let i11 = vy(s10, t108.head, -1) || vy(s10, t108.head, 1) || t108.head > 0 && vy(s10, t108.head - 1, 1) || t108.head < s10.doc.length && vy(s10, t108.head + 1, -1);
    if (!i11 || !i11.end) return t108;
    e10 = true;
    let n11 = i11.start.from == t108.head ? i11.end.to : i11.end.from;
    return ti.cursor(n11);
  }), !!e10 && (n10(x7(s10, i10)), true);
} }, { key: "Mod-/", run: (t107) => {
  let { state: e10 } = t107, i10 = e10.doc.lineAt(e10.selection.main.from), s10 = xI(t107.state, i10.from);
  return s10.line ? xH(t107) : !!s10.block && xW(t107);
} }, { key: "Alt-A", run: xF }, { key: "Ctrl-m", mac: "Shift-Alt-m", run: (t107) => (t107.setTabFocusMode(), true) }].concat([{ key: "ArrowLeft", run: Sn, shift: Sw, preventDefault: true }, { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: (t107) => Sr(t107, !Ss(t107)), shift: (t107) => Sy(t107, !Ss(t107)), preventDefault: true }, { mac: "Cmd-ArrowLeft", run: (t107) => St(t107, (e10) => Sp(t107, e10, !Ss(t107))), shift: (t107) => Sm(t107, (e10) => Sp(t107, e10, !Ss(t107))), preventDefault: true }, { key: "ArrowRight", run: So, shift: Sb, preventDefault: true }, { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: (t107) => Sr(t107, Ss(t107)), shift: (t107) => Sy(t107, Ss(t107)), preventDefault: true }, { mac: "Cmd-ArrowRight", run: (t107) => St(t107, (e10) => Sp(t107, e10, Ss(t107))), shift: (t107) => Sm(t107, (e10) => Sp(t107, e10, Ss(t107))), preventDefault: true }, { key: "ArrowUp", run: Sa, shift: SS, preventDefault: true }, { mac: "Cmd-ArrowUp", run: SD, shift: ST }, { mac: "Ctrl-ArrowUp", run: Sf, shift: SC }, { key: "ArrowDown", run: Sc, shift: Sk, preventDefault: true }, { mac: "Cmd-ArrowDown", run: SO, shift: SE }, { mac: "Ctrl-ArrowDown", run: Sg, shift: SA }, { key: "PageUp", run: Sf, shift: SC }, { key: "PageDown", run: Sg, shift: SA }, { key: "Home", run: (t107) => St(t107, (e10) => Sp(t107, e10, false)), shift: (t107) => Sm(t107, (e10) => Sp(t107, e10, false)), preventDefault: true }, { key: "Mod-Home", run: SD, shift: ST }, { key: "End", run: (t107) => St(t107, (e10) => Sp(t107, e10, true)), shift: (t107) => Sm(t107, (e10) => Sp(t107, e10, true)), preventDefault: true }, { key: "Mod-End", run: SO, shift: SE }, { key: "Enter", run: Sz }, { key: "Mod-a", run: (t107) => {
  let { state: e10, dispatch: i10 } = t107;
  return i10(e10.update({ selection: { anchor: 0, head: e10.doc.length }, userEvent: "select" })), true;
} }, { key: "Backspace", run: SP, shift: SP }, { key: "Delete", run: SN }, { key: "Mod-Backspace", mac: "Alt-Backspace", run: SH }, { key: "Mod-Delete", mac: "Alt-Delete", run: (t107) => SV(t107, true) }, { mac: "Mod-Backspace", run: (t107) => SR(t107, (e10) => {
  let i10 = t107.moveToLineBoundary(e10, false).head;
  return e10.head > i10 ? i10 : Math.max(0, e10.head - 1);
}) }, { mac: "Mod-Delete", run: (t107) => SR(t107, (e10) => {
  let i10 = t107.moveToLineBoundary(e10, true).head;
  return e10.head < i10 ? i10 : Math.min(t107.state.doc.length, e10.head + 1);
}) }].concat(SU.map((t107) => ({ mac: t107.key, run: t107.run, shift: t107.shift })))), S$ = { key: "Tab", run: SG, shift: Sj };
export {
  mU as A,
  mk as B,
  wm as C,
  up as D,
  tW as E,
  wL as F,
  v9 as G,
  hF as H,
  _ as I,
  S$ as J,
  hW as K,
  mL as L,
  hR as M,
  uS as N,
  u_ as P,
  uC as T,
  ux as a,
  uw as b,
  nr as c,
  hN as d,
  n$ as e,
  ve as f,
  m8 as g,
  vm as h,
  wS as i,
  wO as j,
  ng as k,
  h8 as l,
  nZ as m,
  nR as n,
  nD as o,
  xU as p,
  x5 as q,
  SY as r,
  p9 as s,
  mm as t,
  vl as u,
  mv as v,
  mS as w,
  mI as x,
  m_ as y,
  mj as z
};
