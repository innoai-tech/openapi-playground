import { m } from './vendor-min-mermaid~chunk-ZN7TASNU.CdKFbHTs.chunk.js';
import { o } from './vendor-min-mermaid~chunk-ZZTKAOFA.BmEKORPt.chunk.js';
import { d } from './vendor-min-mermaid~chunk-S67DUUA5.D3-Ci5Su.chunk.js';
import { n } from './vendor-min-mermaid~chunk-LM6QDVU5.Cd9M_jtg.chunk.js';
import { J as Jr, F as Fn } from './vendor-min-mermaid~chunk-TK7VX7YV.CPX48Ryn.chunk.js';
import { I as Ie$1, X as Xe$1, b as be$1 } from './vendor-min-mermaid~chunk-CRSA2SMT.DrUenSi3.chunk.js';
import { m as m$1 } from './vendor-min-mermaid~chunk-GTKDMUJJ.CzbCS-C_.chunk.js';
import { O as Or$1, k as kh, Y as Yf, t as tt, V as Vf, b as Vu, s as se$1, h as hh, c as Xc, d as Zc, z as zf, R as Rf, e as XC, D as De$1 } from './vendor-min-mermaid~chunk-63ZE7VZ5.CfadwiGU.chunk.js';
import { _ as _f } from './vendor-min-mermaid~chunk-5ZJXQJOJ.Be7I3AGN.chunk.js';
var yt = /*#__PURE__*/ function() {
    var e = /*#__PURE__*/ m$1(function(T, y, d, f) {
        for(d = d || {}, f = T.length; f--; d[T[f]] = y);
        return d;
    }, "o"), t = [
        1,
        7
    ], s = [
        1,
        13
    ], n = [
        1,
        14
    ], i = [
        1,
        15
    ], a = [
        1,
        19
    ], r = [
        1,
        16
    ], l = [
        1,
        17
    ], o = [
        1,
        18
    ], u = [
        8,
        30
    ], g = [
        8,
        21,
        28,
        29,
        30,
        31,
        32,
        40,
        44,
        47
    ], x = [
        1,
        23
    ], m = [
        1,
        24
    ], b = [
        8,
        15,
        16,
        21,
        28,
        29,
        30,
        31,
        32,
        40,
        44,
        47
    ], L = [
        8,
        15,
        16,
        21,
        27,
        28,
        29,
        30,
        31,
        32,
        40,
        44,
        47
    ], _ = [
        1,
        49
    ], S = {
        trace: /*#__PURE__*/ m$1(function() {}, "trace"),
        yy: {},
        symbols_: {
            error: 2,
            spaceLines: 3,
            SPACELINE: 4,
            NL: 5,
            separator: 6,
            SPACE: 7,
            EOF: 8,
            start: 9,
            BLOCK_DIAGRAM_KEY: 10,
            document: 11,
            stop: 12,
            statement: 13,
            link: 14,
            LINK: 15,
            START_LINK: 16,
            LINK_LABEL: 17,
            STR: 18,
            nodeStatement: 19,
            columnsStatement: 20,
            SPACE_BLOCK: 21,
            blockStatement: 22,
            classDefStatement: 23,
            cssClassStatement: 24,
            styleStatement: 25,
            node: 26,
            SIZE: 27,
            COLUMNS: 28,
            "id-block": 29,
            end: 30,
            block: 31,
            NODE_ID: 32,
            nodeShapeNLabel: 33,
            dirList: 34,
            DIR: 35,
            NODE_DSTART: 36,
            NODE_DEND: 37,
            BLOCK_ARROW_START: 38,
            BLOCK_ARROW_END: 39,
            classDef: 40,
            CLASSDEF_ID: 41,
            CLASSDEF_STYLEOPTS: 42,
            DEFAULT: 43,
            class: 44,
            CLASSENTITY_IDS: 45,
            STYLECLASS: 46,
            style: 47,
            STYLE_ENTITY_IDS: 48,
            STYLE_DEFINITION_DATA: 49,
            $accept: 0,
            $end: 1
        },
        terminals_: {
            2: "error",
            4: "SPACELINE",
            5: "NL",
            7: "SPACE",
            8: "EOF",
            10: "BLOCK_DIAGRAM_KEY",
            15: "LINK",
            16: "START_LINK",
            17: "LINK_LABEL",
            18: "STR",
            21: "SPACE_BLOCK",
            27: "SIZE",
            28: "COLUMNS",
            29: "id-block",
            30: "end",
            31: "block",
            32: "NODE_ID",
            35: "DIR",
            36: "NODE_DSTART",
            37: "NODE_DEND",
            38: "BLOCK_ARROW_START",
            39: "BLOCK_ARROW_END",
            40: "classDef",
            41: "CLASSDEF_ID",
            42: "CLASSDEF_STYLEOPTS",
            43: "DEFAULT",
            44: "class",
            45: "CLASSENTITY_IDS",
            46: "STYLECLASS",
            47: "style",
            48: "STYLE_ENTITY_IDS",
            49: "STYLE_DEFINITION_DATA"
        },
        productions_: [
            0,
            [
                3,
                1
            ],
            [
                3,
                2
            ],
            [
                3,
                2
            ],
            [
                6,
                1
            ],
            [
                6,
                1
            ],
            [
                6,
                1
            ],
            [
                9,
                3
            ],
            [
                12,
                1
            ],
            [
                12,
                1
            ],
            [
                12,
                2
            ],
            [
                12,
                2
            ],
            [
                11,
                1
            ],
            [
                11,
                2
            ],
            [
                14,
                1
            ],
            [
                14,
                4
            ],
            [
                13,
                1
            ],
            [
                13,
                1
            ],
            [
                13,
                1
            ],
            [
                13,
                1
            ],
            [
                13,
                1
            ],
            [
                13,
                1
            ],
            [
                13,
                1
            ],
            [
                19,
                3
            ],
            [
                19,
                2
            ],
            [
                19,
                1
            ],
            [
                20,
                1
            ],
            [
                22,
                4
            ],
            [
                22,
                3
            ],
            [
                26,
                1
            ],
            [
                26,
                2
            ],
            [
                34,
                1
            ],
            [
                34,
                2
            ],
            [
                33,
                3
            ],
            [
                33,
                4
            ],
            [
                23,
                3
            ],
            [
                23,
                3
            ],
            [
                24,
                3
            ],
            [
                25,
                3
            ]
        ],
        performAction: /*#__PURE__*/ m$1(function(y, d, f, w, E, h, Y) {
            var p = h.length - 1;
            switch(E){
                case 4:
                    w.getLogger().debug("Rule: separator (NL) ");
                    break;
                case 5:
                    w.getLogger().debug("Rule: separator (Space) ");
                    break;
                case 6:
                    w.getLogger().debug("Rule: separator (EOF) ");
                    break;
                case 7:
                    w.getLogger().debug("Rule: hierarchy: ", h[p - 1]), w.setHierarchy(h[p - 1]);
                    break;
                case 8:
                    w.getLogger().debug("Stop NL ");
                    break;
                case 9:
                    w.getLogger().debug("Stop EOF ");
                    break;
                case 10:
                    w.getLogger().debug("Stop NL2 ");
                    break;
                case 11:
                    w.getLogger().debug("Stop EOF2 ");
                    break;
                case 12:
                    w.getLogger().debug("Rule: statement: ", h[p]), typeof h[p].length == "number" ? this.$ = h[p] : this.$ = [
                        h[p]
                    ];
                    break;
                case 13:
                    w.getLogger().debug("Rule: statement #2: ", h[p - 1]), this.$ = /*#__PURE__*/ [
                        h[p - 1]
                    ].concat(h[p]);
                    break;
                case 14:
                    w.getLogger().debug("Rule: link: ", h[p], y), this.$ = {
                        edgeTypeStr: h[p],
                        label: ""
                    };
                    break;
                case 15:
                    w.getLogger().debug("Rule: LABEL link: ", h[p - 3], h[p - 1], h[p]), this.$ = {
                        edgeTypeStr: h[p],
                        label: h[p - 1]
                    };
                    break;
                case 18:
                    let R = /*#__PURE__*/ parseInt(h[p]), Z = /*#__PURE__*/ w.generateId();
                    this.$ = {
                        id: Z,
                        type: "space",
                        label: "",
                        width: R,
                        children: []
                    };
                    break;
                case 23:
                    w.getLogger().debug("Rule: (nodeStatement link node) ", h[p - 2], h[p - 1], h[p], " typestr: ", h[p - 1].edgeTypeStr);
                    let V = /*#__PURE__*/ w.edgeStrToEdgeData(h[p - 1].edgeTypeStr);
                    this.$ = [
                        {
                            id: h[p - 2].id,
                            label: h[p - 2].label,
                            type: h[p - 2].type,
                            directions: h[p - 2].directions
                        },
                        {
                            id: h[p - 2].id + "-" + h[p].id,
                            start: h[p - 2].id,
                            end: h[p].id,
                            label: h[p - 1].label,
                            type: "edge",
                            directions: h[p].directions,
                            arrowTypeEnd: V,
                            arrowTypeStart: "arrow_open"
                        },
                        {
                            id: h[p].id,
                            label: h[p].label,
                            type: /*#__PURE__*/ w.typeStr2Type(h[p].typeStr),
                            directions: h[p].directions
                        }
                    ];
                    break;
                case 24:
                    w.getLogger().debug("Rule: nodeStatement (abc88 node size) ", h[p - 1], h[p]), this.$ = {
                        id: h[p - 1].id,
                        label: h[p - 1].label,
                        type: /*#__PURE__*/ w.typeStr2Type(h[p - 1].typeStr),
                        directions: h[p - 1].directions,
                        widthInColumns: /*#__PURE__*/ parseInt(h[p], 10)
                    };
                    break;
                case 25:
                    w.getLogger().debug("Rule: nodeStatement (node) ", h[p]), this.$ = {
                        id: h[p].id,
                        label: h[p].label,
                        type: /*#__PURE__*/ w.typeStr2Type(h[p].typeStr),
                        directions: h[p].directions,
                        widthInColumns: 1
                    };
                    break;
                case 26:
                    w.getLogger().debug("APA123", this ? this : "na"), w.getLogger().debug("COLUMNS: ", h[p]), this.$ = {
                        type: "column-setting",
                        columns: h[p] === "auto" ? -1 : parseInt(h[p])
                    };
                    break;
                case 27:
                    w.getLogger().debug("Rule: id-block statement : ", h[p - 2], h[p - 1]);
                    w.generateId();
                    this.$ = {
                        ...h[p - 2],
                        type: "composite",
                        children: h[p - 1]
                    };
                    break;
                case 28:
                    w.getLogger().debug("Rule: blockStatement : ", h[p - 2], h[p - 1], h[p]);
                    let at = /*#__PURE__*/ w.generateId();
                    this.$ = {
                        id: at,
                        type: "composite",
                        label: "",
                        children: h[p - 1]
                    };
                    break;
                case 29:
                    w.getLogger().debug("Rule: node (NODE_ID separator): ", h[p]), this.$ = {
                        id: h[p]
                    };
                    break;
                case 30:
                    w.getLogger().debug("Rule: node (NODE_ID nodeShapeNLabel separator): ", h[p - 1], h[p]), this.$ = {
                        id: h[p - 1],
                        label: h[p].label,
                        typeStr: h[p].typeStr,
                        directions: h[p].directions
                    };
                    break;
                case 31:
                    w.getLogger().debug("Rule: dirList: ", h[p]), this.$ = [
                        h[p]
                    ];
                    break;
                case 32:
                    w.getLogger().debug("Rule: dirList: ", h[p - 1], h[p]), this.$ = /*#__PURE__*/ [
                        h[p - 1]
                    ].concat(h[p]);
                    break;
                case 33:
                    w.getLogger().debug("Rule: nodeShapeNLabel: ", h[p - 2], h[p - 1], h[p]), this.$ = {
                        typeStr: h[p - 2] + h[p],
                        label: h[p - 1]
                    };
                    break;
                case 34:
                    w.getLogger().debug("Rule: BLOCK_ARROW nodeShapeNLabel: ", h[p - 3], h[p - 2], " #3:", h[p - 1], h[p]), this.$ = {
                        typeStr: h[p - 3] + h[p],
                        label: h[p - 2],
                        directions: h[p - 1]
                    };
                    break;
                case 35:
                case 36:
                    this.$ = {
                        type: "classDef",
                        id: /*#__PURE__*/ h[p - 1].trim(),
                        css: /*#__PURE__*/ h[p].trim()
                    };
                    break;
                case 37:
                    this.$ = {
                        type: "applyClass",
                        id: /*#__PURE__*/ h[p - 1].trim(),
                        styleClass: /*#__PURE__*/ h[p].trim()
                    };
                    break;
                case 38:
                    this.$ = {
                        type: "applyStyles",
                        id: /*#__PURE__*/ h[p - 1].trim(),
                        stylesStr: /*#__PURE__*/ h[p].trim()
                    };
                    break;
            }
        }, "anonymous"),
        table: [
            {
                9: 1,
                10: [
                    1,
                    2
                ]
            },
            {
                1: [
                    3
                ]
            },
            {
                11: 3,
                13: 4,
                19: 5,
                20: 6,
                21: t,
                22: 8,
                23: 9,
                24: 10,
                25: 11,
                26: 12,
                28: s,
                29: n,
                31: i,
                32: a,
                40: r,
                44: l,
                47: o
            },
            {
                8: [
                    1,
                    20
                ]
            },
            /*#__PURE__*/ e(u, [
                2,
                12
            ], {
                13: 4,
                19: 5,
                20: 6,
                22: 8,
                23: 9,
                24: 10,
                25: 11,
                26: 12,
                11: 21,
                21: t,
                28: s,
                29: n,
                31: i,
                32: a,
                40: r,
                44: l,
                47: o
            }),
            /*#__PURE__*/ e(g, [
                2,
                16
            ], {
                14: 22,
                15: x,
                16: m
            }),
            /*#__PURE__*/ e(g, [
                2,
                17
            ]),
            /*#__PURE__*/ e(g, [
                2,
                18
            ]),
            /*#__PURE__*/ e(g, [
                2,
                19
            ]),
            /*#__PURE__*/ e(g, [
                2,
                20
            ]),
            /*#__PURE__*/ e(g, [
                2,
                21
            ]),
            /*#__PURE__*/ e(g, [
                2,
                22
            ]),
            /*#__PURE__*/ e(b, [
                2,
                25
            ], {
                27: [
                    1,
                    25
                ]
            }),
            /*#__PURE__*/ e(g, [
                2,
                26
            ]),
            {
                19: 26,
                26: 12,
                32: a
            },
            {
                11: 27,
                13: 4,
                19: 5,
                20: 6,
                21: t,
                22: 8,
                23: 9,
                24: 10,
                25: 11,
                26: 12,
                28: s,
                29: n,
                31: i,
                32: a,
                40: r,
                44: l,
                47: o
            },
            {
                41: [
                    1,
                    28
                ],
                43: [
                    1,
                    29
                ]
            },
            {
                45: [
                    1,
                    30
                ]
            },
            {
                48: [
                    1,
                    31
                ]
            },
            /*#__PURE__*/ e(L, [
                2,
                29
            ], {
                33: 32,
                36: [
                    1,
                    33
                ],
                38: [
                    1,
                    34
                ]
            }),
            {
                1: [
                    2,
                    7
                ]
            },
            /*#__PURE__*/ e(u, [
                2,
                13
            ]),
            {
                26: 35,
                32: a
            },
            {
                32: [
                    2,
                    14
                ]
            },
            {
                17: [
                    1,
                    36
                ]
            },
            /*#__PURE__*/ e(b, [
                2,
                24
            ]),
            {
                11: 37,
                13: 4,
                14: 22,
                15: x,
                16: m,
                19: 5,
                20: 6,
                21: t,
                22: 8,
                23: 9,
                24: 10,
                25: 11,
                26: 12,
                28: s,
                29: n,
                31: i,
                32: a,
                40: r,
                44: l,
                47: o
            },
            {
                30: [
                    1,
                    38
                ]
            },
            {
                42: [
                    1,
                    39
                ]
            },
            {
                42: [
                    1,
                    40
                ]
            },
            {
                46: [
                    1,
                    41
                ]
            },
            {
                49: [
                    1,
                    42
                ]
            },
            /*#__PURE__*/ e(L, [
                2,
                30
            ]),
            {
                18: [
                    1,
                    43
                ]
            },
            {
                18: [
                    1,
                    44
                ]
            },
            /*#__PURE__*/ e(b, [
                2,
                23
            ]),
            {
                18: [
                    1,
                    45
                ]
            },
            {
                30: [
                    1,
                    46
                ]
            },
            /*#__PURE__*/ e(g, [
                2,
                28
            ]),
            /*#__PURE__*/ e(g, [
                2,
                35
            ]),
            /*#__PURE__*/ e(g, [
                2,
                36
            ]),
            /*#__PURE__*/ e(g, [
                2,
                37
            ]),
            /*#__PURE__*/ e(g, [
                2,
                38
            ]),
            {
                37: [
                    1,
                    47
                ]
            },
            {
                34: 48,
                35: _
            },
            {
                15: [
                    1,
                    50
                ]
            },
            /*#__PURE__*/ e(g, [
                2,
                27
            ]),
            /*#__PURE__*/ e(L, [
                2,
                33
            ]),
            {
                39: [
                    1,
                    51
                ]
            },
            {
                34: 52,
                35: _,
                39: [
                    2,
                    31
                ]
            },
            {
                32: [
                    2,
                    15
                ]
            },
            /*#__PURE__*/ e(L, [
                2,
                34
            ]),
            {
                39: [
                    2,
                    32
                ]
            }
        ],
        defaultActions: {
            20: [
                2,
                7
            ],
            23: [
                2,
                14
            ],
            50: [
                2,
                15
            ],
            52: [
                2,
                32
            ]
        },
        parseError: /*#__PURE__*/ m$1(function(y, d) {
            if (d.recoverable) this.trace(y);
            else {
                var f = new Error(y);
                throw f.hash = d, f;
            }
        }, "parseError"),
        parse: /*#__PURE__*/ m$1(function(y) {
            var d = this, f = [
                0
            ], w = [], E = [
                null
            ], h = [], Y = this.table, p = "", R = 0, Z = 0, V = 0, Bt = 2, at = 1, Be = /*#__PURE__*/ h.slice.call(arguments, 1), z = /*#__PURE__*/ Object.create(this.lexer), J = {
                yy: {}
            };
            for(var dt in this.yy)Object.prototype.hasOwnProperty.call(this.yy, dt) && (J.yy[dt] = this.yy[dt]);
            z.setInput(y, J.yy), J.yy.lexer = z, J.yy.parser = this, typeof z.yylloc > "u" && (z.yylloc = {});
            var ut = z.yylloc;
            h.push(ut);
            var ve = z.options && z.options.ranges;
            typeof J.yy.parseError == "function" ? this.parseError = J.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
            function qr(H) {
                f.length = f.length - 2 * H, E.length = E.length - H, h.length = h.length - H;
            }
            m$1(qr, "popStack");
            function Te() {
                var H;
                return H = w.pop() || z.lex() || at, typeof H != "number" && (H instanceof Array && (w = H, H = /*#__PURE__*/ w.pop()), H = d.symbols_[H] || H), H;
            }
            m$1(Te, "lex");
            for(var F, pt, Q, K, Jr, ft, $ = {}, st, G, vt, it;;){
                if (Q = f[f.length - 1], this.defaultActions[Q] ? K = this.defaultActions[Q] : ((F === null || typeof F > "u") && (F = /*#__PURE__*/ Te()), K = Y[Q] && Y[Q][F]), typeof K > "u" || !K.length || !K[0]) {
                    var xt = "";
                    it = [];
                    for(st in Y[Q])this.terminals_[st] && st > Bt && it.push("'" + this.terminals_[st] + "'");
                    z.showPosition ? xt = "Parse error on line " + (R + 1) + `:
` + z.showPosition() + `
Expecting ` + it.join(", ") + ", got '" + (this.terminals_[F] || F) + "'" : xt = "Parse error on line " + (R + 1) + ": Unexpected " + (F == at ? "end of input" : "'" + (this.terminals_[F] || F) + "'"), this.parseError(xt, {
                        text: z.match,
                        token: this.terminals_[F] || F,
                        line: z.yylineno,
                        loc: ut,
                        expected: it
                    });
                }
                if (K[0] instanceof Array && K.length > 1) throw new Error("Parse Error: multiple actions possible at state: " + Q + ", token: " + F);
                switch(K[0]){
                    case 1:
                        f.push(F), E.push(z.yytext), h.push(z.yylloc), f.push(K[1]), F = null, pt ? (F = pt, pt = null) : (Z = z.yyleng, p = z.yytext, R = z.yylineno, ut = z.yylloc, V > 0);
                        break;
                    case 2:
                        if (G = this.productions_[K[1]][1], $.$ = E[E.length - G], $._$ = {
                            first_line: h[h.length - (G || 1)].first_line,
                            last_line: h[h.length - 1].last_line,
                            first_column: h[h.length - (G || 1)].first_column,
                            last_column: h[h.length - 1].last_column
                        }, ve && ($._$.range = [
                            h[h.length - (G || 1)].range[0],
                            h[h.length - 1].range[1]
                        ]), ft = /*#__PURE__*/ this.performAction.apply($, /*#__PURE__*/ [
                            p,
                            Z,
                            R,
                            J.yy,
                            K[1],
                            E,
                            h
                        ].concat(Be)), typeof ft < "u") return ft;
                        G && (f = /*#__PURE__*/ f.slice(0, -1 * G * 2), E = /*#__PURE__*/ E.slice(0, -1 * G), h = /*#__PURE__*/ h.slice(0, -1 * G)), f.push(this.productions_[K[1]][0]), E.push($.$), h.push($._$), vt = Y[f[f.length - 2]][f[f.length - 1]], f.push(vt);
                        break;
                    case 3:
                        return true;
                }
            }
            return true;
        }, "parse")
    }, I = /*#__PURE__*/ function() {
        var T = {
            EOF: 1,
            parseError: /*#__PURE__*/ m$1(function(d, f) {
                if (this.yy.parser) this.yy.parser.parseError(d, f);
                else throw new Error(d);
            }, "parseError"),
            setInput: /*#__PURE__*/ m$1(function(y, d) {
                return this.yy = d || this.yy || {}, this._input = y, this._more = this._backtrack = this.done = false, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = [
                    "INITIAL"
                ], this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0
                }, this.options.ranges && (this.yylloc.range = [
                    0,
                    0
                ]), this.offset = 0, this;
            }, "setInput"),
            input: /*#__PURE__*/ m$1(function() {
                var y = this._input[0];
                this.yytext += y, this.yyleng++, this.offset++, this.match += y, this.matched += y;
                var d = /*#__PURE__*/ y.match(/(?:\r\n?|\n).*/g);
                return d ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = /*#__PURE__*/ this._input.slice(1), y;
            }, "input"),
            unput: /*#__PURE__*/ m$1(function(y) {
                var d = y.length, f = /*#__PURE__*/ y.split(/(?:\r\n?|\n)/g);
                this._input = y + this._input, this.yytext = /*#__PURE__*/ this.yytext.substr(0, this.yytext.length - d), this.offset -= d;
                var w = /*#__PURE__*/ this.match.split(/(?:\r\n?|\n)/g);
                this.match = /*#__PURE__*/ this.match.substr(0, this.match.length - 1), this.matched = /*#__PURE__*/ this.matched.substr(0, this.matched.length - 1), f.length - 1 && (this.yylineno -= f.length - 1);
                var E = this.yylloc.range;
                return this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: f ? (f.length === w.length ? this.yylloc.first_column : 0) + w[w.length - f.length].length - f[0].length : this.yylloc.first_column - d
                }, this.options.ranges && (this.yylloc.range = [
                    E[0],
                    E[0] + this.yyleng - d
                ]), this.yyleng = this.yytext.length, this;
            }, "unput"),
            more: /*#__PURE__*/ m$1(function() {
                return this._more = true, this;
            }, "more"),
            reject: /*#__PURE__*/ m$1(function() {
                if (this.options.backtrack_lexer) this._backtrack = true;
                else return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
                    text: "",
                    token: null,
                    line: this.yylineno
                });
                return this;
            }, "reject"),
            less: /*#__PURE__*/ m$1(function(y) {
                this.unput(/*#__PURE__*/ this.match.slice(y));
            }, "less"),
            pastInput: /*#__PURE__*/ m$1(function() {
                var y = /*#__PURE__*/ this.matched.substr(0, this.matched.length - this.match.length);
                return (y.length > 20 ? "..." : "") + y.substr(-20).replace(/\n/g, "");
            }, "pastInput"),
            upcomingInput: /*#__PURE__*/ m$1(function() {
                var y = this.match;
                return y.length < 20 && (y += /*#__PURE__*/ this._input.substr(0, 20 - y.length)), (y.substr(0, 20) + (y.length > 20 ? "..." : "")).replace(/\n/g, "");
            }, "upcomingInput"),
            showPosition: /*#__PURE__*/ m$1(function() {
                var y = /*#__PURE__*/ this.pastInput(), d = /*#__PURE__*/ new Array(y.length + 1).join("-");
                return y + this.upcomingInput() + `
` + d + "^";
            }, "showPosition"),
            test_match: /*#__PURE__*/ m$1(function(y, d) {
                var f, w, E;
                if (this.options.backtrack_lexer && (E = {
                    yylineno: this.yylineno,
                    yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column
                    },
                    yytext: this.yytext,
                    match: this.match,
                    matches: this.matches,
                    matched: this.matched,
                    yyleng: this.yyleng,
                    offset: this.offset,
                    _more: this._more,
                    _input: this._input,
                    yy: this.yy,
                    conditionStack: /*#__PURE__*/ this.conditionStack.slice(0),
                    done: this.done
                }, this.options.ranges && (E.yylloc.range = /*#__PURE__*/ this.yylloc.range.slice(0))), w = /*#__PURE__*/ y[0].match(/(?:\r\n?|\n).*/g), w && (this.yylineno += w.length), this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: w ? w[w.length - 1].length - w[w.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + y[0].length
                }, this.yytext += y[0], this.match += y[0], this.matches = y, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [
                    this.offset,
                    this.offset += this.yyleng
                ]), this._more = false, this._backtrack = false, this._input = /*#__PURE__*/ this._input.slice(y[0].length), this.matched += y[0], f = /*#__PURE__*/ this.performAction.call(this, this.yy, this, d, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = false), f) return f;
                if (this._backtrack) {
                    for(var h in E)this[h] = E[h];
                    return false;
                }
                return false;
            }, "test_match"),
            next: /*#__PURE__*/ m$1(function() {
                if (this.done) return this.EOF;
                this._input || (this.done = true);
                var y, d, f, w;
                this._more || (this.yytext = "", this.match = "");
                for(var E = /*#__PURE__*/ this._currentRules(), h = 0; h < E.length; h++)if (f = /*#__PURE__*/ this._input.match(this.rules[E[h]]), f && (!d || f[0].length > d[0].length)) {
                    if (d = f, w = h, this.options.backtrack_lexer) {
                        if (y = /*#__PURE__*/ this.test_match(f, E[h]), y !== false) return y;
                        if (this._backtrack) {
                            d = false;
                            continue;
                        } else return false;
                    } else if (!this.options.flex) break;
                }
                return d ? (y = /*#__PURE__*/ this.test_match(d, E[w]), y !== false ? y : false) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
                    text: "",
                    token: null,
                    line: this.yylineno
                });
            }, "next"),
            lex: /*#__PURE__*/ m$1(function() {
                var d = /*#__PURE__*/ this.next();
                return d || this.lex();
            }, "lex"),
            begin: /*#__PURE__*/ m$1(function(d) {
                this.conditionStack.push(d);
            }, "begin"),
            popState: /*#__PURE__*/ m$1(function() {
                var d = this.conditionStack.length - 1;
                return d > 0 ? this.conditionStack.pop() : this.conditionStack[0];
            }, "popState"),
            _currentRules: /*#__PURE__*/ m$1(function() {
                return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
            }, "_currentRules"),
            topState: /*#__PURE__*/ m$1(function(d) {
                return d = this.conditionStack.length - 1 - Math.abs(d || 0), d >= 0 ? this.conditionStack[d] : "INITIAL";
            }, "topState"),
            pushState: /*#__PURE__*/ m$1(function(d) {
                this.begin(d);
            }, "pushState"),
            stateStackSize: /*#__PURE__*/ m$1(function() {
                return this.conditionStack.length;
            }, "stateStackSize"),
            options: {},
            performAction: /*#__PURE__*/ m$1(function(d, f, w, E) {
                switch(w){
                    case 0:
                        return 10;
                    case 1:
                        return d.getLogger().debug("Found space-block"), 31;
                    case 2:
                        return d.getLogger().debug("Found nl-block"), 31;
                    case 3:
                        return d.getLogger().debug("Found space-block"), 29;
                    case 4:
                        d.getLogger().debug(".", f.yytext);
                        break;
                    case 5:
                        d.getLogger().debug("_", f.yytext);
                        break;
                    case 6:
                        return 5;
                    case 7:
                        return f.yytext = -1, 28;
                    case 8:
                        return f.yytext = /*#__PURE__*/ f.yytext.replace(/columns\s+/, ""), d.getLogger().debug("COLUMNS (LEX)", f.yytext), 28;
                    case 9:
                        this.pushState("md_string");
                        break;
                    case 10:
                        return "MD_STR";
                    case 11:
                        this.popState();
                        break;
                    case 12:
                        this.pushState("string");
                        break;
                    case 13:
                        d.getLogger().debug("LEX: POPPING STR:", f.yytext), this.popState();
                        break;
                    case 14:
                        return d.getLogger().debug("LEX: STR end:", f.yytext), "STR";
                    case 15:
                        return f.yytext = /*#__PURE__*/ f.yytext.replace(/space\:/, ""), d.getLogger().debug("SPACE NUM (LEX)", f.yytext), 21;
                    case 16:
                        return f.yytext = "1", d.getLogger().debug("COLUMNS (LEX)", f.yytext), 21;
                    case 17:
                        return 43;
                    case 18:
                        return "LINKSTYLE";
                    case 19:
                        return "INTERPOLATE";
                    case 20:
                        return this.pushState("CLASSDEF"), 40;
                    case 21:
                        return this.popState(), this.pushState("CLASSDEFID"), "DEFAULT_CLASSDEF_ID";
                    case 22:
                        return this.popState(), this.pushState("CLASSDEFID"), 41;
                    case 23:
                        return this.popState(), 42;
                    case 24:
                        return this.pushState("CLASS"), 44;
                    case 25:
                        return this.popState(), this.pushState("CLASS_STYLE"), 45;
                    case 26:
                        return this.popState(), 46;
                    case 27:
                        return this.pushState("STYLE_STMNT"), 47;
                    case 28:
                        return this.popState(), this.pushState("STYLE_DEFINITION"), 48;
                    case 29:
                        return this.popState(), 49;
                    case 30:
                        return this.pushState("acc_title"), "acc_title";
                    case 31:
                        return this.popState(), "acc_title_value";
                    case 32:
                        return this.pushState("acc_descr"), "acc_descr";
                    case 33:
                        return this.popState(), "acc_descr_value";
                    case 34:
                        this.pushState("acc_descr_multiline");
                        break;
                    case 35:
                        this.popState();
                        break;
                    case 36:
                        return "acc_descr_multiline_value";
                    case 37:
                        return 30;
                    case 38:
                        return this.popState(), d.getLogger().debug("Lex: (("), "NODE_DEND";
                    case 39:
                        return this.popState(), d.getLogger().debug("Lex: (("), "NODE_DEND";
                    case 40:
                        return this.popState(), d.getLogger().debug("Lex: ))"), "NODE_DEND";
                    case 41:
                        return this.popState(), d.getLogger().debug("Lex: (("), "NODE_DEND";
                    case 42:
                        return this.popState(), d.getLogger().debug("Lex: (("), "NODE_DEND";
                    case 43:
                        return this.popState(), d.getLogger().debug("Lex: (-"), "NODE_DEND";
                    case 44:
                        return this.popState(), d.getLogger().debug("Lex: -)"), "NODE_DEND";
                    case 45:
                        return this.popState(), d.getLogger().debug("Lex: (("), "NODE_DEND";
                    case 46:
                        return this.popState(), d.getLogger().debug("Lex: ]]"), "NODE_DEND";
                    case 47:
                        return this.popState(), d.getLogger().debug("Lex: ("), "NODE_DEND";
                    case 48:
                        return this.popState(), d.getLogger().debug("Lex: ])"), "NODE_DEND";
                    case 49:
                        return this.popState(), d.getLogger().debug("Lex: /]"), "NODE_DEND";
                    case 50:
                        return this.popState(), d.getLogger().debug("Lex: /]"), "NODE_DEND";
                    case 51:
                        return this.popState(), d.getLogger().debug("Lex: )]"), "NODE_DEND";
                    case 52:
                        return this.popState(), d.getLogger().debug("Lex: )"), "NODE_DEND";
                    case 53:
                        return this.popState(), d.getLogger().debug("Lex: ]>"), "NODE_DEND";
                    case 54:
                        return this.popState(), d.getLogger().debug("Lex: ]"), "NODE_DEND";
                    case 55:
                        return d.getLogger().debug("Lexa: -)"), this.pushState("NODE"), 36;
                    case 56:
                        return d.getLogger().debug("Lexa: (-"), this.pushState("NODE"), 36;
                    case 57:
                        return d.getLogger().debug("Lexa: ))"), this.pushState("NODE"), 36;
                    case 58:
                        return d.getLogger().debug("Lexa: )"), this.pushState("NODE"), 36;
                    case 59:
                        return d.getLogger().debug("Lex: ((("), this.pushState("NODE"), 36;
                    case 60:
                        return d.getLogger().debug("Lexa: )"), this.pushState("NODE"), 36;
                    case 61:
                        return d.getLogger().debug("Lexa: )"), this.pushState("NODE"), 36;
                    case 62:
                        return d.getLogger().debug("Lexa: )"), this.pushState("NODE"), 36;
                    case 63:
                        return d.getLogger().debug("Lexc: >"), this.pushState("NODE"), 36;
                    case 64:
                        return d.getLogger().debug("Lexa: (["), this.pushState("NODE"), 36;
                    case 65:
                        return d.getLogger().debug("Lexa: )"), this.pushState("NODE"), 36;
                    case 66:
                        return this.pushState("NODE"), 36;
                    case 67:
                        return this.pushState("NODE"), 36;
                    case 68:
                        return this.pushState("NODE"), 36;
                    case 69:
                        return this.pushState("NODE"), 36;
                    case 70:
                        return this.pushState("NODE"), 36;
                    case 71:
                        return this.pushState("NODE"), 36;
                    case 72:
                        return this.pushState("NODE"), 36;
                    case 73:
                        return d.getLogger().debug("Lexa: ["), this.pushState("NODE"), 36;
                    case 74:
                        return this.pushState("BLOCK_ARROW"), d.getLogger().debug("LEX ARR START"), 38;
                    case 75:
                        return d.getLogger().debug("Lex: NODE_ID", f.yytext), 32;
                    case 76:
                        return d.getLogger().debug("Lex: EOF", f.yytext), 8;
                    case 77:
                        this.pushState("md_string");
                        break;
                    case 78:
                        this.pushState("md_string");
                        break;
                    case 79:
                        return "NODE_DESCR";
                    case 80:
                        this.popState();
                        break;
                    case 81:
                        d.getLogger().debug("Lex: Starting string"), this.pushState("string");
                        break;
                    case 82:
                        d.getLogger().debug("LEX ARR: Starting string"), this.pushState("string");
                        break;
                    case 83:
                        return d.getLogger().debug("LEX: NODE_DESCR:", f.yytext), "NODE_DESCR";
                    case 84:
                        d.getLogger().debug("LEX POPPING"), this.popState();
                        break;
                    case 85:
                        d.getLogger().debug("Lex: =>BAE"), this.pushState("ARROW_DIR");
                        break;
                    case 86:
                        return f.yytext = /*#__PURE__*/ f.yytext.replace(/^,\s*/, ""), d.getLogger().debug("Lex (right): dir:", f.yytext), "DIR";
                    case 87:
                        return f.yytext = /*#__PURE__*/ f.yytext.replace(/^,\s*/, ""), d.getLogger().debug("Lex (left):", f.yytext), "DIR";
                    case 88:
                        return f.yytext = /*#__PURE__*/ f.yytext.replace(/^,\s*/, ""), d.getLogger().debug("Lex (x):", f.yytext), "DIR";
                    case 89:
                        return f.yytext = /*#__PURE__*/ f.yytext.replace(/^,\s*/, ""), d.getLogger().debug("Lex (y):", f.yytext), "DIR";
                    case 90:
                        return f.yytext = /*#__PURE__*/ f.yytext.replace(/^,\s*/, ""), d.getLogger().debug("Lex (up):", f.yytext), "DIR";
                    case 91:
                        return f.yytext = /*#__PURE__*/ f.yytext.replace(/^,\s*/, ""), d.getLogger().debug("Lex (down):", f.yytext), "DIR";
                    case 92:
                        return f.yytext = "]>", d.getLogger().debug("Lex (ARROW_DIR end):", f.yytext), this.popState(), this.popState(), "BLOCK_ARROW_END";
                    case 93:
                        return d.getLogger().debug("Lex: LINK", "#" + f.yytext + "#"), 15;
                    case 94:
                        return d.getLogger().debug("Lex: LINK", f.yytext), 15;
                    case 95:
                        return d.getLogger().debug("Lex: LINK", f.yytext), 15;
                    case 96:
                        return d.getLogger().debug("Lex: LINK", f.yytext), 15;
                    case 97:
                        return d.getLogger().debug("Lex: START_LINK", f.yytext), this.pushState("LLABEL"), 16;
                    case 98:
                        return d.getLogger().debug("Lex: START_LINK", f.yytext), this.pushState("LLABEL"), 16;
                    case 99:
                        return d.getLogger().debug("Lex: START_LINK", f.yytext), this.pushState("LLABEL"), 16;
                    case 100:
                        this.pushState("md_string");
                        break;
                    case 101:
                        return d.getLogger().debug("Lex: Starting string"), this.pushState("string"), "LINK_LABEL";
                    case 102:
                        return this.popState(), d.getLogger().debug("Lex: LINK", "#" + f.yytext + "#"), 15;
                    case 103:
                        return this.popState(), d.getLogger().debug("Lex: LINK", f.yytext), 15;
                    case 104:
                        return this.popState(), d.getLogger().debug("Lex: LINK", f.yytext), 15;
                    case 105:
                        return d.getLogger().debug("Lex: COLON", f.yytext), f.yytext = /*#__PURE__*/ f.yytext.slice(1), 27;
                }
            }, "anonymous"),
            rules: [
                /^(?:block-beta\b)/,
                /^(?:block\s+)/,
                /^(?:block\n+)/,
                /^(?:block:)/,
                /^(?:[\s]+)/,
                /^(?:[\n]+)/,
                /^(?:((\u000D\u000A)|(\u000A)))/,
                /^(?:columns\s+auto\b)/,
                /^(?:columns\s+[\d]+)/,
                /^(?:["][`])/,
                /^(?:[^`"]+)/,
                /^(?:[`]["])/,
                /^(?:["])/,
                /^(?:["])/,
                /^(?:[^"]*)/,
                /^(?:space[:]\d+)/,
                /^(?:space\b)/,
                /^(?:default\b)/,
                /^(?:linkStyle\b)/,
                /^(?:interpolate\b)/,
                /^(?:classDef\s+)/,
                /^(?:DEFAULT\s+)/,
                /^(?:\w+\s+)/,
                /^(?:[^\n]*)/,
                /^(?:class\s+)/,
                /^(?:(\w+)+((,\s*\w+)*))/,
                /^(?:[^\n]*)/,
                /^(?:style\s+)/,
                /^(?:(\w+)+((,\s*\w+)*))/,
                /^(?:[^\n]*)/,
                /^(?:accTitle\s*:\s*)/,
                /^(?:(?!\n||)*[^\n]*)/,
                /^(?:accDescr\s*:\s*)/,
                /^(?:(?!\n||)*[^\n]*)/,
                /^(?:accDescr\s*\{\s*)/,
                /^(?:[\}])/,
                /^(?:[^\}]*)/,
                /^(?:end\b\s*)/,
                /^(?:\(\(\()/,
                /^(?:\)\)\))/,
                /^(?:[\)]\))/,
                /^(?:\}\})/,
                /^(?:\})/,
                /^(?:\(-)/,
                /^(?:-\))/,
                /^(?:\(\()/,
                /^(?:\]\])/,
                /^(?:\()/,
                /^(?:\]\))/,
                /^(?:\\\])/,
                /^(?:\/\])/,
                /^(?:\)\])/,
                /^(?:[\)])/,
                /^(?:\]>)/,
                /^(?:[\]])/,
                /^(?:-\))/,
                /^(?:\(-)/,
                /^(?:\)\))/,
                /^(?:\))/,
                /^(?:\(\(\()/,
                /^(?:\(\()/,
                /^(?:\{\{)/,
                /^(?:\{)/,
                /^(?:>)/,
                /^(?:\(\[)/,
                /^(?:\()/,
                /^(?:\[\[)/,
                /^(?:\[\|)/,
                /^(?:\[\()/,
                /^(?:\)\)\))/,
                /^(?:\[\\)/,
                /^(?:\[\/)/,
                /^(?:\[\\)/,
                /^(?:\[)/,
                /^(?:<\[)/,
                /^(?:[^\(\[\n\-\)\{\}\s\<\>:]+)/,
                /^(?:$)/,
                /^(?:["][`])/,
                /^(?:["][`])/,
                /^(?:[^`"]+)/,
                /^(?:[`]["])/,
                /^(?:["])/,
                /^(?:["])/,
                /^(?:[^"]+)/,
                /^(?:["])/,
                /^(?:\]>\s*\()/,
                /^(?:,?\s*right\s*)/,
                /^(?:,?\s*left\s*)/,
                /^(?:,?\s*x\s*)/,
                /^(?:,?\s*y\s*)/,
                /^(?:,?\s*up\s*)/,
                /^(?:,?\s*down\s*)/,
                /^(?:\)\s*)/,
                /^(?:\s*[xo<]?--+[-xo>]\s*)/,
                /^(?:\s*[xo<]?==+[=xo>]\s*)/,
                /^(?:\s*[xo<]?-?\.+-[xo>]?\s*)/,
                /^(?:\s*~~[\~]+\s*)/,
                /^(?:\s*[xo<]?--\s*)/,
                /^(?:\s*[xo<]?==\s*)/,
                /^(?:\s*[xo<]?-\.\s*)/,
                /^(?:["][`])/,
                /^(?:["])/,
                /^(?:\s*[xo<]?--+[-xo>]\s*)/,
                /^(?:\s*[xo<]?==+[=xo>]\s*)/,
                /^(?:\s*[xo<]?-?\.+-[xo>]?\s*)/,
                /^(?::\d+)/
            ],
            conditions: {
                STYLE_DEFINITION: {
                    rules: [
                        29
                    ],
                    inclusive: false
                },
                STYLE_STMNT: {
                    rules: [
                        28
                    ],
                    inclusive: false
                },
                CLASSDEFID: {
                    rules: [
                        23
                    ],
                    inclusive: false
                },
                CLASSDEF: {
                    rules: [
                        21,
                        22
                    ],
                    inclusive: false
                },
                CLASS_STYLE: {
                    rules: [
                        26
                    ],
                    inclusive: false
                },
                CLASS: {
                    rules: [
                        25
                    ],
                    inclusive: false
                },
                LLABEL: {
                    rules: [
                        100,
                        101,
                        102,
                        103,
                        104
                    ],
                    inclusive: false
                },
                ARROW_DIR: {
                    rules: [
                        86,
                        87,
                        88,
                        89,
                        90,
                        91,
                        92
                    ],
                    inclusive: false
                },
                BLOCK_ARROW: {
                    rules: [
                        77,
                        82,
                        85
                    ],
                    inclusive: false
                },
                NODE: {
                    rules: [
                        38,
                        39,
                        40,
                        41,
                        42,
                        43,
                        44,
                        45,
                        46,
                        47,
                        48,
                        49,
                        50,
                        51,
                        52,
                        53,
                        54,
                        78,
                        81
                    ],
                    inclusive: false
                },
                md_string: {
                    rules: [
                        10,
                        11,
                        79,
                        80
                    ],
                    inclusive: false
                },
                space: {
                    rules: [],
                    inclusive: false
                },
                string: {
                    rules: [
                        13,
                        14,
                        83,
                        84
                    ],
                    inclusive: false
                },
                acc_descr_multiline: {
                    rules: [
                        35,
                        36
                    ],
                    inclusive: false
                },
                acc_descr: {
                    rules: [
                        33
                    ],
                    inclusive: false
                },
                acc_title: {
                    rules: [
                        31
                    ],
                    inclusive: false
                },
                INITIAL: {
                    rules: [
                        0,
                        1,
                        2,
                        3,
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        12,
                        15,
                        16,
                        17,
                        18,
                        19,
                        20,
                        24,
                        27,
                        30,
                        32,
                        34,
                        37,
                        55,
                        56,
                        57,
                        58,
                        59,
                        60,
                        61,
                        62,
                        63,
                        64,
                        65,
                        66,
                        67,
                        68,
                        69,
                        70,
                        71,
                        72,
                        73,
                        74,
                        75,
                        76,
                        93,
                        94,
                        95,
                        96,
                        97,
                        98,
                        99,
                        105
                    ],
                    inclusive: true
                }
            }
        };
        return T;
    }();
    S.lexer = I;
    function D() {
        this.yy = {};
    }
    return m$1(D, "Parser"), D.prototype = S, S.Parser = D, new D;
}();
yt.parser = yt;
var Kt = yt;
var X = new Map, kt = [], mt = new Map, Xt = "color", Ut = "fill", Ne = "bgFill", Gt = ",", Ie = /*#__PURE__*/ hh(), lt = new Map, Oe = /*#__PURE__*/ m$1((e)=>XC.sanitizeText(e, Ie), "sanitizeText"), Re = /*#__PURE__*/ m$1(function(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    let s = /*#__PURE__*/ lt.get(e);
    s || (s = {
        id: e,
        styles: [],
        textStyles: []
    }, lt.set(e, s)), t?.split(Gt).forEach((n)=>{
        let i = /*#__PURE__*/ n.replace(/([^;]*);/, "$1").trim();
        if (RegExp(Xt).exec(n)) {
            let r = /*#__PURE__*/ i.replace(Ut, Ne).replace(Xt, Ut);
            s.textStyles.push(r);
        }
        s.styles.push(i);
    });
}, "addStyleClass"), Ae = /*#__PURE__*/ m$1(function(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    let s = /*#__PURE__*/ X.get(e);
    t != null && (s.styles = /*#__PURE__*/ t.split(Gt));
}, "addStyle2Node"), ze = /*#__PURE__*/ m$1(function(e, t) {
    e.split(",").forEach(function(s) {
        let n = /*#__PURE__*/ X.get(s);
        if (n === void 0) {
            let i = /*#__PURE__*/ s.trim();
            n = {
                id: i,
                type: "na",
                children: []
            }, X.set(i, n);
        }
        n.classes || (n.classes = []), n.classes.push(t);
    });
}, "setCssClass"), Zt = m$1((e, t)=>{
    let s = /*#__PURE__*/ e.flat(), n = [];
    for (let i of s){
        if (i.label && (i.label = /*#__PURE__*/ Oe(i.label)), i.type === "classDef") {
            Re(i.id, i.css);
            continue;
        }
        if (i.type === "applyClass") {
            ze(i.id, i?.styleClass ?? "");
            continue;
        }
        if (i.type === "applyStyles") {
            i?.stylesStr && Ae(i.id, i?.stylesStr);
            continue;
        }
        if (i.type === "column-setting") t.columns = i.columns ?? -1;
        else if (i.type === "edge") {
            let a = (mt.get(i.id) ?? 0) + 1;
            mt.set(i.id, a), i.id = a + "-" + i.id, kt.push(i);
        } else {
            i.label || (i.type === "composite" ? i.label = "" : i.label = i.id);
            let a = /*#__PURE__*/ X.get(i.id);
            if (a === void 0 ? X.set(i.id, i) : (i.type !== "na" && (a.type = i.type), i.label !== i.id && (a.label = i.label)), i.children && Zt(i.children, i), i.type === "space") {
                let r = i.width ?? 1;
                for(let l = 0; l < r; l++){
                    let o = /*#__PURE__*/ _f(i);
                    o.id = o.id + "-" + l, X.set(o.id, o), n.push(o);
                }
            } else a === void 0 && n.push(i);
        }
    }
    t.children = n;
}, "populateBlockDatabase"), wt = [], rt = {
    id: "root",
    type: "composite",
    children: [],
    columns: -1
}, Me = /*#__PURE__*/ m$1(()=>{
    tt.debug("Clear called"), Vf(), rt = {
        id: "root",
        type: "composite",
        children: [],
        columns: -1
    }, X = new Map([
        [
            "root",
            rt
        ]
    ]), wt = [], lt = new Map, kt = [], mt = new Map;
}, "clear");
function Fe(e) {
    switch(tt.debug("typeStr2Type", e), e){
        case "[]":
            return "square";
        case "()":
            return tt.debug("we have a round"), "round";
        case "(())":
            return "circle";
        case ">]":
            return "rect_left_inv_arrow";
        case "{}":
            return "diamond";
        case "{{}}":
            return "hexagon";
        case "([])":
            return "stadium";
        case "[[]]":
            return "subroutine";
        case "[()]":
            return "cylinder";
        case "((()))":
            return "doublecircle";
        case "[//]":
            return "lean_right";
        case "[\\\\]":
            return "lean_left";
        case "[/\\]":
            return "trapezoid";
        case "[\\/]":
            return "inv_trapezoid";
        case "<[]>":
            return "block_arrow";
        default:
            return "na";
    }
}
m$1(Fe, "typeStr2Type");
function We(e) {
    switch(tt.debug("typeStr2Type", e), e){
        case "==":
            return "thick";
        default:
            return "normal";
    }
}
m$1(We, "edgeTypeStr2Type");
function Pe(e) {
    switch(e.trim()){
        case "--x":
            return "arrow_cross";
        case "--o":
            return "arrow_circle";
        default:
            return "arrow_point";
    }
}
m$1(Pe, "edgeStrToEdgeData");
var Vt = 0, Ye = /*#__PURE__*/ m$1(()=>(Vt++, "id-" + Math.random().toString(36).substr(2, 12) + "-" + Vt), "generateId"), He = /*#__PURE__*/ m$1((e)=>{
    rt.children = e, Zt(e, rt), wt = rt.children;
}, "setHierarchy"), je = /*#__PURE__*/ m$1((e)=>{
    let t = /*#__PURE__*/ X.get(e);
    return t ? t.columns ? t.columns : t.children ? t.children.length : -1 : -1;
}, "getColumns"), Ke = /*#__PURE__*/ m$1(()=>[
        .../*#__PURE__*/ X.values()
    ], "getBlocksFlat"), Xe = /*#__PURE__*/ m$1(()=>wt || [], "getBlocks"), Ue = /*#__PURE__*/ m$1(()=>kt, "getEdges"), Ve = /*#__PURE__*/ m$1((e)=>X.get(e), "getBlock"), Ge = /*#__PURE__*/ m$1((e)=>{
    X.set(e.id, e);
}, "setBlock"), Ze = /*#__PURE__*/ m$1(()=>console, "getLogger"), qe = /*#__PURE__*/ m$1(function() {
    return lt;
}, "getClasses"), Je = {
    getConfig: /*#__PURE__*/ m$1(()=>Or$1().block, "getConfig"),
    typeStr2Type: Fe,
    edgeTypeStr2Type: We,
    edgeStrToEdgeData: Pe,
    getLogger: Ze,
    getBlocksFlat: Ke,
    getBlocks: Xe,
    getEdges: Ue,
    setHierarchy: He,
    getBlock: Ve,
    setBlock: Ge,
    getColumns: je,
    getClasses: qe,
    clear: Me,
    generateId: Ye
}, qt = Je;
var ot = /*#__PURE__*/ m$1((e, t)=>{
    let s = Vu, n = /*#__PURE__*/ s(e, "r"), i = /*#__PURE__*/ s(e, "g"), a = /*#__PURE__*/ s(e, "b");
    return se$1(n, i, a, t);
}, "fade"), Qe = /*#__PURE__*/ m$1((e)=>`.label {
    font-family: ${e.fontFamily};
    color: ${e.nodeTextColor || e.textColor};
  }
  .cluster-label text {
    fill: ${e.titleColor};
  }
  .cluster-label span,p {
    color: ${e.titleColor};
  }



  .label text,span,p {
    fill: ${e.nodeTextColor || e.textColor};
    color: ${e.nodeTextColor || e.textColor};
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${e.mainBkg};
    stroke: ${e.nodeBorder};
    stroke-width: 1px;
  }
  .flowchart-label text {
    text-anchor: middle;
  }
  // .flowchart-label .text-outer-tspan {
  //   text-anchor: middle;
  // }
  // .flowchart-label .text-inner-tspan {
  //   text-anchor: start;
  // }

  .node .label {
    text-align: center;
  }
  .node.clickable {
    cursor: pointer;
  }

  .arrowheadPath {
    fill: ${e.arrowheadColor};
  }

  .edgePath .path {
    stroke: ${e.lineColor};
    stroke-width: 2.0px;
  }

  .flowchart-link {
    stroke: ${e.lineColor};
    fill: none;
  }

  .edgeLabel {
    background-color: ${e.edgeLabelBackground};
    rect {
      opacity: 0.5;
      background-color: ${e.edgeLabelBackground};
      fill: ${e.edgeLabelBackground};
    }
    text-align: center;
  }

  /* For html labels only */
  .labelBkg {
    background-color: ${ot(e.edgeLabelBackground, .5)};
    // background-color:
  }

  .node .cluster {
    // fill: ${ot(e.mainBkg, .5)};
    fill: ${ot(e.clusterBkg, .5)};
    stroke: ${ot(e.clusterBorder, .2)};
    box-shadow: rgba(50, 50, 93, 0.25) 0px 13px 27px -5px, rgba(0, 0, 0, 0.3) 0px 8px 16px -8px;
    stroke-width: 1px;
  }

  .cluster text {
    fill: ${e.titleColor};
  }

  .cluster span,p {
    color: ${e.titleColor};
  }
  /* .cluster div {
    color: ${e.titleColor};
  } */

  div.mermaidTooltip {
    position: absolute;
    text-align: center;
    max-width: 200px;
    padding: 2px;
    font-family: ${e.fontFamily};
    font-size: 12px;
    background: ${e.tertiaryColor};
    border: 1px solid ${e.border2};
    border-radius: 2px;
    pointer-events: none;
    z-index: 100;
  }

  .flowchartTitleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${e.textColor};
  }
  ${o()}
`, "getStyles"), Jt = Qe;
var $e = /*#__PURE__*/ m$1((e, t, s, n)=>{
    t.forEach((i)=>{
        cr[i](e, s, n);
    });
}, "insertMarkers"), tr = /*#__PURE__*/ m$1((e, t, s)=>{
    tt.trace("Making markers for ", s), e.append("defs").append("marker").attr("id", s + "_" + t + "-extensionStart").attr("class", "marker extension " + t).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 1,7 L18,13 V 1 Z"), e.append("defs").append("marker").attr("id", s + "_" + t + "-extensionEnd").attr("class", "marker extension " + t).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 1,1 V 13 L18,7 Z");
}, "extension"), er = /*#__PURE__*/ m$1((e, t, s)=>{
    e.append("defs").append("marker").attr("id", s + "_" + t + "-compositionStart").attr("class", "marker composition " + t).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), e.append("defs").append("marker").attr("id", s + "_" + t + "-compositionEnd").attr("class", "marker composition " + t).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
}, "composition"), rr = /*#__PURE__*/ m$1((e, t, s)=>{
    e.append("defs").append("marker").attr("id", s + "_" + t + "-aggregationStart").attr("class", "marker aggregation " + t).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), e.append("defs").append("marker").attr("id", s + "_" + t + "-aggregationEnd").attr("class", "marker aggregation " + t).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
}, "aggregation"), ar = /*#__PURE__*/ m$1((e, t, s)=>{
    e.append("defs").append("marker").attr("id", s + "_" + t + "-dependencyStart").attr("class", "marker dependency " + t).attr("refX", 6).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 5,7 L9,13 L1,7 L9,1 Z"), e.append("defs").append("marker").attr("id", s + "_" + t + "-dependencyEnd").attr("class", "marker dependency " + t).attr("refX", 13).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
}, "dependency"), sr = /*#__PURE__*/ m$1((e, t, s)=>{
    e.append("defs").append("marker").attr("id", s + "_" + t + "-lollipopStart").attr("class", "marker lollipop " + t).attr("refX", 13).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6), e.append("defs").append("marker").attr("id", s + "_" + t + "-lollipopEnd").attr("class", "marker lollipop " + t).attr("refX", 1).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6);
}, "lollipop"), ir = /*#__PURE__*/ m$1((e, t, s)=>{
    e.append("marker").attr("id", s + "_" + t + "-pointEnd").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", 6).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), e.append("marker").attr("id", s + "_" + t + "-pointStart").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", 4.5).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 5 L 10 10 L 10 0 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
}, "point"), nr = /*#__PURE__*/ m$1((e, t, s)=>{
    e.append("marker").attr("id", s + "_" + t + "-circleEnd").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", 11).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), e.append("marker").attr("id", s + "_" + t + "-circleStart").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", -1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
}, "circle"), lr = /*#__PURE__*/ m$1((e, t, s)=>{
    e.append("marker").attr("id", s + "_" + t + "-crossEnd").attr("class", "marker cross " + t).attr("viewBox", "0 0 11 11").attr("refX", 12).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0"), e.append("marker").attr("id", s + "_" + t + "-crossStart").attr("class", "marker cross " + t).attr("viewBox", "0 0 11 11").attr("refX", -1).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0");
}, "cross"), or = /*#__PURE__*/ m$1((e, t, s)=>{
    e.append("defs").append("marker").attr("id", s + "_" + t + "-barbEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 14).attr("markerUnits", "strokeWidth").attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
}, "barb"), cr = {
    extension: tr,
    composition: er,
    aggregation: rr,
    dependency: ar,
    lollipop: sr,
    point: ir,
    circle: nr,
    cross: lr,
    barb: or
}, Qt = $e;
var O = hh()?.block?.padding ?? 8;
function hr(e, t) {
    if (e === 0 || !Number.isInteger(e)) throw new Error("Columns must be an integer !== 0.");
    if (t < 0 || !Number.isInteger(t)) throw new Error("Position must be a non-negative integer." + t);
    if (e < 0) return {
        px: t,
        py: 0
    };
    if (e === 1) return {
        px: 0,
        py: t
    };
    let s = t % e, n = /*#__PURE__*/ Math.floor(t / e);
    return {
        px: s,
        py: n
    };
}
m$1(hr, "calculateBlockPosition");
var gr = /*#__PURE__*/ m$1((e)=>{
    let t = 0, s = 0;
    for (let n of e.children){
        let { width: i, height: a, x: r, y: l } = n.size ?? {
            width: 0,
            height: 0,
            x: 0,
            y: 0
        };
        tt.debug("getMaxChildSize abc95 child:", n.id, "width:", i, "height:", a, "x:", r, "y:", l, n.type), n.type !== "space" && (i > t && (t = i / (e.widthInColumns ?? 1)), a > s && (s = a));
    }
    return {
        width: t,
        height: s
    };
}, "getMaxChildSize");
function Lt(e, t) {
    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    tt.debug("setBlockSizes abc95 (start)", e.id, e?.size?.x, "block width =", e?.size, "siblingWidth", s), e?.size?.width || (e.size = {
        width: s,
        height: n,
        x: 0,
        y: 0
    });
    let i = 0, a = 0;
    if (e.children?.length > 0) {
        for (let b of e.children)Lt(b, t);
        let r = /*#__PURE__*/ gr(e);
        i = r.width, a = r.height, tt.debug("setBlockSizes abc95 maxWidth of", e.id, ":s children is ", i, a);
        for (let b of e.children)b.size && (tt.debug(`abc95 Setting size of children of ${e.id} id=${b.id} ${i} ${a} ${JSON.stringify(b.size)}`), b.size.width = i * (b.widthInColumns ?? 1) + O * ((b.widthInColumns ?? 1) - 1), b.size.height = a, b.size.x = 0, b.size.y = 0, tt.debug(`abc95 updating size of ${e.id} children child:${b.id} maxWidth:${i} maxHeight:${a}`));
        for (let b of e.children)Lt(b, t, i, a);
        let l = e.columns ?? -1, o = 0;
        for (let b of e.children)o += b.widthInColumns ?? 1;
        let u = e.children.length;
        l > 0 && l < o && (u = l);
        let g = /*#__PURE__*/ Math.ceil(o / u), x = u * (i + O) + O, m = g * (a + O) + O;
        if (x < s) {
            tt.debug(`Detected to small sibling: abc95 ${e.id} siblingWidth ${s} siblingHeight ${n} width ${x}`), x = s, m = n;
            let b = (s - u * O - O) / u, L = (n - g * O - O) / g;
            tt.debug("Size indata abc88", e.id, "childWidth", b, "maxWidth", i), tt.debug("Size indata abc88", e.id, "childHeight", L, "maxHeight", a), tt.debug("Size indata abc88 xSize", u, "padding", O);
            for (let _ of e.children)_.size && (_.size.width = b, _.size.height = L, _.size.x = 0, _.size.y = 0);
        }
        if (tt.debug(`abc95 (finale calc) ${e.id} xSize ${u} ySize ${g} columns ${l}${e.children.length} width=${Math.max(x, e.size?.width || 0)}`), x < (e?.size?.width || 0)) {
            x = e?.size?.width || 0;
            let b = l > 0 ? Math.min(e.children.length, l) : e.children.length;
            if (b > 0) {
                let L = (x - b * O - O) / b;
                tt.debug("abc95 (growing to fit) width", e.id, x, e.size?.width, L);
                for (let _ of e.children)_.size && (_.size.width = L);
            }
        }
        e.size = {
            width: x,
            height: m,
            x: 0,
            y: 0
        };
    }
    tt.debug("setBlockSizes abc94 (done)", e.id, e?.size?.x, e?.size?.width, e?.size?.y, e?.size?.height);
}
m$1(Lt, "setBlockSizes");
function $t(e, t) {
    tt.debug(`abc85 layout blocks (=>layoutBlocks) ${e.id} x: ${e?.size?.x} y: ${e?.size?.y} width: ${e?.size?.width}`);
    let s = e.columns ?? -1;
    if (tt.debug("layoutBlocks columns abc95", e.id, "=>", s, e), e.children && e.children.length > 0) {
        let n = e?.children[0]?.size?.width ?? 0, i = e.children.length * n + (e.children.length - 1) * O;
        tt.debug("widthOfChildren 88", i, "posX");
        let a = 0;
        tt.debug("abc91 block?.size?.x", e.id, e?.size?.x);
        let r = e?.size?.x ? e?.size?.x + (-e?.size?.width / 2 || 0) : -O, l = 0;
        for (let o of e.children){
            let u = e;
            if (!o.size) continue;
            let { width: g, height: x } = o.size, { px: m, py: b } = hr(s, a);
            if (b != l && (l = b, r = e?.size?.x ? e?.size?.x + (-e?.size?.width / 2 || 0) : -O, tt.debug("New row in layout for block", e.id, " and child ", o.id, l)), tt.debug(`abc89 layout blocks (child) id: ${o.id} Pos: ${a} (px, py) ${m},${b} (${u?.size?.x},${u?.size?.y}) parent: ${u.id} width: ${g}${O}`), u.size) {
                let L = g / 2;
                o.size.x = r + O + L, tt.debug(`abc91 layout blocks (calc) px, pyid:${o.id} startingPos=X${r} new startingPosX${o.size.x} ${L} padding=${O} width=${g} halfWidth=${L} => x:${o.size.x} y:${o.size.y} ${o.widthInColumns} (width * (child?.w || 1)) / 2 ${g * (o?.widthInColumns ?? 1) / 2}`), r = o.size.x + L, o.size.y = u.size.y - u.size.height / 2 + b * (x + O) + x / 2 + O, tt.debug(`abc88 layout blocks (calc) px, pyid:${o.id}startingPosX${r}${O}${L}=>x:${o.size.x}y:${o.size.y}${o.widthInColumns}(width * (child?.w || 1)) / 2${g * (o?.widthInColumns ?? 1) / 2}`);
            }
            o.children && $t(o), a += o?.widthInColumns ?? 1, tt.debug("abc88 columnsPos", o, a);
        }
    }
    tt.debug(`layout blocks (<==layoutBlocks) ${e.id} x: ${e?.size?.x} y: ${e?.size?.y} width: ${e?.size?.width}`);
}
m$1($t, "layoutBlocks");
function te(e) {
    let { minX: t, minY: s, maxX: n, maxY: i } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        minX: 0,
        minY: 0,
        maxX: 0,
        maxY: 0
    };
    if (e.size && e.id !== "root") {
        let { x: a, y: r, width: l, height: o } = e.size;
        a - l / 2 < t && (t = a - l / 2), r - o / 2 < s && (s = r - o / 2), a + l / 2 > n && (n = a + l / 2), r + o / 2 > i && (i = r + o / 2);
    }
    if (e.children) for (let a of e.children)({ minX: t, minY: s, maxX: n, maxY: i } = /*#__PURE__*/ te(a, {
        minX: t,
        minY: s,
        maxX: n,
        maxY: i
    }));
    return {
        minX: t,
        minY: s,
        maxX: n,
        maxY: i
    };
}
m$1(te, "findBounds");
function ee(e) {
    let t = /*#__PURE__*/ e.getBlock("root");
    if (!t) return;
    Lt(t, e, 0, 0), $t(t), tt.debug("getBlocks", /*#__PURE__*/ JSON.stringify(t, null, 2));
    let { minX: s, minY: n, maxX: i, maxY: a } = te(t), r = a - n, l = i - s;
    return {
        x: s,
        y: n,
        width: l,
        height: r
    };
}
m$1(ee, "layout");
function re(e, t) {
    t && e.attr("style", t);
}
m$1(re, "applyStyle");
function dr(e) {
    let t = /*#__PURE__*/ kh(/*#__PURE__*/ document.createElementNS("http://www.w3.org/2000/svg", "foreignObject")), s = /*#__PURE__*/ t.append("xhtml:div"), n = e.label, i = e.isNode ? "nodeLabel" : "edgeLabel", a = /*#__PURE__*/ s.append("span");
    return a.html(n), re(a, e.labelStyle), a.attr("class", i), re(s, e.labelStyle), s.style("display", "inline-block"), s.style("white-space", "nowrap"), s.attr("xmlns", "http://www.w3.org/1999/xhtml"), t.node();
}
m$1(dr, "addHtmlLabel");
var ur = /*#__PURE__*/ m$1(async (e, t, s, n)=>{
    let i = e || "";
    if (typeof i == "object" && (i = i[0]), Rf(hh().flowchart.htmlLabels)) {
        i = /*#__PURE__*/ i.replace(/\\n|\n/g, "<br />"), tt.debug("vertexText" + i);
        let a = await Fn(/*#__PURE__*/ Xe$1(i)), r = {
            isNode: n,
            label: a,
            labelStyle: /*#__PURE__*/ t.replace("fill:", "color:")
        };
        return dr(r);
    } else {
        let a = /*#__PURE__*/ document.createElementNS("http://www.w3.org/2000/svg", "text");
        a.setAttribute("style", /*#__PURE__*/ t.replace("color:", "fill:"));
        let r = [];
        typeof i == "string" ? r = /*#__PURE__*/ i.split(/\\n|\n|<br\s*\/?>/gi) : Array.isArray(i) ? r = i : r = [];
        for (let l of r){
            let o = /*#__PURE__*/ document.createElementNS("http://www.w3.org/2000/svg", "tspan");
            o.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), o.setAttribute("dy", "1em"), o.setAttribute("x", "0"), s ? o.setAttribute("class", "title-row") : o.setAttribute("class", "row"), o.textContent = /*#__PURE__*/ l.trim(), a.appendChild(o);
        }
        return a;
    }
}, "createLabel"), W = ur;
var se = /*#__PURE__*/ m$1((e, t, s, n, i)=>{
    t.arrowTypeStart && ae(e, "start", t.arrowTypeStart, s, n, i), t.arrowTypeEnd && ae(e, "end", t.arrowTypeEnd, s, n, i);
}, "addEdgeMarkers"), pr = {
    arrow_cross: "cross",
    arrow_point: "point",
    arrow_barb: "barb",
    arrow_circle: "circle",
    aggregation: "aggregation",
    extension: "extension",
    composition: "composition",
    dependency: "dependency",
    lollipop: "lollipop"
}, ae = /*#__PURE__*/ m$1((e, t, s, n, i, a)=>{
    let r = pr[s];
    if (!r) {
        tt.warn(`Unknown arrow type: ${s}`);
        return;
    }
    let l = t === "start" ? "Start" : "End";
    e.attr(`marker-${t}`, `url(${n}#${i}_${a}-${r}${l})`);
}, "addEdgeMarker");
var St = {}, M = {};
var ne = /*#__PURE__*/ m$1(async (e, t)=>{
    let s = /*#__PURE__*/ hh(), n = /*#__PURE__*/ Rf(s.flowchart.htmlLabels), i = t.labelType === "markdown" ? Jr(e, t.label, {
        style: t.labelStyle,
        useHtmlLabels: n,
        addSvgBackground: true
    }, s) : await W(t.label, t.labelStyle), a = /*#__PURE__*/ e.insert("g").attr("class", "edgeLabel"), r = /*#__PURE__*/ a.insert("g").attr("class", "label");
    r.node().appendChild(i);
    let l = /*#__PURE__*/ i.getBBox();
    if (n) {
        let u = i.children[0], g = /*#__PURE__*/ kh(i);
        l = /*#__PURE__*/ u.getBoundingClientRect(), g.attr("width", l.width), g.attr("height", l.height);
    }
    r.attr("transform", "translate(" + -l.width / 2 + ", " + -l.height / 2 + ")"), St[t.id] = a, t.width = l.width, t.height = l.height;
    let o;
    if (t.startLabelLeft) {
        let u = await W(t.startLabelLeft, t.labelStyle), g = /*#__PURE__*/ e.insert("g").attr("class", "edgeTerminals"), x = /*#__PURE__*/ g.insert("g").attr("class", "inner");
        o = /*#__PURE__*/ x.node().appendChild(u);
        let m = /*#__PURE__*/ u.getBBox();
        x.attr("transform", "translate(" + -m.width / 2 + ", " + -m.height / 2 + ")"), M[t.id] || (M[t.id] = {}), M[t.id].startLeft = g, ct(o, t.startLabelLeft);
    }
    if (t.startLabelRight) {
        let u = await W(t.startLabelRight, t.labelStyle), g = /*#__PURE__*/ e.insert("g").attr("class", "edgeTerminals"), x = /*#__PURE__*/ g.insert("g").attr("class", "inner");
        o = /*#__PURE__*/ g.node().appendChild(u), x.node().appendChild(u);
        let m = /*#__PURE__*/ u.getBBox();
        x.attr("transform", "translate(" + -m.width / 2 + ", " + -m.height / 2 + ")"), M[t.id] || (M[t.id] = {}), M[t.id].startRight = g, ct(o, t.startLabelRight);
    }
    if (t.endLabelLeft) {
        let u = await W(t.endLabelLeft, t.labelStyle), g = /*#__PURE__*/ e.insert("g").attr("class", "edgeTerminals"), x = /*#__PURE__*/ g.insert("g").attr("class", "inner");
        o = /*#__PURE__*/ x.node().appendChild(u);
        let m = /*#__PURE__*/ u.getBBox();
        x.attr("transform", "translate(" + -m.width / 2 + ", " + -m.height / 2 + ")"), g.node().appendChild(u), M[t.id] || (M[t.id] = {}), M[t.id].endLeft = g, ct(o, t.endLabelLeft);
    }
    if (t.endLabelRight) {
        let u = await W(t.endLabelRight, t.labelStyle), g = /*#__PURE__*/ e.insert("g").attr("class", "edgeTerminals"), x = /*#__PURE__*/ g.insert("g").attr("class", "inner");
        o = /*#__PURE__*/ x.node().appendChild(u);
        let m = /*#__PURE__*/ u.getBBox();
        x.attr("transform", "translate(" + -m.width / 2 + ", " + -m.height / 2 + ")"), g.node().appendChild(u), M[t.id] || (M[t.id] = {}), M[t.id].endRight = g, ct(o, t.endLabelRight);
    }
    return i;
}, "insertEdgeLabel");
function ct(e, t) {
    hh().flowchart.htmlLabels && e && (e.style.width = t.length * 9 + "px", e.style.height = "12px");
}
m$1(ct, "setTerminalWidth");
var le = /*#__PURE__*/ m$1((e, t)=>{
    tt.debug("Moving label abc88 ", e.id, e.label, St[e.id], t);
    let s = t.updatedPath ? t.updatedPath : t.originalPath, n$1 = /*#__PURE__*/ hh(), { subGraphTitleTotalMargin: i } = n(n$1);
    if (e.label) {
        let a = St[e.id], r = e.x, l = e.y;
        if (s) {
            let o = /*#__PURE__*/ Ie$1.calcLabelPosition(s);
            tt.debug("Moving label " + e.label + " from (", r, ",", l, ") to (", o.x, ",", o.y, ") abc88"), t.updatedPath && (r = o.x, l = o.y);
        }
        a.attr("transform", `translate(${r}, ${l + i / 2})`);
    }
    if (e.startLabelLeft) {
        let a = M[e.id].startLeft, r = e.x, l = e.y;
        if (s) {
            let o = /*#__PURE__*/ Ie$1.calcTerminalLabelPosition(e.arrowTypeStart ? 10 : 0, "start_left", s);
            r = o.x, l = o.y;
        }
        a.attr("transform", `translate(${r}, ${l})`);
    }
    if (e.startLabelRight) {
        let a = M[e.id].startRight, r = e.x, l = e.y;
        if (s) {
            let o = /*#__PURE__*/ Ie$1.calcTerminalLabelPosition(e.arrowTypeStart ? 10 : 0, "start_right", s);
            r = o.x, l = o.y;
        }
        a.attr("transform", `translate(${r}, ${l})`);
    }
    if (e.endLabelLeft) {
        let a = M[e.id].endLeft, r = e.x, l = e.y;
        if (s) {
            let o = /*#__PURE__*/ Ie$1.calcTerminalLabelPosition(e.arrowTypeEnd ? 10 : 0, "end_left", s);
            r = o.x, l = o.y;
        }
        a.attr("transform", `translate(${r}, ${l})`);
    }
    if (e.endLabelRight) {
        let a = M[e.id].endRight, r = e.x, l = e.y;
        if (s) {
            let o = /*#__PURE__*/ Ie$1.calcTerminalLabelPosition(e.arrowTypeEnd ? 10 : 0, "end_right", s);
            r = o.x, l = o.y;
        }
        a.attr("transform", `translate(${r}, ${l})`);
    }
}, "positionEdgeLabel"), fr = /*#__PURE__*/ m$1((e, t)=>{
    let s = e.x, n = e.y, i = /*#__PURE__*/ Math.abs(t.x - s), a = /*#__PURE__*/ Math.abs(t.y - n), r = e.width / 2, l = e.height / 2;
    return i >= r || a >= l;
}, "outsideNode"), xr = /*#__PURE__*/ m$1((e, t, s)=>{
    tt.debug(`intersection calc abc89:
  outsidePoint: ${JSON.stringify(t)}
  insidePoint : ${JSON.stringify(s)}
  node        : x:${e.x} y:${e.y} w:${e.width} h:${e.height}`);
    let n = e.x, i = e.y, a = /*#__PURE__*/ Math.abs(n - s.x), r = e.width / 2, l = s.x < t.x ? r - a : r + a, o = e.height / 2, u = /*#__PURE__*/ Math.abs(t.y - s.y), g = /*#__PURE__*/ Math.abs(t.x - s.x);
    if (Math.abs(i - t.y) * r > Math.abs(n - t.x) * o) {
        let x = s.y < t.y ? t.y - o - i : i - o - t.y;
        l = g * x / u;
        let m = {
            x: s.x < t.x ? s.x + l : s.x - g + l,
            y: s.y < t.y ? s.y + u - x : s.y - u + x
        };
        return l === 0 && (m.x = t.x, m.y = t.y), g === 0 && (m.x = t.x), u === 0 && (m.y = t.y), tt.debug(`abc89 topp/bott calc, Q ${u}, q ${x}, R ${g}, r ${l}`, m), m;
    } else {
        s.x < t.x ? l = t.x - r - n : l = n - r - t.x;
        let x = u * l / g, m = s.x < t.x ? s.x + g - l : s.x - g + l, b = s.y < t.y ? s.y + x : s.y - x;
        return tt.debug(`sides calc abc89, Q ${u}, q ${x}, R ${g}, r ${l}`, {
            _x: m,
            _y: b
        }), l === 0 && (m = t.x, b = t.y), g === 0 && (m = t.x), u === 0 && (b = t.y), {
            x: m,
            y: b
        };
    }
}, "intersection"), ie = /*#__PURE__*/ m$1((e, t)=>{
    tt.debug("abc88 cutPathAtIntersect", e, t);
    let s = [], n = e[0], i = false;
    return e.forEach((a)=>{
        if (!fr(t, a) && !i) {
            let r = /*#__PURE__*/ xr(t, n, a), l = false;
            s.forEach((o)=>{
                l = l || o.x === r.x && o.y === r.y;
            }), s.some((o)=>o.x === r.x && o.y === r.y) || s.push(r), i = true;
        } else n = a, i || s.push(a);
    }), s;
}, "cutPathAtIntersect"), oe = /*#__PURE__*/ m$1(function(e, t, s, n, i, a, r) {
    let l = s.points;
    tt.debug("abc88 InsertEdge: edge=", s, "e=", t);
    let o = false, u = /*#__PURE__*/ a.node(t.v);
    var g = /*#__PURE__*/ a.node(t.w);
    g?.intersect && u?.intersect && (l = /*#__PURE__*/ l.slice(1, s.points.length - 1), l.unshift(/*#__PURE__*/ u.intersect(l[0])), l.push(/*#__PURE__*/ g.intersect(l[l.length - 1]))), s.toCluster && (tt.debug("to cluster abc88", n[s.toCluster]), l = /*#__PURE__*/ ie(s.points, n[s.toCluster].node), o = true), s.fromCluster && (tt.debug("from cluster abc88", n[s.fromCluster]), l = /*#__PURE__*/ ie(/*#__PURE__*/ l.reverse(), n[s.fromCluster].node).reverse(), o = true);
    let x = /*#__PURE__*/ l.filter((y)=>!Number.isNaN(y.y)), m = Zc;
    s.curve && (i === "graph" || i === "flowchart") && (m = s.curve);
    let { x: b, y: L } = d(s), _ = /*#__PURE__*/ Xc().x(b).y(L).curve(m), S;
    switch(s.thickness){
        case "normal":
            S = "edge-thickness-normal";
            break;
        case "thick":
            S = "edge-thickness-thick";
            break;
        case "invisible":
            S = "edge-thickness-thick";
            break;
        default:
            S = "";
    }
    switch(s.pattern){
        case "solid":
            S += " edge-pattern-solid";
            break;
        case "dotted":
            S += " edge-pattern-dotted";
            break;
        case "dashed":
            S += " edge-pattern-dashed";
            break;
    }
    let I = /*#__PURE__*/ e.append("path").attr("d", /*#__PURE__*/ _(x)).attr("id", s.id).attr("class", " " + S + (s.classes ? " " + s.classes : "")).attr("style", s.style), D = "";
    (hh().flowchart.arrowMarkerAbsolute || hh().state.arrowMarkerAbsolute) && (D = /*#__PURE__*/ zf(true)), se(I, s, D, r, i);
    let T = {};
    return o && (T.updatedPath = l), T.originalPath = s.points, T;
}, "insertEdge");
var br = /*#__PURE__*/ m$1((e)=>{
    let t = new Set;
    for (let s of e)switch(s){
        case "x":
            t.add("right"), t.add("left");
            break;
        case "y":
            t.add("up"), t.add("down");
            break;
        default:
            t.add(s);
            break;
    }
    return t;
}, "expandAndDeduplicateDirections"), ce = /*#__PURE__*/ m$1((e, t, s)=>{
    let n = /*#__PURE__*/ br(e), i = 2, a = t.height + 2 * s.padding, r = a / i, l = t.width + 2 * r + s.padding, o = s.padding / 2;
    return n.has("right") && n.has("left") && n.has("up") && n.has("down") ? [
        {
            x: 0,
            y: 0
        },
        {
            x: r,
            y: 0
        },
        {
            x: l / 2,
            y: 2 * o
        },
        {
            x: l - r,
            y: 0
        },
        {
            x: l,
            y: 0
        },
        {
            x: l,
            y: -a / 3
        },
        {
            x: l + 2 * o,
            y: -a / 2
        },
        {
            x: l,
            y: -2 * a / 3
        },
        {
            x: l,
            y: -a
        },
        {
            x: l - r,
            y: -a
        },
        {
            x: l / 2,
            y: -a - 2 * o
        },
        {
            x: r,
            y: -a
        },
        {
            x: 0,
            y: -a
        },
        {
            x: 0,
            y: -2 * a / 3
        },
        {
            x: -2 * o,
            y: -a / 2
        },
        {
            x: 0,
            y: -a / 3
        }
    ] : n.has("right") && n.has("left") && n.has("up") ? [
        {
            x: r,
            y: 0
        },
        {
            x: l - r,
            y: 0
        },
        {
            x: l,
            y: -a / 2
        },
        {
            x: l - r,
            y: -a
        },
        {
            x: r,
            y: -a
        },
        {
            x: 0,
            y: -a / 2
        }
    ] : n.has("right") && n.has("left") && n.has("down") ? [
        {
            x: 0,
            y: 0
        },
        {
            x: r,
            y: -a
        },
        {
            x: l - r,
            y: -a
        },
        {
            x: l,
            y: 0
        }
    ] : n.has("right") && n.has("up") && n.has("down") ? [
        {
            x: 0,
            y: 0
        },
        {
            x: l,
            y: -r
        },
        {
            x: l,
            y: -a + r
        },
        {
            x: 0,
            y: -a
        }
    ] : n.has("left") && n.has("up") && n.has("down") ? [
        {
            x: l,
            y: 0
        },
        {
            x: 0,
            y: -r
        },
        {
            x: 0,
            y: -a + r
        },
        {
            x: l,
            y: -a
        }
    ] : n.has("right") && n.has("left") ? [
        {
            x: r,
            y: 0
        },
        {
            x: r,
            y: -o
        },
        {
            x: l - r,
            y: -o
        },
        {
            x: l - r,
            y: 0
        },
        {
            x: l,
            y: -a / 2
        },
        {
            x: l - r,
            y: -a
        },
        {
            x: l - r,
            y: -a + o
        },
        {
            x: r,
            y: -a + o
        },
        {
            x: r,
            y: -a
        },
        {
            x: 0,
            y: -a / 2
        }
    ] : n.has("up") && n.has("down") ? [
        {
            x: l / 2,
            y: 0
        },
        {
            x: 0,
            y: -o
        },
        {
            x: r,
            y: -o
        },
        {
            x: r,
            y: -a + o
        },
        {
            x: 0,
            y: -a + o
        },
        {
            x: l / 2,
            y: -a
        },
        {
            x: l,
            y: -a + o
        },
        {
            x: l - r,
            y: -a + o
        },
        {
            x: l - r,
            y: -o
        },
        {
            x: l,
            y: -o
        }
    ] : n.has("right") && n.has("up") ? [
        {
            x: 0,
            y: 0
        },
        {
            x: l,
            y: -r
        },
        {
            x: 0,
            y: -a
        }
    ] : n.has("right") && n.has("down") ? [
        {
            x: 0,
            y: 0
        },
        {
            x: l,
            y: 0
        },
        {
            x: 0,
            y: -a
        }
    ] : n.has("left") && n.has("up") ? [
        {
            x: l,
            y: 0
        },
        {
            x: 0,
            y: -r
        },
        {
            x: l,
            y: -a
        }
    ] : n.has("left") && n.has("down") ? [
        {
            x: l,
            y: 0
        },
        {
            x: 0,
            y: 0
        },
        {
            x: l,
            y: -a
        }
    ] : n.has("right") ? [
        {
            x: r,
            y: -o
        },
        {
            x: r,
            y: -o
        },
        {
            x: l - r,
            y: -o
        },
        {
            x: l - r,
            y: 0
        },
        {
            x: l,
            y: -a / 2
        },
        {
            x: l - r,
            y: -a
        },
        {
            x: l - r,
            y: -a + o
        },
        {
            x: r,
            y: -a + o
        },
        {
            x: r,
            y: -a + o
        }
    ] : n.has("left") ? [
        {
            x: r,
            y: 0
        },
        {
            x: r,
            y: -o
        },
        {
            x: l - r,
            y: -o
        },
        {
            x: l - r,
            y: -a + o
        },
        {
            x: r,
            y: -a + o
        },
        {
            x: r,
            y: -a
        },
        {
            x: 0,
            y: -a / 2
        }
    ] : n.has("up") ? [
        {
            x: r,
            y: -o
        },
        {
            x: r,
            y: -a + o
        },
        {
            x: 0,
            y: -a + o
        },
        {
            x: l / 2,
            y: -a
        },
        {
            x: l,
            y: -a + o
        },
        {
            x: l - r,
            y: -a + o
        },
        {
            x: l - r,
            y: -o
        }
    ] : n.has("down") ? [
        {
            x: l / 2,
            y: 0
        },
        {
            x: 0,
            y: -o
        },
        {
            x: r,
            y: -o
        },
        {
            x: r,
            y: -a + o
        },
        {
            x: l - r,
            y: -a + o
        },
        {
            x: l - r,
            y: -o
        },
        {
            x: l,
            y: -o
        }
    ] : [
        {
            x: 0,
            y: 0
        }
    ];
}, "getArrowPoints");
function yr(e, t) {
    return e.intersect(t);
}
m$1(yr, "intersectNode");
var he = yr;
function mr(e, t, s, n) {
    var i = e.x, a = e.y, r = i - n.x, l = a - n.y, o = /*#__PURE__*/ Math.sqrt(t * t * l * l + s * s * r * r), u = /*#__PURE__*/ Math.abs(t * s * r / o);
    n.x < i && (u = -u);
    var g = /*#__PURE__*/ Math.abs(t * s * l / o);
    return n.y < a && (g = -g), {
        x: i + u,
        y: a + g
    };
}
m$1(mr, "intersectEllipse");
var ht = mr;
function kr(e, t, s) {
    return ht(e, t, t, s);
}
m$1(kr, "intersectCircle");
var ge = kr;
function wr(e, t, s, n) {
    var i, a, r, l, o, u, g, x, m, b, L, _, S, I, D;
    if (i = t.y - e.y, r = e.x - t.x, o = t.x * e.y - e.x * t.y, m = i * s.x + r * s.y + o, b = i * n.x + r * n.y + o, !(m !== 0 && b !== 0 && de(m, b)) && (a = n.y - s.y, l = s.x - n.x, u = n.x * s.y - s.x * n.y, g = a * e.x + l * e.y + u, x = a * t.x + l * t.y + u, !(g !== 0 && x !== 0 && de(g, x)) && (L = i * l - a * r, L !== 0))) return _ = /*#__PURE__*/ Math.abs(L / 2), S = r * u - l * o, I = S < 0 ? (S - _) / L : (S + _) / L, S = a * o - i * u, D = S < 0 ? (S - _) / L : (S + _) / L, {
        x: I,
        y: D
    };
}
m$1(wr, "intersectLine");
function de(e, t) {
    return e * t > 0;
}
m$1(de, "sameSign");
var ue = wr;
var pe = Lr;
function Lr(e, t, s) {
    var n = e.x, i = e.y, a = [], r = Number.POSITIVE_INFINITY, l = Number.POSITIVE_INFINITY;
    typeof t.forEach == "function" ? t.forEach(function(L) {
        r = /*#__PURE__*/ Math.min(r, L.x), l = /*#__PURE__*/ Math.min(l, L.y);
    }) : (r = /*#__PURE__*/ Math.min(r, t.x), l = /*#__PURE__*/ Math.min(l, t.y));
    for(var o = n - e.width / 2 - r, u = i - e.height / 2 - l, g = 0; g < t.length; g++){
        var x = t[g], m = t[g < t.length - 1 ? g + 1 : 0], b = /*#__PURE__*/ ue(e, s, {
            x: o + x.x,
            y: u + x.y
        }, {
            x: o + m.x,
            y: u + m.y
        });
        b && a.push(b);
    }
    return a.length ? (a.length > 1 && a.sort(function(L, _) {
        var S = L.x - s.x, I = L.y - s.y, D = /*#__PURE__*/ Math.sqrt(S * S + I * I), T = _.x - s.x, y = _.y - s.y, d = /*#__PURE__*/ Math.sqrt(T * T + y * y);
        return D < d ? -1 : D === d ? 0 : 1;
    }), a[0]) : e;
}
m$1(Lr, "intersectPolygon");
var Sr = /*#__PURE__*/ m$1((e, t)=>{
    var s = e.x, n = e.y, i = t.x - s, a = t.y - n, r = e.width / 2, l = e.height / 2, o, u;
    return Math.abs(a) * r > Math.abs(i) * l ? (a < 0 && (l = -l), o = a === 0 ? 0 : l * i / a, u = l) : (i < 0 && (r = -r), o = r, u = i === 0 ? 0 : r * a / i), {
        x: s + o,
        y: n + u
    };
}, "intersectRect"), fe = Sr;
var v = {
    node: he,
    circle: ge,
    ellipse: ht,
    polygon: pe,
    rect: fe
};
var A = /*#__PURE__*/ m$1(async (e, t, s, n)=>{
    let i = /*#__PURE__*/ hh(), a, r = t.useHtmlLabels || Rf(i.flowchart.htmlLabels);
    s ? a = s : a = "node default";
    let l = /*#__PURE__*/ e.insert("g").attr("class", a).attr("id", t.domId || t.id), o = /*#__PURE__*/ l.insert("g").attr("class", "label").attr("style", t.labelStyle), u;
    t.labelText === void 0 ? u = "" : u = typeof t.labelText == "string" ? t.labelText : t.labelText[0];
    let g = /*#__PURE__*/ o.node(), x;
    t.labelType === "markdown" ? x = /*#__PURE__*/ Jr(o, /*#__PURE__*/ De$1(/*#__PURE__*/ Xe$1(u), i), {
        useHtmlLabels: r,
        width: t.width || i.flowchart.wrappingWidth,
        classes: "markdown-node-label"
    }, i) : x = /*#__PURE__*/ g.appendChild(await W(/*#__PURE__*/ De$1(/*#__PURE__*/ Xe$1(u), i), t.labelStyle, false, n));
    let m = /*#__PURE__*/ x.getBBox(), b = t.padding / 2;
    if (Rf(i.flowchart.htmlLabels)) {
        let L = x.children[0], _ = /*#__PURE__*/ kh(x), S = /*#__PURE__*/ L.getElementsByTagName("img");
        if (S) {
            let I = u.replace(/<img[^>]*>/g, "").trim() === "";
            await Promise.all(/*#__PURE__*/ [
                ...S
            ].map((D)=>new Promise((T)=>{
                    function y() {
                        if (D.style.display = "flex", D.style.flexDirection = "column", I) {
                            let d = i.fontSize ? i.fontSize : window.getComputedStyle(document.body).fontSize, w = parseInt(d, 10) * 5 + "px";
                            D.style.minWidth = w, D.style.maxWidth = w;
                        } else D.style.width = "100%";
                        T(D);
                    }
                    m$1(y, "setupImage"), setTimeout(()=>{
                        D.complete && y();
                    }), D.addEventListener("error", y), D.addEventListener("load", y);
                })));
        }
        m = /*#__PURE__*/ L.getBoundingClientRect(), _.attr("width", m.width), _.attr("height", m.height);
    }
    return r ? o.attr("transform", "translate(" + -m.width / 2 + ", " + -m.height / 2 + ")") : o.attr("transform", "translate(0, " + -m.height / 2 + ")"), t.centerLabel && o.attr("transform", "translate(" + -m.width / 2 + ", " + -m.height / 2 + ")"), o.insert("rect", ":first-child"), {
        shapeSvg: l,
        bbox: m,
        halfPadding: b,
        label: o
    };
}, "labelHelper"), N = /*#__PURE__*/ m$1((e, t)=>{
    let s = /*#__PURE__*/ t.node().getBBox();
    e.width = s.width, e.height = s.height;
}, "updateNodeBounds");
function U(e, t, s, n) {
    return e.insert("polygon", ":first-child").attr("points", /*#__PURE__*/ n.map(function(i) {
        return i.x + "," + i.y;
    }).join(" ")).attr("class", "label-container").attr("transform", "translate(" + -t / 2 + "," + s / 2 + ")");
}
m$1(U, "insertPolygonShape");
var Er = /*#__PURE__*/ m$1(async (e, t)=>{
    t.useHtmlLabels || hh().flowchart.htmlLabels || (t.centerLabel = true);
    let { shapeSvg: n, bbox: i, halfPadding: a } = await A(e, t, "node " + t.classes, true);
    tt.info("Classes = ", t.classes);
    let r = /*#__PURE__*/ n.insert("rect", ":first-child");
    return r.attr("rx", t.rx).attr("ry", t.ry).attr("x", -i.width / 2 - a).attr("y", -i.height / 2 - a).attr("width", i.width + t.padding).attr("height", i.height + t.padding), N(t, r), t.intersect = function(l) {
        return v.rect(t, l);
    }, n;
}, "note"), xe = Er;
var be = /*#__PURE__*/ m$1((e)=>e ? " " + e : "", "formatClass"), j = /*#__PURE__*/ m$1((e, t)=>`${t || "node default"}${be(e.classes)} ${be(e.class)}`, "getClassesFromNode"), ye = /*#__PURE__*/ m$1(async (e, t)=>{
    let { shapeSvg: s, bbox: n } = await A(e, t, /*#__PURE__*/ j(t, void 0), true), i = n.width + t.padding, a = n.height + t.padding, r = i + a, l = [
        {
            x: r / 2,
            y: 0
        },
        {
            x: r,
            y: -r / 2
        },
        {
            x: r / 2,
            y: -r
        },
        {
            x: 0,
            y: -r / 2
        }
    ];
    tt.info("Question main (Circle)");
    let o = /*#__PURE__*/ U(s, r, r, l);
    return o.attr("style", t.style), N(t, o), t.intersect = function(u) {
        return tt.warn("Intersect called"), v.polygon(t, l, u);
    }, s;
}, "question"), _r = /*#__PURE__*/ m$1((e, t)=>{
    let s = /*#__PURE__*/ e.insert("g").attr("class", "node default").attr("id", t.domId || t.id), n = 28, i = [
        {
            x: 0,
            y: n / 2
        },
        {
            x: n / 2,
            y: 0
        },
        {
            x: 0,
            y: -n / 2
        },
        {
            x: -n / 2,
            y: 0
        }
    ];
    return s.insert("polygon", ":first-child").attr("points", /*#__PURE__*/ i.map(function(r) {
        return r.x + "," + r.y;
    }).join(" ")).attr("class", "state-start").attr("r", 7).attr("width", 28).attr("height", 28), t.width = 28, t.height = 28, t.intersect = function(r) {
        return v.circle(t, 14, r);
    }, s;
}, "choice"), Dr = /*#__PURE__*/ m$1(async (e, t)=>{
    let { shapeSvg: s, bbox: n } = await A(e, t, /*#__PURE__*/ j(t, void 0), true), i = 4, a = n.height + t.padding, r = a / i, l = n.width + 2 * r + t.padding, o = [
        {
            x: r,
            y: 0
        },
        {
            x: l - r,
            y: 0
        },
        {
            x: l,
            y: -a / 2
        },
        {
            x: l - r,
            y: -a
        },
        {
            x: r,
            y: -a
        },
        {
            x: 0,
            y: -a / 2
        }
    ], u = /*#__PURE__*/ U(s, l, a, o);
    return u.attr("style", t.style), N(t, u), t.intersect = function(g) {
        return v.polygon(t, o, g);
    }, s;
}, "hexagon"), Br = /*#__PURE__*/ m$1(async (e, t)=>{
    let { shapeSvg: s, bbox: n } = await A(e, t, void 0, true), i = 2, a = n.height + 2 * t.padding, r = a / i, l = n.width + 2 * r + t.padding, o = /*#__PURE__*/ ce(t.directions, n, t), u = /*#__PURE__*/ U(s, l, a, o);
    return u.attr("style", t.style), N(t, u), t.intersect = function(g) {
        return v.polygon(t, o, g);
    }, s;
}, "block_arrow"), vr = /*#__PURE__*/ m$1(async (e, t)=>{
    let { shapeSvg: s, bbox: n } = await A(e, t, /*#__PURE__*/ j(t, void 0), true), i = n.width + t.padding, a = n.height + t.padding, r = [
        {
            x: -a / 2,
            y: 0
        },
        {
            x: i,
            y: 0
        },
        {
            x: i,
            y: -a
        },
        {
            x: -a / 2,
            y: -a
        },
        {
            x: 0,
            y: -a / 2
        }
    ];
    return U(s, i, a, r).attr("style", t.style), t.width = i + a, t.height = a, t.intersect = function(o) {
        return v.polygon(t, r, o);
    }, s;
}, "rect_left_inv_arrow"), Tr = /*#__PURE__*/ m$1(async (e, t)=>{
    let { shapeSvg: s, bbox: n } = await A(e, t, /*#__PURE__*/ j(t), true), i = n.width + t.padding, a = n.height + t.padding, r = [
        {
            x: -2 * a / 6,
            y: 0
        },
        {
            x: i - a / 6,
            y: 0
        },
        {
            x: i + 2 * a / 6,
            y: -a
        },
        {
            x: a / 6,
            y: -a
        }
    ], l = /*#__PURE__*/ U(s, i, a, r);
    return l.attr("style", t.style), N(t, l), t.intersect = function(o) {
        return v.polygon(t, r, o);
    }, s;
}, "lean_right"), Cr = /*#__PURE__*/ m$1(async (e, t)=>{
    let { shapeSvg: s, bbox: n } = await A(e, t, /*#__PURE__*/ j(t, void 0), true), i = n.width + t.padding, a = n.height + t.padding, r = [
        {
            x: 2 * a / 6,
            y: 0
        },
        {
            x: i + a / 6,
            y: 0
        },
        {
            x: i - 2 * a / 6,
            y: -a
        },
        {
            x: -a / 6,
            y: -a
        }
    ], l = /*#__PURE__*/ U(s, i, a, r);
    return l.attr("style", t.style), N(t, l), t.intersect = function(o) {
        return v.polygon(t, r, o);
    }, s;
}, "lean_left"), Nr = /*#__PURE__*/ m$1(async (e, t)=>{
    let { shapeSvg: s, bbox: n } = await A(e, t, /*#__PURE__*/ j(t, void 0), true), i = n.width + t.padding, a = n.height + t.padding, r = [
        {
            x: -2 * a / 6,
            y: 0
        },
        {
            x: i + 2 * a / 6,
            y: 0
        },
        {
            x: i - a / 6,
            y: -a
        },
        {
            x: a / 6,
            y: -a
        }
    ], l = /*#__PURE__*/ U(s, i, a, r);
    return l.attr("style", t.style), N(t, l), t.intersect = function(o) {
        return v.polygon(t, r, o);
    }, s;
}, "trapezoid"), Ir = /*#__PURE__*/ m$1(async (e, t)=>{
    let { shapeSvg: s, bbox: n } = await A(e, t, /*#__PURE__*/ j(t, void 0), true), i = n.width + t.padding, a = n.height + t.padding, r = [
        {
            x: a / 6,
            y: 0
        },
        {
            x: i - a / 6,
            y: 0
        },
        {
            x: i + 2 * a / 6,
            y: -a
        },
        {
            x: -2 * a / 6,
            y: -a
        }
    ], l = /*#__PURE__*/ U(s, i, a, r);
    return l.attr("style", t.style), N(t, l), t.intersect = function(o) {
        return v.polygon(t, r, o);
    }, s;
}, "inv_trapezoid"), Or = /*#__PURE__*/ m$1(async (e, t)=>{
    let { shapeSvg: s, bbox: n } = await A(e, t, /*#__PURE__*/ j(t, void 0), true), i = n.width + t.padding, a = n.height + t.padding, r = [
        {
            x: 0,
            y: 0
        },
        {
            x: i + a / 2,
            y: 0
        },
        {
            x: i,
            y: -a / 2
        },
        {
            x: i + a / 2,
            y: -a
        },
        {
            x: 0,
            y: -a
        }
    ], l = /*#__PURE__*/ U(s, i, a, r);
    return l.attr("style", t.style), N(t, l), t.intersect = function(o) {
        return v.polygon(t, r, o);
    }, s;
}, "rect_right_inv_arrow"), Rr = /*#__PURE__*/ m$1(async (e, t)=>{
    let { shapeSvg: s, bbox: n } = await A(e, t, /*#__PURE__*/ j(t, void 0), true), i = n.width + t.padding, a = i / 2, r = a / (2.5 + i / 50), l = n.height + r + t.padding, o = "M 0," + r + " a " + a + "," + r + " 0,0,0 " + i + " 0 a " + a + "," + r + " 0,0,0 " + -i + " 0 l 0," + l + " a " + a + "," + r + " 0,0,0 " + i + " 0 l 0," + -l, u = /*#__PURE__*/ s.attr("label-offset-y", r).insert("path", ":first-child").attr("style", t.style).attr("d", o).attr("transform", "translate(" + -i / 2 + "," + -(l / 2 + r) + ")");
    return N(t, u), t.intersect = function(g) {
        let x = /*#__PURE__*/ v.rect(t, g), m = x.x - t.x;
        if (a != 0 && (Math.abs(m) < t.width / 2 || Math.abs(m) == t.width / 2 && Math.abs(x.y - t.y) > t.height / 2 - r)) {
            let b = r * r * (1 - m * m / (a * a));
            b != 0 && (b = /*#__PURE__*/ Math.sqrt(b)), b = r - b, g.y - t.y > 0 && (b = -b), x.y += b;
        }
        return x;
    }, s;
}, "cylinder"), Ar = /*#__PURE__*/ m$1(async (e, t)=>{
    let { shapeSvg: s, bbox: n, halfPadding: i } = await A(e, t, "node " + t.classes + " " + t.class, true), a = /*#__PURE__*/ s.insert("rect", ":first-child"), r = t.positioned ? t.width : n.width + t.padding, l = t.positioned ? t.height : n.height + t.padding, o = t.positioned ? -r / 2 : -n.width / 2 - i, u = t.positioned ? -l / 2 : -n.height / 2 - i;
    if (a.attr("class", "basic label-container").attr("style", t.style).attr("rx", t.rx).attr("ry", t.ry).attr("x", o).attr("y", u).attr("width", r).attr("height", l), t.props) {
        let g = new Set(Object.keys(t.props));
        t.props.borders && (Et(a, t.props.borders, r, l), g.delete("borders")), g.forEach((x)=>{
            tt.warn(`Unknown node property ${x}`);
        });
    }
    return N(t, a), t.intersect = function(g) {
        return v.rect(t, g);
    }, s;
}, "rect"), zr = /*#__PURE__*/ m$1(async (e, t)=>{
    let { shapeSvg: s, bbox: n, halfPadding: i } = await A(e, t, "node " + t.classes, true), a = /*#__PURE__*/ s.insert("rect", ":first-child"), r = t.positioned ? t.width : n.width + t.padding, l = t.positioned ? t.height : n.height + t.padding, o = t.positioned ? -r / 2 : -n.width / 2 - i, u = t.positioned ? -l / 2 : -n.height / 2 - i;
    if (a.attr("class", "basic cluster composite label-container").attr("style", t.style).attr("rx", t.rx).attr("ry", t.ry).attr("x", o).attr("y", u).attr("width", r).attr("height", l), t.props) {
        let g = new Set(Object.keys(t.props));
        t.props.borders && (Et(a, t.props.borders, r, l), g.delete("borders")), g.forEach((x)=>{
            tt.warn(`Unknown node property ${x}`);
        });
    }
    return N(t, a), t.intersect = function(g) {
        return v.rect(t, g);
    }, s;
}, "composite"), Mr = /*#__PURE__*/ m$1(async (e, t)=>{
    let { shapeSvg: s } = await A(e, t, "label", true);
    tt.trace("Classes = ", t.class);
    let n = /*#__PURE__*/ s.insert("rect", ":first-child"), i = 0, a = 0;
    if (n.attr("width", i).attr("height", a), s.attr("class", "label edgeLabel"), t.props) {
        let r = new Set(Object.keys(t.props));
        t.props.borders && (Et(n, t.props.borders, i, a), r.delete("borders")), r.forEach((l)=>{
            tt.warn(`Unknown node property ${l}`);
        });
    }
    return N(t, n), t.intersect = function(r) {
        return v.rect(t, r);
    }, s;
}, "labelRect");
function Et(e, t, s, n) {
    let i = [], a = /*#__PURE__*/ m$1((l)=>{
        i.push(l, 0);
    }, "addBorder"), r = /*#__PURE__*/ m$1((l)=>{
        i.push(0, l);
    }, "skipBorder");
    t.includes("t") ? (tt.debug("add top border"), a(s)) : r(s), t.includes("r") ? (tt.debug("add right border"), a(n)) : r(n), t.includes("b") ? (tt.debug("add bottom border"), a(s)) : r(s), t.includes("l") ? (tt.debug("add left border"), a(n)) : r(n), e.attr("stroke-dasharray", /*#__PURE__*/ i.join(" "));
}
m$1(Et, "applyNodePropertyBorders");
var Fr = /*#__PURE__*/ m$1(async (e, t)=>{
    let s;
    t.classes ? s = "node " + t.classes : s = "node default";
    let n = /*#__PURE__*/ e.insert("g").attr("class", s).attr("id", t.domId || t.id), i = /*#__PURE__*/ n.insert("rect", ":first-child"), a = /*#__PURE__*/ n.insert("line"), r = /*#__PURE__*/ n.insert("g").attr("class", "label"), l = t.labelText.flat ? t.labelText.flat() : t.labelText, o = "";
    typeof l == "object" ? o = l[0] : o = l, tt.info("Label text abc79", o, l, typeof l == "object");
    let u = /*#__PURE__*/ r.node().appendChild(await W(o, t.labelStyle, true, true)), g = {
        width: 0,
        height: 0
    };
    if (Rf(hh().flowchart.htmlLabels)) {
        let _ = u.children[0], S = /*#__PURE__*/ kh(u);
        g = /*#__PURE__*/ _.getBoundingClientRect(), S.attr("width", g.width), S.attr("height", g.height);
    }
    tt.info("Text 2", l);
    let x = /*#__PURE__*/ l.slice(1, l.length), m = /*#__PURE__*/ u.getBBox(), b = /*#__PURE__*/ r.node().appendChild(await W(x.join ? x.join("<br/>") : x, t.labelStyle, true, true));
    if (Rf(hh().flowchart.htmlLabels)) {
        let _ = b.children[0], S = /*#__PURE__*/ kh(b);
        g = /*#__PURE__*/ _.getBoundingClientRect(), S.attr("width", g.width), S.attr("height", g.height);
    }
    let L = t.padding / 2;
    return kh(b).attr("transform", "translate( " + (g.width > m.width ? 0 : (m.width - g.width) / 2) + ", " + (m.height + L + 5) + ")"), kh(u).attr("transform", "translate( " + (g.width < m.width ? 0 : -(m.width - g.width) / 2) + ", 0)"), g = /*#__PURE__*/ r.node().getBBox(), r.attr("transform", "translate(" + -g.width / 2 + ", " + (-g.height / 2 - L + 3) + ")"), i.attr("class", "outer title-state").attr("x", -g.width / 2 - L).attr("y", -g.height / 2 - L).attr("width", g.width + t.padding).attr("height", g.height + t.padding), a.attr("class", "divider").attr("x1", -g.width / 2 - L).attr("x2", g.width / 2 + L).attr("y1", -g.height / 2 - L + m.height + L).attr("y2", -g.height / 2 - L + m.height + L), N(t, i), t.intersect = function(_) {
        return v.rect(t, _);
    }, n;
}, "rectWithTitle"), Wr = /*#__PURE__*/ m$1(async (e, t)=>{
    let { shapeSvg: s, bbox: n } = await A(e, t, /*#__PURE__*/ j(t, void 0), true), i = n.height + t.padding, a = n.width + i / 4 + t.padding, r = /*#__PURE__*/ s.insert("rect", ":first-child").attr("style", t.style).attr("rx", i / 2).attr("ry", i / 2).attr("x", -a / 2).attr("y", -i / 2).attr("width", a).attr("height", i);
    return N(t, r), t.intersect = function(l) {
        return v.rect(t, l);
    }, s;
}, "stadium"), Pr = /*#__PURE__*/ m$1(async (e, t)=>{
    let { shapeSvg: s, bbox: n, halfPadding: i } = await A(e, t, /*#__PURE__*/ j(t, void 0), true), a = /*#__PURE__*/ s.insert("circle", ":first-child");
    return a.attr("style", t.style).attr("rx", t.rx).attr("ry", t.ry).attr("r", n.width / 2 + i).attr("width", n.width + t.padding).attr("height", n.height + t.padding), tt.info("Circle main"), N(t, a), t.intersect = function(r) {
        return tt.info("Circle intersect", t, n.width / 2 + i, r), v.circle(t, n.width / 2 + i, r);
    }, s;
}, "circle"), Yr = /*#__PURE__*/ m$1(async (e, t)=>{
    let { shapeSvg: s, bbox: n, halfPadding: i } = await A(e, t, /*#__PURE__*/ j(t, void 0), true), a = 5, r = /*#__PURE__*/ s.insert("g", ":first-child"), l = /*#__PURE__*/ r.insert("circle"), o = /*#__PURE__*/ r.insert("circle");
    return r.attr("class", t.class), l.attr("style", t.style).attr("rx", t.rx).attr("ry", t.ry).attr("r", n.width / 2 + i + a).attr("width", n.width + t.padding + a * 2).attr("height", n.height + t.padding + a * 2), o.attr("style", t.style).attr("rx", t.rx).attr("ry", t.ry).attr("r", n.width / 2 + i).attr("width", n.width + t.padding).attr("height", n.height + t.padding), tt.info("DoubleCircle main"), N(t, l), t.intersect = function(u) {
        return tt.info("DoubleCircle intersect", t, n.width / 2 + i + a, u), v.circle(t, n.width / 2 + i + a, u);
    }, s;
}, "doublecircle"), Hr = /*#__PURE__*/ m$1(async (e, t)=>{
    let { shapeSvg: s, bbox: n } = await A(e, t, /*#__PURE__*/ j(t, void 0), true), i = n.width + t.padding, a = n.height + t.padding, r = [
        {
            x: 0,
            y: 0
        },
        {
            x: i,
            y: 0
        },
        {
            x: i,
            y: -a
        },
        {
            x: 0,
            y: -a
        },
        {
            x: 0,
            y: 0
        },
        {
            x: -8,
            y: 0
        },
        {
            x: i + 8,
            y: 0
        },
        {
            x: i + 8,
            y: -a
        },
        {
            x: -8,
            y: -a
        },
        {
            x: -8,
            y: 0
        }
    ], l = /*#__PURE__*/ U(s, i, a, r);
    return l.attr("style", t.style), N(t, l), t.intersect = function(o) {
        return v.polygon(t, r, o);
    }, s;
}, "subroutine"), jr = /*#__PURE__*/ m$1((e, t)=>{
    let s = /*#__PURE__*/ e.insert("g").attr("class", "node default").attr("id", t.domId || t.id), n = /*#__PURE__*/ s.insert("circle", ":first-child");
    return n.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14), N(t, n), t.intersect = function(i) {
        return v.circle(t, 7, i);
    }, s;
}, "start"), me = /*#__PURE__*/ m$1((e, t, s)=>{
    let n = /*#__PURE__*/ e.insert("g").attr("class", "node default").attr("id", t.domId || t.id), i = 70, a = 10;
    s === "LR" && (i = 10, a = 70);
    let r = /*#__PURE__*/ n.append("rect").attr("x", -1 * i / 2).attr("y", -1 * a / 2).attr("width", i).attr("height", a).attr("class", "fork-join");
    return N(t, r), t.height = t.height + t.padding / 2, t.width = t.width + t.padding / 2, t.intersect = function(l) {
        return v.rect(t, l);
    }, n;
}, "forkJoin"), Kr = /*#__PURE__*/ m$1((e, t)=>{
    let s = /*#__PURE__*/ e.insert("g").attr("class", "node default").attr("id", t.domId || t.id), n = /*#__PURE__*/ s.insert("circle", ":first-child"), i = /*#__PURE__*/ s.insert("circle", ":first-child");
    return i.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14), n.attr("class", "state-end").attr("r", 5).attr("width", 10).attr("height", 10), N(t, i), t.intersect = function(a) {
        return v.circle(t, 7, a);
    }, s;
}, "end"), Xr = /*#__PURE__*/ m$1(async (e, t)=>{
    let s = t.padding / 2, n = 4, i = 8, a;
    t.classes ? a = "node " + t.classes : a = "node default";
    let r = /*#__PURE__*/ e.insert("g").attr("class", a).attr("id", t.domId || t.id), l = /*#__PURE__*/ r.insert("rect", ":first-child"), o = /*#__PURE__*/ r.insert("line"), u = /*#__PURE__*/ r.insert("line"), g = 0, x = n, m = /*#__PURE__*/ r.insert("g").attr("class", "label"), b = 0, L = t.classData.annotations?.[0], _ = t.classData.annotations[0] ? "\xAB" + t.classData.annotations[0] + "\xBB" : "", S = /*#__PURE__*/ m.node().appendChild(await W(_, t.labelStyle, true, true)), I = /*#__PURE__*/ S.getBBox();
    if (Rf(hh().flowchart.htmlLabels)) {
        let E = S.children[0], h = /*#__PURE__*/ kh(S);
        I = /*#__PURE__*/ E.getBoundingClientRect(), h.attr("width", I.width), h.attr("height", I.height);
    }
    t.classData.annotations[0] && (x += I.height + n, g += I.width);
    let D = t.classData.label;
    t.classData.type !== void 0 && t.classData.type !== "" && (hh().flowchart.htmlLabels ? D += "&lt;" + t.classData.type + "&gt;" : D += "<" + t.classData.type + ">");
    let T = /*#__PURE__*/ m.node().appendChild(await W(D, t.labelStyle, true, true));
    kh(T).attr("class", "classTitle");
    let y = /*#__PURE__*/ T.getBBox();
    if (Rf(hh().flowchart.htmlLabels)) {
        let E = T.children[0], h = /*#__PURE__*/ kh(T);
        y = /*#__PURE__*/ E.getBoundingClientRect(), h.attr("width", y.width), h.attr("height", y.height);
    }
    x += y.height + n, y.width > g && (g = y.width);
    let d = [];
    t.classData.members.forEach(async (E)=>{
        let h = /*#__PURE__*/ E.getDisplayDetails(), Y = h.displayText;
        hh().flowchart.htmlLabels && (Y = /*#__PURE__*/ Y.replace(/</g, "&lt;").replace(/>/g, "&gt;"));
        let p = /*#__PURE__*/ m.node().appendChild(await W(Y, h.cssStyle ? h.cssStyle : t.labelStyle, true, true)), R = /*#__PURE__*/ p.getBBox();
        if (Rf(hh().flowchart.htmlLabels)) {
            let Z = p.children[0], V = /*#__PURE__*/ kh(p);
            R = /*#__PURE__*/ Z.getBoundingClientRect(), V.attr("width", R.width), V.attr("height", R.height);
        }
        R.width > g && (g = R.width), x += R.height + n, d.push(p);
    }), x += i;
    let f = [];
    if (t.classData.methods.forEach(async (E)=>{
        let h = /*#__PURE__*/ E.getDisplayDetails(), Y = h.displayText;
        hh().flowchart.htmlLabels && (Y = /*#__PURE__*/ Y.replace(/</g, "&lt;").replace(/>/g, "&gt;"));
        let p = /*#__PURE__*/ m.node().appendChild(await W(Y, h.cssStyle ? h.cssStyle : t.labelStyle, true, true)), R = /*#__PURE__*/ p.getBBox();
        if (Rf(hh().flowchart.htmlLabels)) {
            let Z = p.children[0], V = /*#__PURE__*/ kh(p);
            R = /*#__PURE__*/ Z.getBoundingClientRect(), V.attr("width", R.width), V.attr("height", R.height);
        }
        R.width > g && (g = R.width), x += R.height + n, f.push(p);
    }), x += i, L) {
        let E = (g - I.width) / 2;
        kh(S).attr("transform", "translate( " + (-1 * g / 2 + E) + ", " + -1 * x / 2 + ")"), b = I.height + n;
    }
    let w = (g - y.width) / 2;
    return kh(T).attr("transform", "translate( " + (-1 * g / 2 + w) + ", " + (-1 * x / 2 + b) + ")"), b += y.height + n, o.attr("class", "divider").attr("x1", -g / 2 - s).attr("x2", g / 2 + s).attr("y1", -x / 2 - s + i + b).attr("y2", -x / 2 - s + i + b), b += i, d.forEach((E)=>{
        kh(E).attr("transform", "translate( " + -g / 2 + ", " + (-1 * x / 2 + b + i / 2) + ")");
        let h = E?.getBBox();
        b += (h?.height ?? 0) + n;
    }), b += i, u.attr("class", "divider").attr("x1", -g / 2 - s).attr("x2", g / 2 + s).attr("y1", -x / 2 - s + i + b).attr("y2", -x / 2 - s + i + b), b += i, f.forEach((E)=>{
        kh(E).attr("transform", "translate( " + -g / 2 + ", " + (-1 * x / 2 + b) + ")");
        let h = E?.getBBox();
        b += (h?.height ?? 0) + n;
    }), l.attr("style", t.style).attr("class", "outer title-state").attr("x", -g / 2 - s).attr("y", -(x / 2) - s).attr("width", g + t.padding).attr("height", x + t.padding), N(t, l), t.intersect = function(E) {
        return v.rect(t, E);
    }, r;
}, "class_box"), ke = {
    rhombus: ye,
    composite: zr,
    question: ye,
    rect: Ar,
    labelRect: Mr,
    rectWithTitle: Fr,
    choice: _r,
    circle: Pr,
    doublecircle: Yr,
    stadium: Wr,
    hexagon: Dr,
    block_arrow: Br,
    rect_left_inv_arrow: vr,
    lean_right: Tr,
    lean_left: Cr,
    trapezoid: Nr,
    inv_trapezoid: Ir,
    rect_right_inv_arrow: Or,
    cylinder: Rr,
    start: jr,
    end: Kr,
    note: xe,
    subroutine: Hr,
    fork: me,
    join: me,
    class_box: Xr
}, gt = {}, _t = /*#__PURE__*/ m$1(async (e, t, s)=>{
    let n, i;
    if (t.link) {
        let a;
        hh().securityLevel === "sandbox" ? a = "_top" : t.linkTarget && (a = t.linkTarget || "_blank"), n = /*#__PURE__*/ e.insert("svg:a").attr("xlink:href", t.link).attr("target", a), i = await ke[t.shape](n, t, s);
    } else i = await ke[t.shape](e, t, s), n = i;
    return t.tooltip && i.attr("title", t.tooltip), t.class && i.attr("class", "node default " + t.class), gt[t.id] = n, t.haveCallback && gt[t.id].attr("class", gt[t.id].attr("class") + " clickable"), n;
}, "insertNode");
var we = /*#__PURE__*/ m$1((e)=>{
    let t = gt[e.id];
    tt.trace("Transforming node", e.diff, e, "translate(" + (e.x - e.width / 2 - 5) + ", " + e.width / 2 + ")");
    let s = 8, n = e.diff || 0;
    return e.clusterNode ? t.attr("transform", "translate(" + (e.x + n - e.width / 2) + ", " + (e.y - e.height / 2 - s) + ")") : t.attr("transform", "translate(" + e.x + ", " + e.y + ")"), n;
}, "positionNode");
function Le(e, t) {
    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    let n = e, i = "default";
    (n?.classes?.length || 0) > 0 && (i = /*#__PURE__*/ (n?.classes ?? []).join(" ")), i = i + " flowchart-label";
    let a = 0, r = "", l;
    switch(n.type){
        case "round":
            a = 5, r = "rect";
            break;
        case "composite":
            a = 0, r = "composite", l = 0;
            break;
        case "square":
            r = "rect";
            break;
        case "diamond":
            r = "question";
            break;
        case "hexagon":
            r = "hexagon";
            break;
        case "block_arrow":
            r = "block_arrow";
            break;
        case "odd":
            r = "rect_left_inv_arrow";
            break;
        case "lean_right":
            r = "lean_right";
            break;
        case "lean_left":
            r = "lean_left";
            break;
        case "trapezoid":
            r = "trapezoid";
            break;
        case "inv_trapezoid":
            r = "inv_trapezoid";
            break;
        case "rect_left_inv_arrow":
            r = "rect_left_inv_arrow";
            break;
        case "circle":
            r = "circle";
            break;
        case "ellipse":
            r = "ellipse";
            break;
        case "stadium":
            r = "stadium";
            break;
        case "subroutine":
            r = "subroutine";
            break;
        case "cylinder":
            r = "cylinder";
            break;
        case "group":
            r = "rect";
            break;
        case "doublecircle":
            r = "doublecircle";
            break;
        default:
            r = "rect";
    }
    let o = /*#__PURE__*/ be$1(n?.styles ?? []), u = n.label, g = n.size ?? {
        width: 0,
        height: 0,
        x: 0,
        y: 0
    };
    return {
        labelStyle: o.labelStyle,
        shape: r,
        labelText: u,
        rx: a,
        ry: a,
        class: i,
        style: o.style,
        id: n.id,
        directions: n.directions,
        width: g.width,
        height: g.height,
        x: g.x,
        y: g.y,
        positioned: s,
        intersect: void 0,
        type: n.type,
        padding: l ?? Or$1()?.block?.padding ?? 0
    };
}
m$1(Le, "getNodeFromBlock");
async function Ur(e, t, s) {
    let n = /*#__PURE__*/ Le(t, s, false);
    if (n.type === "group") return;
    let i = /*#__PURE__*/ Or$1(), a = await _t(e, n, {
        config: i
    }), r = /*#__PURE__*/ a.node().getBBox(), l = /*#__PURE__*/ s.getBlock(n.id);
    l.size = {
        width: r.width,
        height: r.height,
        x: 0,
        y: 0,
        node: a
    }, s.setBlock(l), a.remove();
}
m$1(Ur, "calculateBlockSize");
async function Vr(e, t, s) {
    let n = /*#__PURE__*/ Le(t, s, true);
    if (s.getBlock(n.id).type !== "space") {
        let a = /*#__PURE__*/ Or$1();
        await _t(e, n, {
            config: a
        }), t.intersect = n?.intersect, we(n);
    }
}
m$1(Vr, "insertBlockPositioned");
async function Dt(e, t, s, n) {
    for (let i of t)await n(e, i, s), i.children && await Dt(e, i.children, s, n);
}
m$1(Dt, "performOperations");
async function Se(e, t, s) {
    await Dt(e, t, s, Ur);
}
m$1(Se, "calculateBlockSizes");
async function Ee(e, t, s) {
    await Dt(e, t, s, Vr);
}
m$1(Ee, "insertBlocks");
async function _e(e, t, s, n, i) {
    let a = new m({
        multigraph: true,
        compound: true
    });
    a.setGraph({
        rankdir: "TB",
        nodesep: 10,
        ranksep: 10,
        marginx: 8,
        marginy: 8
    });
    for (let r of s)r.size && a.setNode(r.id, {
        width: r.size.width,
        height: r.size.height,
        intersect: r.intersect
    });
    for (let r of t)if (r.start && r.end) {
        let l = /*#__PURE__*/ n.getBlock(r.start), o = /*#__PURE__*/ n.getBlock(r.end);
        if (l?.size && o?.size) {
            let u = l.size, g = o.size, x = [
                {
                    x: u.x,
                    y: u.y
                },
                {
                    x: u.x + (g.x - u.x) / 2,
                    y: u.y + (g.y - u.y) / 2
                },
                {
                    x: g.x,
                    y: g.y
                }
            ];
            oe(e, {
                v: r.start,
                w: r.end,
                name: r.id
            }, {
                ...r,
                arrowTypeEnd: r.arrowTypeEnd,
                arrowTypeStart: r.arrowTypeStart,
                points: x,
                classes: "edge-thickness-normal edge-pattern-solid flowchart-link LS-a1 LE-b1"
            }, void 0, "block", a, i), r.label && (await ne(e, {
                ...r,
                label: r.label,
                labelStyle: "stroke: #333; stroke-width: 1.5px;fill:none;",
                arrowTypeEnd: r.arrowTypeEnd,
                arrowTypeStart: r.arrowTypeStart,
                points: x,
                classes: "edge-thickness-normal edge-pattern-solid flowchart-link LS-a1 LE-b1"
            }), le({
                ...r,
                x: x[1].x,
                y: x[1].y
            }, {
                originalPath: x
            }));
        }
    }
}
m$1(_e, "insertEdges");
var Gr = /*#__PURE__*/ m$1(function(e, t) {
    return t.db.getClasses();
}, "getClasses"), Zr = /*#__PURE__*/ m$1(async function(e, t, s, n) {
    let { securityLevel: i, block: a } = Or$1(), r = n.db, l;
    i === "sandbox" && (l = /*#__PURE__*/ kh("#i" + t));
    let o = i === "sandbox" ? kh(l.nodes()[0].contentDocument.body) : kh("body"), u = i === "sandbox" ? o.select(`[id="${t}"]`) : kh(`[id="${t}"]`);
    Qt(u, [
        "point",
        "circle",
        "cross"
    ], n.type, t);
    let x = /*#__PURE__*/ r.getBlocks(), m = /*#__PURE__*/ r.getBlocksFlat(), b = /*#__PURE__*/ r.getEdges(), L = /*#__PURE__*/ u.insert("g").attr("class", "block");
    await Se(L, x, r);
    let _ = /*#__PURE__*/ ee(r);
    if (await Ee(L, x, r), await _e(L, b, m, r, t), _) {
        let S = _, I = /*#__PURE__*/ Math.max(1, /*#__PURE__*/ Math.round(.125 * (S.width / S.height))), D = S.height + I + 10, T = S.width + 10, { useMaxWidth: y } = a;
        Yf(u, D, T, !!y), tt.debug("Here Bounds", _, S), u.attr("viewBox", `${S.x - 5} ${S.y - 5} ${S.width + 10} ${S.height + 10}`);
    }
}, "draw"), De = {
    draw: Zr,
    getClasses: Gr
};
var $s = {
    parser: Kt,
    db: qt,
    renderer: De,
    styles: Jt
};
export { $s as diagram };
