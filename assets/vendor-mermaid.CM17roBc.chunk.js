let e;
var t = {};
let r = function(e, r, i) {
	let n = Promise.resolve();
	if (r && r.length > 0) {
		let e = document.getElementsByTagName("link"), a = document.querySelector("meta[property=csp-nonce]"), s = a?.nonce || a?.getAttribute("nonce");
		n = Promise.all(r.map((r) => {
			if ((r = "/__APP_BASE_HREF__/" + r) in t) return;
			t[r] = !0;
			let n = r.endsWith(".css");
			if (i) for (let t = e.length - 1; t >= 0; t--) {
				let i = e[t];
				if (i.href === r && (!n || "stylesheet" === i.rel)) return;
			}
			else if (document.querySelector(`link[href="${r}"]${n ? "[rel=\"stylesheet\"]" : ""}`)) return;
			let a = document.createElement("link");
			if (a.rel = n ? "stylesheet" : "modulepreload", n || (a.as = "script"), a.crossOrigin = "", a.href = r, s && a.setAttribute("nonce", s), document.head.appendChild(a), n) return new Promise((e, t) => {
				a.addEventListener("load", e), a.addEventListener("error", () => t(Error(`Unable to preload CSS for ${r}`)));
			});
		}).map((e) => Promise.resolve(e).then((e) => ({
			status: "fulfilled",
			value: e
		}), (e) => ({
			status: "rejected",
			reason: e
		}))));
	}
	function a(e) {
		let t = new Event("vite:preloadError", { cancelable: !0 });
		if (t.payload = e, window.dispatchEvent(t), !t.defaultPrevented) throw e;
	}
	return n.then((t) => {
		for (let e of t || []) "rejected" === e.status && a(e.reason);
		return e().catch(a);
	});
};
var i = Object.create, n = Object.defineProperty, a = Object.getOwnPropertyDescriptor, s = Object.getOwnPropertyNames, o = Object.getPrototypeOf, l = Object.prototype.hasOwnProperty, h = (e, t) => n(e, "name", {
	value: t,
	configurable: !0
}), u = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), d = (e, t) => {
	for (var r in t) n(e, r, {
		get: t[r],
		enumerable: !0
	});
}, p = (e, t, r, i) => {
	if (t && "object" == typeof t || "function" == typeof t) for (let o of s(t)) l.call(e, o) || o === r || n(e, o, {
		get: () => t[o],
		enumerable: !(i = a(t, o)) || i.enumerable
	});
	return e;
}, f = (e, t, r) => (p(e, t, "default"), r && p(r, t, "default")), g = (e, t, r) => (r = null != e ? i(o(e)) : {}, p(!t && e && e.__esModule ? r : n(r, "default", {
	value: e,
	enumerable: !0
}), e)), m = "object" == typeof global && global && global.Object === Object && global, y = "object" == typeof self && self && self.Object === Object && self, v = m || y || Function("return this")(), x = v.Symbol, b = Object.prototype, w = b.hasOwnProperty, k = b.toString, T = x ? x.toStringTag : void 0;
function _(e) {
	var t = w.call(e, T), r = e[T];
	try {
		e[T] = void 0;
		var i = !0;
	} catch {}
	var n = k.call(e);
	return i && (t ? e[T] = r : delete e[T]), n;
}
h(_, "getRawTag");
var E = Object.prototype.toString;
function C(e) {
	return E.call(e);
}
h(C, "objectToString");
var S = x ? x.toStringTag : void 0;
function A(e) {
	return null == e ? void 0 === e ? "[object Undefined]" : "[object Null]" : S && S in Object(e) ? _(e) : C(e);
}
function L(e) {
	var t = typeof e;
	return null != e && ("object" == t || "function" == t);
}
function R(e) {
	if (!L(e)) return !1;
	var t = A(e);
	return "[object Function]" == t || "[object GeneratorFunction]" == t || "[object AsyncFunction]" == t || "[object Proxy]" == t;
}
h(A, "baseGetTag"), h(L, "isObject"), h(R, "isFunction");
var N = v["__core-js_shared__"], I = (aY = /[^.]+$/.exec(N && N.keys && N.keys.IE_PROTO || "")) ? "Symbol(src)_1." + aY : "";
function M(e) {
	return !!I && I in e;
}
h(M, "isMasked");
var D = Function.prototype.toString;
function O(e) {
	if (null != e) {
		try {
			return D.call(e);
		} catch {}
		try {
			return e + "";
		} catch {}
	}
	return "";
}
h(O, "toSource");
var $ = /^\[object .+?Constructor\]$/, P = Object.prototype, B = Function.prototype.toString, F = P.hasOwnProperty, z = RegExp("^" + B.call(F).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function U(e) {
	return !(!L(e) || M(e)) && (R(e) ? z : $).test(O(e));
}
function G(e, t) {
	return e?.[t];
}
function q(e, t) {
	var r = G(e, t);
	return U(r) ? r : void 0;
}
h(U, "baseIsNative"), h(G, "getValue"), h(q, "getNative");
var j = q(Object, "create");
function W() {
	this.__data__ = j ? j(null) : {}, this.size = 0;
}
function Y(e) {
	var t = this.has(e) && delete this.__data__[e];
	return this.size -= !!t, t;
}
h(W, "hashClear"), h(Y, "hashDelete");
var V = Object.prototype.hasOwnProperty;
function H(e) {
	var t = this.__data__;
	if (j) {
		var r = t[e];
		return "__lodash_hash_undefined__" === r ? void 0 : r;
	}
	return V.call(t, e) ? t[e] : void 0;
}
h(H, "hashGet");
var X = Object.prototype.hasOwnProperty;
function K(e) {
	var t = this.__data__;
	return j ? void 0 !== t[e] : X.call(t, e);
}
function Z(e, t) {
	var r = this.__data__;
	return this.size += +!this.has(e), r[e] = j && void 0 === t ? "__lodash_hash_undefined__" : t, this;
}
function Q(e) {
	var t = -1, r = null == e ? 0 : e.length;
	for (this.clear(); ++t < r;) {
		var i = e[t];
		this.set(i[0], i[1]);
	}
}
function J() {
	this.__data__ = [], this.size = 0;
}
function ee(e, t) {
	return e === t || e != e && t != t;
}
function et(e, t) {
	for (var r = e.length; r--;) if (ee(e[r][0], t)) return r;
	return -1;
}
h(K, "hashHas"), h(Z, "hashSet"), h(Q, "Hash"), Q.prototype.clear = W, Q.prototype.delete = Y, Q.prototype.get = H, Q.prototype.has = K, Q.prototype.set = Z, h(J, "listCacheClear"), h(ee, "eq"), h(et, "assocIndexOf");
var er = Array.prototype.splice;
function ei(e) {
	var t = this.__data__, r = et(t, e);
	return !(r < 0) && (r == t.length - 1 ? t.pop() : er.call(t, r, 1), --this.size, !0);
}
function en(e) {
	var t = this.__data__, r = et(t, e);
	return r < 0 ? void 0 : t[r][1];
}
function ea(e) {
	return et(this.__data__, e) > -1;
}
function es(e, t) {
	var r = this.__data__, i = et(r, e);
	return i < 0 ? (++this.size, r.push([e, t])) : r[i][1] = t, this;
}
function eo(e) {
	var t = -1, r = null == e ? 0 : e.length;
	for (this.clear(); ++t < r;) {
		var i = e[t];
		this.set(i[0], i[1]);
	}
}
h(ei, "listCacheDelete"), h(en, "listCacheGet"), h(ea, "listCacheHas"), h(es, "listCacheSet"), h(eo, "ListCache"), eo.prototype.clear = J, eo.prototype.delete = ei, eo.prototype.get = en, eo.prototype.has = ea, eo.prototype.set = es;
var el = q(v, "Map");
function ec() {
	this.size = 0, this.__data__ = {
		hash: new Q(),
		map: new (el || eo)(),
		string: new Q()
	};
}
function eh(e) {
	var t = typeof e;
	return "string" == t || "number" == t || "symbol" == t || "boolean" == t ? "__proto__" !== e : null === e;
}
function eu(e, t) {
	var r = e.__data__;
	return eh(t) ? r["string" == typeof t ? "string" : "hash"] : r.map;
}
function ed(e) {
	var t = eu(this, e).delete(e);
	return this.size -= !!t, t;
}
function ep(e) {
	return eu(this, e).get(e);
}
function ef(e) {
	return eu(this, e).has(e);
}
function eg(e, t) {
	var r = eu(this, e), i = r.size;
	return r.set(e, t), this.size += +(r.size != i), this;
}
function em(e) {
	var t = -1, r = null == e ? 0 : e.length;
	for (this.clear(); ++t < r;) {
		var i = e[t];
		this.set(i[0], i[1]);
	}
}
function ey(e, t) {
	if ("function" != typeof e || null != t && "function" != typeof t) throw TypeError("Expected a function");
	var r = h(function() {
		var i = arguments, n = t ? t.apply(this, i) : i[0], a = r.cache;
		if (a.has(n)) return a.get(n);
		var s = e.apply(this, i);
		return r.cache = a.set(n, s) || a, s;
	}, "memoized");
	return r.cache = new (ey.Cache || em)(), r;
}
function ev(e) {
	return function() {
		return e;
	};
}
function ex() {
	this.__data__ = new eo(), this.size = 0;
}
function eb(e) {
	var t = this.__data__, r = t.delete(e);
	return this.size = t.size, r;
}
function ew(e) {
	return this.__data__.get(e);
}
function ek(e) {
	return this.__data__.has(e);
}
function eT(e, t) {
	var r = this.__data__;
	if (r instanceof eo) {
		var i = r.__data__;
		if (!el || i.length < 199) return i.push([e, t]), this.size = ++r.size, this;
		r = this.__data__ = new em(i);
	}
	return r.set(e, t), this.size = r.size, this;
}
function e_(e) {
	this.size = (this.__data__ = new eo(e)).size;
}
h(ec, "mapCacheClear"), h(eh, "isKeyable"), h(eu, "getMapData"), h(ed, "mapCacheDelete"), h(ep, "mapCacheGet"), h(ef, "mapCacheHas"), h(eg, "mapCacheSet"), h(em, "MapCache"), em.prototype.clear = ec, em.prototype.delete = ed, em.prototype.get = ep, em.prototype.has = ef, em.prototype.set = eg, h(ey, "memoize"), ey.Cache = em, h(ev, "constant"), h(ex, "stackClear"), h(eb, "stackDelete"), h(ew, "stackGet"), h(ek, "stackHas"), h(eT, "stackSet"), h(e_, "Stack"), e_.prototype.clear = ex, e_.prototype.delete = eb, e_.prototype.get = ew, e_.prototype.has = ek, e_.prototype.set = eT;
var eE = function() {
	try {
		var e = q(Object, "defineProperty");
		return e({}, "", {}), e;
	} catch {}
}();
function eC(e, t, r) {
	"__proto__" == t && eE ? eE(e, t, {
		configurable: !0,
		enumerable: !0,
		value: r,
		writable: !0
	}) : e[t] = r;
}
function eS(e, t, r) {
	(void 0 === r || ee(e[t], r)) && (void 0 !== r || t in e) || eC(e, t, r);
}
function eA(e) {
	return function(t, r, i) {
		for (var n = -1, a = Object(t), s = i(t), o = s.length; o--;) {
			var l = s[e ? o : ++n];
			if (!1 === r(a[l], l, a)) break;
		}
		return t;
	};
}
h(eC, "baseAssignValue"), h(eS, "assignMergeValue"), h(eA, "createBaseFor");
var eL = eA(), eR = "object" == typeof exports && exports && !exports.nodeType && exports, eN = eR && "object" == typeof module && module && !module.nodeType && module, eI = eN && eN.exports === eR ? v.Buffer : void 0, eM = eI ? eI.allocUnsafe : void 0;
function eD(e, t) {
	if (t) return e.slice();
	var r = e.length, i = eM ? eM(r) : new e.constructor(r);
	return e.copy(i), i;
}
h(eD, "cloneBuffer");
var eO = v.Uint8Array;
function e$(e) {
	var t = new e.constructor(e.byteLength);
	return new eO(t).set(new eO(e)), t;
}
function eP(e, t) {
	var r = t ? e$(e.buffer) : e.buffer;
	return new e.constructor(r, e.byteOffset, e.length);
}
function eB(e, t) {
	var r = -1, i = e.length;
	for (t || (t = Array(i)); ++r < i;) t[r] = e[r];
	return t;
}
h(e$, "cloneArrayBuffer"), h(eP, "cloneTypedArray"), h(eB, "copyArray");
var eF = Object.create, ez = function() {
	function e() {}
	return h(e, "object"), function(t) {
		if (!L(t)) return {};
		if (eF) return eF(t);
		e.prototype = t;
		var r = new e();
		return e.prototype = void 0, r;
	};
}();
function eU(e, t) {
	return function(r) {
		return e(t(r));
	};
}
h(eU, "overArg");
var eG = eU(Object.getPrototypeOf, Object), eq = Object.prototype;
function ej(e) {
	var t = e && e.constructor;
	return e === ("function" == typeof t && t.prototype || eq);
}
function eW(e) {
	return "function" != typeof e.constructor || ej(e) ? {} : ez(eG(e));
}
function eY(e) {
	return null != e && "object" == typeof e;
}
function eV(e) {
	return eY(e) && "[object Arguments]" == A(e);
}
h(ej, "isPrototype"), h(eW, "initCloneObject"), h(eY, "isObjectLike"), h(eV, "baseIsArguments");
var eH = Object.prototype, eX = eH.hasOwnProperty, eK = eH.propertyIsEnumerable, eZ = eV(function() {
	return arguments;
}()) ? eV : function(e) {
	return eY(e) && eX.call(e, "callee") && !eK.call(e, "callee");
}, eQ = Array.isArray;
function eJ(e) {
	return "number" == typeof e && e > -1 && e % 1 == 0 && e <= 9007199254740991;
}
function e0(e) {
	return null != e && eJ(e.length) && !R(e);
}
function e1(e) {
	return eY(e) && e0(e);
}
function e2() {
	return !1;
}
h(eJ, "isLength"), h(e0, "isArrayLike"), h(e1, "isArrayLikeObject"), h(e2, "stubFalse");
var e4 = "object" == typeof exports && exports && !exports.nodeType && exports, e5 = e4 && "object" == typeof module && module && !module.nodeType && module, e3 = e5 && e5.exports === e4 ? v.Buffer : void 0, e6 = (e3 ? e3.isBuffer : void 0) || e2, e7 = Object.prototype, e8 = Function.prototype.toString, e9 = e7.hasOwnProperty, te = e8.call(Object);
function tt(e) {
	if (!eY(e) || "[object Object]" != A(e)) return !1;
	var t = eG(e);
	if (null === t) return !0;
	var r = e9.call(t, "constructor") && t.constructor;
	return "function" == typeof r && r instanceof r && e8.call(r) == te;
}
h(tt, "isPlainObject");
var tr = {};
function ti(e) {
	return eY(e) && eJ(e.length) && !!tr[A(e)];
}
function tn(e) {
	return function(t) {
		return e(t);
	};
}
tr["[object Float32Array]"] = tr["[object Float64Array]"] = tr["[object Int8Array]"] = tr["[object Int16Array]"] = tr["[object Int32Array]"] = tr["[object Uint8Array]"] = tr["[object Uint8ClampedArray]"] = tr["[object Uint16Array]"] = tr["[object Uint32Array]"] = !0, tr["[object Arguments]"] = tr["[object Array]"] = tr["[object ArrayBuffer]"] = tr["[object Boolean]"] = tr["[object DataView]"] = tr["[object Date]"] = tr["[object Error]"] = tr["[object Function]"] = tr["[object Map]"] = tr["[object Number]"] = tr["[object Object]"] = tr["[object RegExp]"] = tr["[object Set]"] = tr["[object String]"] = tr["[object WeakMap]"] = !1, h(ti, "baseIsTypedArray"), h(tn, "baseUnary");
var ta = "object" == typeof exports && exports && !exports.nodeType && exports, ts = ta && "object" == typeof module && module && !module.nodeType && module, to = ts && ts.exports === ta && m.process, tl = function() {
	try {
		return ts && ts.require && ts.require("util").types || to && to.binding && to.binding("util");
	} catch {}
}(), tc = tl && tl.isTypedArray, th = tc ? tn(tc) : ti;
function tu(e, t) {
	if (("constructor" !== t || "function" != typeof e[t]) && "__proto__" != t) return e[t];
}
h(tu, "safeGet");
var td = Object.prototype.hasOwnProperty;
function tp(e, t, r) {
	var i = e[t];
	td.call(e, t) && ee(i, r) && (void 0 !== r || t in e) || eC(e, t, r);
}
function tf(e, t, r, i) {
	var n = !r;
	r || (r = {});
	for (var a = -1, s = t.length; ++a < s;) {
		var o = t[a], l = i ? i(r[o], e[o], o, r, e) : void 0;
		void 0 === l && (l = e[o]), n ? eC(r, o, l) : tp(r, o, l);
	}
	return r;
}
function tg(e, t) {
	for (var r = -1, i = Array(e); ++r < e;) i[r] = t(r);
	return i;
}
h(tp, "assignValue"), h(tf, "copyObject"), h(tg, "baseTimes");
var tm = /^(?:0|[1-9]\d*)$/;
function ty(e, t) {
	var r = typeof e;
	return !!(t = t ?? 9007199254740991) && ("number" == r || "symbol" != r && tm.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
h(ty, "isIndex");
var tv = Object.prototype.hasOwnProperty;
function tx(e, t) {
	var r = eQ(e), i = !r && eZ(e), n = !r && !i && e6(e), a = !r && !i && !n && th(e), s = r || i || n || a, o = s ? tg(e.length, String) : [], l = o.length;
	for (var h in e) (t || tv.call(e, h)) && !(s && ("length" == h || n && ("offset" == h || "parent" == h) || a && ("buffer" == h || "byteLength" == h || "byteOffset" == h) || ty(h, l))) && o.push(h);
	return o;
}
function tb(e) {
	var t = [];
	if (null != e) for (var r in Object(e)) t.push(r);
	return t;
}
h(tx, "arrayLikeKeys"), h(tb, "nativeKeysIn");
var tw = Object.prototype.hasOwnProperty;
function tk(e) {
	if (!L(e)) return tb(e);
	var t = ej(e), r = [];
	for (var i in e) "constructor" == i && (t || !tw.call(e, i)) || r.push(i);
	return r;
}
function tT(e) {
	return e0(e) ? tx(e, !0) : tk(e);
}
function t_(e) {
	return tf(e, tT(e));
}
function tE(e, t, r, i, n, a, s) {
	var o = tu(e, r), l = tu(t, r), h = s.get(l);
	if (h) return void eS(e, r, h);
	var u = a ? a(o, l, r + "", e, t, s) : void 0, d = void 0 === u;
	if (d) {
		var p = eQ(l), f = !p && e6(l), g = !p && !f && th(l);
		u = l, p || f || g ? eQ(o) ? u = o : e1(o) ? u = eB(o) : f ? (d = !1, u = eD(l, !0)) : g ? (d = !1, u = eP(l, !0)) : u = [] : tt(l) || eZ(l) ? (u = o, eZ(o) ? u = t_(o) : (!L(o) || R(o)) && (u = eW(l))) : d = !1;
	}
	d && (s.set(l, u), n(u, l, i, a, s), s.delete(l)), eS(e, r, u);
}
function tC(e, t, r, i, n) {
	e !== t && eL(t, function(a, s) {
		if (n || (n = new e_()), L(a)) tE(e, t, s, r, tC, i, n);
		else {
			var o = i ? i(tu(e, s), a, s + "", e, t, n) : void 0;
			void 0 === o && (o = a), eS(e, s, o);
		}
	}, tT);
}
function tS(e) {
	return e;
}
function tA(e, t, r) {
	switch (r.length) {
		case 0: return e.call(t);
		case 1: return e.call(t, r[0]);
		case 2: return e.call(t, r[0], r[1]);
		case 3: return e.call(t, r[0], r[1], r[2]);
	}
	return e.apply(t, r);
}
h(tk, "baseKeysIn"), h(tT, "keysIn"), h(t_, "toPlainObject"), h(tE, "baseMergeDeep"), h(tC, "baseMerge"), h(tS, "identity"), h(tA, "apply");
var tL = Math.max;
function tR(e, t, r) {
	return t = tL(void 0 === t ? e.length - 1 : t, 0), function() {
		for (var i = arguments, n = -1, a = tL(i.length - t, 0), s = Array(a); ++n < a;) s[n] = i[t + n];
		n = -1;
		for (var o = Array(t + 1); ++n < t;) o[n] = i[n];
		return o[t] = r(s), tA(e, this, o);
	};
}
h(tR, "overRest");
var tN = eE ? function(e, t) {
	return eE(e, "toString", {
		configurable: !0,
		enumerable: !1,
		value: ev(t),
		writable: !0
	});
} : tS, tI = Date.now;
function tM(e) {
	var t = 0, r = 0;
	return function() {
		var i = tI(), n = 16 - (i - r);
		if (r = i, n > 0) {
			if (++t >= 800) return arguments[0];
		} else t = 0;
		return e.apply(void 0, arguments);
	};
}
h(tM, "shortOut");
var tD = tM(tN);
function tO(e, t) {
	return tD(tR(e, t, tS), e + "");
}
function t$(e, t, r) {
	if (!L(r)) return !1;
	var i = typeof t;
	return ("number" == i ? !!(e0(r) && ty(t, r.length)) : "string" == i && t in r) && ee(r[t], e);
}
function tP(e) {
	return tO(function(t, r) {
		var i = -1, n = r.length, a = n > 1 ? r[n - 1] : void 0, s = n > 2 ? r[2] : void 0;
		for (a = e.length > 3 && "function" == typeof a ? (n--, a) : void 0, s && t$(r[0], r[1], s) && (a = n < 3 ? void 0 : a, n = 1), t = Object(t); ++i < n;) {
			var o = r[i];
			o && e(t, o, i, a);
		}
		return t;
	});
}
h(tO, "baseRest"), h(t$, "isIterateeCall"), h(tP, "createAssigner");
var tB = tP(function(e, t, r) {
	tC(e, t, r);
}), tF = eU(Object.keys, Object), tz = Object.prototype.hasOwnProperty;
function tU(e) {
	if (!ej(e)) return tF(e);
	var t = [];
	for (var r in Object(e)) tz.call(e, r) && "constructor" != r && t.push(r);
	return t;
}
h(tU, "baseKeys");
var tG = q(v, "DataView"), tq = q(v, "Promise"), tj = q(v, "Set"), tW = q(v, "WeakMap"), tY = "[object Map]", tV = "[object Promise]", tH = "[object Set]", tX = "[object WeakMap]", tK = "[object DataView]", tZ = O(tG), tQ = O(el), tJ = O(tq), t0 = O(tj), t1 = O(tW), t2 = A;
(tG && t2(new tG(/* @__PURE__ */ new ArrayBuffer(1))) != tK || el && t2(new el()) != tY || tq && t2(tq.resolve()) != tV || tj && t2(new tj()) != tH || tW && t2(new tW()) != tX) && (t2 = h(function(e) {
	var t = A(e), r = "[object Object]" == t ? e.constructor : void 0, i = r ? O(r) : "";
	if (i) switch (i) {
		case tZ: return tK;
		case tQ: return tY;
		case tJ: return tV;
		case t0: return tH;
		case t1: return tX;
	}
	return t;
}, "getTag"));
var t4 = t2, t5 = Object.prototype.hasOwnProperty;
function t3(e) {
	if (null == e) return !0;
	if (e0(e) && (eQ(e) || "string" == typeof e || "function" == typeof e.splice || e6(e) || th(e) || eZ(e))) return !e.length;
	var t = t4(e);
	if ("[object Map]" == t || "[object Set]" == t) return !e.size;
	if (ej(e)) return !tU(e).length;
	for (var r in e) if (t5.call(e, r)) return !1;
	return !0;
}
function t6(e) {
	return e0(e) ? tx(e) : tU(e);
}
function t7(e, t) {
	for (var r = -1, i = null == e ? 0 : e.length; ++r < i && !1 !== t(e[r], r, e););
	return e;
}
function t8(e, t) {
	return e && tf(t, t6(t), e);
}
function t9(e, t) {
	return e && tf(t, tT(t), e);
}
function re(e, t) {
	for (var r = -1, i = null == e ? 0 : e.length, n = 0, a = []; ++r < i;) {
		var s = e[r];
		t(s, r, e) && (a[n++] = s);
	}
	return a;
}
function rt() {
	return [];
}
h(t3, "isEmpty"), h(t6, "keys"), h(t7, "arrayEach"), h(t8, "baseAssign"), h(t9, "baseAssignIn"), h(re, "arrayFilter"), h(rt, "stubArray");
var rr = Object.prototype.propertyIsEnumerable, ri = Object.getOwnPropertySymbols, rn = ri ? function(e) {
	return null == e ? [] : re(ri(e = Object(e)), function(t) {
		return rr.call(e, t);
	});
} : rt;
function ra(e, t) {
	return tf(e, rn(e), t);
}
function rs(e, t) {
	for (var r = -1, i = t.length, n = e.length; ++r < i;) e[n + r] = t[r];
	return e;
}
h(ra, "copySymbols"), h(rs, "arrayPush");
var ro = Object.getOwnPropertySymbols ? function(e) {
	for (var t = []; e;) rs(t, rn(e)), e = eG(e);
	return t;
} : rt;
function rl(e, t) {
	return tf(e, ro(e), t);
}
function rc(e, t, r) {
	var i = t(e);
	return eQ(e) ? i : rs(i, r(e));
}
function rh(e) {
	return rc(e, t6, rn);
}
function ru(e) {
	return rc(e, tT, ro);
}
h(rl, "copySymbolsIn"), h(rc, "baseGetAllKeys"), h(rh, "getAllKeys"), h(ru, "getAllKeysIn");
var rd = Object.prototype.hasOwnProperty;
function rp(e) {
	var t = e.length, r = new e.constructor(t);
	return t && "string" == typeof e[0] && rd.call(e, "index") && (r.index = e.index, r.input = e.input), r;
}
function rf(e, t) {
	var r = t ? e$(e.buffer) : e.buffer;
	return new e.constructor(r, e.byteOffset, e.byteLength);
}
h(rp, "initCloneArray"), h(rf, "cloneDataView");
var rg = /\w*$/;
function rm(e) {
	var t = new e.constructor(e.source, rg.exec(e));
	return t.lastIndex = e.lastIndex, t;
}
h(rm, "cloneRegExp");
var ry = x ? x.prototype : void 0, rv = ry ? ry.valueOf : void 0;
function rx(e) {
	return rv ? Object(rv.call(e)) : {};
}
function rb(e, t, r) {
	var i = e.constructor;
	switch (t) {
		case "[object ArrayBuffer]": return e$(e);
		case "[object Boolean]":
		case "[object Date]": return new i(+e);
		case "[object DataView]": return rf(e, r);
		case "[object Float32Array]":
		case "[object Float64Array]":
		case "[object Int8Array]":
		case "[object Int16Array]":
		case "[object Int32Array]":
		case "[object Uint8Array]":
		case "[object Uint8ClampedArray]":
		case "[object Uint16Array]":
		case "[object Uint32Array]": return eP(e, r);
		case "[object Map]":
		case "[object Set]": return new i();
		case "[object Number]":
		case "[object String]": return new i(e);
		case "[object RegExp]": return rm(e);
		case "[object Symbol]": return rx(e);
	}
}
function rw(e) {
	return eY(e) && "[object Map]" == t4(e);
}
h(rx, "cloneSymbol"), h(rb, "initCloneByTag"), h(rw, "baseIsMap");
var rk = tl && tl.isMap, rT = rk ? tn(rk) : rw;
function r_(e) {
	return eY(e) && "[object Set]" == t4(e);
}
h(r_, "baseIsSet");
var rE = tl && tl.isSet, rC = rE ? tn(rE) : r_, rS = "[object Arguments]", rA = "[object Function]", rL = "[object Object]", rR = {};
function rN(e, t, r, i, n, a) {
	var s, o = 1 & t, l = 2 & t, h = 4 & t;
	if (r && (s = n ? r(e, i, n, a) : r(e)), void 0 !== s) return s;
	if (!L(e)) return e;
	var u = eQ(e);
	if (u) {
		if (s = rp(e), !o) return eB(e, s);
	} else {
		var d = t4(e), p = d == rA || "[object GeneratorFunction]" == d;
		if (e6(e)) return eD(e, o);
		if (d == rL || d == rS || p && !n) {
			if (s = l || p ? {} : eW(e), !o) return l ? rl(e, t9(s, e)) : ra(e, t8(s, e));
		} else {
			if (!rR[d]) return n ? e : {};
			s = rb(e, d, o);
		}
	}
	a || (a = new e_());
	var f = a.get(e);
	if (f) return f;
	a.set(e, s), rC(e) ? e.forEach(function(i) {
		s.add(rN(i, t, r, i, e, a));
	}) : rT(e) && e.forEach(function(i, n) {
		s.set(n, rN(i, t, r, n, e, a));
	});
	var g = u ? void 0 : (h ? l ? ru : rh : l ? tT : t6)(e);
	return t7(g || e, function(i, n) {
		g && (i = e[n = i]), tp(s, n, rN(i, t, r, n, e, a));
	}), s;
}
function rI(e) {
	return rN(e, 4);
}
rR[rS] = rR["[object Array]"] = rR["[object ArrayBuffer]"] = rR["[object DataView]"] = rR["[object Boolean]"] = rR["[object Date]"] = rR["[object Float32Array]"] = rR["[object Float64Array]"] = rR["[object Int8Array]"] = rR["[object Int16Array]"] = rR["[object Int32Array]"] = rR["[object Map]"] = rR["[object Number]"] = rR[rL] = rR["[object RegExp]"] = rR["[object Set]"] = rR["[object String]"] = rR["[object Symbol]"] = rR["[object Uint8Array]"] = rR["[object Uint8ClampedArray]"] = rR["[object Uint16Array]"] = rR["[object Uint32Array]"] = !0, rR["[object Error]"] = rR[rA] = rR["[object WeakMap]"] = !1, h(rN, "baseClone"), h(rI, "clone");
var rM = Object.prototype, rD = rM.hasOwnProperty, rO = tO(function(e, t) {
	e = Object(e);
	var r = -1, i = t.length, n = i > 2 ? t[2] : void 0;
	for (n && t$(t[0], t[1], n) && (i = 1); ++r < i;) for (var a = t[r], s = tT(a), o = -1, l = s.length; ++o < l;) {
		var h = s[o], u = e[h];
		(void 0 === u || ee(u, rM[h]) && !rD.call(e, h)) && (e[h] = a[h]);
	}
	return e;
});
function r$(e) {
	var t = null == e ? 0 : e.length;
	return t ? e[t - 1] : void 0;
}
function rP(e, t) {
	return e && eL(e, t, t6);
}
function rB(e, t) {
	return function(r, i) {
		if (null == r) return r;
		if (!e0(r)) return e(r, i);
		for (var n = r.length, a = t ? n : -1, s = Object(r); (t ? a-- : ++a < n) && !1 !== i(s[a], a, s););
		return r;
	};
}
h(r$, "last"), h(rP, "baseForOwn"), h(rB, "createBaseEach");
var rF = rB(rP);
function rz(e) {
	return "function" == typeof e ? e : tS;
}
function rU(e, t) {
	return (eQ(e) ? t7 : rF)(e, rz(t));
}
function rG(e, t) {
	var r = [];
	return rF(e, function(e, i, n) {
		t(e, i, n) && r.push(e);
	}), r;
}
function rq(e) {
	return this.__data__.set(e, "__lodash_hash_undefined__"), this;
}
function rj(e) {
	return this.__data__.has(e);
}
function rW(e) {
	var t = -1, r = null == e ? 0 : e.length;
	for (this.__data__ = new em(); ++t < r;) this.add(e[t]);
}
function rY(e, t) {
	for (var r = -1, i = null == e ? 0 : e.length; ++r < i;) if (t(e[r], r, e)) return !0;
	return !1;
}
function rV(e, t) {
	return e.has(t);
}
function rH(e, t, r, i, n, a) {
	var s = 1 & r, o = e.length, l = t.length;
	if (o != l && !(s && l > o)) return !1;
	var h = a.get(e), u = a.get(t);
	if (h && u) return h == t && u == e;
	var d = -1, p = !0, f = 2 & r ? new rW() : void 0;
	for (a.set(e, t), a.set(t, e); ++d < o;) {
		var g = e[d], m = t[d];
		if (i) var y = s ? i(m, g, d, t, e, a) : i(g, m, d, e, t, a);
		if (void 0 !== y) {
			if (y) continue;
			p = !1;
			break;
		}
		if (f) {
			if (!rY(t, function(e, t) {
				if (!rV(f, t) && (g === e || n(g, e, r, i, a))) return f.push(t);
			})) {
				p = !1;
				break;
			}
		} else if (!(g === m || n(g, m, r, i, a))) {
			p = !1;
			break;
		}
	}
	return a.delete(e), a.delete(t), p;
}
function rX(e) {
	var t = -1, r = Array(e.size);
	return e.forEach(function(e, i) {
		r[++t] = [i, e];
	}), r;
}
function rK(e) {
	var t = -1, r = Array(e.size);
	return e.forEach(function(e) {
		r[++t] = e;
	}), r;
}
h(rz, "castFunction"), h(rU, "forEach"), h(rG, "baseFilter"), h(rq, "setCacheAdd"), h(rj, "setCacheHas"), h(rW, "SetCache"), rW.prototype.add = rW.prototype.push = rq, rW.prototype.has = rj, h(rY, "arraySome"), h(rV, "cacheHas"), h(rH, "equalArrays"), h(rX, "mapToArray"), h(rK, "setToArray");
var rZ = x ? x.prototype : void 0, rQ = rZ ? rZ.valueOf : void 0;
function rJ(e, t, r, i, n, a, s) {
	switch (r) {
		case "[object DataView]":
			if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset) break;
			e = e.buffer, t = t.buffer;
		case "[object ArrayBuffer]": return !(e.byteLength != t.byteLength || !a(new eO(e), new eO(t)));
		case "[object Boolean]":
		case "[object Date]":
		case "[object Number]": return ee(+e, +t);
		case "[object Error]": return e.name == t.name && e.message == t.message;
		case "[object RegExp]":
		case "[object String]": return e == t + "";
		case "[object Map]": var o = rX;
		case "[object Set]":
			var l = 1 & i;
			if (o || (o = rK), e.size != t.size && !l) break;
			var h = s.get(e);
			if (h) return h == t;
			i |= 2, s.set(e, t);
			var u = rH(o(e), o(t), i, n, a, s);
			return s.delete(e), u;
		case "[object Symbol]": if (rQ) return rQ.call(e) == rQ.call(t);
	}
	return !1;
}
h(rJ, "equalByTag");
var r0 = Object.prototype.hasOwnProperty;
function r1(e, t, r, i, n, a) {
	var s = 1 & r, o = rh(e), l = o.length;
	if (l != rh(t).length && !s) return !1;
	for (var h = l; h--;) {
		var u = o[h];
		if (!(s ? u in t : r0.call(t, u))) return !1;
	}
	var d = a.get(e), p = a.get(t);
	if (d && p) return d == t && p == e;
	var f = !0;
	a.set(e, t), a.set(t, e);
	for (var g = s; ++h < l;) {
		var m = e[u = o[h]], y = t[u];
		if (i) var v = s ? i(y, m, u, t, e, a) : i(m, y, u, e, t, a);
		if (!(void 0 === v ? m === y || n(m, y, r, i, a) : v)) {
			f = !1;
			break;
		}
		g || (g = "constructor" == u);
	}
	if (f && !g) {
		var x = e.constructor, b = t.constructor;
		x != b && "constructor" in e && "constructor" in t && !("function" == typeof x && x instanceof x && "function" == typeof b && b instanceof b) && (f = !1);
	}
	return a.delete(e), a.delete(t), f;
}
h(r1, "equalObjects");
var r2 = "[object Arguments]", r4 = "[object Array]", r5 = "[object Object]", r3 = Object.prototype.hasOwnProperty;
function r6(e, t, r, i, n, a) {
	var s = eQ(e), o = eQ(t), l = s ? r4 : t4(e), h = o ? r4 : t4(t);
	l = l == r2 ? r5 : l, h = h == r2 ? r5 : h;
	var u = l == r5, d = h == r5, p = l == h;
	if (p && e6(e)) {
		if (!e6(t)) return !1;
		s = !0, u = !1;
	}
	if (p && !u) return a || (a = new e_()), s || th(e) ? rH(e, t, r, i, n, a) : rJ(e, t, l, r, i, n, a);
	if (!(1 & r)) {
		var f = u && r3.call(e, "__wrapped__"), g = d && r3.call(t, "__wrapped__");
		if (f || g) {
			var m = f ? e.value() : e, y = g ? t.value() : t;
			return a || (a = new e_()), n(m, y, r, i, a);
		}
	}
	return !!p && (a || (a = new e_()), r1(e, t, r, i, n, a));
}
function r7(e, t, r, i, n) {
	return e === t || (null != e && null != t && (eY(e) || eY(t)) ? r6(e, t, r, i, r7, n) : e != e && t != t);
}
function r8(e, t, r, i) {
	var n = r.length, a = n, s = !i;
	if (null == e) return !a;
	for (e = Object(e); n--;) {
		var o = r[n];
		if (s && o[2] ? o[1] !== e[o[0]] : !(o[0] in e)) return !1;
	}
	for (; ++n < a;) {
		var l = (o = r[n])[0], h = e[l], u = o[1];
		if (s && o[2]) {
			if (void 0 === h && !(l in e)) return !1;
		} else {
			var d = new e_();
			if (i) var p = i(h, u, l, e, t, d);
			if (!(void 0 === p ? r7(u, h, 3, i, d) : p)) return !1;
		}
	}
	return !0;
}
function r9(e) {
	return e == e && !L(e);
}
function ie(e) {
	for (var t = t6(e), r = t.length; r--;) {
		var i = t[r], n = e[i];
		t[r] = [
			i,
			n,
			r9(n)
		];
	}
	return t;
}
function it(e, t) {
	return function(r) {
		return null != r && r[e] === t && (void 0 !== t || e in Object(r));
	};
}
function ir(e) {
	var t = ie(e);
	return 1 == t.length && t[0][2] ? it(t[0][0], t[0][1]) : function(r) {
		return r === e || r8(r, e, t);
	};
}
function ii(e) {
	return "symbol" == typeof e || eY(e) && "[object Symbol]" == A(e);
}
h(r6, "baseIsEqualDeep"), h(r7, "baseIsEqual"), h(r8, "baseIsMatch"), h(r9, "isStrictComparable"), h(ie, "getMatchData"), h(it, "matchesStrictComparable"), h(ir, "baseMatches"), h(ii, "isSymbol");
var ia = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, is = /^\w*$/;
function io(e, t) {
	if (eQ(e)) return !1;
	var r = typeof e;
	return !!("number" == r || "symbol" == r || "boolean" == r || null == e || ii(e)) || is.test(e) || !ia.test(e) || null != t && e in Object(t);
}
function il(e) {
	var t = ey(e, function(e) {
		return 500 === r.size && r.clear(), e;
	}), r = t.cache;
	return t;
}
h(io, "isKey"), h(il, "memoizeCapped");
var ic = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, ih = /\\(\\)?/g, iu = il(function(e) {
	var t = [];
	return 46 === e.charCodeAt(0) && t.push(""), e.replace(ic, function(e, r, i, n) {
		t.push(i ? n.replace(ih, "$1") : r || e);
	}), t;
});
function id(e, t) {
	for (var r = -1, i = null == e ? 0 : e.length, n = Array(i); ++r < i;) n[r] = t(e[r], r, e);
	return n;
}
h(id, "arrayMap");
var ip = Infinity, ig = x ? x.prototype : void 0, im = ig ? ig.toString : void 0;
function iy(e) {
	if ("string" == typeof e) return e;
	if (eQ(e)) return id(e, iy) + "";
	if (ii(e)) return im ? im.call(e) : "";
	var t = e + "";
	return "0" == t && 1 / e == -ip ? "-0" : t;
}
function iv(e) {
	return null == e ? "" : iy(e);
}
function ix(e, t) {
	return eQ(e) ? e : io(e, t) ? [e] : iu(iv(e));
}
h(iy, "baseToString"), h(iv, "toString"), h(ix, "castPath");
var ib = Infinity;
function iw(e) {
	if ("string" == typeof e || ii(e)) return e;
	var t = e + "";
	return "0" == t && 1 / e == -ib ? "-0" : t;
}
function ik(e, t) {
	t = ix(t, e);
	for (var r = 0, i = t.length; null != e && r < i;) e = e[iw(t[r++])];
	return r && r == i ? e : void 0;
}
function iT(e, t, r) {
	var i = null == e ? void 0 : ik(e, t);
	return void 0 === i ? r : i;
}
function i_(e, t) {
	return null != e && t in Object(e);
}
function iE(e, t, r) {
	t = ix(t, e);
	for (var i = -1, n = t.length, a = !1; ++i < n;) {
		var s = iw(t[i]);
		if (!(a = null != e && r(e, s))) break;
		e = e[s];
	}
	return a || ++i != n ? a : !!(n = null == e ? 0 : e.length) && eJ(n) && ty(s, n) && (eQ(e) || eZ(e));
}
function iC(e, t) {
	return null != e && iE(e, t, i_);
}
function iS(e, t) {
	return io(e) && r9(t) ? it(iw(e), t) : function(r) {
		var i = iT(r, e);
		return void 0 === i && i === t ? iC(r, e) : r7(t, i, 3);
	};
}
function iA(e) {
	return function(t) {
		return t?.[e];
	};
}
function iL(e) {
	return function(t) {
		return ik(t, e);
	};
}
function iR(e) {
	return io(e) ? iA(iw(e)) : iL(e);
}
function iN(e) {
	return "function" == typeof e ? e : null == e ? tS : "object" == typeof e ? eQ(e) ? iS(e[0], e[1]) : ir(e) : iR(e);
}
function iI(e, t) {
	return (eQ(e) ? re : rG)(e, iN(t, 3));
}
function iM(e, t) {
	var r = -1, i = e0(e) ? Array(e.length) : [];
	return rF(e, function(e, n, a) {
		i[++r] = t(e, n, a);
	}), i;
}
function iD(e, t) {
	return (eQ(e) ? id : iM)(e, iN(t, 3));
}
function iO(e, t) {
	return id(t, function(t) {
		return e[t];
	});
}
function i$(e) {
	return null == e ? [] : iO(e, t6(e));
}
function iP(e) {
	return void 0 === e;
}
function iB(e, t) {
	var r = {};
	return t = iN(t, 3), rP(e, function(e, i, n) {
		eC(r, i, t(e, i, n));
	}), r;
}
function iF(e, t, r) {
	for (var i = -1, n = e.length; ++i < n;) {
		var a = e[i], s = t(a);
		if (null != s && (void 0 === o ? s == s && !ii(s) : r(s, o))) var o = s, l = a;
	}
	return l;
}
function iz(e, t) {
	return e > t;
}
function iU(e) {
	return e && e.length ? iF(e, tS, iz) : void 0;
}
function iG(e, t, r, i) {
	if (!L(e)) return e;
	t = ix(t, e);
	for (var n = -1, a = t.length, s = a - 1, o = e; null != o && ++n < a;) {
		var l = iw(t[n]), h = r;
		if ("__proto__" === l || "constructor" === l || "prototype" === l) break;
		if (n != s) {
			var u = o[l];
			void 0 === (h = i ? i(u, l, o) : void 0) && (h = L(u) ? u : ty(t[n + 1]) ? [] : {});
		}
		tp(o, l, h), o = o[l];
	}
	return e;
}
function iq(e, t, r) {
	for (var i = -1, n = t.length, a = {}; ++i < n;) {
		var s = t[i], o = ik(e, s);
		r(o, s) && iG(a, ix(s, e), o);
	}
	return a;
}
function ij(e, t) {
	return iq(e, t, function(t, r) {
		return iC(e, r);
	});
}
h(iw, "toKey"), h(ik, "baseGet"), h(iT, "get"), h(i_, "baseHasIn"), h(iE, "hasPath"), h(iC, "hasIn"), h(iS, "baseMatchesProperty"), h(iA, "baseProperty"), h(iL, "basePropertyDeep"), h(iR, "property"), h(iN, "baseIteratee"), h(iI, "filter"), h(iM, "baseMap"), h(iD, "map"), h(iO, "baseValues"), h(i$, "values"), h(iP, "isUndefined"), h(iB, "mapValues"), h(iF, "baseExtremum"), h(iz, "baseGt"), h(iU, "max"), h(iG, "baseSet"), h(iq, "basePickBy"), h(ij, "basePick");
var iW = x ? x.isConcatSpreadable : void 0;
function iY(e) {
	return eQ(e) || eZ(e) || !!(iW && e && e[iW]);
}
function iV(e, t, r, i, n) {
	var a = -1, s = e.length;
	for (r || (r = iY), n || (n = []); ++a < s;) {
		var o = e[a];
		t > 0 && r(o) ? t > 1 ? iV(o, t - 1, r, i, n) : rs(n, o) : i || (n[n.length] = o);
	}
	return n;
}
function iH(e) {
	return (null == e ? 0 : e.length) ? iV(e, 1) : [];
}
function iX(e) {
	return tD(tR(e, void 0, iH), e + "");
}
h(iY, "isFlattenable"), h(iV, "baseFlatten"), h(iH, "flatten"), h(iX, "flatRest");
var iK = iX(function(e, t) {
	return null == e ? {} : ij(e, t);
});
function iZ(e, t, r, i) {
	var n = -1, a = null == e ? 0 : e.length;
	for (i && a && (r = e[++n]); ++n < a;) r = t(r, e[n], n, e);
	return r;
}
function iQ(e, t, r, i, n) {
	return n(e, function(e, n, a) {
		r = i ? (i = !1, e) : t(r, e, n, a);
	}), r;
}
function iJ(e, t, r) {
	var i = eQ(e) ? iZ : iQ, n = arguments.length < 3;
	return i(e, iN(t, 4), r, n, rF);
}
function i0(e, t, r, i) {
	for (var n = e.length, a = r + (i ? 1 : -1); i ? a-- : ++a < n;) if (t(e[a], a, e)) return a;
	return -1;
}
function i1(e) {
	return e != e;
}
function i2(e, t, r) {
	for (var i = r - 1, n = e.length; ++i < n;) if (e[i] === t) return i;
	return -1;
}
function i4(e, t, r) {
	return t == t ? i2(e, t, r) : i0(e, i1, r);
}
function i5(e, t) {
	return !!(null == e ? 0 : e.length) && i4(e, t, 0) > -1;
}
function i3(e, t, r) {
	for (var i = -1, n = null == e ? 0 : e.length; ++i < n;) if (r(t, e[i])) return !0;
	return !1;
}
function i6() {}
h(iZ, "arrayReduce"), h(iQ, "baseReduce"), h(iJ, "reduce"), h(i0, "baseFindIndex"), h(i1, "baseIsNaN"), h(i2, "strictIndexOf"), h(i4, "baseIndexOf"), h(i5, "arrayIncludes"), h(i3, "arrayIncludesWith"), h(i6, "noop");
var i7 = tj && 1 / rK(new tj([, -0]))[1] == Infinity ? function(e) {
	return new tj(e);
} : i6;
function i8(e, t, r) {
	var i = -1, n = i5, a = e.length, s = !0, o = [], l = o;
	if (r) s = !1, n = i3;
	else if (a >= 200) {
		var h = t ? null : i7(e);
		if (h) return rK(h);
		s = !1, n = rV, l = new rW();
	} else l = t ? [] : o;
	e: for (; ++i < a;) {
		var u = e[i], d = t ? t(u) : u;
		if (u = r || 0 !== u ? u : 0, s && d == d) {
			for (var p = l.length; p--;) if (l[p] === d) continue e;
			t && l.push(d), o.push(u);
		} else n(l, d, r) || (l !== o && l.push(d), o.push(u));
	}
	return o;
}
h(i8, "baseUniq");
var i9 = tO(function(e) {
	return i8(iV(e, 1, e1, !0));
}), ne = /\s/;
function nt(e) {
	for (var t = e.length; t-- && ne.test(e.charAt(t)););
	return t;
}
h(nt, "trimmedEndIndex");
var nr = /^\s+/;
function ni(e) {
	return e && e.slice(0, nt(e) + 1).replace(nr, "");
}
h(ni, "baseTrim");
var nn = NaN, na = /^[-+]0x[0-9a-f]+$/i, ns = /^0b[01]+$/i, no = /^0o[0-7]+$/i, nl = parseInt;
function nc(e) {
	if ("number" == typeof e) return e;
	if (ii(e)) return nn;
	if (L(e)) {
		var t = "function" == typeof e.valueOf ? e.valueOf() : e;
		e = L(t) ? t + "" : t;
	}
	if ("string" != typeof e) return 0 === e ? e : +e;
	e = ni(e);
	var r = ns.test(e);
	return r || no.test(e) ? nl(e.slice(2), r ? 2 : 8) : na.test(e) ? nn : +e;
}
h(nc, "toNumber");
var nh = Infinity;
function nu(e) {
	return e ? (e = nc(e)) === nh || e === -nh ? (e < 0 ? -1 : 1) * 17976931348623157e292 : e == e ? e : 0 : 0 === e ? e : 0;
}
function nd(e) {
	var t = nu(e), r = t % 1;
	return t == t ? r ? t - r : t : 0;
}
h(nu, "toFinite"), h(nd, "toInteger");
var np = Object.prototype.hasOwnProperty, nf = tP(function(e, t) {
	if (ej(t) || e0(t)) return void tf(t, t6(t), e);
	for (var r in t) np.call(t, r) && tp(e, r, t[r]);
});
function ng(e, t, r) {
	var i = -1, n = e.length;
	t < 0 && (t = -t > n ? 0 : n + t), (r = r > n ? n : r) < 0 && (r += n), n = t > r ? 0 : r - t >>> 0, t >>>= 0;
	for (var a = Array(n); ++i < n;) a[i] = e[i + t];
	return a;
}
h(ng, "baseSlice");
var nm = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]");
function ny(e) {
	return nm.test(e);
}
function nv(e) {
	return rN(e, 5);
}
function nx(e) {
	for (var t = -1, r = null == e ? 0 : e.length, i = 0, n = []; ++t < r;) {
		var a = e[t];
		a && (n[i++] = a);
	}
	return n;
}
function nb(e, t, r, i) {
	for (var n = -1, a = null == e ? 0 : e.length; ++n < a;) {
		var s = e[n];
		t(i, s, r(s), e);
	}
	return i;
}
function nw(e, t, r, i) {
	return rF(e, function(e, n, a) {
		t(i, e, r(e), a);
	}), i;
}
function nk(e, t) {
	return function(r, i) {
		var n = eQ(r) ? nb : nw, a = t ? t() : {};
		return n(r, e, iN(i, 2), a);
	};
}
h(ny, "hasUnicode"), h(nv, "cloneDeep"), h(nx, "compact"), h(nb, "arrayAggregator"), h(nw, "baseAggregator"), h(nk, "createAggregator");
var nT = h(function() {
	return v.Date.now();
}, "now");
function n_(e, t, r, i) {
	var n = -1, a = i5, s = !0, o = e.length, l = [], h = t.length;
	if (!o) return l;
	r && (t = id(t, tn(r))), i ? (a = i3, s = !1) : t.length >= 200 && (a = rV, s = !1, t = new rW(t));
	e: for (; ++n < o;) {
		var u = e[n], d = null == r ? u : r(u);
		if (u = i || 0 !== u ? u : 0, s && d == d) {
			for (var p = h; p--;) if (t[p] === d) continue e;
			l.push(u);
		} else a(t, d, i) || l.push(u);
	}
	return l;
}
h(n_, "baseDifference");
var nE = tO(function(e, t) {
	return e1(e) ? n_(e, iV(t, 1, e1, !0)) : [];
});
function nC(e, t, r) {
	var i = null == e ? 0 : e.length;
	return i ? ng(e, (t = r || void 0 === t ? 1 : nd(t)) < 0 ? 0 : t, i) : [];
}
function nS(e, t, r) {
	var i = null == e ? 0 : e.length;
	return i ? ng(e, 0, (t = i - (t = r || void 0 === t ? 1 : nd(t))) < 0 ? 0 : t) : [];
}
function nA(e, t) {
	for (var r = -1, i = null == e ? 0 : e.length; ++r < i;) if (!t(e[r], r, e)) return !1;
	return !0;
}
function nL(e, t) {
	var r = !0;
	return rF(e, function(e, i, n) {
		return r = !!t(e, i, n);
	}), r;
}
function nR(e, t, r) {
	var i = eQ(e) ? nA : nL;
	return r && t$(e, t, r) && (t = void 0), i(e, iN(t, 3));
}
function nN(e) {
	return function(t, r, i) {
		var n = Object(t);
		if (!e0(t)) {
			var a = iN(r, 3);
			t = t6(t), r = h(function(e) {
				return a(n[e], e, n);
			}, "predicate");
		}
		var s = e(t, r, i);
		return s > -1 ? n[a ? t[s] : s] : void 0;
	};
}
h(nC, "drop"), h(nS, "dropRight"), h(nA, "arrayEvery"), h(nL, "baseEvery"), h(nR, "every"), h(nN, "createFind");
var nI = Math.max;
function nM(e, t, r) {
	var i = null == e ? 0 : e.length;
	if (!i) return -1;
	var n = null == r ? 0 : nd(r);
	return n < 0 && (n = nI(i + n, 0)), i0(e, iN(t, 3), n);
}
h(nM, "findIndex");
var nD = nN(nM);
function nO(e) {
	return e && e.length ? e[0] : void 0;
}
function n$(e, t) {
	return iV(iD(e, t), 1);
}
function nP(e, t) {
	return null == e ? e : eL(e, rz(t), tT);
}
function nB(e, t) {
	return e && rP(e, rz(t));
}
h(nO, "head"), h(n$, "flatMap"), h(nP, "forIn"), h(nB, "forOwn");
var nF = Object.prototype.hasOwnProperty, nz = nk(function(e, t, r) {
	nF.call(e, r) ? e[r].push(t) : eC(e, r, [t]);
}), nU = Object.prototype.hasOwnProperty;
function nG(e, t) {
	return null != e && nU.call(e, t);
}
function nq(e, t) {
	return null != e && iE(e, t, nG);
}
function nj(e) {
	return "string" == typeof e || !eQ(e) && eY(e) && "[object String]" == A(e);
}
h(nG, "baseHas"), h(nq, "has"), h(nj, "isString");
var nW = Math.max;
function nY(e, t, r, i) {
	e = e0(e) ? e : i$(e), r = r && !i ? nd(r) : 0;
	var n = e.length;
	return r < 0 && (r = nW(n + r, 0)), nj(e) ? r <= n && e.indexOf(t, r) > -1 : !!n && i4(e, t, r) > -1;
}
h(nY, "includes");
var nV = Math.max;
function nH(e, t, r) {
	var i = null == e ? 0 : e.length;
	if (!i) return -1;
	var n = null == r ? 0 : nd(r);
	return n < 0 && (n = nV(i + n, 0)), i4(e, t, n);
}
function nX(e) {
	return eY(e) && "[object RegExp]" == A(e);
}
h(nH, "indexOf"), h(nX, "baseIsRegExp");
var nK = tl && tl.isRegExp, nZ = nK ? tn(nK) : nX;
function nQ(e, t) {
	return e < t;
}
function nJ(e) {
	return e && e.length ? iF(e, tS, nQ) : void 0;
}
function n0(e, t) {
	return e && e.length ? iF(e, iN(t, 2), nQ) : void 0;
}
function n1(e) {
	if ("function" != typeof e) throw TypeError("Expected a function");
	return function() {
		var t = arguments;
		switch (t.length) {
			case 0: return !e.call(this);
			case 1: return !e.call(this, t[0]);
			case 2: return !e.call(this, t[0], t[1]);
			case 3: return !e.call(this, t[0], t[1], t[2]);
		}
		return !e.apply(this, t);
	};
}
function n2(e, t) {
	if (null == e) return {};
	var r = id(ru(e), function(e) {
		return [e];
	});
	return t = iN(t), iq(e, r, function(e, r) {
		return t(e, r[0]);
	});
}
function n4(e, t) {
	var r = e.length;
	for (e.sort(t); r--;) e[r] = e[r].value;
	return e;
}
function n5(e, t) {
	if (e !== t) {
		var r = void 0 !== e, i = null === e, n = e == e, a = ii(e), s = void 0 !== t, o = null === t, l = t == t, h = ii(t);
		if (!o && !h && !a && e > t || a && s && l && !o && !h || i && s && l || !r && l || !n) return 1;
		if (!i && !a && !h && e < t || h && r && n && !i && !a || o && r && n || !s && n || !l) return -1;
	}
	return 0;
}
function n3(e, t, r) {
	for (var i = -1, n = e.criteria, a = t.criteria, s = n.length, o = r.length; ++i < s;) {
		var l = n5(n[i], a[i]);
		if (l) {
			if (i >= o) return l;
			return l * ("desc" == r[i] ? -1 : 1);
		}
	}
	return e.index - t.index;
}
function n6(e, t, r) {
	t = t.length ? id(t, function(e) {
		return eQ(e) ? function(t) {
			return ik(t, 1 === e.length ? e[0] : e);
		} : e;
	}) : [tS];
	var i = -1;
	return t = id(t, tn(iN)), n4(iM(e, function(e, r, n) {
		return {
			criteria: id(t, function(t) {
				return t(e);
			}),
			index: ++i,
			value: e
		};
	}), function(e, t) {
		return n3(e, t, r);
	});
}
h(nQ, "baseLt"), h(nJ, "min"), h(n0, "minBy"), h(n1, "negate"), h(n2, "pickBy"), h(n4, "baseSortBy"), h(n5, "compareAscending"), h(n3, "compareMultiple"), h(n6, "baseOrderBy");
var n7 = iA("length"), n8 = "\\ud800-\\udfff", n9 = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]", ae = "\\ud83c[\\udffb-\\udfff]", at = "[^" + n8 + "]", ar = "(?:\\ud83c[\\udde6-\\uddff]){2}", ai = "[\\ud800-\\udbff][\\udc00-\\udfff]", an = "(?:" + n9 + "|" + ae + ")?", aa = "[\\ufe0e\\ufe0f]?", as = "(?:\\u200d(?:" + [
	at,
	ar,
	ai
].join("|") + ")" + aa + an + ")*", ao = RegExp(ae + "(?=" + ae + ")|" + ("(?:" + [
	at + n9 + "?",
	n9,
	ar,
	ai,
	"[" + n8 + "]"
].join("|")) + ")" + (aa + an + as), "g");
function al(e) {
	for (var t = ao.lastIndex = 0; ao.test(e);) ++t;
	return t;
}
function ac(e) {
	return ny(e) ? al(e) : n7(e);
}
h(al, "unicodeSize"), h(ac, "stringSize");
var ah = Math.ceil, au = Math.max;
function ad(e, t, r, i) {
	for (var n = -1, a = au(ah((t - e) / (r || 1)), 0), s = Array(a); a--;) s[i ? a : ++n] = e, e += r;
	return s;
}
function ap(e) {
	return function(t, r, i) {
		return i && "number" != typeof i && t$(t, r, i) && (r = i = void 0), t = nu(t), void 0 === r ? (r = t, t = 0) : r = nu(r), i = void 0 === i ? t < r ? 1 : -1 : nu(i), ad(t, r, i, e);
	};
}
h(ad, "baseRange"), h(ap, "createRange");
var af = ap();
function ag(e, t) {
	return (eQ(e) ? re : rG)(e, n1(iN(t, 3)));
}
function am(e) {
	if (null == e) return 0;
	if (e0(e)) return nj(e) ? ac(e) : e.length;
	var t = t4(e);
	return "[object Map]" == t || "[object Set]" == t ? e.size : tU(e).length;
}
function ay(e, t) {
	var r;
	return rF(e, function(e, i, n) {
		return !(r = t(e, i, n));
	}), !!r;
}
function av(e, t, r) {
	var i = eQ(e) ? rY : ay;
	return r && t$(e, t, r) && (t = void 0), i(e, iN(t, 3));
}
h(ag, "reject"), h(am, "size"), h(ay, "baseSome"), h(av, "some");
var ax = tO(function(e, t) {
	if (null == e) return [];
	var r = t.length;
	return r > 1 && t$(e, t[0], t[1]) ? t = [] : r > 2 && t$(t[0], t[1], t[2]) && (t = [t[0]]), n6(e, iV(t, 1), []);
});
function ab(e) {
	return e && e.length ? i8(e) : [];
}
function aw(e, t) {
	return e && e.length ? i8(e, iN(t, 2)) : [];
}
h(ab, "uniq"), h(aw, "uniqBy");
var ak = 0;
function aT(e) {
	var t = ++ak;
	return iv(e) + t;
}
function a_(e, t, r) {
	for (var i = -1, n = e.length, a = t.length, s = {}; ++i < n;) {
		var o = i < a ? t[i] : void 0;
		r(s, e[i], o);
	}
	return s;
}
function aE(e, t) {
	return a_(e || [], t || [], tp);
}
h(aT, "uniqueId"), h(a_, "baseZipObject"), h(aE, "zipObject");
var aC = u((e) => {
	function t() {
		if (void 0 === r) throw Error("No runtime abstraction layer installed");
		return r;
	}
	Object.defineProperty(e, "__esModule", { value: !0 }), h(t, "RAL");
	var r, i = t || (t = {});
	function n(e) {
		if (void 0 === e) throw Error("No runtime abstraction layer provided");
		r = e;
	}
	h(n, "install"), i.install = n, e.default = t;
}), aS = u((e) => {
	function t(e) {
		return !0 === e || !1 === e;
	}
	function r(e) {
		return "string" == typeof e || e instanceof String;
	}
	function i(e) {
		return "number" == typeof e || e instanceof Number;
	}
	function n(e) {
		return e instanceof Error;
	}
	function a(e) {
		return "function" == typeof e;
	}
	function s(e) {
		return Array.isArray(e);
	}
	function o(e) {
		return s(e) && e.every((e) => r(e));
	}
	Object.defineProperty(e, "__esModule", { value: !0 }), e.stringArray = e.array = e.func = e.error = e.number = e.string = e.boolean = void 0, h(t, "boolean"), e.boolean = t, h(r, "string"), e.string = r, h(i, "number"), e.number = i, h(n, "error"), e.error = n, h(a, "func"), e.func = a, h(s, "array"), e.array = s, h(o, "stringArray"), e.stringArray = o;
}), aA = u((e) => {
	let t;
	Object.defineProperty(e, "__esModule", { value: !0 }), e.Emitter = e.Event = void 0;
	var r, i, n = aC();
	r = i || (e.Event = i = {}), t = { dispose() {} }, r.None = function() {
		return t;
	};
	var a = class {
		static {
			h(this, "CallbackList");
		}
		add(e, t = null, r) {
			this._callbacks || (this._callbacks = [], this._contexts = []), this._callbacks.push(e), this._contexts.push(t), Array.isArray(r) && r.push({ dispose: h(() => this.remove(e, t), "dispose") });
		}
		remove(e, t = null) {
			if (!this._callbacks) return;
			let r = !1;
			for (let i = 0, n = this._callbacks.length; i < n; i++) if (this._callbacks[i] === e) if (this._contexts[i] === t) {
				this._callbacks.splice(i, 1), this._contexts.splice(i, 1);
				return;
			} else r = !0;
			if (r) throw Error("When adding a listener with a context, you should remove it with the same context");
		}
		invoke(...e) {
			if (!this._callbacks) return [];
			let t = [], r = this._callbacks.slice(0), i = this._contexts.slice(0);
			for (let a = 0, s = r.length; a < s; a++) try {
				t.push(r[a].apply(i[a], e));
			} catch (e) {
				(0, n.default)().console.error(e);
			}
			return t;
		}
		isEmpty() {
			return !this._callbacks || 0 === this._callbacks.length;
		}
		dispose() {
			this._callbacks = void 0, this._contexts = void 0;
		}
	}, s = class e {
		static {
			h(this, "Emitter");
		}
		constructor(e) {
			this._options = e;
		}
		get event() {
			return this._event || (this._event = (t, r, i) => {
				this._callbacks || (this._callbacks = new a()), this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty() && this._options.onFirstListenerAdd(this), this._callbacks.add(t, r);
				let n = { dispose: h(() => {
					this._callbacks && (this._callbacks.remove(t, r), n.dispose = e._noop, this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty() && this._options.onLastListenerRemove(this));
				}, "dispose") };
				return Array.isArray(i) && i.push(n), n;
			}), this._event;
		}
		fire(e) {
			this._callbacks && this._callbacks.invoke.call(this._callbacks, e);
		}
		dispose() {
			this._callbacks && (this._callbacks.dispose(), this._callbacks = void 0);
		}
	};
	e.Emitter = s, s._noop = function() {};
}), aL = u((e) => {
	Object.defineProperty(e, "__esModule", { value: !0 }), e.CancellationTokenSource = e.CancellationToken = void 0;
	var t, r = aC(), i = aS(), n = aA(), a = t || (e.CancellationToken = t = {});
	function s(e) {
		return e && (e === a.None || e === a.Cancelled || i.boolean(e.isCancellationRequested) && !!e.onCancellationRequested);
	}
	a.None = Object.freeze({
		isCancellationRequested: !1,
		onCancellationRequested: n.Event.None
	}), a.Cancelled = Object.freeze({
		isCancellationRequested: !0,
		onCancellationRequested: n.Event.None
	}), h(s, "is"), a.is = s;
	var o = Object.freeze(function(e, t) {
		let i = (0, r.default)().timer.setTimeout(e.bind(t), 0);
		return { dispose() {
			i.dispose();
		} };
	}), l = class {
		static {
			h(this, "MutableToken");
		}
		constructor() {
			this._isCancelled = !1;
		}
		cancel() {
			this._isCancelled || (this._isCancelled = !0, this._emitter && (this._emitter.fire(void 0), this.dispose()));
		}
		get isCancellationRequested() {
			return this._isCancelled;
		}
		get onCancellationRequested() {
			return this._isCancelled ? o : (this._emitter || (this._emitter = new n.Emitter()), this._emitter.event);
		}
		dispose() {
			this._emitter && (this._emitter.dispose(), this._emitter = void 0);
		}
	};
	e.CancellationTokenSource = class {
		static {
			h(this, "CancellationTokenSource");
		}
		get token() {
			return this._token || (this._token = new l()), this._token;
		}
		cancel() {
			this._token ? this._token.cancel() : this._token = t.Cancelled;
		}
		dispose() {
			this._token ? this._token instanceof l && this._token.dispose() : this._token = t.None;
		}
	};
}), aR = {};
d(aR, {
	AbstractAstReflection: () => a$,
	AbstractCstNode: () => yN,
	AbstractLangiumParser: () => yF,
	AbstractParserErrorMessageProvider: () => yU,
	AbstractThreadedAsyncParser: () => xF,
	AstUtils: () => oG,
	BiMap: () => v$,
	Cancellation: () => va,
	CompositeCstNodeImpl: () => yM,
	ContextCache: () => vq,
	CstNodeBuilder: () => yR,
	CstUtils: () => aN,
	DEFAULT_TOKENIZE_OPTIONS: () => xn,
	DONE_RESULT: () => aj,
	DatatypeSymbol: () => y$,
	DefaultAstNodeDescriptionProvider: () => v4,
	DefaultAstNodeLocator: () => v3,
	DefaultAsyncParser: () => xB,
	DefaultCommentProvider: () => xP,
	DefaultConfigurationProvider: () => v7,
	DefaultDocumentBuilder: () => xe,
	DefaultDocumentValidator: () => vJ,
	DefaultHydrator: () => xG,
	DefaultIndexManager: () => xt,
	DefaultJsonSerializer: () => vX,
	DefaultLangiumDocumentFactory: () => vA,
	DefaultLangiumDocuments: () => vL,
	DefaultLexer: () => xa,
	DefaultLexerErrorMessageProvider: () => xi,
	DefaultLinker: () => vN,
	DefaultNameProvider: () => vM,
	DefaultReferenceDescriptionProvider: () => v5,
	DefaultReferences: () => vD,
	DefaultScopeComputation: () => vP,
	DefaultScopeProvider: () => vY,
	DefaultServiceRegistry: () => vK,
	DefaultTokenBuilder: () => vi,
	DefaultValueConverter: () => vn,
	DefaultWorkspaceLock: () => xU,
	DefaultWorkspaceManager: () => xr,
	Deferred: () => vg,
	Disposable: () => x5,
	DisposableCache: () => vU,
	DocumentCache: () => vj,
	DocumentState: () => x1,
	DocumentValidator: () => x4,
	EMPTY_SCOPE: () => vz,
	EMPTY_STREAM: () => aq,
	EmptyFileSystem: () => br,
	EmptyFileSystemProvider: () => bt,
	ErrorWithLocation: () => ss,
	GrammarAST: () => sl,
	GrammarUtils: () => sa,
	IndentationAwareLexer: () => x9,
	IndentationAwareTokenBuilder: () => x8,
	JSDocDocumentationProvider: () => x$,
	LangiumCompletionParser: () => yq,
	LangiumParser: () => yz,
	LangiumParserErrorMessageProvider: () => yG,
	LeafCstNodeImpl: () => yI,
	LexingMode: () => x6,
	MapScope: () => vF,
	Module: () => x3,
	MultiMap: () => vO,
	OperationCancelled: () => vu,
	ParserWorker: () => xz,
	Reduction: () => aV,
	RegExpUtils: () => o4,
	RootCstNodeImpl: () => yO,
	SimpleCache: () => vG,
	StreamImpl: () => az,
	StreamScope: () => vB,
	TextDocument: () => vf,
	TreeStreamImpl: () => aH,
	URI: () => vC,
	UriUtils: () => x0,
	ValidationCategory: () => x2,
	ValidationRegistry: () => vQ,
	ValueConverter: () => vr,
	WorkspaceCache: () => vW,
	assertUnreachable: () => so,
	createCompletionParser: () => y9,
	createDefaultCoreModule: () => xq,
	createDefaultSharedCoreModule: () => xj,
	createGrammarConfig: () => l4,
	createLangiumParser: () => ve,
	createParser: () => yY,
	delayNextTick: () => vs,
	diagnosticData: () => vZ,
	eagerLoad: () => xV,
	getDiagnosticRange: () => v0,
	indentationBuilderDefaultOptions: () => x7,
	inject: () => xW,
	interruptAndCheck: () => vp,
	isAstNode: () => aI,
	isAstNodeDescription: () => aD,
	isAstNodeWithComment: () => vV,
	isCompositeCstNode: () => aP,
	isIMultiModeLexerDefinition: () => xo,
	isJSDoc: () => xh,
	isLeafCstNode: () => aB,
	isLinkingError: () => aO,
	isNamed: () => vI,
	isOperationCancelled: () => vd,
	isReference: () => aM,
	isRootCstNode: () => aF,
	isTokenTypeArray: () => xs,
	isTokenTypeDictionary: () => xl,
	loadGrammarFromJson: () => bs,
	parseJSDoc: () => xc,
	prepareLangiumParser: () => vt,
	setInterruptionPeriod: () => vh,
	startCancelableOperation: () => vc,
	stream: () => aW,
	toDiagnosticData: () => v2,
	toDiagnosticSeverity: () => v1
});
var aN = {};
function aI(e) {
	return "object" == typeof e && null !== e && "string" == typeof e.$type;
}
function aM(e) {
	return "object" == typeof e && null !== e && "string" == typeof e.$refText;
}
function aD(e) {
	return "object" == typeof e && null !== e && "string" == typeof e.name && "string" == typeof e.type && "string" == typeof e.path;
}
function aO(e) {
	return "object" == typeof e && null !== e && aI(e.container) && aM(e.reference) && "string" == typeof e.message;
}
d(aN, {
	DefaultNameRegexp: () => a2,
	RangeComparison: () => dS,
	compareRange: () => a0,
	findCommentNode: () => a5,
	findDeclarationNodeAtOffset: () => a4,
	findLeafNodeAtOffset: () => a6,
	findLeafNodeBeforeOffset: () => a7,
	flattenCst: () => aK,
	getInteriorNodes: () => sr,
	getNextNode: () => se,
	getPreviousNode: () => a9,
	getStartlineNode: () => st,
	inRange: () => a1,
	isChildNode: () => aZ,
	isCommentNode: () => a3,
	streamCst: () => aX,
	toDocumentSegment: () => aJ,
	tokenToRange: () => aQ
}), h(aI, "isAstNode"), h(aM, "isReference"), h(aD, "isAstNodeDescription"), h(aO, "isLinkingError");
var a$ = class {
	static {
		h(this, "AbstractAstReflection");
	}
	constructor() {
		this.subtypes = {}, this.allSubtypes = {};
	}
	isInstance(e, t) {
		return aI(e) && this.isSubtype(e.$type, t);
	}
	isSubtype(e, t) {
		if (e === t) return !0;
		let r = this.subtypes[e];
		r || (r = this.subtypes[e] = {});
		let i = r[t];
		if (void 0 !== i) return i;
		{
			let i = this.computeIsSubtype(e, t);
			return r[t] = i, i;
		}
	}
	getAllSubTypes(e) {
		let t = this.allSubtypes[e];
		if (t) return t;
		{
			let t = this.getAllTypes(), r = [];
			for (let i of t) this.isSubtype(i, e) && r.push(i);
			return this.allSubtypes[e] = r, r;
		}
	}
};
function aP(e) {
	return "object" == typeof e && null !== e && Array.isArray(e.content);
}
function aB(e) {
	return "object" == typeof e && null !== e && "object" == typeof e.tokenType;
}
function aF(e) {
	return aP(e) && "string" == typeof e.fullText;
}
h(aP, "isCompositeCstNode"), h(aB, "isLeafCstNode"), h(aF, "isRootCstNode");
var az = class e {
	static {
		h(this, "StreamImpl");
	}
	constructor(e, t) {
		this.startFn = e, this.nextFn = t;
	}
	iterator() {
		let e = {
			state: this.startFn(),
			next: h(() => this.nextFn(e.state), "next"),
			[Symbol.iterator]: () => e
		};
		return e;
	}
	[Symbol.iterator]() {
		return this.iterator();
	}
	isEmpty() {
		return !!this.iterator().next().done;
	}
	count() {
		let e = this.iterator(), t = 0, r = e.next();
		for (; !r.done;) t++, r = e.next();
		return t;
	}
	toArray() {
		let e = [], t = this.iterator(), r;
		do
			void 0 !== (r = t.next()).value && e.push(r.value);
		while (!r.done);
		return e;
	}
	toSet() {
		return new Set(this);
	}
	toMap(e, t) {
		return new Map(this.map((r) => [e ? e(r) : r, t ? t(r) : r]));
	}
	toString() {
		return this.join();
	}
	concat(t) {
		return new e(() => ({
			first: this.startFn(),
			firstDone: !1,
			iterator: t[Symbol.iterator]()
		}), (e) => {
			let t;
			if (!e.firstDone) {
				do
					if (!(t = this.nextFn(e.first)).done) return t;
				while (!t.done);
				e.firstDone = !0;
			}
			do
				if (!(t = e.iterator.next()).done) return t;
			while (!t.done);
			return aj;
		});
	}
	join(e = ",") {
		let t = this.iterator(), r = "", i, n = !1;
		do
			(i = t.next()).done || (n && (r += e), r += aU(i.value)), n = !0;
		while (!i.done);
		return r;
	}
	indexOf(e, t = 0) {
		let r = this.iterator(), i = 0, n = r.next();
		for (; !n.done;) {
			if (i >= t && n.value === e) return i;
			n = r.next(), i++;
		}
		return -1;
	}
	every(e) {
		let t = this.iterator(), r = t.next();
		for (; !r.done;) {
			if (!e(r.value)) return !1;
			r = t.next();
		}
		return !0;
	}
	some(e) {
		let t = this.iterator(), r = t.next();
		for (; !r.done;) {
			if (e(r.value)) return !0;
			r = t.next();
		}
		return !1;
	}
	forEach(e) {
		let t = this.iterator(), r = 0, i = t.next();
		for (; !i.done;) e(i.value, r), i = t.next(), r++;
	}
	map(t) {
		return new e(this.startFn, (e) => {
			let { done: r, value: i } = this.nextFn(e);
			return r ? aj : {
				done: !1,
				value: t(i)
			};
		});
	}
	filter(t) {
		return new e(this.startFn, (e) => {
			let r;
			do
				if (!(r = this.nextFn(e)).done && t(r.value)) return r;
			while (!r.done);
			return aj;
		});
	}
	nonNullable() {
		return this.filter((e) => null != e);
	}
	reduce(e, t) {
		let r = this.iterator(), i = t, n = r.next();
		for (; !n.done;) i = void 0 === i ? n.value : e(i, n.value), n = r.next();
		return i;
	}
	reduceRight(e, t) {
		return this.recursiveReduce(this.iterator(), e, t);
	}
	recursiveReduce(e, t, r) {
		let i = e.next();
		if (i.done) return r;
		let n = this.recursiveReduce(e, t, r);
		return void 0 === n ? i.value : t(n, i.value);
	}
	find(e) {
		let t = this.iterator(), r = t.next();
		for (; !r.done;) {
			if (e(r.value)) return r.value;
			r = t.next();
		}
	}
	findIndex(e) {
		let t = this.iterator(), r = 0, i = t.next();
		for (; !i.done;) {
			if (e(i.value)) return r;
			i = t.next(), r++;
		}
		return -1;
	}
	includes(e) {
		let t = this.iterator(), r = t.next();
		for (; !r.done;) {
			if (r.value === e) return !0;
			r = t.next();
		}
		return !1;
	}
	flatMap(t) {
		return new e(() => ({ this: this.startFn() }), (e) => {
			do {
				if (e.iterator) {
					let t = e.iterator.next();
					if (!t.done) return t;
					e.iterator = void 0;
				}
				let { done: r, value: i } = this.nextFn(e.this);
				if (!r) {
					let r = t(i);
					if (!aG(r)) return {
						done: !1,
						value: r
					};
					e.iterator = r[Symbol.iterator]();
				}
			} while (e.iterator);
			return aj;
		});
	}
	flat(t) {
		if (void 0 === t && (t = 1), t <= 0) return this;
		let r = t > 1 ? this.flat(t - 1) : this;
		return new e(() => ({ this: r.startFn() }), (e) => {
			do {
				if (e.iterator) {
					let t = e.iterator.next();
					if (!t.done) return t;
					e.iterator = void 0;
				}
				let { done: t, value: i } = r.nextFn(e.this);
				if (!t) if (!aG(i)) return {
					done: !1,
					value: i
				};
				else e.iterator = i[Symbol.iterator]();
			} while (e.iterator);
			return aj;
		});
	}
	head() {
		let e = this.iterator().next();
		if (!e.done) return e.value;
	}
	tail(t = 1) {
		return new e(() => {
			let e = this.startFn();
			for (let r = 0; r < t && !this.nextFn(e).done; r++);
			return e;
		}, this.nextFn);
	}
	limit(t) {
		return new e(() => ({
			size: 0,
			state: this.startFn()
		}), (e) => (e.size++, e.size > t ? aj : this.nextFn(e.state)));
	}
	distinct(t) {
		return new e(() => ({
			set: /* @__PURE__ */ new Set(),
			internalState: this.startFn()
		}), (e) => {
			let r;
			do
				if (!(r = this.nextFn(e.internalState)).done) {
					let i = t ? t(r.value) : r.value;
					if (!e.set.has(i)) return e.set.add(i), r;
				}
			while (!r.done);
			return aj;
		});
	}
	exclude(e, t) {
		let r = /* @__PURE__ */ new Set();
		for (let i of e) {
			let e = t ? t(i) : i;
			r.add(e);
		}
		return this.filter((e) => {
			let i = t ? t(e) : e;
			return !r.has(i);
		});
	}
};
function aU(e) {
	return "string" == typeof e ? e : typeof e > "u" ? "undefined" : "function" == typeof e.toString ? e.toString() : Object.prototype.toString.call(e);
}
function aG(e) {
	return !!e && "function" == typeof e[Symbol.iterator];
}
h(aU, "toString"), h(aG, "isIterable");
var aq = new az(() => {}, () => aj), aj = Object.freeze({
	done: !0,
	value: void 0
});
function aW(...e) {
	if (1 === e.length) {
		let t = e[0];
		if (t instanceof az) return t;
		if (aG(t)) return new az(() => t[Symbol.iterator](), (e) => e.next());
		if ("number" == typeof t.length) return new az(() => ({ index: 0 }), (e) => e.index < t.length ? {
			done: !1,
			value: t[e.index++]
		} : aj);
	}
	return e.length > 1 ? new az(() => ({
		collIndex: 0,
		arrIndex: 0
	}), (t) => {
		do {
			if (t.iterator) {
				let e = t.iterator.next();
				if (!e.done) return e;
				t.iterator = void 0;
			}
			if (t.array) {
				if (t.arrIndex < t.array.length) return {
					done: !1,
					value: t.array[t.arrIndex++]
				};
				t.array = void 0, t.arrIndex = 0;
			}
			if (t.collIndex < e.length) {
				let r = e[t.collIndex++];
				aG(r) ? t.iterator = r[Symbol.iterator]() : r && "number" == typeof r.length && (t.array = r);
			}
		} while (t.iterator || t.array || t.collIndex < e.length);
		return aj;
	}) : aq;
}
h(aW, "stream");
var aY, aV, aH = class extends az {
	static {
		h(this, "TreeStreamImpl");
	}
	constructor(e, t, r) {
		super(() => ({
			iterators: r?.includeRoot ? [[e][Symbol.iterator]()] : [t(e)[Symbol.iterator]()],
			pruned: !1
		}), (e) => {
			for (e.pruned && (e.iterators.pop(), e.pruned = !1); e.iterators.length > 0;) {
				let r = e.iterators[e.iterators.length - 1].next();
				if (!r.done) return e.iterators.push(t(r.value)[Symbol.iterator]()), r;
				e.iterators.pop();
			}
			return aj;
		});
	}
	iterator() {
		let e = {
			state: this.startFn(),
			next: h(() => this.nextFn(e.state), "next"),
			prune: h(() => {
				e.state.pruned = !0;
			}, "prune"),
			[Symbol.iterator]: () => e
		};
		return e;
	}
};
function aX(e) {
	return new aH(e, (e) => aP(e) ? e.content : [], { includeRoot: !0 });
}
function aK(e) {
	return aX(e).filter(aB);
}
function aZ(e, t) {
	for (; e.container;) if ((e = e.container) === t) return !0;
	return !1;
}
function aQ(e) {
	return {
		start: {
			character: e.startColumn - 1,
			line: e.startLine - 1
		},
		end: {
			character: e.endColumn,
			line: e.endLine - 1
		}
	};
}
function aJ(e) {
	if (!e) return;
	let { offset: t, end: r, range: i } = e;
	return {
		range: i,
		offset: t,
		end: r,
		length: r - t
	};
}
function a0(e, t) {
	if (e.end.line < t.start.line || e.end.line === t.start.line && e.end.character <= t.start.character) return dS.Before;
	if (e.start.line > t.end.line || e.start.line === t.end.line && e.start.character >= t.end.character) return dS.After;
	let r = e.start.line > t.start.line || e.start.line === t.start.line && e.start.character >= t.start.character, i = e.end.line < t.end.line || e.end.line === t.end.line && e.end.character <= t.end.character;
	return r && i ? dS.Inside : r ? dS.OverlapBack : i ? dS.OverlapFront : dS.Outside;
}
function a1(e, t) {
	return a0(e, t) > dS.After;
}
(function(e) {
	function t(e) {
		return e.reduce((e, t) => e + t, 0);
	}
	function r(e) {
		return e.reduce((e, t) => e * t, 0);
	}
	function i(e) {
		return e.reduce((e, t) => Math.min(e, t));
	}
	function n(e) {
		return e.reduce((e, t) => Math.max(e, t));
	}
	h(t, "sum"), e.sum = t, h(r, "product"), e.product = r, h(i, "min"), e.min = i, h(n, "max"), e.max = n;
})(aV || (aV = {})), h(aX, "streamCst"), h(aK, "flattenCst"), h(aZ, "isChildNode"), h(aQ, "tokenToRange"), h(aJ, "toDocumentSegment"), (dT = dS || (dS = {}))[dT.Before = 0] = "Before", dT[dT.After = 1] = "After", dT[dT.OverlapFront = 2] = "OverlapFront", dT[dT.OverlapBack = 3] = "OverlapBack", dT[dT.Inside = 4] = "Inside", dT[dT.Outside = 5] = "Outside", h(a0, "compareRange"), h(a1, "inRange");
var a2 = /^[\w\p{L}]$/u;
function a4(e, t, r = a2) {
	if (e) {
		if (t > 0) {
			let i = t - e.offset, n = e.text.charAt(i);
			r.test(n) || t--;
		}
		return a6(e, t);
	}
}
function a5(e, t) {
	if (e) {
		let r = a9(e, !0);
		if (r && a3(r, t)) return r;
		if (aF(e)) {
			let r = e.content.findIndex((e) => !e.hidden);
			for (let i = r - 1; i >= 0; i--) {
				let r = e.content[i];
				if (a3(r, t)) return r;
			}
		}
	}
}
function a3(e, t) {
	return aB(e) && t.includes(e.tokenType.name);
}
function a6(e, t) {
	if (aB(e)) return e;
	if (aP(e)) {
		let r = a8(e, t, !1);
		if (r) return a6(r, t);
	}
}
function a7(e, t) {
	if (aB(e)) return e;
	if (aP(e)) {
		let r = a8(e, t, !0);
		if (r) return a7(r, t);
	}
}
function a8(e, t, r) {
	let i = 0, n = e.content.length - 1, a;
	for (; i <= n;) {
		let s = Math.floor((i + n) / 2), o = e.content[s];
		if (o.offset <= t && o.end > t) return o;
		o.end <= t ? (a = r ? o : void 0, i = s + 1) : n = s - 1;
	}
	return a;
}
function a9(e, t = !0) {
	for (; e.container;) {
		let r = e.container, i = r.content.indexOf(e);
		for (; i > 0;) {
			i--;
			let e = r.content[i];
			if (t || !e.hidden) return e;
		}
		e = r;
	}
}
function se(e, t = !0) {
	for (; e.container;) {
		let r = e.container, i = r.content.indexOf(e), n = r.content.length - 1;
		for (; i < n;) {
			i++;
			let e = r.content[i];
			if (t || !e.hidden) return e;
		}
		e = r;
	}
}
function st(e) {
	if (0 === e.range.start.character) return e;
	let t = e.range.start.line, r = e, i;
	for (; e.container;) {
		let n = e.container, a = i ?? n.content.indexOf(e);
		if (0 === a ? (e = n, i = void 0) : (i = a - 1, e = n.content[i]), e.range.start.line !== t) break;
		r = e;
	}
	return r;
}
function sr(e, t) {
	let r = si(e, t);
	return r ? r.parent.content.slice(r.a + 1, r.b) : [];
}
function si(e, t) {
	let r = sn(e), i = sn(t), n;
	for (let e = 0; e < r.length && e < i.length; e++) {
		let t = r[e], a = i[e];
		if (t.parent === a.parent) n = {
			parent: t.parent,
			a: t.index,
			b: a.index
		};
		else break;
	}
	return n;
}
function sn(e) {
	let t = [];
	for (; e.container;) {
		let r = e.container, i = r.content.indexOf(e);
		t.push({
			parent: r,
			index: i
		}), e = r;
	}
	return t.reverse();
}
h(a4, "findDeclarationNodeAtOffset"), h(a5, "findCommentNode"), h(a3, "isCommentNode"), h(a6, "findLeafNodeAtOffset"), h(a7, "findLeafNodeBeforeOffset"), h(a8, "binarySearch"), h(a9, "getPreviousNode"), h(se, "getNextNode"), h(st, "getStartlineNode"), h(sr, "getInteriorNodes"), h(si, "getCommonParent"), h(sn, "getParentChain");
var sa = {};
d(sa, {
	findAssignment: () => lN,
	findNameAssignment: () => lI,
	findNodeForKeyword: () => lL,
	findNodeForProperty: () => lC,
	findNodesForKeyword: () => lA,
	findNodesForKeywordInternal: () => lR,
	findNodesForProperty: () => lE,
	getActionAtElement: () => lD,
	getActionType: () => lj,
	getAllReachableRules: () => lw,
	getCrossReferenceTerminal: () => lT,
	getEntryRule: () => lx,
	getExplicitRuleType: () => lG,
	getHiddenRules: () => lb,
	getRuleType: () => lY,
	getRuleTypeName: () => lW,
	getTypeName: () => lq,
	isArrayCardinality: () => l$,
	isArrayOperator: () => lP,
	isCommentTerminal: () => l_,
	isDataType: () => lz,
	isDataTypeRule: () => lB,
	isOptionalCardinality: () => lO,
	terminalRegex: () => lV
});
var ss = class extends Error {
	static {
		h(this, "ErrorWithLocation");
	}
	constructor(e, t) {
		super(e ? `${t} at ${e.range.start.line}:${e.range.start.character}` : t);
	}
};
function so(e) {
	throw Error("Error! The input value was not handled.");
}
h(so, "assertUnreachable");
var sl = {};
d(sl, {
	AbstractElement: () => sk,
	AbstractRule: () => sh,
	AbstractType: () => sd,
	Action: () => os,
	Alternatives: () => ol,
	ArrayLiteral: () => s_,
	ArrayType: () => sC,
	Assignment: () => oh,
	BooleanLiteral: () => sA,
	CharacterRange: () => od,
	Condition: () => sf,
	Conjunction: () => sR,
	CrossReference: () => of,
	Disjunction: () => sI,
	EndOfFile: () => om,
	Grammar: () => sD,
	GrammarImport: () => s$,
	Group: () => ov,
	InferredType: () => sB,
	Interface: () => sz,
	Keyword: () => ob,
	LangiumGrammarAstReflection: () => oz,
	LangiumGrammarTerminals: () => sc,
	NamedArgument: () => sG,
	NegatedToken: () => ok,
	Negation: () => sj,
	NumberLiteral: () => sY,
	Parameter: () => sH,
	ParameterReference: () => sK,
	ParserRule: () => sQ,
	ReferenceType: () => s0,
	RegexToken: () => o_,
	ReturnType: () => s2,
	RuleCall: () => oC,
	SimpleType: () => s5,
	StringLiteral: () => s6,
	TerminalAlternatives: () => oA,
	TerminalGroup: () => oR,
	TerminalRule: () => s8,
	TerminalRuleCall: () => oI,
	Type: () => oe,
	TypeAttribute: () => or,
	TypeDefinition: () => sv,
	UnionType: () => on,
	UnorderedGroup: () => oD,
	UntilToken: () => o$,
	ValueLiteral: () => sb,
	Wildcard: () => oB,
	isAbstractElement: () => sT,
	isAbstractRule: () => su,
	isAbstractType: () => sp,
	isAction: () => oo,
	isAlternatives: () => oc,
	isArrayLiteral: () => sE,
	isArrayType: () => sS,
	isAssignment: () => ou,
	isBooleanLiteral: () => sL,
	isCharacterRange: () => op,
	isCondition: () => sg,
	isConjunction: () => sN,
	isCrossReference: () => og,
	isDisjunction: () => sM,
	isEndOfFile: () => oy,
	isFeatureName: () => sm,
	isGrammar: () => sO,
	isGrammarImport: () => sP,
	isGroup: () => ox,
	isInferredType: () => sF,
	isInterface: () => sU,
	isKeyword: () => ow,
	isNamedArgument: () => sq,
	isNegatedToken: () => oT,
	isNegation: () => sW,
	isNumberLiteral: () => sV,
	isParameter: () => sX,
	isParameterReference: () => sZ,
	isParserRule: () => sJ,
	isPrimitiveType: () => sy,
	isReferenceType: () => s1,
	isRegexToken: () => oE,
	isReturnType: () => s4,
	isRuleCall: () => oS,
	isSimpleType: () => s3,
	isStringLiteral: () => s7,
	isTerminalAlternatives: () => oL,
	isTerminalGroup: () => oN,
	isTerminalRule: () => s9,
	isTerminalRuleCall: () => oM,
	isType: () => ot,
	isTypeAttribute: () => oi,
	isTypeDefinition: () => sx,
	isUnionType: () => oa,
	isUnorderedGroup: () => oO,
	isUntilToken: () => oP,
	isValueLiteral: () => sw,
	isWildcard: () => oF,
	reflection: () => oU
});
var sc = {
	ID: /\^?[_a-zA-Z][\w_]*/,
	STRING: /"(\\.|[^"\\])*"|'(\\.|[^'\\])*'/,
	NUMBER: /NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity)/,
	RegexLiteral: /\/(?![*+?])(?:[^\r\n\[/\\]|\\.|\[(?:[^\r\n\]\\]|\\.)*\])+\/[a-z]*/,
	WS: /\s+/,
	ML_COMMENT: /\/\*[\s\S]*?\*\//,
	SL_COMMENT: /\/\/[^\n\r]*/
}, sh = "AbstractRule";
function su(e) {
	return oU.isInstance(e, sh);
}
h(su, "isAbstractRule");
var sd = "AbstractType";
function sp(e) {
	return oU.isInstance(e, sd);
}
h(sp, "isAbstractType");
var sf = "Condition";
function sg(e) {
	return oU.isInstance(e, sf);
}
function sm(e) {
	return sy(e) || "current" === e || "entry" === e || "extends" === e || "false" === e || "fragment" === e || "grammar" === e || "hidden" === e || "import" === e || "interface" === e || "returns" === e || "terminal" === e || "true" === e || "type" === e || "infer" === e || "infers" === e || "with" === e || "string" == typeof e && /\^?[_a-zA-Z][\w_]*/.test(e);
}
function sy(e) {
	return "string" === e || "number" === e || "boolean" === e || "Date" === e || "bigint" === e;
}
h(sg, "isCondition"), h(sm, "isFeatureName"), h(sy, "isPrimitiveType");
var sv = "TypeDefinition";
function sx(e) {
	return oU.isInstance(e, sv);
}
h(sx, "isTypeDefinition");
var sb = "ValueLiteral";
function sw(e) {
	return oU.isInstance(e, sb);
}
h(sw, "isValueLiteral");
var sk = "AbstractElement";
function sT(e) {
	return oU.isInstance(e, sk);
}
h(sT, "isAbstractElement");
var s_ = "ArrayLiteral";
function sE(e) {
	return oU.isInstance(e, s_);
}
h(sE, "isArrayLiteral");
var sC = "ArrayType";
function sS(e) {
	return oU.isInstance(e, sC);
}
h(sS, "isArrayType");
var sA = "BooleanLiteral";
function sL(e) {
	return oU.isInstance(e, sA);
}
h(sL, "isBooleanLiteral");
var sR = "Conjunction";
function sN(e) {
	return oU.isInstance(e, sR);
}
h(sN, "isConjunction");
var sI = "Disjunction";
function sM(e) {
	return oU.isInstance(e, sI);
}
h(sM, "isDisjunction");
var sD = "Grammar";
function sO(e) {
	return oU.isInstance(e, sD);
}
h(sO, "isGrammar");
var s$ = "GrammarImport";
function sP(e) {
	return oU.isInstance(e, s$);
}
h(sP, "isGrammarImport");
var sB = "InferredType";
function sF(e) {
	return oU.isInstance(e, sB);
}
h(sF, "isInferredType");
var sz = "Interface";
function sU(e) {
	return oU.isInstance(e, sz);
}
h(sU, "isInterface");
var sG = "NamedArgument";
function sq(e) {
	return oU.isInstance(e, sG);
}
h(sq, "isNamedArgument");
var sj = "Negation";
function sW(e) {
	return oU.isInstance(e, sj);
}
h(sW, "isNegation");
var sY = "NumberLiteral";
function sV(e) {
	return oU.isInstance(e, sY);
}
h(sV, "isNumberLiteral");
var sH = "Parameter";
function sX(e) {
	return oU.isInstance(e, sH);
}
h(sX, "isParameter");
var sK = "ParameterReference";
function sZ(e) {
	return oU.isInstance(e, sK);
}
h(sZ, "isParameterReference");
var sQ = "ParserRule";
function sJ(e) {
	return oU.isInstance(e, sQ);
}
h(sJ, "isParserRule");
var s0 = "ReferenceType";
function s1(e) {
	return oU.isInstance(e, s0);
}
h(s1, "isReferenceType");
var s2 = "ReturnType";
function s4(e) {
	return oU.isInstance(e, s2);
}
h(s4, "isReturnType");
var s5 = "SimpleType";
function s3(e) {
	return oU.isInstance(e, s5);
}
h(s3, "isSimpleType");
var s6 = "StringLiteral";
function s7(e) {
	return oU.isInstance(e, s6);
}
h(s7, "isStringLiteral");
var s8 = "TerminalRule";
function s9(e) {
	return oU.isInstance(e, s8);
}
h(s9, "isTerminalRule");
var oe = "Type";
function ot(e) {
	return oU.isInstance(e, oe);
}
h(ot, "isType");
var or = "TypeAttribute";
function oi(e) {
	return oU.isInstance(e, or);
}
h(oi, "isTypeAttribute");
var on = "UnionType";
function oa(e) {
	return oU.isInstance(e, on);
}
h(oa, "isUnionType");
var os = "Action";
function oo(e) {
	return oU.isInstance(e, os);
}
h(oo, "isAction");
var ol = "Alternatives";
function oc(e) {
	return oU.isInstance(e, ol);
}
h(oc, "isAlternatives");
var oh = "Assignment";
function ou(e) {
	return oU.isInstance(e, oh);
}
h(ou, "isAssignment");
var od = "CharacterRange";
function op(e) {
	return oU.isInstance(e, od);
}
h(op, "isCharacterRange");
var of = "CrossReference";
function og(e) {
	return oU.isInstance(e, of);
}
h(og, "isCrossReference");
var om = "EndOfFile";
function oy(e) {
	return oU.isInstance(e, om);
}
h(oy, "isEndOfFile");
var ov = "Group";
function ox(e) {
	return oU.isInstance(e, ov);
}
h(ox, "isGroup");
var ob = "Keyword";
function ow(e) {
	return oU.isInstance(e, ob);
}
h(ow, "isKeyword");
var ok = "NegatedToken";
function oT(e) {
	return oU.isInstance(e, ok);
}
h(oT, "isNegatedToken");
var o_ = "RegexToken";
function oE(e) {
	return oU.isInstance(e, o_);
}
h(oE, "isRegexToken");
var oC = "RuleCall";
function oS(e) {
	return oU.isInstance(e, oC);
}
h(oS, "isRuleCall");
var oA = "TerminalAlternatives";
function oL(e) {
	return oU.isInstance(e, oA);
}
h(oL, "isTerminalAlternatives");
var oR = "TerminalGroup";
function oN(e) {
	return oU.isInstance(e, oR);
}
h(oN, "isTerminalGroup");
var oI = "TerminalRuleCall";
function oM(e) {
	return oU.isInstance(e, oI);
}
h(oM, "isTerminalRuleCall");
var oD = "UnorderedGroup";
function oO(e) {
	return oU.isInstance(e, oD);
}
h(oO, "isUnorderedGroup");
var o$ = "UntilToken";
function oP(e) {
	return oU.isInstance(e, o$);
}
h(oP, "isUntilToken");
var oB = "Wildcard";
function oF(e) {
	return oU.isInstance(e, oB);
}
h(oF, "isWildcard");
var oz = class extends a$ {
	static {
		h(this, "LangiumGrammarAstReflection");
	}
	getAllTypes() {
		return [
			sk,
			sh,
			sd,
			os,
			ol,
			s_,
			sC,
			oh,
			sA,
			od,
			sf,
			sR,
			of,
			sI,
			om,
			sD,
			s$,
			ov,
			sB,
			sz,
			ob,
			sG,
			ok,
			sj,
			sY,
			sH,
			sK,
			sQ,
			s0,
			o_,
			s2,
			oC,
			s5,
			s6,
			oA,
			oR,
			s8,
			oI,
			oe,
			or,
			sv,
			on,
			oD,
			o$,
			sb,
			oB
		];
	}
	computeIsSubtype(e, t) {
		switch (e) {
			case os:
			case ol:
			case oh:
			case od:
			case of:
			case om:
			case ov:
			case ob:
			case ok:
			case o_:
			case oC:
			case oA:
			case oR:
			case oI:
			case oD:
			case o$:
			case oB: return this.isSubtype(sk, t);
			case s_:
			case sY:
			case s6: return this.isSubtype(sb, t);
			case sC:
			case s0:
			case s5:
			case on: return this.isSubtype(sv, t);
			case sA: return this.isSubtype(sf, t) || this.isSubtype(sb, t);
			case sR:
			case sI:
			case sj:
			case sK: return this.isSubtype(sf, t);
			case sB:
			case sz:
			case oe: return this.isSubtype(sd, t);
			case sQ: return this.isSubtype(sh, t) || this.isSubtype(sd, t);
			case s8: return this.isSubtype(sh, t);
			default: return !1;
		}
	}
	getReferenceType(e) {
		let t = `${e.container.$type}:${e.property}`;
		switch (t) {
			case "Action:type":
			case "CrossReference:type":
			case "Interface:superTypes":
			case "ParserRule:returnType":
			case "SimpleType:typeRef": return sd;
			case "Grammar:hiddenTokens":
			case "ParserRule:hiddenTokens":
			case "RuleCall:rule": return sh;
			case "Grammar:usedGrammars": return sD;
			case "NamedArgument:parameter":
			case "ParameterReference:parameter": return sH;
			case "TerminalRuleCall:rule": return s8;
			default: throw Error(`${t} is not a valid reference id.`);
		}
	}
	getTypeMetaData(e) {
		switch (e) {
			case sk: return {
				name: sk,
				properties: [{ name: "cardinality" }, { name: "lookahead" }]
			};
			case s_: return {
				name: s_,
				properties: [{
					name: "elements",
					defaultValue: []
				}]
			};
			case sC: return {
				name: sC,
				properties: [{ name: "elementType" }]
			};
			case sA: return {
				name: sA,
				properties: [{
					name: "true",
					defaultValue: !1
				}]
			};
			case sR: return {
				name: sR,
				properties: [{ name: "left" }, { name: "right" }]
			};
			case sI: return {
				name: sI,
				properties: [{ name: "left" }, { name: "right" }]
			};
			case sD: return {
				name: sD,
				properties: [
					{
						name: "definesHiddenTokens",
						defaultValue: !1
					},
					{
						name: "hiddenTokens",
						defaultValue: []
					},
					{
						name: "imports",
						defaultValue: []
					},
					{
						name: "interfaces",
						defaultValue: []
					},
					{
						name: "isDeclared",
						defaultValue: !1
					},
					{ name: "name" },
					{
						name: "rules",
						defaultValue: []
					},
					{
						name: "types",
						defaultValue: []
					},
					{
						name: "usedGrammars",
						defaultValue: []
					}
				]
			};
			case s$: return {
				name: s$,
				properties: [{ name: "path" }]
			};
			case sB: return {
				name: sB,
				properties: [{ name: "name" }]
			};
			case sz: return {
				name: sz,
				properties: [
					{
						name: "attributes",
						defaultValue: []
					},
					{ name: "name" },
					{
						name: "superTypes",
						defaultValue: []
					}
				]
			};
			case sG: return {
				name: sG,
				properties: [
					{
						name: "calledByName",
						defaultValue: !1
					},
					{ name: "parameter" },
					{ name: "value" }
				]
			};
			case sj: return {
				name: sj,
				properties: [{ name: "value" }]
			};
			case sY: return {
				name: sY,
				properties: [{ name: "value" }]
			};
			case sH: return {
				name: sH,
				properties: [{ name: "name" }]
			};
			case sK: return {
				name: sK,
				properties: [{ name: "parameter" }]
			};
			case sQ: return {
				name: sQ,
				properties: [
					{ name: "dataType" },
					{
						name: "definesHiddenTokens",
						defaultValue: !1
					},
					{ name: "definition" },
					{
						name: "entry",
						defaultValue: !1
					},
					{
						name: "fragment",
						defaultValue: !1
					},
					{
						name: "hiddenTokens",
						defaultValue: []
					},
					{ name: "inferredType" },
					{ name: "name" },
					{
						name: "parameters",
						defaultValue: []
					},
					{ name: "returnType" },
					{
						name: "wildcard",
						defaultValue: !1
					}
				]
			};
			case s0: return {
				name: s0,
				properties: [{ name: "referenceType" }]
			};
			case s2: return {
				name: s2,
				properties: [{ name: "name" }]
			};
			case s5: return {
				name: s5,
				properties: [
					{ name: "primitiveType" },
					{ name: "stringType" },
					{ name: "typeRef" }
				]
			};
			case s6: return {
				name: s6,
				properties: [{ name: "value" }]
			};
			case s8: return {
				name: s8,
				properties: [
					{ name: "definition" },
					{
						name: "fragment",
						defaultValue: !1
					},
					{
						name: "hidden",
						defaultValue: !1
					},
					{ name: "name" },
					{ name: "type" }
				]
			};
			case oe: return {
				name: oe,
				properties: [{ name: "name" }, { name: "type" }]
			};
			case or: return {
				name: or,
				properties: [
					{ name: "defaultValue" },
					{
						name: "isOptional",
						defaultValue: !1
					},
					{ name: "name" },
					{ name: "type" }
				]
			};
			case on: return {
				name: on,
				properties: [{
					name: "types",
					defaultValue: []
				}]
			};
			case os: return {
				name: os,
				properties: [
					{ name: "cardinality" },
					{ name: "feature" },
					{ name: "inferredType" },
					{ name: "lookahead" },
					{ name: "operator" },
					{ name: "type" }
				]
			};
			case ol: return {
				name: ol,
				properties: [
					{ name: "cardinality" },
					{
						name: "elements",
						defaultValue: []
					},
					{ name: "lookahead" }
				]
			};
			case oh: return {
				name: oh,
				properties: [
					{ name: "cardinality" },
					{ name: "feature" },
					{ name: "lookahead" },
					{ name: "operator" },
					{ name: "terminal" }
				]
			};
			case od: return {
				name: od,
				properties: [
					{ name: "cardinality" },
					{ name: "left" },
					{ name: "lookahead" },
					{ name: "right" }
				]
			};
			case of: return {
				name: of,
				properties: [
					{ name: "cardinality" },
					{
						name: "deprecatedSyntax",
						defaultValue: !1
					},
					{ name: "lookahead" },
					{ name: "terminal" },
					{ name: "type" }
				]
			};
			case om: return {
				name: om,
				properties: [{ name: "cardinality" }, { name: "lookahead" }]
			};
			case ov: return {
				name: ov,
				properties: [
					{ name: "cardinality" },
					{
						name: "elements",
						defaultValue: []
					},
					{ name: "guardCondition" },
					{ name: "lookahead" }
				]
			};
			case ob: return {
				name: ob,
				properties: [
					{ name: "cardinality" },
					{ name: "lookahead" },
					{ name: "value" }
				]
			};
			case ok: return {
				name: ok,
				properties: [
					{ name: "cardinality" },
					{ name: "lookahead" },
					{ name: "terminal" }
				]
			};
			case o_: return {
				name: o_,
				properties: [
					{ name: "cardinality" },
					{ name: "lookahead" },
					{ name: "regex" }
				]
			};
			case oC: return {
				name: oC,
				properties: [
					{
						name: "arguments",
						defaultValue: []
					},
					{ name: "cardinality" },
					{ name: "lookahead" },
					{ name: "rule" }
				]
			};
			case oA: return {
				name: oA,
				properties: [
					{ name: "cardinality" },
					{
						name: "elements",
						defaultValue: []
					},
					{ name: "lookahead" }
				]
			};
			case oR: return {
				name: oR,
				properties: [
					{ name: "cardinality" },
					{
						name: "elements",
						defaultValue: []
					},
					{ name: "lookahead" }
				]
			};
			case oI: return {
				name: oI,
				properties: [
					{ name: "cardinality" },
					{ name: "lookahead" },
					{ name: "rule" }
				]
			};
			case oD: return {
				name: oD,
				properties: [
					{ name: "cardinality" },
					{
						name: "elements",
						defaultValue: []
					},
					{ name: "lookahead" }
				]
			};
			case o$: return {
				name: o$,
				properties: [
					{ name: "cardinality" },
					{ name: "lookahead" },
					{ name: "terminal" }
				]
			};
			case oB: return {
				name: oB,
				properties: [{ name: "cardinality" }, { name: "lookahead" }]
			};
			default: return {
				name: e,
				properties: []
			};
		}
	}
}, oU = new oz(), oG = {};
function oq(e) {
	for (let [t, r] of Object.entries(e)) t.startsWith("$") || (Array.isArray(r) ? r.forEach((r, i) => {
		aI(r) && (r.$container = e, r.$containerProperty = t, r.$containerIndex = i);
	}) : aI(r) && (r.$container = e, r.$containerProperty = t));
}
function oj(e, t) {
	let r = e;
	for (; r;) {
		if (t(r)) return r;
		r = r.$container;
	}
}
function oW(e, t) {
	let r = e;
	for (; r;) {
		if (t(r)) return !0;
		r = r.$container;
	}
	return !1;
}
function oY(e) {
	let t = oV(e).$document;
	if (!t) throw Error("AST node has no document.");
	return t;
}
function oV(e) {
	for (; e.$container;) e = e.$container;
	return e;
}
function oH(e, t) {
	if (!e) throw Error("Node must be an AstNode.");
	let r = t?.range;
	return new az(() => ({
		keys: Object.keys(e),
		keyIndex: 0,
		arrayIndex: 0
	}), (t) => {
		for (; t.keyIndex < t.keys.length;) {
			let i = t.keys[t.keyIndex];
			if (!i.startsWith("$")) {
				let n = e[i];
				if (aI(n)) {
					if (t.keyIndex++, oZ(n, r)) return {
						done: !1,
						value: n
					};
				} else if (Array.isArray(n)) {
					for (; t.arrayIndex < n.length;) {
						let e = n[t.arrayIndex++];
						if (aI(e) && oZ(e, r)) return {
							done: !1,
							value: e
						};
					}
					t.arrayIndex = 0;
				}
			}
			t.keyIndex++;
		}
		return aj;
	});
}
function oX(e, t) {
	if (!e) throw Error("Root node must be an AstNode.");
	return new aH(e, (e) => oH(e, t));
}
function oK(e, t) {
	if (e) {
		if (t?.range && !oZ(e, t.range)) return new aH(e, () => []);
	} else throw Error("Root node must be an AstNode.");
	return new aH(e, (e) => oH(e, t), { includeRoot: !0 });
}
function oZ(e, t) {
	var r;
	if (!t) return !0;
	let i = null == (r = e.$cstNode) ? void 0 : r.range;
	return !!i && a1(i, t);
}
function oQ(e) {
	return new az(() => ({
		keys: Object.keys(e),
		keyIndex: 0,
		arrayIndex: 0
	}), (t) => {
		for (; t.keyIndex < t.keys.length;) {
			let r = t.keys[t.keyIndex];
			if (!r.startsWith("$")) {
				let i = e[r];
				if (aM(i)) return t.keyIndex++, {
					done: !1,
					value: {
						reference: i,
						container: e,
						property: r
					}
				};
				if (Array.isArray(i)) {
					for (; t.arrayIndex < i.length;) {
						let n = t.arrayIndex++, a = i[n];
						if (aM(a)) return {
							done: !1,
							value: {
								reference: a,
								container: e,
								property: r,
								index: n
							}
						};
					}
					t.arrayIndex = 0;
				}
			}
			t.keyIndex++;
		}
		return aj;
	});
}
function oJ(e, t = oY(e).parseResult.value) {
	let r = [];
	return oK(t).forEach((t) => {
		oQ(t).forEach((t) => {
			t.reference.ref === e && r.push(t.reference);
		});
	}), aW(r);
}
function o0(e, t) {
	for (let r of e.getTypeMetaData(t.$type).properties) void 0 !== r.defaultValue && void 0 === t[r.name] && (t[r.name] = o1(r.defaultValue));
}
function o1(e) {
	return Array.isArray(e) ? [...e.map(o1)] : e;
}
function o2(e, t) {
	let r = { $type: e.$type };
	for (let [i, n] of Object.entries(e)) if (!i.startsWith("$")) if (aI(n)) r[i] = o2(n, t);
	else if (aM(n)) r[i] = t(r, i, n.$refNode, n.$refText);
	else if (Array.isArray(n)) {
		let e = [];
		for (let a of n) aI(a) ? e.push(o2(a, t)) : aM(a) ? e.push(t(r, i, a.$refNode, a.$refText)) : e.push(a);
		r[i] = e;
	} else r[i] = n;
	return oq(r), r;
}
d(oG, {
	assignMandatoryProperties: () => o0,
	copyAstNode: () => o2,
	findLocalReferences: () => oJ,
	findRootNode: () => oV,
	getContainerOfType: () => oj,
	getDocument: () => oY,
	hasContainerOfType: () => oW,
	linkContentToContainer: () => oq,
	streamAllContents: () => oX,
	streamAst: () => oK,
	streamContents: () => oH,
	streamReferences: () => oQ
}), h(oq, "linkContentToContainer"), h(oj, "getContainerOfType"), h(oW, "hasContainerOfType"), h(oY, "getDocument"), h(oV, "findRootNode"), h(oH, "streamContents"), h(oX, "streamAllContents"), h(oK, "streamAst"), h(oZ, "isAstNodeInRange"), h(oQ, "streamReferences"), h(oJ, "findLocalReferences"), h(o0, "assignMandatoryProperties"), h(o1, "copyDefaultValue"), h(o2, "copyAstNode");
var o4 = {};
function o5(e) {
	return e.charCodeAt(0);
}
function o3(e, t) {
	Array.isArray(e) ? e.forEach(function(e) {
		t.push(e);
	}) : t.push(e);
}
function o6(e, t) {
	if (!0 === e[t]) throw "duplicate flag " + t;
	e[t], e[t] = !0;
}
function o7(e) {
	if (void 0 === e) throw Error("Internal Error - Should never get here!");
	return !0;
}
function o8() {
	throw Error("Internal Error - Should never get here!");
}
function o9(e) {
	return "Character" === e.type;
}
d(o4, {
	NEWLINE_REGEXP: () => ll,
	escapeRegExp: () => lg,
	getCaseInsensitivePattern: () => lm,
	getTerminalParts: () => lu,
	isMultilineComment: () => ld,
	isWhitespace: () => lf,
	partialMatches: () => ly,
	partialRegExp: () => lv,
	whitespaceCharacters: () => lp
}), h(o5, "cc"), h(o3, "insertToSet"), h(o6, "addFlag"), h(o7, "ASSERT_EXISTS"), h(o8, "ASSERT_NEVER_REACH_HERE"), h(o9, "isCharacter");
var le = [];
for (let e = o5("0"); e <= o5("9"); e++) le.push(e);
var lt = [o5("_")].concat(le);
for (let e = o5("a"); e <= o5("z"); e++) lt.push(e);
for (let e = o5("A"); e <= o5("Z"); e++) lt.push(e);
var lr = [
	o5(" "),
	o5("\f"),
	o5(`
`),
	o5("\r"),
	o5("	"),
	o5("\v"),
	o5("	"),
	o5("\xA0"),
	o5(""),
	o5(""),
	o5(""),
	o5(""),
	o5(""),
	o5(""),
	o5(""),
	o5(""),
	o5(""),
	o5(""),
	o5(""),
	o5(""),
	o5("\u2028"),
	o5("\u2029"),
	o5(""),
	o5(""),
	o5(""),
	o5("")
], li = /[0-9a-fA-F]/, ln = /[0-9]/, la = /[1-9]/, ls = class {
	static {
		h(this, "RegExpParser");
	}
	constructor() {
		this.idx = 0, this.input = "", this.groupIdx = 0;
	}
	saveState() {
		return {
			idx: this.idx,
			input: this.input,
			groupIdx: this.groupIdx
		};
	}
	restoreState(e) {
		this.idx = e.idx, this.input = e.input, this.groupIdx = e.groupIdx;
	}
	pattern(e) {
		this.idx = 0, this.input = e, this.groupIdx = 0, this.consumeChar("/");
		let t = this.disjunction();
		this.consumeChar("/");
		let r = {
			type: "Flags",
			loc: {
				begin: this.idx,
				end: e.length
			},
			global: !1,
			ignoreCase: !1,
			multiLine: !1,
			unicode: !1,
			sticky: !1
		};
		for (; this.isRegExpFlag();) switch (this.popChar()) {
			case "g":
				o6(r, "global");
				break;
			case "i":
				o6(r, "ignoreCase");
				break;
			case "m":
				o6(r, "multiLine");
				break;
			case "u":
				o6(r, "unicode");
				break;
			case "y": o6(r, "sticky");
		}
		if (this.idx !== this.input.length) throw Error("Redundant input: " + this.input.substring(this.idx));
		return {
			type: "Pattern",
			flags: r,
			value: t,
			loc: this.loc(0)
		};
	}
	disjunction() {
		let e = [], t = this.idx;
		for (e.push(this.alternative()); "|" === this.peekChar();) this.consumeChar("|"), e.push(this.alternative());
		return {
			type: "Disjunction",
			value: e,
			loc: this.loc(t)
		};
	}
	alternative() {
		let e = [], t = this.idx;
		for (; this.isTerm();) e.push(this.term());
		return {
			type: "Alternative",
			value: e,
			loc: this.loc(t)
		};
	}
	term() {
		return this.isAssertion() ? this.assertion() : this.atom();
	}
	assertion() {
		let e = this.idx;
		switch (this.popChar()) {
			case "^": return {
				type: "StartAnchor",
				loc: this.loc(e)
			};
			case "$": return {
				type: "EndAnchor",
				loc: this.loc(e)
			};
			case "\\":
				switch (this.popChar()) {
					case "b": return {
						type: "WordBoundary",
						loc: this.loc(e)
					};
					case "B": return {
						type: "NonWordBoundary",
						loc: this.loc(e)
					};
				}
				throw Error("Invalid Assertion Escape");
			case "(":
				let t;
				switch (this.consumeChar("?"), this.popChar()) {
					case "=":
						t = "Lookahead";
						break;
					case "!": t = "NegativeLookahead";
				}
				o7(t);
				let r = this.disjunction();
				return this.consumeChar(")"), {
					type: t,
					value: r,
					loc: this.loc(e)
				};
		}
		return o8();
	}
	quantifier(e = !1) {
		let t, r = this.idx;
		switch (this.popChar()) {
			case "*":
				t = {
					atLeast: 0,
					atMost: Infinity
				};
				break;
			case "+":
				t = {
					atLeast: 1,
					atMost: Infinity
				};
				break;
			case "?":
				t = {
					atLeast: 0,
					atMost: 1
				};
				break;
			case "{":
				let i = this.integerIncludingZero();
				switch (this.popChar()) {
					case "}":
						t = {
							atLeast: i,
							atMost: i
						};
						break;
					case ",": t = this.isDigit() ? {
						atLeast: i,
						atMost: this.integerIncludingZero()
					} : {
						atLeast: i,
						atMost: Infinity
					}, this.consumeChar("}");
				}
				if (!0 === e && void 0 === t) return;
				o7(t);
		}
		if ((!0 !== e || void 0 !== t) && o7(t)) return "?" === this.peekChar(0) ? (this.consumeChar("?"), t.greedy = !1) : t.greedy = !0, t.type = "Quantifier", t.loc = this.loc(r), t;
	}
	atom() {
		let e, t = this.idx;
		switch (this.peekChar()) {
			case ".":
				e = this.dotAll();
				break;
			case "\\":
				e = this.atomEscape();
				break;
			case "[":
				e = this.characterClass();
				break;
			case "(": e = this.group();
		}
		return void 0 === e && this.isPatternCharacter() && (e = this.patternCharacter()), o7(e) ? (e.loc = this.loc(t), this.isQuantifier() && (e.quantifier = this.quantifier()), e) : o8();
	}
	dotAll() {
		return this.consumeChar("."), {
			type: "Set",
			complement: !0,
			value: [
				o5(`
`),
				o5("\r"),
				o5("\u2028"),
				o5("\u2029")
			]
		};
	}
	atomEscape() {
		switch (this.consumeChar("\\"), this.peekChar()) {
			case "1":
			case "2":
			case "3":
			case "4":
			case "5":
			case "6":
			case "7":
			case "8":
			case "9": return this.decimalEscapeAtom();
			case "d":
			case "D":
			case "s":
			case "S":
			case "w":
			case "W": return this.characterClassEscape();
			case "f":
			case "n":
			case "r":
			case "t":
			case "v": return this.controlEscapeAtom();
			case "c": return this.controlLetterEscapeAtom();
			case "0": return this.nulCharacterAtom();
			case "x": return this.hexEscapeSequenceAtom();
			case "u": return this.regExpUnicodeEscapeSequenceAtom();
			default: return this.identityEscapeAtom();
		}
	}
	decimalEscapeAtom() {
		return {
			type: "GroupBackReference",
			value: this.positiveInteger()
		};
	}
	characterClassEscape() {
		let e, t = !1;
		switch (this.popChar()) {
			case "d":
				e = le;
				break;
			case "D":
				e = le, t = !0;
				break;
			case "s":
				e = lr;
				break;
			case "S":
				e = lr, t = !0;
				break;
			case "w":
				e = lt;
				break;
			case "W": e = lt, t = !0;
		}
		return o7(e) ? {
			type: "Set",
			value: e,
			complement: t
		} : o8();
	}
	controlEscapeAtom() {
		let e;
		switch (this.popChar()) {
			case "f":
				e = o5("\f");
				break;
			case "n":
				e = o5(`
`);
				break;
			case "r":
				e = o5("\r");
				break;
			case "t":
				e = o5("	");
				break;
			case "v": e = o5("\v");
		}
		return o7(e) ? {
			type: "Character",
			value: e
		} : o8();
	}
	controlLetterEscapeAtom() {
		this.consumeChar("c");
		let e = this.popChar();
		if (!1 === /[a-zA-Z]/.test(e)) throw Error("Invalid ");
		return {
			type: "Character",
			value: e.toUpperCase().charCodeAt(0) - 64
		};
	}
	nulCharacterAtom() {
		return this.consumeChar("0"), {
			type: "Character",
			value: o5("\0")
		};
	}
	hexEscapeSequenceAtom() {
		return this.consumeChar("x"), this.parseHexDigits(2);
	}
	regExpUnicodeEscapeSequenceAtom() {
		return this.consumeChar("u"), this.parseHexDigits(4);
	}
	identityEscapeAtom() {
		return {
			type: "Character",
			value: o5(this.popChar())
		};
	}
	classPatternCharacterAtom() {
		switch (this.peekChar()) {
			case `
`:
			case "\r":
			case "\u2028":
			case "\u2029":
			case "\\":
			case "]": throw Error("TBD");
			default: return {
				type: "Character",
				value: o5(this.popChar())
			};
		}
	}
	characterClass() {
		let e = [], t = !1;
		for (this.consumeChar("["), "^" === this.peekChar(0) && (this.consumeChar("^"), t = !0); this.isClassAtom();) {
			let t = this.classAtom();
			if (t.type, o9(t) && this.isRangeDash()) {
				this.consumeChar("-");
				let r = this.classAtom();
				if (r.type, o9(r)) {
					if (r.value < t.value) throw Error("Range out of order in character class");
					e.push({
						from: t.value,
						to: r.value
					});
				} else o3(t.value, e), e.push(o5("-")), o3(r.value, e);
			} else o3(t.value, e);
		}
		return this.consumeChar("]"), {
			type: "Set",
			complement: t,
			value: e
		};
	}
	classAtom() {
		switch (this.peekChar()) {
			case "]":
			case `
`:
			case "\r":
			case "\u2028":
			case "\u2029": throw Error("TBD");
			case "\\": return this.classEscape();
			default: return this.classPatternCharacterAtom();
		}
	}
	classEscape() {
		switch (this.consumeChar("\\"), this.peekChar()) {
			case "b": return this.consumeChar("b"), {
				type: "Character",
				value: o5("\b")
			};
			case "d":
			case "D":
			case "s":
			case "S":
			case "w":
			case "W": return this.characterClassEscape();
			case "f":
			case "n":
			case "r":
			case "t":
			case "v": return this.controlEscapeAtom();
			case "c": return this.controlLetterEscapeAtom();
			case "0": return this.nulCharacterAtom();
			case "x": return this.hexEscapeSequenceAtom();
			case "u": return this.regExpUnicodeEscapeSequenceAtom();
			default: return this.identityEscapeAtom();
		}
	}
	group() {
		let e = !0;
		(this.consumeChar("("), "?" === this.peekChar(0)) ? (this.consumeChar("?"), this.consumeChar(":"), e = !1) : this.groupIdx++;
		let t = this.disjunction();
		this.consumeChar(")");
		let r = {
			type: "Group",
			capturing: e,
			value: t
		};
		return e && (r.idx = this.groupIdx), r;
	}
	positiveInteger() {
		let e = this.popChar();
		if (!1 === la.test(e)) throw Error("Expecting a positive integer");
		for (; ln.test(this.peekChar(0));) e += this.popChar();
		return parseInt(e, 10);
	}
	integerIncludingZero() {
		let e = this.popChar();
		if (!1 === ln.test(e)) throw Error("Expecting an integer");
		for (; ln.test(this.peekChar(0));) e += this.popChar();
		return parseInt(e, 10);
	}
	patternCharacter() {
		let e = this.popChar();
		switch (e) {
			case `
`:
			case "\r":
			case "\u2028":
			case "\u2029":
			case "^":
			case "$":
			case "\\":
			case ".":
			case "*":
			case "+":
			case "?":
			case "(":
			case ")":
			case "[":
			case "|": throw Error("TBD");
			default: return {
				type: "Character",
				value: o5(e)
			};
		}
	}
	isRegExpFlag() {
		switch (this.peekChar(0)) {
			case "g":
			case "i":
			case "m":
			case "u":
			case "y": return !0;
			default: return !1;
		}
	}
	isRangeDash() {
		return "-" === this.peekChar() && this.isClassAtom(1);
	}
	isDigit() {
		return ln.test(this.peekChar(0));
	}
	isClassAtom(e = 0) {
		switch (this.peekChar(e)) {
			case "]":
			case `
`:
			case "\r":
			case "\u2028":
			case "\u2029": return !1;
			default: return !0;
		}
	}
	isTerm() {
		return this.isAtom() || this.isAssertion();
	}
	isAtom() {
		if (this.isPatternCharacter()) return !0;
		switch (this.peekChar(0)) {
			case ".":
			case "\\":
			case "[":
			case "(": return !0;
			default: return !1;
		}
	}
	isAssertion() {
		switch (this.peekChar(0)) {
			case "^":
			case "$": return !0;
			case "\\": switch (this.peekChar(1)) {
				case "b":
				case "B": return !0;
				default: return !1;
			}
			case "(": return "?" === this.peekChar(1) && ("=" === this.peekChar(2) || "!" === this.peekChar(2));
			default: return !1;
		}
	}
	isQuantifier() {
		let e = this.saveState();
		try {
			return void 0 !== this.quantifier(!0);
		} catch {
			return !1;
		} finally {
			this.restoreState(e);
		}
	}
	isPatternCharacter() {
		switch (this.peekChar()) {
			case "^":
			case "$":
			case "\\":
			case ".":
			case "*":
			case "+":
			case "?":
			case "(":
			case ")":
			case "[":
			case "|":
			case "/":
			case `
`:
			case "\r":
			case "\u2028":
			case "\u2029": return !1;
			default: return !0;
		}
	}
	parseHexDigits(e) {
		let t = "";
		for (let r = 0; r < e; r++) {
			let e = this.popChar();
			if (!1 === li.test(e)) throw Error("Expecting a HexDecimal digits");
			t += e;
		}
		return {
			type: "Character",
			value: parseInt(t, 16)
		};
	}
	peekChar(e = 0) {
		return this.input[this.idx + e];
	}
	popChar() {
		let e = this.peekChar(0);
		return this.consumeChar(void 0), e;
	}
	consumeChar(e) {
		if (void 0 !== e && this.input[this.idx] !== e) throw Error("Expected: '" + e + "' but found: '" + this.input[this.idx] + "' at offset: " + this.idx);
		if (this.idx >= this.input.length) throw Error("Unexpected end of input");
		this.idx++;
	}
	loc(e) {
		return {
			begin: e,
			end: this.idx
		};
	}
}, lo = class {
	static {
		h(this, "BaseRegExpVisitor");
	}
	visitChildren(e) {
		for (let t in e) {
			let r = e[t];
			e.hasOwnProperty(t) && (void 0 !== r.type ? this.visit(r) : Array.isArray(r) && r.forEach((e) => {
				this.visit(e);
			}, this));
		}
	}
	visit(e) {
		switch (e.type) {
			case "Pattern":
				this.visitPattern(e);
				break;
			case "Flags":
				this.visitFlags(e);
				break;
			case "Disjunction":
				this.visitDisjunction(e);
				break;
			case "Alternative":
				this.visitAlternative(e);
				break;
			case "StartAnchor":
				this.visitStartAnchor(e);
				break;
			case "EndAnchor":
				this.visitEndAnchor(e);
				break;
			case "WordBoundary":
				this.visitWordBoundary(e);
				break;
			case "NonWordBoundary":
				this.visitNonWordBoundary(e);
				break;
			case "Lookahead":
				this.visitLookahead(e);
				break;
			case "NegativeLookahead":
				this.visitNegativeLookahead(e);
				break;
			case "Character":
				this.visitCharacter(e);
				break;
			case "Set":
				this.visitSet(e);
				break;
			case "Group":
				this.visitGroup(e);
				break;
			case "GroupBackReference":
				this.visitGroupBackReference(e);
				break;
			case "Quantifier": this.visitQuantifier(e);
		}
		this.visitChildren(e);
	}
	visitPattern(e) {}
	visitFlags(e) {}
	visitDisjunction(e) {}
	visitAlternative(e) {}
	visitStartAnchor(e) {}
	visitEndAnchor(e) {}
	visitWordBoundary(e) {}
	visitNonWordBoundary(e) {}
	visitLookahead(e) {}
	visitNegativeLookahead(e) {}
	visitCharacter(e) {}
	visitSet(e) {}
	visitGroup(e) {}
	visitGroupBackReference(e) {}
	visitQuantifier(e) {}
}, ll = /\r?\n/gm, lc = new ls(), lh = new class extends lo {
	static {
		h(this, "TerminalRegExpVisitor");
	}
	constructor() {
		super(...arguments), this.isStarting = !0, this.endRegexpStack = [], this.multiline = !1;
	}
	get endRegex() {
		return this.endRegexpStack.join("");
	}
	reset(e) {
		this.multiline = !1, this.regex = e, this.startRegexp = "", this.isStarting = !0, this.endRegexpStack = [];
	}
	visitGroup(e) {
		e.quantifier && (this.isStarting = !1, this.endRegexpStack = []);
	}
	visitCharacter(e) {
		let t = String.fromCharCode(e.value);
		if (this.multiline || t !== `
` || (this.multiline = !0), e.quantifier) this.isStarting = !1, this.endRegexpStack = [];
		else {
			let e = lg(t);
			this.endRegexpStack.push(e), this.isStarting && (this.startRegexp += e);
		}
	}
	visitSet(e) {
		if (!this.multiline) {
			let t = new RegExp(this.regex.substring(e.loc.begin, e.loc.end));
			this.multiline = !!`
`.match(t);
		}
		if (e.quantifier) this.isStarting = !1, this.endRegexpStack = [];
		else {
			let t = this.regex.substring(e.loc.begin, e.loc.end);
			this.endRegexpStack.push(t), this.isStarting && (this.startRegexp += t);
		}
	}
	visitChildren(e) {
		"Group" === e.type && e.quantifier || super.visitChildren(e);
	}
}();
function lu(e) {
	try {
		"string" != typeof e && (e = e.source), e = `/${e}/`;
		let t = lc.pattern(e), r = [];
		for (let i of t.value.value) lh.reset(e), lh.visit(i), r.push({
			start: lh.startRegexp,
			end: lh.endRegex
		});
		return r;
	} catch {
		return [];
	}
}
function ld(e) {
	try {
		return "string" == typeof e && (e = new RegExp(e)), e = e.toString(), lh.reset(e), lh.visit(lc.pattern(e)), lh.multiline;
	} catch {
		return !1;
	}
}
h(lu, "getTerminalParts"), h(ld, "isMultilineComment");
var lp = `\f
\r	\v \xa0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF`.split("");
function lf(e) {
	let t = "string" == typeof e ? new RegExp(e) : e;
	return lp.some((e) => t.test(e));
}
function lg(e) {
	return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function lm(e) {
	return Array.prototype.map.call(e, (e) => /\w/.test(e) ? `[${e.toLowerCase()}${e.toUpperCase()}]` : lg(e)).join("");
}
function ly(e, t) {
	let r = lv(e), i = t.match(r);
	return !!i && i[0].length > 0;
}
function lv(e) {
	"string" == typeof e && (e = new RegExp(e));
	let t = e, r = e.source, i = 0;
	function n() {
		let e = "", a;
		function s(t) {
			e += r.substr(i, t), i += t;
		}
		function o(t) {
			e += "(?:" + r.substr(i, t) + "|$)", i += t;
		}
		for (h(s, "appendRaw"), h(o, "appendOptional"); i < r.length;) switch (r[i]) {
			case "\\":
				switch (r[i + 1]) {
					case "c":
						o(3);
						break;
					case "x":
						o(4);
						break;
					case "u":
						o(t.unicode ? "{" === r[i + 2] ? r.indexOf("}", i) - i + 1 : 6 : 2);
						break;
					case "p":
					case "P":
						o(t.unicode ? r.indexOf("}", i) - i + 1 : 2);
						break;
					case "k":
						o(r.indexOf(">", i) - i + 1);
						break;
					default: o(2);
				}
				break;
			case "[":
				(a = /\[(?:\\.|.)*?\]/g).lastIndex = i, o((a = a.exec(r) || [])[0].length);
				break;
			case "|":
			case "^":
			case "$":
			case "*":
			case "+":
			case "?":
				s(1);
				break;
			case "{":
				(a = /\{\d+,?\d*\}/g).lastIndex = i, (a = a.exec(r)) ? s(a[0].length) : o(1);
				break;
			case "(":
				if ("?" === r[i + 1]) switch (r[i + 2]) {
					case ":":
						e += "(?:", i += 3, e += n() + "|$)";
						break;
					case "=":
						e += "(?=", i += 3, e += n() + ")";
						break;
					case "!":
						a = i, i += 3, n(), e += r.substr(a, i - a);
						break;
					case "<": switch (r[i + 3]) {
						case "=":
						case "!":
							a = i, i += 4, n(), e += r.substr(a, i - a);
							break;
						default: s(r.indexOf(">", i) - i + 1), e += n() + "|$)";
					}
				}
				else s(1), e += n() + "|$)";
				break;
			case ")": return ++i, e;
			default: o(1);
		}
		return e;
	}
	return h(n, "process"), new RegExp(n(), e.flags);
}
function lx(e) {
	return e.rules.find((e) => sJ(e) && e.entry);
}
function lb(e) {
	return e.rules.filter((e) => s9(e) && e.hidden);
}
function lw(e, t) {
	let r = /* @__PURE__ */ new Set(), i = lx(e);
	if (!i) return new Set(e.rules);
	for (let n of [i].concat(lb(e))) lk(n, r, t);
	let n = /* @__PURE__ */ new Set();
	for (let t of e.rules) (r.has(t.name) || s9(t) && t.hidden) && n.add(t);
	return n;
}
function lk(e, t, r) {
	t.add(e.name), oX(e).forEach((e) => {
		if (oS(e) || r && oM(e)) {
			let i = e.rule.ref;
			i && !t.has(i.name) && lk(i, t, r);
		}
	});
}
function lT(e) {
	return e.terminal ? e.terminal : e.type.ref ? lI(e.type.ref)?.terminal : void 0;
}
function l_(e) {
	return e.hidden && !lf(lV(e));
}
function lE(e, t) {
	return e && t ? lS(e, t, e.astNode, !0) : [];
}
function lC(e, t, r) {
	if (!e || !t) return;
	let i = lS(e, t, e.astNode, !0);
	if (0 !== i.length) return r = void 0 !== r ? Math.max(0, Math.min(r, i.length - 1)) : 0, i[r];
}
function lS(e, t, r, i) {
	if (!i) {
		let r = oj(e.grammarSource, ou);
		if (r && r.feature === t) return [e];
	}
	return aP(e) && e.astNode === r ? e.content.flatMap((e) => lS(e, t, r, !1)) : [];
}
function lA(e, t) {
	return e ? lR(e, t, e?.astNode) : [];
}
function lL(e, t, r) {
	if (!e) return;
	let i = lR(e, t, e?.astNode);
	if (0 !== i.length) return r = void 0 !== r ? Math.max(0, Math.min(r, i.length - 1)) : 0, i[r];
}
function lR(e, t, r) {
	if (e.astNode !== r) return [];
	if (ow(e.grammarSource) && e.grammarSource.value === t) return [e];
	let i = aX(e).iterator(), n, a = [];
	do
		if (!(n = i.next()).done) {
			let e = n.value;
			e.astNode === r ? ow(e.grammarSource) && e.grammarSource.value === t && a.push(e) : i.prune();
		}
	while (!n.done);
	return a;
}
function lN(e) {
	var t;
	let r = e.astNode;
	for (; r === (null == (t = e.container) ? void 0 : t.astNode);) {
		let t = oj(e.grammarSource, ou);
		if (t) return t;
		e = e.container;
	}
}
function lI(e) {
	let t = e;
	return sF(t) && (oo(t.$container) ? t = t.$container.$container : sJ(t.$container) ? t = t.$container : so(t.$container)), lM(e, t, /* @__PURE__ */ new Map());
}
function lM(e, t, r) {
	var i;
	function n(t, i) {
		let n;
		return oj(t, ou) || (n = lM(i, i, r)), r.set(e, n), n;
	}
	if (h(n, "go"), r.has(e)) return r.get(e);
	for (let a of (r.set(e, void 0), oX(t))) {
		if (ou(a) && "name" === a.feature.toLowerCase()) return r.set(e, a), a;
		if (oS(a) && sJ(a.rule.ref)) return n(a, a.rule.ref);
		if (s3(a) && null != (i = a.typeRef) && i.ref) return n(a, a.typeRef.ref);
	}
}
function lD(e) {
	let t = e.$container;
	if (ox(t)) {
		let r = t.elements, i = r.indexOf(e);
		for (let e = i - 1; e >= 0; e--) {
			let t = r[e];
			if (oo(t)) return t;
			{
				let t = oX(r[e]).find(oo);
				if (t) return t;
			}
		}
	}
	if (sT(t)) return lD(t);
}
function lO(e, t) {
	return "?" === e || "*" === e || ox(t) && !!t.guardCondition;
}
function l$(e) {
	return "*" === e || "+" === e;
}
function lP(e) {
	return "+=" === e;
}
function lB(e) {
	return lF(e, /* @__PURE__ */ new Set());
}
function lF(e, t) {
	if (t.has(e)) return !0;
	for (let r of (t.add(e), oX(e))) if (oS(r)) {
		if (!r.rule.ref || sJ(r.rule.ref) && !lF(r.rule.ref, t)) return !1;
	} else if (ou(r) || oo(r)) return !1;
	return !!e.definition;
}
function lz(e) {
	return lU(e.type, /* @__PURE__ */ new Set());
}
function lU(e, t) {
	if (t.has(e)) return !0;
	if (t.add(e), sS(e) || s1(e)) return !1;
	if (oa(e)) return e.types.every((e) => lU(e, t));
	if (!s3(e)) return !1;
	if (void 0 !== e.primitiveType || void 0 !== e.stringType) return !0;
	if (void 0 === e.typeRef) return !1;
	{
		let r = e.typeRef.ref;
		return !!ot(r) && lU(r.type, t);
	}
}
function lG(e) {
	if (e.inferredType) return e.inferredType.name;
	if (e.dataType) return e.dataType;
	if (e.returnType) {
		let t = e.returnType.ref;
		if (t && (sJ(t) || sU(t) || ot(t))) return t.name;
	}
}
function lq(e) {
	var t;
	if (sJ(e)) return lB(e) ? e.name : null != (t = lG(e)) ? t : e.name;
	if (sU(e) || ot(e) || s4(e)) return e.name;
	if (oo(e)) {
		let t = lj(e);
		if (t) return t;
	} else if (sF(e)) return e.name;
	throw Error("Cannot get name of Unknown Type");
}
function lj(e) {
	var t;
	return e.inferredType ? e.inferredType.name : null != (t = e.type) && t.ref ? lq(e.type.ref) : void 0;
}
function lW(e) {
	var t, r, i;
	return s9(e) ? null != (r = null == (t = e.type) ? void 0 : t.name) ? r : "string" : lB(e) ? e.name : null != (i = lG(e)) ? i : e.name;
}
function lY(e) {
	var t, r, i;
	return s9(e) ? null != (r = null == (t = e.type) ? void 0 : t.name) ? r : "string" : null != (i = lG(e)) ? i : e.name;
}
function lV(e) {
	let t = {
		s: !1,
		i: !1,
		u: !1
	};
	return new RegExp(lX(e.definition, t), Object.entries(t).filter(([, e]) => e).map(([e]) => e).join(""));
}
h(lf, "isWhitespace"), h(lg, "escapeRegExp"), h(lm, "getCaseInsensitivePattern"), h(ly, "partialMatches"), h(lv, "partialRegExp"), h(lx, "getEntryRule"), h(lb, "getHiddenRules"), h(lw, "getAllReachableRules"), h(lk, "ruleDfs"), h(lT, "getCrossReferenceTerminal"), h(l_, "isCommentTerminal"), h(lE, "findNodesForProperty"), h(lC, "findNodeForProperty"), h(lS, "findNodesForPropertyInternal"), h(lA, "findNodesForKeyword"), h(lL, "findNodeForKeyword"), h(lR, "findNodesForKeywordInternal"), h(lN, "findAssignment"), h(lI, "findNameAssignment"), h(lM, "findNameAssignmentInternal"), h(lD, "getActionAtElement"), h(lO, "isOptionalCardinality"), h(l$, "isArrayCardinality"), h(lP, "isArrayOperator"), h(lB, "isDataTypeRule"), h(lF, "isDataTypeRuleInternal"), h(lz, "isDataType"), h(lU, "isDataTypeInternal"), h(lG, "getExplicitRuleType"), h(lq, "getTypeName"), h(lj, "getActionType"), h(lW, "getRuleTypeName"), h(lY, "getRuleType"), h(lV, "terminalRegex");
var lH = /[\s\S]/.source;
function lX(e, t) {
	if (oL(e)) return lK(e);
	if (oN(e)) return lZ(e);
	if (op(e)) return l0(e);
	if (oM(e)) {
		let t = e.rule.ref;
		if (!t) throw Error("Missing rule reference.");
		return l2(lX(t.definition), {
			cardinality: e.cardinality,
			lookahead: e.lookahead
		});
	}
	if (oT(e)) return lJ(e);
	if (oP(e)) return lQ(e);
	if (oE(e)) {
		let r = e.regex.lastIndexOf("/"), i = e.regex.substring(1, r), n = e.regex.substring(r + 1);
		return t && (t.i = n.includes("i"), t.s = n.includes("s"), t.u = n.includes("u")), l2(i, {
			cardinality: e.cardinality,
			lookahead: e.lookahead,
			wrap: !1
		});
	}
	if (oF(e)) return l2(lH, {
		cardinality: e.cardinality,
		lookahead: e.lookahead
	});
	throw Error(`Invalid terminal element: ${e?.$type}`);
}
function lK(e) {
	return l2(e.elements.map((e) => lX(e)).join("|"), {
		cardinality: e.cardinality,
		lookahead: e.lookahead
	});
}
function lZ(e) {
	return l2(e.elements.map((e) => lX(e)).join(""), {
		cardinality: e.cardinality,
		lookahead: e.lookahead
	});
}
function lQ(e) {
	return l2(`${lH}*?${lX(e.terminal)}`, {
		cardinality: e.cardinality,
		lookahead: e.lookahead
	});
}
function lJ(e) {
	return l2(`(?!${lX(e.terminal)})${lH}*?`, {
		cardinality: e.cardinality,
		lookahead: e.lookahead
	});
}
function l0(e) {
	return e.right ? l2(`[${l1(e.left)}-${l1(e.right)}]`, {
		cardinality: e.cardinality,
		lookahead: e.lookahead,
		wrap: !1
	}) : l2(l1(e.left), {
		cardinality: e.cardinality,
		lookahead: e.lookahead,
		wrap: !1
	});
}
function l1(e) {
	return lg(e.value);
}
function l2(e, t) {
	var r;
	return (!1 !== t.wrap || t.lookahead) && (e = `(${null != (r = t.lookahead) ? r : ""}${e})`), t.cardinality ? `${e}${t.cardinality}` : e;
}
function l4(e) {
	let t = [];
	for (let r of e.Grammar.rules) s9(r) && l_(r) && ld(lV(r)) && t.push(r.name);
	return {
		multilineCommentRules: t,
		nameRegexp: a2
	};
}
function l5(e) {
	console && console.error && console.error(`Error: ${e}`);
}
function l3(e) {
	console && console.warn && console.warn(`Warning: ${e}`);
}
function l6(e) {
	let t = (/* @__PURE__ */ new Date()).getTime(), r = e();
	return {
		time: (/* @__PURE__ */ new Date()).getTime() - t,
		value: r
	};
}
function l7(e) {
	function t() {}
	h(t, "FakeConstructor"), t.prototype = e;
	let r = new t();
	function i() {
		return typeof r.bar;
	}
	return h(i, "fakeAccess"), i(), i(), e;
}
function l8(e) {
	return l9(e) ? e.LABEL : e.name;
}
function l9(e) {
	return nj(e.LABEL) && "" !== e.LABEL;
}
h(lX, "abstractElementToRegex"), h(lK, "terminalAlternativesToRegex"), h(lZ, "terminalGroupToRegex"), h(lQ, "untilTokenToRegex"), h(lJ, "negateTokenToRegex"), h(l0, "characterRangeToRegex"), h(l1, "keywordToRegex"), h(l2, "withCardinality"), h(l4, "createGrammarConfig"), h(l5, "PRINT_ERROR"), h(l3, "PRINT_WARNING"), h(l6, "timer"), h(l7, "toFastProperties"), h(l8, "tokenLabel"), h(l9, "hasTokenLabel");
var ce = class {
	static {
		h(this, "AbstractProduction");
	}
	get definition() {
		return this._definition;
	}
	set definition(e) {
		this._definition = e;
	}
	constructor(e) {
		this._definition = e;
	}
	accept(e) {
		e.visit(this), rU(this.definition, (t) => {
			t.accept(e);
		});
	}
}, ct = class extends ce {
	static {
		h(this, "NonTerminal");
	}
	constructor(e) {
		super([]), this.idx = 1, nf(this, n2(e, (e) => void 0 !== e));
	}
	set definition(e) {}
	get definition() {
		return void 0 !== this.referencedRule ? this.referencedRule.definition : [];
	}
	accept(e) {
		e.visit(this);
	}
}, cr = class extends ce {
	static {
		h(this, "Rule");
	}
	constructor(e) {
		super(e.definition), this.orgText = "", nf(this, n2(e, (e) => void 0 !== e));
	}
}, ci = class extends ce {
	static {
		h(this, "Alternative");
	}
	constructor(e) {
		super(e.definition), this.ignoreAmbiguities = !1, nf(this, n2(e, (e) => void 0 !== e));
	}
}, cn = class extends ce {
	static {
		h(this, "Option");
	}
	constructor(e) {
		super(e.definition), this.idx = 1, nf(this, n2(e, (e) => void 0 !== e));
	}
}, ca = class extends ce {
	static {
		h(this, "RepetitionMandatory");
	}
	constructor(e) {
		super(e.definition), this.idx = 1, nf(this, n2(e, (e) => void 0 !== e));
	}
}, cs = class extends ce {
	static {
		h(this, "RepetitionMandatoryWithSeparator");
	}
	constructor(e) {
		super(e.definition), this.idx = 1, nf(this, n2(e, (e) => void 0 !== e));
	}
}, co = class extends ce {
	static {
		h(this, "Repetition");
	}
	constructor(e) {
		super(e.definition), this.idx = 1, nf(this, n2(e, (e) => void 0 !== e));
	}
}, cl = class extends ce {
	static {
		h(this, "RepetitionWithSeparator");
	}
	constructor(e) {
		super(e.definition), this.idx = 1, nf(this, n2(e, (e) => void 0 !== e));
	}
}, cc = class extends ce {
	static {
		h(this, "Alternation");
	}
	get definition() {
		return this._definition;
	}
	set definition(e) {
		this._definition = e;
	}
	constructor(e) {
		super(e.definition), this.idx = 1, this.ignoreAmbiguities = !1, this.hasPredicates = !1, nf(this, n2(e, (e) => void 0 !== e));
	}
}, ch = class {
	static {
		h(this, "Terminal");
	}
	constructor(e) {
		this.idx = 1, nf(this, n2(e, (e) => void 0 !== e));
	}
	accept(e) {
		e.visit(this);
	}
};
function cu(e) {
	return iD(e, cd);
}
function cd(e) {
	function t(e) {
		return iD(e, cd);
	}
	if (h(t, "convertDefinition"), e instanceof ct) {
		let t = {
			type: "NonTerminal",
			name: e.nonTerminalName,
			idx: e.idx
		};
		return nj(e.label) && (t.label = e.label), t;
	}
	if (e instanceof ci) return {
		type: "Alternative",
		definition: t(e.definition)
	};
	if (e instanceof cn) return {
		type: "Option",
		idx: e.idx,
		definition: t(e.definition)
	};
	if (e instanceof ca) return {
		type: "RepetitionMandatory",
		idx: e.idx,
		definition: t(e.definition)
	};
	if (e instanceof cs) return {
		type: "RepetitionMandatoryWithSeparator",
		idx: e.idx,
		separator: cd(new ch({ terminalType: e.separator })),
		definition: t(e.definition)
	};
	if (e instanceof cl) return {
		type: "RepetitionWithSeparator",
		idx: e.idx,
		separator: cd(new ch({ terminalType: e.separator })),
		definition: t(e.definition)
	};
	if (e instanceof co) return {
		type: "Repetition",
		idx: e.idx,
		definition: t(e.definition)
	};
	if (e instanceof cc) return {
		type: "Alternation",
		idx: e.idx,
		definition: t(e.definition)
	};
	if (e instanceof ch) {
		let t = {
			type: "Terminal",
			name: e.terminalType.name,
			label: l8(e.terminalType),
			idx: e.idx
		};
		nj(e.label) && (t.terminalLabel = e.label);
		let r = e.terminalType.PATTERN;
		return e.terminalType.PATTERN && (t.pattern = nZ(r) ? r.source : r), t;
	}
	if (e instanceof cr) return {
		type: "Rule",
		name: e.name,
		orgText: e.orgText,
		definition: t(e.definition)
	};
	throw Error("non exhaustive match");
}
h(cu, "serializeGrammar"), h(cd, "serializeProduction");
var cp = class {
	static {
		h(this, "GAstVisitor");
	}
	visit(e) {
		switch (e.constructor) {
			case ct: return this.visitNonTerminal(e);
			case ci: return this.visitAlternative(e);
			case cn: return this.visitOption(e);
			case ca: return this.visitRepetitionMandatory(e);
			case cs: return this.visitRepetitionMandatoryWithSeparator(e);
			case cl: return this.visitRepetitionWithSeparator(e);
			case co: return this.visitRepetition(e);
			case cc: return this.visitAlternation(e);
			case ch: return this.visitTerminal(e);
			case cr: return this.visitRule(e);
			default: throw Error("non exhaustive match");
		}
	}
	visitNonTerminal(e) {}
	visitAlternative(e) {}
	visitOption(e) {}
	visitRepetition(e) {}
	visitRepetitionMandatory(e) {}
	visitRepetitionMandatoryWithSeparator(e) {}
	visitRepetitionWithSeparator(e) {}
	visitAlternation(e) {}
	visitTerminal(e) {}
	visitRule(e) {}
};
function cf(e) {
	return e instanceof ci || e instanceof cn || e instanceof co || e instanceof ca || e instanceof cs || e instanceof cl || e instanceof ch || e instanceof cr;
}
function cg(e, t = []) {
	return e instanceof cn || e instanceof co || e instanceof cl || (e instanceof cc ? av(e.definition, (e) => cg(e, t)) : !(e instanceof ct && nY(t, e)) && e instanceof ce && (e instanceof ct && t.push(e), nR(e.definition, (e) => cg(e, t))));
}
function cm(e) {
	return e instanceof cc;
}
function cy(e) {
	if (e instanceof ct) return "SUBRULE";
	if (e instanceof cn) return "OPTION";
	if (e instanceof cc) return "OR";
	if (e instanceof ca) return "AT_LEAST_ONE";
	if (e instanceof cs) return "AT_LEAST_ONE_SEP";
	if (e instanceof cl) return "MANY_SEP";
	if (e instanceof co) return "MANY";
	if (e instanceof ch) return "CONSUME";
	throw Error("non exhaustive match");
}
h(cf, "isSequenceProd"), h(cg, "isOptionalProd"), h(cm, "isBranchingProd"), h(cy, "getProductionDslName");
var cv = class {
	static {
		h(this, "RestWalker");
	}
	walk(e, t = []) {
		rU(e.definition, (r, i) => {
			let n = nC(e.definition, i + 1);
			if (r instanceof ct) this.walkProdRef(r, n, t);
			else if (r instanceof ch) this.walkTerminal(r, n, t);
			else if (r instanceof ci) this.walkFlat(r, n, t);
			else if (r instanceof cn) this.walkOption(r, n, t);
			else if (r instanceof ca) this.walkAtLeastOne(r, n, t);
			else if (r instanceof cs) this.walkAtLeastOneSep(r, n, t);
			else if (r instanceof cl) this.walkManySep(r, n, t);
			else if (r instanceof co) this.walkMany(r, n, t);
			else if (r instanceof cc) this.walkOr(r, n, t);
			else throw Error("non exhaustive match");
		});
	}
	walkTerminal(e, t, r) {}
	walkProdRef(e, t, r) {}
	walkFlat(e, t, r) {
		let i = t.concat(r);
		this.walk(e, i);
	}
	walkOption(e, t, r) {
		let i = t.concat(r);
		this.walk(e, i);
	}
	walkAtLeastOne(e, t, r) {
		let i = [new cn({ definition: e.definition })].concat(t, r);
		this.walk(e, i);
	}
	walkAtLeastOneSep(e, t, r) {
		let i = cx(e, t, r);
		this.walk(e, i);
	}
	walkMany(e, t, r) {
		let i = [new cn({ definition: e.definition })].concat(t, r);
		this.walk(e, i);
	}
	walkManySep(e, t, r) {
		let i = cx(e, t, r);
		this.walk(e, i);
	}
	walkOr(e, t, r) {
		let i = t.concat(r);
		rU(e.definition, (e) => {
			let t = new ci({ definition: [e] });
			this.walk(t, i);
		});
	}
};
function cx(e, t, r) {
	return [new cn({ definition: [new ch({ terminalType: e.separator })].concat(e.definition) })].concat(t, r);
}
function cb(e) {
	if (e instanceof ct) return cb(e.referencedRule);
	if (e instanceof ch) return cT(e);
	if (cf(e)) return cw(e);
	if (cm(e)) return ck(e);
	throw Error("non exhaustive match");
}
function cw(e) {
	let t = [], r = e.definition, i = 0, n = r.length > i, a, s = !0;
	for (; n && s;) s = cg(a = r[i]), t = t.concat(cb(a)), i += 1, n = r.length > i;
	return ab(t);
}
function ck(e) {
	return ab(iH(iD(e.definition, (e) => cb(e))));
}
function cT(e) {
	return [e.terminalType];
}
h(cx, "restForRepetitionWithSeparator"), h(cb, "first"), h(cw, "firstForSequence"), h(ck, "firstForBranching"), h(cT, "firstForTerminal");
var c_ = "_~IN~_", cE = class extends cv {
	static {
		h(this, "ResyncFollowsWalker");
	}
	constructor(e) {
		super(), this.topProd = e, this.follows = {};
	}
	startWalking() {
		return this.walk(this.topProd), this.follows;
	}
	walkTerminal(e, t, r) {}
	walkProdRef(e, t, r) {
		let i = cS(e.referencedRule, e.idx) + this.topProd.name, n = cb(new ci({ definition: t.concat(r) }));
		this.follows[i] = n;
	}
};
function cC(e) {
	let t = {};
	return rU(e, (e) => {
		nf(t, new cE(e).startWalking());
	}), t;
}
function cS(e, t) {
	return e.name + t + c_;
}
h(cC, "computeAllProdsFollows"), h(cS, "buildBetweenProdsFollowPrefix");
var cA = {}, cL = new ls();
function cR(e) {
	let t = e.toString();
	if (cA.hasOwnProperty(t)) return cA[t];
	{
		let e = cL.pattern(t);
		return cA[t] = e, e;
	}
}
function cN() {
	cA = {};
}
h(cR, "getRegExpAst"), h(cN, "clearRegExpParserCache");
var cI = "Complement Sets are not supported for first char optimization", cM = `Unable to use "first char" lexer optimizations:
`;
function cD(e, t = !1) {
	try {
		let t = cR(e);
		return cO(t.value, {}, t.flags.ignoreCase);
	} catch (r) {
		if (r.message === cI) t && l3(`${cM}	Unable to optimize: < ${e.toString()} >
	Complement Sets cannot be automatically optimized.
	This will disable the lexer's first char optimizations.
	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.`);
		else {
			let r = "";
			t && (r = `
	This will disable the lexer's first char optimizations.
	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.`), l5(`${cM}
	Failed parsing: < ${e.toString()} >
	Using the @chevrotain/regexp-to-ast library
	Please open an issue at: https://github.com/chevrotain/chevrotain/issues` + r);
		}
	}
	return [];
}
function cO(e, t, r) {
	switch (e.type) {
		case "Disjunction":
			for (let i = 0; i < e.value.length; i++) cO(e.value[i], t, r);
			break;
		case "Alternative":
			let i = e.value;
			for (let e = 0; e < i.length; e++) {
				let n = i[e];
				switch (n.type) {
					case "EndAnchor":
					case "GroupBackReference":
					case "Lookahead":
					case "NegativeLookahead":
					case "StartAnchor":
					case "WordBoundary":
					case "NonWordBoundary": continue;
				}
				switch (n.type) {
					case "Character":
						c$(n.value, t, r);
						break;
					case "Set":
						if (!0 === n.complement) throw Error(cI);
						rU(n.value, (e) => {
							if ("number" == typeof e) c$(e, t, r);
							else if (!0 === r) for (let i = e.from; i <= e.to; i++) c$(i, t, r);
							else {
								for (let i = e.from; i <= e.to && i < hu; i++) c$(i, t, r);
								if (e.to >= hu) {
									let r = e.from >= hu ? e.from : hu, i = e.to, n = hp(r), a = hp(i);
									for (let e = n; e <= a; e++) t[e] = e;
								}
							}
						});
						break;
					case "Group":
						cO(n.value, t, r);
						break;
					default: throw Error("Non Exhaustive Match");
				}
				let a = void 0 !== n.quantifier && 0 === n.quantifier.atLeast;
				if ("Group" === n.type && !1 === cF(n) || "Group" !== n.type && !1 === a) break;
			}
			break;
		default: throw Error("non exhaustive match!");
	}
	return i$(t);
}
function c$(e, t, r) {
	let i = hp(e);
	t[i] = i, !0 === r && cP(e, t);
}
function cP(e, t) {
	let r = String.fromCharCode(e), i = r.toUpperCase();
	if (i !== r) {
		let e = hp(i.charCodeAt(0));
		t[e] = e;
	} else {
		let e = r.toLowerCase();
		if (e !== r) {
			let r = hp(e.charCodeAt(0));
			t[r] = r;
		}
	}
}
function cB(e, t) {
	return nD(e.value, (e) => "number" == typeof e ? nY(t, e) : void 0 !== nD(t, (t) => e.from <= t && t <= e.to));
}
function cF(e) {
	let t = e.quantifier;
	return !!t && 0 === t.atLeast || !!e.value && (eQ(e.value) ? nR(e.value, cF) : cF(e.value));
}
h(cD, "getOptimizedStartCodesIndices"), h(cO, "firstCharOptimizedIndices"), h(c$, "addOptimizedIdxToResult"), h(cP, "handleIgnoreCase"), h(cB, "findCode"), h(cF, "isWholeOptional");
var cz = class extends lo {
	static {
		h(this, "CharCodeFinder");
	}
	constructor(e) {
		super(), this.targetCharCodes = e, this.found = !1;
	}
	visitChildren(e) {
		if (!0 !== this.found) {
			switch (e.type) {
				case "Lookahead":
					this.visitLookahead(e);
					return;
				case "NegativeLookahead":
					this.visitNegativeLookahead(e);
					return;
			}
			super.visitChildren(e);
		}
	}
	visitCharacter(e) {
		nY(this.targetCharCodes, e.value) && (this.found = !0);
	}
	visitSet(e) {
		e.complement ? void 0 === cB(e, this.targetCharCodes) && (this.found = !0) : void 0 !== cB(e, this.targetCharCodes) && (this.found = !0);
	}
};
function cU(e, t) {
	if (!(t instanceof RegExp)) return void 0 !== nD(t, (t) => nY(e, t.charCodeAt(0)));
	{
		let r = cR(t), i = new cz(e);
		return i.visit(r), i.found;
	}
}
h(cU, "canMatchCharCode");
var cG = "PATTERN", cq = "defaultMode", cj = "modes", cW = "boolean" == typeof RegExp("(?:)").sticky;
function cY(e, t) {
	let r, i, n, a, s, o, l, u, d, p, f, g = (t = rO(t, {
		useSticky: cW,
		debug: !1,
		safeMode: !1,
		positionTracking: "full",
		lineTerminatorCharacters: ["\r", `
`],
		tracer: h((e, t) => t(), "tracer")
	})).tracer;
	g("initCharCodeToOptimizedIndexMap", () => {
		hf();
	}), g("Reject Lexer.NA", () => {
		r = ag(e, (e) => e[cG] === hI.NA);
	});
	let m = !1, y;
	g("Transform Patterns", () => {
		m = !1, y = iD(r, (e) => {
			let r = e[cG];
			if (nZ(r)) {
				let e = r.source;
				return 1 !== e.length || "^" === e || "$" === e || "." === e || r.ignoreCase ? 2 !== e.length || "\\" !== e[0] || nY([
					"d",
					"D",
					"s",
					"S",
					"t",
					"r",
					"n",
					"t",
					"0",
					"c",
					"b",
					"B",
					"f",
					"v",
					"w",
					"W"
				], e[1]) ? t.useSticky ? he(r) : c9(r) : e[1] : e;
			}
			if (R(r)) return m = !0, { exec: r };
			if ("object" == typeof r) return m = !0, r;
			if ("string" == typeof r) {
				if (1 === r.length) return r;
				{
					let e = new RegExp(r.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&"));
					return t.useSticky ? he(e) : c9(e);
				}
			}
			throw Error("non exhaustive match");
		});
	}), g("misc mapping", () => {
		i = iD(r, (e) => e.tokenTypeIdx), n = iD(r, (e) => {
			let t = e.GROUP;
			if (t !== hI.SKIPPED) {
				if (nj(t)) return t;
				if (iP(t)) return !1;
				throw Error("non exhaustive match");
			}
		}), a = iD(r, (e) => {
			let t = e.LONGER_ALT;
			if (t) return eQ(t) ? iD(t, (e) => nH(r, e)) : [nH(r, t)];
		}), s = iD(r, (e) => e.PUSH_MODE), o = iD(r, (e) => nq(e, "POP_MODE"));
	}), g("Line Terminator Handling", () => {
		let e = hc(t.lineTerminatorCharacters);
		l = iD(r, (e) => !1), "onlyOffset" !== t.positionTracking && (l = iD(r, (t) => nq(t, "LINE_BREAKS") ? !!t.LINE_BREAKS : !1 === ho(t, e) && cU(e, t.PATTERN)));
	}), g("Misc Mapping #2", () => {
		u = iD(r, hn), d = iD(y, ha), p = iJ(r, (e, t) => {
			let r = t.GROUP;
			return nj(r) && r !== hI.SKIPPED && (e[r] = []), e;
		}, {}), f = iD(y, (e, t) => ({
			pattern: y[t],
			longerAlt: a[t],
			canLineTerminator: l[t],
			isCustom: u[t],
			short: d[t],
			group: n[t],
			push: s[t],
			pop: o[t],
			tokenTypeIdx: i[t],
			tokenType: r[t]
		}));
	});
	let v = !0, x = [];
	return t.safeMode || g("First Char Optimization", () => {
		x = iJ(r, (e, r, i) => {
			if ("string" == typeof r.PATTERN) hh(e, hp(r.PATTERN.charCodeAt(0)), f[i]);
			else if (eQ(r.START_CHARS_HINT)) {
				let t;
				rU(r.START_CHARS_HINT, (r) => {
					let n = hp("string" == typeof r ? r.charCodeAt(0) : r);
					t !== n && (t = n, hh(e, n, f[i]));
				});
			} else if (nZ(r.PATTERN)) if (r.PATTERN.unicode) v = !1, t.ensureOptimizations && l5(`${cM}	Unable to analyze < ${r.PATTERN.toString()} > pattern.
	The regexp unicode flag is not currently supported by the regexp-to-ast library.
	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE`);
			else {
				let n = cD(r.PATTERN, t.ensureOptimizations);
				t3(n) && (v = !1), rU(n, (t) => {
					hh(e, t, f[i]);
				});
			}
			else t.ensureOptimizations && l5(`${cM}	TokenType: <${r.name}> is using a custom token pattern without providing <start_chars_hint> parameter.
	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE`), v = !1;
			return e;
		}, []);
	}), {
		emptyGroups: p,
		patternIdxToConfig: f,
		charCodeToPatternIdxToConfig: x,
		hasCustom: m,
		canBeOptimized: v
	};
}
function cV(e, t) {
	let r = [], i = cX(e);
	r = r.concat(i.errors);
	let n = cK(i.valid), a = n.valid;
	return (r = (r = (r = (r = r.concat(n.errors)).concat(cH(a))).concat(c5(a))).concat(c3(a, t))).concat(c6(a));
}
function cH(e) {
	let t = [], r = iI(e, (e) => nZ(e[cG]));
	return (t = (t = (t = (t = t.concat(cQ(r))).concat(c1(r))).concat(c2(r))).concat(c4(r))).concat(cJ(r));
}
function cX(e) {
	let t = iI(e, (e) => !nq(e, cG));
	return {
		errors: iD(t, (e) => ({
			message: "Token Type: ->" + e.name + "<- missing static 'PATTERN' property",
			type: dA.MISSING_PATTERN,
			tokenTypes: [e]
		})),
		valid: nE(e, t)
	};
}
function cK(e) {
	let t = iI(e, (e) => {
		let t = e[cG];
		return !nZ(t) && !R(t) && !nq(t, "exec") && !nj(t);
	});
	return {
		errors: iD(t, (e) => ({
			message: "Token Type: ->" + e.name + "<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",
			type: dA.INVALID_PATTERN,
			tokenTypes: [e]
		})),
		valid: nE(e, t)
	};
}
h(cY, "analyzeTokenTypes"), h(cV, "validatePatterns"), h(cH, "validateRegExpPattern"), h(cX, "findMissingPatterns"), h(cK, "findInvalidPatterns");
var cZ = /[^\\][$]/;
function cQ(e) {
	class t extends lo {
		static {
			h(this, "EndAnchorFinder");
		}
		constructor() {
			super(...arguments), this.found = !1;
		}
		visitEndAnchor(e) {
			this.found = !0;
		}
	}
	return iD(iI(e, (e) => {
		let r = e.PATTERN;
		try {
			let e = cR(r), i = new t();
			return i.visit(e), i.found;
		} catch {
			return cZ.test(r.source);
		}
	}), (e) => ({
		message: `Unexpected RegExp Anchor Error:
	Token Type: ->` + e.name + `<- static 'PATTERN' cannot contain end of input anchor '$'
	See chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.`,
		type: dA.EOI_ANCHOR_FOUND,
		tokenTypes: [e]
	}));
}
function cJ(e) {
	return iD(iI(e, (e) => e.PATTERN.test("")), (e) => ({
		message: "Token Type: ->" + e.name + "<- static 'PATTERN' must not match an empty string",
		type: dA.EMPTY_MATCH_PATTERN,
		tokenTypes: [e]
	}));
}
h(cQ, "findEndOfInputAnchor"), h(cJ, "findEmptyMatchRegExps");
var c0 = /[^\\[][\^]|^\^/;
function c1(e) {
	class t extends lo {
		static {
			h(this, "StartAnchorFinder");
		}
		constructor() {
			super(...arguments), this.found = !1;
		}
		visitStartAnchor(e) {
			this.found = !0;
		}
	}
	return iD(iI(e, (e) => {
		let r = e.PATTERN;
		try {
			let e = cR(r), i = new t();
			return i.visit(e), i.found;
		} catch {
			return c0.test(r.source);
		}
	}), (e) => ({
		message: `Unexpected RegExp Anchor Error:
	Token Type: ->` + e.name + `<- static 'PATTERN' cannot contain start of input anchor '^'
	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.`,
		type: dA.SOI_ANCHOR_FOUND,
		tokenTypes: [e]
	}));
}
function c2(e) {
	return iD(iI(e, (e) => {
		let t = e[cG];
		return t instanceof RegExp && (t.multiline || t.global);
	}), (e) => ({
		message: "Token Type: ->" + e.name + "<- static 'PATTERN' may NOT contain global('g') or multiline('m')",
		type: dA.UNSUPPORTED_FLAGS_FOUND,
		tokenTypes: [e]
	}));
}
function c4(e) {
	let t = [], r = iD(e, (r) => iJ(e, (e, i) => (r.PATTERN.source !== i.PATTERN.source || nY(t, i) || i.PATTERN === hI.NA || (t.push(i), e.push(i)), e), []));
	return iD(iI(r = nx(r), (e) => e.length > 1), (e) => {
		let t = iD(e, (e) => e.name);
		return {
			message: `The same RegExp pattern ->${nO(e).PATTERN}<-has been used in all of the following Token Types: ${t.join(", ")} <-`,
			type: dA.DUPLICATE_PATTERNS_FOUND,
			tokenTypes: e
		};
	});
}
function c5(e) {
	return iD(iI(e, (e) => {
		if (!nq(e, "GROUP")) return !1;
		let t = e.GROUP;
		return t !== hI.SKIPPED && t !== hI.NA && !nj(t);
	}), (e) => ({
		message: "Token Type: ->" + e.name + "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",
		type: dA.INVALID_GROUP_TYPE_FOUND,
		tokenTypes: [e]
	}));
}
function c3(e, t) {
	return iD(iI(e, (e) => void 0 !== e.PUSH_MODE && !nY(t, e.PUSH_MODE)), (e) => ({
		message: `Token Type: ->${e.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${e.PUSH_MODE}<-which does not exist`,
		type: dA.PUSH_MODE_DOES_NOT_EXIST,
		tokenTypes: [e]
	}));
}
function c6(e) {
	let t = [], r = iJ(e, (e, t, r) => {
		let i = t.PATTERN;
		return i === hI.NA || (nj(i) ? e.push({
			str: i,
			idx: r,
			tokenType: t
		}) : nZ(i) && c8(i) && e.push({
			str: i.source,
			idx: r,
			tokenType: t
		})), e;
	}, []);
	return rU(e, (e, i) => {
		rU(r, ({ str: r, idx: n, tokenType: a }) => {
			if (i < n && c7(r, e.PATTERN)) {
				let r = `Token: ->${a.name}<- can never be matched.
Because it appears AFTER the Token Type ->${e.name}<-in the lexer's definition.
See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;
				t.push({
					message: r,
					type: dA.UNREACHABLE_PATTERN,
					tokenTypes: [e, a]
				});
			}
		});
	}), t;
}
function c7(e, t) {
	if (nZ(t)) {
		let r = t.exec(e);
		return null !== r && 0 === r.index;
	}
	if (R(t)) return t(e, 0, [], {});
	if (nq(t, "exec")) return t.exec(e, 0, [], {});
	if ("string" == typeof t) return t === e;
	throw Error("non exhaustive match");
}
function c8(e) {
	return void 0 === nD([
		".",
		"\\",
		"[",
		"]",
		"|",
		"^",
		"$",
		"(",
		")",
		"?",
		"*",
		"+",
		"{"
	], (t) => -1 !== e.source.indexOf(t));
}
function c9(e) {
	let t = e.ignoreCase ? "i" : "";
	return RegExp(`^(?:${e.source})`, t);
}
function he(e) {
	let t = e.ignoreCase ? "iy" : "y";
	return RegExp(`${e.source}`, t);
}
function ht(e, t, r) {
	let i = [];
	return nq(e, cq) || i.push({
		message: "A MultiMode Lexer cannot be initialized without a <" + cq + `> property in its definition
`,
		type: dA.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE
	}), nq(e, cj) || i.push({
		message: "A MultiMode Lexer cannot be initialized without a <" + cj + `> property in its definition
`,
		type: dA.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY
	}), nq(e, cj) && nq(e, cq) && !nq(e.modes, e.defaultMode) && i.push({
		message: `A MultiMode Lexer cannot be initialized with a ${cq}: <${e.defaultMode}>which does not exist
`,
		type: dA.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST
	}), nq(e, cj) && rU(e.modes, (e, t) => {
		rU(e, (r, n) => {
			iP(r) ? i.push({
				message: `A Lexer cannot be initialized using an undefined Token Type. Mode:<${t}> at index: <${n}>
`,
				type: dA.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED
			}) : nq(r, "LONGER_ALT") && rU(eQ(r.LONGER_ALT) ? r.LONGER_ALT : [r.LONGER_ALT], (n) => {
				iP(n) || nY(e, n) || i.push({
					message: `A MultiMode Lexer cannot be initialized with a longer_alt <${n.name}> on token <${r.name}> outside of mode <${t}>
`,
					type: dA.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE
				});
			});
		});
	}), i;
}
function hr(e, t, r) {
	let i = [], n = !1, a = ag(nx(iH(i$(e.modes))), (e) => e[cG] === hI.NA), s = hc(r);
	return t && rU(a, (e) => {
		let t = ho(e, s);
		if (!1 !== t) {
			let r = {
				message: hl(e, t),
				type: t.issue,
				tokenType: e
			};
			i.push(r);
		} else nq(e, "LINE_BREAKS") ? !0 === e.LINE_BREAKS && (n = !0) : cU(s, e.PATTERN) && (n = !0);
	}), t && !n && i.push({
		message: `Warning: No LINE_BREAKS Found.
	This Lexer has been defined to track line and column information,
	But none of the Token Types can be identified as matching a line terminator.
	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS 
	for details.`,
		type: dA.NO_LINE_BREAKS_FLAGS
	}), i;
}
function hi(e) {
	let t = {};
	return rU(t6(e), (r) => {
		if (eQ(e[r])) t[r] = [];
		else throw Error("non exhaustive match");
	}), t;
}
function hn(e) {
	let t = e.PATTERN;
	if (nZ(t)) return !1;
	if (R(t) || nq(t, "exec")) return !0;
	if (nj(t)) return !1;
	throw Error("non exhaustive match");
}
function ha(e) {
	return !!nj(e) && 1 === e.length && e.charCodeAt(0);
}
h(c1, "findStartOfInputAnchor"), h(c2, "findUnsupportedFlags"), h(c4, "findDuplicatePatterns"), h(c5, "findInvalidGroupType"), h(c3, "findModesThatDoNotExist"), h(c6, "findUnreachablePatterns"), h(c7, "testTokenType"), h(c8, "noMetaChar"), h(c9, "addStartOfInput"), h(he, "addStickyFlag"), h(ht, "performRuntimeChecks"), h(hr, "performWarningRuntimeChecks"), h(hi, "cloneEmptyGroups"), h(hn, "isCustomPattern"), h(ha, "isShortPattern");
var hs = {
	test: h(function(e) {
		let t = e.length;
		for (let r = this.lastIndex; r < t; r++) {
			let t = e.charCodeAt(r);
			if (10 === t) return this.lastIndex = r + 1, !0;
			if (13 === t) return 10 === e.charCodeAt(r + 1) ? this.lastIndex = r + 2 : this.lastIndex = r + 1, !0;
		}
		return !1;
	}, "test"),
	lastIndex: 0
};
function ho(e, t) {
	if (nq(e, "LINE_BREAKS")) return !1;
	if (nZ(e.PATTERN)) {
		try {
			cU(t, e.PATTERN);
		} catch (e) {
			return {
				issue: dA.IDENTIFY_TERMINATOR,
				errMsg: e.message
			};
		}
		return !1;
	}
	if (nj(e.PATTERN)) return !1;
	if (hn(e)) return { issue: dA.CUSTOM_LINE_BREAK };
	throw Error("non exhaustive match");
}
function hl(e, t) {
	if (t.issue === dA.IDENTIFY_TERMINATOR) return `Warning: unable to identify line terminator usage in pattern.
	The problem is in the <${e.name}> Token Type
	 Root cause: ${t.errMsg}.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR`;
	if (t.issue === dA.CUSTOM_LINE_BREAK) return `Warning: A Custom Token Pattern should specify the <line_breaks> option.
	The problem is in the <${e.name}> Token Type
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK`;
	throw Error("non exhaustive match");
}
function hc(e) {
	return iD(e, (e) => nj(e) ? e.charCodeAt(0) : e);
}
function hh(e, t, r) {
	void 0 === e[t] ? e[t] = [r] : e[t].push(r);
}
h(ho, "checkLineBreaksIssues"), h(hl, "buildLineBreakIssueMessage"), h(hc, "getCharCodes"), h(hh, "addToMapOfArrays");
var hu = 256, hd = [];
function hp(e) {
	return e < hu ? e : hd[e];
}
function hf() {
	if (t3(hd)) {
		hd = Array(65536);
		for (let e = 0; e < 65536; e++) hd[e] = e > 255 ? 255 + ~~(e / 255) : e;
	}
}
function hg(e, t) {
	let r = e.tokenTypeIdx;
	return r === t.tokenTypeIdx || !0 === t.isParent && !0 === t.categoryMatchesMap[r];
}
function hm(e, t) {
	return e.tokenTypeIdx === t.tokenTypeIdx;
}
h(hp, "charCodeToOptimizedIndex"), h(hf, "initCharCodeToOptimizedIndexMap"), h(hg, "tokenStructuredMatcher"), h(hm, "tokenStructuredMatcherNoCategories");
var hy = 1, hv = {};
function hx(e) {
	let t = hb(e);
	hw(t), hT(t), hk(t), rU(t, (e) => {
		e.isParent = e.categoryMatches.length > 0;
	});
}
function hb(e) {
	let t = rI(e), r = e, i = !0;
	for (; i;) {
		let e = nE(r = nx(iH(iD(r, (e) => e.CATEGORIES))), t);
		t = t.concat(e), t3(e) ? i = !1 : r = e;
	}
	return t;
}
function hw(e) {
	rU(e, (e) => {
		hE(e) || (hv[hy] = e, e.tokenTypeIdx = hy++), hC(e) && !eQ(e.CATEGORIES) && (e.CATEGORIES = [e.CATEGORIES]), hC(e) || (e.CATEGORIES = []), hS(e) || (e.categoryMatches = []), hA(e) || (e.categoryMatchesMap = {});
	});
}
function hk(e) {
	rU(e, (e) => {
		e.categoryMatches = [], rU(e.categoryMatchesMap, (t, r) => {
			e.categoryMatches.push(hv[r].tokenTypeIdx);
		});
	});
}
function hT(e) {
	rU(e, (e) => {
		h_([], e);
	});
}
function h_(e, t) {
	rU(e, (e) => {
		t.categoryMatchesMap[e.tokenTypeIdx] = !0;
	}), rU(t.CATEGORIES, (r) => {
		let i = e.concat(t);
		nY(i, r) || h_(i, r);
	});
}
function hE(e) {
	return nq(e, "tokenTypeIdx");
}
function hC(e) {
	return nq(e, "CATEGORIES");
}
function hS(e) {
	return nq(e, "categoryMatches");
}
function hA(e) {
	return nq(e, "categoryMatchesMap");
}
function hL(e) {
	return nq(e, "tokenTypeIdx");
}
h(hx, "augmentTokenTypes"), h(hb, "expandCategories"), h(hw, "assignTokenDefaultProps"), h(hk, "assignCategoriesTokensProp"), h(hT, "assignCategoriesMapProp"), h(h_, "singleAssignCategoriesToksMap"), h(hE, "hasShortKeyProperty"), h(hC, "hasCategoriesProperty"), h(hS, "hasExtendingTokensTypesProperty"), h(hA, "hasExtendingTokensTypesMapProperty"), h(hL, "isTokenType");
var hR = {
	buildUnableToPopLexerModeMessage: (e) => `Unable to pop Lexer Mode after encountering Token ->${e.image}<- The Mode Stack is empty`,
	buildUnexpectedCharactersMessage: (e, t, r, i, n) => `unexpected character: ->${e.charAt(t)}<- at offset: ${t}, skipped ${r} characters.`
};
(d_ = dA || (dA = {}))[d_.MISSING_PATTERN = 0] = "MISSING_PATTERN", d_[d_.INVALID_PATTERN = 1] = "INVALID_PATTERN", d_[d_.EOI_ANCHOR_FOUND = 2] = "EOI_ANCHOR_FOUND", d_[d_.UNSUPPORTED_FLAGS_FOUND = 3] = "UNSUPPORTED_FLAGS_FOUND", d_[d_.DUPLICATE_PATTERNS_FOUND = 4] = "DUPLICATE_PATTERNS_FOUND", d_[d_.INVALID_GROUP_TYPE_FOUND = 5] = "INVALID_GROUP_TYPE_FOUND", d_[d_.PUSH_MODE_DOES_NOT_EXIST = 6] = "PUSH_MODE_DOES_NOT_EXIST", d_[d_.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE = 7] = "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE", d_[d_.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY = 8] = "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY", d_[d_.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST = 9] = "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST", d_[d_.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED = 10] = "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED", d_[d_.SOI_ANCHOR_FOUND = 11] = "SOI_ANCHOR_FOUND", d_[d_.EMPTY_MATCH_PATTERN = 12] = "EMPTY_MATCH_PATTERN", d_[d_.NO_LINE_BREAKS_FLAGS = 13] = "NO_LINE_BREAKS_FLAGS", d_[d_.UNREACHABLE_PATTERN = 14] = "UNREACHABLE_PATTERN", d_[d_.IDENTIFY_TERMINATOR = 15] = "IDENTIFY_TERMINATOR", d_[d_.CUSTOM_LINE_BREAK = 16] = "CUSTOM_LINE_BREAK", d_[d_.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE = 17] = "MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE";
var hN = {
	deferDefinitionErrorsHandling: !1,
	positionTracking: "full",
	lineTerminatorsPattern: /\n|\r\n?/g,
	lineTerminatorCharacters: [`
`, "\r"],
	ensureOptimizations: !1,
	safeMode: !1,
	errorMessageProvider: hR,
	traceInitPerf: !1,
	skipValidations: !1,
	recoveryEnabled: !0
};
Object.freeze(hN);
var hI = class {
	static {
		h(this, "Lexer");
	}
	constructor(e, t = hN) {
		if (this.lexerDefinition = e, this.lexerDefinitionErrors = [], this.lexerDefinitionWarning = [], this.patternIdxToConfig = {}, this.charCodeToPatternIdxToConfig = {}, this.modes = [], this.emptyGroups = {}, this.trackStartLines = !0, this.trackEndLines = !0, this.hasCustom = !1, this.canModeBeOptimized = {}, this.TRACE_INIT = (e, t) => {
			if (!0 !== this.traceInitPerf) return t();
			{
				this.traceInitIndent++;
				let r = Array(this.traceInitIndent + 1).join("	");
				this.traceInitIndent < this.traceInitMaxIdent && console.log(`${r}--> <${e}>`);
				let { time: i, value: n } = l6(t), a = i > 10 ? console.warn : console.log;
				return this.traceInitIndent < this.traceInitMaxIdent && a(`${r}<-- <${e}> time: ${i}ms`), this.traceInitIndent--, n;
			}
		}, "boolean" == typeof t) throw Error(`The second argument to the Lexer constructor is now an ILexerConfig Object.
a boolean 2nd argument is no longer supported`);
		this.config = nf({}, hN, t);
		let r = this.config.traceInitPerf;
		!0 === r ? (this.traceInitMaxIdent = Infinity, this.traceInitPerf = !0) : "number" == typeof r && (this.traceInitMaxIdent = r, this.traceInitPerf = !0), this.traceInitIndent = -1, this.TRACE_INIT("Lexer Constructor", () => {
			let r, i = !0;
			this.TRACE_INIT("Lexer Config handling", () => {
				if (this.config.lineTerminatorsPattern === hN.lineTerminatorsPattern) this.config.lineTerminatorsPattern = hs;
				else if (this.config.lineTerminatorCharacters === hN.lineTerminatorCharacters) throw Error(`Error: Missing <lineTerminatorCharacters> property on the Lexer config.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS`);
				if (t.safeMode && t.ensureOptimizations) throw Error("\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.");
				this.trackStartLines = /full|onlyStart/i.test(this.config.positionTracking), this.trackEndLines = /full/i.test(this.config.positionTracking), eQ(e) ? r = {
					modes: { defaultMode: rI(e) },
					defaultMode: cq
				} : (i = !1, r = rI(e));
			}), !1 === this.config.skipValidations && (this.TRACE_INIT("performRuntimeChecks", () => {
				this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(ht(r, this.trackStartLines, this.config.lineTerminatorCharacters));
			}), this.TRACE_INIT("performWarningRuntimeChecks", () => {
				this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(hr(r, this.trackStartLines, this.config.lineTerminatorCharacters));
			})), r.modes = r.modes ? r.modes : {}, rU(r.modes, (e, t) => {
				r.modes[t] = ag(e, (e) => iP(e));
			});
			let n = t6(r.modes);
			if (rU(r.modes, (e, r) => {
				this.TRACE_INIT(`Mode: <${r}> processing`, () => {
					if (this.modes.push(r), !1 === this.config.skipValidations && this.TRACE_INIT("validatePatterns", () => {
						this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(cV(e, n));
					}), t3(this.lexerDefinitionErrors)) {
						let i;
						hx(e), this.TRACE_INIT("analyzeTokenTypes", () => {
							i = cY(e, {
								lineTerminatorCharacters: this.config.lineTerminatorCharacters,
								positionTracking: t.positionTracking,
								ensureOptimizations: t.ensureOptimizations,
								safeMode: t.safeMode,
								tracer: this.TRACE_INIT
							});
						}), this.patternIdxToConfig[r] = i.patternIdxToConfig, this.charCodeToPatternIdxToConfig[r] = i.charCodeToPatternIdxToConfig, this.emptyGroups = nf({}, this.emptyGroups, i.emptyGroups), this.hasCustom = i.hasCustom || this.hasCustom, this.canModeBeOptimized[r] = i.canBeOptimized;
					}
				});
			}), this.defaultMode = r.defaultMode, !t3(this.lexerDefinitionErrors) && !this.config.deferDefinitionErrorsHandling) throw Error(`Errors detected in definition of Lexer:
` + iD(this.lexerDefinitionErrors, (e) => e.message).join(`-----------------------
`));
			rU(this.lexerDefinitionWarning, (e) => {
				l3(e.message);
			}), this.TRACE_INIT("Choosing sub-methods implementations", () => {
				if (cW ? (this.chopInput = tS, this.match = this.matchWithTest) : (this.updateLastIndex = i6, this.match = this.matchWithExec), i && (this.handleModes = i6), !1 === this.trackStartLines && (this.computeNewColumn = tS), !1 === this.trackEndLines && (this.updateTokenEndLineColumnLocation = i6), /full/i.test(this.config.positionTracking)) this.createTokenInstance = this.createFullToken;
				else if (/onlyStart/i.test(this.config.positionTracking)) this.createTokenInstance = this.createStartOnlyToken;
				else if (/onlyOffset/i.test(this.config.positionTracking)) this.createTokenInstance = this.createOffsetOnlyToken;
				else throw Error(`Invalid <positionTracking> config option: "${this.config.positionTracking}"`);
				this.hasCustom ? (this.addToken = this.addTokenUsingPush, this.handlePayload = this.handlePayloadWithCustom) : (this.addToken = this.addTokenUsingMemberAccess, this.handlePayload = this.handlePayloadNoCustom);
			}), this.TRACE_INIT("Failed Optimization Warnings", () => {
				let e = iJ(this.canModeBeOptimized, (e, t, r) => (!1 === t && e.push(r), e), []);
				if (t.ensureOptimizations && !t3(e)) throw Error(`Lexer Modes: < ${e.join(", ")} > cannot be optimized.
	 Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.
	 Or inspect the console log for details on how to resolve these issues.`);
			}), this.TRACE_INIT("clearRegExpParserCache", () => {
				cN();
			}), this.TRACE_INIT("toFastProperties", () => {
				l7(this);
			});
		});
	}
	tokenize(e, t = this.defaultMode) {
		if (!t3(this.lexerDefinitionErrors)) throw Error(`Unable to Tokenize because Errors detected in definition of Lexer:
` + iD(this.lexerDefinitionErrors, (e) => e.message).join(`-----------------------
`));
		return this.tokenizeInternal(e, t);
	}
	tokenizeInternal(e, t) {
		let r, i, n, a, s, o, l, u, d, p, f, g, m, y, v, x, b = e, w = b.length, k = 0, T = 0, _ = Array(this.hasCustom ? 0 : Math.floor(e.length / 10)), E = [], C = this.trackStartLines ? 1 : void 0, S = this.trackStartLines ? 1 : void 0, A = hi(this.emptyGroups), L = this.trackStartLines, R = this.config.lineTerminatorsPattern, N = 0, I = [], M = [], D = [], O = [];
		function $() {
			return I;
		}
		function P(e) {
			let t = M[hp(e)];
			return void 0 === t ? O : t;
		}
		Object.freeze(O), h($, "getPossiblePatternsSlow"), h(P, "getPossiblePatternsOptimized");
		let B = h((e) => {
			if (1 === D.length && void 0 === e.tokenType.PUSH_MODE) {
				let t = this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(e);
				E.push({
					offset: e.startOffset,
					line: e.startLine,
					column: e.startColumn,
					length: e.image.length,
					message: t
				});
			} else {
				D.pop();
				let e = r$(D);
				I = this.patternIdxToConfig[e], M = this.charCodeToPatternIdxToConfig[e], N = I.length;
				let t = this.canModeBeOptimized[e] && !1 === this.config.safeMode;
				r = M && t ? P : $;
			}
		}, "pop_mode");
		function F(e) {
			D.push(e), M = this.charCodeToPatternIdxToConfig[e], N = (I = this.patternIdxToConfig[e]).length, N = I.length;
			let t = this.canModeBeOptimized[e] && !1 === this.config.safeMode;
			r = M && t ? P : $;
		}
		h(F, "push_mode"), F.call(this, t);
		let z, U = this.config.recoveryEnabled;
		for (; k < w;) {
			l = null;
			let t = b.charCodeAt(k), h = r(t), M = h.length;
			for (i = 0; i < M; i++) {
				let r = (z = h[i]).pattern;
				u = null;
				let n = z.short;
				if (!1 !== n ? t === n && (l = r) : !0 === z.isCustom ? null !== (x = r.exec(b, k, _, A)) ? (l = x[0], void 0 !== x.payload && (u = x.payload)) : l = null : (this.updateLastIndex(r, k), l = this.match(r, e, k)), null !== l) {
					if (void 0 !== (o = z.longerAlt)) {
						let t = o.length;
						for (a = 0; a < t; a++) {
							let t = I[o[a]], r = t.pattern;
							if (d = null, !0 === t.isCustom ? null !== (x = r.exec(b, k, _, A)) ? (s = x[0], void 0 !== x.payload && (d = x.payload)) : s = null : (this.updateLastIndex(r, k), s = this.match(r, e, k)), s && s.length > l.length) {
								l = s, u = d, z = t;
								break;
							}
						}
					}
					break;
				}
			}
			if (null !== l) {
				if (p = l.length, void 0 !== (f = z.group) && (g = z.tokenTypeIdx, m = this.createTokenInstance(l, k, g, z.tokenType, C, S, p), this.handlePayload(m, u), !1 === f ? T = this.addToken(_, T, m) : A[f].push(m)), e = this.chopInput(e, p), k += p, S = this.computeNewColumn(S, p), !0 === L && !0 === z.canLineTerminator) {
					let e = 0, t, r;
					R.lastIndex = 0;
					do
						!0 === (t = R.test(l)) && (r = R.lastIndex - 1, e++);
					while (!0 === t);
					0 !== e && (C += e, S = p - r, this.updateTokenEndLineColumnLocation(m, f, r, e, C, S, p));
				}
				this.handleModes(z, B, F, m);
			} else {
				let t = k, r = C, i = S, a = !1 === U;
				for (; !1 === a && k < w;) for (e = this.chopInput(e, 1), k++, n = 0; n < N; n++) {
					let t = I[n], r = t.pattern, i = t.short;
					if (!1 !== i ? b.charCodeAt(k) === i && (a = !0) : !0 === t.isCustom ? a = null !== r.exec(b, k, _, A) : (this.updateLastIndex(r, k), a = null !== r.exec(e)), !0 === a) break;
				}
				if (y = k - t, S = this.computeNewColumn(S, y), v = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(b, t, y, r, i), E.push({
					offset: t,
					line: r,
					column: i,
					length: y,
					message: v
				}), !1 === U) break;
			}
		}
		return this.hasCustom || (_.length = T), {
			tokens: _,
			groups: A,
			errors: E
		};
	}
	handleModes(e, t, r, i) {
		if (!0 === e.pop) {
			let n = e.push;
			t(i), void 0 !== n && r.call(this, n);
		} else void 0 !== e.push && r.call(this, e.push);
	}
	chopInput(e, t) {
		return e.substring(t);
	}
	updateLastIndex(e, t) {
		e.lastIndex = t;
	}
	updateTokenEndLineColumnLocation(e, t, r, i, n, a, s) {
		let o, l;
		void 0 !== t && (l = (o = r === s - 1) ? -1 : 0, 1 === i && !0 === o || (e.endLine = n + l, e.endColumn = a - 1 + -l));
	}
	computeNewColumn(e, t) {
		return e + t;
	}
	createOffsetOnlyToken(e, t, r, i) {
		return {
			image: e,
			startOffset: t,
			tokenTypeIdx: r,
			tokenType: i
		};
	}
	createStartOnlyToken(e, t, r, i, n, a) {
		return {
			image: e,
			startOffset: t,
			startLine: n,
			startColumn: a,
			tokenTypeIdx: r,
			tokenType: i
		};
	}
	createFullToken(e, t, r, i, n, a, s) {
		return {
			image: e,
			startOffset: t,
			endOffset: t + s - 1,
			startLine: n,
			endLine: n,
			startColumn: a,
			endColumn: a + s - 1,
			tokenTypeIdx: r,
			tokenType: i
		};
	}
	addTokenUsingPush(e, t, r) {
		return e.push(r), t;
	}
	addTokenUsingMemberAccess(e, t, r) {
		return e[t] = r, ++t;
	}
	handlePayloadNoCustom(e, t) {}
	handlePayloadWithCustom(e, t) {
		null !== t && (e.payload = t);
	}
	matchWithTest(e, t, r) {
		return !0 === e.test(t) ? t.substring(r, e.lastIndex) : null;
	}
	matchWithExec(e, t) {
		let r = e.exec(t);
		return null !== r ? r[0] : null;
	}
};
function hM(e) {
	return hD(e) ? e.LABEL : e.name;
}
function hD(e) {
	return nj(e.LABEL) && "" !== e.LABEL;
}
hI.SKIPPED = "This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.", hI.NA = /NOT_APPLICABLE/, h(hM, "tokenLabel"), h(hD, "hasTokenLabel");
var hO = "categories", h$ = "label", hP = "group", hB = "push_mode", hF = "pop_mode", hz = "longer_alt", hU = "line_breaks", hG = "start_chars_hint";
function hq(e) {
	return hj(e);
}
function hj(e) {
	let t = e.pattern, r = {};
	if (r.name = e.name, iP(t) || (r.PATTERN = t), nq(e, "parent")) throw `The parent property is no longer supported.
See: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.`;
	return nq(e, hO) && (r.CATEGORIES = e[hO]), hx([r]), nq(e, h$) && (r.LABEL = e[h$]), nq(e, hP) && (r.GROUP = e[hP]), nq(e, hF) && (r.POP_MODE = e[hF]), nq(e, hB) && (r.PUSH_MODE = e[hB]), nq(e, hz) && (r.LONGER_ALT = e[hz]), nq(e, hU) && (r.LINE_BREAKS = e[hU]), nq(e, hG) && (r.START_CHARS_HINT = e[hG]), r;
}
h(hq, "createToken"), h(hj, "createTokenInternal");
var hW = hq({
	name: "EOF",
	pattern: hI.NA
});
function hY(e, t, r, i, n, a, s, o) {
	return {
		image: t,
		startOffset: r,
		endOffset: i,
		startLine: n,
		endLine: a,
		startColumn: s,
		endColumn: o,
		tokenTypeIdx: e.tokenTypeIdx,
		tokenType: e
	};
}
function hV(e, t) {
	return hg(e, t);
}
hx([hW]), h(hY, "createTokenInstance"), h(hV, "tokenMatcher");
var hH = {
	buildMismatchTokenMessage: ({ expected: e, actual: t, previous: r, ruleName: i }) => `Expecting ${hD(e) ? `--> ${hM(e)} <--` : `token of type --> ${e.name} <--`} but found --> '${t.image}' <--`,
	buildNotAllInputParsedMessage: ({ firstRedundant: e, ruleName: t }) => "Redundant input, expecting EOF but found: " + e.image,
	buildNoViableAltMessage({ expectedPathsPerAlt: e, actual: t, previous: r, customUserDescription: i, ruleName: n }) {
		let a = `
but found: '` + nO(t).image + "'";
		return i ? "Expecting: " + i + a : `Expecting: one of these possible Token sequences:
${iD(iD(iJ(e, (e, t) => e.concat(t), []), (e) => `[${iD(e, (e) => hM(e)).join(", ")}]`), (e, t) => `  ${t + 1}. ${e}`).join(`
`)}` + a;
	},
	buildEarlyExitMessage({ expectedIterationPaths: e, actual: t, customUserDescription: r, ruleName: i }) {
		let n = `
but found: '` + nO(t).image + "'";
		return r ? "Expecting: " + r + n : `Expecting: expecting at least one iteration which starts with one of these possible Token sequences::
  <${iD(e, (e) => `[${iD(e, (e) => hM(e)).join(",")}]`).join(" ,")}>` + n;
	}
};
Object.freeze(hH);
var hX = { buildRuleNotFoundError: (e, t) => "Invalid grammar, reference to a rule which is not defined: ->" + t.nonTerminalName + `<-
inside top level rule: ->` + e.name + "<-" }, hK = {
	buildDuplicateFoundError(e, t) {
		function r(e) {
			return e instanceof ch ? e.terminalType.name : e instanceof ct ? e.nonTerminalName : "";
		}
		h(r, "getExtraProductionArgument");
		let i = e.name, n = nO(t), a = n.idx, s = cy(n), o = r(n), l = `->${s}${a > 0 ? a : ""}<- ${o ? `with argument: ->${o}<-` : ""}
                  appears more than once (${t.length} times) in the top level rule: ->${i}<-.                  
                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES 
                  `;
		return (l = l.replace(/[ \t]+/g, " ")).replace(/\s\s+/g, `
`);
	},
	buildNamespaceConflictError: (e) => `Namespace conflict found in grammar.
The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${e.name}>.
To resolve this make sure each Terminal and Non-Terminal names are unique
This is easy to accomplish by using the convention that Terminal names start with an uppercase letter
and Non-Terminal names start with a lower case letter.`,
	buildAlternationPrefixAmbiguityError(e) {
		let t = iD(e.prefixPath, (e) => hM(e)).join(", "), r = 0 === e.alternation.idx ? "" : e.alternation.idx;
		return `Ambiguous alternatives: <${e.ambiguityIndices.join(" ,")}> due to common lookahead prefix
in <OR${r}> inside <${e.topLevelRule.name}> Rule,
<${t}> may appears as a prefix path in all these alternatives.
See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX
For Further details.`;
	},
	buildAlternationAmbiguityError(e) {
		let t = iD(e.prefixPath, (e) => hM(e)).join(", "), r = 0 === e.alternation.idx ? "" : e.alternation.idx;
		return `Ambiguous Alternatives Detected: <${e.ambiguityIndices.join(" ,")}> in <OR${r}> inside <${e.topLevelRule.name}> Rule,
<${t}> may appears as a prefix path in all these alternatives.
See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.`;
	},
	buildEmptyRepetitionError(e) {
		let t = cy(e.repetition);
		return 0 !== e.repetition.idx && (t += e.repetition.idx), `The repetition <${t}> within Rule <${e.topLevelRule.name}> can never consume any tokens.
This could lead to an infinite loop.`;
	},
	buildTokenNameError: (e) => "deprecated",
	buildEmptyAlternationError: (e) => `Ambiguous empty alternative: <${e.emptyChoiceIdx + 1}> in <OR${e.alternation.idx}> inside <${e.topLevelRule.name}> Rule.
Only the last alternative may be an empty alternative.`,
	buildTooManyAlternativesError: (e) => `An Alternation cannot have more than 256 alternatives:
<OR${e.alternation.idx}> inside <${e.topLevelRule.name}> Rule.
 has ${e.alternation.definition.length + 1} alternatives.`,
	buildLeftRecursionError(e) {
		let t = e.topLevelRule.name;
		return `Left Recursion found in grammar.
rule: <${t}> can be invoked from itself (directly or indirectly)
without consuming any Tokens. The grammar path that causes this is: 
 ${t} --> ${iD(e.leftRecursionPath, (e) => e.name).concat([t]).join(" --> ")}
 To fix this refactor your grammar to remove the left recursion.
see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`;
	},
	buildInvalidRuleNameError: (e) => "deprecated",
	buildDuplicateRuleNameError(e) {
		let t;
		return t = e.topLevelRule instanceof cr ? e.topLevelRule.name : e.topLevelRule, `Duplicate definition, rule: ->${t}<- is already defined in the grammar: ->${e.grammarName}<-`;
	}
};
function hZ(e, t) {
	let r = new hQ(e, t);
	return r.resolveRefs(), r.errors;
}
h(hZ, "resolveGrammar");
var hQ = class extends cp {
	static {
		h(this, "GastRefResolverVisitor");
	}
	constructor(e, t) {
		super(), this.nameToTopRule = e, this.errMsgProvider = t, this.errors = [];
	}
	resolveRefs() {
		rU(i$(this.nameToTopRule), (e) => {
			this.currTopLevel = e, e.accept(this);
		});
	}
	visitNonTerminal(e) {
		let t = this.nameToTopRule[e.nonTerminalName];
		if (t) e.referencedRule = t;
		else {
			let t = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, e);
			this.errors.push({
				message: t,
				type: dN.UNRESOLVED_SUBRULE_REF,
				ruleName: this.currTopLevel.name,
				unresolvedRefName: e.nonTerminalName
			});
		}
	}
}, hJ = class extends cv {
	static {
		h(this, "AbstractNextPossibleTokensWalker");
	}
	constructor(e, t) {
		super(), this.topProd = e, this.path = t, this.possibleTokTypes = [], this.nextProductionName = "", this.nextProductionOccurrence = 0, this.found = !1, this.isAtEndOfPath = !1;
	}
	startWalking() {
		if (this.found = !1, this.path.ruleStack[0] !== this.topProd.name) throw Error("The path does not start with the walker's top Rule!");
		return this.ruleStack = rI(this.path.ruleStack).reverse(), this.occurrenceStack = rI(this.path.occurrenceStack).reverse(), this.ruleStack.pop(), this.occurrenceStack.pop(), this.updateExpectedNext(), this.walk(this.topProd), this.possibleTokTypes;
	}
	walk(e, t = []) {
		this.found || super.walk(e, t);
	}
	walkProdRef(e, t, r) {
		if (e.referencedRule.name === this.nextProductionName && e.idx === this.nextProductionOccurrence) {
			let i = t.concat(r);
			this.updateExpectedNext(), this.walk(e.referencedRule, i);
		}
	}
	updateExpectedNext() {
		t3(this.ruleStack) ? (this.nextProductionName = "", this.nextProductionOccurrence = 0, this.isAtEndOfPath = !0) : (this.nextProductionName = this.ruleStack.pop(), this.nextProductionOccurrence = this.occurrenceStack.pop());
	}
}, h0 = class extends hJ {
	static {
		h(this, "NextAfterTokenWalker");
	}
	constructor(e, t) {
		super(e, t), this.path = t, this.nextTerminalName = "", this.nextTerminalOccurrence = 0, this.nextTerminalName = this.path.lastTok.name, this.nextTerminalOccurrence = this.path.lastTokOccurrence;
	}
	walkTerminal(e, t, r) {
		this.isAtEndOfPath && e.terminalType.name === this.nextTerminalName && e.idx === this.nextTerminalOccurrence && !this.found && (this.possibleTokTypes = cb(new ci({ definition: t.concat(r) })), this.found = !0);
	}
}, h1 = class extends cv {
	static {
		h(this, "AbstractNextTerminalAfterProductionWalker");
	}
	constructor(e, t) {
		super(), this.topRule = e, this.occurrence = t, this.result = {
			token: void 0,
			occurrence: void 0,
			isEndOfRule: void 0
		};
	}
	startWalking() {
		return this.walk(this.topRule), this.result;
	}
}, h2 = class extends h1 {
	static {
		h(this, "NextTerminalAfterManyWalker");
	}
	walkMany(e, t, r) {
		if (e.idx === this.occurrence) {
			let e = nO(t.concat(r));
			this.result.isEndOfRule = void 0 === e, e instanceof ch && (this.result.token = e.terminalType, this.result.occurrence = e.idx);
		} else super.walkMany(e, t, r);
	}
}, h4 = class extends h1 {
	static {
		h(this, "NextTerminalAfterManySepWalker");
	}
	walkManySep(e, t, r) {
		if (e.idx === this.occurrence) {
			let e = nO(t.concat(r));
			this.result.isEndOfRule = void 0 === e, e instanceof ch && (this.result.token = e.terminalType, this.result.occurrence = e.idx);
		} else super.walkManySep(e, t, r);
	}
}, h5 = class extends h1 {
	static {
		h(this, "NextTerminalAfterAtLeastOneWalker");
	}
	walkAtLeastOne(e, t, r) {
		if (e.idx === this.occurrence) {
			let e = nO(t.concat(r));
			this.result.isEndOfRule = void 0 === e, e instanceof ch && (this.result.token = e.terminalType, this.result.occurrence = e.idx);
		} else super.walkAtLeastOne(e, t, r);
	}
}, h3 = class extends h1 {
	static {
		h(this, "NextTerminalAfterAtLeastOneSepWalker");
	}
	walkAtLeastOneSep(e, t, r) {
		if (e.idx === this.occurrence) {
			let e = nO(t.concat(r));
			this.result.isEndOfRule = void 0 === e, e instanceof ch && (this.result.token = e.terminalType, this.result.occurrence = e.idx);
		} else super.walkAtLeastOneSep(e, t, r);
	}
};
function h6(e, t, r = []) {
	r = rI(r);
	let i = [], n = 0;
	function a(t) {
		return t.concat(nC(e, n + 1));
	}
	function s(e) {
		let n = h6(a(e), t, r);
		return i.concat(n);
	}
	for (h(a, "remainingPathWith"), h(s, "getAlternativesForProd"); r.length < t && n < e.length;) {
		let t = e[n];
		if (t instanceof ci || t instanceof ct) return s(t.definition);
		if (t instanceof cn) i = s(t.definition);
		else if (t instanceof ca) return s(t.definition.concat([new co({ definition: t.definition })]));
		else if (t instanceof cs) return s([new ci({ definition: t.definition }), new co({ definition: [new ch({ terminalType: t.separator })].concat(t.definition) })]);
		else if (t instanceof cl) i = s(t.definition.concat([new co({ definition: [new ch({ terminalType: t.separator })].concat(t.definition) })]));
		else if (t instanceof co) i = s(t.definition.concat([new co({ definition: t.definition })]));
		else {
			if (t instanceof cc) return rU(t.definition, (e) => {
				!1 === t3(e.definition) && (i = s(e.definition));
			}), i;
			if (t instanceof ch) r.push(t.terminalType);
			else throw Error("non exhaustive match");
		}
		n++;
	}
	return i.push({
		partialPath: r,
		suffixDef: nC(e, n)
	}), i;
}
function h7(e, t, r, i) {
	let n = "EXIT_NONE_TERMINAL", a = [n], s = "EXIT_ALTERNATIVE", o = !1, l = t.length, h = l - i - 1, u = [], d = [];
	for (d.push({
		idx: -1,
		def: e,
		ruleStack: [],
		occurrenceStack: []
	}); !t3(d);) {
		let e = d.pop();
		if (e === s) {
			o && r$(d).idx <= h && d.pop();
			continue;
		}
		let i = e.def, p = e.idx, f = e.ruleStack, g = e.occurrenceStack;
		if (t3(i)) continue;
		let m = i[0];
		if (m === n) {
			let e = {
				idx: p,
				def: nC(i),
				ruleStack: nS(f),
				occurrenceStack: nS(g)
			};
			d.push(e);
		} else if (m instanceof ch) if (p < l - 1) {
			let e = p + 1;
			if (r(t[e], m.terminalType)) {
				let t = {
					idx: e,
					def: nC(i),
					ruleStack: f,
					occurrenceStack: g
				};
				d.push(t);
			}
		} else if (p === l - 1) u.push({
			nextTokenType: m.terminalType,
			nextTokenOccurrence: m.idx,
			ruleStack: f,
			occurrenceStack: g
		}), o = !0;
		else throw Error("non exhaustive match");
		else if (m instanceof ct) {
			let e = rI(f);
			e.push(m.nonTerminalName);
			let t = rI(g);
			t.push(m.idx);
			let r = {
				idx: p,
				def: m.definition.concat(a, nC(i)),
				ruleStack: e,
				occurrenceStack: t
			};
			d.push(r);
		} else if (m instanceof cn) {
			let e = {
				idx: p,
				def: nC(i),
				ruleStack: f,
				occurrenceStack: g
			};
			d.push(e), d.push(s);
			let t = {
				idx: p,
				def: m.definition.concat(nC(i)),
				ruleStack: f,
				occurrenceStack: g
			};
			d.push(t);
		} else if (m instanceof ca) {
			let e = new co({
				definition: m.definition,
				idx: m.idx
			}), t = {
				idx: p,
				def: m.definition.concat([e], nC(i)),
				ruleStack: f,
				occurrenceStack: g
			};
			d.push(t);
		} else if (m instanceof cs) {
			let e = new co({
				definition: [new ch({ terminalType: m.separator })].concat(m.definition),
				idx: m.idx
			}), t = {
				idx: p,
				def: m.definition.concat([e], nC(i)),
				ruleStack: f,
				occurrenceStack: g
			};
			d.push(t);
		} else if (m instanceof cl) {
			let e = {
				idx: p,
				def: nC(i),
				ruleStack: f,
				occurrenceStack: g
			};
			d.push(e), d.push(s);
			let t = new co({
				definition: [new ch({ terminalType: m.separator })].concat(m.definition),
				idx: m.idx
			}), r = {
				idx: p,
				def: m.definition.concat([t], nC(i)),
				ruleStack: f,
				occurrenceStack: g
			};
			d.push(r);
		} else if (m instanceof co) {
			let e = {
				idx: p,
				def: nC(i),
				ruleStack: f,
				occurrenceStack: g
			};
			d.push(e), d.push(s);
			let t = new co({
				definition: m.definition,
				idx: m.idx
			}), r = {
				idx: p,
				def: m.definition.concat([t], nC(i)),
				ruleStack: f,
				occurrenceStack: g
			};
			d.push(r);
		} else if (m instanceof cc) for (let e = m.definition.length - 1; e >= 0; e--) {
			let t = {
				idx: p,
				def: m.definition[e].definition.concat(nC(i)),
				ruleStack: f,
				occurrenceStack: g
			};
			d.push(t), d.push(s);
		}
		else if (m instanceof ci) d.push({
			idx: p,
			def: m.definition.concat(nC(i)),
			ruleStack: f,
			occurrenceStack: g
		});
		else if (m instanceof cr) d.push(h8(m, p, f, g));
		else throw Error("non exhaustive match");
	}
	return u;
}
function h8(e, t, r, i) {
	let n = rI(r);
	n.push(e.name);
	let a = rI(i);
	return a.push(1), {
		idx: t,
		def: e.definition,
		ruleStack: n,
		occurrenceStack: a
	};
}
function h9(e) {
	if (e instanceof cn || "Option" === e) return dL.OPTION;
	if (e instanceof co || "Repetition" === e) return dL.REPETITION;
	if (e instanceof ca || "RepetitionMandatory" === e) return dL.REPETITION_MANDATORY;
	if (e instanceof cs || "RepetitionMandatoryWithSeparator" === e) return dL.REPETITION_MANDATORY_WITH_SEPARATOR;
	if (e instanceof cl || "RepetitionWithSeparator" === e) return dL.REPETITION_WITH_SEPARATOR;
	if (e instanceof cc || "Alternation" === e) return dL.ALTERNATION;
	throw Error("non exhaustive match");
}
function ue(e) {
	let { occurrence: t, rule: r, prodType: i, maxLookahead: n } = e, a = h9(i);
	return a === dL.ALTERNATION ? uu(t, r, n) : ud(t, r, a, n);
}
function ut(e, t, r, i, n, a) {
	let s = uu(e, t, r);
	return a(s, i, ug(s) ? hm : hg, n);
}
function ur(e, t, r, i, n, a) {
	let s = ud(e, t, n, r), o = ug(s) ? hm : hg;
	return a(s[0], o, i);
}
function ui(e, t, r, i) {
	let n = e.length, a = nR(e, (e) => nR(e, (e) => 1 === e.length));
	if (t) return function(t) {
		let i = iD(t, (e) => e.GATE);
		for (let t = 0; t < n; t++) {
			let n = e[t], a = n.length, s = i[t];
			if (void 0 === s || !1 !== s.call(this)) t: for (let e = 0; e < a; e++) {
				let i = n[e], a = i.length;
				for (let e = 0; e < a; e++) if (!1 === r(this.LA(e + 1), i[e])) continue t;
				return t;
			}
		}
	};
	if (!a || i) return function() {
		for (let t = 0; t < n; t++) {
			let i = e[t], n = i.length;
			t: for (let e = 0; e < n; e++) {
				let n = i[e], a = n.length;
				for (let e = 0; e < a; e++) if (!1 === r(this.LA(e + 1), n[e])) continue t;
				return t;
			}
		}
	};
	{
		let t = iJ(iD(e, (e) => iH(e)), (e, t, r) => (rU(t, (t) => {
			nq(e, t.tokenTypeIdx) || (e[t.tokenTypeIdx] = r), rU(t.categoryMatches, (t) => {
				nq(e, t) || (e[t] = r);
			});
		}), e), {});
		return function() {
			return t[this.LA(1).tokenTypeIdx];
		};
	}
}
function un(e, t, r) {
	let i = nR(e, (e) => 1 === e.length), n = e.length;
	if (!i || r) return function() {
		t: for (let r = 0; r < n; r++) {
			let i = e[r], n = i.length;
			for (let e = 0; e < n; e++) if (!1 === t(this.LA(e + 1), i[e])) continue t;
			return !0;
		}
		return !1;
	};
	{
		let t = iH(e);
		if (1 === t.length && t3(t[0].categoryMatches)) {
			let e = t[0].tokenTypeIdx;
			return function() {
				return this.LA(1).tokenTypeIdx === e;
			};
		}
		{
			let e = iJ(t, (e, t, r) => (e[t.tokenTypeIdx] = !0, rU(t.categoryMatches, (t) => {
				e[t] = !0;
			}), e), []);
			return function() {
				return !0 === e[this.LA(1).tokenTypeIdx];
			};
		}
	}
}
h(h6, "possiblePathsFrom"), h(h7, "nextPossibleTokensAfter"), h(h8, "expandTopLevelRule"), (dE = dL || (dL = {}))[dE.OPTION = 0] = "OPTION", dE[dE.REPETITION = 1] = "REPETITION", dE[dE.REPETITION_MANDATORY = 2] = "REPETITION_MANDATORY", dE[dE.REPETITION_MANDATORY_WITH_SEPARATOR = 3] = "REPETITION_MANDATORY_WITH_SEPARATOR", dE[dE.REPETITION_WITH_SEPARATOR = 4] = "REPETITION_WITH_SEPARATOR", dE[dE.ALTERNATION = 5] = "ALTERNATION", h(h9, "getProdType"), h(ue, "getLookaheadPaths"), h(ut, "buildLookaheadFuncForOr"), h(ur, "buildLookaheadFuncForOptionalProd"), h(ui, "buildAlternativesLookAheadFunc"), h(un, "buildSingleAlternativeLookaheadFunction");
var ua = class extends cv {
	static {
		h(this, "RestDefinitionFinderWalker");
	}
	constructor(e, t, r) {
		super(), this.topProd = e, this.targetOccurrence = t, this.targetProdType = r;
	}
	startWalking() {
		return this.walk(this.topProd), this.restDef;
	}
	checkIsTarget(e, t, r, i) {
		return e.idx === this.targetOccurrence && this.targetProdType === t && (this.restDef = r.concat(i), !0);
	}
	walkOption(e, t, r) {
		this.checkIsTarget(e, dL.OPTION, t, r) || super.walkOption(e, t, r);
	}
	walkAtLeastOne(e, t, r) {
		this.checkIsTarget(e, dL.REPETITION_MANDATORY, t, r) || super.walkOption(e, t, r);
	}
	walkAtLeastOneSep(e, t, r) {
		this.checkIsTarget(e, dL.REPETITION_MANDATORY_WITH_SEPARATOR, t, r) || super.walkOption(e, t, r);
	}
	walkMany(e, t, r) {
		this.checkIsTarget(e, dL.REPETITION, t, r) || super.walkOption(e, t, r);
	}
	walkManySep(e, t, r) {
		this.checkIsTarget(e, dL.REPETITION_WITH_SEPARATOR, t, r) || super.walkOption(e, t, r);
	}
}, us = class extends cp {
	static {
		h(this, "InsideDefinitionFinderVisitor");
	}
	constructor(e, t, r) {
		super(), this.targetOccurrence = e, this.targetProdType = t, this.targetRef = r, this.result = [];
	}
	checkIsTarget(e, t) {
		e.idx === this.targetOccurrence && this.targetProdType === t && (void 0 === this.targetRef || e === this.targetRef) && (this.result = e.definition);
	}
	visitOption(e) {
		this.checkIsTarget(e, dL.OPTION);
	}
	visitRepetition(e) {
		this.checkIsTarget(e, dL.REPETITION);
	}
	visitRepetitionMandatory(e) {
		this.checkIsTarget(e, dL.REPETITION_MANDATORY);
	}
	visitRepetitionMandatoryWithSeparator(e) {
		this.checkIsTarget(e, dL.REPETITION_MANDATORY_WITH_SEPARATOR);
	}
	visitRepetitionWithSeparator(e) {
		this.checkIsTarget(e, dL.REPETITION_WITH_SEPARATOR);
	}
	visitAlternation(e) {
		this.checkIsTarget(e, dL.ALTERNATION);
	}
};
function uo(e) {
	let t = Array(e);
	for (let r = 0; r < e; r++) t[r] = [];
	return t;
}
function ul(e) {
	let t = [""];
	for (let r = 0; r < e.length; r++) {
		let i = e[r], n = [];
		for (let e = 0; e < t.length; e++) {
			let r = t[e];
			n.push(r + "_" + i.tokenTypeIdx);
			for (let e = 0; e < i.categoryMatches.length; e++) {
				let t = "_" + i.categoryMatches[e];
				n.push(r + t);
			}
		}
		t = n;
	}
	return t;
}
function uc(e, t, r) {
	for (let i = 0; i < e.length; i++) {
		if (i === r) continue;
		let n = e[i];
		for (let e = 0; e < t.length; e++) if (!0 === n[t[e]]) return !1;
	}
	return !0;
}
function uh(e, t) {
	let r = iD(e, (e) => h6([e], 1)), i = uo(r.length), n = iD(r, (e) => {
		let t = {};
		return rU(e, (e) => {
			rU(ul(e.partialPath), (e) => {
				t[e] = !0;
			});
		}), t;
	}), a = r;
	for (let e = 1; e <= t; e++) {
		let r = a;
		a = uo(r.length);
		for (let s = 0; s < r.length; s++) {
			let o = r[s];
			for (let r = 0; r < o.length; r++) {
				let l = o[r].partialPath, h = o[r].suffixDef, u = ul(l);
				if (uc(n, u, s) || t3(h) || l.length === t) {
					let e = i[s];
					if (!1 === up(e, l)) {
						e.push(l);
						for (let e = 0; e < u.length; e++) {
							let t = u[e];
							n[s][t] = !0;
						}
					}
				} else {
					let t = h6(h, e + 1, l);
					a[s] = a[s].concat(t), rU(t, (e) => {
						rU(ul(e.partialPath), (e) => {
							n[s][e] = !0;
						});
					});
				}
			}
		}
	}
	return i;
}
function uu(e, t, r, i) {
	let n = new us(e, dL.ALTERNATION, i);
	return t.accept(n), uh(n.result, r);
}
function ud(e, t, r, i) {
	let n = new us(e, r);
	t.accept(n);
	let a = n.result, s = new ua(t, e, r).startWalking();
	return uh([new ci({ definition: a }), new ci({ definition: s })], i);
}
function up(e, t) {
	t: for (let r = 0; r < e.length; r++) {
		let i = e[r];
		if (i.length === t.length) {
			for (let e = 0; e < i.length; e++) {
				let r = t[e], n = i[e];
				if ((r === n || void 0 !== n.categoryMatchesMap[r.tokenTypeIdx]) == !1) continue t;
			}
			return !0;
		}
	}
	return !1;
}
function uf(e, t) {
	return e.length < t.length && nR(e, (e, r) => {
		let i = t[r];
		return e === i || i.categoryMatchesMap[e.tokenTypeIdx];
	});
}
function ug(e) {
	return nR(e, (e) => nR(e, (e) => nR(e, (e) => t3(e.categoryMatches))));
}
function um(e) {
	return iD(e.lookaheadStrategy.validate({
		rules: e.rules,
		tokenTypes: e.tokenTypes,
		grammarName: e.grammarName
	}), (e) => Object.assign({ type: dN.CUSTOM_LOOKAHEAD_VALIDATION }, e));
}
function uy(e, t, r, i) {
	let n = n$(e, (e) => uv(e, r)), a = uD(e, t, r), s = n$(e, (e) => uR(e, r)), o = n$(e, (t) => uk(t, e, i, r));
	return n.concat(a, s, o);
}
function uv(e, t) {
	let r = new uw();
	return e.accept(r), iD(i$(n2(nz(r.allProductions, ux), (e) => e.length > 1)), (r) => {
		let i = nO(r), n = t.buildDuplicateFoundError(e, r), a = cy(i), s = {
			message: n,
			type: dN.DUPLICATE_PRODUCTIONS,
			ruleName: e.name,
			dslName: a,
			occurrence: i.idx
		}, o = ub(i);
		return o && (s.parameter = o), s;
	});
}
function ux(e) {
	return `${cy(e)}_#_${e.idx}_#_${ub(e)}`;
}
function ub(e) {
	return e instanceof ch ? e.terminalType.name : e instanceof ct ? e.nonTerminalName : "";
}
h(uo, "initializeArrayOfArrays"), h(ul, "pathToHashKeys"), h(uc, "isUniquePrefixHash"), h(uh, "lookAheadSequenceFromAlternatives"), h(uu, "getLookaheadPathsForOr"), h(ud, "getLookaheadPathsForOptionalProd"), h(up, "containsPath"), h(uf, "isStrictPrefixOfPath"), h(ug, "areTokenCategoriesNotUsed"), h(um, "validateLookahead"), h(uy, "validateGrammar"), h(uv, "validateDuplicateProductions"), h(ux, "identifyProductionForDuplicates"), h(ub, "getExtraProductionArgument");
var uw = class extends cp {
	static {
		h(this, "OccurrenceValidationCollector");
	}
	constructor() {
		super(...arguments), this.allProductions = [];
	}
	visitNonTerminal(e) {
		this.allProductions.push(e);
	}
	visitOption(e) {
		this.allProductions.push(e);
	}
	visitRepetitionWithSeparator(e) {
		this.allProductions.push(e);
	}
	visitRepetitionMandatory(e) {
		this.allProductions.push(e);
	}
	visitRepetitionMandatoryWithSeparator(e) {
		this.allProductions.push(e);
	}
	visitRepetition(e) {
		this.allProductions.push(e);
	}
	visitAlternation(e) {
		this.allProductions.push(e);
	}
	visitTerminal(e) {
		this.allProductions.push(e);
	}
};
function uk(e, t, r, i) {
	let n = [];
	if (iJ(t, (t, r) => r.name === e.name ? t + 1 : t, 0) > 1) {
		let t = i.buildDuplicateRuleNameError({
			topLevelRule: e,
			grammarName: r
		});
		n.push({
			message: t,
			type: dN.DUPLICATE_RULE_NAME,
			ruleName: e.name
		});
	}
	return n;
}
function uT(e, t, r) {
	let i = [];
	return nY(t, e) || i.push({
		message: `Invalid rule override, rule: ->${e}<- cannot be overridden in the grammar: ->${r}<-as it is not defined in any of the super grammars `,
		type: dN.INVALID_RULE_OVERRIDE,
		ruleName: e
	}), i;
}
function u_(e, t, r, i = []) {
	let n = [], a = uE(t.definition);
	if (t3(a)) return [];
	{
		let t = e.name;
		nY(a, e) && n.push({
			message: r.buildLeftRecursionError({
				topLevelRule: e,
				leftRecursionPath: i
			}),
			type: dN.LEFT_RECURSION,
			ruleName: t
		});
		let s = n$(nE(a, i.concat([e])), (t) => {
			let n = rI(i);
			return n.push(t), u_(e, t, r, n);
		});
		return n.concat(s);
	}
}
function uE(e) {
	let t = [];
	if (t3(e)) return t;
	let r = nO(e);
	if (r instanceof ct) t.push(r.referencedRule);
	else if (r instanceof ci || r instanceof cn || r instanceof ca || r instanceof cs || r instanceof cl || r instanceof co) t = t.concat(uE(r.definition));
	else if (r instanceof cc) t = iH(iD(r.definition, (e) => uE(e.definition)));
	else if (!(r instanceof ch)) throw Error("non exhaustive match");
	let i = cg(r), n = e.length > 1;
	if (!i || !n) return t;
	{
		let r = nC(e);
		return t.concat(uE(r));
	}
}
h(uk, "validateRuleDoesNotAlreadyExist"), h(uT, "validateRuleIsOverridden"), h(u_, "validateNoLeftRecursion"), h(uE, "getFirstNoneTerminal");
var uC = class extends cp {
	static {
		h(this, "OrCollector");
	}
	constructor() {
		super(...arguments), this.alternations = [];
	}
	visitAlternation(e) {
		this.alternations.push(e);
	}
};
function uS(e, t) {
	let r = new uC();
	return e.accept(r), n$(r.alternations, (r) => n$(nS(r.definition), (i, n) => t3(h7([i], [], hg, 1)) ? [{
		message: t.buildEmptyAlternationError({
			topLevelRule: e,
			alternation: r,
			emptyChoiceIdx: n
		}),
		type: dN.NONE_LAST_EMPTY_ALT,
		ruleName: e.name,
		occurrence: r.idx,
		alternative: n + 1
	}] : []));
}
function uA(e, t, r) {
	let i = new uC();
	e.accept(i);
	let n = i.alternations;
	return n$(n = ag(n, (e) => !0 === e.ignoreAmbiguities), (i) => {
		let n = uu(i.idx, e, i.maxLookahead || t, i), a = uI(n, i, e, r), s = uM(n, i, e, r);
		return a.concat(s);
	});
}
h(uS, "validateEmptyOrAlternative"), h(uA, "validateAmbiguousAlternationAlternatives");
var uL = class extends cp {
	static {
		h(this, "RepetitionCollector");
	}
	constructor() {
		super(...arguments), this.allProductions = [];
	}
	visitRepetitionWithSeparator(e) {
		this.allProductions.push(e);
	}
	visitRepetitionMandatory(e) {
		this.allProductions.push(e);
	}
	visitRepetitionMandatoryWithSeparator(e) {
		this.allProductions.push(e);
	}
	visitRepetition(e) {
		this.allProductions.push(e);
	}
};
function uR(e, t) {
	let r = new uC();
	return e.accept(r), n$(r.alternations, (r) => r.definition.length > 255 ? [{
		message: t.buildTooManyAlternativesError({
			topLevelRule: e,
			alternation: r
		}),
		type: dN.TOO_MANY_ALTS,
		ruleName: e.name,
		occurrence: r.idx
	}] : []);
}
function uN(e, t, r) {
	let i = [];
	return rU(e, (e) => {
		let n = new uL();
		e.accept(n), rU(n.allProductions, (n) => {
			let a = h9(n), s = n.maxLookahead || t;
			if (t3(iH(ud(n.idx, e, a, s)[0]))) {
				let t = r.buildEmptyRepetitionError({
					topLevelRule: e,
					repetition: n
				});
				i.push({
					message: t,
					type: dN.NO_NON_EMPTY_LOOKAHEAD,
					ruleName: e.name
				});
			}
		});
	}), i;
}
function uI(e, t, r, i) {
	let n = [];
	return iD(iJ(e, (r, i, a) => (!0 === t.definition[a].ignoreAmbiguities || rU(i, (i) => {
		let s = [a];
		rU(e, (e, r) => {
			a !== r && up(e, i) && !0 !== t.definition[r].ignoreAmbiguities && s.push(r);
		}), s.length > 1 && !up(n, i) && (n.push(i), r.push({
			alts: s,
			path: i
		}));
	}), r), []), (e) => {
		let n = iD(e.alts, (e) => e + 1);
		return {
			message: i.buildAlternationAmbiguityError({
				topLevelRule: r,
				alternation: t,
				ambiguityIndices: n,
				prefixPath: e.path
			}),
			type: dN.AMBIGUOUS_ALTS,
			ruleName: r.name,
			occurrence: t.idx,
			alternatives: e.alts
		};
	});
}
function uM(e, t, r, i) {
	let n = iJ(e, (e, t, r) => {
		let i = iD(t, (e) => ({
			idx: r,
			path: e
		}));
		return e.concat(i);
	}, []);
	return nx(n$(n, (e) => {
		if (!0 === t.definition[e.idx].ignoreAmbiguities) return [];
		let a = e.idx, s = e.path;
		return iD(iI(n, (e) => !0 !== t.definition[e.idx].ignoreAmbiguities && e.idx < a && uf(e.path, s)), (e) => {
			let n = [e.idx + 1, a + 1], s = 0 === t.idx ? "" : t.idx;
			return {
				message: i.buildAlternationPrefixAmbiguityError({
					topLevelRule: r,
					alternation: t,
					ambiguityIndices: n,
					prefixPath: e.path
				}),
				type: dN.AMBIGUOUS_PREFIX_ALTS,
				ruleName: r.name,
				occurrence: s,
				alternatives: n
			};
		});
	}));
}
function uD(e, t, r) {
	let i = [], n = iD(t, (e) => e.name);
	return rU(e, (e) => {
		let t = e.name;
		if (nY(n, t)) {
			let n = r.buildNamespaceConflictError(e);
			i.push({
				message: n,
				type: dN.CONFLICT_TOKENS_RULES_NAMESPACE,
				ruleName: t
			});
		}
	}), i;
}
function uO(e) {
	let t = rO(e, { errMsgProvider: hX }), r = {};
	return rU(e.rules, (e) => {
		r[e.name] = e;
	}), hZ(r, t.errMsgProvider);
}
function u$(e) {
	return uy((e = rO(e, { errMsgProvider: hK })).rules, e.tokenTypes, e.errMsgProvider, e.grammarName);
}
h(uR, "validateTooManyAlts"), h(uN, "validateSomeNonEmptyLookaheadPath"), h(uI, "checkAlternativesAmbiguities"), h(uM, "checkPrefixAlternativesAmbiguities"), h(uD, "checkTerminalAndNoneTerminalsNameSpace"), h(uO, "resolveGrammar"), h(u$, "validateGrammar");
var uP = "MismatchedTokenException", uB = "NoViableAltException", uF = "EarlyExitException", uz = "NotAllInputParsedException", uU = [
	uP,
	uB,
	uF,
	uz
];
function uG(e) {
	return nY(uU, e.name);
}
Object.freeze(uU), h(uG, "isRecognitionException");
var uq = class extends Error {
	static {
		h(this, "RecognitionException");
	}
	constructor(e, t) {
		super(e), this.token = t, this.resyncedTokens = [], Object.setPrototypeOf(this, new.target.prototype), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
	}
}, uj = class extends uq {
	static {
		h(this, "MismatchedTokenException");
	}
	constructor(e, t, r) {
		super(e, t), this.previousToken = r, this.name = uP;
	}
}, uW = class extends uq {
	static {
		h(this, "NoViableAltException");
	}
	constructor(e, t, r) {
		super(e, t), this.previousToken = r, this.name = uB;
	}
}, uY = class extends uq {
	static {
		h(this, "NotAllInputParsedException");
	}
	constructor(e, t) {
		super(e, t), this.name = uz;
	}
}, uV = class extends uq {
	static {
		h(this, "EarlyExitException");
	}
	constructor(e, t, r) {
		super(e, t), this.previousToken = r, this.name = uF;
	}
}, uH = {}, uX = "InRuleRecoveryException", uK = class extends Error {
	static {
		h(this, "InRuleRecoveryException");
	}
	constructor(e) {
		super(e), this.name = uX;
	}
}, uZ = class {
	static {
		h(this, "Recoverable");
	}
	initRecoverable(e) {
		this.firstAfterRepMap = {}, this.resyncFollows = {}, this.recoveryEnabled = nq(e, "recoveryEnabled") ? e.recoveryEnabled : dI.recoveryEnabled, this.recoveryEnabled && (this.attemptInRepetitionRecovery = uQ);
	}
	getTokenToInsert(e) {
		let t = hY(e, "", NaN, NaN, NaN, NaN, NaN, NaN);
		return t.isInsertedInRecovery = !0, t;
	}
	canTokenTypeBeInsertedInRecovery(e) {
		return !0;
	}
	canTokenTypeBeDeletedInRecovery(e) {
		return !0;
	}
	tryInRepetitionRecovery(e, t, r, i) {
		let n = this.findReSyncTokenType(), a = this.exportLexerState(), s = [], o = !1, l = this.LA(1), u = this.LA(1), d = h(() => {
			let e = this.LA(0), t = new uj(this.errorMessageProvider.buildMismatchTokenMessage({
				expected: i,
				actual: l,
				previous: e,
				ruleName: this.getCurrRuleFullName()
			}), l, this.LA(0));
			t.resyncedTokens = nS(s), this.SAVE_ERROR(t);
		}, "generateErrorMessage");
		for (; !o;) if (this.tokenMatcher(u, i)) return void d();
		else if (r.call(this)) {
			d(), e.apply(this, t);
			return;
		} else this.tokenMatcher(u, n) ? o = !0 : (u = this.SKIP_TOKEN(), this.addToResyncTokens(u, s));
		this.importLexerState(a);
	}
	shouldInRepetitionRecoveryBeTried(e, t, r) {
		return !(!1 === r || this.tokenMatcher(this.LA(1), e) || this.isBackTracking() || this.canPerformInRuleRecovery(e, this.getFollowsForInRuleRecovery(e, t)));
	}
	getFollowsForInRuleRecovery(e, t) {
		let r = this.getCurrentGrammarPath(e, t);
		return this.getNextPossibleTokenTypes(r);
	}
	tryInRuleRecovery(e, t) {
		if (this.canRecoverWithSingleTokenInsertion(e, t)) return this.getTokenToInsert(e);
		if (this.canRecoverWithSingleTokenDeletion(e)) {
			let e = this.SKIP_TOKEN();
			return this.consumeToken(), e;
		}
		throw new uK("sad sad panda");
	}
	canPerformInRuleRecovery(e, t) {
		return this.canRecoverWithSingleTokenInsertion(e, t) || this.canRecoverWithSingleTokenDeletion(e);
	}
	canRecoverWithSingleTokenInsertion(e, t) {
		if (!this.canTokenTypeBeInsertedInRecovery(e) || t3(t)) return !1;
		let r = this.LA(1);
		return void 0 !== nD(t, (e) => this.tokenMatcher(r, e));
	}
	canRecoverWithSingleTokenDeletion(e) {
		return !!this.canTokenTypeBeDeletedInRecovery(e) && this.tokenMatcher(this.LA(2), e);
	}
	isInCurrentRuleReSyncSet(e) {
		let t = this.getCurrFollowKey();
		return nY(this.getFollowSetFromFollowKey(t), e);
	}
	findReSyncTokenType() {
		let e = this.flattenFollowSet(), t = this.LA(1), r = 2;
		for (;;) {
			let i = nD(e, (e) => hV(t, e));
			if (void 0 !== i) return i;
			t = this.LA(r), r++;
		}
	}
	getCurrFollowKey() {
		if (1 === this.RULE_STACK.length) return uH;
		let e = this.getLastExplicitRuleShortName(), t = this.getLastExplicitRuleOccurrenceIndex(), r = this.getPreviousExplicitRuleShortName();
		return {
			ruleName: this.shortRuleNameToFullName(e),
			idxInCallingRule: t,
			inRule: this.shortRuleNameToFullName(r)
		};
	}
	buildFullFollowKeyStack() {
		let e = this.RULE_STACK, t = this.RULE_OCCURRENCE_STACK;
		return iD(e, (r, i) => 0 === i ? uH : {
			ruleName: this.shortRuleNameToFullName(r),
			idxInCallingRule: t[i],
			inRule: this.shortRuleNameToFullName(e[i - 1])
		});
	}
	flattenFollowSet() {
		return iH(iD(this.buildFullFollowKeyStack(), (e) => this.getFollowSetFromFollowKey(e)));
	}
	getFollowSetFromFollowKey(e) {
		if (e === uH) return [hW];
		let t = e.ruleName + e.idxInCallingRule + c_ + e.inRule;
		return this.resyncFollows[t];
	}
	addToResyncTokens(e, t) {
		return this.tokenMatcher(e, hW) || t.push(e), t;
	}
	reSyncTo(e) {
		let t = [], r = this.LA(1);
		for (; !1 === this.tokenMatcher(r, e);) r = this.SKIP_TOKEN(), this.addToResyncTokens(r, t);
		return nS(t);
	}
	attemptInRepetitionRecovery(e, t, r, i, n, a, s) {}
	getCurrentGrammarPath(e, t) {
		return {
			ruleStack: this.getHumanReadableRuleStack(),
			occurrenceStack: rI(this.RULE_OCCURRENCE_STACK),
			lastTok: e,
			lastTokOccurrence: t
		};
	}
	getHumanReadableRuleStack() {
		return iD(this.RULE_STACK, (e) => this.shortRuleNameToFullName(e));
	}
};
function uQ(e, t, r, i, n, a, s) {
	let o = this.getKeyForAutomaticLookahead(i, n), l = this.firstAfterRepMap[o];
	if (void 0 === l) {
		let e = this.getCurrRuleFullName();
		l = new a(this.getGAstProductions()[e], n).startWalking(), this.firstAfterRepMap[o] = l;
	}
	let h = l.token, u = l.occurrence, d = l.isEndOfRule;
	1 === this.RULE_STACK.length && d && void 0 === h && (h = hW, u = 1), void 0 !== h && void 0 !== u && this.shouldInRepetitionRecoveryBeTried(h, u, s) && this.tryInRepetitionRecovery(e, t, r, h);
}
function uJ(e, t, r) {
	return r | t | e;
}
h(uQ, "attemptInRepetitionRecovery"), h(uJ, "getKeyForAutomaticLookahead");
var u0 = class {
	static {
		h(this, "LLkLookaheadStrategy");
	}
	constructor(e) {
		var t;
		this.maxLookahead = null != (t = e?.maxLookahead) ? t : dI.maxLookahead;
	}
	validate(e) {
		let t = this.validateNoLeftRecursion(e.rules);
		return t3(t) ? [
			...t,
			...this.validateEmptyOrAlternatives(e.rules),
			...this.validateAmbiguousAlternationAlternatives(e.rules, this.maxLookahead),
			...this.validateSomeNonEmptyLookaheadPath(e.rules, this.maxLookahead)
		] : t;
	}
	validateNoLeftRecursion(e) {
		return n$(e, (e) => u_(e, e, hK));
	}
	validateEmptyOrAlternatives(e) {
		return n$(e, (e) => uS(e, hK));
	}
	validateAmbiguousAlternationAlternatives(e, t) {
		return n$(e, (e) => uA(e, t, hK));
	}
	validateSomeNonEmptyLookaheadPath(e, t) {
		return uN(e, t, hK);
	}
	buildLookaheadForAlternation(e) {
		return ut(e.prodOccurrence, e.rule, e.maxLookahead, e.hasPredicates, e.dynamicTokensEnabled, ui);
	}
	buildLookaheadForOptional(e) {
		return ur(e.prodOccurrence, e.rule, e.maxLookahead, e.dynamicTokensEnabled, h9(e.prodType), un);
	}
}, u1 = class {
	static {
		h(this, "LooksAhead");
	}
	initLooksAhead(e) {
		this.dynamicTokensEnabled = nq(e, "dynamicTokensEnabled") ? e.dynamicTokensEnabled : dI.dynamicTokensEnabled, this.maxLookahead = nq(e, "maxLookahead") ? e.maxLookahead : dI.maxLookahead, this.lookaheadStrategy = nq(e, "lookaheadStrategy") ? e.lookaheadStrategy : new u0({ maxLookahead: this.maxLookahead }), this.lookAheadFuncsCache = /* @__PURE__ */ new Map();
	}
	preComputeLookaheadFunctions(e) {
		rU(e, (e) => {
			this.TRACE_INIT(`${e.name} Rule Lookahead`, () => {
				let { alternation: t, repetition: r, option: i, repetitionMandatory: n, repetitionMandatoryWithSeparator: a, repetitionWithSeparator: s } = u4(e);
				rU(t, (t) => {
					let r = 0 === t.idx ? "" : t.idx;
					this.TRACE_INIT(`${cy(t)}${r}`, () => {
						let r = this.lookaheadStrategy.buildLookaheadForAlternation({
							prodOccurrence: t.idx,
							rule: e,
							maxLookahead: t.maxLookahead || this.maxLookahead,
							hasPredicates: t.hasPredicates,
							dynamicTokensEnabled: this.dynamicTokensEnabled
						}), i = uJ(this.fullRuleNameToShort[e.name], 256, t.idx);
						this.setLaFuncCache(i, r);
					});
				}), rU(r, (t) => {
					this.computeLookaheadFunc(e, t.idx, 768, "Repetition", t.maxLookahead, cy(t));
				}), rU(i, (t) => {
					this.computeLookaheadFunc(e, t.idx, 512, "Option", t.maxLookahead, cy(t));
				}), rU(n, (t) => {
					this.computeLookaheadFunc(e, t.idx, 1024, "RepetitionMandatory", t.maxLookahead, cy(t));
				}), rU(a, (t) => {
					this.computeLookaheadFunc(e, t.idx, 1536, "RepetitionMandatoryWithSeparator", t.maxLookahead, cy(t));
				}), rU(s, (t) => {
					this.computeLookaheadFunc(e, t.idx, 1280, "RepetitionWithSeparator", t.maxLookahead, cy(t));
				});
			});
		});
	}
	computeLookaheadFunc(e, t, r, i, n, a) {
		this.TRACE_INIT(`${a}${0 === t ? "" : t}`, () => {
			let a = this.lookaheadStrategy.buildLookaheadForOptional({
				prodOccurrence: t,
				rule: e,
				maxLookahead: n || this.maxLookahead,
				dynamicTokensEnabled: this.dynamicTokensEnabled,
				prodType: i
			}), s = uJ(this.fullRuleNameToShort[e.name], r, t);
			this.setLaFuncCache(s, a);
		});
	}
	getKeyForAutomaticLookahead(e, t) {
		return uJ(this.getLastExplicitRuleShortName(), e, t);
	}
	getLaFuncFromCache(e) {
		return this.lookAheadFuncsCache.get(e);
	}
	setLaFuncCache(e, t) {
		this.lookAheadFuncsCache.set(e, t);
	}
}, u2 = new class extends cp {
	static {
		h(this, "DslMethodsCollectorVisitor");
	}
	constructor() {
		super(...arguments), this.dslMethods = {
			option: [],
			alternation: [],
			repetition: [],
			repetitionWithSeparator: [],
			repetitionMandatory: [],
			repetitionMandatoryWithSeparator: []
		};
	}
	reset() {
		this.dslMethods = {
			option: [],
			alternation: [],
			repetition: [],
			repetitionWithSeparator: [],
			repetitionMandatory: [],
			repetitionMandatoryWithSeparator: []
		};
	}
	visitOption(e) {
		this.dslMethods.option.push(e);
	}
	visitRepetitionWithSeparator(e) {
		this.dslMethods.repetitionWithSeparator.push(e);
	}
	visitRepetitionMandatory(e) {
		this.dslMethods.repetitionMandatory.push(e);
	}
	visitRepetitionMandatoryWithSeparator(e) {
		this.dslMethods.repetitionMandatoryWithSeparator.push(e);
	}
	visitRepetition(e) {
		this.dslMethods.repetition.push(e);
	}
	visitAlternation(e) {
		this.dslMethods.alternation.push(e);
	}
}();
function u4(e) {
	u2.reset(), e.accept(u2);
	let t = u2.dslMethods;
	return u2.reset(), t;
}
function u5(e, t) {
	!0 === isNaN(e.startOffset) ? (e.startOffset = t.startOffset, e.endOffset = t.endOffset) : e.endOffset < t.endOffset && (e.endOffset = t.endOffset);
}
function u3(e, t) {
	!0 === isNaN(e.startOffset) ? (e.startOffset = t.startOffset, e.startColumn = t.startColumn, e.startLine = t.startLine, e.endOffset = t.endOffset, e.endColumn = t.endColumn, e.endLine = t.endLine) : e.endOffset < t.endOffset && (e.endOffset = t.endOffset, e.endColumn = t.endColumn, e.endLine = t.endLine);
}
function u6(e, t, r) {
	void 0 === e.children[r] ? e.children[r] = [t] : e.children[r].push(t);
}
function u7(e, t, r) {
	void 0 === e.children[t] ? e.children[t] = [r] : e.children[t].push(r);
}
function u8(e, t) {
	Object.defineProperty(e, "name", {
		enumerable: !1,
		configurable: !0,
		writable: !1,
		value: t
	});
}
function u9(e, t) {
	let r = t6(e), i = r.length;
	for (let n = 0; n < i; n++) {
		let i = e[r[n]], a = i.length;
		for (let e = 0; e < a; e++) {
			let r = i[e];
			void 0 === r.tokenTypeIdx && this[r.name](r.children, t);
		}
	}
}
function de(e, t) {
	let r = h(function() {}, "derivedConstructor");
	return u8(r, e + "BaseSemantics"), r.prototype = {
		visit: h(function(e, t) {
			if (eQ(e) && (e = e[0]), !iP(e)) return this[e.name](e.children, t);
		}, "visit"),
		validateVisitor: h(function() {
			let e = dr(this, t);
			if (!t3(e)) {
				let t = iD(e, (e) => e.msg);
				throw Error(`Errors Detected in CST Visitor <${this.constructor.name}>:
	${t.join(`

`).replace(/\n/g, `
	`)}`);
			}
		}, "validateVisitor")
	}, r.prototype.constructor = r, r._RULE_NAMES = t, r;
}
function dt(e, t, r) {
	let i = h(function() {}, "derivedConstructor");
	u8(i, e + "BaseSemanticsWithDefaults");
	let n = Object.create(r.prototype);
	return rU(t, (e) => {
		n[e] = u9;
	}), i.prototype = n, i.prototype.constructor = i, i;
}
function dr(e, t) {
	return di(e, t);
}
function di(e, t) {
	return nx(iD(iI(t, (t) => !1 === R(e[t])), (t) => ({
		msg: `Missing visitor method: <${t}> on ${e.constructor.name} CST Visitor.`,
		type: dR.MISSING_METHOD,
		methodName: t
	})));
}
h(u4, "collectMethods"), h(u5, "setNodeLocationOnlyOffset"), h(u3, "setNodeLocationFull"), h(u6, "addTerminalToCst"), h(u7, "addNoneTerminalToCst"), h(u8, "defineNameProp"), h(u9, "defaultVisit"), h(de, "createBaseSemanticVisitorConstructor"), h(dt, "createBaseVisitorConstructorWithDefaults"), (dC = dR || (dR = {}))[dC.REDUNDANT_METHOD = 0] = "REDUNDANT_METHOD", dC[dC.MISSING_METHOD = 1] = "MISSING_METHOD", h(dr, "validateVisitor"), h(di, "validateMissingCstMethods");
var dn = class {
	static {
		h(this, "TreeBuilder");
	}
	initTreeBuilder(e) {
		if (this.CST_STACK = [], this.outputCst = e.outputCst, this.nodeLocationTracking = nq(e, "nodeLocationTracking") ? e.nodeLocationTracking : dI.nodeLocationTracking, this.outputCst) if (/full/i.test(this.nodeLocationTracking)) this.recoveryEnabled ? (this.setNodeLocationFromToken = u3, this.setNodeLocationFromNode = u3, this.cstPostRule = i6, this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery) : (this.setNodeLocationFromToken = i6, this.setNodeLocationFromNode = i6, this.cstPostRule = this.cstPostRuleFull, this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular);
		else if (/onlyOffset/i.test(this.nodeLocationTracking)) this.recoveryEnabled ? (this.setNodeLocationFromToken = u5, this.setNodeLocationFromNode = u5, this.cstPostRule = i6, this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery) : (this.setNodeLocationFromToken = i6, this.setNodeLocationFromNode = i6, this.cstPostRule = this.cstPostRuleOnlyOffset, this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular);
		else if (/none/i.test(this.nodeLocationTracking)) this.setNodeLocationFromToken = i6, this.setNodeLocationFromNode = i6, this.cstPostRule = i6, this.setInitialNodeLocation = i6;
		else throw Error(`Invalid <nodeLocationTracking> config option: "${e.nodeLocationTracking}"`);
		else this.cstInvocationStateUpdate = i6, this.cstFinallyStateUpdate = i6, this.cstPostTerminal = i6, this.cstPostNonTerminal = i6, this.cstPostRule = i6;
	}
	setInitialNodeLocationOnlyOffsetRecovery(e) {
		e.location = {
			startOffset: NaN,
			endOffset: NaN
		};
	}
	setInitialNodeLocationOnlyOffsetRegular(e) {
		e.location = {
			startOffset: this.LA(1).startOffset,
			endOffset: NaN
		};
	}
	setInitialNodeLocationFullRecovery(e) {
		e.location = {
			startOffset: NaN,
			startLine: NaN,
			startColumn: NaN,
			endOffset: NaN,
			endLine: NaN,
			endColumn: NaN
		};
	}
	setInitialNodeLocationFullRegular(e) {
		let t = this.LA(1);
		e.location = {
			startOffset: t.startOffset,
			startLine: t.startLine,
			startColumn: t.startColumn,
			endOffset: NaN,
			endLine: NaN,
			endColumn: NaN
		};
	}
	cstInvocationStateUpdate(e) {
		let t = {
			name: e,
			children: Object.create(null)
		};
		this.setInitialNodeLocation(t), this.CST_STACK.push(t);
	}
	cstFinallyStateUpdate() {
		this.CST_STACK.pop();
	}
	cstPostRuleFull(e) {
		let t = this.LA(0), r = e.location;
		r.startOffset <= t.startOffset ? (r.endOffset = t.endOffset, r.endLine = t.endLine, r.endColumn = t.endColumn) : (r.startOffset = NaN, r.startLine = NaN, r.startColumn = NaN);
	}
	cstPostRuleOnlyOffset(e) {
		let t = this.LA(0), r = e.location;
		r.startOffset <= t.startOffset ? r.endOffset = t.endOffset : r.startOffset = NaN;
	}
	cstPostTerminal(e, t) {
		let r = this.CST_STACK[this.CST_STACK.length - 1];
		u6(r, t, e), this.setNodeLocationFromToken(r.location, t);
	}
	cstPostNonTerminal(e, t) {
		let r = this.CST_STACK[this.CST_STACK.length - 1];
		u7(r, t, e), this.setNodeLocationFromNode(r.location, e.location);
	}
	getBaseCstVisitorConstructor() {
		if (iP(this.baseCstVisitorConstructor)) {
			let e = de(this.className, t6(this.gastProductionsCache));
			return this.baseCstVisitorConstructor = e, e;
		}
		return this.baseCstVisitorConstructor;
	}
	getBaseCstVisitorConstructorWithDefaults() {
		if (iP(this.baseCstVisitorWithDefaultsConstructor)) {
			let e = dt(this.className, t6(this.gastProductionsCache), this.getBaseCstVisitorConstructor());
			return this.baseCstVisitorWithDefaultsConstructor = e, e;
		}
		return this.baseCstVisitorWithDefaultsConstructor;
	}
	getLastExplicitRuleShortName() {
		let e = this.RULE_STACK;
		return e[e.length - 1];
	}
	getPreviousExplicitRuleShortName() {
		let e = this.RULE_STACK;
		return e[e.length - 2];
	}
	getLastExplicitRuleOccurrenceIndex() {
		let e = this.RULE_OCCURRENCE_STACK;
		return e[e.length - 1];
	}
}, da = class {
	static {
		h(this, "LexerAdapter");
	}
	initLexerAdapter() {
		this.tokVector = [], this.tokVectorLength = 0, this.currIdx = -1;
	}
	set input(e) {
		if (!0 !== this.selfAnalysisDone) throw Error("Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.");
		this.reset(), this.tokVector = e, this.tokVectorLength = e.length;
	}
	get input() {
		return this.tokVector;
	}
	SKIP_TOKEN() {
		return this.currIdx <= this.tokVector.length - 2 ? (this.consumeToken(), this.LA(1)) : dk;
	}
	LA(e) {
		let t = this.currIdx + e;
		return t < 0 || this.tokVectorLength <= t ? dk : this.tokVector[t];
	}
	consumeToken() {
		this.currIdx++;
	}
	exportLexerState() {
		return this.currIdx;
	}
	importLexerState(e) {
		this.currIdx = e;
	}
	resetLexerState() {
		this.currIdx = -1;
	}
	moveToTerminatedState() {
		this.currIdx = this.tokVector.length - 1;
	}
	getLexerPosition() {
		return this.exportLexerState();
	}
}, ds = class {
	static {
		h(this, "RecognizerApi");
	}
	ACTION(e) {
		return e.call(this);
	}
	consume(e, t, r) {
		return this.consumeInternal(t, e, r);
	}
	subrule(e, t, r) {
		return this.subruleInternal(t, e, r);
	}
	option(e, t) {
		return this.optionInternal(t, e);
	}
	or(e, t) {
		return this.orInternal(t, e);
	}
	many(e, t) {
		return this.manyInternal(e, t);
	}
	atLeastOne(e, t) {
		return this.atLeastOneInternal(e, t);
	}
	CONSUME(e, t) {
		return this.consumeInternal(e, 0, t);
	}
	CONSUME1(e, t) {
		return this.consumeInternal(e, 1, t);
	}
	CONSUME2(e, t) {
		return this.consumeInternal(e, 2, t);
	}
	CONSUME3(e, t) {
		return this.consumeInternal(e, 3, t);
	}
	CONSUME4(e, t) {
		return this.consumeInternal(e, 4, t);
	}
	CONSUME5(e, t) {
		return this.consumeInternal(e, 5, t);
	}
	CONSUME6(e, t) {
		return this.consumeInternal(e, 6, t);
	}
	CONSUME7(e, t) {
		return this.consumeInternal(e, 7, t);
	}
	CONSUME8(e, t) {
		return this.consumeInternal(e, 8, t);
	}
	CONSUME9(e, t) {
		return this.consumeInternal(e, 9, t);
	}
	SUBRULE(e, t) {
		return this.subruleInternal(e, 0, t);
	}
	SUBRULE1(e, t) {
		return this.subruleInternal(e, 1, t);
	}
	SUBRULE2(e, t) {
		return this.subruleInternal(e, 2, t);
	}
	SUBRULE3(e, t) {
		return this.subruleInternal(e, 3, t);
	}
	SUBRULE4(e, t) {
		return this.subruleInternal(e, 4, t);
	}
	SUBRULE5(e, t) {
		return this.subruleInternal(e, 5, t);
	}
	SUBRULE6(e, t) {
		return this.subruleInternal(e, 6, t);
	}
	SUBRULE7(e, t) {
		return this.subruleInternal(e, 7, t);
	}
	SUBRULE8(e, t) {
		return this.subruleInternal(e, 8, t);
	}
	SUBRULE9(e, t) {
		return this.subruleInternal(e, 9, t);
	}
	OPTION(e) {
		return this.optionInternal(e, 0);
	}
	OPTION1(e) {
		return this.optionInternal(e, 1);
	}
	OPTION2(e) {
		return this.optionInternal(e, 2);
	}
	OPTION3(e) {
		return this.optionInternal(e, 3);
	}
	OPTION4(e) {
		return this.optionInternal(e, 4);
	}
	OPTION5(e) {
		return this.optionInternal(e, 5);
	}
	OPTION6(e) {
		return this.optionInternal(e, 6);
	}
	OPTION7(e) {
		return this.optionInternal(e, 7);
	}
	OPTION8(e) {
		return this.optionInternal(e, 8);
	}
	OPTION9(e) {
		return this.optionInternal(e, 9);
	}
	OR(e) {
		return this.orInternal(e, 0);
	}
	OR1(e) {
		return this.orInternal(e, 1);
	}
	OR2(e) {
		return this.orInternal(e, 2);
	}
	OR3(e) {
		return this.orInternal(e, 3);
	}
	OR4(e) {
		return this.orInternal(e, 4);
	}
	OR5(e) {
		return this.orInternal(e, 5);
	}
	OR6(e) {
		return this.orInternal(e, 6);
	}
	OR7(e) {
		return this.orInternal(e, 7);
	}
	OR8(e) {
		return this.orInternal(e, 8);
	}
	OR9(e) {
		return this.orInternal(e, 9);
	}
	MANY(e) {
		this.manyInternal(0, e);
	}
	MANY1(e) {
		this.manyInternal(1, e);
	}
	MANY2(e) {
		this.manyInternal(2, e);
	}
	MANY3(e) {
		this.manyInternal(3, e);
	}
	MANY4(e) {
		this.manyInternal(4, e);
	}
	MANY5(e) {
		this.manyInternal(5, e);
	}
	MANY6(e) {
		this.manyInternal(6, e);
	}
	MANY7(e) {
		this.manyInternal(7, e);
	}
	MANY8(e) {
		this.manyInternal(8, e);
	}
	MANY9(e) {
		this.manyInternal(9, e);
	}
	MANY_SEP(e) {
		this.manySepFirstInternal(0, e);
	}
	MANY_SEP1(e) {
		this.manySepFirstInternal(1, e);
	}
	MANY_SEP2(e) {
		this.manySepFirstInternal(2, e);
	}
	MANY_SEP3(e) {
		this.manySepFirstInternal(3, e);
	}
	MANY_SEP4(e) {
		this.manySepFirstInternal(4, e);
	}
	MANY_SEP5(e) {
		this.manySepFirstInternal(5, e);
	}
	MANY_SEP6(e) {
		this.manySepFirstInternal(6, e);
	}
	MANY_SEP7(e) {
		this.manySepFirstInternal(7, e);
	}
	MANY_SEP8(e) {
		this.manySepFirstInternal(8, e);
	}
	MANY_SEP9(e) {
		this.manySepFirstInternal(9, e);
	}
	AT_LEAST_ONE(e) {
		this.atLeastOneInternal(0, e);
	}
	AT_LEAST_ONE1(e) {
		return this.atLeastOneInternal(1, e);
	}
	AT_LEAST_ONE2(e) {
		this.atLeastOneInternal(2, e);
	}
	AT_LEAST_ONE3(e) {
		this.atLeastOneInternal(3, e);
	}
	AT_LEAST_ONE4(e) {
		this.atLeastOneInternal(4, e);
	}
	AT_LEAST_ONE5(e) {
		this.atLeastOneInternal(5, e);
	}
	AT_LEAST_ONE6(e) {
		this.atLeastOneInternal(6, e);
	}
	AT_LEAST_ONE7(e) {
		this.atLeastOneInternal(7, e);
	}
	AT_LEAST_ONE8(e) {
		this.atLeastOneInternal(8, e);
	}
	AT_LEAST_ONE9(e) {
		this.atLeastOneInternal(9, e);
	}
	AT_LEAST_ONE_SEP(e) {
		this.atLeastOneSepFirstInternal(0, e);
	}
	AT_LEAST_ONE_SEP1(e) {
		this.atLeastOneSepFirstInternal(1, e);
	}
	AT_LEAST_ONE_SEP2(e) {
		this.atLeastOneSepFirstInternal(2, e);
	}
	AT_LEAST_ONE_SEP3(e) {
		this.atLeastOneSepFirstInternal(3, e);
	}
	AT_LEAST_ONE_SEP4(e) {
		this.atLeastOneSepFirstInternal(4, e);
	}
	AT_LEAST_ONE_SEP5(e) {
		this.atLeastOneSepFirstInternal(5, e);
	}
	AT_LEAST_ONE_SEP6(e) {
		this.atLeastOneSepFirstInternal(6, e);
	}
	AT_LEAST_ONE_SEP7(e) {
		this.atLeastOneSepFirstInternal(7, e);
	}
	AT_LEAST_ONE_SEP8(e) {
		this.atLeastOneSepFirstInternal(8, e);
	}
	AT_LEAST_ONE_SEP9(e) {
		this.atLeastOneSepFirstInternal(9, e);
	}
	RULE(e, t, r = dM) {
		if (nY(this.definedRulesNames, e)) {
			let t = {
				message: hK.buildDuplicateRuleNameError({
					topLevelRule: e,
					grammarName: this.className
				}),
				type: dN.DUPLICATE_RULE_NAME,
				ruleName: e
			};
			this.definitionErrors.push(t);
		}
		this.definedRulesNames.push(e);
		let i = this.defineRule(e, t, r);
		return this[e] = i, i;
	}
	OVERRIDE_RULE(e, t, r = dM) {
		let i = uT(e, this.definedRulesNames, this.className);
		this.definitionErrors = this.definitionErrors.concat(i);
		let n = this.defineRule(e, t, r);
		return this[e] = n, n;
	}
	BACKTRACK(e, t) {
		return function() {
			this.isBackTrackingStack.push(1);
			let r = this.saveRecogState();
			try {
				return e.apply(this, t), !0;
			} catch (e) {
				if (uG(e)) return !1;
				throw e;
			} finally {
				this.reloadRecogState(r), this.isBackTrackingStack.pop();
			}
		};
	}
	getGAstProductions() {
		return this.gastProductionsCache;
	}
	getSerializedGastProductions() {
		return cu(i$(this.gastProductionsCache));
	}
}, dl = class {
	static {
		h(this, "RecognizerEngine");
	}
	initRecognizerEngine(e, t) {
		if (this.className = this.constructor.name, this.shortRuleNameToFull = {}, this.fullRuleNameToShort = {}, this.ruleShortNameIdx = 256, this.tokenMatcher = hm, this.subruleIdx = 0, this.definedRulesNames = [], this.tokensMap = {}, this.isBackTrackingStack = [], this.RULE_STACK = [], this.RULE_OCCURRENCE_STACK = [], this.gastProductionsCache = {}, nq(t, "serializedGrammar")) throw Error(`The Parser's configuration can no longer contain a <serializedGrammar> property.
	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0
	For Further details.`);
		if (eQ(e)) {
			if (t3(e)) throw Error(`A Token Vocabulary cannot be empty.
	Note that the first argument for the parser constructor
	is no longer a Token vector (since v4.0).`);
			if ("number" == typeof e[0].startOffset) throw Error(`The Parser constructor no longer accepts a token vector as the first argument.
	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0
	For Further details.`);
		}
		if (eQ(e)) this.tokensMap = iJ(e, (e, t) => (e[t.name] = t, e), {});
		else if (nq(e, "modes") && nR(iH(i$(e.modes)), hL)) this.tokensMap = iJ(ab(iH(i$(e.modes))), (e, t) => (e[t.name] = t, e), {});
		else if (L(e)) this.tokensMap = rI(e);
		else throw Error("<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition");
		this.tokensMap.EOF = hW, this.tokenMatcher = nR(nq(e, "modes") ? iH(i$(e.modes)) : i$(e), (e) => t3(e.categoryMatches)) ? hm : hg, hx(i$(this.tokensMap));
	}
	defineRule(e, t, r) {
		if (this.selfAnalysisDone) throw Error(`Grammar rule <${e}> may not be defined after the 'performSelfAnalysis' method has been called'
Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`);
		let i = nq(r, "resyncEnabled") ? r.resyncEnabled : dM.resyncEnabled, n = nq(r, "recoveryValueFunc") ? r.recoveryValueFunc : dM.recoveryValueFunc, a = this.ruleShortNameIdx << 12;
		return this.ruleShortNameIdx++, this.shortRuleNameToFull[a] = e, this.fullRuleNameToShort[e] = a, Object.assign(!0 === this.outputCst ? h(function(...r) {
			try {
				this.ruleInvocationStateUpdate(a, e, this.subruleIdx), t.apply(this, r);
				let i = this.CST_STACK[this.CST_STACK.length - 1];
				return this.cstPostRule(i), i;
			} catch (e) {
				return this.invokeRuleCatch(e, i, n);
			} finally {
				this.ruleFinallyStateUpdate();
			}
		}, "invokeRuleWithTry") : h(function(...r) {
			try {
				return this.ruleInvocationStateUpdate(a, e, this.subruleIdx), t.apply(this, r);
			} catch (e) {
				return this.invokeRuleCatch(e, i, n);
			} finally {
				this.ruleFinallyStateUpdate();
			}
		}, "invokeRuleWithTryCst"), {
			ruleName: e,
			originalGrammarAction: t
		});
	}
	invokeRuleCatch(e, t, r) {
		let i = 1 === this.RULE_STACK.length, n = t && !this.isBackTracking() && this.recoveryEnabled;
		if (uG(e)) {
			if (n) {
				let t = this.findReSyncTokenType();
				if (this.isInCurrentRuleReSyncSet(t)) if (e.resyncedTokens = this.reSyncTo(t), !this.outputCst) return r(e);
				else {
					let e = this.CST_STACK[this.CST_STACK.length - 1];
					return e.recoveredNode = !0, e;
				}
				if (this.outputCst) {
					let t = this.CST_STACK[this.CST_STACK.length - 1];
					t.recoveredNode = !0, e.partialCstResult = t;
				}
				throw e;
			}
			if (i) return this.moveToTerminatedState(), r(e);
		}
		throw e;
	}
	optionInternal(e, t) {
		let r = this.getKeyForAutomaticLookahead(512, t);
		return this.optionInternalLogic(e, t, r);
	}
	optionInternalLogic(e, t, r) {
		let i = this.getLaFuncFromCache(r), n;
		if ("function" != typeof e) {
			n = e.DEF;
			let t = e.GATE;
			if (void 0 !== t) {
				let e = i;
				i = h(() => t.call(this) && e.call(this), "lookAheadFunc");
			}
		} else n = e;
		if (!0 === i.call(this)) return n.call(this);
	}
	atLeastOneInternal(e, t) {
		let r = this.getKeyForAutomaticLookahead(1024, e);
		return this.atLeastOneInternalLogic(e, t, r);
	}
	atLeastOneInternalLogic(e, t, r) {
		let i = this.getLaFuncFromCache(r), n;
		if ("function" != typeof t) {
			n = t.DEF;
			let e = t.GATE;
			if (void 0 !== e) {
				let t = i;
				i = h(() => e.call(this) && t.call(this), "lookAheadFunc");
			}
		} else n = t;
		if (!0 === i.call(this)) {
			let e = this.doSingleRepetition(n);
			for (; !0 === i.call(this) && !0 === e;) e = this.doSingleRepetition(n);
		} else throw this.raiseEarlyExitException(e, dL.REPETITION_MANDATORY, t.ERR_MSG);
		this.attemptInRepetitionRecovery(this.atLeastOneInternal, [e, t], i, 1024, e, h5);
	}
	atLeastOneSepFirstInternal(e, t) {
		let r = this.getKeyForAutomaticLookahead(1536, e);
		this.atLeastOneSepFirstInternalLogic(e, t, r);
	}
	atLeastOneSepFirstInternalLogic(e, t, r) {
		let i = t.DEF, n = t.SEP;
		if (!0 === this.getLaFuncFromCache(r).call(this)) {
			i.call(this);
			let t = h(() => this.tokenMatcher(this.LA(1), n), "separatorLookAheadFunc");
			for (; !0 === this.tokenMatcher(this.LA(1), n);) this.CONSUME(n), i.call(this);
			this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
				e,
				n,
				t,
				i,
				h3
			], t, 1536, e, h3);
		} else throw this.raiseEarlyExitException(e, dL.REPETITION_MANDATORY_WITH_SEPARATOR, t.ERR_MSG);
	}
	manyInternal(e, t) {
		let r = this.getKeyForAutomaticLookahead(768, e);
		return this.manyInternalLogic(e, t, r);
	}
	manyInternalLogic(e, t, r) {
		let i = this.getLaFuncFromCache(r), n;
		if ("function" != typeof t) {
			n = t.DEF;
			let e = t.GATE;
			if (void 0 !== e) {
				let t = i;
				i = h(() => e.call(this) && t.call(this), "lookaheadFunction");
			}
		} else n = t;
		let a = !0;
		for (; !0 === i.call(this) && !0 === a;) a = this.doSingleRepetition(n);
		this.attemptInRepetitionRecovery(this.manyInternal, [e, t], i, 768, e, h2, a);
	}
	manySepFirstInternal(e, t) {
		let r = this.getKeyForAutomaticLookahead(1280, e);
		this.manySepFirstInternalLogic(e, t, r);
	}
	manySepFirstInternalLogic(e, t, r) {
		let i = t.DEF, n = t.SEP;
		if (!0 === this.getLaFuncFromCache(r).call(this)) {
			i.call(this);
			let t = h(() => this.tokenMatcher(this.LA(1), n), "separatorLookAheadFunc");
			for (; !0 === this.tokenMatcher(this.LA(1), n);) this.CONSUME(n), i.call(this);
			this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
				e,
				n,
				t,
				i,
				h4
			], t, 1280, e, h4);
		}
	}
	repetitionSepSecondInternal(e, t, r, i, n) {
		for (; r();) this.CONSUME(t), i.call(this);
		this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
			e,
			t,
			r,
			i,
			n
		], r, 1536, e, n);
	}
	doSingleRepetition(e) {
		let t = this.getLexerPosition();
		return e.call(this), this.getLexerPosition() > t;
	}
	orInternal(e, t) {
		let r = this.getKeyForAutomaticLookahead(256, t), i = eQ(e) ? e : e.DEF, n = this.getLaFuncFromCache(r).call(this, i);
		if (void 0 !== n) return i[n].ALT.call(this);
		this.raiseNoAltException(t, e.ERR_MSG);
	}
	ruleFinallyStateUpdate() {
		if (this.RULE_STACK.pop(), this.RULE_OCCURRENCE_STACK.pop(), this.cstFinallyStateUpdate(), 0 === this.RULE_STACK.length && !1 === this.isAtEndOfInput()) {
			let e = this.LA(1), t = this.errorMessageProvider.buildNotAllInputParsedMessage({
				firstRedundant: e,
				ruleName: this.getCurrRuleFullName()
			});
			this.SAVE_ERROR(new uY(t, e));
		}
	}
	subruleInternal(e, t, r) {
		let i;
		try {
			let n = void 0 !== r ? r.ARGS : void 0;
			return this.subruleIdx = t, i = e.apply(this, n), this.cstPostNonTerminal(i, void 0 !== r && void 0 !== r.LABEL ? r.LABEL : e.ruleName), i;
		} catch (t) {
			throw this.subruleInternalError(t, r, e.ruleName);
		}
	}
	subruleInternalError(e, t, r) {
		throw uG(e) && void 0 !== e.partialCstResult && (this.cstPostNonTerminal(e.partialCstResult, void 0 !== t && void 0 !== t.LABEL ? t.LABEL : r), delete e.partialCstResult), e;
	}
	consumeInternal(e, t, r) {
		let i;
		try {
			let t = this.LA(1);
			!0 === this.tokenMatcher(t, e) ? (this.consumeToken(), i = t) : this.consumeInternalError(e, t, r);
		} catch (r) {
			i = this.consumeInternalRecovery(e, t, r);
		}
		return this.cstPostTerminal(void 0 !== r && void 0 !== r.LABEL ? r.LABEL : e.name, i), i;
	}
	consumeInternalError(e, t, r) {
		let i, n = this.LA(0);
		throw i = void 0 !== r && r.ERR_MSG ? r.ERR_MSG : this.errorMessageProvider.buildMismatchTokenMessage({
			expected: e,
			actual: t,
			previous: n,
			ruleName: this.getCurrRuleFullName()
		}), this.SAVE_ERROR(new uj(i, t, n));
	}
	consumeInternalRecovery(e, t, r) {
		if (this.recoveryEnabled && "MismatchedTokenException" === r.name && !this.isBackTracking()) {
			let i = this.getFollowsForInRuleRecovery(e, t);
			try {
				return this.tryInRuleRecovery(e, i);
			} catch (e) {
				throw e.name === uX ? r : e;
			}
		}
		throw r;
	}
	saveRecogState() {
		let e = this.errors, t = rI(this.RULE_STACK);
		return {
			errors: e,
			lexerState: this.exportLexerState(),
			RULE_STACK: t,
			CST_STACK: this.CST_STACK
		};
	}
	reloadRecogState(e) {
		this.errors = e.errors, this.importLexerState(e.lexerState), this.RULE_STACK = e.RULE_STACK;
	}
	ruleInvocationStateUpdate(e, t, r) {
		this.RULE_OCCURRENCE_STACK.push(r), this.RULE_STACK.push(e), this.cstInvocationStateUpdate(t);
	}
	isBackTracking() {
		return 0 !== this.isBackTrackingStack.length;
	}
	getCurrRuleFullName() {
		let e = this.getLastExplicitRuleShortName();
		return this.shortRuleNameToFull[e];
	}
	shortRuleNameToFullName(e) {
		return this.shortRuleNameToFull[e];
	}
	isAtEndOfInput() {
		return this.tokenMatcher(this.LA(1), hW);
	}
	reset() {
		this.resetLexerState(), this.subruleIdx = 0, this.isBackTrackingStack = [], this.errors = [], this.RULE_STACK = [], this.CST_STACK = [], this.RULE_OCCURRENCE_STACK = [];
	}
}, dc = class {
	static {
		h(this, "ErrorHandler");
	}
	initErrorHandler(e) {
		this._errors = [], this.errorMessageProvider = nq(e, "errorMessageProvider") ? e.errorMessageProvider : dI.errorMessageProvider;
	}
	SAVE_ERROR(e) {
		if (uG(e)) return e.context = {
			ruleStack: this.getHumanReadableRuleStack(),
			ruleOccurrenceStack: rI(this.RULE_OCCURRENCE_STACK)
		}, this._errors.push(e), e;
		throw Error("Trying to save an Error which is not a RecognitionException");
	}
	get errors() {
		return rI(this._errors);
	}
	set errors(e) {
		this._errors = e;
	}
	raiseEarlyExitException(e, t, r) {
		let i = this.getCurrRuleFullName(), n = ud(e, this.getGAstProductions()[i], t, this.maxLookahead)[0], a = [];
		for (let e = 1; e <= this.maxLookahead; e++) a.push(this.LA(e));
		let s = this.errorMessageProvider.buildEarlyExitMessage({
			expectedIterationPaths: n,
			actual: a,
			previous: this.LA(0),
			customUserDescription: r,
			ruleName: i
		});
		throw this.SAVE_ERROR(new uV(s, this.LA(1), this.LA(0)));
	}
	raiseNoAltException(e, t) {
		let r = this.getCurrRuleFullName(), i = uu(e, this.getGAstProductions()[r], this.maxLookahead), n = [];
		for (let e = 1; e <= this.maxLookahead; e++) n.push(this.LA(e));
		let a = this.LA(0), s = this.errorMessageProvider.buildNoViableAltMessage({
			expectedPathsPerAlt: i,
			actual: n,
			previous: a,
			customUserDescription: t,
			ruleName: this.getCurrRuleFullName()
		});
		throw this.SAVE_ERROR(new uW(s, this.LA(1), a));
	}
}, dh = class {
	static {
		h(this, "ContentAssist");
	}
	initContentAssist() {}
	computeContentAssist(e, t) {
		let r = this.gastProductionsCache[e];
		if (iP(r)) throw Error(`Rule ->${e}<- does not exist in this grammar.`);
		return h7([r], t, this.tokenMatcher, this.maxLookahead);
	}
	getNextPossibleTokenTypes(e) {
		let t = nO(e.ruleStack);
		return new h0(this.getGAstProductions()[t], e).startWalking();
	}
}, du = { description: "This Object indicates the Parser is during Recording Phase" };
Object.freeze(du);
var dd = hq({
	name: "RECORDING_PHASE_TOKEN",
	pattern: hI.NA
});
hx([dd]);
var dp = hY(dd, `This IToken indicates the Parser is in Recording Phase
	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details`, -1, -1, -1, -1, -1, -1);
Object.freeze(dp);
var df = {
	name: `This CSTNode indicates the Parser is in Recording Phase
	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details`,
	children: {}
}, dg = class {
	static {
		h(this, "GastRecorder");
	}
	initGastRecorder(e) {
		this.recordingProdStack = [], this.RECORDING_PHASE = !1;
	}
	enableRecording() {
		this.RECORDING_PHASE = !0, this.TRACE_INIT("Enable Recording", () => {
			for (let e = 0; e < 10; e++) {
				let t = e > 0 ? e : "";
				this[`CONSUME${t}`] = function(t, r) {
					return this.consumeInternalRecord(t, e, r);
				}, this[`SUBRULE${t}`] = function(t, r) {
					return this.subruleInternalRecord(t, e, r);
				}, this[`OPTION${t}`] = function(t) {
					return this.optionInternalRecord(t, e);
				}, this[`OR${t}`] = function(t) {
					return this.orInternalRecord(t, e);
				}, this[`MANY${t}`] = function(t) {
					this.manyInternalRecord(e, t);
				}, this[`MANY_SEP${t}`] = function(t) {
					this.manySepFirstInternalRecord(e, t);
				}, this[`AT_LEAST_ONE${t}`] = function(t) {
					this.atLeastOneInternalRecord(e, t);
				}, this[`AT_LEAST_ONE_SEP${t}`] = function(t) {
					this.atLeastOneSepFirstInternalRecord(e, t);
				};
			}
			this.consume = function(e, t, r) {
				return this.consumeInternalRecord(t, e, r);
			}, this.subrule = function(e, t, r) {
				return this.subruleInternalRecord(t, e, r);
			}, this.option = function(e, t) {
				return this.optionInternalRecord(t, e);
			}, this.or = function(e, t) {
				return this.orInternalRecord(t, e);
			}, this.many = function(e, t) {
				this.manyInternalRecord(e, t);
			}, this.atLeastOne = function(e, t) {
				this.atLeastOneInternalRecord(e, t);
			}, this.ACTION = this.ACTION_RECORD, this.BACKTRACK = this.BACKTRACK_RECORD, this.LA = this.LA_RECORD;
		});
	}
	disableRecording() {
		this.RECORDING_PHASE = !1, this.TRACE_INIT("Deleting Recording methods", () => {
			for (let e = 0; e < 10; e++) {
				let t = e > 0 ? e : "";
				delete this[`CONSUME${t}`], delete this[`SUBRULE${t}`], delete this[`OPTION${t}`], delete this[`OR${t}`], delete this[`MANY${t}`], delete this[`MANY_SEP${t}`], delete this[`AT_LEAST_ONE${t}`], delete this[`AT_LEAST_ONE_SEP${t}`];
			}
			delete this.consume, delete this.subrule, delete this.option, delete this.or, delete this.many, delete this.atLeastOne, delete this.ACTION, delete this.BACKTRACK, delete this.LA;
		});
	}
	ACTION_RECORD(e) {}
	BACKTRACK_RECORD(e, t) {
		return () => !0;
	}
	LA_RECORD(e) {
		return dk;
	}
	topLevelRuleRecord(e, t) {
		try {
			let r = new cr({
				definition: [],
				name: e
			});
			return r.name = e, this.recordingProdStack.push(r), t.call(this), this.recordingProdStack.pop(), r;
		} catch (e) {
			if (!0 !== e.KNOWN_RECORDER_ERROR) try {
				e.message = e.message + `
	 This error was thrown during the "grammar recording phase" For more info see:
	https://chevrotain.io/docs/guide/internals.html#grammar-recording`;
			} catch {}
			throw e;
		}
	}
	optionInternalRecord(e, t) {
		return dm.call(this, cn, e, t);
	}
	atLeastOneInternalRecord(e, t) {
		dm.call(this, ca, t, e);
	}
	atLeastOneSepFirstInternalRecord(e, t) {
		dm.call(this, cs, t, e, !0);
	}
	manyInternalRecord(e, t) {
		dm.call(this, co, t, e);
	}
	manySepFirstInternalRecord(e, t) {
		dm.call(this, cl, t, e, !0);
	}
	orInternalRecord(e, t) {
		return dy.call(this, e, t);
	}
	subruleInternalRecord(e, t, r) {
		if (dx(t), !e || !1 === nq(e, "ruleName")) {
			let r = Error(`<SUBRULE${dv(t)}> argument is invalid expecting a Parser method reference but got: <${JSON.stringify(e)}>
 inside top level rule: <${this.recordingProdStack[0].name}>`);
			throw r.KNOWN_RECORDER_ERROR = !0, r;
		}
		let i = r$(this.recordingProdStack), n = new ct({
			idx: t,
			nonTerminalName: e.ruleName,
			label: r?.LABEL,
			referencedRule: void 0
		});
		return i.definition.push(n), this.outputCst ? df : du;
	}
	consumeInternalRecord(e, t, r) {
		if (dx(t), !hE(e)) {
			let r = Error(`<CONSUME${dv(t)}> argument is invalid expecting a TokenType reference but got: <${JSON.stringify(e)}>
 inside top level rule: <${this.recordingProdStack[0].name}>`);
			throw r.KNOWN_RECORDER_ERROR = !0, r;
		}
		let i = r$(this.recordingProdStack), n = new ch({
			idx: t,
			terminalType: e,
			label: r?.LABEL
		});
		return i.definition.push(n), dp;
	}
};
function dm(e, t, r, i = !1) {
	dx(r);
	let n = r$(this.recordingProdStack), a = R(t) ? t : t.DEF, s = new e({
		definition: [],
		idx: r
	});
	return i && (s.separator = t.SEP), nq(t, "MAX_LOOKAHEAD") && (s.maxLookahead = t.MAX_LOOKAHEAD), this.recordingProdStack.push(s), a.call(this), n.definition.push(s), this.recordingProdStack.pop(), du;
}
function dy(e, t) {
	dx(t);
	let r = r$(this.recordingProdStack), i = !1 === eQ(e), n = !1 === i ? e : e.DEF, a = new cc({
		definition: [],
		idx: t,
		ignoreAmbiguities: i && !0 === e.IGNORE_AMBIGUITIES
	});
	return nq(e, "MAX_LOOKAHEAD") && (a.maxLookahead = e.MAX_LOOKAHEAD), a.hasPredicates = av(n, (e) => R(e.GATE)), r.definition.push(a), rU(n, (e) => {
		let t = new ci({ definition: [] });
		a.definition.push(t), nq(e, "IGNORE_AMBIGUITIES") ? t.ignoreAmbiguities = e.IGNORE_AMBIGUITIES : nq(e, "GATE") && (t.ignoreAmbiguities = !0), this.recordingProdStack.push(t), e.ALT.call(this), this.recordingProdStack.pop();
	}), du;
}
function dv(e) {
	return 0 === e ? "" : `${e}`;
}
function dx(e) {
	if (e < 0 || e > 255) {
		let t = Error(`Invalid DSL Method idx value: <${e}>
	Idx value must be a none negative value smaller than 256`);
		throw t.KNOWN_RECORDER_ERROR = !0, t;
	}
}
h(dm, "recordProd"), h(dy, "recordOrProd"), h(dv, "getIdxSuffix"), h(dx, "assertMethodIdxIsValid");
var db = class {
	static {
		h(this, "PerformanceTracer");
	}
	initPerformanceTracer(e) {
		if (nq(e, "traceInitPerf")) {
			let t = e.traceInitPerf, r = "number" == typeof t;
			this.traceInitMaxIdent = r ? t : Infinity, this.traceInitPerf = r ? t > 0 : t;
		} else this.traceInitMaxIdent = 0, this.traceInitPerf = dI.traceInitPerf;
		this.traceInitIndent = -1;
	}
	TRACE_INIT(e, t) {
		if (!0 !== this.traceInitPerf) return t();
		{
			this.traceInitIndent++;
			let r = Array(this.traceInitIndent + 1).join("	");
			this.traceInitIndent < this.traceInitMaxIdent && console.log(`${r}--> <${e}>`);
			let { time: i, value: n } = l6(t), a = i > 10 ? console.warn : console.log;
			return this.traceInitIndent < this.traceInitMaxIdent && a(`${r}<-- <${e}> time: ${i}ms`), this.traceInitIndent--, n;
		}
	}
};
function dw(e, t) {
	t.forEach((t) => {
		let r = t.prototype;
		Object.getOwnPropertyNames(r).forEach((i) => {
			if ("constructor" === i) return;
			let n = Object.getOwnPropertyDescriptor(r, i);
			n && (n.get || n.set) ? Object.defineProperty(e.prototype, i, n) : e.prototype[i] = t.prototype[i];
		});
	});
}
h(dw, "applyMixins");
var dk = hY(hW, "", NaN, NaN, NaN, NaN, NaN, NaN);
Object.freeze(dk);
var dT, d_, dE, dC, dS, dA, dL, dR, dN, dI = Object.freeze({
	recoveryEnabled: !1,
	maxLookahead: 3,
	dynamicTokensEnabled: !1,
	outputCst: !0,
	errorMessageProvider: hH,
	nodeLocationTracking: "none",
	traceInitPerf: !1,
	skipValidations: !1
}), dM = Object.freeze({
	recoveryValueFunc: h(() => {}, "recoveryValueFunc"),
	resyncEnabled: !0
});
function dD(e) {
	return function() {
		return e;
	};
}
(g9 = dN || (dN = {}))[g9.INVALID_RULE_NAME = 0] = "INVALID_RULE_NAME", g9[g9.DUPLICATE_RULE_NAME = 1] = "DUPLICATE_RULE_NAME", g9[g9.INVALID_RULE_OVERRIDE = 2] = "INVALID_RULE_OVERRIDE", g9[g9.DUPLICATE_PRODUCTIONS = 3] = "DUPLICATE_PRODUCTIONS", g9[g9.UNRESOLVED_SUBRULE_REF = 4] = "UNRESOLVED_SUBRULE_REF", g9[g9.LEFT_RECURSION = 5] = "LEFT_RECURSION", g9[g9.NONE_LAST_EMPTY_ALT = 6] = "NONE_LAST_EMPTY_ALT", g9[g9.AMBIGUOUS_ALTS = 7] = "AMBIGUOUS_ALTS", g9[g9.CONFLICT_TOKENS_RULES_NAMESPACE = 8] = "CONFLICT_TOKENS_RULES_NAMESPACE", g9[g9.INVALID_TOKEN_NAME = 9] = "INVALID_TOKEN_NAME", g9[g9.NO_NON_EMPTY_LOOKAHEAD = 10] = "NO_NON_EMPTY_LOOKAHEAD", g9[g9.AMBIGUOUS_PREFIX_ALTS = 11] = "AMBIGUOUS_PREFIX_ALTS", g9[g9.TOO_MANY_ALTS = 12] = "TOO_MANY_ALTS", g9[g9.CUSTOM_LOOKAHEAD_VALIDATION = 13] = "CUSTOM_LOOKAHEAD_VALIDATION", h(dD, "EMPTY_ALT");
var dO = class e {
	static {
		h(this, "Parser");
	}
	static performSelfAnalysis(e) {
		throw Error("The **static** `performSelfAnalysis` method has been deprecated.	\nUse the **instance** method with the same name instead.");
	}
	performSelfAnalysis() {
		this.TRACE_INIT("performSelfAnalysis", () => {
			let t;
			this.selfAnalysisDone = !0;
			let r = this.className;
			this.TRACE_INIT("toFastProps", () => {
				l7(this);
			}), this.TRACE_INIT("Grammar Recording", () => {
				try {
					this.enableRecording(), rU(this.definedRulesNames, (e) => {
						let t = this[e].originalGrammarAction, r;
						this.TRACE_INIT(`${e} Rule`, () => {
							r = this.topLevelRuleRecord(e, t);
						}), this.gastProductionsCache[e] = r;
					});
				} finally {
					this.disableRecording();
				}
			});
			let i = [];
			if (this.TRACE_INIT("Grammar Resolving", () => {
				i = uO({ rules: i$(this.gastProductionsCache) }), this.definitionErrors = this.definitionErrors.concat(i);
			}), this.TRACE_INIT("Grammar Validations", () => {
				if (t3(i) && !1 === this.skipValidations) {
					let e = u$({
						rules: i$(this.gastProductionsCache),
						tokenTypes: i$(this.tokensMap),
						errMsgProvider: hK,
						grammarName: r
					}), t = um({
						lookaheadStrategy: this.lookaheadStrategy,
						rules: i$(this.gastProductionsCache),
						tokenTypes: i$(this.tokensMap),
						grammarName: r
					});
					this.definitionErrors = this.definitionErrors.concat(e, t);
				}
			}), t3(this.definitionErrors) && (this.recoveryEnabled && this.TRACE_INIT("computeAllProdsFollows", () => {
				this.resyncFollows = cC(i$(this.gastProductionsCache));
			}), this.TRACE_INIT("ComputeLookaheadFunctions", () => {
				var e, t;
				null == (t = (e = this.lookaheadStrategy).initialize) || t.call(e, { rules: i$(this.gastProductionsCache) }), this.preComputeLookaheadFunctions(i$(this.gastProductionsCache));
			})), !e.DEFER_DEFINITION_ERRORS_HANDLING && !t3(this.definitionErrors)) throw t = iD(this.definitionErrors, (e) => e.message), Error(`Parser Definition Errors detected:
 ${t.join(`
-------------------------------
`)}`);
		});
	}
	constructor(e, t) {
		if (this.definitionErrors = [], this.selfAnalysisDone = !1, this.initErrorHandler(t), this.initLexerAdapter(), this.initLooksAhead(t), this.initRecognizerEngine(e, t), this.initRecoverable(t), this.initTreeBuilder(t), this.initContentAssist(), this.initGastRecorder(t), this.initPerformanceTracer(t), nq(t, "ignoredIssues")) throw Error(`The <ignoredIssues> IParserConfig property has been deprecated.
	Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.
	See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES
	For further details.`);
		this.skipValidations = nq(t, "skipValidations") ? t.skipValidations : dI.skipValidations;
	}
};
dO.DEFER_DEFINITION_ERRORS_HANDLING = !1, dw(dO, [
	uZ,
	u1,
	dn,
	da,
	dl,
	ds,
	dc,
	dh,
	dg,
	db
]);
var d$ = class extends dO {
	static {
		h(this, "EmbeddedActionsParser");
	}
	constructor(e, t = dI) {
		let r = rI(t);
		r.outputCst = !1, super(e, r);
	}
};
function dP(e, t, r) {
	return `${e.name}_${t}_${r}`;
}
h(dP, "buildATNKey");
var dB = class {
	static {
		h(this, "AbstractTransition");
	}
	constructor(e) {
		this.target = e;
	}
	isEpsilon() {
		return !1;
	}
}, dF = class extends dB {
	static {
		h(this, "AtomTransition");
	}
	constructor(e, t) {
		super(e), this.tokenType = t;
	}
}, dz = class extends dB {
	static {
		h(this, "EpsilonTransition");
	}
	constructor(e) {
		super(e);
	}
	isEpsilon() {
		return !0;
	}
}, dU = class extends dB {
	static {
		h(this, "RuleTransition");
	}
	constructor(e, t, r) {
		super(e), this.rule = t, this.followState = r;
	}
	isEpsilon() {
		return !0;
	}
};
function dG(e) {
	let t = {
		decisionMap: {},
		decisionStates: [],
		ruleToStartState: /* @__PURE__ */ new Map(),
		ruleToStopState: /* @__PURE__ */ new Map(),
		states: []
	};
	dq(t, e);
	let r = e.length;
	for (let i = 0; i < r; i++) {
		let r = e[i], n = dZ(t, r, r);
		void 0 !== n && d7(t, r, n);
	}
	return t;
}
function dq(e, t) {
	let r = t.length;
	for (let i = 0; i < r; i++) {
		let r = t[i], n = d9(e, r, void 0, { type: 2 }), a = d9(e, r, void 0, { type: 7 });
		n.stop = a, e.ruleToStartState.set(r, n), e.ruleToStopState.set(r, a);
	}
}
function dj(e, t, r) {
	return r instanceof ch ? d3(e, t, r.terminalType, r) : r instanceof ct ? d6(e, t, r) : r instanceof cc ? dX(e, t, r) : r instanceof cn ? dK(e, t, r) : r instanceof co ? dW(e, t, r) : r instanceof cl ? dY(e, t, r) : r instanceof ca ? dV(e, t, r) : r instanceof cs ? dH(e, t, r) : dZ(e, t, r);
}
function dW(e, t, r) {
	let i = d9(e, t, r, { type: 5 });
	return d1(e, i), dJ(e, t, r, d2(e, t, i, r, dZ(e, t, r)));
}
function dY(e, t, r) {
	let i = d9(e, t, r, { type: 5 });
	return d1(e, i), dJ(e, t, r, d2(e, t, i, r, dZ(e, t, r)), d3(e, t, r.separator, r));
}
function dV(e, t, r) {
	let i = d9(e, t, r, { type: 4 });
	return d1(e, i), dQ(e, t, r, d2(e, t, i, r, dZ(e, t, r)));
}
function dH(e, t, r) {
	let i = d9(e, t, r, { type: 4 });
	return d1(e, i), dQ(e, t, r, d2(e, t, i, r, dZ(e, t, r)), d3(e, t, r.separator, r));
}
function dX(e, t, r) {
	let i = d9(e, t, r, { type: 1 });
	return d1(e, i), d2(e, t, i, r, ...iD(r.definition, (r) => dj(e, t, r)));
}
function dK(e, t, r) {
	let i = d9(e, t, r, { type: 1 });
	return d1(e, i), d0(e, t, r, d2(e, t, i, r, dZ(e, t, r)));
}
function dZ(e, t, r) {
	let i = iI(iD(r.definition, (r) => dj(e, t, r)), (e) => void 0 !== e);
	return 1 === i.length ? i[0] : 0 === i.length ? void 0 : d5(e, i);
}
function dQ(e, t, r, i, n) {
	let a = i.left, s = i.right, o = d9(e, t, r, { type: 11 });
	d1(e, o);
	let l = d9(e, t, r, { type: 12 });
	return a.loopback = o, l.loopback = o, e.decisionMap[dP(t, n ? "RepetitionMandatoryWithSeparator" : "RepetitionMandatory", r.idx)] = o, d8(s, o), void 0 === n ? (d8(o, a), d8(o, l)) : (d8(o, l), d8(o, n.left), d8(n.right, a)), {
		left: a,
		right: l
	};
}
function dJ(e, t, r, i, n) {
	let a = i.left, s = i.right, o = d9(e, t, r, { type: 10 });
	d1(e, o);
	let l = d9(e, t, r, { type: 12 }), h = d9(e, t, r, { type: 9 });
	return o.loopback = h, l.loopback = h, d8(o, a), d8(o, l), d8(s, h), void 0 !== n ? (d8(h, l), d8(h, n.left), d8(n.right, a)) : d8(h, o), e.decisionMap[dP(t, n ? "RepetitionWithSeparator" : "Repetition", r.idx)] = o, {
		left: o,
		right: l
	};
}
function d0(e, t, r, i) {
	let n = i.left;
	return d8(n, i.right), e.decisionMap[dP(t, "Option", r.idx)] = n, i;
}
function d1(e, t) {
	return e.decisionStates.push(t), t.decision = e.decisionStates.length - 1, t.decision;
}
function d2(e, t, r, i, ...n) {
	let a = d9(e, t, i, {
		type: 8,
		start: r
	});
	for (let e of (r.end = a, n)) void 0 !== e ? (d8(r, e.left), d8(e.right, a)) : d8(r, a);
	return e.decisionMap[dP(t, d4(i), i.idx)] = r, {
		left: r,
		right: a
	};
}
function d4(e) {
	if (e instanceof cc) return "Alternation";
	if (e instanceof cn) return "Option";
	if (e instanceof co) return "Repetition";
	if (e instanceof cl) return "RepetitionWithSeparator";
	if (e instanceof ca) return "RepetitionMandatory";
	if (e instanceof cs) return "RepetitionMandatoryWithSeparator";
	throw Error("Invalid production type encountered");
}
function d5(e, t) {
	let r = t.length;
	for (let i = 0; i < r - 1; i++) {
		let r = t[i], n;
		1 === r.left.transitions.length && (n = r.left.transitions[0]);
		let a = n instanceof dU, s = n, o = t[i + 1].left;
		1 === r.left.type && 1 === r.right.type && void 0 !== n && (a && s.followState === r.right || n.target === r.right) ? (a ? s.followState = o : n.target = o, pt(e, r.right)) : d8(r.right, o);
	}
	let i = t[0], n = t[r - 1];
	return {
		left: i.left,
		right: n.right
	};
}
function d3(e, t, r, i) {
	let n = d9(e, t, i, { type: 1 }), a = d9(e, t, i, { type: 1 });
	return pe(n, new dF(a, r)), {
		left: n,
		right: a
	};
}
function d6(e, t, r) {
	let i = r.referencedRule, n = e.ruleToStartState.get(i), a = d9(e, t, r, { type: 1 }), s = d9(e, t, r, { type: 1 });
	return pe(a, new dU(n, i, s)), {
		left: a,
		right: s
	};
}
function d7(e, t, r) {
	let i = e.ruleToStartState.get(t);
	d8(i, r.left);
	let n = e.ruleToStopState.get(t);
	return d8(r.right, n), {
		left: i,
		right: n
	};
}
function d8(e, t) {
	pe(e, new dz(t));
}
function d9(e, t, r, i) {
	let n = Object.assign({
		atn: e,
		production: r,
		epsilonOnlyTransitions: !1,
		rule: t,
		transitions: [],
		nextTokenWithinRule: [],
		stateNumber: e.states.length
	}, i);
	return e.states.push(n), n;
}
function pe(e, t) {
	0 === e.transitions.length && (e.epsilonOnlyTransitions = t.isEpsilon()), e.transitions.push(t);
}
function pt(e, t) {
	e.states.splice(e.states.indexOf(t), 1);
}
h(dG, "createATN"), h(dq, "createRuleStartAndStopATNStates"), h(dj, "atom"), h(dW, "repetition"), h(dY, "repetitionSep"), h(dV, "repetitionMandatory"), h(dH, "repetitionMandatorySep"), h(dX, "alternation"), h(dK, "option"), h(dZ, "block"), h(dQ, "plus"), h(dJ, "star"), h(d0, "optional"), h(d1, "defineDecisionState"), h(d2, "makeAlts"), h(d4, "getProdType"), h(d5, "makeBlock"), h(d3, "tokenRef"), h(d6, "ruleRef"), h(d7, "buildRuleHandle"), h(d8, "epsilon"), h(d9, "newState"), h(pe, "addTransition"), h(pt, "removeState");
var pr = {}, pi = class {
	static {
		h(this, "ATNConfigSet");
	}
	constructor() {
		this.map = {}, this.configs = [];
	}
	get size() {
		return this.configs.length;
	}
	finalize() {
		this.map = {};
	}
	add(e) {
		let t = pn(e);
		t in this.map || (this.map[t] = this.configs.length, this.configs.push(e));
	}
	get elements() {
		return this.configs;
	}
	get alts() {
		return iD(this.configs, (e) => e.alt);
	}
	get key() {
		let e = "";
		for (let t in this.map) e += t + ":";
		return e;
	}
};
function pn(e, t = !0) {
	return `${t ? `a${e.alt}` : ""}s${e.state.stateNumber}:${e.stack.map((e) => e.stateNumber.toString()).join("_")}`;
}
function pa(e, t) {
	let r = {};
	return (i) => {
		let n = i.toString(), a = r[n];
		return void 0 !== a || (a = {
			atnStartState: e,
			decision: t,
			states: {}
		}, r[n] = a), a;
	};
}
h(pn, "getATNConfigKey"), h(pa, "createDFACache");
var ps = class {
	static {
		h(this, "PredicateSet");
	}
	constructor() {
		this.predicates = [];
	}
	is(e) {
		return e >= this.predicates.length || this.predicates[e];
	}
	set(e, t) {
		this.predicates[e] = t;
	}
	toString() {
		let e = "", t = this.predicates.length;
		for (let r = 0; r < t; r++) e += !0 === this.predicates[r] ? "1" : "0";
		return e;
	}
}, po = new ps(), pl = class extends u0 {
	static {
		h(this, "LLStarLookaheadStrategy");
	}
	constructor(e) {
		var t;
		super(), this.logging = null != (t = e?.logging) ? t : (e) => console.log(e);
	}
	initialize(e) {
		this.atn = dG(e.rules), this.dfas = ph(this.atn);
	}
	validateAmbiguousAlternationAlternatives() {
		return [];
	}
	validateEmptyOrAlternatives() {
		return [];
	}
	buildLookaheadForAlternation(e) {
		let { prodOccurrence: t, rule: r, hasPredicates: i, dynamicTokensEnabled: n } = e, a = this.dfas, s = this.logging, o = dP(r, "Alternation", t), l = this.atn.decisionMap[o].decision, h = iD(ue({
			maxLookahead: 1,
			occurrence: t,
			prodType: "Alternation",
			rule: r
		}), (e) => iD(e, (e) => e[0]));
		if (!pc(h, !1) || n) return i ? function(e) {
			let t = new ps(), r = void 0 === e ? 0 : e.length;
			for (let i = 0; i < r; i++) {
				let r = e?.[i].GATE;
				t.set(i, void 0 === r || r.call(this));
			}
			let i = pu.call(this, a, l, t, s);
			return "number" == typeof i ? i : void 0;
		} : function() {
			let e = pu.call(this, a, l, po, s);
			return "number" == typeof e ? e : void 0;
		};
		{
			let e = iJ(h, (e, t, r) => (rU(t, (t) => {
				t && (e[t.tokenTypeIdx] = r, rU(t.categoryMatches, (t) => {
					e[t] = r;
				}));
			}), e), {});
			return i ? function(t) {
				var r;
				let i = e[this.LA(1).tokenTypeIdx];
				if (void 0 !== t && void 0 !== i) {
					let e = null == (r = t[i]) ? void 0 : r.GATE;
					if (void 0 !== e && !1 === e.call(this)) return;
				}
				return i;
			} : function() {
				return e[this.LA(1).tokenTypeIdx];
			};
		}
	}
	buildLookaheadForOptional(e) {
		let { prodOccurrence: t, rule: r, prodType: i, dynamicTokensEnabled: n } = e, a = this.dfas, s = this.logging, o = dP(r, i, t), l = this.atn.decisionMap[o].decision, h = iD(ue({
			maxLookahead: 1,
			occurrence: t,
			prodType: i,
			rule: r
		}), (e) => iD(e, (e) => e[0]));
		if (pc(h) && h[0][0] && !n) {
			let e = iH(h[0]);
			if (1 === e.length && t3(e[0].categoryMatches)) {
				let t = e[0].tokenTypeIdx;
				return function() {
					return this.LA(1).tokenTypeIdx === t;
				};
			}
			{
				let t = iJ(e, (e, t) => (void 0 !== t && (e[t.tokenTypeIdx] = !0, rU(t.categoryMatches, (t) => {
					e[t] = !0;
				})), e), {});
				return function() {
					return !0 === t[this.LA(1).tokenTypeIdx];
				};
			}
		}
		return function() {
			let e = pu.call(this, a, l, po, s);
			return "object" != typeof e && 0 === e;
		};
	}
};
function pc(e, t = !0) {
	let r = /* @__PURE__ */ new Set();
	for (let i of e) {
		let e = /* @__PURE__ */ new Set();
		for (let n of i) {
			if (void 0 === n) {
				if (t) break;
				return !1;
			}
			for (let t of [n.tokenTypeIdx].concat(n.categoryMatches)) if (r.has(t)) {
				if (!e.has(t)) return !1;
			} else r.add(t), e.add(t);
		}
	}
	return !0;
}
function ph(e) {
	let t = e.decisionStates.length, r = Array(t);
	for (let i = 0; i < t; i++) r[i] = pa(e.decisionStates[i], i);
	return r;
}
function pu(e, t, r, i) {
	let n = e[t](r), a = n.start;
	return void 0 === a && (a = p_(n, pk(pE(n.atnStartState))), n.start = a), pd.apply(this, [
		n,
		a,
		r,
		i
	]);
}
function pd(e, t, r, i) {
	let n = t, a = 1, s = [], o = this.LA(a++);
	for (;;) {
		let t = pv(n, o);
		if (void 0 === t && (t = pp.apply(this, [
			e,
			n,
			o,
			a,
			r,
			i
		])), t === pr) return py(s, n, o);
		if (!0 === t.isAcceptState) return t.prediction;
		n = t, s.push(o), o = this.LA(a++);
	}
}
function pp(e, t, r, i, n, a) {
	let s = px(t.configs, r, n);
	if (0 === s.size) return pT(e, t, r, pr), pr;
	let o = pk(s), l = pw(s, n);
	if (void 0 !== l) o.isAcceptState = !0, o.prediction = l, o.configs.uniqueAlt = l;
	else if (pR(s)) {
		let t = nJ(s.alts);
		o.isAcceptState = !0, o.prediction = t, o.configs.uniqueAlt = t, pf.apply(this, [
			e,
			i,
			s.alts,
			a
		]);
	}
	return pT(e, t, r, o);
}
function pf(e, t, r, i) {
	let n = [];
	for (let e = 1; e <= t; e++) n.push(this.LA(e).tokenType);
	let a = e.atnStartState;
	i(pg({
		topLevelRule: a.rule,
		ambiguityIndices: r,
		production: a.production,
		prefixPath: n
	}));
}
function pg(e) {
	let t = iD(e.prefixPath, (e) => hM(e)).join(", "), r = 0 === e.production.idx ? "" : e.production.idx;
	return `Ambiguous Alternatives Detected: <${e.ambiguityIndices.join(", ")}> in <${pm(e.production)}${r}> inside <${e.topLevelRule.name}> Rule,
<${t}> may appears as a prefix path in all these alternatives.
See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.`;
}
function pm(e) {
	if (e instanceof ct) return "SUBRULE";
	if (e instanceof cn) return "OPTION";
	if (e instanceof cc) return "OR";
	if (e instanceof ca) return "AT_LEAST_ONE";
	if (e instanceof cs) return "AT_LEAST_ONE_SEP";
	if (e instanceof cl) return "MANY_SEP";
	if (e instanceof co) return "MANY";
	if (e instanceof ch) return "CONSUME";
	throw Error("non exhaustive match");
}
function py(e, t, r) {
	return {
		actualToken: r,
		possibleTokenTypes: aw(n$(t.configs.elements, (e) => e.state.transitions).filter((e) => e instanceof dF).map((e) => e.tokenType), (e) => e.tokenTypeIdx),
		tokenPath: e
	};
}
function pv(e, t) {
	return e.edges[t.tokenTypeIdx];
}
function px(e, t, r) {
	let i, n = new pi(), a = [];
	for (let i of e.elements) {
		if (!1 === r.is(i.alt)) continue;
		if (7 === i.state.type) {
			a.push(i);
			continue;
		}
		let e = i.state.transitions.length;
		for (let r = 0; r < e; r++) {
			let e = pb(i.state.transitions[r], t);
			void 0 !== e && n.add({
				state: e,
				alt: i.alt,
				stack: i.stack
			});
		}
	}
	if (0 === a.length && 1 === n.size && (i = n), void 0 === i) for (let e of (i = new pi(), n.elements)) pC(e, i);
	if (a.length > 0 && !pA(i)) for (let e of a) i.add(e);
	return i;
}
function pb(e, t) {
	if (e instanceof dF && hV(t, e.tokenType)) return e.target;
}
function pw(e, t) {
	let r;
	for (let i of e.elements) if (!0 === t.is(i.alt)) {
		if (void 0 === r) r = i.alt;
		else if (r !== i.alt) return;
	}
	return r;
}
function pk(e) {
	return {
		configs: e,
		edges: {},
		isAcceptState: !1,
		prediction: -1
	};
}
function pT(e, t, r, i) {
	return i = p_(e, i), t.edges[r.tokenTypeIdx] = i, i;
}
function p_(e, t) {
	if (t === pr) return t;
	let r = t.configs.key, i = e.states[r];
	return void 0 !== i ? i : (t.configs.finalize(), e.states[r] = t, t);
}
function pE(e) {
	let t = new pi(), r = e.transitions.length;
	for (let i = 0; i < r; i++) pC({
		state: e.transitions[i].target,
		alt: i,
		stack: []
	}, t);
	return t;
}
function pC(e, t) {
	let r = e.state;
	if (7 === r.type) {
		if (e.stack.length > 0) {
			let r = [...e.stack];
			pC({
				state: r.pop(),
				alt: e.alt,
				stack: r
			}, t);
		} else t.add(e);
		return;
	}
	r.epsilonOnlyTransitions || t.add(e);
	let i = r.transitions.length;
	for (let n = 0; n < i; n++) {
		let i = pS(e, r.transitions[n]);
		void 0 !== i && pC(i, t);
	}
}
function pS(e, t) {
	if (t instanceof dz) return {
		state: t.target,
		alt: e.alt,
		stack: e.stack
	};
	if (t instanceof dU) {
		let r = [...e.stack, t.followState];
		return {
			state: t.target,
			alt: e.alt,
			stack: r
		};
	}
}
function pA(e) {
	for (let t of e.elements) if (7 === t.state.type) return !0;
	return !1;
}
function pL(e) {
	for (let t of e.elements) if (7 !== t.state.type) return !1;
	return !0;
}
function pR(e) {
	if (pL(e)) return !0;
	let t = pN(e.elements);
	return pI(t) && !pM(t);
}
function pN(e) {
	let t = /* @__PURE__ */ new Map();
	for (let r of e) {
		let e = pn(r, !1), i = t.get(e);
		void 0 === i && (i = {}, t.set(e, i)), i[r.alt] = !0;
	}
	return t;
}
function pI(e) {
	for (let t of Array.from(e.values())) if (Object.keys(t).length > 1) return !0;
	return !1;
}
function pM(e) {
	for (let t of Array.from(e.values())) if (1 === Object.keys(t).length) return !0;
	return !1;
}
h(pc, "isLL1Sequence"), h(ph, "initATNSimulator"), h(pu, "adaptivePredict"), h(pd, "performLookahead"), h(pp, "computeLookaheadTarget"), h(pf, "reportLookaheadAmbiguity"), h(pg, "buildAmbiguityError"), h(pm, "getProductionDslName"), h(py, "buildAdaptivePredictError"), h(pv, "getExistingTargetState"), h(px, "computeReachSet"), h(pb, "getReachableTarget"), h(pw, "getUniqueAlt"), h(pk, "newDFAState"), h(pT, "addDFAEdge"), h(p_, "addDFAState"), h(pE, "computeStartState"), h(pC, "closure"), h(pS, "getEpsilonTarget"), h(pA, "hasConfigInRuleStopState"), h(pL, "allConfigsInRuleStopStates"), h(pR, "hasConflictTerminatingPrediction"), h(pN, "getConflictingAltSets"), h(pI, "hasConflictingAltSet"), h(pM, "hasStateAssociatedWithOneAlt");
var pD = mp || (mp = {});
function pO(e) {
	return "string" == typeof e;
}
h(pO, "is"), pD.is = pO;
var p$ = mf || (mf = {});
function pP(e) {
	return "string" == typeof e;
}
h(pP, "is"), p$.is = pP;
var pB = mg || (mg = {});
function pF(e) {
	return "number" == typeof e && pB.MIN_VALUE <= e && e <= pB.MAX_VALUE;
}
pB.MIN_VALUE = -2147483648, pB.MAX_VALUE = 2147483647, h(pF, "is"), pB.is = pF;
var pz = mm || (mm = {});
function pU(e) {
	return "number" == typeof e && pz.MIN_VALUE <= e && e <= pz.MAX_VALUE;
}
pz.MIN_VALUE = 0, pz.MAX_VALUE = 2147483647, h(pU, "is"), pz.is = pU;
var pG = my || (my = {});
function pq(e, t) {
	return e === Number.MAX_VALUE && (e = mm.MAX_VALUE), t === Number.MAX_VALUE && (t = mm.MAX_VALUE), {
		line: e,
		character: t
	};
}
function pj(e) {
	return yA.objectLiteral(e) && yA.uinteger(e.line) && yA.uinteger(e.character);
}
h(pq, "create"), pG.create = pq, h(pj, "is"), pG.is = pj;
var pW = mv || (mv = {});
function pY(e, t, r, i) {
	if (yA.uinteger(e) && yA.uinteger(t) && yA.uinteger(r) && yA.uinteger(i)) return {
		start: my.create(e, t),
		end: my.create(r, i)
	};
	if (my.is(e) && my.is(t)) return {
		start: e,
		end: t
	};
	throw Error(`Range#create called with invalid arguments[${e}, ${t}, ${r}, ${i}]`);
}
function pV(e) {
	return yA.objectLiteral(e) && my.is(e.start) && my.is(e.end);
}
h(pY, "create"), pW.create = pY, h(pV, "is"), pW.is = pV;
var pH = mx || (mx = {});
function pX(e, t) {
	return {
		uri: e,
		range: t
	};
}
function pK(e) {
	return yA.objectLiteral(e) && mv.is(e.range) && (yA.string(e.uri) || yA.undefined(e.uri));
}
h(pX, "create"), pH.create = pX, h(pK, "is"), pH.is = pK;
var pZ = mb || (mb = {});
function pQ(e, t, r, i) {
	return {
		targetUri: e,
		targetRange: t,
		targetSelectionRange: r,
		originSelectionRange: i
	};
}
function pJ(e) {
	return yA.objectLiteral(e) && mv.is(e.targetRange) && yA.string(e.targetUri) && mv.is(e.targetSelectionRange) && (mv.is(e.originSelectionRange) || yA.undefined(e.originSelectionRange));
}
h(pQ, "create"), pZ.create = pQ, h(pJ, "is"), pZ.is = pJ;
var p0 = mw || (mw = {});
function p1(e, t, r, i) {
	return {
		red: e,
		green: t,
		blue: r,
		alpha: i
	};
}
function p2(e) {
	return yA.objectLiteral(e) && yA.numberRange(e.red, 0, 1) && yA.numberRange(e.green, 0, 1) && yA.numberRange(e.blue, 0, 1) && yA.numberRange(e.alpha, 0, 1);
}
h(p1, "create"), p0.create = p1, h(p2, "is"), p0.is = p2;
var p4 = mk || (mk = {});
function p5(e, t) {
	return {
		range: e,
		color: t
	};
}
function p3(e) {
	return yA.objectLiteral(e) && mv.is(e.range) && mw.is(e.color);
}
h(p5, "create"), p4.create = p5, h(p3, "is"), p4.is = p3;
var p6 = mT || (mT = {});
function p7(e, t, r) {
	return {
		label: e,
		textEdit: t,
		additionalTextEdits: r
	};
}
function p8(e) {
	return yA.objectLiteral(e) && yA.string(e.label) && (yA.undefined(e.textEdit) || mI.is(e)) && (yA.undefined(e.additionalTextEdits) || yA.typedArray(e.additionalTextEdits, mI.is));
}
h(p7, "create"), p6.create = p7, h(p8, "is"), p6.is = p8, (me = m_ || (m_ = {})).Comment = "comment", me.Imports = "imports", me.Region = "region";
var p9 = mE || (mE = {});
function fe(e, t, r, i, n, a) {
	let s = {
		startLine: e,
		endLine: t
	};
	return yA.defined(r) && (s.startCharacter = r), yA.defined(i) && (s.endCharacter = i), yA.defined(n) && (s.kind = n), yA.defined(a) && (s.collapsedText = a), s;
}
function ft(e) {
	return yA.objectLiteral(e) && yA.uinteger(e.startLine) && yA.uinteger(e.startLine) && (yA.undefined(e.startCharacter) || yA.uinteger(e.startCharacter)) && (yA.undefined(e.endCharacter) || yA.uinteger(e.endCharacter)) && (yA.undefined(e.kind) || yA.string(e.kind));
}
h(fe, "create"), p9.create = fe, h(ft, "is"), p9.is = ft;
var fr = mC || (mC = {});
function fi(e, t) {
	return {
		location: e,
		message: t
	};
}
function fn(e) {
	return yA.defined(e) && mx.is(e.location) && yA.string(e.message);
}
h(fi, "create"), fr.create = fi, h(fn, "is"), fr.is = fn, (mt = mS || (mS = {})).Error = 1, mt.Warning = 2, mt.Information = 3, mt.Hint = 4, (mr = mA || (mA = {})).Unnecessary = 1, mr.Deprecated = 2;
var fa = mL || (mL = {});
function fs(e) {
	return yA.objectLiteral(e) && yA.string(e.href);
}
h(fs, "is"), fa.is = fs;
var fo = mR || (mR = {});
function fl(e, t, r, i, n, a) {
	let s = {
		range: e,
		message: t
	};
	return yA.defined(r) && (s.severity = r), yA.defined(i) && (s.code = i), yA.defined(n) && (s.source = n), yA.defined(a) && (s.relatedInformation = a), s;
}
function fc(e) {
	var t;
	return yA.defined(e) && mv.is(e.range) && yA.string(e.message) && (yA.number(e.severity) || yA.undefined(e.severity)) && (yA.integer(e.code) || yA.string(e.code) || yA.undefined(e.code)) && (yA.undefined(e.codeDescription) || yA.string(null == (t = e.codeDescription) ? void 0 : t.href)) && (yA.string(e.source) || yA.undefined(e.source)) && (yA.undefined(e.relatedInformation) || yA.typedArray(e.relatedInformation, mC.is));
}
h(fl, "create"), fo.create = fl, h(fc, "is"), fo.is = fc;
var fh = mN || (mN = {});
function fu(e, t, ...r) {
	let i = {
		title: e,
		command: t
	};
	return yA.defined(r) && r.length > 0 && (i.arguments = r), i;
}
function fd(e) {
	return yA.defined(e) && yA.string(e.title) && yA.string(e.command);
}
h(fu, "create"), fh.create = fu, h(fd, "is"), fh.is = fd, function(e) {
	function t(e, t) {
		return {
			range: e,
			newText: t
		};
	}
	function r(e, t) {
		return {
			range: {
				start: e,
				end: e
			},
			newText: t
		};
	}
	function i(e) {
		return {
			range: e,
			newText: ""
		};
	}
	function n(e) {
		return yA.objectLiteral(e) && yA.string(e.newText) && mv.is(e.range);
	}
	h(t, "replace"), e.replace = t, h(r, "insert"), e.insert = r, h(i, "del"), e.del = i, h(n, "is"), e.is = n;
}(mI || (mI = {}));
var fp = mM || (mM = {});
function ff(e, t, r) {
	let i = { label: e };
	return void 0 !== t && (i.needsConfirmation = t), void 0 !== r && (i.description = r), i;
}
function fg(e) {
	return yA.objectLiteral(e) && yA.string(e.label) && (yA.boolean(e.needsConfirmation) || void 0 === e.needsConfirmation) && (yA.string(e.description) || void 0 === e.description);
}
h(ff, "create"), fp.create = ff, h(fg, "is"), fp.is = fg;
var fm = mD || (mD = {});
function fy(e) {
	return yA.string(e);
}
h(fy, "is"), fm.is = fy, function(e) {
	function t(e, t, r) {
		return {
			range: e,
			newText: t,
			annotationId: r
		};
	}
	function r(e, t, r) {
		return {
			range: {
				start: e,
				end: e
			},
			newText: t,
			annotationId: r
		};
	}
	function i(e, t) {
		return {
			range: e,
			newText: "",
			annotationId: t
		};
	}
	function n(e) {
		return mI.is(e) && (mM.is(e.annotationId) || mD.is(e.annotationId));
	}
	h(t, "replace"), e.replace = t, h(r, "insert"), e.insert = r, h(i, "del"), e.del = i, h(n, "is"), e.is = n;
}(mO || (mO = {}));
var fv = m$ || (m$ = {});
function fx(e, t) {
	return {
		textDocument: e,
		edits: t
	};
}
function fb(e) {
	return yA.defined(e) && mq.is(e.textDocument) && Array.isArray(e.edits);
}
h(fx, "create"), fv.create = fx, h(fb, "is"), fv.is = fb;
var fw = mP || (mP = {});
function fk(e, t, r) {
	let i = {
		kind: "create",
		uri: e
	};
	return void 0 !== t && (void 0 !== t.overwrite || void 0 !== t.ignoreIfExists) && (i.options = t), void 0 !== r && (i.annotationId = r), i;
}
function fT(e) {
	return e && "create" === e.kind && yA.string(e.uri) && (void 0 === e.options || (void 0 === e.options.overwrite || yA.boolean(e.options.overwrite)) && (void 0 === e.options.ignoreIfExists || yA.boolean(e.options.ignoreIfExists))) && (void 0 === e.annotationId || mD.is(e.annotationId));
}
h(fk, "create"), fw.create = fk, h(fT, "is"), fw.is = fT;
var f_ = mB || (mB = {});
function fE(e, t, r, i) {
	let n = {
		kind: "rename",
		oldUri: e,
		newUri: t
	};
	return void 0 !== r && (void 0 !== r.overwrite || void 0 !== r.ignoreIfExists) && (n.options = r), void 0 !== i && (n.annotationId = i), n;
}
function fC(e) {
	return e && "rename" === e.kind && yA.string(e.oldUri) && yA.string(e.newUri) && (void 0 === e.options || (void 0 === e.options.overwrite || yA.boolean(e.options.overwrite)) && (void 0 === e.options.ignoreIfExists || yA.boolean(e.options.ignoreIfExists))) && (void 0 === e.annotationId || mD.is(e.annotationId));
}
h(fE, "create"), f_.create = fE, h(fC, "is"), f_.is = fC;
var fS = mF || (mF = {});
function fA(e, t, r) {
	let i = {
		kind: "delete",
		uri: e
	};
	return void 0 !== t && (void 0 !== t.recursive || void 0 !== t.ignoreIfNotExists) && (i.options = t), void 0 !== r && (i.annotationId = r), i;
}
function fL(e) {
	return e && "delete" === e.kind && yA.string(e.uri) && (void 0 === e.options || (void 0 === e.options.recursive || yA.boolean(e.options.recursive)) && (void 0 === e.options.ignoreIfNotExists || yA.boolean(e.options.ignoreIfNotExists))) && (void 0 === e.annotationId || mD.is(e.annotationId));
}
h(fA, "create"), fS.create = fA, h(fL, "is"), fS.is = fL;
var fR = mz || (mz = {});
function fN(e) {
	return e && (void 0 !== e.changes || void 0 !== e.documentChanges) && (void 0 === e.documentChanges || e.documentChanges.every((e) => yA.string(e.kind) ? mP.is(e) || mB.is(e) || mF.is(e) : m$.is(e)));
}
h(fN, "is"), fR.is = fN;
var fI = mU || (mU = {});
function fM(e) {
	return { uri: e };
}
function fD(e) {
	return yA.defined(e) && yA.string(e.uri);
}
h(fM, "create"), fI.create = fM, h(fD, "is"), fI.is = fD;
var fO = mG || (mG = {});
function f$(e, t) {
	return {
		uri: e,
		version: t
	};
}
function fP(e) {
	return yA.defined(e) && yA.string(e.uri) && yA.integer(e.version);
}
h(f$, "create"), fO.create = f$, h(fP, "is"), fO.is = fP;
var fB = mq || (mq = {});
function fF(e, t) {
	return {
		uri: e,
		version: t
	};
}
function fz(e) {
	return yA.defined(e) && yA.string(e.uri) && (null === e.version || yA.integer(e.version));
}
h(fF, "create"), fB.create = fF, h(fz, "is"), fB.is = fz;
var fU = mj || (mj = {});
function fG(e, t, r, i) {
	return {
		uri: e,
		languageId: t,
		version: r,
		text: i
	};
}
function fq(e) {
	return yA.defined(e) && yA.string(e.uri) && yA.string(e.languageId) && yA.integer(e.version) && yA.string(e.text);
}
h(fG, "create"), fU.create = fG, h(fq, "is"), fU.is = fq;
var fj = mW || (mW = {});
function fW(e) {
	return e === fj.PlainText || e === fj.Markdown;
}
fj.PlainText = "plaintext", fj.Markdown = "markdown", h(fW, "is"), fj.is = fW;
var fY = mY || (mY = {});
function fV(e) {
	return yA.objectLiteral(e) && mW.is(e.kind) && yA.string(e.value);
}
h(fV, "is"), fY.is = fV, (mi = mV || (mV = {})).Text = 1, mi.Method = 2, mi.Function = 3, mi.Constructor = 4, mi.Field = 5, mi.Variable = 6, mi.Class = 7, mi.Interface = 8, mi.Module = 9, mi.Property = 10, mi.Unit = 11, mi.Value = 12, mi.Enum = 13, mi.Keyword = 14, mi.Snippet = 15, mi.Color = 16, mi.File = 17, mi.Reference = 18, mi.Folder = 19, mi.EnumMember = 20, mi.Constant = 21, mi.Struct = 22, mi.Event = 23, mi.Operator = 24, mi.TypeParameter = 25, (mn = mH || (mH = {})).PlainText = 1, mn.Snippet = 2, (mX || (mX = {})).Deprecated = 1;
var fH = mK || (mK = {});
function fX(e, t, r) {
	return {
		newText: e,
		insert: t,
		replace: r
	};
}
function fK(e) {
	return e && yA.string(e.newText) && mv.is(e.insert) && mv.is(e.replace);
}
h(fX, "create"), fH.create = fX, h(fK, "is"), fH.is = fK, (ma = mZ || (mZ = {})).asIs = 1, ma.adjustIndentation = 2;
var fZ = mQ || (mQ = {});
function fQ(e) {
	return e && (yA.string(e.detail) || void 0 === e.detail) && (yA.string(e.description) || void 0 === e.description);
}
h(fQ, "is"), fZ.is = fQ;
var fJ = mJ || (mJ = {});
function f0(e) {
	return { label: e };
}
h(f0, "create"), fJ.create = f0;
var f1 = m0 || (m0 = {});
function f2(e, t) {
	return {
		items: e || [],
		isIncomplete: !!t
	};
}
h(f2, "create"), f1.create = f2;
var f4 = m1 || (m1 = {});
function f5(e) {
	return e.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
}
function f3(e) {
	return yA.string(e) || yA.objectLiteral(e) && yA.string(e.language) && yA.string(e.value);
}
h(f5, "fromPlainText"), f4.fromPlainText = f5, h(f3, "is"), f4.is = f3;
var f6 = m2 || (m2 = {});
function f7(e) {
	return !!e && yA.objectLiteral(e) && (mY.is(e.contents) || m1.is(e.contents) || yA.typedArray(e.contents, m1.is)) && (void 0 === e.range || mv.is(e.range));
}
h(f7, "is"), f6.is = f7;
var f8 = m4 || (m4 = {});
function f9(e, t) {
	return t ? {
		label: e,
		documentation: t
	} : { label: e };
}
h(f9, "create"), f8.create = f9;
var ge = m5 || (m5 = {});
function gt(e, t, ...r) {
	let i = { label: e };
	return yA.defined(t) && (i.documentation = t), yA.defined(r) ? i.parameters = r : i.parameters = [], i;
}
h(gt, "create"), ge.create = gt, (ms = m3 || (m3 = {})).Text = 1, ms.Read = 2, ms.Write = 3;
var gr = m6 || (m6 = {});
function gi(e, t) {
	let r = { range: e };
	return yA.number(t) && (r.kind = t), r;
}
h(gi, "create"), gr.create = gi, (mo = m7 || (m7 = {})).File = 1, mo.Module = 2, mo.Namespace = 3, mo.Package = 4, mo.Class = 5, mo.Method = 6, mo.Property = 7, mo.Field = 8, mo.Constructor = 9, mo.Enum = 10, mo.Interface = 11, mo.Function = 12, mo.Variable = 13, mo.Constant = 14, mo.String = 15, mo.Number = 16, mo.Boolean = 17, mo.Array = 18, mo.Object = 19, mo.Key = 20, mo.Null = 21, mo.EnumMember = 22, mo.Struct = 23, mo.Event = 24, mo.Operator = 25, mo.TypeParameter = 26, (m8 || (m8 = {})).Deprecated = 1;
var gn = m9 || (m9 = {});
function ga(e, t, r, i, n) {
	let a = {
		name: e,
		kind: t,
		location: {
			uri: i,
			range: r
		}
	};
	return n && (a.containerName = n), a;
}
h(ga, "create"), gn.create = ga;
var gs = ye || (ye = {});
function go(e, t, r, i) {
	return void 0 !== i ? {
		name: e,
		kind: t,
		location: {
			uri: r,
			range: i
		}
	} : {
		name: e,
		kind: t,
		location: { uri: r }
	};
}
h(go, "create"), gs.create = go;
var gl = yt || (yt = {});
function gc(e, t, r, i, n, a) {
	let s = {
		name: e,
		detail: t,
		kind: r,
		range: i,
		selectionRange: n
	};
	return void 0 !== a && (s.children = a), s;
}
function gh(e) {
	return e && yA.string(e.name) && yA.number(e.kind) && mv.is(e.range) && mv.is(e.selectionRange) && (void 0 === e.detail || yA.string(e.detail)) && (void 0 === e.deprecated || yA.boolean(e.deprecated)) && (void 0 === e.children || Array.isArray(e.children)) && (void 0 === e.tags || Array.isArray(e.tags));
}
h(gc, "create"), gl.create = gc, h(gh, "is"), gl.is = gh, (ml = yr || (yr = {})).Empty = "", ml.QuickFix = "quickfix", ml.Refactor = "refactor", ml.RefactorExtract = "refactor.extract", ml.RefactorInline = "refactor.inline", ml.RefactorRewrite = "refactor.rewrite", ml.Source = "source", ml.SourceOrganizeImports = "source.organizeImports", ml.SourceFixAll = "source.fixAll", (mc = yi || (yi = {})).Invoked = 1, mc.Automatic = 2;
var gu = yn || (yn = {});
function gd(e, t, r) {
	let i = { diagnostics: e };
	return null != t && (i.only = t), null != r && (i.triggerKind = r), i;
}
function gp(e) {
	return yA.defined(e) && yA.typedArray(e.diagnostics, mR.is) && (void 0 === e.only || yA.typedArray(e.only, yA.string)) && (void 0 === e.triggerKind || e.triggerKind === yi.Invoked || e.triggerKind === yi.Automatic);
}
h(gd, "create"), gu.create = gd, h(gp, "is"), gu.is = gp;
var gf = ya || (ya = {});
function gg(e, t, r) {
	let i = { title: e }, n = !0;
	return "string" == typeof t ? (n = !1, i.kind = t) : mN.is(t) ? i.command = t : i.edit = t, n && void 0 !== r && (i.kind = r), i;
}
function gm(e) {
	return e && yA.string(e.title) && (void 0 === e.diagnostics || yA.typedArray(e.diagnostics, mR.is)) && (void 0 === e.kind || yA.string(e.kind)) && (void 0 !== e.edit || void 0 !== e.command) && (void 0 === e.command || mN.is(e.command)) && (void 0 === e.isPreferred || yA.boolean(e.isPreferred)) && (void 0 === e.edit || mz.is(e.edit));
}
h(gg, "create"), gf.create = gg, h(gm, "is"), gf.is = gm;
var gy = ys || (ys = {});
function gv(e, t) {
	let r = { range: e };
	return yA.defined(t) && (r.data = t), r;
}
function gx(e) {
	return yA.defined(e) && mv.is(e.range) && (yA.undefined(e.command) || mN.is(e.command));
}
h(gv, "create"), gy.create = gv, h(gx, "is"), gy.is = gx;
var gb = yo || (yo = {});
function gw(e, t) {
	return {
		tabSize: e,
		insertSpaces: t
	};
}
function gk(e) {
	return yA.defined(e) && yA.uinteger(e.tabSize) && yA.boolean(e.insertSpaces);
}
h(gw, "create"), gb.create = gw, h(gk, "is"), gb.is = gk;
var gT = yl || (yl = {});
function g_(e, t, r) {
	return {
		range: e,
		target: t,
		data: r
	};
}
function gE(e) {
	return yA.defined(e) && mv.is(e.range) && (yA.undefined(e.target) || yA.string(e.target));
}
h(g_, "create"), gT.create = g_, h(gE, "is"), gT.is = gE;
var gC = yc || (yc = {});
function gS(e, t) {
	return {
		range: e,
		parent: t
	};
}
function gA(e) {
	return yA.objectLiteral(e) && mv.is(e.range) && (void 0 === e.parent || gC.is(e.parent));
}
h(gS, "create"), gC.create = gS, h(gA, "is"), gC.is = gA, (mh = yh || (yh = {})).namespace = "namespace", mh.type = "type", mh.class = "class", mh.enum = "enum", mh.interface = "interface", mh.struct = "struct", mh.typeParameter = "typeParameter", mh.parameter = "parameter", mh.variable = "variable", mh.property = "property", mh.enumMember = "enumMember", mh.event = "event", mh.function = "function", mh.method = "method", mh.macro = "macro", mh.keyword = "keyword", mh.modifier = "modifier", mh.comment = "comment", mh.string = "string", mh.number = "number", mh.regexp = "regexp", mh.operator = "operator", mh.decorator = "decorator", (mu = yu || (yu = {})).declaration = "declaration", mu.definition = "definition", mu.readonly = "readonly", mu.static = "static", mu.deprecated = "deprecated", mu.abstract = "abstract", mu.async = "async", mu.modification = "modification", mu.documentation = "documentation", mu.defaultLibrary = "defaultLibrary";
var gL = yd || (yd = {});
function gR(e) {
	return yA.objectLiteral(e) && (void 0 === e.resultId || "string" == typeof e.resultId) && Array.isArray(e.data) && (0 === e.data.length || "number" == typeof e.data[0]);
}
h(gR, "is"), gL.is = gR;
var gN = yp || (yp = {});
function gI(e, t) {
	return {
		range: e,
		text: t
	};
}
function gM(e) {
	return null != e && mv.is(e.range) && yA.string(e.text);
}
h(gI, "create"), gN.create = gI, h(gM, "is"), gN.is = gM;
var gD = yf || (yf = {});
function gO(e, t, r) {
	return {
		range: e,
		variableName: t,
		caseSensitiveLookup: r
	};
}
function g$(e) {
	return null != e && mv.is(e.range) && yA.boolean(e.caseSensitiveLookup) && (yA.string(e.variableName) || void 0 === e.variableName);
}
h(gO, "create"), gD.create = gO, h(g$, "is"), gD.is = g$;
var gP = yg || (yg = {});
function gB(e, t) {
	return {
		range: e,
		expression: t
	};
}
function gF(e) {
	return null != e && mv.is(e.range) && (yA.string(e.expression) || void 0 === e.expression);
}
h(gB, "create"), gP.create = gB, h(gF, "is"), gP.is = gF;
var gz = ym || (ym = {});
function gU(e, t) {
	return {
		frameId: e,
		stoppedLocation: t
	};
}
function gG(e) {
	return yA.defined(e) && mv.is(e.stoppedLocation);
}
h(gU, "create"), gz.create = gU, h(gG, "is"), gz.is = gG;
var gq = yy || (yy = {});
function gj(e) {
	return 1 === e || 2 === e;
}
gq.Type = 1, gq.Parameter = 2, h(gj, "is"), gq.is = gj;
var gW = yv || (yv = {});
function gY(e) {
	return { value: e };
}
function gV(e) {
	return yA.objectLiteral(e) && (void 0 === e.tooltip || yA.string(e.tooltip) || mY.is(e.tooltip)) && (void 0 === e.location || mx.is(e.location)) && (void 0 === e.command || mN.is(e.command));
}
h(gY, "create"), gW.create = gY, h(gV, "is"), gW.is = gV;
var gH = yx || (yx = {});
function gX(e, t, r) {
	let i = {
		position: e,
		label: t
	};
	return void 0 !== r && (i.kind = r), i;
}
function gK(e) {
	return yA.objectLiteral(e) && my.is(e.position) && (yA.string(e.label) || yA.typedArray(e.label, yv.is)) && (void 0 === e.kind || yy.is(e.kind)) && void 0 === e.textEdits || yA.typedArray(e.textEdits, mI.is) && (void 0 === e.tooltip || yA.string(e.tooltip) || mY.is(e.tooltip)) && (void 0 === e.paddingLeft || yA.boolean(e.paddingLeft)) && (void 0 === e.paddingRight || yA.boolean(e.paddingRight));
}
h(gX, "create"), gH.create = gX, h(gK, "is"), gH.is = gK;
var gZ = yb || (yb = {});
function gQ(e) {
	return {
		kind: "snippet",
		value: e
	};
}
h(gQ, "createSnippet"), gZ.createSnippet = gQ;
var gJ = yw || (yw = {});
function g0(e, t, r, i) {
	return {
		insertText: e,
		filterText: t,
		range: r,
		command: i
	};
}
h(g0, "create"), gJ.create = g0;
var g1 = yk || (yk = {});
function g2(e) {
	return { items: e };
}
h(g2, "create"), g1.create = g2, (md = yT || (yT = {})).Invoked = 0, md.Automatic = 1;
var g4 = y_ || (y_ = {});
function g5(e, t) {
	return {
		range: e,
		text: t
	};
}
h(g5, "create"), g4.create = g5;
var g3 = yE || (yE = {});
function g6(e, t) {
	return {
		triggerKind: e,
		selectedCompletionInfo: t
	};
}
h(g6, "create"), g3.create = g6;
var g7 = yC || (yC = {});
function g8(e) {
	return yA.objectLiteral(e) && mf.is(e.uri) && yA.string(e.name);
}
h(g8, "is"), g7.is = g8, function(e) {
	function t(e, t, r, i) {
		return new yL(e, t, r, i);
	}
	function r(e) {
		return !!(yA.defined(e) && yA.string(e.uri) && (yA.undefined(e.languageId) || yA.string(e.languageId)) && yA.uinteger(e.lineCount) && yA.func(e.getText) && yA.func(e.positionAt) && yA.func(e.offsetAt));
	}
	function i(e, t) {
		let r = e.getText(), i = n(t, (e, t) => {
			let r = e.range.start.line - t.range.start.line;
			return 0 === r ? e.range.start.character - t.range.start.character : r;
		}), a = r.length;
		for (let t = i.length - 1; t >= 0; t--) {
			let n = i[t], s = e.offsetAt(n.range.start), o = e.offsetAt(n.range.end);
			if (o <= a) r = r.substring(0, s) + n.newText + r.substring(o, r.length);
			else throw Error("Overlapping edit");
			a = s;
		}
		return r;
	}
	function n(e, t) {
		if (e.length <= 1) return e;
		let r = e.length / 2 | 0, i = e.slice(0, r), a = e.slice(r);
		n(i, t), n(a, t);
		let s = 0, o = 0, l = 0;
		for (; s < i.length && o < a.length;) 0 >= t(i[s], a[o]) ? e[l++] = i[s++] : e[l++] = a[o++];
		for (; s < i.length;) e[l++] = i[s++];
		for (; o < a.length;) e[l++] = a[o++];
		return e;
	}
	h(t, "create"), e.create = t, h(r, "is"), e.is = r, h(i, "applyEdits"), e.applyEdits = i, h(n, "mergeSort");
}(yS || (yS = {}));
var g9, me, mt, mr, mi, mn, ma, ms, mo, ml, mc, mh, mu, md, mp, mf, mg, mm, my, mv, mx, mb, mw, mk, mT, m_, mE, mC, mS, mA, mL, mR, mN, mI, mM, mD, mO, m$, mP, mB, mF, mz, mU, mG, mq, mj, mW, mY, mV, mH, mX, mK, mZ, mQ, mJ, m0, m1, m2, m4, m5, m3, m6, m7, m8, m9, ye, yt, yr, yi, yn, ya, ys, yo, yl, yc, yh, yu, yd, yp, yf, yg, ym, yy, yv, yx, yb, yw, yk, yT, y_, yE, yC, yS, yA, yL = class {
	static {
		h(this, "FullTextDocument");
	}
	constructor(e, t, r, i) {
		this._uri = e, this._languageId = t, this._version = r, this._content = i, this._lineOffsets = void 0;
	}
	get uri() {
		return this._uri;
	}
	get languageId() {
		return this._languageId;
	}
	get version() {
		return this._version;
	}
	getText(e) {
		if (e) {
			let t = this.offsetAt(e.start), r = this.offsetAt(e.end);
			return this._content.substring(t, r);
		}
		return this._content;
	}
	update(e, t) {
		this._content = e.text, this._version = t, this._lineOffsets = void 0;
	}
	getLineOffsets() {
		if (void 0 === this._lineOffsets) {
			let e = [], t = this._content, r = !0;
			for (let i = 0; i < t.length; i++) {
				r && (e.push(i), r = !1);
				let n = t.charAt(i);
				r = "\r" === n || n === `
`, "\r" === n && i + 1 < t.length && t.charAt(i + 1) === `
` && i++;
			}
			r && t.length > 0 && e.push(t.length), this._lineOffsets = e;
		}
		return this._lineOffsets;
	}
	positionAt(e) {
		e = Math.max(Math.min(e, this._content.length), 0);
		let t = this.getLineOffsets(), r = 0, i = t.length;
		if (0 === i) return my.create(0, e);
		for (; r < i;) {
			let n = Math.floor((r + i) / 2);
			t[n] > e ? i = n : r = n + 1;
		}
		let n = r - 1;
		return my.create(n, e - t[n]);
	}
	offsetAt(e) {
		let t = this.getLineOffsets();
		if (e.line >= t.length) return this._content.length;
		if (e.line < 0) return 0;
		let r = t[e.line], i = e.line + 1 < t.length ? t[e.line + 1] : this._content.length;
		return Math.max(Math.min(r + e.character, i), r);
	}
	get lineCount() {
		return this.getLineOffsets().length;
	}
};
(function(e) {
	let t = Object.prototype.toString;
	function r(e) {
		return "u" > typeof e;
	}
	function i(e) {
		return typeof e > "u";
	}
	function n(e) {
		return !0 === e || !1 === e;
	}
	function a(e) {
		return "[object String]" === t.call(e);
	}
	function s(e) {
		return "[object Number]" === t.call(e);
	}
	function o(e, r, i) {
		return "[object Number]" === t.call(e) && r <= e && e <= i;
	}
	function l(e) {
		return "[object Number]" === t.call(e) && -2147483648 <= e && e <= 2147483647;
	}
	function u(e) {
		return "[object Number]" === t.call(e) && 0 <= e && e <= 2147483647;
	}
	function d(e) {
		return "[object Function]" === t.call(e);
	}
	function p(e) {
		return null !== e && "object" == typeof e;
	}
	function f(e, t) {
		return Array.isArray(e) && e.every(t);
	}
	h(r, "defined"), e.defined = r, h(i, "undefined"), e.undefined = i, h(n, "boolean"), e.boolean = n, h(a, "string"), e.string = a, h(s, "number"), e.number = s, h(o, "numberRange"), e.numberRange = o, h(l, "integer"), e.integer = l, h(u, "uinteger"), e.uinteger = u, h(d, "func"), e.func = d, h(p, "objectLiteral"), e.objectLiteral = p, h(f, "typedArray"), e.typedArray = f;
})(yA || (yA = {}));
var yR = class {
	static {
		h(this, "CstNodeBuilder");
	}
	constructor() {
		this.nodeStack = [];
	}
	get current() {
		var e;
		return null != (e = this.nodeStack[this.nodeStack.length - 1]) ? e : this.rootNode;
	}
	buildRootNode(e) {
		return this.rootNode = new yO(e), this.rootNode.root = this.rootNode, this.nodeStack = [this.rootNode], this.rootNode;
	}
	buildCompositeNode(e) {
		let t = new yM();
		return t.grammarSource = e, t.root = this.rootNode, this.current.content.push(t), this.nodeStack.push(t), t;
	}
	buildLeafNode(e, t) {
		let r = new yI(e.startOffset, e.image.length, aQ(e), e.tokenType, !t);
		return r.grammarSource = t, r.root = this.rootNode, this.current.content.push(r), r;
	}
	removeNode(e) {
		let t = e.container;
		if (t) {
			let r = t.content.indexOf(e);
			r >= 0 && t.content.splice(r, 1);
		}
	}
	addHiddenNodes(e) {
		let t = [];
		for (let r of e) {
			let e = new yI(r.startOffset, r.image.length, aQ(r), r.tokenType, !0);
			e.root = this.rootNode, t.push(e);
		}
		let r = this.current, i = !1;
		if (r.content.length > 0) return void r.content.push(...t);
		for (; r.container;) {
			let e = r.container.content.indexOf(r);
			if (e > 0) {
				r.container.content.splice(e, 0, ...t), i = !0;
				break;
			}
			r = r.container;
		}
		i || this.rootNode.content.unshift(...t);
	}
	construct(e) {
		let t = this.current;
		"string" == typeof e.$type && (this.current.astNode = e), e.$cstNode = t;
		let r = this.nodeStack.pop();
		r?.content.length === 0 && this.removeNode(r);
	}
}, yN = class {
	static {
		h(this, "AbstractCstNode");
	}
	get parent() {
		return this.container;
	}
	get feature() {
		return this.grammarSource;
	}
	get hidden() {
		return !1;
	}
	get astNode() {
		var e, t;
		let r = "string" == typeof (null == (e = this._astNode) ? void 0 : e.$type) ? this._astNode : null == (t = this.container) ? void 0 : t.astNode;
		if (!r) throw Error("This node has no associated AST element");
		return r;
	}
	set astNode(e) {
		this._astNode = e;
	}
	get element() {
		return this.astNode;
	}
	get text() {
		return this.root.fullText.substring(this.offset, this.end);
	}
}, yI = class extends yN {
	static {
		h(this, "LeafCstNodeImpl");
	}
	get offset() {
		return this._offset;
	}
	get length() {
		return this._length;
	}
	get end() {
		return this._offset + this._length;
	}
	get hidden() {
		return this._hidden;
	}
	get tokenType() {
		return this._tokenType;
	}
	get range() {
		return this._range;
	}
	constructor(e, t, r, i, n = !1) {
		super(), this._hidden = n, this._offset = e, this._tokenType = i, this._length = t, this._range = r;
	}
}, yM = class extends yN {
	static {
		h(this, "CompositeCstNodeImpl");
	}
	constructor() {
		super(...arguments), this.content = new yD(this);
	}
	get children() {
		return this.content;
	}
	get offset() {
		var e, t;
		return null != (t = null == (e = this.firstNonHiddenNode) ? void 0 : e.offset) ? t : 0;
	}
	get length() {
		return this.end - this.offset;
	}
	get end() {
		var e, t;
		return null != (t = null == (e = this.lastNonHiddenNode) ? void 0 : e.end) ? t : 0;
	}
	get range() {
		let e = this.firstNonHiddenNode, t = this.lastNonHiddenNode;
		if (!e || !t) return {
			start: my.create(0, 0),
			end: my.create(0, 0)
		};
		if (void 0 === this._rangeCache) {
			let { range: r } = e, { range: i } = t;
			this._rangeCache = {
				start: r.start,
				end: i.end.line < r.start.line ? r.start : i.end
			};
		}
		return this._rangeCache;
	}
	get firstNonHiddenNode() {
		for (let e of this.content) if (!e.hidden) return e;
		return this.content[0];
	}
	get lastNonHiddenNode() {
		for (let e = this.content.length - 1; e >= 0; e--) {
			let t = this.content[e];
			if (!t.hidden) return t;
		}
		return this.content[this.content.length - 1];
	}
}, yD = class e extends Array {
	static {
		h(this, "CstNodeContainer");
	}
	constructor(t) {
		super(), this.parent = t, Object.setPrototypeOf(this, e.prototype);
	}
	push(...e) {
		return this.addParents(e), super.push(...e);
	}
	unshift(...e) {
		return this.addParents(e), super.unshift(...e);
	}
	splice(e, t, ...r) {
		return this.addParents(r), super.splice(e, t, ...r);
	}
	addParents(e) {
		for (let t of e) t.container = this.parent;
	}
}, yO = class extends yM {
	static {
		h(this, "RootCstNodeImpl");
	}
	get text() {
		return this._text.substring(this.offset, this.end);
	}
	get fullText() {
		return this._text;
	}
	constructor(e) {
		super(), this._text = "", this._text = e ?? "";
	}
}, y$ = Symbol("Datatype");
function yP(e) {
	return e.$type === y$;
}
h(yP, "isDataTypeNode");
var yB = h((e) => e.endsWith("") ? e : e + "", "withRuleSuffix"), yF = class {
	static {
		h(this, "AbstractLangiumParser");
	}
	constructor(e) {
		this._unorderedGroups = /* @__PURE__ */ new Map(), this.allRules = /* @__PURE__ */ new Map(), this.lexer = e.parser.Lexer;
		let t = this.lexer.definition, r = "production" === e.LanguageMetaData.mode;
		this.wrapper = new yW(t, Object.assign(Object.assign({}, e.parser.ParserConfig), {
			skipValidations: r,
			errorMessageProvider: e.parser.ParserErrorMessageProvider
		}));
	}
	alternatives(e, t) {
		this.wrapper.wrapOr(e, t);
	}
	optional(e, t) {
		this.wrapper.wrapOption(e, t);
	}
	many(e, t) {
		this.wrapper.wrapMany(e, t);
	}
	atLeastOne(e, t) {
		this.wrapper.wrapAtLeastOne(e, t);
	}
	getRule(e) {
		return this.allRules.get(e);
	}
	isRecording() {
		return this.wrapper.IS_RECORDING;
	}
	get unorderedGroups() {
		return this._unorderedGroups;
	}
	getRuleStack() {
		return this.wrapper.RULE_STACK;
	}
	finalize() {
		this.wrapper.wrapSelfAnalysis();
	}
}, yz = class extends yF {
	static {
		h(this, "LangiumParser");
	}
	get current() {
		return this.stack[this.stack.length - 1];
	}
	constructor(e) {
		super(e), this.nodeBuilder = new yR(), this.stack = [], this.assignmentMap = /* @__PURE__ */ new Map(), this.linker = e.references.Linker, this.converter = e.parser.ValueConverter, this.astReflection = e.shared.AstReflection;
	}
	rule(e, t) {
		let r = this.computeRuleType(e), i = this.wrapper.DEFINE_RULE(yB(e.name), this.startImplementation(r, t).bind(this));
		return this.allRules.set(e.name, i), e.entry && (this.mainRule = i), i;
	}
	computeRuleType(e) {
		if (!e.fragment) return lB(e) ? y$ : lG(e) ?? e.name;
	}
	parse(e, t = {}) {
		this.nodeBuilder.buildRootNode(e);
		let r = this.lexerResult = this.lexer.tokenize(e);
		this.wrapper.input = r.tokens;
		let i = t.rule ? this.allRules.get(t.rule) : this.mainRule;
		if (!i) throw Error(t.rule ? `No rule found with name '${t.rule}'` : "No main rule available.");
		let n = i.call(this.wrapper, {});
		return this.nodeBuilder.addHiddenNodes(r.hidden), this.unorderedGroups.clear(), this.lexerResult = void 0, {
			value: n,
			lexerErrors: r.errors,
			lexerReport: r.report,
			parserErrors: this.wrapper.errors
		};
	}
	startImplementation(e, t) {
		return (r) => {
			let i, n = !this.isRecording() && void 0 !== e;
			if (n) {
				let t = { $type: e };
				this.stack.push(t), e === y$ && (t.value = "");
			}
			try {
				i = t(r);
			} catch {
				i = void 0;
			}
			return void 0 === i && n && (i = this.construct()), i;
		};
	}
	extractHiddenTokens(e) {
		let t = this.lexerResult.hidden;
		if (!t.length) return [];
		let r = e.startOffset;
		for (let e = 0; e < t.length; e++) if (t[e].startOffset > r) return t.splice(0, e);
		return t.splice(0, t.length);
	}
	consume(e, t, r) {
		let i = this.wrapper.wrapConsume(e, t);
		if (!this.isRecording() && this.isValidToken(i)) {
			let e = this.extractHiddenTokens(i);
			this.nodeBuilder.addHiddenNodes(e);
			let t = this.nodeBuilder.buildLeafNode(i, r), { assignment: n, isCrossRef: a } = this.getAssignment(r), s = this.current;
			if (n) {
				let e = ow(r) ? i.image : this.converter.convert(i.image, t);
				this.assign(n.operator, n.feature, e, t, a);
			} else if (yP(s)) {
				let e = i.image;
				ow(r) || (e = this.converter.convert(e, t).toString()), s.value += e;
			}
		}
	}
	isValidToken(e) {
		return !e.isInsertedInRecovery && !isNaN(e.startOffset) && "number" == typeof e.endOffset && !isNaN(e.endOffset);
	}
	subrule(e, t, r, i, n) {
		let a;
		this.isRecording() || r || (a = this.nodeBuilder.buildCompositeNode(i));
		let s = this.wrapper.wrapSubrule(e, t, n);
		!this.isRecording() && a && a.length > 0 && this.performSubruleAssignment(s, i, a);
	}
	performSubruleAssignment(e, t, r) {
		let { assignment: i, isCrossRef: n } = this.getAssignment(t);
		if (i) this.assign(i.operator, i.feature, e, r, n);
		else if (!i) {
			let t = this.current;
			if (yP(t)) t.value += e.toString();
			else if ("object" == typeof e && e) {
				let r = this.assignWithoutOverride(e, t);
				this.stack.pop(), this.stack.push(r);
			}
		}
	}
	action(e, t) {
		if (!this.isRecording()) {
			let r = this.current;
			t.feature && t.operator ? (r = this.construct(), this.nodeBuilder.removeNode(r.$cstNode), this.nodeBuilder.buildCompositeNode(t).content.push(r.$cstNode), this.stack.push({ $type: e }), this.assign(t.operator, t.feature, r, r.$cstNode, !1)) : r.$type = e;
		}
	}
	construct() {
		if (this.isRecording()) return;
		let e = this.current;
		return oq(e), this.nodeBuilder.construct(e), this.stack.pop(), yP(e) ? this.converter.convert(e.value, e.$cstNode) : (o0(this.astReflection, e), e);
	}
	getAssignment(e) {
		if (!this.assignmentMap.has(e)) {
			let t = oj(e, ou);
			this.assignmentMap.set(e, {
				assignment: t,
				isCrossRef: !!t && og(t.terminal)
			});
		}
		return this.assignmentMap.get(e);
	}
	assign(e, t, r, i, n) {
		let a = this.current, s;
		switch (s = n && "string" == typeof r ? this.linker.buildReference(a, t, i, r) : r, e) {
			case "=":
				a[t] = s;
				break;
			case "?=":
				a[t] = !0;
				break;
			case "+=": Array.isArray(a[t]) || (a[t] = []), a[t].push(s);
		}
	}
	assignWithoutOverride(e, t) {
		for (let [r, i] of Object.entries(t)) {
			let t = e[r];
			void 0 === t ? e[r] = i : Array.isArray(t) && Array.isArray(i) && (i.push(...t), e[r] = i);
		}
		let r = e.$cstNode;
		return r && (r.astNode = void 0, e.$cstNode = void 0), e;
	}
	get definitionErrors() {
		return this.wrapper.definitionErrors;
	}
}, yU = class {
	static {
		h(this, "AbstractParserErrorMessageProvider");
	}
	buildMismatchTokenMessage(e) {
		return hH.buildMismatchTokenMessage(e);
	}
	buildNotAllInputParsedMessage(e) {
		return hH.buildNotAllInputParsedMessage(e);
	}
	buildNoViableAltMessage(e) {
		return hH.buildNoViableAltMessage(e);
	}
	buildEarlyExitMessage(e) {
		return hH.buildEarlyExitMessage(e);
	}
}, yG = class extends yU {
	static {
		h(this, "LangiumParserErrorMessageProvider");
	}
	buildMismatchTokenMessage({ expected: e, actual: t }) {
		return `Expecting ${e.LABEL ? "`" + e.LABEL + "`" : e.name.endsWith(":KW") ? `keyword '${e.name.substring(0, e.name.length - 3)}'` : `token of type '${e.name}'`} but found \`${t.image}\`.`;
	}
	buildNotAllInputParsedMessage({ firstRedundant: e }) {
		return `Expecting end of file but found \`${e.image}\`.`;
	}
}, yq = class extends yF {
	static {
		h(this, "LangiumCompletionParser");
	}
	constructor() {
		super(...arguments), this.tokens = [], this.elementStack = [], this.lastElementStack = [], this.nextTokenIndex = 0, this.stackSize = 0;
	}
	action() {}
	construct() {}
	parse(e) {
		return this.resetState(), this.tokens = this.lexer.tokenize(e, { mode: "partial" }).tokens, this.wrapper.input = [...this.tokens], this.mainRule.call(this.wrapper, {}), this.unorderedGroups.clear(), {
			tokens: this.tokens,
			elementStack: [...this.lastElementStack],
			tokenIndex: this.nextTokenIndex
		};
	}
	rule(e, t) {
		let r = this.wrapper.DEFINE_RULE(yB(e.name), this.startImplementation(t).bind(this));
		return this.allRules.set(e.name, r), e.entry && (this.mainRule = r), r;
	}
	resetState() {
		this.elementStack = [], this.lastElementStack = [], this.nextTokenIndex = 0, this.stackSize = 0;
	}
	startImplementation(e) {
		return (t) => {
			let r = this.keepStackSize();
			try {
				e(t);
			} finally {
				this.resetStackSize(r);
			}
		};
	}
	removeUnexpectedElements() {
		this.elementStack.splice(this.stackSize);
	}
	keepStackSize() {
		let e = this.elementStack.length;
		return this.stackSize = e, e;
	}
	resetStackSize(e) {
		this.removeUnexpectedElements(), this.stackSize = e;
	}
	consume(e, t, r) {
		this.wrapper.wrapConsume(e, t), this.isRecording() || (this.lastElementStack = [...this.elementStack, r], this.nextTokenIndex = this.currIdx + 1);
	}
	subrule(e, t, r, i, n) {
		this.before(i), this.wrapper.wrapSubrule(e, t, n), this.after(i);
	}
	before(e) {
		this.isRecording() || this.elementStack.push(e);
	}
	after(e) {
		if (!this.isRecording()) {
			let t = this.elementStack.lastIndexOf(e);
			t >= 0 && this.elementStack.splice(t);
		}
	}
	get currIdx() {
		return this.wrapper.currIdx;
	}
}, yj = {
	recoveryEnabled: !0,
	nodeLocationTracking: "full",
	skipValidations: !0,
	errorMessageProvider: new yG()
}, yW = class extends d$ {
	static {
		h(this, "ChevrotainWrapper");
	}
	constructor(e, t) {
		super(e, Object.assign(Object.assign(Object.assign({}, yj), { lookaheadStrategy: t && "maxLookahead" in t ? new u0({ maxLookahead: t.maxLookahead }) : new pl({ logging: t.skipValidations ? () => {} : void 0 }) }), t));
	}
	get IS_RECORDING() {
		return this.RECORDING_PHASE;
	}
	DEFINE_RULE(e, t) {
		return this.RULE(e, t);
	}
	wrapSelfAnalysis() {
		this.performSelfAnalysis();
	}
	wrapConsume(e, t) {
		return this.consume(e, t);
	}
	wrapSubrule(e, t, r) {
		return this.subrule(e, t, { ARGS: [r] });
	}
	wrapOr(e, t) {
		this.or(e, t);
	}
	wrapOption(e, t) {
		this.option(e, t);
	}
	wrapMany(e, t) {
		this.many(e, t);
	}
	wrapAtLeastOne(e, t) {
		this.atLeastOne(e, t);
	}
};
function yY(e, t, r) {
	return yV({
		parser: t,
		tokens: r,
		ruleNames: /* @__PURE__ */ new Map()
	}, e), t;
}
function yV(e, t) {
	let r = lw(t, !1);
	for (let i of aW(t.rules).filter(sJ).filter((e) => r.has(e))) {
		let t = Object.assign(Object.assign({}, e), {
			consume: 1,
			optional: 1,
			subrule: 1,
			many: 1,
			or: 1
		});
		e.parser.rule(i, yH(t, i.definition));
	}
}
function yH(e, t, r = !1) {
	let i;
	if (ow(t)) i = y5(e, t);
	else if (oo(t)) i = yX(e, t);
	else if (ou(t)) i = yH(e, t.terminal);
	else if (og(t)) i = y4(e, t);
	else if (oS(t)) i = yK(e, t);
	else if (oc(t)) i = yJ(e, t);
	else if (oO(t)) i = y0(e, t);
	else if (ox(t)) i = y1(e, t);
	else if (oy(t)) {
		let r = e.consume++;
		i = h(() => e.parser.consume(r, hW, t), "method");
	} else throw new ss(t.$cstNode, `Unexpected element type: ${t.$type}`);
	return y3(e, r ? void 0 : y2(t), i, t.cardinality);
}
function yX(e, t) {
	let r = lq(t);
	return () => e.parser.action(r, t);
}
function yK(e, t) {
	let r = t.rule.ref;
	if (sJ(r)) {
		let i = e.subrule++, n = r.fragment, a = t.arguments.length > 0 ? yZ(r, t.arguments) : () => ({});
		return (s) => e.parser.subrule(i, y6(e, r), n, t, a(s));
	}
	if (s9(r)) {
		let i = e.consume++, n = y8(e, r.name);
		return () => e.parser.consume(i, n, t);
	}
	if (r) so(r);
	else throw new ss(t.$cstNode, `Undefined rule: ${t.rule.$refText}`);
}
function yZ(e, t) {
	let r = t.map((e) => yQ(e.value));
	return (t) => {
		let i = {};
		for (let n = 0; n < r.length; n++) {
			let a = e.parameters[n], s = r[n];
			i[a.name] = s(t);
		}
		return i;
	};
}
function yQ(e) {
	if (sM(e)) {
		let t = yQ(e.left), r = yQ(e.right);
		return (e) => t(e) || r(e);
	}
	if (sN(e)) {
		let t = yQ(e.left), r = yQ(e.right);
		return (e) => t(e) && r(e);
	}
	if (sW(e)) {
		let t = yQ(e.value);
		return (e) => !t(e);
	}
	if (sZ(e)) {
		let t = e.parameter.ref.name;
		return (e) => void 0 !== e && !0 === e[t];
	}
	if (sL(e)) {
		let t = !!e.true;
		return () => t;
	}
	so(e);
}
function yJ(e, t) {
	if (1 === t.elements.length) return yH(e, t.elements[0]);
	{
		let r = [];
		for (let i of t.elements) {
			let t = { ALT: yH(e, i, !0) }, n = y2(i);
			n && (t.GATE = yQ(n)), r.push(t);
		}
		let i = e.or++;
		return (t) => e.parser.alternatives(i, r.map((e) => {
			let r = { ALT: h(() => e.ALT(t), "ALT") }, i = e.GATE;
			return i && (r.GATE = () => i(t)), r;
		}));
	}
}
function y0(e, t) {
	if (1 === t.elements.length) return yH(e, t.elements[0]);
	let r = [];
	for (let i of t.elements) {
		let t = { ALT: yH(e, i, !0) }, n = y2(i);
		n && (t.GATE = yQ(n)), r.push(t);
	}
	let i = e.or++, n = h((e, t) => `uGroup_${e}_${t.getRuleStack().join("-")}`, "idFunc"), a = h((t) => e.parser.alternatives(i, r.map((r, a) => {
		let s = { ALT: h(() => !0, "ALT") }, o = e.parser;
		s.ALT = () => {
			if (r.ALT(t), !o.isRecording()) {
				let e = n(i, o);
				o.unorderedGroups.get(e) || o.unorderedGroups.set(e, []);
				let t = o.unorderedGroups.get(e);
				typeof t?.[a] > "u" && (t[a] = !0);
			}
		};
		let l = r.GATE;
		return l ? s.GATE = () => l(t) : s.GATE = () => !o.unorderedGroups.get(n(i, o))?.[a], s;
	})), "alternatives"), s = y3(e, y2(t), a, "*");
	return (t) => {
		s(t), e.parser.isRecording() || e.parser.unorderedGroups.delete(n(i, e.parser));
	};
}
function y1(e, t) {
	let r = t.elements.map((t) => yH(e, t));
	return (e) => r.forEach((t) => t(e));
}
function y2(e) {
	if (ox(e)) return e.guardCondition;
}
function y4(e, t, r = t.terminal) {
	if (r) if (oS(r) && sJ(r.rule.ref)) {
		let i = r.rule.ref, n = e.subrule++;
		return (r) => e.parser.subrule(n, y6(e, i), !1, t, r);
	} else if (oS(r) && s9(r.rule.ref)) {
		let i = e.consume++, n = y8(e, r.rule.ref.name);
		return () => e.parser.consume(i, n, t);
	} else if (ow(r)) {
		let i = e.consume++, n = y8(e, r.value);
		return () => e.parser.consume(i, n, t);
	} else throw Error("Could not build cross reference parser");
	{
		if (!t.type.ref) throw Error("Could not resolve reference to type: " + t.type.$refText);
		let r = lI(t.type.ref)?.terminal;
		if (!r) throw Error("Could not find name assignment for type: " + lq(t.type.ref));
		return y4(e, t, r);
	}
}
function y5(e, t) {
	let r = e.consume++, i = e.tokens[t.value];
	if (!i) throw Error("Could not find token for keyword: " + t.value);
	return () => e.parser.consume(r, i, t);
}
function y3(e, t, r, i) {
	let n = t && yQ(t);
	if (!i) if (!n) return r;
	else {
		let t = e.or++;
		return (i) => e.parser.alternatives(t, [{
			ALT: h(() => r(i), "ALT"),
			GATE: h(() => n(i), "GATE")
		}, {
			ALT: dD(),
			GATE: h(() => !n(i), "GATE")
		}]);
	}
	if ("*" === i) {
		let t = e.many++;
		return (i) => e.parser.many(t, {
			DEF: h(() => r(i), "DEF"),
			GATE: n ? () => n(i) : void 0
		});
	}
	if ("+" === i) {
		let t = e.many++;
		if (!n) return (i) => e.parser.atLeastOne(t, { DEF: h(() => r(i), "DEF") });
		{
			let i = e.or++;
			return (a) => e.parser.alternatives(i, [{
				ALT: h(() => e.parser.atLeastOne(t, { DEF: h(() => r(a), "DEF") }), "ALT"),
				GATE: h(() => n(a), "GATE")
			}, {
				ALT: dD(),
				GATE: h(() => !n(a), "GATE")
			}]);
		}
	}
	if ("?" === i) {
		let t = e.optional++;
		return (i) => e.parser.optional(t, {
			DEF: h(() => r(i), "DEF"),
			GATE: n ? () => n(i) : void 0
		});
	}
	so(i);
}
function y6(e, t) {
	let r = y7(e, t), i = e.parser.getRule(r);
	if (!i) throw Error(`Rule "${r}" not found."`);
	return i;
}
function y7(e, t) {
	if (sJ(t)) return t.name;
	if (e.ruleNames.has(t)) return e.ruleNames.get(t);
	{
		let r = t, i = r.$container, n = t.$type;
		for (; !sJ(i);) (ox(i) || oc(i) || oO(i)) && (n = i.elements.indexOf(r).toString() + ":" + n), r = i, i = i.$container;
		return n = i.name + ":" + n, e.ruleNames.set(t, n), n;
	}
}
function y8(e, t) {
	let r = e.tokens[t];
	if (!r) throw Error(`Token "${t}" not found."`);
	return r;
}
function y9(e) {
	let t = e.Grammar, r = e.parser.Lexer, i = new yq(e);
	return yY(t, i, r.definition), i.finalize(), i;
}
function ve(e) {
	let t = vt(e);
	return t.finalize(), t;
}
function vt(e) {
	let t = e.Grammar, r = e.parser.Lexer;
	return yY(t, new yz(e), r.definition);
}
h(yY, "createParser"), h(yV, "buildRules"), h(yH, "buildElement"), h(yX, "buildAction"), h(yK, "buildRuleCall"), h(yZ, "buildRuleCallPredicate"), h(yQ, "buildPredicate"), h(yJ, "buildAlternatives"), h(y0, "buildUnorderedGroup"), h(y1, "buildGroup"), h(y2, "getGuardCondition"), h(y4, "buildCrossReference"), h(y5, "buildKeyword"), h(y3, "wrap"), h(y6, "getRule"), h(y7, "getRuleName"), h(y8, "getToken"), h(y9, "createCompletionParser"), h(ve, "createLangiumParser"), h(vt, "prepareLangiumParser");
var vr, vi = class {
	static {
		h(this, "DefaultTokenBuilder");
	}
	constructor() {
		this.diagnostics = [];
	}
	buildTokens(e, t) {
		let r = aW(lw(e, !1)), i = this.buildTerminalTokens(r), n = this.buildKeywordTokens(r, i, t);
		return i.forEach((e) => {
			let t = e.PATTERN;
			"object" == typeof t && t && "test" in t && lf(t) ? n.unshift(e) : n.push(e);
		}), n;
	}
	flushLexingReport(e) {
		return { diagnostics: this.popDiagnostics() };
	}
	popDiagnostics() {
		let e = [...this.diagnostics];
		return this.diagnostics = [], e;
	}
	buildTerminalTokens(e) {
		return e.filter(s9).filter((e) => !e.fragment).map((e) => this.buildTerminalToken(e)).toArray();
	}
	buildTerminalToken(e) {
		let t = lV(e), r = this.requiresCustomPattern(t) ? this.regexPatternFunction(t) : t, i = {
			name: e.name,
			PATTERN: r
		};
		return "function" == typeof r && (i.LINE_BREAKS = !0), e.hidden && (i.GROUP = lf(t) ? hI.SKIPPED : "hidden"), i;
	}
	requiresCustomPattern(e) {
		return !!(e.flags.includes("u") || e.flags.includes("s")) || !!(e.source.includes("?<=") || e.source.includes("?<!"));
	}
	regexPatternFunction(e) {
		let t = RegExp(e, e.flags + "y");
		return (e, r) => (t.lastIndex = r, t.exec(e));
	}
	buildKeywordTokens(e, t, r) {
		return e.filter(sJ).flatMap((e) => oX(e).filter(ow)).distinct((e) => e.value).toArray().sort((e, t) => t.value.length - e.value.length).map((e) => this.buildKeywordToken(e, t, !!r?.caseInsensitive));
	}
	buildKeywordToken(e, t, r) {
		let i = this.buildKeywordPattern(e, r), n = {
			name: e.value,
			PATTERN: i,
			LONGER_ALT: this.findLongerAlt(e, t)
		};
		return "function" == typeof i && (n.LINE_BREAKS = !0), n;
	}
	buildKeywordPattern(e, t) {
		return t ? new RegExp(lm(e.value)) : e.value;
	}
	findLongerAlt(e, t) {
		return t.reduce((t, r) => {
			let i = r?.PATTERN;
			return i?.source && ly("^" + i.source + "$", e.value) && t.push(r), t;
		}, []);
	}
}, vn = class {
	static {
		h(this, "DefaultValueConverter");
	}
	convert(e, t) {
		let r = t.grammarSource;
		if (og(r) && (r = lT(r)), oS(r)) {
			let i = r.rule.ref;
			if (!i) throw Error("This cst node was not parsed by a rule.");
			return this.runConverter(i, e, t);
		}
		return e;
	}
	runConverter(e, t, r) {
		var i;
		switch (e.name.toUpperCase()) {
			case "INT": return vr.convertInt(t);
			case "STRING": return vr.convertString(t);
			case "ID": return vr.convertID(t);
		}
		switch (null == (i = lY(e)) ? void 0 : i.toLowerCase()) {
			case "number": return vr.convertNumber(t);
			case "boolean": return vr.convertBoolean(t);
			case "bigint": return vr.convertBigint(t);
			case "date": return vr.convertDate(t);
			default: return t;
		}
	}
};
(function(e) {
	function t(e) {
		let t = "";
		for (let i = 1; i < e.length - 1; i++) {
			let n = e.charAt(i);
			"\\" === n ? t += r(e.charAt(++i)) : t += n;
		}
		return t;
	}
	function r(e) {
		switch (e) {
			case "b": return "\b";
			case "f": return "\f";
			case "n": return `
`;
			case "r": return "\r";
			case "t": return "	";
			case "v": return "\v";
			case "0": return "\0";
			default: return e;
		}
	}
	function i(e) {
		return "^" === e.charAt(0) ? e.substring(1) : e;
	}
	function n(e) {
		return parseInt(e);
	}
	function a(e) {
		return BigInt(e);
	}
	function s(e) {
		return new Date(e);
	}
	function o(e) {
		return Number(e);
	}
	function l(e) {
		return "true" === e.toLowerCase();
	}
	h(t, "convertString"), e.convertString = t, h(r, "convertEscapeCharacter"), h(i, "convertID"), e.convertID = i, h(n, "convertInt"), e.convertInt = n, h(a, "convertBigint"), e.convertBigint = a, h(s, "convertDate"), e.convertDate = s, h(o, "convertNumber"), e.convertNumber = o, h(l, "convertBoolean"), e.convertBoolean = l;
})(vr || (vr = {}));
var va = {};
function vs() {
	return new Promise((e) => {
		typeof setImmediate > "u" ? setTimeout(e, 0) : setImmediate(e);
	});
}
f(va, g(aL(), 1)), h(vs, "delayNextTick");
var vo = 0, vl = 10;
function vc() {
	return vo = performance.now(), new va.CancellationTokenSource();
}
function vh(e) {
	vl = e;
}
h(vc, "startCancelableOperation"), h(vh, "setInterruptionPeriod");
var vu = Symbol("OperationCancelled");
function vd(e) {
	return e === vu;
}
async function vp(e) {
	if (e === va.CancellationToken.None) return;
	let t = performance.now();
	if (t - vo >= vl && (vo = t, await vs(), vo = performance.now()), e.isCancellationRequested) throw vu;
}
h(vd, "isOperationCancelled"), h(vp, "interruptAndCheck");
var vf, vg = class {
	static {
		h(this, "Deferred");
	}
	constructor() {
		this.promise = new Promise((e, t) => {
			this.resolve = (t) => (e(t), this), this.reject = (e) => (t(e), this);
		});
	}
}, vm = class e {
	static {
		h(this, "FullTextDocument");
	}
	constructor(e, t, r, i) {
		this._uri = e, this._languageId = t, this._version = r, this._content = i, this._lineOffsets = void 0;
	}
	get uri() {
		return this._uri;
	}
	get languageId() {
		return this._languageId;
	}
	get version() {
		return this._version;
	}
	getText(e) {
		if (e) {
			let t = this.offsetAt(e.start), r = this.offsetAt(e.end);
			return this._content.substring(t, r);
		}
		return this._content;
	}
	update(t, r) {
		for (let r of t) if (e.isIncremental(r)) {
			let e = vb(r.range), t = this.offsetAt(e.start), i = this.offsetAt(e.end);
			this._content = this._content.substring(0, t) + r.text + this._content.substring(i, this._content.length);
			let n = Math.max(e.start.line, 0), a = Math.max(e.end.line, 0), s = this._lineOffsets, o = vv(r.text, !1, t);
			if (a - n === o.length) for (let e = 0, t = o.length; e < t; e++) s[e + n + 1] = o[e];
			else o.length < 1e4 ? s.splice(n + 1, a - n, ...o) : this._lineOffsets = s = s.slice(0, n + 1).concat(o, s.slice(a + 1));
			let l = r.text.length - (i - t);
			if (0 !== l) for (let e = n + 1 + o.length, t = s.length; e < t; e++) s[e] = s[e] + l;
		} else if (e.isFull(r)) this._content = r.text, this._lineOffsets = void 0;
		else throw Error("Unknown change event received");
		this._version = r;
	}
	getLineOffsets() {
		return void 0 === this._lineOffsets && (this._lineOffsets = vv(this._content, !0)), this._lineOffsets;
	}
	positionAt(e) {
		e = Math.max(Math.min(e, this._content.length), 0);
		let t = this.getLineOffsets(), r = 0, i = t.length;
		if (0 === i) return {
			line: 0,
			character: e
		};
		for (; r < i;) {
			let n = Math.floor((r + i) / 2);
			t[n] > e ? i = n : r = n + 1;
		}
		let n = r - 1;
		return e = this.ensureBeforeEOL(e, t[n]), {
			line: n,
			character: e - t[n]
		};
	}
	offsetAt(e) {
		let t = this.getLineOffsets();
		if (e.line >= t.length) return this._content.length;
		if (e.line < 0) return 0;
		let r = t[e.line];
		if (e.character <= 0) return r;
		let i = e.line + 1 < t.length ? t[e.line + 1] : this._content.length, n = Math.min(r + e.character, i);
		return this.ensureBeforeEOL(n, r);
	}
	ensureBeforeEOL(e, t) {
		for (; e > t && vx(this._content.charCodeAt(e - 1));) e--;
		return e;
	}
	get lineCount() {
		return this.getLineOffsets().length;
	}
	static isIncremental(e) {
		return null != e && "string" == typeof e.text && void 0 !== e.range && (void 0 === e.rangeLength || "number" == typeof e.rangeLength);
	}
	static isFull(e) {
		return null != e && "string" == typeof e.text && void 0 === e.range && void 0 === e.rangeLength;
	}
};
function vy(e, t) {
	if (e.length <= 1) return e;
	let r = e.length / 2 | 0, i = e.slice(0, r), n = e.slice(r);
	vy(i, t), vy(n, t);
	let a = 0, s = 0, o = 0;
	for (; a < i.length && s < n.length;) 0 >= t(i[a], n[s]) ? e[o++] = i[a++] : e[o++] = n[s++];
	for (; a < i.length;) e[o++] = i[a++];
	for (; s < n.length;) e[o++] = n[s++];
	return e;
}
function vv(e, t, r = 0) {
	let i = t ? [r] : [];
	for (let t = 0; t < e.length; t++) {
		let n = e.charCodeAt(t);
		vx(n) && (13 === n && t + 1 < e.length && 10 === e.charCodeAt(t + 1) && t++, i.push(r + t + 1));
	}
	return i;
}
function vx(e) {
	return 13 === e || 10 === e;
}
function vb(e) {
	let t = e.start, r = e.end;
	return t.line > r.line || t.line === r.line && t.character > r.character ? {
		start: r,
		end: t
	} : e;
}
function vw(e) {
	let t = vb(e.range);
	return t !== e.range ? {
		newText: e.newText,
		range: t
	} : e;
}
(function(e) {
	function t(e, t, r, i) {
		return new vm(e, t, r, i);
	}
	function r(e, t, r) {
		if (e instanceof vm) return e.update(t, r), e;
		throw Error("TextDocument.update: document must be created by TextDocument.create");
	}
	function i(e, t) {
		let r = e.getText(), i = vy(t.map(vw), (e, t) => {
			let r = e.range.start.line - t.range.start.line;
			return 0 === r ? e.range.start.character - t.range.start.character : r;
		}), n = 0, a = [];
		for (let t of i) {
			let i = e.offsetAt(t.range.start);
			if (i < n) throw Error("Overlapping edit");
			i > n && a.push(r.substring(n, i)), t.newText.length && a.push(t.newText), n = e.offsetAt(t.range.end);
		}
		return a.push(r.substr(n)), a.join("");
	}
	h(t, "create"), e.create = t, h(r, "update"), e.update = r, h(i, "applyEdits"), e.applyEdits = i;
})(vf || (vf = {})), h(vy, "mergeSort"), h(vv, "computeLineOffsets"), h(vx, "isEOL"), h(vb, "getWellformedRange"), h(vw, "getWellformedEdit");
var vk = { 470: (e) => {
	function t(e) {
		if ("string" != typeof e) throw TypeError("Path must be a string. Received " + JSON.stringify(e));
	}
	function r(e, t) {
		for (var r, i = "", n = 0, a = -1, s = 0, o = 0; o <= e.length; ++o) {
			if (o < e.length) r = e.charCodeAt(o);
			else {
				if (47 === r) break;
				r = 47;
			}
			if (47 === r) {
				if (a !== o - 1 && 1 !== s) if (a !== o - 1 && 2 === s) {
					if (i.length < 2 || 2 !== n || 46 !== i.charCodeAt(i.length - 1) || 46 !== i.charCodeAt(i.length - 2)) {
						if (i.length > 2) {
							var l = i.lastIndexOf("/");
							if (l !== i.length - 1) {
								-1 === l ? (i = "", n = 0) : n = (i = i.slice(0, l)).length - 1 - i.lastIndexOf("/"), a = o, s = 0;
								continue;
							}
						} else if (2 === i.length || 1 === i.length) {
							i = "", n = 0, a = o, s = 0;
							continue;
						}
					}
					t && (i.length > 0 ? i += "/.." : i = "..", n = 2);
				} else i.length > 0 ? i += "/" + e.slice(a + 1, o) : i = e.slice(a + 1, o), n = o - a - 1;
				a = o, s = 0;
			} else 46 === r && -1 !== s ? ++s : s = -1;
		}
		return i;
	}
	h(t, "e"), h(r, "r");
	var i = {
		resolve: h(function() {
			for (var e, i, n = "", a = !1, s = arguments.length - 1; s >= -1 && !a; s--) s >= 0 ? e = arguments[s] : (void 0 === i && (i = process.cwd()), e = i), t(e), 0 !== e.length && (n = e + "/" + n, a = 47 === e.charCodeAt(0));
			return n = r(n, !a), a ? n.length > 0 ? "/" + n : "/" : n.length > 0 ? n : ".";
		}, "resolve"),
		normalize: h(function(e) {
			if (t(e), 0 === e.length) return ".";
			var i = 47 === e.charCodeAt(0), n = 47 === e.charCodeAt(e.length - 1);
			return 0 !== (e = r(e, !i)).length || i || (e = "."), e.length > 0 && n && (e += "/"), i ? "/" + e : e;
		}, "normalize"),
		isAbsolute: h(function(e) {
			return t(e), e.length > 0 && 47 === e.charCodeAt(0);
		}, "isAbsolute"),
		join: h(function() {
			if (0 == arguments.length) return ".";
			for (var e, r = 0; r < arguments.length; ++r) {
				var n = arguments[r];
				t(n), n.length > 0 && (void 0 === e ? e = n : e += "/" + n);
			}
			return void 0 === e ? "." : i.normalize(e);
		}, "join"),
		relative: h(function(e, r) {
			if (t(e), t(r), e === r || (e = i.resolve(e)) === (r = i.resolve(r))) return "";
			for (var n = 1; n < e.length && 47 === e.charCodeAt(n); ++n);
			for (var a = e.length, s = a - n, o = 1; o < r.length && 47 === r.charCodeAt(o); ++o);
			for (var l = r.length - o, h = s < l ? s : l, u = -1, d = 0; d <= h; ++d) {
				if (d === h) {
					if (l > h) {
						if (47 === r.charCodeAt(o + d)) return r.slice(o + d + 1);
						if (0 === d) return r.slice(o + d);
					} else s > h && (47 === e.charCodeAt(n + d) ? u = d : 0 === d && (u = 0));
					break;
				}
				var p = e.charCodeAt(n + d);
				if (p !== r.charCodeAt(o + d)) break;
				47 === p && (u = d);
			}
			var f = "";
			for (d = n + u + 1; d <= a; ++d) d !== a && 47 !== e.charCodeAt(d) || (0 === f.length ? f += ".." : f += "/..");
			return f.length > 0 ? f + r.slice(o + u) : (o += u, 47 === r.charCodeAt(o) && ++o, r.slice(o));
		}, "relative"),
		_makeLong: h(function(e) {
			return e;
		}, "_makeLong"),
		dirname: h(function(e) {
			if (t(e), 0 === e.length) return ".";
			for (var r = e.charCodeAt(0), i = 47 === r, n = -1, a = !0, s = e.length - 1; s >= 1; --s) if (47 === (r = e.charCodeAt(s))) {
				if (!a) {
					n = s;
					break;
				}
			} else a = !1;
			return -1 === n ? i ? "/" : "." : i && 1 === n ? "//" : e.slice(0, n);
		}, "dirname"),
		basename: h(function(e, r) {
			if (void 0 !== r && "string" != typeof r) throw TypeError("\"ext\" argument must be a string");
			t(e);
			var i, n = 0, a = -1, s = !0;
			if (void 0 !== r && r.length > 0 && r.length <= e.length) {
				if (r.length === e.length && r === e) return "";
				var o = r.length - 1, l = -1;
				for (i = e.length - 1; i >= 0; --i) {
					var h = e.charCodeAt(i);
					if (47 === h) {
						if (!s) {
							n = i + 1;
							break;
						}
					} else -1 === l && (s = !1, l = i + 1), o >= 0 && (h === r.charCodeAt(o) ? -1 == --o && (a = i) : (o = -1, a = l));
				}
				return n === a ? a = l : -1 === a && (a = e.length), e.slice(n, a);
			}
			for (i = e.length - 1; i >= 0; --i) if (47 === e.charCodeAt(i)) {
				if (!s) {
					n = i + 1;
					break;
				}
			} else -1 === a && (s = !1, a = i + 1);
			return -1 === a ? "" : e.slice(n, a);
		}, "basename"),
		extname: h(function(e) {
			t(e);
			for (var r = -1, i = 0, n = -1, a = !0, s = 0, o = e.length - 1; o >= 0; --o) {
				var l = e.charCodeAt(o);
				if (47 !== l) -1 === n && (a = !1, n = o + 1), 46 === l ? -1 === r ? r = o : 1 !== s && (s = 1) : -1 !== r && (s = -1);
				else if (!a) {
					i = o + 1;
					break;
				}
			}
			return -1 === r || -1 === n || 0 === s || 1 === s && r === n - 1 && r === i + 1 ? "" : e.slice(r, n);
		}, "extname"),
		format: h(function(e) {
			var t, r;
			if (null === e || "object" != typeof e) throw TypeError("The \"pathObject\" argument must be of type Object. Received type " + typeof e);
			return t = e.dir || e.root, r = e.base || (e.name || "") + (e.ext || ""), t ? t === e.root ? t + r : t + "/" + r : r;
		}, "format"),
		parse: h(function(e) {
			t(e);
			var r = {
				root: "",
				dir: "",
				base: "",
				ext: "",
				name: ""
			};
			if (0 === e.length) return r;
			var i, n = e.charCodeAt(0), a = 47 === n;
			a ? (r.root = "/", i = 1) : i = 0;
			for (var s = -1, o = 0, l = -1, h = !0, u = e.length - 1, d = 0; u >= i; --u) if (47 !== (n = e.charCodeAt(u))) -1 === l && (h = !1, l = u + 1), 46 === n ? -1 === s ? s = u : 1 !== d && (d = 1) : -1 !== s && (d = -1);
			else if (!h) {
				o = u + 1;
				break;
			}
			return -1 === s || -1 === l || 0 === d || 1 === d && s === l - 1 && s === o + 1 ? -1 !== l && (r.base = r.name = 0 === o && a ? e.slice(1, l) : e.slice(o, l)) : (0 === o && a ? (r.name = e.slice(1, s), r.base = e.slice(1, l)) : (r.name = e.slice(o, s), r.base = e.slice(o, l)), r.ext = e.slice(s, l)), o > 0 ? r.dir = e.slice(0, o - 1) : a && (r.dir = "/"), r;
		}, "parse"),
		sep: "/",
		delimiter: ":",
		win32: null,
		posix: null
	};
	i.posix = i, e.exports = i;
} }, vT = {};
function v_(e) {
	var t = vT[e];
	if (void 0 !== t) return t.exports;
	var r = vT[e] = { exports: {} };
	return vk[e](r, r.exports, v_), r.exports;
}
h(v_, "r"), v_.d = (e, t) => {
	for (var r in t) v_.o(t, r) && !v_.o(e, r) && Object.defineProperty(e, r, {
		enumerable: !0,
		get: t[r]
	});
}, v_.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), v_.r = (e) => {
	"u" > typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 });
};
var vE = {};
(() => {
	let e;
	v_.r(vE), v_.d(vE, {
		URI: h(() => s, "URI"),
		Utils: h(() => b, "Utils")
	}), "object" == typeof process ? e = "win32" === process.platform : "object" == typeof navigator && (e = navigator.userAgent.indexOf("Windows") >= 0);
	let t = /^\w[\w\d+.-]*$/, r = /^\//, i = /^\/\//;
	function n(e, n) {
		if (!e.scheme && n) throw Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${e.authority}", path: "${e.path}", query: "${e.query}", fragment: "${e.fragment}"}`);
		if (e.scheme && !t.test(e.scheme)) throw Error("[UriError]: Scheme contains illegal characters.");
		if (e.path) {
			if (e.authority) {
				if (!r.test(e.path)) throw Error("[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character");
			} else if (i.test(e.path)) throw Error("[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")");
		}
	}
	h(n, "s");
	let a = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
	class s {
		static {
			h(this, "f");
		}
		static isUri(e) {
			return e instanceof s || !!e && "string" == typeof e.authority && "string" == typeof e.fragment && "string" == typeof e.path && "string" == typeof e.query && "string" == typeof e.scheme && "string" == typeof e.fsPath && "function" == typeof e.with && "function" == typeof e.toString;
		}
		scheme;
		authority;
		path;
		query;
		fragment;
		constructor(e, t, r, i, a, s = !1) {
			"object" == typeof e ? (this.scheme = e.scheme || "", this.authority = e.authority || "", this.path = e.path || "", this.query = e.query || "", this.fragment = e.fragment || "") : (this.scheme = e || s ? e : "file", this.authority = t || "", this.path = function(e, t) {
				switch (e) {
					case "https":
					case "http":
					case "file": t ? "/" !== t[0] && (t = "/" + t) : t = "/";
				}
				return t;
			}(this.scheme, r || ""), this.query = i || "", this.fragment = a || "", n(this, s));
		}
		get fsPath() {
			return f(this, !1);
		}
		with(e) {
			if (!e) return this;
			let { scheme: t, authority: r, path: i, query: n, fragment: a } = e;
			return void 0 === t ? t = this.scheme : null === t && (t = ""), void 0 === r ? r = this.authority : null === r && (r = ""), void 0 === i ? i = this.path : null === i && (i = ""), void 0 === n ? n = this.query : null === n && (n = ""), void 0 === a ? a = this.fragment : null === a && (a = ""), t === this.scheme && r === this.authority && i === this.path && n === this.query && a === this.fragment ? this : new l(t, r, i, n, a);
		}
		static parse(e, t = !1) {
			let r = a.exec(e);
			return r ? new l(r[2] || "", v(r[4] || ""), v(r[5] || ""), v(r[7] || ""), v(r[9] || ""), t) : new l("", "", "", "", "");
		}
		static file(t) {
			let r = "";
			if (e && (t = t.replace(/\\/g, "/")), "/" === t[0] && "/" === t[1]) {
				let e = t.indexOf("/", 2);
				-1 === e ? (r = t.substring(2), t = "/") : (r = t.substring(2, e), t = t.substring(e) || "/");
			}
			return new l("file", r, t, "", "");
		}
		static from(e) {
			let t = new l(e.scheme, e.authority, e.path, e.query, e.fragment);
			return n(t, !0), t;
		}
		toString(e = !1) {
			return g(this, e);
		}
		toJSON() {
			return this;
		}
		static revive(e) {
			if (e) {
				if (e instanceof s) return e;
				{
					let t = new l(e);
					return t._formatted = e.external, t._fsPath = e._sep === o ? e.fsPath : null, t;
				}
			}
			return e;
		}
	}
	let o = e ? 1 : void 0;
	class l extends s {
		static {
			h(this, "l");
		}
		_formatted = null;
		_fsPath = null;
		get fsPath() {
			return this._fsPath || (this._fsPath = f(this, !1)), this._fsPath;
		}
		toString(e = !1) {
			return e ? g(this, !0) : (this._formatted || (this._formatted = g(this, !1)), this._formatted);
		}
		toJSON() {
			let e = { $mid: 1 };
			return this._fsPath && (e.fsPath = this._fsPath, e._sep = o), this._formatted && (e.external = this._formatted), this.path && (e.path = this.path), this.scheme && (e.scheme = this.scheme), this.authority && (e.authority = this.authority), this.query && (e.query = this.query), this.fragment && (e.fragment = this.fragment), e;
		}
	}
	let u = {
		58: "%3A",
		47: "%2F",
		63: "%3F",
		35: "%23",
		91: "%5B",
		93: "%5D",
		64: "%40",
		33: "%21",
		36: "%24",
		38: "%26",
		39: "%27",
		40: "%28",
		41: "%29",
		42: "%2A",
		43: "%2B",
		44: "%2C",
		59: "%3B",
		61: "%3D",
		32: "%20"
	};
	function d(e, t, r) {
		let i, n = -1;
		for (let a = 0; a < e.length; a++) {
			let s = e.charCodeAt(a);
			if (s >= 97 && s <= 122 || s >= 65 && s <= 90 || s >= 48 && s <= 57 || 45 === s || 46 === s || 95 === s || 126 === s || t && 47 === s || r && 91 === s || r && 93 === s || r && 58 === s) -1 !== n && (i += encodeURIComponent(e.substring(n, a)), n = -1), void 0 !== i && (i += e.charAt(a));
			else {
				void 0 === i && (i = e.substr(0, a));
				let t = u[s];
				void 0 !== t ? (-1 !== n && (i += encodeURIComponent(e.substring(n, a)), n = -1), i += t) : -1 === n && (n = a);
			}
		}
		return -1 !== n && (i += encodeURIComponent(e.substring(n))), void 0 !== i ? i : e;
	}
	function p(e) {
		let t;
		for (let r = 0; r < e.length; r++) {
			let i = e.charCodeAt(r);
			35 === i || 63 === i ? (void 0 === t && (t = e.substr(0, r)), t += u[i]) : void 0 !== t && (t += e[r]);
		}
		return void 0 !== t ? t : e;
	}
	function f(t, r) {
		let i;
		return i = t.authority && t.path.length > 1 && "file" === t.scheme ? `//${t.authority}${t.path}` : 47 === t.path.charCodeAt(0) && (t.path.charCodeAt(1) >= 65 && 90 >= t.path.charCodeAt(1) || t.path.charCodeAt(1) >= 97 && 122 >= t.path.charCodeAt(1)) && 58 === t.path.charCodeAt(2) ? r ? t.path.substr(1) : t.path[1].toLowerCase() + t.path.substr(2) : t.path, e && (i = i.replace(/\//g, "\\")), i;
	}
	function g(e, t) {
		let r = t ? p : d, i = "", { scheme: n, authority: a, path: s, query: o, fragment: l } = e;
		if (n && (i += n, i += ":"), (a || "file" === n) && (i += "/", i += "/"), a) {
			let e = a.indexOf("@");
			if (-1 !== e) {
				let t = a.substr(0, e);
				a = a.substr(e + 1), -1 === (e = t.lastIndexOf(":")) ? i += r(t, !1, !1) : (i += r(t.substr(0, e), !1, !1), i += ":", i += r(t.substr(e + 1), !1, !0)), i += "@";
			}
			-1 === (e = (a = a.toLowerCase()).lastIndexOf(":")) ? i += r(a, !1, !0) : (i += r(a.substr(0, e), !1, !0), i += a.substr(e));
		}
		if (s) {
			if (s.length >= 3 && 47 === s.charCodeAt(0) && 58 === s.charCodeAt(2)) {
				let e = s.charCodeAt(1);
				e >= 65 && e <= 90 && (s = `/${String.fromCharCode(e + 32)}:${s.substr(3)}`);
			} else if (s.length >= 2 && 58 === s.charCodeAt(1)) {
				let e = s.charCodeAt(0);
				e >= 65 && e <= 90 && (s = `${String.fromCharCode(e + 32)}:${s.substr(2)}`);
			}
			i += r(s, !0, !1);
		}
		return o && (i += "?", i += r(o, !1, !1)), l && (i += "#", i += t ? l : d(l, !1, !1)), i;
	}
	function m(e) {
		try {
			return decodeURIComponent(e);
		} catch {
			return e.length > 3 ? e.substr(0, 3) + m(e.substr(3)) : e;
		}
	}
	h(d, "d"), h(p, "p"), h(f, "m"), h(g, "y"), h(m, "v");
	let y = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
	function v(e) {
		return e.match(y) ? e.replace(y, (e) => m(e)) : e;
	}
	h(v, "C");
	var x, b, w = v_(470);
	let k = w.posix || w;
	(x = b || (b = {})).joinPath = function(e, ...t) {
		return e.with({ path: k.join(e.path, ...t) });
	}, x.resolvePath = function(e, ...t) {
		let r = e.path, i = !1;
		"/" !== r[0] && (r = "/" + r, i = !0);
		let n = k.resolve(r, ...t);
		return i && "/" === n[0] && !e.authority && (n = n.substring(1)), e.with({ path: n });
	}, x.dirname = function(e) {
		if (0 === e.path.length || "/" === e.path) return e;
		let t = k.dirname(e.path);
		return 1 === t.length && 46 === t.charCodeAt(0) && (t = ""), e.with({ path: t });
	}, x.basename = function(e) {
		return k.basename(e.path);
	}, x.extname = function(e) {
		return k.extname(e.path);
	};
})();
var { URI: vC, Utils: vS } = vE;
(function(e) {
	function t(e, t) {
		return e?.toString() === t?.toString();
	}
	function r(e, t) {
		let r = "string" == typeof e ? e : e.path, i = "string" == typeof t ? t : t.path, n = r.split("/").filter((e) => e.length > 0), a = i.split("/").filter((e) => e.length > 0), s = 0;
		for (; s < n.length && n[s] === a[s]; s++);
		return "../".repeat(n.length - s) + a.slice(s).join("/");
	}
	function i(e) {
		return vC.parse(e.toString()).toString();
	}
	e.basename = vS.basename, e.dirname = vS.dirname, e.extname = vS.extname, e.joinPath = vS.joinPath, e.resolvePath = vS.resolvePath, h(t, "equals"), e.equals = t, h(r, "relative"), e.relative = r, h(i, "normalize"), e.normalize = i;
})(x0 || (x0 = {})), (xQ = x1 || (x1 = {}))[xQ.Changed = 0] = "Changed", xQ[xQ.Parsed = 1] = "Parsed", xQ[xQ.IndexedContent = 2] = "IndexedContent", xQ[xQ.ComputedScopes = 3] = "ComputedScopes", xQ[xQ.Linked = 4] = "Linked", xQ[xQ.IndexedReferences = 5] = "IndexedReferences", xQ[xQ.Validated = 6] = "Validated";
var vA = class {
	static {
		h(this, "DefaultLangiumDocumentFactory");
	}
	constructor(e) {
		this.serviceRegistry = e.ServiceRegistry, this.textDocuments = e.workspace.TextDocuments, this.fileSystemProvider = e.workspace.FileSystemProvider;
	}
	async fromUri(e, t = va.CancellationToken.None) {
		let r = await this.fileSystemProvider.readFile(e);
		return this.createAsync(e, r, t);
	}
	fromTextDocument(e, t, r) {
		return t = t ?? vC.parse(e.uri), va.CancellationToken.is(r) ? this.createAsync(t, e, r) : this.create(t, e, r);
	}
	fromString(e, t, r) {
		return va.CancellationToken.is(r) ? this.createAsync(t, e, r) : this.create(t, e, r);
	}
	fromModel(e, t) {
		return this.create(t, { $model: e });
	}
	create(e, t, r) {
		if ("string" == typeof t) {
			let i = this.parse(e, t, r);
			return this.createLangiumDocument(i, e, void 0, t);
		}
		if ("$model" in t) {
			let r = {
				value: t.$model,
				parserErrors: [],
				lexerErrors: []
			};
			return this.createLangiumDocument(r, e);
		}
		{
			let i = this.parse(e, t.getText(), r);
			return this.createLangiumDocument(i, e, t);
		}
	}
	async createAsync(e, t, r) {
		if ("string" == typeof t) {
			let i = await this.parseAsync(e, t, r);
			return this.createLangiumDocument(i, e, void 0, t);
		}
		{
			let i = await this.parseAsync(e, t.getText(), r);
			return this.createLangiumDocument(i, e, t);
		}
	}
	createLangiumDocument(e, t, r, i) {
		let n;
		if (r) n = {
			parseResult: e,
			uri: t,
			state: x1.Parsed,
			references: [],
			textDocument: r
		};
		else {
			let r = this.createTextDocumentGetter(t, i);
			n = {
				parseResult: e,
				uri: t,
				state: x1.Parsed,
				references: [],
				get textDocument() {
					return r();
				}
			};
		}
		return e.value.$document = n, n;
	}
	async update(e, t) {
		var r, i;
		let n = null == (r = e.parseResult.value.$cstNode) ? void 0 : r.root.fullText, a = null == (i = this.textDocuments) ? void 0 : i.get(e.uri.toString()), s = a ? a.getText() : await this.fileSystemProvider.readFile(e.uri);
		if (a) Object.defineProperty(e, "textDocument", { value: a });
		else {
			let t = this.createTextDocumentGetter(e.uri, s);
			Object.defineProperty(e, "textDocument", { get: t });
		}
		return n !== s && (e.parseResult = await this.parseAsync(e.uri, s, t), e.parseResult.value.$document = e), e.state = x1.Parsed, e;
	}
	parse(e, t, r) {
		return this.serviceRegistry.getServices(e).parser.LangiumParser.parse(t, r);
	}
	parseAsync(e, t, r) {
		return this.serviceRegistry.getServices(e).parser.AsyncParser.parse(t, r);
	}
	createTextDocumentGetter(e, t) {
		let r = this.serviceRegistry, i;
		return () => i ?? (i = vf.create(e.toString(), r.getServices(e).LanguageMetaData.languageId, 0, t ?? ""));
	}
}, vL = class {
	static {
		h(this, "DefaultLangiumDocuments");
	}
	constructor(e) {
		this.documentMap = /* @__PURE__ */ new Map(), this.langiumDocumentFactory = e.workspace.LangiumDocumentFactory, this.serviceRegistry = e.ServiceRegistry;
	}
	get all() {
		return aW(this.documentMap.values());
	}
	addDocument(e) {
		let t = e.uri.toString();
		if (this.documentMap.has(t)) throw Error(`A document with the URI '${t}' is already present.`);
		this.documentMap.set(t, e);
	}
	getDocument(e) {
		let t = e.toString();
		return this.documentMap.get(t);
	}
	async getOrCreateDocument(e, t) {
		let r = this.getDocument(e);
		return r || (r = await this.langiumDocumentFactory.fromUri(e, t), this.addDocument(r), r);
	}
	createDocument(e, t, r) {
		if (r) return this.langiumDocumentFactory.fromString(t, e, r).then((e) => (this.addDocument(e), e));
		{
			let r = this.langiumDocumentFactory.fromString(t, e);
			return this.addDocument(r), r;
		}
	}
	hasDocument(e) {
		return this.documentMap.has(e.toString());
	}
	invalidateDocument(e) {
		let t = e.toString(), r = this.documentMap.get(t);
		return r && (this.serviceRegistry.getServices(e).references.Linker.unlink(r), r.state = x1.Changed, r.precomputedScopes = void 0, r.diagnostics = void 0), r;
	}
	deleteDocument(e) {
		let t = e.toString(), r = this.documentMap.get(t);
		return r && (r.state = x1.Changed, this.documentMap.delete(t)), r;
	}
}, vR = Symbol("ref_resolving"), vN = class {
	static {
		h(this, "DefaultLinker");
	}
	constructor(e) {
		this.reflection = e.shared.AstReflection, this.langiumDocuments = () => e.shared.workspace.LangiumDocuments, this.scopeProvider = e.references.ScopeProvider, this.astNodeLocator = e.workspace.AstNodeLocator;
	}
	async link(e, t = va.CancellationToken.None) {
		for (let r of oK(e.parseResult.value)) await vp(t), oQ(r).forEach((t) => this.doLink(t, e));
	}
	doLink(e, t) {
		var r;
		let i = e.reference;
		if (void 0 === i._ref) {
			i._ref = vR;
			try {
				let t = this.getCandidate(e);
				aO(t) ? i._ref = t : (i._nodeDescription = t, this.langiumDocuments().hasDocument(t.documentUri)) ? i._ref = this.loadAstNode(t) ?? this.createLinkingError(e, t) : i._ref = void 0;
			} catch (n) {
				console.error(`An error occurred while resolving reference to '${i.$refText}':`, n);
				let t = null != (r = n.message) ? r : String(n);
				i._ref = Object.assign(Object.assign({}, e), { message: `An error occurred while resolving reference to '${i.$refText}': ${t}` });
			}
			t.references.push(i);
		}
	}
	unlink(e) {
		for (let t of e.references) delete t._ref, delete t._nodeDescription;
		e.references = [];
	}
	getCandidate(e) {
		return this.scopeProvider.getScope(e).getElement(e.reference.$refText) ?? this.createLinkingError(e);
	}
	buildReference(e, t, r, i) {
		let n = this, a = {
			$refNode: r,
			$refText: i,
			get ref() {
				var s;
				if (aI(this._ref)) return this._ref;
				if (aD(this._nodeDescription)) this._ref = n.loadAstNode(this._nodeDescription) ?? n.createLinkingError({
					reference: a,
					container: e,
					property: t
				}, this._nodeDescription);
				else if (void 0 === this._ref) {
					this._ref = vR;
					let r = oV(e).$document, i = n.getLinkedNode({
						reference: a,
						container: e,
						property: t
					});
					if (i.error && r && r.state < x1.ComputedScopes) return this._ref = void 0;
					this._ref = null != (s = i.node) ? s : i.error, this._nodeDescription = i.descr, r?.references.push(this);
				} else if (this._ref === vR) throw Error(`Cyclic reference resolution detected: ${n.astNodeLocator.getAstNodePath(e)}/${t} (symbol '${i}')`);
				return aI(this._ref) ? this._ref : void 0;
			},
			get $nodeDescription() {
				return this._nodeDescription;
			},
			get error() {
				return aO(this._ref) ? this._ref : void 0;
			}
		};
		return a;
	}
	getLinkedNode(e) {
		var t;
		try {
			let t = this.getCandidate(e);
			if (aO(t)) return { error: t };
			let r = this.loadAstNode(t);
			return r ? {
				node: r,
				descr: t
			} : {
				descr: t,
				error: this.createLinkingError(e, t)
			};
		} catch (i) {
			console.error(`An error occurred while resolving reference to '${e.reference.$refText}':`, i);
			let r = null != (t = i.message) ? t : String(i);
			return { error: Object.assign(Object.assign({}, e), { message: `An error occurred while resolving reference to '${e.reference.$refText}': ${r}` }) };
		}
	}
	loadAstNode(e) {
		if (e.node) return e.node;
		let t = this.langiumDocuments().getDocument(e.documentUri);
		if (t) return this.astNodeLocator.getAstNode(t.parseResult.value, e.path);
	}
	createLinkingError(e, t) {
		let r = oV(e.container).$document;
		r && r.state < x1.ComputedScopes && console.warn(`Attempted reference resolution before document reached ComputedScopes state (${r.uri}).`);
		let i = this.reflection.getReferenceType(e);
		return Object.assign(Object.assign({}, e), {
			message: `Could not resolve reference to ${i} named '${e.reference.$refText}'.`,
			targetDescription: t
		});
	}
};
function vI(e) {
	return "string" == typeof e.name;
}
h(vI, "isNamed");
var vM = class {
	static {
		h(this, "DefaultNameProvider");
	}
	getName(e) {
		if (vI(e)) return e.name;
	}
	getNameNode(e) {
		return lC(e.$cstNode, "name");
	}
}, vD = class {
	static {
		h(this, "DefaultReferences");
	}
	constructor(e) {
		this.nameProvider = e.references.NameProvider, this.index = e.shared.workspace.IndexManager, this.nodeLocator = e.workspace.AstNodeLocator;
	}
	findDeclaration(e) {
		if (e) {
			let t = lN(e), r = e.astNode;
			if (t && r) {
				let i = r[t.feature];
				if (aM(i)) return i.ref;
				if (Array.isArray(i)) {
					for (let t of i) if (aM(t) && t.$refNode && t.$refNode.offset <= e.offset && t.$refNode.end >= e.end) return t.ref;
				}
			}
			if (r) {
				let t = this.nameProvider.getNameNode(r);
				if (t && (t === e || aZ(e, t))) return r;
			}
		}
	}
	findDeclarationNode(e) {
		let t = this.findDeclaration(e);
		if (t?.$cstNode) return this.nameProvider.getNameNode(t) ?? t.$cstNode;
	}
	findReferences(e, t) {
		let r = [];
		if (t.includeDeclaration) {
			let t = this.getReferenceToSelf(e);
			t && r.push(t);
		}
		let i = this.index.findAllReferences(e, this.nodeLocator.getAstNodePath(e));
		return t.documentUri && (i = i.filter((e) => x0.equals(e.sourceUri, t.documentUri))), r.push(...i), aW(r);
	}
	getReferenceToSelf(e) {
		let t = this.nameProvider.getNameNode(e);
		if (t) {
			let r = oY(e), i = this.nodeLocator.getAstNodePath(e);
			return {
				sourceUri: r.uri,
				sourcePath: i,
				targetUri: r.uri,
				targetPath: i,
				segment: aJ(t),
				local: !0
			};
		}
	}
}, vO = class {
	static {
		h(this, "MultiMap");
	}
	constructor(e) {
		if (this.map = /* @__PURE__ */ new Map(), e) for (let [t, r] of e) this.add(t, r);
	}
	get size() {
		return aV.sum(aW(this.map.values()).map((e) => e.length));
	}
	clear() {
		this.map.clear();
	}
	delete(e, t) {
		if (void 0 === t) return this.map.delete(e);
		{
			let r = this.map.get(e);
			if (r) {
				let i = r.indexOf(t);
				if (i >= 0) return 1 === r.length ? this.map.delete(e) : r.splice(i, 1), !0;
			}
			return !1;
		}
	}
	get(e) {
		var t;
		return null != (t = this.map.get(e)) ? t : [];
	}
	has(e, t) {
		if (void 0 === t) return this.map.has(e);
		{
			let r = this.map.get(e);
			return !!r && r.indexOf(t) >= 0;
		}
	}
	add(e, t) {
		return this.map.has(e) ? this.map.get(e).push(t) : this.map.set(e, [t]), this;
	}
	addAll(e, t) {
		return this.map.has(e) ? this.map.get(e).push(...t) : this.map.set(e, Array.from(t)), this;
	}
	forEach(e) {
		this.map.forEach((t, r) => t.forEach((t) => e(t, r, this)));
	}
	[Symbol.iterator]() {
		return this.entries().iterator();
	}
	entries() {
		return aW(this.map.entries()).flatMap(([e, t]) => t.map((t) => [e, t]));
	}
	keys() {
		return aW(this.map.keys());
	}
	values() {
		return aW(this.map.values()).flat();
	}
	entriesGroupedByKey() {
		return aW(this.map.entries());
	}
}, v$ = class {
	static {
		h(this, "BiMap");
	}
	get size() {
		return this.map.size;
	}
	constructor(e) {
		if (this.map = /* @__PURE__ */ new Map(), this.inverse = /* @__PURE__ */ new Map(), e) for (let [t, r] of e) this.set(t, r);
	}
	clear() {
		this.map.clear(), this.inverse.clear();
	}
	set(e, t) {
		return this.map.set(e, t), this.inverse.set(t, e), this;
	}
	get(e) {
		return this.map.get(e);
	}
	getKey(e) {
		return this.inverse.get(e);
	}
	delete(e) {
		let t = this.map.get(e);
		return void 0 !== t && (this.map.delete(e), this.inverse.delete(t), !0);
	}
}, vP = class {
	static {
		h(this, "DefaultScopeComputation");
	}
	constructor(e) {
		this.nameProvider = e.references.NameProvider, this.descriptions = e.workspace.AstNodeDescriptionProvider;
	}
	async computeExports(e, t = va.CancellationToken.None) {
		return this.computeExportsForNode(e.parseResult.value, e, void 0, t);
	}
	async computeExportsForNode(e, t, r = oH, i = va.CancellationToken.None) {
		let n = [];
		for (let a of (this.exportNode(e, n, t), r(e))) await vp(i), this.exportNode(a, n, t);
		return n;
	}
	exportNode(e, t, r) {
		let i = this.nameProvider.getName(e);
		i && t.push(this.descriptions.createDescription(e, i, r));
	}
	async computeLocalScopes(e, t = va.CancellationToken.None) {
		let r = e.parseResult.value, i = new vO();
		for (let n of oX(r)) await vp(t), this.processNode(n, e, i);
		return i;
	}
	processNode(e, t, r) {
		let i = e.$container;
		if (i) {
			let n = this.nameProvider.getName(e);
			n && r.add(i, this.descriptions.createDescription(e, n, t));
		}
	}
}, vB = class {
	static {
		h(this, "StreamScope");
	}
	constructor(e, t, r) {
		var i;
		this.elements = e, this.outerScope = t, this.caseInsensitive = null != (i = r?.caseInsensitive) && i;
	}
	getAllElements() {
		return this.outerScope ? this.elements.concat(this.outerScope.getAllElements()) : this.elements;
	}
	getElement(e) {
		return (this.caseInsensitive ? this.elements.find((t) => t.name.toLowerCase() === e.toLowerCase()) : this.elements.find((t) => t.name === e)) || (this.outerScope ? this.outerScope.getElement(e) : void 0);
	}
}, vF = class {
	static {
		h(this, "MapScope");
	}
	constructor(e, t, r) {
		var i;
		for (let t of (this.elements = /* @__PURE__ */ new Map(), this.caseInsensitive = null != (i = r?.caseInsensitive) && i, e)) {
			let e = this.caseInsensitive ? t.name.toLowerCase() : t.name;
			this.elements.set(e, t);
		}
		this.outerScope = t;
	}
	getElement(e) {
		let t = this.caseInsensitive ? e.toLowerCase() : e;
		return this.elements.get(t) || (this.outerScope ? this.outerScope.getElement(e) : void 0);
	}
	getAllElements() {
		let e = aW(this.elements.values());
		return this.outerScope && (e = e.concat(this.outerScope.getAllElements())), e;
	}
}, vz = {
	getElement() {},
	getAllElements: () => aq
}, vU = class {
	static {
		h(this, "DisposableCache");
	}
	constructor() {
		this.toDispose = [], this.isDisposed = !1;
	}
	onDispose(e) {
		this.toDispose.push(e);
	}
	dispose() {
		this.throwIfDisposed(), this.clear(), this.isDisposed = !0, this.toDispose.forEach((e) => e.dispose());
	}
	throwIfDisposed() {
		if (this.isDisposed) throw Error("This cache has already been disposed");
	}
}, vG = class extends vU {
	static {
		h(this, "SimpleCache");
	}
	constructor() {
		super(...arguments), this.cache = /* @__PURE__ */ new Map();
	}
	has(e) {
		return this.throwIfDisposed(), this.cache.has(e);
	}
	set(e, t) {
		this.throwIfDisposed(), this.cache.set(e, t);
	}
	get(e, t) {
		if (this.throwIfDisposed(), this.cache.has(e)) return this.cache.get(e);
		if (t) {
			let r = t();
			return this.cache.set(e, r), r;
		}
	}
	delete(e) {
		return this.throwIfDisposed(), this.cache.delete(e);
	}
	clear() {
		this.throwIfDisposed(), this.cache.clear();
	}
}, vq = class extends vU {
	static {
		h(this, "ContextCache");
	}
	constructor(e) {
		super(), this.cache = /* @__PURE__ */ new Map(), this.converter = e ?? ((e) => e);
	}
	has(e, t) {
		return this.throwIfDisposed(), this.cacheForContext(e).has(t);
	}
	set(e, t, r) {
		this.throwIfDisposed(), this.cacheForContext(e).set(t, r);
	}
	get(e, t, r) {
		this.throwIfDisposed();
		let i = this.cacheForContext(e);
		if (i.has(t)) return i.get(t);
		if (r) {
			let e = r();
			return i.set(t, e), e;
		}
	}
	delete(e, t) {
		return this.throwIfDisposed(), this.cacheForContext(e).delete(t);
	}
	clear(e) {
		if (this.throwIfDisposed(), e) {
			let t = this.converter(e);
			this.cache.delete(t);
		} else this.cache.clear();
	}
	cacheForContext(e) {
		let t = this.converter(e), r = this.cache.get(t);
		return r || (r = /* @__PURE__ */ new Map(), this.cache.set(t, r)), r;
	}
}, vj = class extends vq {
	static {
		h(this, "DocumentCache");
	}
	constructor(e, t) {
		super((e) => e.toString()), t ? (this.toDispose.push(e.workspace.DocumentBuilder.onDocumentPhase(t, (e) => {
			this.clear(e.uri.toString());
		})), this.toDispose.push(e.workspace.DocumentBuilder.onUpdate((e, t) => {
			for (let e of t) this.clear(e);
		}))) : this.toDispose.push(e.workspace.DocumentBuilder.onUpdate((e, t) => {
			for (let r of e.concat(t)) this.clear(r);
		}));
	}
}, vW = class extends vG {
	static {
		h(this, "WorkspaceCache");
	}
	constructor(e, t) {
		super(), t ? (this.toDispose.push(e.workspace.DocumentBuilder.onBuildPhase(t, () => {
			this.clear();
		})), this.toDispose.push(e.workspace.DocumentBuilder.onUpdate((e, t) => {
			t.length > 0 && this.clear();
		}))) : this.toDispose.push(e.workspace.DocumentBuilder.onUpdate(() => {
			this.clear();
		}));
	}
}, vY = class {
	static {
		h(this, "DefaultScopeProvider");
	}
	constructor(e) {
		this.reflection = e.shared.AstReflection, this.nameProvider = e.references.NameProvider, this.descriptions = e.workspace.AstNodeDescriptionProvider, this.indexManager = e.shared.workspace.IndexManager, this.globalScopeCache = new vW(e.shared);
	}
	getScope(e) {
		let t = [], r = this.reflection.getReferenceType(e), i = oY(e.container).precomputedScopes;
		if (i) {
			let n = e.container;
			do {
				let e = i.get(n);
				e.length > 0 && t.push(aW(e).filter((e) => this.reflection.isSubtype(e.type, r))), n = n.$container;
			} while (n);
		}
		let n = this.getGlobalScope(r, e);
		for (let e = t.length - 1; e >= 0; e--) n = this.createScope(t[e], n);
		return n;
	}
	createScope(e, t, r) {
		return new vB(aW(e), t, r);
	}
	createScopeForNodes(e, t, r) {
		return new vB(aW(e).map((e) => {
			let t = this.nameProvider.getName(e);
			if (t) return this.descriptions.createDescription(e, t);
		}).nonNullable(), t, r);
	}
	getGlobalScope(e, t) {
		return this.globalScopeCache.get(e, () => new vF(this.indexManager.allElements(e)));
	}
};
function vV(e) {
	return "string" == typeof e.$comment;
}
function vH(e) {
	return "object" == typeof e && !!e && ("$ref" in e || "$error" in e);
}
h(vV, "isAstNodeWithComment"), h(vH, "isIntermediateReference");
var vX = class {
	static {
		h(this, "DefaultJsonSerializer");
	}
	constructor(e) {
		this.ignoreProperties = new Set([
			"$container",
			"$containerProperty",
			"$containerIndex",
			"$document",
			"$cstNode"
		]), this.langiumDocuments = e.shared.workspace.LangiumDocuments, this.astNodeLocator = e.workspace.AstNodeLocator, this.nameProvider = e.references.NameProvider, this.commentProvider = e.documentation.CommentProvider;
	}
	serialize(e, t) {
		let r = t ?? {}, i = t?.replacer, n = h((e, t) => this.replacer(e, t, r), "defaultReplacer"), a = i ? (e, t) => i(e, t, n) : n;
		try {
			return this.currentDocument = oY(e), JSON.stringify(e, a, t?.space);
		} finally {
			this.currentDocument = void 0;
		}
	}
	deserialize(e, t) {
		let r = JSON.parse(e);
		return this.linkNode(r, r, t ?? {}), r;
	}
	replacer(e, t, { refText: r, sourceText: i, textRegions: n, comments: a, uriConverter: s }) {
		var o, l, h, u;
		if (!this.ignoreProperties.has(e)) if (aM(t)) {
			let e = t.ref, i = r ? t.$refText : void 0;
			if (!e) return {
				$error: null != (l = null == (o = t.error) ? void 0 : o.message) ? l : "Could not resolve reference",
				$refText: i
			};
			{
				let r = oY(e), n = "";
				this.currentDocument && this.currentDocument !== r && (n = s ? s(r.uri, t) : r.uri.toString());
				let a = this.astNodeLocator.getAstNodePath(e);
				return {
					$ref: `${n}#${a}`,
					$refText: i
				};
			}
		} else {
			let r;
			if (!aI(t)) return t;
			if (n && (r = this.addAstNodeRegionWithAssignmentsTo(Object.assign({}, t)), (!e || t.$document) && r?.$textRegion && (r.$textRegion.documentURI = null == (h = this.currentDocument) ? void 0 : h.uri.toString())), i && !e && (r ?? (r = Object.assign({}, t)), r.$sourceText = null == (u = t.$cstNode) ? void 0 : u.text), a) {
				r ?? (r = Object.assign({}, t));
				let e = this.commentProvider.getComment(t);
				e && (r.$comment = e.replace(/\r/g, ""));
			}
			return r ?? t;
		}
	}
	addAstNodeRegionWithAssignmentsTo(e) {
		let t = h((e) => ({
			offset: e.offset,
			end: e.end,
			length: e.length,
			range: e.range
		}), "createDocumentSegment");
		if (e.$cstNode) {
			let r = (e.$textRegion = t(e.$cstNode)).assignments = {};
			return Object.keys(e).filter((e) => !e.startsWith("$")).forEach((i) => {
				let n = lE(e.$cstNode, i).map(t);
				0 !== n.length && (r[i] = n);
			}), e;
		}
	}
	linkNode(e, t, r, i, n, a) {
		for (let [i, n] of Object.entries(e)) if (Array.isArray(n)) for (let a = 0; a < n.length; a++) {
			let s = n[a];
			vH(s) ? n[a] = this.reviveReference(e, i, t, s, r) : aI(s) && this.linkNode(s, t, r, e, i, a);
		}
		else vH(n) ? e[i] = this.reviveReference(e, i, t, n, r) : aI(n) && this.linkNode(n, t, r, e, i);
		e.$container = i, e.$containerProperty = n, e.$containerIndex = a;
	}
	reviveReference(e, t, r, i, n) {
		let a = i.$refText, s = i.$error;
		if (i.$ref) {
			let e = this.getRefNode(r, i.$ref, n.uriConverter);
			if (aI(e)) return a || (a = this.nameProvider.getName(e)), {
				$refText: a ?? "",
				ref: e
			};
			s = e;
		}
		if (s) {
			let r = { $refText: a ?? "" };
			return r.error = {
				container: e,
				property: t,
				message: s,
				reference: r
			}, r;
		}
	}
	getRefNode(e, t, r) {
		try {
			let i = t.indexOf("#");
			if (0 === i) return this.astNodeLocator.getAstNode(e, t.substring(1)) || "Could not resolve path: " + t;
			if (i < 0) {
				let e = r ? r(t) : vC.parse(t), i = this.langiumDocuments.getDocument(e);
				return i ? i.parseResult.value : "Could not find document for URI: " + t;
			}
			let n = r ? r(t.substring(0, i)) : vC.parse(t.substring(0, i)), a = this.langiumDocuments.getDocument(n);
			if (!a) return "Could not find document for URI: " + t;
			if (i === t.length - 1) return a.parseResult.value;
			return this.astNodeLocator.getAstNode(a.parseResult.value, t.substring(i + 1)) || "Could not resolve URI: " + t;
		} catch (e) {
			return String(e);
		}
	}
}, vK = class {
	static {
		h(this, "DefaultServiceRegistry");
	}
	get map() {
		return this.fileExtensionMap;
	}
	constructor(e) {
		this.languageIdMap = /* @__PURE__ */ new Map(), this.fileExtensionMap = /* @__PURE__ */ new Map(), this.textDocuments = e?.workspace.TextDocuments;
	}
	register(e) {
		let t = e.LanguageMetaData;
		for (let r of t.fileExtensions) this.fileExtensionMap.has(r) && console.warn(`The file extension ${r} is used by multiple languages. It is now assigned to '${t.languageId}'.`), this.fileExtensionMap.set(r, e);
		this.languageIdMap.set(t.languageId, e), 1 === this.languageIdMap.size ? this.singleton = e : this.singleton = void 0;
	}
	getServices(e) {
		var t, r;
		if (void 0 !== this.singleton) return this.singleton;
		if (0 === this.languageIdMap.size) throw Error("The service registry is empty. Use `register` to register the services of a language.");
		let i = null == (r = null == (t = this.textDocuments) ? void 0 : t.get(e)) ? void 0 : r.languageId;
		if (void 0 !== i) {
			let e = this.languageIdMap.get(i);
			if (e) return e;
		}
		let n = x0.extname(e), a = this.fileExtensionMap.get(n);
		if (!a) throw i ? Error(`The service registry contains no services for the extension '${n}' for language '${i}'.`) : Error(`The service registry contains no services for the extension '${n}'.`);
		return a;
	}
	hasServices(e) {
		try {
			return this.getServices(e), !0;
		} catch {
			return !1;
		}
	}
	get all() {
		return Array.from(this.languageIdMap.values());
	}
};
function vZ(e) {
	return { code: e };
}
h(vZ, "diagnosticData"), (x2 || (x2 = {})).all = [
	"fast",
	"slow",
	"built-in"
];
var vQ = class {
	static {
		h(this, "ValidationRegistry");
	}
	constructor(e) {
		this.entries = new vO(), this.entriesBefore = [], this.entriesAfter = [], this.reflection = e.shared.AstReflection;
	}
	register(e, t = this, r = "fast") {
		if ("built-in" === r) throw Error("The 'built-in' category is reserved for lexer, parser, and linker errors.");
		for (let [i, n] of Object.entries(e)) if (Array.isArray(n)) for (let e of n) {
			let n = {
				check: this.wrapValidationException(e, t),
				category: r
			};
			this.addEntry(i, n);
		}
		else if ("function" == typeof n) {
			let e = {
				check: this.wrapValidationException(n, t),
				category: r
			};
			this.addEntry(i, e);
		} else so(n);
	}
	wrapValidationException(e, t) {
		return async (r, i, n) => {
			await this.handleException(() => e.call(t, r, i, n), "An error occurred during validation", i, r);
		};
	}
	async handleException(e, t, r, i) {
		try {
			await e();
		} catch (e) {
			if (vd(e)) throw e;
			console.error(`${t}:`, e), e instanceof Error && e.stack && console.error(e.stack), r("error", `${t}: ${e instanceof Error ? e.message : String(e)}`, { node: i });
		}
	}
	addEntry(e, t) {
		if ("AstNode" === e) return void this.entries.add("AstNode", t);
		for (let r of this.reflection.getAllSubTypes(e)) this.entries.add(r, t);
	}
	getChecks(e, t) {
		let r = aW(this.entries.get(e)).concat(this.entries.get("AstNode"));
		return t && (r = r.filter((e) => t.includes(e.category))), r.map((e) => e.check);
	}
	registerBeforeDocument(e, t = this) {
		this.entriesBefore.push(this.wrapPreparationException(e, "An error occurred during set-up of the validation", t));
	}
	registerAfterDocument(e, t = this) {
		this.entriesAfter.push(this.wrapPreparationException(e, "An error occurred during tear-down of the validation", t));
	}
	wrapPreparationException(e, t, r) {
		return async (i, n, a, s) => {
			await this.handleException(() => e.call(r, i, n, a, s), t, n, i);
		};
	}
	get checksBefore() {
		return this.entriesBefore;
	}
	get checksAfter() {
		return this.entriesAfter;
	}
}, vJ = class {
	static {
		h(this, "DefaultDocumentValidator");
	}
	constructor(e) {
		this.validationRegistry = e.validation.ValidationRegistry, this.metadata = e.LanguageMetaData;
	}
	async validateDocument(e, t = {}, r = va.CancellationToken.None) {
		let i = e.parseResult, n = [];
		if (await vp(r), (!t.categories || t.categories.includes("built-in")) && (this.processLexingErrors(i, n, t), t.stopAfterLexingErrors && n.some((e) => {
			var t;
			return (null == (t = e.data) ? void 0 : t.code) === x4.LexingError;
		}) || (this.processParsingErrors(i, n, t), t.stopAfterParsingErrors && n.some((e) => {
			var t;
			return (null == (t = e.data) ? void 0 : t.code) === x4.ParsingError;
		})) || (this.processLinkingErrors(e, n, t), t.stopAfterLinkingErrors && n.some((e) => {
			var t;
			return (null == (t = e.data) ? void 0 : t.code) === x4.LinkingError;
		})))) return n;
		try {
			n.push(...await this.validateAst(i.value, t, r));
		} catch (e) {
			if (vd(e)) throw e;
			console.error("An error occurred during validation:", e);
		}
		return await vp(r), n;
	}
	processLexingErrors(e, t, r) {
		var i, n, a;
		for (let r of [...e.lexerErrors, ...null != (n = null == (i = e.lexerReport) ? void 0 : i.diagnostics) ? n : []]) {
			let e = null != (a = r.severity) ? a : "error", i = {
				severity: v1(e),
				range: {
					start: {
						line: r.line - 1,
						character: r.column - 1
					},
					end: {
						line: r.line - 1,
						character: r.column + r.length - 1
					}
				},
				message: r.message,
				data: v2(e),
				source: this.getSource()
			};
			t.push(i);
		}
	}
	processParsingErrors(e, t, r) {
		for (let r of e.parserErrors) {
			let e;
			if (isNaN(r.token.startOffset)) {
				if ("previousToken" in r) {
					let t = r.previousToken;
					if (isNaN(t.startOffset)) {
						let t = {
							line: 0,
							character: 0
						};
						e = {
							start: t,
							end: t
						};
					} else {
						let r = {
							line: t.endLine - 1,
							character: t.endColumn
						};
						e = {
							start: r,
							end: r
						};
					}
				}
			} else e = aQ(r.token);
			if (e) {
				let i = {
					severity: v1("error"),
					range: e,
					message: r.message,
					data: vZ(x4.ParsingError),
					source: this.getSource()
				};
				t.push(i);
			}
		}
	}
	processLinkingErrors(e, t, r) {
		for (let r of e.references) {
			let e = r.error;
			if (e) {
				let r = {
					node: e.container,
					property: e.property,
					index: e.index,
					data: {
						code: x4.LinkingError,
						containerType: e.container.$type,
						property: e.property,
						refText: e.reference.$refText
					}
				};
				t.push(this.toDiagnostic("error", e.message, r));
			}
		}
	}
	async validateAst(e, t, r = va.CancellationToken.None) {
		let i = [], n = h((e, t, r) => {
			i.push(this.toDiagnostic(e, t, r));
		}, "acceptor");
		return await this.validateAstBefore(e, t, n, r), await this.validateAstNodes(e, t, n, r), await this.validateAstAfter(e, t, n, r), i;
	}
	async validateAstBefore(e, t, r, i = va.CancellationToken.None) {
		var n;
		for (let a of this.validationRegistry.checksBefore) await vp(i), await a(e, r, null != (n = t.categories) ? n : [], i);
	}
	async validateAstNodes(e, t, r, i = va.CancellationToken.None) {
		await Promise.all(oK(e).map(async (e) => {
			for (let n of (await vp(i), this.validationRegistry.getChecks(e.$type, t.categories))) await n(e, r, i);
		}));
	}
	async validateAstAfter(e, t, r, i = va.CancellationToken.None) {
		var n;
		for (let a of this.validationRegistry.checksAfter) await vp(i), await a(e, r, null != (n = t.categories) ? n : [], i);
	}
	toDiagnostic(e, t, r) {
		return {
			message: t,
			range: v0(r),
			severity: v1(e),
			code: r.code,
			codeDescription: r.codeDescription,
			tags: r.tags,
			relatedInformation: r.relatedInformation,
			data: r.data,
			source: this.getSource()
		};
	}
	getSource() {
		return this.metadata.languageId;
	}
};
function v0(e) {
	let t;
	return e.range ? e.range : ("string" == typeof e.property ? t = lC(e.node.$cstNode, e.property, e.index) : "string" == typeof e.keyword && (t = lL(e.node.$cstNode, e.keyword, e.index)), t ?? (t = e.node.$cstNode), t ? t.range : {
		start: {
			line: 0,
			character: 0
		},
		end: {
			line: 0,
			character: 0
		}
	});
}
function v1(e) {
	switch (e) {
		case "error": return 1;
		case "warning": return 2;
		case "info": return 3;
		case "hint": return 4;
		default: throw Error("Invalid diagnostic severity: " + e);
	}
}
function v2(e) {
	switch (e) {
		case "error": return vZ(x4.LexingError);
		case "warning": return vZ(x4.LexingWarning);
		case "info": return vZ(x4.LexingInfo);
		case "hint": return vZ(x4.LexingHint);
		default: throw Error("Invalid diagnostic severity: " + e);
	}
}
h(v0, "getDiagnosticRange"), h(v1, "toDiagnosticSeverity"), h(v2, "toDiagnosticData"), (xJ = x4 || (x4 = {})).LexingError = "lexing-error", xJ.LexingWarning = "lexing-warning", xJ.LexingInfo = "lexing-info", xJ.LexingHint = "lexing-hint", xJ.ParsingError = "parsing-error", xJ.LinkingError = "linking-error";
var v4 = class {
	static {
		h(this, "DefaultAstNodeDescriptionProvider");
	}
	constructor(e) {
		this.astNodeLocator = e.workspace.AstNodeLocator, this.nameProvider = e.references.NameProvider;
	}
	createDescription(e, t, r) {
		let i = r ?? oY(e);
		t ?? (t = this.nameProvider.getName(e));
		let n = this.astNodeLocator.getAstNodePath(e);
		if (!t) throw Error(`Node at path ${n} has no name.`);
		let a, s = h(() => {
			var t;
			return a ?? (a = aJ(null != (t = this.nameProvider.getNameNode(e)) ? t : e.$cstNode));
		}, "nameSegmentGetter");
		return {
			node: e,
			name: t,
			get nameSegment() {
				return s();
			},
			selectionSegment: aJ(e.$cstNode),
			type: e.$type,
			documentUri: i.uri,
			path: n
		};
	}
}, v5 = class {
	static {
		h(this, "DefaultReferenceDescriptionProvider");
	}
	constructor(e) {
		this.nodeLocator = e.workspace.AstNodeLocator;
	}
	async createDescriptions(e, t = va.CancellationToken.None) {
		let r = [];
		for (let i of oK(e.parseResult.value)) await vp(t), oQ(i).filter((e) => !aO(e)).forEach((e) => {
			let t = this.createDescription(e);
			t && r.push(t);
		});
		return r;
	}
	createDescription(e) {
		let t = e.reference.$nodeDescription, r = e.reference.$refNode;
		if (!t || !r) return;
		let i = oY(e.container).uri;
		return {
			sourceUri: i,
			sourcePath: this.nodeLocator.getAstNodePath(e.container),
			targetUri: t.documentUri,
			targetPath: t.path,
			segment: aJ(r),
			local: x0.equals(t.documentUri, i)
		};
	}
}, v3 = class {
	static {
		h(this, "DefaultAstNodeLocator");
	}
	constructor() {
		this.segmentSeparator = "/", this.indexSeparator = "@";
	}
	getAstNodePath(e) {
		if (e.$container) {
			let t = this.getAstNodePath(e.$container), r = this.getPathSegment(e);
			return t + this.segmentSeparator + r;
		}
		return "";
	}
	getPathSegment({ $containerProperty: e, $containerIndex: t }) {
		if (!e) throw Error("Missing '$containerProperty' in AST node.");
		return void 0 !== t ? e + this.indexSeparator + t : e;
	}
	getAstNode(e, t) {
		return t.split(this.segmentSeparator).reduce((e, t) => {
			if (!e || 0 === t.length) return e;
			let r = t.indexOf(this.indexSeparator);
			if (r > 0) {
				let i = t.substring(0, r), n = parseInt(t.substring(r + 1));
				return e[i]?.[n];
			}
			return e[t];
		}, e);
	}
}, v6 = {};
f(v6, g(aA(), 1));
var v7 = class {
	static {
		h(this, "DefaultConfigurationProvider");
	}
	constructor(e) {
		this._ready = new vg(), this.settings = {}, this.workspaceConfig = !1, this.onConfigurationSectionUpdateEmitter = new v6.Emitter(), this.serviceRegistry = e.ServiceRegistry;
	}
	get ready() {
		return this._ready.promise;
	}
	initialize(e) {
		var t, r;
		this.workspaceConfig = null != (r = null == (t = e.capabilities.workspace) ? void 0 : t.configuration) && r;
	}
	async initialized(e) {
		if (this.workspaceConfig) {
			if (e.register) {
				let t = this.serviceRegistry.all;
				e.register({ section: t.map((e) => this.toSectionName(e.LanguageMetaData.languageId)) });
			}
			if (e.fetchConfiguration) {
				let t = this.serviceRegistry.all.map((e) => ({ section: this.toSectionName(e.LanguageMetaData.languageId) })), r = await e.fetchConfiguration(t);
				t.forEach((e, t) => {
					this.updateSectionConfiguration(e.section, r[t]);
				});
			}
		}
		this._ready.resolve();
	}
	updateConfiguration(e) {
		e.settings && Object.keys(e.settings).forEach((t) => {
			let r = e.settings[t];
			this.updateSectionConfiguration(t, r), this.onConfigurationSectionUpdateEmitter.fire({
				section: t,
				configuration: r
			});
		});
	}
	updateSectionConfiguration(e, t) {
		this.settings[e] = t;
	}
	async getConfiguration(e, t) {
		await this.ready;
		let r = this.toSectionName(e);
		if (this.settings[r]) return this.settings[r][t];
	}
	toSectionName(e) {
		return `${e}`;
	}
	get onConfigurationSectionUpdate() {
		return this.onConfigurationSectionUpdateEmitter.event;
	}
}, v8 = x5 || (x5 = {});
function v9(e) {
	return { dispose: h(async () => await e(), "dispose") };
}
h(v9, "create"), v8.create = v9;
var xe = class {
	static {
		h(this, "DefaultDocumentBuilder");
	}
	constructor(e) {
		this.updateBuildOptions = { validation: { categories: ["built-in", "fast"] } }, this.updateListeners = [], this.buildPhaseListeners = new vO(), this.documentPhaseListeners = new vO(), this.buildState = /* @__PURE__ */ new Map(), this.documentBuildWaiters = /* @__PURE__ */ new Map(), this.currentState = x1.Changed, this.langiumDocuments = e.workspace.LangiumDocuments, this.langiumDocumentFactory = e.workspace.LangiumDocumentFactory, this.textDocuments = e.workspace.TextDocuments, this.indexManager = e.workspace.IndexManager, this.serviceRegistry = e.ServiceRegistry;
	}
	async build(e, t = {}, r = va.CancellationToken.None) {
		var i, n;
		for (let r of e) {
			let e = r.uri.toString();
			if (r.state === x1.Validated) {
				if ("boolean" == typeof t.validation && t.validation) r.state = x1.IndexedReferences, r.diagnostics = void 0, this.buildState.delete(e);
				else if ("object" == typeof t.validation) {
					let a = this.buildState.get(e), s = null == (i = a?.result) ? void 0 : i.validationChecks;
					if (s) {
						let i = (null != (n = t.validation.categories) ? n : x2.all).filter((e) => !s.includes(e));
						i.length > 0 && (this.buildState.set(e, {
							completed: !1,
							options: { validation: Object.assign(Object.assign({}, t.validation), { categories: i }) },
							result: a.result
						}), r.state = x1.IndexedReferences);
					}
				}
			} else this.buildState.delete(e);
		}
		this.currentState = x1.Changed, await this.emitUpdate(e.map((e) => e.uri), []), await this.buildDocuments(e, t, r);
	}
	async update(e, t, r = va.CancellationToken.None) {
		for (let e of (this.currentState = x1.Changed, t)) this.langiumDocuments.deleteDocument(e), this.buildState.delete(e.toString()), this.indexManager.remove(e);
		for (let t of e) {
			if (!this.langiumDocuments.invalidateDocument(t)) {
				let e = this.langiumDocumentFactory.fromModel({ $type: "INVALID" }, t);
				e.state = x1.Changed, this.langiumDocuments.addDocument(e);
			}
			this.buildState.delete(t.toString());
		}
		let i = aW(e).concat(t).map((e) => e.toString()).toSet();
		this.langiumDocuments.all.filter((e) => !i.has(e.uri.toString()) && this.shouldRelink(e, i)).forEach((e) => {
			this.serviceRegistry.getServices(e.uri).references.Linker.unlink(e), e.state = Math.min(e.state, x1.ComputedScopes), e.diagnostics = void 0;
		}), await this.emitUpdate(e, t), await vp(r);
		let n = this.sortDocuments(this.langiumDocuments.all.filter((e) => {
			var t;
			return e.state < x1.Linked || !(null != (t = this.buildState.get(e.uri.toString())) && t.completed);
		}).toArray());
		await this.buildDocuments(n, this.updateBuildOptions, r);
	}
	async emitUpdate(e, t) {
		await Promise.all(this.updateListeners.map((r) => r(e, t)));
	}
	sortDocuments(e) {
		let t = 0, r = e.length - 1;
		for (; t < r;) {
			for (; t < e.length && this.hasTextDocument(e[t]);) t++;
			for (; r >= 0 && !this.hasTextDocument(e[r]);) r--;
			t < r && ([e[t], e[r]] = [e[r], e[t]]);
		}
		return e;
	}
	hasTextDocument(e) {
		var t;
		return !!(null != (t = this.textDocuments) && t.get(e.uri));
	}
	shouldRelink(e, t) {
		return !!e.references.some((e) => void 0 !== e.error) || this.indexManager.isAffected(e, t);
	}
	onUpdate(e) {
		return this.updateListeners.push(e), x5.create(() => {
			let t = this.updateListeners.indexOf(e);
			t >= 0 && this.updateListeners.splice(t, 1);
		});
	}
	async buildDocuments(e, t, r) {
		this.prepareBuild(e, t), await this.runCancelable(e, x1.Parsed, r, (e) => this.langiumDocumentFactory.update(e, r)), await this.runCancelable(e, x1.IndexedContent, r, (e) => this.indexManager.updateContent(e, r)), await this.runCancelable(e, x1.ComputedScopes, r, async (e) => {
			e.precomputedScopes = await this.serviceRegistry.getServices(e.uri).references.ScopeComputation.computeLocalScopes(e, r);
		}), await this.runCancelable(e, x1.Linked, r, (e) => this.serviceRegistry.getServices(e.uri).references.Linker.link(e, r)), await this.runCancelable(e, x1.IndexedReferences, r, (e) => this.indexManager.updateReferences(e, r));
		let i = e.filter((e) => this.shouldValidate(e));
		for (let t of (await this.runCancelable(i, x1.Validated, r, (e) => this.validate(e, r)), e)) {
			let e = this.buildState.get(t.uri.toString());
			e && (e.completed = !0);
		}
	}
	prepareBuild(e, t) {
		for (let r of e) {
			let e = r.uri.toString(), i = this.buildState.get(e);
			(!i || i.completed) && this.buildState.set(e, {
				completed: !1,
				options: t,
				result: i?.result
			});
		}
	}
	async runCancelable(e, t, r, i) {
		for (let n of e.filter((e) => e.state < t)) await vp(r), await i(n), n.state = t, await this.notifyDocumentPhase(n, t, r);
		let n = e.filter((e) => e.state === t);
		await this.notifyBuildPhase(n, t, r), this.currentState = t;
	}
	onBuildPhase(e, t) {
		return this.buildPhaseListeners.add(e, t), x5.create(() => {
			this.buildPhaseListeners.delete(e, t);
		});
	}
	onDocumentPhase(e, t) {
		return this.documentPhaseListeners.add(e, t), x5.create(() => {
			this.documentPhaseListeners.delete(e, t);
		});
	}
	waitUntil(e, t, r) {
		let i;
		if (t && "path" in t ? i = t : r = t, r ?? (r = va.CancellationToken.None), i) {
			let t = this.langiumDocuments.getDocument(i);
			if (t && t.state > e) return Promise.resolve(i);
		}
		return this.currentState >= e ? Promise.resolve(void 0) : r.isCancellationRequested ? Promise.reject(vu) : new Promise((t, n) => {
			let a = this.onBuildPhase(e, () => {
				(a.dispose(), s.dispose(), i) ? t(this.langiumDocuments.getDocument(i)?.uri) : t(void 0);
			}), s = r.onCancellationRequested(() => {
				a.dispose(), s.dispose(), n(vu);
			});
		});
	}
	async notifyDocumentPhase(e, t, r) {
		for (let i of this.documentPhaseListeners.get(t).slice()) try {
			await i(e, r);
		} catch (e) {
			if (!vd(e)) throw e;
		}
	}
	async notifyBuildPhase(e, t, r) {
		if (0 !== e.length) for (let i of this.buildPhaseListeners.get(t).slice()) await vp(r), await i(e, r);
	}
	shouldValidate(e) {
		return !!this.getBuildOptions(e).validation;
	}
	async validate(e, t) {
		var r;
		let i = this.serviceRegistry.getServices(e.uri).validation.DocumentValidator, n = this.getBuildOptions(e).validation, a = "object" == typeof n ? n : void 0, s = await i.validateDocument(e, a, t);
		e.diagnostics ? e.diagnostics.push(...s) : e.diagnostics = s;
		let o = this.buildState.get(e.uri.toString());
		if (o) {
			o.result ??= {};
			let e = null != (r = a?.categories) ? r : x2.all;
			o.result.validationChecks ? o.result.validationChecks.push(...e) : o.result.validationChecks = [...e];
		}
	}
	getBuildOptions(e) {
		var t, r;
		return null != (r = null == (t = this.buildState.get(e.uri.toString())) ? void 0 : t.options) ? r : {};
	}
}, xt = class {
	static {
		h(this, "DefaultIndexManager");
	}
	constructor(e) {
		this.symbolIndex = /* @__PURE__ */ new Map(), this.symbolByTypeIndex = new vq(), this.referenceIndex = /* @__PURE__ */ new Map(), this.documents = e.workspace.LangiumDocuments, this.serviceRegistry = e.ServiceRegistry, this.astReflection = e.AstReflection;
	}
	findAllReferences(e, t) {
		let r = oY(e).uri, i = [];
		return this.referenceIndex.forEach((e) => {
			e.forEach((e) => {
				x0.equals(e.targetUri, r) && e.targetPath === t && i.push(e);
			});
		}), aW(i);
	}
	allElements(e, t) {
		let r = aW(this.symbolIndex.keys());
		return t && (r = r.filter((e) => !t || t.has(e))), r.map((t) => this.getFileDescriptions(t, e)).flat();
	}
	getFileDescriptions(e, t) {
		var r;
		return t ? this.symbolByTypeIndex.get(e, t, () => {
			var r;
			return (null != (r = this.symbolIndex.get(e)) ? r : []).filter((e) => this.astReflection.isSubtype(e.type, t));
		}) : null != (r = this.symbolIndex.get(e)) ? r : [];
	}
	remove(e) {
		let t = e.toString();
		this.symbolIndex.delete(t), this.symbolByTypeIndex.clear(t), this.referenceIndex.delete(t);
	}
	async updateContent(e, t = va.CancellationToken.None) {
		let r = await this.serviceRegistry.getServices(e.uri).references.ScopeComputation.computeExports(e, t), i = e.uri.toString();
		this.symbolIndex.set(i, r), this.symbolByTypeIndex.clear(i);
	}
	async updateReferences(e, t = va.CancellationToken.None) {
		let r = await this.serviceRegistry.getServices(e.uri).workspace.ReferenceDescriptionProvider.createDescriptions(e, t);
		this.referenceIndex.set(e.uri.toString(), r);
	}
	isAffected(e, t) {
		let r = this.referenceIndex.get(e.uri.toString());
		return !!r && r.some((e) => !e.local && t.has(e.targetUri.toString()));
	}
}, xr = class {
	static {
		h(this, "DefaultWorkspaceManager");
	}
	constructor(e) {
		this.initialBuildOptions = {}, this._ready = new vg(), this.serviceRegistry = e.ServiceRegistry, this.langiumDocuments = e.workspace.LangiumDocuments, this.documentBuilder = e.workspace.DocumentBuilder, this.fileSystemProvider = e.workspace.FileSystemProvider, this.mutex = e.workspace.WorkspaceLock;
	}
	get ready() {
		return this._ready.promise;
	}
	get workspaceFolders() {
		return this.folders;
	}
	initialize(e) {
		var t;
		this.folders = null != (t = e.workspaceFolders) ? t : void 0;
	}
	initialized(e) {
		return this.mutex.write((e) => {
			var t;
			return this.initializeWorkspace(null != (t = this.folders) ? t : [], e);
		});
	}
	async initializeWorkspace(e, t = va.CancellationToken.None) {
		let r = await this.performStartup(e);
		await vp(t), await this.documentBuilder.build(r, this.initialBuildOptions, t);
	}
	async performStartup(e) {
		let t = this.serviceRegistry.all.flatMap((e) => e.LanguageMetaData.fileExtensions), r = [], i = h((e) => {
			r.push(e), this.langiumDocuments.hasDocument(e.uri) || this.langiumDocuments.addDocument(e);
		}, "collector");
		return await this.loadAdditionalDocuments(e, i), await Promise.all(e.map((e) => [e, this.getRootFolder(e)]).map(async (e) => this.traverseFolder(...e, t, i))), this._ready.resolve(), r;
	}
	loadAdditionalDocuments(e, t) {
		return Promise.resolve();
	}
	getRootFolder(e) {
		return vC.parse(e.uri);
	}
	async traverseFolder(e, t, r, i) {
		let n = await this.fileSystemProvider.readDirectory(t);
		await Promise.all(n.map(async (t) => {
			this.includeEntry(e, t, r) && (t.isDirectory ? await this.traverseFolder(e, t.uri, r, i) : t.isFile && i(await this.langiumDocuments.getOrCreateDocument(t.uri)));
		}));
	}
	includeEntry(e, t, r) {
		let i = x0.basename(t.uri);
		if (i.startsWith(".")) return !1;
		if (t.isDirectory) return "node_modules" !== i && "out" !== i;
		if (t.isFile) {
			let e = x0.extname(t.uri);
			return r.includes(e);
		}
		return !1;
	}
}, xi = class {
	static {
		h(this, "DefaultLexerErrorMessageProvider");
	}
	buildUnexpectedCharactersMessage(e, t, r, i, n) {
		return hR.buildUnexpectedCharactersMessage(e, t, r, i, n);
	}
	buildUnableToPopLexerModeMessage(e) {
		return hR.buildUnableToPopLexerModeMessage(e);
	}
}, xn = { mode: "full" }, xa = class {
	static {
		h(this, "DefaultLexer");
	}
	constructor(e) {
		this.errorMessageProvider = e.parser.LexerErrorMessageProvider, this.tokenBuilder = e.parser.TokenBuilder;
		let t = this.tokenBuilder.buildTokens(e.Grammar, { caseInsensitive: e.LanguageMetaData.caseInsensitive });
		this.tokenTypes = this.toTokenTypeDictionary(t), this.chevrotainLexer = new hI(xl(t) ? Object.values(t) : t, {
			positionTracking: "full",
			skipValidations: "production" === e.LanguageMetaData.mode,
			errorMessageProvider: this.errorMessageProvider
		});
	}
	get definition() {
		return this.tokenTypes;
	}
	tokenize(e, t = xn) {
		var r, i, n;
		let a = this.chevrotainLexer.tokenize(e);
		return {
			tokens: a.tokens,
			errors: a.errors,
			hidden: null != (r = a.groups.hidden) ? r : [],
			report: null == (n = (i = this.tokenBuilder).flushLexingReport) ? void 0 : n.call(i, e)
		};
	}
	toTokenTypeDictionary(e) {
		if (xl(e)) return e;
		let t = xo(e) ? Object.values(e.modes).flat() : e, r = {};
		return t.forEach((e) => r[e.name] = e), r;
	}
};
function xs(e) {
	return Array.isArray(e) && (0 === e.length || "name" in e[0]);
}
function xo(e) {
	return e && "modes" in e && "defaultMode" in e;
}
function xl(e) {
	return !xs(e) && !xo(e);
}
function xc(e, t, r) {
	let i, n;
	return "string" == typeof e ? (n = t, i = r) : (n = e.range.start, i = t), n || (n = my.create(0, 0)), xb({
		index: 0,
		tokens: xf({
			lines: xu(e),
			position: n,
			options: xS(i)
		}),
		position: n
	});
}
function xh(e, t) {
	let r = xS(t), i = xu(e);
	if (0 === i.length) return !1;
	let n = i[0], a = i[i.length - 1], s = r.start, o = r.end;
	return !!s?.exec(n) && !!o?.exec(a);
}
function xu(e) {
	return ("string" == typeof e ? e : e.text).split(ll);
}
h(xs, "isTokenTypeArray"), h(xo, "isIMultiModeLexerDefinition"), h(xl, "isTokenTypeDictionary"), h(xc, "parseJSDoc"), h(xh, "isJSDoc"), h(xu, "getLines");
var xd = /\s*(@([\p{L}][\p{L}\p{N}]*)?)/uy, xp = /\{(@[\p{L}][\p{L}\p{N}]*)(\s*)([^\r\n}]+)?\}/gu;
function xf(e) {
	var t, r, i;
	let n = [], a = e.position.line, s = e.position.character;
	for (let o = 0; o < e.lines.length; o++) {
		let l = 0 === o, h = o === e.lines.length - 1, u = e.lines[o], d = 0;
		if (l && e.options.start) {
			let r = null == (t = e.options.start) ? void 0 : t.exec(u);
			r && (d = r.index + r[0].length);
		} else {
			let t = null == (r = e.options.line) ? void 0 : r.exec(u);
			t && (d = t.index + t[0].length);
		}
		if (h) {
			let t = null == (i = e.options.end) ? void 0 : i.exec(u);
			t && (u = u.substring(0, t.index));
		}
		if (xv(u = u.substring(0, xx(u)), d) >= u.length) {
			if (n.length > 0) {
				let e = my.create(a, s);
				n.push({
					type: "break",
					content: "",
					range: mv.create(e, e)
				});
			}
		} else {
			xd.lastIndex = d;
			let e = xd.exec(u);
			if (e) {
				let t = e[0], r = e[1], i = my.create(a, s + d), o = my.create(a, s + d + t.length);
				n.push({
					type: "tag",
					content: r,
					range: mv.create(i, o)
				}), d += t.length, d = xv(u, d);
			}
			if (d < u.length) {
				let e = u.substring(d), t = Array.from(e.matchAll(xp));
				n.push(...xg(t, e, a, s + d));
			}
		}
		a++, s = 0;
	}
	return n.length > 0 && "break" === n[n.length - 1].type ? n.slice(0, -1) : n;
}
function xg(e, t, r, i) {
	let n = [];
	if (0 === e.length) {
		let e = my.create(r, i), a = my.create(r, i + t.length);
		n.push({
			type: "text",
			content: t,
			range: mv.create(e, a)
		});
	} else {
		let a = 0;
		for (let s of e) {
			let e = s.index, o = t.substring(a, e);
			o.length > 0 && n.push({
				type: "text",
				content: t.substring(a, e),
				range: mv.create(my.create(r, a + i), my.create(r, e + i))
			});
			let l = o.length + 1, h = s[1];
			if (n.push({
				type: "inline-tag",
				content: h,
				range: mv.create(my.create(r, a + l + i), my.create(r, a + l + h.length + i))
			}), l += h.length, 4 === s.length) {
				l += s[2].length;
				let e = s[3];
				n.push({
					type: "text",
					content: e,
					range: mv.create(my.create(r, a + l + i), my.create(r, a + l + e.length + i))
				});
			} else n.push({
				type: "text",
				content: "",
				range: mv.create(my.create(r, a + l + i), my.create(r, a + l + i))
			});
			a = e + s[0].length;
		}
		let s = t.substring(a);
		s.length > 0 && n.push({
			type: "text",
			content: s,
			range: mv.create(my.create(r, a + i), my.create(r, a + i + s.length))
		});
	}
	return n;
}
h(xf, "tokenize"), h(xg, "buildInlineTokens");
var xm = /\S/, xy = /\s*$/;
function xv(e, t) {
	let r = e.substring(t).match(xm);
	return r ? t + r.index : e.length;
}
function xx(e) {
	let t = e.match(xy);
	if (t && "number" == typeof t.index) return t.index;
}
function xb(e) {
	var t, r, i, n;
	let a = my.create(e.position.line, e.position.character);
	if (0 === e.tokens.length) return new xL([], mv.create(a, a));
	let s = [];
	for (; e.index < e.tokens.length;) {
		let t = xw(e, s[s.length - 1]);
		t && s.push(t);
	}
	let o = null != (r = null == (t = s[0]) ? void 0 : t.range.start) ? r : a, l = null != (n = null == (i = s[s.length - 1]) ? void 0 : i.range.end) ? n : a;
	return new xL(s, mv.create(o, l));
}
function xw(e, t) {
	let r = e.tokens[e.index];
	return "tag" === r.type ? xE(e, !1) : "text" === r.type || "inline-tag" === r.type ? xT(e) : void (xk(r, t), e.index++);
}
function xk(e, t) {
	if (t) {
		let r = new xD("", e.range);
		"inlines" in t ? t.inlines.push(r) : t.content.inlines.push(r);
	}
}
function xT(e) {
	let t = e.tokens[e.index], r = t, i = t, n = [];
	for (; t && "break" !== t.type && "tag" !== t.type;) n.push(x_(e)), i = t, t = e.tokens[e.index];
	return new xM(n, mv.create(r.range.start, i.range.end));
}
function x_(e) {
	return "inline-tag" === e.tokens[e.index].type ? xE(e, !0) : xC(e);
}
function xE(e, t) {
	let r = e.tokens[e.index++], i = r.content.substring(1);
	if (e.tokens[e.index]?.type === "text") if (t) {
		let n = xC(e);
		return new xR(i, new xM([n], n.range), t, mv.create(r.range.start, n.range.end));
	} else {
		let n = xT(e);
		return new xR(i, n, t, mv.create(r.range.start, n.range.end));
	}
	{
		let e = r.range;
		return new xR(i, new xM([], e), t, e);
	}
}
function xC(e) {
	let t = e.tokens[e.index++];
	return new xD(t.content, t.range);
}
function xS(e) {
	if (!e) return xS({
		start: "/**",
		end: "*/",
		line: "*"
	});
	let { start: t, end: r, line: i } = e;
	return {
		start: xA(t, !0),
		end: xA(r, !1),
		line: xA(i, !0)
	};
}
function xA(e, t) {
	if ("string" != typeof e && "object" != typeof e) return e;
	{
		let r = "string" == typeof e ? lg(e) : e.source;
		return t ? RegExp(`^\\s*${r}`) : RegExp(`\\s*${r}\\s*$`);
	}
}
h(xv, "skipWhitespace"), h(xx, "lastCharacter"), h(xb, "parseJSDocComment"), h(xw, "parseJSDocElement"), h(xk, "appendEmptyLine"), h(xT, "parseJSDocText"), h(x_, "parseJSDocInline"), h(xE, "parseJSDocTag"), h(xC, "parseJSDocLine"), h(xS, "normalizeOptions"), h(xA, "normalizeOption");
var xL = class {
	static {
		h(this, "JSDocCommentImpl");
	}
	constructor(e, t) {
		this.elements = e, this.range = t;
	}
	getTag(e) {
		return this.getAllTags().find((t) => t.name === e);
	}
	getTags(e) {
		return this.getAllTags().filter((t) => t.name === e);
	}
	getAllTags() {
		return this.elements.filter((e) => "name" in e);
	}
	toString() {
		let e = "";
		for (let t of this.elements) if (0 === e.length) e = t.toString();
		else {
			let r = t.toString();
			e += xO(e) + r;
		}
		return e.trim();
	}
	toMarkdown(e) {
		let t = "";
		for (let r of this.elements) if (0 === t.length) t = r.toMarkdown(e);
		else {
			let i = r.toMarkdown(e);
			t += xO(t) + i;
		}
		return t.trim();
	}
}, xR = class {
	static {
		h(this, "JSDocTagImpl");
	}
	constructor(e, t, r, i) {
		this.name = e, this.content = t, this.inline = r, this.range = i;
	}
	toString() {
		let e = `@${this.name}`, t = this.content.toString();
		return 1 === this.content.inlines.length ? e = `${e} ${t}` : this.content.inlines.length > 1 && (e = `${e}
${t}`), this.inline ? `{${e}}` : e;
	}
	toMarkdown(e) {
		var t, r;
		return null != (r = null == (t = e?.renderTag) ? void 0 : t.call(e, this)) ? r : this.toMarkdownDefault(e);
	}
	toMarkdownDefault(e) {
		let t = this.content.toMarkdown(e);
		if (this.inline) {
			let r = xN(this.name, t, e ?? {});
			if ("string" == typeof r) return r;
		}
		let r = "";
		e?.tag === "italic" || e?.tag === void 0 ? r = "*" : e?.tag === "bold" ? r = "**" : e?.tag === "bold-italic" && (r = "***");
		let i = `${r}@${this.name}${r}`;
		return 1 === this.content.inlines.length ? i = `${i} \u2014 ${t}` : this.content.inlines.length > 1 && (i = `${i}
${t}`), this.inline ? `{${i}}` : i;
	}
};
function xN(e, t, r) {
	var i, n;
	if ("linkplain" === e || "linkcode" === e || "link" === e) {
		let a = t.indexOf(" "), s = t;
		if (a > 0) {
			let e = xv(t, a);
			s = t.substring(e), t = t.substring(0, a);
		}
		return ("linkcode" === e || "link" === e && "code" === r.link) && (s = `\`${s}\``), null != (n = null == (i = r.renderLink) ? void 0 : i.call(r, t, s)) ? n : xI(t, s);
	}
}
function xI(e, t) {
	try {
		return vC.parse(e, !0), `[${t}](${e})`;
	} catch {
		return e;
	}
}
h(xN, "renderInlineTag"), h(xI, "renderLinkDefault");
var xM = class {
	static {
		h(this, "JSDocTextImpl");
	}
	constructor(e, t) {
		this.inlines = e, this.range = t;
	}
	toString() {
		let e = "";
		for (let t = 0; t < this.inlines.length; t++) {
			let r = this.inlines[t], i = this.inlines[t + 1];
			e += r.toString(), i && i.range.start.line > r.range.start.line && (e += `
`);
		}
		return e;
	}
	toMarkdown(e) {
		let t = "";
		for (let r = 0; r < this.inlines.length; r++) {
			let i = this.inlines[r], n = this.inlines[r + 1];
			t += i.toMarkdown(e), n && n.range.start.line > i.range.start.line && (t += `
`);
		}
		return t;
	}
}, xD = class {
	static {
		h(this, "JSDocLineImpl");
	}
	constructor(e, t) {
		this.text = e, this.range = t;
	}
	toString() {
		return this.text;
	}
	toMarkdown() {
		return this.text;
	}
};
function xO(e) {
	return e.endsWith(`
`) ? `
` : `

`;
}
h(xO, "fillNewlines");
var x$ = class {
	static {
		h(this, "JSDocDocumentationProvider");
	}
	constructor(e) {
		this.indexManager = e.shared.workspace.IndexManager, this.commentProvider = e.documentation.CommentProvider;
	}
	getDocumentation(e) {
		let t = this.commentProvider.getComment(e);
		if (t && xh(t)) return xc(t).toMarkdown({
			renderLink: h((t, r) => this.documentationLinkRenderer(e, t, r), "renderLink"),
			renderTag: h((t) => this.documentationTagRenderer(e, t), "renderTag")
		});
	}
	documentationLinkRenderer(e, t, r) {
		var i;
		let n = null != (i = this.findNameInPrecomputedScopes(e, t)) ? i : this.findNameInGlobalScope(e, t);
		if (n && n.nameSegment) {
			let e = n.nameSegment.range.start.line + 1, t = n.nameSegment.range.start.character + 1;
			return `[${r}](${n.documentUri.with({ fragment: `L${e},${t}` }).toString()})`;
		}
	}
	documentationTagRenderer(e, t) {}
	findNameInPrecomputedScopes(e, t) {
		let r = oY(e).precomputedScopes;
		if (!r) return;
		let i = e;
		do {
			let e = r.get(i).find((e) => e.name === t);
			if (e) return e;
			i = i.$container;
		} while (i);
	}
	findNameInGlobalScope(e, t) {
		return this.indexManager.allElements().find((e) => e.name === t);
	}
}, xP = class {
	static {
		h(this, "DefaultCommentProvider");
	}
	constructor(e) {
		this.grammarConfig = () => e.parser.GrammarConfig;
	}
	getComment(e) {
		var t;
		return vV(e) ? e.$comment : null == (t = a5(e.$cstNode, this.grammarConfig().multilineCommentRules)) ? void 0 : t.text;
	}
}, xB = class {
	static {
		h(this, "DefaultAsyncParser");
	}
	constructor(e) {
		this.syncParser = e.parser.LangiumParser;
	}
	parse(e, t) {
		return Promise.resolve(this.syncParser.parse(e));
	}
}, xF = class {
	static {
		h(this, "AbstractThreadedAsyncParser");
	}
	constructor(e) {
		this.threadCount = 8, this.terminationDelay = 200, this.workerPool = [], this.queue = [], this.hydrator = e.serializer.Hydrator;
	}
	initializeWorkers() {
		for (; this.workerPool.length < this.threadCount;) {
			let e = this.createWorker();
			e.onReady(() => {
				if (this.queue.length > 0) {
					let t = this.queue.shift();
					t && (e.lock(), t.resolve(e));
				}
			}), this.workerPool.push(e);
		}
	}
	async parse(e, t) {
		let r = await this.acquireParserWorker(t), i = new vg(), n, a = t.onCancellationRequested(() => {
			n = setTimeout(() => {
				this.terminateWorker(r);
			}, this.terminationDelay);
		});
		return r.parse(e).then((e) => {
			let t = this.hydrator.hydrate(e);
			i.resolve(t);
		}).catch((e) => {
			i.reject(e);
		}).finally(() => {
			a.dispose(), clearTimeout(n);
		}), i.promise;
	}
	terminateWorker(e) {
		e.terminate();
		let t = this.workerPool.indexOf(e);
		t >= 0 && this.workerPool.splice(t, 1);
	}
	async acquireParserWorker(e) {
		for (let e of (this.initializeWorkers(), this.workerPool)) if (e.ready) return e.lock(), e;
		let t = new vg();
		return e.onCancellationRequested(() => {
			let e = this.queue.indexOf(t);
			e >= 0 && this.queue.splice(e, 1), t.reject(vu);
		}), this.queue.push(t), t.promise;
	}
}, xz = class {
	static {
		h(this, "ParserWorker");
	}
	get ready() {
		return this._ready;
	}
	get onReady() {
		return this.onReadyEmitter.event;
	}
	constructor(e, t, r, i) {
		this.onReadyEmitter = new v6.Emitter(), this.deferred = new vg(), this._ready = !0, this._parsing = !1, this.sendMessage = e, this._terminate = i, t((e) => {
			this.deferred.resolve(e), this.unlock();
		}), r((e) => {
			this.deferred.reject(e), this.unlock();
		});
	}
	terminate() {
		this.deferred.reject(vu), this._terminate();
	}
	lock() {
		this._ready = !1;
	}
	unlock() {
		this._parsing = !1, this._ready = !0, this.onReadyEmitter.fire();
	}
	parse(e) {
		if (this._parsing) throw Error("Parser worker is busy");
		return this._parsing = !0, this.deferred = new vg(), this.sendMessage(e), this.deferred.promise;
	}
}, xU = class {
	static {
		h(this, "DefaultWorkspaceLock");
	}
	constructor() {
		this.previousTokenSource = new va.CancellationTokenSource(), this.writeQueue = [], this.readQueue = [], this.done = !0;
	}
	write(e) {
		this.cancelWrite();
		let t = vc();
		return this.previousTokenSource = t, this.enqueue(this.writeQueue, e, t.token);
	}
	read(e) {
		return this.enqueue(this.readQueue, e);
	}
	enqueue(e, t, r = va.CancellationToken.None) {
		let i = new vg();
		return e.push({
			action: t,
			deferred: i,
			cancellationToken: r
		}), this.performNextOperation(), i.promise;
	}
	async performNextOperation() {
		if (!this.done) return;
		let e = [];
		if (this.writeQueue.length > 0) e.push(this.writeQueue.shift());
		else {
			if (!(this.readQueue.length > 0)) return;
			e.push(...this.readQueue.splice(0, this.readQueue.length));
		}
		this.done = !1, await Promise.all(e.map(async ({ action: e, deferred: t, cancellationToken: r }) => {
			try {
				let i = await Promise.resolve().then(() => e(r));
				t.resolve(i);
			} catch (e) {
				vd(e) ? t.resolve(void 0) : t.reject(e);
			}
		})), this.done = !0, this.performNextOperation();
	}
	cancelWrite() {
		this.previousTokenSource.cancel();
	}
}, xG = class {
	static {
		h(this, "DefaultHydrator");
	}
	constructor(e) {
		this.grammarElementIdMap = new v$(), this.tokenTypeIdMap = new v$(), this.grammar = e.Grammar, this.lexer = e.parser.Lexer, this.linker = e.references.Linker;
	}
	dehydrate(e) {
		return {
			lexerErrors: e.lexerErrors,
			lexerReport: e.lexerReport ? this.dehydrateLexerReport(e.lexerReport) : void 0,
			parserErrors: e.parserErrors.map((e) => Object.assign(Object.assign({}, e), { message: e.message })),
			value: this.dehydrateAstNode(e.value, this.createDehyrationContext(e.value))
		};
	}
	dehydrateLexerReport(e) {
		return e;
	}
	createDehyrationContext(e) {
		let t = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
		for (let r of oK(e)) t.set(r, {});
		if (e.$cstNode) for (let t of aX(e.$cstNode)) r.set(t, {});
		return {
			astNodes: t,
			cstNodes: r
		};
	}
	dehydrateAstNode(e, t) {
		let r = t.astNodes.get(e);
		for (let [i, n] of (r.$type = e.$type, r.$containerIndex = e.$containerIndex, r.$containerProperty = e.$containerProperty, void 0 !== e.$cstNode && (r.$cstNode = this.dehydrateCstNode(e.$cstNode, t)), Object.entries(e))) if (!i.startsWith("$")) if (Array.isArray(n)) {
			let e = [];
			for (let a of (r[i] = e, n)) aI(a) ? e.push(this.dehydrateAstNode(a, t)) : aM(a) ? e.push(this.dehydrateReference(a, t)) : e.push(a);
		} else aI(n) ? r[i] = this.dehydrateAstNode(n, t) : aM(n) ? r[i] = this.dehydrateReference(n, t) : void 0 !== n && (r[i] = n);
		return r;
	}
	dehydrateReference(e, t) {
		let r = {};
		return r.$refText = e.$refText, e.$refNode && (r.$refNode = t.cstNodes.get(e.$refNode)), r;
	}
	dehydrateCstNode(e, t) {
		let r = t.cstNodes.get(e);
		return aF(e) ? r.fullText = e.fullText : r.grammarSource = this.getGrammarElementId(e.grammarSource), r.hidden = e.hidden, r.astNode = t.astNodes.get(e.astNode), aP(e) ? r.content = e.content.map((e) => this.dehydrateCstNode(e, t)) : aB(e) && (r.tokenType = e.tokenType.name, r.offset = e.offset, r.length = e.length, r.startLine = e.range.start.line, r.startColumn = e.range.start.character, r.endLine = e.range.end.line, r.endColumn = e.range.end.character), r;
	}
	hydrate(e) {
		let t = e.value, r = this.createHydrationContext(t);
		return "$cstNode" in t && this.hydrateCstNode(t.$cstNode, r), {
			lexerErrors: e.lexerErrors,
			lexerReport: e.lexerReport,
			parserErrors: e.parserErrors,
			value: this.hydrateAstNode(t, r)
		};
	}
	createHydrationContext(e) {
		let t, r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map();
		for (let t of oK(e)) r.set(t, {});
		if (e.$cstNode) for (let r of aX(e.$cstNode)) {
			let e;
			"fullText" in r ? t = e = new yO(r.fullText) : "content" in r ? e = new yM() : "tokenType" in r && (e = this.hydrateCstLeafNode(r)), e && (i.set(r, e), e.root = t);
		}
		return {
			astNodes: r,
			cstNodes: i
		};
	}
	hydrateAstNode(e, t) {
		let r = t.astNodes.get(e);
		for (let [i, n] of (r.$type = e.$type, r.$containerIndex = e.$containerIndex, r.$containerProperty = e.$containerProperty, e.$cstNode && (r.$cstNode = t.cstNodes.get(e.$cstNode)), Object.entries(e))) if (!i.startsWith("$")) if (Array.isArray(n)) {
			let e = [];
			for (let a of (r[i] = e, n)) aI(a) ? e.push(this.setParent(this.hydrateAstNode(a, t), r)) : aM(a) ? e.push(this.hydrateReference(a, r, i, t)) : e.push(a);
		} else aI(n) ? r[i] = this.setParent(this.hydrateAstNode(n, t), r) : aM(n) ? r[i] = this.hydrateReference(n, r, i, t) : void 0 !== n && (r[i] = n);
		return r;
	}
	setParent(e, t) {
		return e.$container = t, e;
	}
	hydrateReference(e, t, r, i) {
		return this.linker.buildReference(t, r, i.cstNodes.get(e.$refNode), e.$refText);
	}
	hydrateCstNode(e, t, r = 0) {
		let i = t.cstNodes.get(e);
		if ("number" == typeof e.grammarSource && (i.grammarSource = this.getGrammarElement(e.grammarSource)), i.astNode = t.astNodes.get(e.astNode), aP(i)) for (let n of e.content) {
			let e = this.hydrateCstNode(n, t, r++);
			i.content.push(e);
		}
		return i;
	}
	hydrateCstLeafNode(e) {
		let t = this.getTokenType(e.tokenType);
		return new yI(e.offset, e.length, {
			start: {
				line: e.startLine,
				character: e.startColumn
			},
			end: {
				line: e.endLine,
				character: e.endColumn
			}
		}, t, e.hidden);
	}
	getTokenType(e) {
		return this.lexer.definition[e];
	}
	getGrammarElementId(e) {
		if (e) return 0 === this.grammarElementIdMap.size && this.createGrammarElementIdMap(), this.grammarElementIdMap.get(e);
	}
	getGrammarElement(e) {
		return 0 === this.grammarElementIdMap.size && this.createGrammarElementIdMap(), this.grammarElementIdMap.getKey(e);
	}
	createGrammarElementIdMap() {
		let e = 0;
		for (let t of oK(this.grammar)) sT(t) && this.grammarElementIdMap.set(t, e++);
	}
};
function xq(e) {
	return {
		documentation: {
			CommentProvider: h((e) => new xP(e), "CommentProvider"),
			DocumentationProvider: h((e) => new x$(e), "DocumentationProvider")
		},
		parser: {
			AsyncParser: h((e) => new xB(e), "AsyncParser"),
			GrammarConfig: h((e) => l4(e), "GrammarConfig"),
			LangiumParser: h((e) => ve(e), "LangiumParser"),
			CompletionParser: h((e) => y9(e), "CompletionParser"),
			ValueConverter: h(() => new vn(), "ValueConverter"),
			TokenBuilder: h(() => new vi(), "TokenBuilder"),
			Lexer: h((e) => new xa(e), "Lexer"),
			ParserErrorMessageProvider: h(() => new yG(), "ParserErrorMessageProvider"),
			LexerErrorMessageProvider: h(() => new xi(), "LexerErrorMessageProvider")
		},
		workspace: {
			AstNodeLocator: h(() => new v3(), "AstNodeLocator"),
			AstNodeDescriptionProvider: h((e) => new v4(e), "AstNodeDescriptionProvider"),
			ReferenceDescriptionProvider: h((e) => new v5(e), "ReferenceDescriptionProvider")
		},
		references: {
			Linker: h((e) => new vN(e), "Linker"),
			NameProvider: h(() => new vM(), "NameProvider"),
			ScopeProvider: h((e) => new vY(e), "ScopeProvider"),
			ScopeComputation: h((e) => new vP(e), "ScopeComputation"),
			References: h((e) => new vD(e), "References")
		},
		serializer: {
			Hydrator: h((e) => new xG(e), "Hydrator"),
			JsonSerializer: h((e) => new vX(e), "JsonSerializer")
		},
		validation: {
			DocumentValidator: h((e) => new vJ(e), "DocumentValidator"),
			ValidationRegistry: h((e) => new vQ(e), "ValidationRegistry")
		},
		shared: h(() => e.shared, "shared")
	};
}
function xj(e) {
	return {
		ServiceRegistry: h((e) => new vK(e), "ServiceRegistry"),
		workspace: {
			LangiumDocuments: h((e) => new vL(e), "LangiumDocuments"),
			LangiumDocumentFactory: h((e) => new vA(e), "LangiumDocumentFactory"),
			DocumentBuilder: h((e) => new xe(e), "DocumentBuilder"),
			IndexManager: h((e) => new xt(e), "IndexManager"),
			WorkspaceManager: h((e) => new xr(e), "WorkspaceManager"),
			FileSystemProvider: h((t) => e.fileSystemProvider(t), "FileSystemProvider"),
			WorkspaceLock: h(() => new xU(), "WorkspaceLock"),
			ConfigurationProvider: h((e) => new v7(e), "ConfigurationProvider")
		}
	};
}
function xW(e, t, r, i, n, a, s, o, l) {
	return xH([
		e,
		t,
		r,
		i,
		n,
		a,
		s,
		o,
		l
	].reduce(xZ, {}));
}
h(xq, "createDefaultCoreModule"), h(xj, "createDefaultSharedCoreModule"), (x3 || (x3 = {})).merge = (e, t) => xZ(xZ({}, e), t), h(xW, "inject");
var xY = Symbol("isProxy");
function xV(e) {
	if (e && e[xY]) for (let t of Object.values(e)) xV(t);
	return e;
}
function xH(e, t) {
	let r = new Proxy({}, {
		deleteProperty: h(() => !1, "deleteProperty"),
		set: h(() => {
			throw Error("Cannot set property on injected service container");
		}, "set"),
		get: h((i, n) => n === xY || xK(i, n, e, t || r), "get"),
		getOwnPropertyDescriptor: h((i, n) => (xK(i, n, e, t || r), Object.getOwnPropertyDescriptor(i, n)), "getOwnPropertyDescriptor"),
		has: h((t, r) => r in e, "has"),
		ownKeys: h(() => [...Object.getOwnPropertyNames(e)], "ownKeys")
	});
	return r;
}
h(xV, "eagerLoad"), h(xH, "_inject");
var xX = Symbol();
function xK(e, t, r, i) {
	if (t in e) {
		if (e[t] instanceof Error) throw Error("Construction failure. Please make sure that your dependencies are constructable.", { cause: e[t] });
		if (e[t] === xX) throw Error("Cycle detected. Please make \"" + String(t) + "\" lazy. Visit https://langium.org/docs/reference/configuration-services/#resolving-cyclic-dependencies");
		return e[t];
	}
	if (t in r) {
		let n = r[t];
		e[t] = xX;
		try {
			e[t] = "function" == typeof n ? n(i) : xH(n, i);
		} catch (r) {
			throw e[t] = r instanceof Error ? r : void 0, r;
		}
		return e[t];
	}
}
function xZ(e, t) {
	if (t) {
		for (let [r, i] of Object.entries(t)) if (void 0 !== i) {
			let t = e[r];
			null !== t && null !== i && "object" == typeof t && "object" == typeof i ? e[r] = xZ(t, i) : e[r] = i;
		}
	}
	return e;
}
h(xK, "_resolve"), h(xZ, "_merge");
var xQ, xJ, x0, x1, x2, x4, x5, x3, x6, x7 = {
	indentTokenName: "INDENT",
	dedentTokenName: "DEDENT",
	whitespaceTokenName: "WS",
	ignoreIndentationDelimiters: []
};
(bj = x6 || (x6 = {})).REGULAR = "indentation-sensitive", bj.IGNORE_INDENTATION = "ignore-indentation";
var x8 = class extends vi {
	static {
		h(this, "IndentationAwareTokenBuilder");
	}
	constructor(e = x7) {
		super(), this.indentationStack = [0], this.whitespaceRegExp = /[ \t]+/y, this.options = Object.assign(Object.assign({}, x7), e), this.indentTokenType = hq({
			name: this.options.indentTokenName,
			pattern: this.indentMatcher.bind(this),
			line_breaks: !1
		}), this.dedentTokenType = hq({
			name: this.options.dedentTokenName,
			pattern: this.dedentMatcher.bind(this),
			line_breaks: !1
		});
	}
	buildTokens(e, t) {
		let r = super.buildTokens(e, t);
		if (!xs(r)) throw Error("Invalid tokens built by default builder");
		let { indentTokenName: i, dedentTokenName: n, whitespaceTokenName: a, ignoreIndentationDelimiters: s } = this.options, o, l, h, u = [];
		for (let e of r) {
			for (let [t, r] of s) e.name === t ? e.PUSH_MODE = x6.IGNORE_INDENTATION : e.name === r && (e.POP_MODE = !0);
			e.name === n ? o = e : e.name === i ? l = e : e.name === a ? h = e : u.push(e);
		}
		if (!o || !l || !h) throw Error("Some indentation/whitespace tokens not found!");
		return s.length > 0 ? {
			modes: {
				[x6.REGULAR]: [
					o,
					l,
					...u,
					h
				],
				[x6.IGNORE_INDENTATION]: [...u, h]
			},
			defaultMode: x6.REGULAR
		} : [
			o,
			l,
			h,
			...u
		];
	}
	flushLexingReport(e) {
		return Object.assign(Object.assign({}, super.flushLexingReport(e)), { remainingDedents: this.flushRemainingDedents(e) });
	}
	isStartOfLine(e, t) {
		return 0 === t || `\r
`.includes(e[t - 1]);
	}
	matchWhitespace(e, t, r, i) {
		var n;
		this.whitespaceRegExp.lastIndex = t;
		let a = this.whitespaceRegExp.exec(e);
		return {
			currIndentLevel: null != (n = a?.[0].length) ? n : 0,
			prevIndentLevel: this.indentationStack.at(-1),
			match: a
		};
	}
	createIndentationTokenInstance(e, t, r, i) {
		let n = this.getLineNumber(t, i);
		return hY(e, r, i, i + r.length, n, n, 1, r.length);
	}
	getLineNumber(e, t) {
		return e.substring(0, t).split(/\r\n|\r|\n/).length;
	}
	indentMatcher(e, t, r, i) {
		if (!this.isStartOfLine(e, t)) return null;
		let { currIndentLevel: n, prevIndentLevel: a, match: s } = this.matchWhitespace(e, t, r, i);
		return n <= a ? null : (this.indentationStack.push(n), s);
	}
	dedentMatcher(e, t, r, i) {
		var n, a, s, o;
		if (!this.isStartOfLine(e, t)) return null;
		let { currIndentLevel: l, prevIndentLevel: h, match: u } = this.matchWhitespace(e, t, r, i);
		if (l >= h) return null;
		let d = this.indentationStack.lastIndexOf(l);
		if (-1 === d) return this.diagnostics.push({
			severity: "error",
			message: `Invalid dedent level ${l} at offset: ${t}. Current indentation stack: ${this.indentationStack}`,
			offset: t,
			length: null != (a = null == (n = u?.[0]) ? void 0 : n.length) ? a : 0,
			line: this.getLineNumber(e, t),
			column: 1
		}), null;
		let p = this.indentationStack.length - d - 1, f = null != (o = null == (s = e.substring(0, t).match(/[\r\n]+$/)) ? void 0 : s[0].length) ? o : 1;
		for (let i = 0; i < p; i++) {
			let i = this.createIndentationTokenInstance(this.dedentTokenType, e, "", t - (f - 1));
			r.push(i), this.indentationStack.pop();
		}
		return null;
	}
	buildTerminalToken(e) {
		let t = super.buildTerminalToken(e), { indentTokenName: r, dedentTokenName: i, whitespaceTokenName: n } = this.options;
		return t.name === r ? this.indentTokenType : t.name === i ? this.dedentTokenType : t.name === n ? hq({
			name: n,
			pattern: this.whitespaceRegExp,
			group: hI.SKIPPED
		}) : t;
	}
	flushRemainingDedents(e) {
		let t = [];
		for (; this.indentationStack.length > 1;) t.push(this.createIndentationTokenInstance(this.dedentTokenType, e, "", e.length)), this.indentationStack.pop();
		return this.indentationStack = [0], t;
	}
}, x9 = class extends xa {
	static {
		h(this, "IndentationAwareLexer");
	}
	constructor(e) {
		if (super(e), e.parser.TokenBuilder instanceof x8) this.indentationTokenBuilder = e.parser.TokenBuilder;
		else throw Error("IndentationAwareLexer requires an accompanying IndentationAwareTokenBuilder");
	}
	tokenize(e, t = xn) {
		let r = super.tokenize(e), i = r.report;
		t?.mode === "full" && r.tokens.push(...i.remainingDedents), i.remainingDedents = [];
		let { indentTokenType: n, dedentTokenType: a } = this.indentationTokenBuilder, s = n.tokenTypeIdx, o = a.tokenTypeIdx, l = [], h = r.tokens.length - 1;
		for (let e = 0; e < h; e++) {
			let t = r.tokens[e], i = r.tokens[e + 1];
			if (t.tokenTypeIdx === s && i.tokenTypeIdx === o) {
				e++;
				continue;
			}
			l.push(t);
		}
		return h >= 0 && l.push(r.tokens[h]), r.tokens = l, r;
	}
}, be = {};
d(be, {
	AstUtils: () => oG,
	BiMap: () => v$,
	Cancellation: () => va,
	ContextCache: () => vq,
	CstUtils: () => aN,
	DONE_RESULT: () => aj,
	Deferred: () => vg,
	Disposable: () => x5,
	DisposableCache: () => vU,
	DocumentCache: () => vj,
	EMPTY_STREAM: () => aq,
	ErrorWithLocation: () => ss,
	GrammarUtils: () => sa,
	MultiMap: () => vO,
	OperationCancelled: () => vu,
	Reduction: () => aV,
	RegExpUtils: () => o4,
	SimpleCache: () => vG,
	StreamImpl: () => az,
	TreeStreamImpl: () => aH,
	URI: () => vC,
	UriUtils: () => x0,
	WorkspaceCache: () => vW,
	assertUnreachable: () => so,
	delayNextTick: () => vs,
	interruptAndCheck: () => vp,
	isOperationCancelled: () => vd,
	loadGrammarFromJson: () => bs,
	setInterruptionPeriod: () => vh,
	startCancelableOperation: () => vc,
	stream: () => aW
}), f(be, v6);
var bt = class {
	static {
		h(this, "EmptyFileSystemProvider");
	}
	readFile() {
		throw Error("No file system is available.");
	}
	async readDirectory() {
		return [];
	}
}, br = { fileSystemProvider: h(() => new bt(), "fileSystemProvider") }, bi = {
	Grammar: h(() => {}, "Grammar"),
	LanguageMetaData: h(() => ({
		caseInsensitive: !1,
		fileExtensions: [".langium"],
		languageId: "langium"
	}), "LanguageMetaData")
}, bn = { AstReflection: h(() => new oz(), "AstReflection") };
function ba() {
	let e = xW(xj(br), bn), t = xW(xq({ shared: e }), bi);
	return e.ServiceRegistry.register(t), t;
}
function bs(e) {
	var t;
	let r = ba(), i = r.serializer.JsonSerializer.deserialize(e);
	return r.shared.workspace.LangiumDocumentFactory.fromModel(i, vC.parse(`memory://${null != (t = i.name) ? t : "grammar"}.langium`)), i;
}
h(ba, "createMinimalGrammarServices"), h(bs, "loadGrammarFromJson"), f(aR, be);
var bo = Object.defineProperty, bl = h((e, t) => bo(e, "name", {
	value: t,
	configurable: !0
}), "__name"), bc = "Statement", bh = "Architecture";
function bu(e) {
	return b4.isInstance(e, bh);
}
h(bu, "isArchitecture"), bl(bu, "isArchitecture");
var bd = "Axis", bp = "Branch";
function bf(e) {
	return b4.isInstance(e, bp);
}
h(bf, "isBranch"), bl(bf, "isBranch");
var bg = "Checkout", bm = "CherryPicking", by = "ClassDefStatement", bv = "Commit";
function bx(e) {
	return b4.isInstance(e, bv);
}
h(bx, "isCommit"), bl(bx, "isCommit");
var bb = "Curve", bw = "Edge", bk = "Entry", bT = "GitGraph";
function b_(e) {
	return b4.isInstance(e, bT);
}
h(b_, "isGitGraph"), bl(b_, "isGitGraph");
var bE = "Group", bC = "Info";
function bS(e) {
	return b4.isInstance(e, bC);
}
h(bS, "isInfo"), bl(bS, "isInfo");
var bA = "Item", bL = "Junction", bR = "Merge";
function bN(e) {
	return b4.isInstance(e, bR);
}
h(bN, "isMerge"), bl(bN, "isMerge");
var bI = "Option", bM = "Packet";
function bD(e) {
	return b4.isInstance(e, bM);
}
h(bD, "isPacket"), bl(bD, "isPacket");
var bO = "PacketBlock";
function b$(e) {
	return b4.isInstance(e, bO);
}
function bP(e) {
	return b4.isInstance(e, "Pie");
}
h(b$, "isPacketBlock"), bl(b$, "isPacketBlock"), h(bP, "isPie"), bl(bP, "isPie");
var bB = "PieSection";
function bF(e) {
	return b4.isInstance(e, bB);
}
h(bF, "isPieSection"), bl(bF, "isPieSection");
var bz = "Radar", bU = "Service", bG = "Treemap";
function bq(e) {
	return b4.isInstance(e, bG);
}
h(bq, "isTreemap"), bl(bq, "isTreemap");
var bj, bW, bY, bV, bH, bX, bK, bZ, bQ = "TreemapRow", bJ = "Direction", b0 = "Leaf", b1 = "Section", b2 = class extends a$ {
	static {
		h(this, "MermaidAstReflection");
	}
	static {
		bl(this, "MermaidAstReflection");
	}
	getAllTypes() {
		return [
			bh,
			bd,
			bp,
			bg,
			bm,
			by,
			bv,
			bb,
			bJ,
			bw,
			bk,
			bT,
			bE,
			bC,
			bA,
			bL,
			b0,
			bR,
			bI,
			bM,
			bO,
			"Pie",
			bB,
			bz,
			b1,
			bU,
			bc,
			bG,
			bQ
		];
	}
	computeIsSubtype(e, t) {
		switch (e) {
			case bp:
			case bg:
			case bm:
			case bv:
			case bR: return this.isSubtype(bc, t);
			case bJ: return this.isSubtype(bT, t);
			case b0:
			case b1: return this.isSubtype(bA, t);
			default: return !1;
		}
	}
	getReferenceType(e) {
		let t = `${e.container.$type}:${e.property}`;
		if ("Entry:axis" === t) return bd;
		throw Error(`${t} is not a valid reference id.`);
	}
	getTypeMetaData(e) {
		switch (e) {
			case bh: return {
				name: bh,
				properties: [
					{ name: "accDescr" },
					{ name: "accTitle" },
					{
						name: "edges",
						defaultValue: []
					},
					{
						name: "groups",
						defaultValue: []
					},
					{
						name: "junctions",
						defaultValue: []
					},
					{
						name: "services",
						defaultValue: []
					},
					{ name: "title" }
				]
			};
			case bd: return {
				name: bd,
				properties: [{ name: "label" }, { name: "name" }]
			};
			case bp: return {
				name: bp,
				properties: [{ name: "name" }, { name: "order" }]
			};
			case bg: return {
				name: bg,
				properties: [{ name: "branch" }]
			};
			case bm: return {
				name: bm,
				properties: [
					{ name: "id" },
					{ name: "parent" },
					{
						name: "tags",
						defaultValue: []
					}
				]
			};
			case by: return {
				name: by,
				properties: [{ name: "className" }, { name: "styleText" }]
			};
			case bv: return {
				name: bv,
				properties: [
					{ name: "id" },
					{ name: "message" },
					{
						name: "tags",
						defaultValue: []
					},
					{ name: "type" }
				]
			};
			case bb: return {
				name: bb,
				properties: [
					{
						name: "entries",
						defaultValue: []
					},
					{ name: "label" },
					{ name: "name" }
				]
			};
			case bw: return {
				name: bw,
				properties: [
					{ name: "lhsDir" },
					{
						name: "lhsGroup",
						defaultValue: !1
					},
					{ name: "lhsId" },
					{
						name: "lhsInto",
						defaultValue: !1
					},
					{ name: "rhsDir" },
					{
						name: "rhsGroup",
						defaultValue: !1
					},
					{ name: "rhsId" },
					{
						name: "rhsInto",
						defaultValue: !1
					},
					{ name: "title" }
				]
			};
			case bk: return {
				name: bk,
				properties: [{ name: "axis" }, { name: "value" }]
			};
			case bT: return {
				name: bT,
				properties: [
					{ name: "accDescr" },
					{ name: "accTitle" },
					{
						name: "statements",
						defaultValue: []
					},
					{ name: "title" }
				]
			};
			case bE: return {
				name: bE,
				properties: [
					{ name: "icon" },
					{ name: "id" },
					{ name: "in" },
					{ name: "title" }
				]
			};
			case bC: return {
				name: bC,
				properties: [
					{ name: "accDescr" },
					{ name: "accTitle" },
					{ name: "title" }
				]
			};
			case bA: return {
				name: bA,
				properties: [{ name: "classSelector" }, { name: "name" }]
			};
			case bL: return {
				name: bL,
				properties: [{ name: "id" }, { name: "in" }]
			};
			case bR: return {
				name: bR,
				properties: [
					{ name: "branch" },
					{ name: "id" },
					{
						name: "tags",
						defaultValue: []
					},
					{ name: "type" }
				]
			};
			case bI: return {
				name: bI,
				properties: [{ name: "name" }, {
					name: "value",
					defaultValue: !1
				}]
			};
			case bM: return {
				name: bM,
				properties: [
					{ name: "accDescr" },
					{ name: "accTitle" },
					{
						name: "blocks",
						defaultValue: []
					},
					{ name: "title" }
				]
			};
			case bO: return {
				name: bO,
				properties: [
					{ name: "bits" },
					{ name: "end" },
					{ name: "label" },
					{ name: "start" }
				]
			};
			case "Pie": return {
				name: "Pie",
				properties: [
					{ name: "accDescr" },
					{ name: "accTitle" },
					{
						name: "sections",
						defaultValue: []
					},
					{
						name: "showData",
						defaultValue: !1
					},
					{ name: "title" }
				]
			};
			case bB: return {
				name: bB,
				properties: [{ name: "label" }, { name: "value" }]
			};
			case bz: return {
				name: bz,
				properties: [
					{ name: "accDescr" },
					{ name: "accTitle" },
					{
						name: "axes",
						defaultValue: []
					},
					{
						name: "curves",
						defaultValue: []
					},
					{
						name: "options",
						defaultValue: []
					},
					{ name: "title" }
				]
			};
			case bU: return {
				name: bU,
				properties: [
					{ name: "icon" },
					{ name: "iconText" },
					{ name: "id" },
					{ name: "in" },
					{ name: "title" }
				]
			};
			case bG: return {
				name: bG,
				properties: [
					{ name: "accDescr" },
					{ name: "accTitle" },
					{ name: "title" },
					{
						name: "TreemapRows",
						defaultValue: []
					}
				]
			};
			case bQ: return {
				name: bQ,
				properties: [{ name: "indent" }, { name: "item" }]
			};
			case bJ: return {
				name: bJ,
				properties: [
					{ name: "accDescr" },
					{ name: "accTitle" },
					{ name: "dir" },
					{
						name: "statements",
						defaultValue: []
					},
					{ name: "title" }
				]
			};
			case b0: return {
				name: b0,
				properties: [
					{ name: "classSelector" },
					{ name: "name" },
					{ name: "value" }
				]
			};
			case b1: return {
				name: b1,
				properties: [{ name: "classSelector" }, { name: "name" }]
			};
			default: return {
				name: e,
				properties: []
			};
		}
	}
}, b4 = new b2(), b5 = bl(() => bW ?? (bW = bs(`{"$type":"Grammar","isDeclared":true,"name":"Info","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Info","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[],"cardinality":"*"},{"$type":"Keyword","value":"info"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[],"cardinality":"*"},{"$type":"Group","elements":[{"$type":"Keyword","value":"showInfo"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[],"cardinality":"*"}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[],"cardinality":"?"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@7"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@8"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[],"types":[],"usedGrammars":[]}`)), "InfoGrammar"), b3 = bl(() => bY ?? (bY = bs(`{"$type":"Grammar","isDeclared":true,"name":"Packet","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Packet","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[],"cardinality":"*"},{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"packet"},{"$type":"Keyword","value":"packet-beta"}]},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]},{"$type":"Assignment","feature":"blocks","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"PacketBlock","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Assignment","feature":"start","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":"-"},{"$type":"Assignment","feature":"end","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}}],"cardinality":"?"}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"+"},{"$type":"Assignment","feature":"bits","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}}]}]},{"$type":"Keyword","value":":"},{"$type":"Assignment","feature":"label","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@8"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@9"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[],"types":[],"usedGrammars":[]}`)), "PacketGrammar"), b6 = bl(() => bV ?? (bV = bs(`{"$type":"Grammar","isDeclared":true,"name":"Pie","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Pie","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[],"cardinality":"*"},{"$type":"Keyword","value":"pie"},{"$type":"Assignment","feature":"showData","operator":"?=","terminal":{"$type":"Keyword","value":"showData"},"cardinality":"?"},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]},{"$type":"Assignment","feature":"sections","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[]}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"PieSection","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"label","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@14"},"arguments":[]}},{"$type":"Keyword","value":":"},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"FLOAT_PIE","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/-?[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT_PIE","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/-?(0|[1-9][0-9]*)(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER_PIE","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@2"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@3"}}]},"fragment":false,"hidden":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@11"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@12"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[],"types":[],"usedGrammars":[]}`)), "PieGrammar"), b7 = bl(() => bH ?? (bH = bs(`{"$type":"Grammar","isDeclared":true,"name":"Architecture","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Architecture","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@23"},"arguments":[],"cardinality":"*"},{"$type":"Keyword","value":"architecture-beta"},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@23"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"Statement","definition":{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"groups","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}},{"$type":"Assignment","feature":"services","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}},{"$type":"Assignment","feature":"junctions","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}},{"$type":"Assignment","feature":"edges","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"LeftPort","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":":"},{"$type":"Assignment","feature":"lhsDir","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"RightPort","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"rhsDir","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}},{"$type":"Keyword","value":":"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"Arrow","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]},{"$type":"Assignment","feature":"lhsInto","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]},"cardinality":"?"},{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"--"},{"$type":"Group","elements":[{"$type":"Keyword","value":"-"},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@29"},"arguments":[]}},{"$type":"Keyword","value":"-"}]}]},{"$type":"Assignment","feature":"rhsInto","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]},"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Group","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"group"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Assignment","feature":"icon","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@28"},"arguments":[]},"cardinality":"?"},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@29"},"arguments":[]},"cardinality":"?"},{"$type":"Group","elements":[{"$type":"Keyword","value":"in"},{"$type":"Assignment","feature":"in","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Service","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"service"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"iconText","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@21"},"arguments":[]}},{"$type":"Assignment","feature":"icon","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@28"},"arguments":[]}}],"cardinality":"?"},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@29"},"arguments":[]},"cardinality":"?"},{"$type":"Group","elements":[{"$type":"Keyword","value":"in"},{"$type":"Assignment","feature":"in","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Junction","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"junction"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":"in"},{"$type":"Assignment","feature":"in","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Edge","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"lhsId","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Assignment","feature":"lhsGroup","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]},"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]},{"$type":"Assignment","feature":"rhsId","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Assignment","feature":"rhsGroup","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]},"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"ARROW_DIRECTION","definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"L"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"R"}}]},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"T"}}]},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"B"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ARROW_GROUP","definition":{"$type":"RegexToken","regex":"/\\\\{group\\\\}/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ARROW_INTO","definition":{"$type":"RegexToken","regex":"/<|>/"},"fragment":false,"hidden":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@23"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@15"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@18"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@19"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false},{"$type":"TerminalRule","name":"ARCH_ICON","definition":{"$type":"RegexToken","regex":"/\\\\([\\\\w-:]+\\\\)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ARCH_TITLE","definition":{"$type":"RegexToken","regex":"/\\\\[[\\\\w ]+\\\\]/"},"fragment":false,"hidden":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[],"types":[],"usedGrammars":[]}`)), "ArchitectureGrammar"), b8 = bl(() => bX ?? (bX = bs(`{"$type":"Grammar","isDeclared":true,"name":"GitGraph","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"GitGraph","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[],"cardinality":"*"},{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"gitGraph"},{"$type":"Group","elements":[{"$type":"Keyword","value":"gitGraph"},{"$type":"Keyword","value":":"}]},{"$type":"Keyword","value":"gitGraph:"},{"$type":"Group","elements":[{"$type":"Keyword","value":"gitGraph"},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]},{"$type":"Keyword","value":":"}]}]},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]},{"$type":"Assignment","feature":"statements","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Statement","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Direction","definition":{"$type":"Assignment","feature":"dir","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"LR"},{"$type":"Keyword","value":"TB"},{"$type":"Keyword","value":"BT"}]}},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Commit","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"commit"},{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Keyword","value":"id:"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"msg:","cardinality":"?"},{"$type":"Assignment","feature":"message","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"tag:"},{"$type":"Assignment","feature":"tags","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"type:"},{"$type":"Assignment","feature":"type","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"NORMAL"},{"$type":"Keyword","value":"REVERSE"},{"$type":"Keyword","value":"HIGHLIGHT"}]}}]}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Branch","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"branch"},{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@24"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]}},{"$type":"Group","elements":[{"$type":"Keyword","value":"order:"},{"$type":"Assignment","feature":"order","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@15"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Merge","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"merge"},{"$type":"Assignment","feature":"branch","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@24"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]}},{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Keyword","value":"id:"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"tag:"},{"$type":"Assignment","feature":"tags","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"type:"},{"$type":"Assignment","feature":"type","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"NORMAL"},{"$type":"Keyword","value":"REVERSE"},{"$type":"Keyword","value":"HIGHLIGHT"}]}}]}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Checkout","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"checkout"},{"$type":"Keyword","value":"switch"}]},{"$type":"Assignment","feature":"branch","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@24"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"CherryPicking","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"cherry-pick"},{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Keyword","value":"id:"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"tag:"},{"$type":"Assignment","feature":"tags","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"parent:"},{"$type":"Assignment","feature":"parent","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@14"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@15"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false},{"$type":"TerminalRule","name":"REFERENCE","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\\\w([-\\\\./\\\\w]*[-\\\\w])?/"},"fragment":false,"hidden":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[],"types":[],"usedGrammars":[]}`)), "GitGraphGrammar"), b9 = bl(() => bK ?? (bK = bs(`{"$type":"Grammar","isDeclared":true,"name":"Radar","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Radar","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"radar-beta"},{"$type":"Keyword","value":"radar-beta:"},{"$type":"Group","elements":[{"$type":"Keyword","value":"radar-beta"},{"$type":"Keyword","value":":"}]}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]},{"$type":"Group","elements":[{"$type":"Keyword","value":"axis"},{"$type":"Assignment","feature":"axes","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"Assignment","feature":"axes","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}}],"cardinality":"*"}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"curve"},{"$type":"Assignment","feature":"curves","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"Assignment","feature":"curves","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}}],"cardinality":"*"}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"options","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"Assignment","feature":"options","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}}],"cardinality":"*"}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"Label","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"["},{"$type":"Assignment","feature":"label","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@18"},"arguments":[]}},{"$type":"Keyword","value":"]"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Axis","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[],"cardinality":"?"}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Curve","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[],"cardinality":"?"},{"$type":"Keyword","value":"{"},{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]},{"$type":"Keyword","value":"}"}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"Entries","definition":{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Assignment","feature":"entries","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Assignment","feature":"entries","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"}]},{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Assignment","feature":"entries","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Assignment","feature":"entries","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"}]}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"DetailedEntry","returnType":{"$ref":"#/interfaces@0"},"definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"axis","operator":"=","terminal":{"$type":"CrossReference","type":{"$ref":"#/rules@2"},"terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]},"deprecatedSyntax":false}},{"$type":"Keyword","value":":","cardinality":"?"},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"NumberEntry","returnType":{"$ref":"#/interfaces@0"},"definition":{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Option","definition":{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"showLegend"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"ticks"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"max"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"min"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"graticule"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}}]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"GRATICULE","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"circle"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"polygon"}}]},"fragment":false,"hidden":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@14"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@15"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@16"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false}],"interfaces":[{"$type":"Interface","name":"Entry","attributes":[{"$type":"TypeAttribute","name":"axis","isOptional":true,"type":{"$type":"ReferenceType","referenceType":{"$type":"SimpleType","typeRef":{"$ref":"#/rules@2"}}}},{"$type":"TypeAttribute","name":"value","type":{"$type":"SimpleType","primitiveType":"number"},"isOptional":false}],"superTypes":[]}],"definesHiddenTokens":false,"hiddenTokens":[],"types":[],"usedGrammars":[]}`)), "RadarGrammar"), we = bl(() => bZ ?? (bZ = bs(`{"$type":"Grammar","isDeclared":true,"name":"Treemap","rules":[{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]}}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"ParserRule","entry":true,"name":"Treemap","returnType":{"$ref":"#/interfaces@4"},"definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@0"},"arguments":[]},{"$type":"Assignment","feature":"TreemapRows","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@14"},"arguments":[]}}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"TREEMAP_KEYWORD","definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"treemap-beta"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"treemap"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"CLASS_DEF","definition":{"$type":"RegexToken","regex":"/classDef\\\\s+([a-zA-Z_][a-zA-Z0-9_]+)(?:\\\\s+([^;\\\\r\\\\n]*))?(?:;)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STYLE_SEPARATOR","definition":{"$type":"CharacterRange","left":{"$type":"Keyword","value":":::"}},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"SEPARATOR","definition":{"$type":"CharacterRange","left":{"$type":"Keyword","value":":"}},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"COMMA","definition":{"$type":"CharacterRange","left":{"$type":"Keyword","value":","}},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WS","definition":{"$type":"RegexToken","regex":"/[ \\\\t]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"ML_COMMENT","definition":{"$type":"RegexToken","regex":"/\\\\%\\\\%[^\\\\n]*/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"NL","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false},{"$type":"ParserRule","name":"TreemapRow","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"indent","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]},"cardinality":"?"},{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"item","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@15"},"arguments":[]}]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"ClassDef","dataType":"string","definition":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Item","returnType":{"$ref":"#/interfaces@0"},"definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@18"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Section","returnType":{"$ref":"#/interfaces@1"},"definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@23"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]},{"$type":"Assignment","feature":"classSelector","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}}],"cardinality":"?"}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Leaf","returnType":{"$ref":"#/interfaces@2"},"definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@23"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[],"cardinality":"?"},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[],"cardinality":"?"},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]},{"$type":"Assignment","feature":"classSelector","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}}],"cardinality":"?"}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"INDENTATION","definition":{"$type":"RegexToken","regex":"/[ \\\\t]{1,}/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID2","definition":{"$type":"RegexToken","regex":"/[a-zA-Z_][a-zA-Z0-9_]*/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER2","definition":{"$type":"RegexToken","regex":"/[0-9_\\\\.\\\\,]+/"},"fragment":false,"hidden":false},{"$type":"ParserRule","name":"MyNumber","dataType":"number","definition":{"$type":"RuleCall","rule":{"$ref":"#/rules@21"},"arguments":[]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"STRING2","definition":{"$type":"RegexToken","regex":"/\\"[^\\"]*\\"|'[^']*'/"},"fragment":false,"hidden":false}],"interfaces":[{"$type":"Interface","name":"Item","attributes":[{"$type":"TypeAttribute","name":"name","type":{"$type":"SimpleType","primitiveType":"string"},"isOptional":false},{"$type":"TypeAttribute","name":"classSelector","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}}],"superTypes":[]},{"$type":"Interface","name":"Section","superTypes":[{"$ref":"#/interfaces@0"}],"attributes":[]},{"$type":"Interface","name":"Leaf","superTypes":[{"$ref":"#/interfaces@0"}],"attributes":[{"$type":"TypeAttribute","name":"value","type":{"$type":"SimpleType","primitiveType":"number"},"isOptional":false}]},{"$type":"Interface","name":"ClassDefStatement","attributes":[{"$type":"TypeAttribute","name":"className","type":{"$type":"SimpleType","primitiveType":"string"},"isOptional":false},{"$type":"TypeAttribute","name":"styleText","type":{"$type":"SimpleType","primitiveType":"string"},"isOptional":false}],"superTypes":[]},{"$type":"Interface","name":"Treemap","attributes":[{"$type":"TypeAttribute","name":"TreemapRows","type":{"$type":"ArrayType","elementType":{"$type":"SimpleType","typeRef":{"$ref":"#/rules@14"}}},"isOptional":false},{"$type":"TypeAttribute","name":"title","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"accTitle","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"accDescr","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}}],"superTypes":[]}],"definesHiddenTokens":false,"hiddenTokens":[],"imports":[],"types":[],"usedGrammars":[],"$comment":"/**\\n * Treemap grammar for Langium\\n * Converted from mindmap grammar\\n *\\n * The ML_COMMENT and NL hidden terminals handle whitespace, comments, and newlines\\n * before the treemap keyword, allowing for empty lines and comments before the\\n * treemap declaration.\\n */"}`)), "TreemapGrammar"), wt = {
	languageId: "info",
	fileExtensions: [".mmd", ".mermaid"],
	caseInsensitive: !1,
	mode: "production"
}, wr = {
	languageId: "packet",
	fileExtensions: [".mmd", ".mermaid"],
	caseInsensitive: !1,
	mode: "production"
}, wi = {
	languageId: "pie",
	fileExtensions: [".mmd", ".mermaid"],
	caseInsensitive: !1,
	mode: "production"
}, wn = {
	languageId: "architecture",
	fileExtensions: [".mmd", ".mermaid"],
	caseInsensitive: !1,
	mode: "production"
}, wa = {
	languageId: "gitGraph",
	fileExtensions: [".mmd", ".mermaid"],
	caseInsensitive: !1,
	mode: "production"
}, ws = {
	languageId: "radar",
	fileExtensions: [".mmd", ".mermaid"],
	caseInsensitive: !1,
	mode: "production"
}, wo = {
	languageId: "treemap",
	fileExtensions: [".mmd", ".mermaid"],
	caseInsensitive: !1,
	mode: "production"
}, wl = { AstReflection: bl(() => new b2(), "AstReflection") }, wc = {
	Grammar: bl(() => b5(), "Grammar"),
	LanguageMetaData: bl(() => wt, "LanguageMetaData"),
	parser: {}
}, wh = {
	Grammar: bl(() => b3(), "Grammar"),
	LanguageMetaData: bl(() => wr, "LanguageMetaData"),
	parser: {}
}, wu = {
	Grammar: bl(() => b6(), "Grammar"),
	LanguageMetaData: bl(() => wi, "LanguageMetaData"),
	parser: {}
}, wd = {
	Grammar: bl(() => b7(), "Grammar"),
	LanguageMetaData: bl(() => wn, "LanguageMetaData"),
	parser: {}
}, wp = {
	Grammar: bl(() => b8(), "Grammar"),
	LanguageMetaData: bl(() => wa, "LanguageMetaData"),
	parser: {}
}, wf = {
	Grammar: bl(() => b9(), "Grammar"),
	LanguageMetaData: bl(() => ws, "LanguageMetaData"),
	parser: {}
}, wg = {
	Grammar: bl(() => we(), "Grammar"),
	LanguageMetaData: bl(() => wo, "LanguageMetaData"),
	parser: {}
}, wm = {
	ACC_DESCR: /accDescr(?:[\t ]*:([^\n\r]*)|\s*{([^}]*)})/,
	ACC_TITLE: /accTitle[\t ]*:([^\n\r]*)/,
	TITLE: /title([\t ][^\n\r]*|)/
}, wy = class extends vn {
	static {
		h(this, "AbstractMermaidValueConverter");
	}
	static {
		bl(this, "AbstractMermaidValueConverter");
	}
	runConverter(e, t, r) {
		let i = this.runCommonConverter(e, t, r);
		return void 0 === i && (i = this.runCustomConverter(e, t, r)), void 0 === i ? super.runConverter(e, t, r) : i;
	}
	runCommonConverter(e, t, r) {
		let i = wm[e.name];
		if (void 0 === i) return;
		let n = i.exec(t);
		if (null !== n) {
			if (void 0 !== n[1]) return n[1].trim().replace(/[\t ]{2,}/gm, " ");
			if (void 0 !== n[2]) return n[2].replace(/^\s*/gm, "").replace(/\s+$/gm, "").replace(/[\t ]{2,}/gm, " ").replace(/[\n\r]{2,}/gm, `
`);
		}
	}
}, wv = class extends wy {
	static {
		h(this, "CommonValueConverter");
	}
	static {
		bl(this, "CommonValueConverter");
	}
	runCustomConverter(e, t, r) {}
}, wx = class extends vi {
	static {
		h(this, "AbstractMermaidTokenBuilder");
	}
	static {
		bl(this, "AbstractMermaidTokenBuilder");
	}
	constructor(e) {
		super(), this.keywords = new Set(e);
	}
	buildKeywordTokens(e, t, r) {
		let i = super.buildKeywordTokens(e, t, r);
		return i.forEach((e) => {
			this.keywords.has(e.name) && void 0 !== e.PATTERN && (e.PATTERN = RegExp(e.PATTERN.toString() + "(?:(?=%%)|(?!\\S))"));
		}), i;
	}
};
(class extends wx {
	static {
		h(this, "CommonTokenBuilder");
	}
	static {
		bl(this, "CommonTokenBuilder");
	}
});
var wb = class extends wx {
	static {
		h(this, "ArchitectureTokenBuilder");
	}
	static {
		bl(this, "ArchitectureTokenBuilder");
	}
	constructor() {
		super(["architecture"]);
	}
}, ww = class extends wy {
	static {
		h(this, "ArchitectureValueConverter");
	}
	static {
		bl(this, "ArchitectureValueConverter");
	}
	runCustomConverter(e, t, r) {
		return "ARCH_ICON" === e.name ? t.replace(/[()]/g, "").trim() : "ARCH_TEXT_ICON" === e.name ? t.replace(/["()]/g, "") : "ARCH_TITLE" === e.name ? t.replace(/[[\]]/g, "").trim() : void 0;
	}
}, wk = { parser: {
	TokenBuilder: bl(() => new wb(), "TokenBuilder"),
	ValueConverter: bl(() => new ww(), "ValueConverter")
} };
function wT(e = br) {
	let t = xW(xj(e), wl), r = xW(xq({ shared: t }), wd, wk);
	return t.ServiceRegistry.register(r), {
		shared: t,
		Architecture: r
	};
}
function w_(e, t) {
	e.accDescr && t.setAccDescription?.(e.accDescr), e.accTitle && t.setAccTitle?.(e.accTitle), e.title && t.setDiagramTitle?.(e.title);
}
h(wT, "createArchitectureServices"), bl(wT, "createArchitectureServices"), h(w_, "populateCommonDb");
var wE = {}, wC = {
	info: bl(async () => {
		let { createInfoServices: e } = await r(async () => {
			let { createInfoServices: e } = await import("./vendor-mermaid.DHks_B7-.chunk.js");
			return { createInfoServices: e };
		}, []);
		wE.info = e().Info.parser.LangiumParser;
	}, "info"),
	packet: bl(async () => {
		let { createPacketServices: e } = await r(async () => {
			let { createPacketServices: e } = await import("./vendor-mermaid.7qM052vm.chunk.js");
			return { createPacketServices: e };
		}, []);
		wE.packet = e().Packet.parser.LangiumParser;
	}, "packet"),
	pie: bl(async () => {
		let { createPieServices: e } = await r(async () => {
			let { createPieServices: e } = await import("./vendor-mermaid.BYUcWBjM.chunk.js");
			return { createPieServices: e };
		}, []);
		wE.pie = e().Pie.parser.LangiumParser;
	}, "pie"),
	architecture: bl(async () => {
		let { createArchitectureServices: e } = await r(async () => {
			let { createArchitectureServices: e } = await import("./vendor-mermaid.Bv47-Lga.chunk.js");
			return { createArchitectureServices: e };
		}, []);
		wE.architecture = e().Architecture.parser.LangiumParser;
	}, "architecture"),
	gitGraph: bl(async () => {
		let { createGitGraphServices: e } = await r(async () => {
			let { createGitGraphServices: e } = await import("./vendor-mermaid.BKhDbe27.chunk.js");
			return { createGitGraphServices: e };
		}, []);
		wE.gitGraph = e().GitGraph.parser.LangiumParser;
	}, "gitGraph"),
	radar: bl(async () => {
		let { createRadarServices: e } = await r(async () => {
			let { createRadarServices: e } = await import("./vendor-mermaid.DlB6vjHY.chunk.js");
			return { createRadarServices: e };
		}, []);
		wE.radar = e().Radar.parser.LangiumParser;
	}, "radar"),
	treemap: bl(async () => {
		let { createTreemapServices: e } = await r(async () => {
			let { createTreemapServices: e } = await import("./vendor-mermaid.DgEHOH9s.chunk.js");
			return { createTreemapServices: e };
		}, []);
		wE.treemap = e().Treemap.parser.LangiumParser;
	}, "treemap")
};
async function wS(e, t) {
	let r = wC[e];
	if (!r) throw Error(`Unknown diagram type: ${e}`);
	wE[e] || await r();
	let i = wE[e].parse(t);
	if (i.lexerErrors.length > 0 || i.parserErrors.length > 0) throw new wA(i);
	return i.value;
}
h(wS, "parse"), bl(wS, "parse");
var wA = class extends Error {
	static {
		h(this, "MermaidParseError");
	}
	constructor(e) {
		super(`Parsing failed: ${e.lexerErrors.map((e) => e.message).join(`
`)} ${e.parserErrors.map((e) => e.message).join(`
`)}`), this.result = e;
	}
	static {
		bl(this, "MermaidParseError");
	}
}, wL = class extends wx {
	static {
		h(this, "PacketTokenBuilder");
	}
	static {
		bl(this, "PacketTokenBuilder");
	}
	constructor() {
		super(["packet"]);
	}
}, wR = { parser: {
	TokenBuilder: bl(() => new wL(), "TokenBuilder"),
	ValueConverter: bl(() => new wv(), "ValueConverter")
} };
function wN(e = br) {
	let t = xW(xj(e), wl), r = xW(xq({ shared: t }), wh, wR);
	return t.ServiceRegistry.register(r), {
		shared: t,
		Packet: r
	};
}
h(wN, "createPacketServices"), bl(wN, "createPacketServices");
var wI = class extends wx {
	static {
		h(this, "PieTokenBuilder");
	}
	static {
		bl(this, "PieTokenBuilder");
	}
	constructor() {
		super(["pie", "showData"]);
	}
}, wM = class extends wy {
	static {
		h(this, "PieValueConverter");
	}
	static {
		bl(this, "PieValueConverter");
	}
	runCustomConverter(e, t, r) {
		if ("PIE_SECTION_LABEL" === e.name) return t.replace(/"/g, "").trim();
	}
}, wD = { parser: {
	TokenBuilder: bl(() => new wI(), "TokenBuilder"),
	ValueConverter: bl(() => new wM(), "ValueConverter")
} };
function wO(e = br) {
	let t = xW(xj(e), wl), r = xW(xq({ shared: t }), wu, wD);
	return t.ServiceRegistry.register(r), {
		shared: t,
		Pie: r
	};
}
h(wO, "createPieServices"), bl(wO, "createPieServices");
var w$ = class extends wx {
	static {
		h(this, "GitGraphTokenBuilder");
	}
	static {
		bl(this, "GitGraphTokenBuilder");
	}
	constructor() {
		super(["gitGraph"]);
	}
}, wP = { parser: {
	TokenBuilder: bl(() => new w$(), "TokenBuilder"),
	ValueConverter: bl(() => new wv(), "ValueConverter")
} };
function wB(e = br) {
	let t = xW(xj(e), wl), r = xW(xq({ shared: t }), wp, wP);
	return t.ServiceRegistry.register(r), {
		shared: t,
		GitGraph: r
	};
}
h(wB, "createGitGraphServices"), bl(wB, "createGitGraphServices");
var wF = class extends wx {
	static {
		h(this, "RadarTokenBuilder");
	}
	static {
		bl(this, "RadarTokenBuilder");
	}
	constructor() {
		super(["radar-beta"]);
	}
}, wz = { parser: {
	TokenBuilder: bl(() => new wF(), "TokenBuilder"),
	ValueConverter: bl(() => new wv(), "ValueConverter")
} };
function wU(e = br) {
	let t = xW(xj(e), wl), r = xW(xq({ shared: t }), wf, wz);
	return t.ServiceRegistry.register(r), {
		shared: t,
		Radar: r
	};
}
h(wU, "createRadarServices"), bl(wU, "createRadarServices");
var wG = class extends wx {
	static {
		h(this, "TreemapTokenBuilder");
	}
	static {
		bl(this, "TreemapTokenBuilder");
	}
	constructor() {
		super(["treemap"]);
	}
}, wq = /classDef\s+([A-Z_a-z]\w+)(?:\s+([^\n\r;]*))?;?/, wj = class extends wy {
	static {
		h(this, "TreemapValueConverter");
	}
	static {
		bl(this, "TreemapValueConverter");
	}
	runCustomConverter(e, t, r) {
		if ("NUMBER2" === e.name) return parseFloat(t.replace(/,/g, ""));
		if ("SEPARATOR" === e.name || "STRING2" === e.name) return t.substring(1, t.length - 1);
		if ("INDENTATION" === e.name) return t.length;
		if ("ClassDef" === e.name) {
			if ("string" != typeof t) return t;
			let e = wq.exec(t);
			if (e) return {
				$type: "ClassDefStatement",
				className: e[1],
				styleText: e[2] || void 0
			};
		}
	}
};
function wW(e) {
	let t = e.validation.TreemapValidator, r = e.validation.ValidationRegistry;
	if (r) {
		let e = { Treemap: t.checkSingleRoot.bind(t) };
		r.register(e, t);
	}
}
h(wW, "registerValidationChecks"), bl(wW, "registerValidationChecks");
var wY = class {
	static {
		h(this, "TreemapValidator");
	}
	static {
		bl(this, "TreemapValidator");
	}
	checkSingleRoot(e, t) {
		let r;
		for (let i of e.TreemapRows) i.item && (void 0 === r && void 0 === i.indent ? r = 0 : void 0 === i.indent ? t("error", "Multiple root nodes are not allowed in a treemap.", {
			node: i,
			property: "item"
		}) : void 0 !== r && r >= parseInt(i.indent, 10) && t("error", "Multiple root nodes are not allowed in a treemap.", {
			node: i,
			property: "item"
		}));
	}
}, wV = {
	parser: {
		TokenBuilder: bl(() => new wG(), "TokenBuilder"),
		ValueConverter: bl(() => new wj(), "ValueConverter")
	},
	validation: { TreemapValidator: bl(() => new wY(), "TreemapValidator") }
};
function wH(e = br) {
	let t = xW(xj(e), wl), r = xW(xq({ shared: t }), wg, wV);
	return t.ServiceRegistry.register(r), wW(r), {
		shared: t,
		Treemap: r
	};
}
h(wH, "createTreemapServices"), bl(wH, "createTreemapServices");
var wX = u((e, t) => {
	var r = e, i = function() {
		var e = "millisecond", t = "second", r = "minute", i = "hour", n = "week", a = "month", s = "quarter", o = "year", l = "date", u = "Invalid Date", d = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, p = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, f = {
			name: "en",
			weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
			months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
			ordinal: h(function(e) {
				var t = [
					"th",
					"st",
					"nd",
					"rd"
				], r = e % 100;
				return "[" + e + (t[(r - 20) % 10] || t[r] || t[0]) + "]";
			}, "ordinal")
		}, g = h(function(e, t, r) {
			var i = String(e);
			return !i || i.length >= t ? e : "" + Array(t + 1 - i.length).join(r) + e;
		}, "m"), m = {
			s: g,
			z: h(function(e) {
				var t = -e.utcOffset(), r = Math.abs(t);
				return (t <= 0 ? "+" : "-") + g(Math.floor(r / 60), 2, "0") + ":" + g(r % 60, 2, "0");
			}, "z"),
			m: h(function e(t, r) {
				if (t.date() < r.date()) return -e(r, t);
				var i = 12 * (r.year() - t.year()) + (r.month() - t.month()), n = t.clone().add(i, a), s = r - n < 0, o = t.clone().add(i + (s ? -1 : 1), a);
				return +(-(i + (r - n) / (s ? n - o : o - n)) || 0);
			}, "t"),
			a: h(function(e) {
				return e < 0 ? Math.ceil(e) || 0 : Math.floor(e);
			}, "a"),
			p: h(function(h) {
				return {
					M: a,
					y: o,
					w: n,
					d: "day",
					D: l,
					h: i,
					m: r,
					s: t,
					ms: e,
					Q: s
				}[h] || String(h || "").toLowerCase().replace(/s$/, "");
			}, "p"),
			u: h(function(e) {
				return void 0 === e;
			}, "u")
		}, y = "en", v = {};
		v[y] = f;
		var x = "$isDayjsObject", b = h(function(e) {
			return e instanceof T || !(!e || !e[x]);
		}, "S"), w = h(function e(t, r, i) {
			var n;
			if (!t) return y;
			if ("string" == typeof t) {
				var a = t.toLowerCase();
				v[a] && (n = a), r && (v[a] = r, n = a);
				var s = t.split("-");
				if (!n && s.length > 1) return e(s[0]);
			} else {
				var o = t.name;
				v[o] = t, n = o;
			}
			return !i && n && (y = n), n || !i && y;
		}, "t"), k = h(function(e, t) {
			if (b(e)) return e.clone();
			var r = "object" == typeof t ? t : {};
			return r.date = e, r.args = arguments, new T(r);
		}, "O");
		m.l = w, m.i = b, m.w = function(e, t) {
			return k(e, {
				locale: t.$L,
				utc: t.$u,
				x: t.$x,
				$offset: t.$offset
			});
		};
		var T = function() {
			function f(e) {
				this.$L = w(e.locale, null, !0), this.parse(e), this.$x = this.$x || e.x || {}, this[x] = !0;
			}
			h(f, "M");
			var g = f.prototype;
			return g.parse = function(e) {
				this.$d = function(e) {
					var t = e.date, r = e.utc;
					if (null === t) return /* @__PURE__ */ new Date(NaN);
					if (m.u(t)) return /* @__PURE__ */ new Date();
					if (t instanceof Date) return new Date(t);
					if ("string" == typeof t && !/Z$/i.test(t)) {
						var i = t.match(d);
						if (i) {
							var n = i[2] - 1 || 0, a = (i[7] || "0").substring(0, 3);
							return r ? new Date(Date.UTC(i[1], n, i[3] || 1, i[4] || 0, i[5] || 0, i[6] || 0, a)) : new Date(i[1], n, i[3] || 1, i[4] || 0, i[5] || 0, i[6] || 0, a);
						}
					}
					return new Date(t);
				}(e), this.init();
			}, g.init = function() {
				var e = this.$d;
				this.$y = e.getFullYear(), this.$M = e.getMonth(), this.$D = e.getDate(), this.$W = e.getDay(), this.$H = e.getHours(), this.$m = e.getMinutes(), this.$s = e.getSeconds(), this.$ms = e.getMilliseconds();
			}, g.$utils = function() {
				return m;
			}, g.isValid = function() {
				return this.$d.toString() !== u;
			}, g.isSame = function(e, t) {
				var r = k(e);
				return this.startOf(t) <= r && r <= this.endOf(t);
			}, g.isAfter = function(e, t) {
				return k(e) < this.startOf(t);
			}, g.isBefore = function(e, t) {
				return this.endOf(t) < k(e);
			}, g.$g = function(e, t, r) {
				return m.u(e) ? this[t] : this.set(r, e);
			}, g.unix = function() {
				return Math.floor(this.valueOf() / 1e3);
			}, g.valueOf = function() {
				return this.$d.getTime();
			}, g.startOf = function(e, s) {
				var u = this, d = !!m.u(s) || s, p = m.p(e), f = h(function(e, t) {
					var r = m.w(u.$u ? Date.UTC(u.$y, t, e) : new Date(u.$y, t, e), u);
					return d ? r : r.endOf("day");
				}, "l"), g = h(function(e, t) {
					return m.w(u.toDate()[e].apply(u.toDate("s"), (d ? [
						0,
						0,
						0,
						0
					] : [
						23,
						59,
						59,
						999
					]).slice(t)), u);
				}, "$"), y = this.$W, v = this.$M, x = this.$D, b = "set" + (this.$u ? "UTC" : "");
				switch (p) {
					case o: return d ? f(1, 0) : f(31, 11);
					case a: return d ? f(1, v) : f(0, v + 1);
					case n:
						var w = this.$locale().weekStart || 0, k = (y < w ? y + 7 : y) - w;
						return f(d ? x - k : x + (6 - k), v);
					case "day":
					case l: return g(b + "Hours", 0);
					case i: return g(b + "Minutes", 1);
					case r: return g(b + "Seconds", 2);
					case t: return g(b + "Milliseconds", 3);
					default: return this.clone();
				}
			}, g.endOf = function(e) {
				return this.startOf(e, !1);
			}, g.$set = function(n, s) {
				var h, u = m.p(n), d = "set" + (this.$u ? "UTC" : ""), p = ((h = {}).day = d + "Date", h[l] = d + "Date", h[a] = d + "Month", h[o] = d + "FullYear", h[i] = d + "Hours", h[r] = d + "Minutes", h[t] = d + "Seconds", h[e] = d + "Milliseconds", h)[u], f = "day" === u ? this.$D + (s - this.$W) : s;
				if (u === a || u === o) {
					var g = this.clone().set(l, 1);
					g.$d[p](f), g.init(), this.$d = g.set(l, Math.min(this.$D, g.daysInMonth())).$d;
				} else p && this.$d[p](f);
				return this.init(), this;
			}, g.set = function(e, t) {
				return this.clone().$set(e, t);
			}, g.get = function(e) {
				return this[m.p(e)]();
			}, g.add = function(e, s) {
				var l, u = this;
				e = Number(e);
				var d = m.p(s), p = h(function(t) {
					var r = k(u);
					return m.w(r.date(r.date() + Math.round(t * e)), u);
				}, "y");
				if (d === a) return this.set(a, this.$M + e);
				if (d === o) return this.set(o, this.$y + e);
				if ("day" === d) return p(1);
				if (d === n) return p(7);
				var f = ((l = {})[r] = 6e4, l[i] = 36e5, l[t] = 1e3, l)[d] || 1, g = this.$d.getTime() + e * f;
				return m.w(g, this);
			}, g.subtract = function(e, t) {
				return this.add(-1 * e, t);
			}, g.format = function(e) {
				var t = this, r = this.$locale();
				if (!this.isValid()) return r.invalidDate || u;
				var i = e || "YYYY-MM-DDTHH:mm:ssZ", n = m.z(this), a = this.$H, s = this.$m, o = this.$M, l = r.weekdays, d = r.months, f = r.meridiem, g = h(function(e, r, n, a) {
					return e && (e[r] || e(t, i)) || n[r].slice(0, a);
				}, "h"), y = h(function(e) {
					return m.s(a % 12 || 12, e, "0");
				}, "d"), v = f || function(e, t, r) {
					var i = e < 12 ? "AM" : "PM";
					return r ? i.toLowerCase() : i;
				};
				return i.replace(p, function(e, i) {
					return i || function(e) {
						switch (e) {
							case "YY": return String(t.$y).slice(-2);
							case "YYYY": return m.s(t.$y, 4, "0");
							case "M": return o + 1;
							case "MM": return m.s(o + 1, 2, "0");
							case "MMM": return g(r.monthsShort, o, d, 3);
							case "MMMM": return g(d, o);
							case "D": return t.$D;
							case "DD": return m.s(t.$D, 2, "0");
							case "d": return String(t.$W);
							case "dd": return g(r.weekdaysMin, t.$W, l, 2);
							case "ddd": return g(r.weekdaysShort, t.$W, l, 3);
							case "dddd": return l[t.$W];
							case "H": return String(a);
							case "HH": return m.s(a, 2, "0");
							case "h": return y(1);
							case "hh": return y(2);
							case "a": return v(a, s, !0);
							case "A": return v(a, s, !1);
							case "m": return String(s);
							case "mm": return m.s(s, 2, "0");
							case "s": return String(t.$s);
							case "ss": return m.s(t.$s, 2, "0");
							case "SSS": return m.s(t.$ms, 3, "0");
							case "Z": return n;
						}
						return null;
					}(e) || n.replace(":", "");
				});
			}, g.utcOffset = function() {
				return -(15 * Math.round(this.$d.getTimezoneOffset() / 15));
			}, g.diff = function(e, l, u) {
				var d, p = this, f = m.p(l), g = k(e), y = (g.utcOffset() - this.utcOffset()) * 6e4, v = this - g, x = h(function() {
					return m.m(p, g);
				}, "D");
				switch (f) {
					case o:
						d = x() / 12;
						break;
					case a:
						d = x();
						break;
					case s:
						d = x() / 3;
						break;
					case n:
						d = (v - y) / 6048e5;
						break;
					case "day":
						d = (v - y) / 864e5;
						break;
					case i:
						d = v / 36e5;
						break;
					case r:
						d = v / 6e4;
						break;
					case t:
						d = v / 1e3;
						break;
					default: d = v;
				}
				return u ? d : m.a(d);
			}, g.daysInMonth = function() {
				return this.endOf(a).$D;
			}, g.$locale = function() {
				return v[this.$L];
			}, g.locale = function(e, t) {
				if (!e) return this.$L;
				var r = this.clone(), i = w(e, t, !0);
				return i && (r.$L = i), r;
			}, g.clone = function() {
				return m.w(this.$d, this);
			}, g.toDate = function() {
				return new Date(this.valueOf());
			}, g.toJSON = function() {
				return this.isValid() ? this.toISOString() : null;
			}, g.toISOString = function() {
				return this.$d.toISOString();
			}, g.toString = function() {
				return this.$d.toUTCString();
			}, f;
		}(), _ = T.prototype;
		return k.prototype = _, [
			["$ms", e],
			["$s", t],
			["$m", r],
			["$H", i],
			["$W", "day"],
			["$M", a],
			["$y", o],
			["$D", l]
		].forEach(function(e) {
			_[e[1]] = function(t) {
				return this.$g(t, e[0], e[1]);
			};
		}), k.extend = function(e, t) {
			return e.$i || (e(t, T, k), e.$i = !0), k;
		}, k.locale = w, k.isDayjs = b, k.unix = function(e) {
			return k(1e3 * e);
		}, k.en = v[y], k.Ls = v, k.p = {}, k;
	};
	"object" == typeof e && "u" > typeof t ? t.exports = i() : "function" == typeof define && define.amd ? define(i) : (r = "u" > typeof globalThis ? globalThis : r || self).dayjs = i();
}), wK = g(wX(), 1), wZ = {
	trace: 0,
	debug: 1,
	info: 2,
	warn: 3,
	error: 4,
	fatal: 5
}, wQ = {
	trace: h((...e) => {}, "trace"),
	debug: h((...e) => {}, "debug"),
	info: h((...e) => {}, "info"),
	warn: h((...e) => {}, "warn"),
	error: h((...e) => {}, "error"),
	fatal: h((...e) => {}, "fatal")
}, wJ = h(function(e = "fatal") {
	let t = wZ.fatal;
	"string" == typeof e ? e.toLowerCase() in wZ && (t = wZ[e]) : "number" == typeof e && (t = e), wQ.trace = () => {}, wQ.debug = () => {}, wQ.info = () => {}, wQ.warn = () => {}, wQ.error = () => {}, wQ.fatal = () => {}, t <= wZ.fatal && (wQ.fatal = console.error ? console.error.bind(console, w0("FATAL"), "color: orange") : console.log.bind(console, "\x1B[35m", w0("FATAL"))), t <= wZ.error && (wQ.error = console.error ? console.error.bind(console, w0("ERROR"), "color: orange") : console.log.bind(console, "\x1B[31m", w0("ERROR"))), t <= wZ.warn && (wQ.warn = console.warn ? console.warn.bind(console, w0("WARN"), "color: orange") : console.log.bind(console, "\x1B[33m", w0("WARN"))), t <= wZ.info && (wQ.info = console.info ? console.info.bind(console, w0("INFO"), "color: lightblue") : console.log.bind(console, "\x1B[34m", w0("INFO"))), t <= wZ.debug && (wQ.debug = console.debug ? console.debug.bind(console, w0("DEBUG"), "color: lightgreen") : console.log.bind(console, "\x1B[32m", w0("DEBUG"))), t <= wZ.trace && (wQ.trace = console.debug ? console.debug.bind(console, w0("TRACE"), "color: lightgreen") : console.log.bind(console, "\x1B[32m", w0("TRACE")));
}, "setLogLevel"), w0 = h((e) => `%c${(0, wK.default)().format("ss.SSS")} : ${e} : `, "format");
function w1(e, t) {
	let r;
	if (void 0 === t) for (let t of e) null != t && (r < t || void 0 === r && t >= t) && (r = t);
	else {
		let i = -1;
		for (let n of e) null != (n = t(n, ++i, e)) && (r < n || void 0 === r && n >= n) && (r = n);
	}
	return r;
}
function w2(e, t) {
	let r;
	if (void 0 === t) for (let t of e) null != t && (r > t || void 0 === r && t >= t) && (r = t);
	else {
		let i = -1;
		for (let n of e) null != (n = t(n, ++i, e)) && (r > n || void 0 === r && n >= n) && (r = n);
	}
	return r;
}
function w4(e, t) {
	return null == e || null == t ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function w5(e, t) {
	return null == e || null == t ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function w3(e) {
	let t, r, i;
	function n(e, i, a = 0, s = e.length) {
		if (a < s) {
			if (0 !== t(i, i)) return s;
			do {
				let t = a + s >>> 1;
				0 > r(e[t], i) ? a = t + 1 : s = t;
			} while (a < s);
		}
		return a;
	}
	function a(e, i, n = 0, s = e.length) {
		if (n < s) {
			if (0 !== t(i, i)) return s;
			do {
				let t = n + s >>> 1;
				0 >= r(e[t], i) ? n = t + 1 : s = t;
			} while (n < s);
		}
		return n;
	}
	function s(e, t, r = 0, a = e.length) {
		let o = n(e, t, r, a - 1);
		return o > r && i(e[o - 1], t) > -i(e[o], t) ? o - 1 : o;
	}
	return 2 !== e.length ? (t = w4, r = h((t, r) => w4(e(t), r), "compare2"), i = h((t, r) => e(t) - r, "delta")) : (t = e === w4 || e === w5 ? e : w6, r = e, i = e), h(n, "left"), h(a, "right"), h(s, "center"), {
		left: n,
		center: s,
		right: a
	};
}
function w6() {
	return 0;
}
function w7(e) {
	return null === e ? NaN : +e;
}
h(w1, "max"), h(w2, "min"), h(w4, "ascending"), h(w5, "descending"), h(w3, "bisector"), h(w6, "zero"), h(w7, "number");
var w8 = w3(w4), w9 = w8.right;
w8.left, w3(w7).center;
var ke = class extends Map {
	static {
		h(this, "InternMap");
	}
	constructor(e, t = kn) {
		if (super(), Object.defineProperties(this, {
			_intern: { value: /* @__PURE__ */ new Map() },
			_key: { value: t }
		}), null != e) for (let [t, r] of e) this.set(t, r);
	}
	get(e) {
		return super.get(kt(this, e));
	}
	has(e) {
		return super.has(kt(this, e));
	}
	set(e, t) {
		return super.set(kr(this, e), t);
	}
	delete(e) {
		return super.delete(ki(this, e));
	}
};
function kt({ _intern: e, _key: t }, r) {
	let i = t(r);
	return e.has(i) ? e.get(i) : r;
}
function kr({ _intern: e, _key: t }, r) {
	let i = t(r);
	return e.has(i) ? e.get(i) : (e.set(i, r), r);
}
function ki({ _intern: e, _key: t }, r) {
	let i = t(r);
	return e.has(i) && (r = e.get(i), e.delete(i)), r;
}
function kn(e) {
	return null !== e && "object" == typeof e ? e.valueOf() : e;
}
h(kt, "intern_get"), h(kr, "intern_set"), h(ki, "intern_delete"), h(kn, "keyof");
var ka = Math.sqrt(50), ks = Math.sqrt(10), ko = Math.sqrt(2);
function kl(e, t, r) {
	let i = (t - e) / Math.max(0, r), n = Math.floor(Math.log10(i)), a = i / Math.pow(10, n), s = a >= ka ? 10 : a >= ks ? 5 : a >= ko ? 2 : 1, o, l, h;
	return n < 0 ? (o = Math.round(e * (h = Math.pow(10, -n) / s)), l = Math.round(t * h), o / h < e && ++o, l / h > t && --l, h = -h) : (o = Math.round(e / (h = Math.pow(10, n) * s)), l = Math.round(t / h), o * h < e && ++o, l * h > t && --l), l < o && .5 <= r && r < 2 ? kl(e, t, 2 * r) : [
		o,
		l,
		h
	];
}
function kc(e, t, r) {
	if (t *= 1, e *= 1, !((r *= 1) > 0)) return [];
	if (e === t) return [e];
	let i = t < e, [n, a, s] = i ? kl(t, e, r) : kl(e, t, r);
	if (!(a >= n)) return [];
	let o = a - n + 1, l = Array(o);
	if (i) if (s < 0) for (let e = 0; e < o; ++e) l[e] = -((a - e) / s);
	else for (let e = 0; e < o; ++e) l[e] = (a - e) * s;
	else if (s < 0) for (let e = 0; e < o; ++e) l[e] = -((n + e) / s);
	else for (let e = 0; e < o; ++e) l[e] = (n + e) * s;
	return l;
}
function kh(e, t, r) {
	return kl(e *= 1, t *= 1, r *= 1)[2];
}
function ku(e, t, r) {
	t *= 1, e *= 1, r *= 1;
	let i = t < e, n = i ? kh(t, e, r) : kh(e, t, r);
	return (i ? -1 : 1) * (n < 0 ? -(1 / n) : n);
}
function kd(e, t, r) {
	e *= 1, t *= 1, r = (n = arguments.length) < 2 ? (t = e, e = 0, 1) : n < 3 ? 1 : +r;
	for (var i = -1, n = 0 | Math.max(0, Math.ceil((t - e) / r)), a = Array(n); ++i < n;) a[i] = e + i * r;
	return a;
}
function kp(e) {
	return e;
}
function kf(e) {
	return "translate(" + e + ",0)";
}
function kg(e) {
	return "translate(0," + e + ")";
}
function km(e) {
	return (t) => +e(t);
}
function ky(e, t) {
	return t = Math.max(0, e.bandwidth() - 2 * t) / 2, e.round() && (t = Math.round(t)), (r) => +e(r) + t;
}
function kv() {
	return !this.__axis;
}
function kx(e, t) {
	var r = [], i = null, n = null, a = 6, s = 6, o = 3, l = "u" > typeof window && window.devicePixelRatio > 1 ? 0 : .5, u = 1 === e || 4 === e ? -1 : 1, d = 4 === e || 2 === e ? "x" : "y", p = 1 === e || 3 === e ? kf : kg;
	function f(h) {
		var f = i ?? (t.ticks ? t.ticks.apply(t, r) : t.domain()), g = n ?? (t.tickFormat ? t.tickFormat.apply(t, r) : kp), m = Math.max(a, 0) + o, y = t.range(), v = +y[0] + l, x = +y[y.length - 1] + l, b = (t.bandwidth ? ky : km)(t.copy(), l), w = h.selection ? h.selection() : h, k = w.selectAll(".domain").data([null]), T = w.selectAll(".tick").data(f, t).order(), _ = T.exit(), E = T.enter().append("g").attr("class", "tick"), C = T.select("line"), S = T.select("text");
		k = k.merge(k.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor")), T = T.merge(E), C = C.merge(E.append("line").attr("stroke", "currentColor").attr(d + "2", u * a)), S = S.merge(E.append("text").attr("fill", "currentColor").attr(d, u * m).attr("dy", 1 === e ? "0em" : 3 === e ? "0.71em" : "0.32em")), h !== w && (k = k.transition(h), T = T.transition(h), C = C.transition(h), S = S.transition(h), _ = _.transition(h).attr("opacity", 1e-6).attr("transform", function(e) {
			return isFinite(e = b(e)) ? p(e + l) : this.getAttribute("transform");
		}), E.attr("opacity", 1e-6).attr("transform", function(e) {
			var t = this.parentNode.__axis;
			return p((t && isFinite(t = t(e)) ? t : b(e)) + l);
		})), _.remove(), k.attr("d", 4 === e || 2 === e ? s ? "M" + u * s + "," + v + "H" + l + "V" + x + "H" + u * s : "M" + l + "," + v + "V" + x : s ? "M" + v + "," + u * s + "V" + l + "H" + x + "V" + u * s : "M" + v + "," + l + "H" + x), T.attr("opacity", 1).attr("transform", function(e) {
			return p(b(e) + l);
		}), C.attr(d + "2", u * a), S.attr(d, u * m).text(g), w.filter(kv).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", 2 === e ? "start" : 4 === e ? "end" : "middle"), w.each(function() {
			this.__axis = b;
		});
	}
	return h(f, "axis"), f.scale = function(e) {
		return arguments.length ? (t = e, f) : t;
	}, f.ticks = function() {
		return r = Array.from(arguments), f;
	}, f.tickArguments = function(e) {
		return arguments.length ? (r = null == e ? [] : Array.from(e), f) : r.slice();
	}, f.tickValues = function(e) {
		return arguments.length ? (i = null == e ? null : Array.from(e), f) : i && i.slice();
	}, f.tickFormat = function(e) {
		return arguments.length ? (n = e, f) : n;
	}, f.tickSize = function(e) {
		return arguments.length ? (a = s = +e, f) : a;
	}, f.tickSizeInner = function(e) {
		return arguments.length ? (a = +e, f) : a;
	}, f.tickSizeOuter = function(e) {
		return arguments.length ? (s = +e, f) : s;
	}, f.tickPadding = function(e) {
		return arguments.length ? (o = +e, f) : o;
	}, f.offset = function(e) {
		return arguments.length ? (l = +e, f) : l;
	}, f;
}
function kb(e) {
	return kx(1, e);
}
function kw(e) {
	return kx(3, e);
}
function kk() {}
function kT(e) {
	return null == e ? kk : function() {
		return this.querySelector(e);
	};
}
function k_(e) {
	"function" != typeof e && (e = kT(e));
	for (var t = this._groups, r = t.length, i = Array(r), n = 0; n < r; ++n) for (var a, s, o = t[n], l = o.length, h = i[n] = Array(l), u = 0; u < l; ++u) (a = o[u]) && (s = e.call(a, a.__data__, u, o)) && ("__data__" in a && (s.__data__ = a.__data__), h[u] = s);
	return new T8(i, this._parents);
}
function kE(e) {
	return null == e ? [] : Array.isArray(e) ? e : Array.from(e);
}
function kC() {
	return [];
}
function kS(e) {
	return null == e ? kC : function() {
		return this.querySelectorAll(e);
	};
}
function kA(e) {
	return function() {
		return kE(e.apply(this, arguments));
	};
}
function kL(e) {
	e = "function" == typeof e ? kA(e) : kS(e);
	for (var t = this._groups, r = t.length, i = [], n = [], a = 0; a < r; ++a) for (var s, o = t[a], l = o.length, h = 0; h < l; ++h) (s = o[h]) && (i.push(e.call(s, s.__data__, h, o)), n.push(s));
	return new T8(i, n);
}
function kR(e) {
	return function() {
		return this.matches(e);
	};
}
function kN(e) {
	return function(t) {
		return t.matches(e);
	};
}
h(kl, "tickSpec"), h(kc, "ticks"), h(kh, "tickIncrement"), h(ku, "tickStep"), h(kd, "range"), h(kp, "default"), h(kf, "translateX"), h(kg, "translateY"), h(km, "number"), h(ky, "center"), h(kv, "entering"), h(kx, "axis"), h(kb, "axisTop"), h(kw, "axisBottom"), h(kk, "none"), h(kT, "default"), h(k_, "default"), h(kE, "array"), h(kC, "empty"), h(kS, "default"), h(kA, "arrayAll"), h(kL, "default"), h(kR, "default"), h(kN, "childMatcher");
var kI = Array.prototype.find;
function kM(e) {
	return function() {
		return kI.call(this.children, e);
	};
}
function kD() {
	return this.firstElementChild;
}
function kO(e) {
	return this.select(null == e ? kD : kM("function" == typeof e ? e : kN(e)));
}
h(kM, "childFind"), h(kD, "childFirst"), h(kO, "default");
var k$ = Array.prototype.filter;
function kP() {
	return Array.from(this.children);
}
function kB(e) {
	return function() {
		return k$.call(this.children, e);
	};
}
function kF(e) {
	return this.selectAll(null == e ? kP : kB("function" == typeof e ? e : kN(e)));
}
function kz(e) {
	"function" != typeof e && (e = kR(e));
	for (var t = this._groups, r = t.length, i = Array(r), n = 0; n < r; ++n) for (var a, s = t[n], o = s.length, l = i[n] = [], h = 0; h < o; ++h) (a = s[h]) && e.call(a, a.__data__, h, s) && l.push(a);
	return new T8(i, this._parents);
}
function kU(e) {
	return Array(e.length);
}
function kG() {
	return new T8(this._enter || this._groups.map(kU), this._parents);
}
function kq(e, t) {
	this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
}
function kj(e) {
	return function() {
		return e;
	};
}
function kW(e, t, r, i, n, a) {
	for (var s, o = 0, l = t.length, h = a.length; o < h; ++o) (s = t[o]) ? (s.__data__ = a[o], i[o] = s) : r[o] = new kq(e, a[o]);
	for (; o < l; ++o) (s = t[o]) && (n[o] = s);
}
function kY(e, t, r, i, n, a, s) {
	var o, l, h, u = /* @__PURE__ */ new Map(), d = t.length, p = a.length, f = Array(d);
	for (o = 0; o < d; ++o) (l = t[o]) && (f[o] = h = s.call(l, l.__data__, o, t) + "", u.has(h) ? n[o] = l : u.set(h, l));
	for (o = 0; o < p; ++o) h = s.call(e, a[o], o, a) + "", (l = u.get(h)) ? (i[o] = l, l.__data__ = a[o], u.delete(h)) : r[o] = new kq(e, a[o]);
	for (o = 0; o < d; ++o) (l = t[o]) && u.get(f[o]) === l && (n[o] = l);
}
function kV(e) {
	return e.__data__;
}
function kH(e, t) {
	if (!arguments.length) return Array.from(this, kV);
	var r = t ? kY : kW, i = this._parents, n = this._groups;
	"function" != typeof e && (e = kj(e));
	for (var a = n.length, s = Array(a), o = Array(a), l = Array(a), h = 0; h < a; ++h) {
		var u = i[h], d = n[h], p = d.length, f = kX(e.call(u, u && u.__data__, h, i)), g = f.length, m = o[h] = Array(g), y = s[h] = Array(g);
		r(u, d, m, y, l[h] = Array(p), f, t);
		for (var v, x, b = 0, w = 0; b < g; ++b) if (v = m[b]) {
			for (b >= w && (w = b + 1); !(x = y[w]) && ++w < g;);
			v._next = x || null;
		}
	}
	return (s = new T8(s, i))._enter = o, s._exit = l, s;
}
function kX(e) {
	return "object" == typeof e && "length" in e ? e : Array.from(e);
}
function kK() {
	return new T8(this._exit || this._groups.map(kU), this._parents);
}
function kZ(e, t, r) {
	var i = this.enter(), n = this, a = this.exit();
	return "function" == typeof e ? (i = e(i)) && (i = i.selection()) : i = i.append(e + ""), null != t && (n = t(n)) && (n = n.selection()), null == r ? a.remove() : r(a), i && n ? i.merge(n).order() : n;
}
function kQ(e) {
	for (var t = e.selection ? e.selection() : e, r = this._groups, i = t._groups, n = r.length, a = i.length, s = Math.min(n, a), o = Array(n), l = 0; l < s; ++l) for (var h, u = r[l], d = i[l], p = u.length, f = o[l] = Array(p), g = 0; g < p; ++g) (h = u[g] || d[g]) && (f[g] = h);
	for (; l < n; ++l) o[l] = r[l];
	return new T8(o, this._parents);
}
function kJ() {
	for (var e = this._groups, t = -1, r = e.length; ++t < r;) for (var i, n = e[t], a = n.length - 1, s = n[a]; --a >= 0;) (i = n[a]) && (s && 4 ^ i.compareDocumentPosition(s) && s.parentNode.insertBefore(i, s), s = i);
	return this;
}
function k0(e) {
	function t(t, r) {
		return t && r ? e(t.__data__, r.__data__) : !t - !r;
	}
	e || (e = k1), h(t, "compareNode");
	for (var r = this._groups, i = r.length, n = Array(i), a = 0; a < i; ++a) {
		for (var s, o = r[a], l = o.length, u = n[a] = Array(l), d = 0; d < l; ++d) (s = o[d]) && (u[d] = s);
		u.sort(t);
	}
	return new T8(n, this._parents).order();
}
function k1(e, t) {
	return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function k2() {
	var e = arguments[0];
	return arguments[0] = this, e.apply(null, arguments), this;
}
function k4() {
	return Array.from(this);
}
function k5() {
	for (var e = this._groups, t = 0, r = e.length; t < r; ++t) for (var i = e[t], n = 0, a = i.length; n < a; ++n) {
		var s = i[n];
		if (s) return s;
	}
	return null;
}
function k3() {
	let e = 0;
	for (let t of this) ++e;
	return e;
}
function k6() {
	return !this.node();
}
function k7(e) {
	for (var t = this._groups, r = 0, i = t.length; r < i; ++r) for (var n, a = t[r], s = 0, o = a.length; s < o; ++s) (n = a[s]) && e.call(n, n.__data__, s, a);
	return this;
}
h(kP, "children"), h(kB, "childrenFilter"), h(kF, "default"), h(kz, "default"), h(kU, "default"), h(kG, "default"), h(kq, "EnterNode"), kq.prototype = {
	constructor: kq,
	appendChild: h(function(e) {
		return this._parent.insertBefore(e, this._next);
	}, "appendChild"),
	insertBefore: h(function(e, t) {
		return this._parent.insertBefore(e, t);
	}, "insertBefore"),
	querySelector: h(function(e) {
		return this._parent.querySelector(e);
	}, "querySelector"),
	querySelectorAll: h(function(e) {
		return this._parent.querySelectorAll(e);
	}, "querySelectorAll")
}, h(kj, "default"), h(kW, "bindIndex"), h(kY, "bindKey"), h(kV, "datum"), h(kH, "default"), h(kX, "arraylike"), h(kK, "default"), h(kZ, "default"), h(kQ, "default"), h(kJ, "default"), h(k0, "default"), h(k1, "ascending"), h(k2, "default"), h(k4, "default"), h(k5, "default"), h(k3, "default"), h(k6, "default"), h(k7, "default");
var k8 = "http://www.w3.org/1999/xhtml", k9 = {
	svg: "http://www.w3.org/2000/svg",
	xhtml: k8,
	xlink: "http://www.w3.org/1999/xlink",
	xml: "http://www.w3.org/XML/1998/namespace",
	xmlns: "http://www.w3.org/2000/xmlns/"
};
function Te(e) {
	var t = e += "", r = t.indexOf(":");
	return r >= 0 && "xmlns" !== (t = e.slice(0, r)) && (e = e.slice(r + 1)), k9.hasOwnProperty(t) ? {
		space: k9[t],
		local: e
	} : e;
}
function Tt(e) {
	return function() {
		this.removeAttribute(e);
	};
}
function Tr(e) {
	return function() {
		this.removeAttributeNS(e.space, e.local);
	};
}
function Ti(e, t) {
	return function() {
		this.setAttribute(e, t);
	};
}
function Tn(e, t) {
	return function() {
		this.setAttributeNS(e.space, e.local, t);
	};
}
function Ta(e, t) {
	return function() {
		var r = t.apply(this, arguments);
		null == r ? this.removeAttribute(e) : this.setAttribute(e, r);
	};
}
function Ts(e, t) {
	return function() {
		var r = t.apply(this, arguments);
		null == r ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, r);
	};
}
function To(e, t) {
	var r = Te(e);
	if (arguments.length < 2) {
		var i = this.node();
		return r.local ? i.getAttributeNS(r.space, r.local) : i.getAttribute(r);
	}
	return this.each((null == t ? r.local ? Tr : Tt : "function" == typeof t ? r.local ? Ts : Ta : r.local ? Tn : Ti)(r, t));
}
function Tl(e) {
	return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
}
function Tc(e) {
	return function() {
		this.style.removeProperty(e);
	};
}
function Th(e, t, r) {
	return function() {
		this.style.setProperty(e, t, r);
	};
}
function Tu(e, t, r) {
	return function() {
		var i = t.apply(this, arguments);
		null == i ? this.style.removeProperty(e) : this.style.setProperty(e, i, r);
	};
}
function Td(e, t, r) {
	return arguments.length > 1 ? this.each((null == t ? Tc : "function" == typeof t ? Tu : Th)(e, t, r ?? "")) : Tp(this.node(), e);
}
function Tp(e, t) {
	return e.style.getPropertyValue(t) || Tl(e).getComputedStyle(e, null).getPropertyValue(t);
}
function Tf(e) {
	return function() {
		delete this[e];
	};
}
function Tg(e, t) {
	return function() {
		this[e] = t;
	};
}
function Tm(e, t) {
	return function() {
		var r = t.apply(this, arguments);
		null == r ? delete this[e] : this[e] = r;
	};
}
function Ty(e, t) {
	return arguments.length > 1 ? this.each((null == t ? Tf : "function" == typeof t ? Tm : Tg)(e, t)) : this.node()[e];
}
function Tv(e) {
	return e.trim().split(/^|\s+/);
}
function Tx(e) {
	return e.classList || new Tb(e);
}
function Tb(e) {
	this._node = e, this._names = Tv(e.getAttribute("class") || "");
}
function Tw(e, t) {
	for (var r = Tx(e), i = -1, n = t.length; ++i < n;) r.add(t[i]);
}
function Tk(e, t) {
	for (var r = Tx(e), i = -1, n = t.length; ++i < n;) r.remove(t[i]);
}
function TT(e) {
	return function() {
		Tw(this, e);
	};
}
function T_(e) {
	return function() {
		Tk(this, e);
	};
}
function TE(e, t) {
	return function() {
		(t.apply(this, arguments) ? Tw : Tk)(this, e);
	};
}
function TC(e, t) {
	var r = Tv(e + "");
	if (arguments.length < 2) {
		for (var i = Tx(this.node()), n = -1, a = r.length; ++n < a;) if (!i.contains(r[n])) return !1;
		return !0;
	}
	return this.each(("function" == typeof t ? TE : t ? TT : T_)(r, t));
}
function TS() {
	this.textContent = "";
}
function TA(e) {
	return function() {
		this.textContent = e;
	};
}
function TL(e) {
	return function() {
		this.textContent = e.apply(this, arguments) ?? "";
	};
}
function TR(e) {
	return arguments.length ? this.each(null == e ? TS : ("function" == typeof e ? TL : TA)(e)) : this.node().textContent;
}
function TN() {
	this.innerHTML = "";
}
function TI(e) {
	return function() {
		this.innerHTML = e;
	};
}
function TM(e) {
	return function() {
		this.innerHTML = e.apply(this, arguments) ?? "";
	};
}
function TD(e) {
	return arguments.length ? this.each(null == e ? TN : ("function" == typeof e ? TM : TI)(e)) : this.node().innerHTML;
}
function TO() {
	this.nextSibling && this.parentNode.appendChild(this);
}
function T$() {
	return this.each(TO);
}
function TP() {
	this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function TB() {
	return this.each(TP);
}
function TF(e) {
	return function() {
		var t = this.ownerDocument, r = this.namespaceURI;
		return r === k8 && t.documentElement.namespaceURI === k8 ? t.createElement(e) : t.createElementNS(r, e);
	};
}
function Tz(e) {
	return function() {
		return this.ownerDocument.createElementNS(e.space, e.local);
	};
}
function TU(e) {
	var t = Te(e);
	return (t.local ? Tz : TF)(t);
}
function TG(e) {
	var t = "function" == typeof e ? e : TU(e);
	return this.select(function() {
		return this.appendChild(t.apply(this, arguments));
	});
}
function Tq() {
	return null;
}
function Tj(e, t) {
	var r = "function" == typeof e ? e : TU(e), i = null == t ? Tq : "function" == typeof t ? t : kT(t);
	return this.select(function() {
		return this.insertBefore(r.apply(this, arguments), i.apply(this, arguments) || null);
	});
}
function TW() {
	var e = this.parentNode;
	e && e.removeChild(this);
}
function TY() {
	return this.each(TW);
}
function TV() {
	var e = this.cloneNode(!1), t = this.parentNode;
	return t ? t.insertBefore(e, this.nextSibling) : e;
}
function TH() {
	var e = this.cloneNode(!0), t = this.parentNode;
	return t ? t.insertBefore(e, this.nextSibling) : e;
}
function TX(e) {
	return this.select(e ? TH : TV);
}
function TK(e) {
	return arguments.length ? this.property("__data__", e) : this.node().__data__;
}
function TZ(e) {
	return function(t) {
		e.call(this, t, this.__data__);
	};
}
function TQ(e) {
	return e.trim().split(/^|\s+/).map(function(e) {
		var t = "", r = e.indexOf(".");
		return r >= 0 && (t = e.slice(r + 1), e = e.slice(0, r)), {
			type: e,
			name: t
		};
	});
}
function TJ(e) {
	return function() {
		var t = this.__on;
		if (t) {
			for (var r, i = 0, n = -1, a = t.length; i < a; ++i) r = t[i], e.type && r.type !== e.type || r.name !== e.name ? t[++n] = r : this.removeEventListener(r.type, r.listener, r.options);
			++n ? t.length = n : delete this.__on;
		}
	};
}
function T0(e, t, r) {
	return function() {
		var i, n = this.__on, a = TZ(t);
		if (n) {
			for (var s = 0, o = n.length; s < o; ++s) if ((i = n[s]).type === e.type && i.name === e.name) {
				this.removeEventListener(i.type, i.listener, i.options), this.addEventListener(i.type, i.listener = a, i.options = r), i.value = t;
				return;
			}
		}
		this.addEventListener(e.type, a, r), i = {
			type: e.type,
			name: e.name,
			value: t,
			listener: a,
			options: r
		}, n ? n.push(i) : this.__on = [i];
	};
}
function T1(e, t, r) {
	var i, n, a = TQ(e + ""), s = a.length;
	if (arguments.length < 2) {
		var o = this.node().__on;
		if (o) {
			for (var l, h = 0, u = o.length; h < u; ++h) for (i = 0, l = o[h]; i < s; ++i) if ((n = a[i]).type === l.type && n.name === l.name) return l.value;
		}
		return;
	}
	for (o = t ? T0 : TJ, i = 0; i < s; ++i) this.each(o(a[i], t, r));
	return this;
}
function T2(e, t, r) {
	var i = Tl(e), n = i.CustomEvent;
	"function" == typeof n ? n = new n(t, r) : (n = i.document.createEvent("Event"), r ? (n.initEvent(t, r.bubbles, r.cancelable), n.detail = r.detail) : n.initEvent(t, !1, !1)), e.dispatchEvent(n);
}
function T4(e, t) {
	return function() {
		return T2(this, e, t);
	};
}
function T5(e, t) {
	return function() {
		return T2(this, e, t.apply(this, arguments));
	};
}
function T3(e, t) {
	return this.each(("function" == typeof t ? T5 : T4)(e, t));
}
function* T6() {
	for (var e = this._groups, t = 0, r = e.length; t < r; ++t) for (var i, n = e[t], a = 0, s = n.length; a < s; ++a) (i = n[a]) && (yield i);
}
h(Te, "default"), h(Tt, "attrRemove"), h(Tr, "attrRemoveNS"), h(Ti, "attrConstant"), h(Tn, "attrConstantNS"), h(Ta, "attrFunction"), h(Ts, "attrFunctionNS"), h(To, "default"), h(Tl, "default"), h(Tc, "styleRemove"), h(Th, "styleConstant"), h(Tu, "styleFunction"), h(Td, "default"), h(Tp, "styleValue"), h(Tf, "propertyRemove"), h(Tg, "propertyConstant"), h(Tm, "propertyFunction"), h(Ty, "default"), h(Tv, "classArray"), h(Tx, "classList"), h(Tb, "ClassList"), Tb.prototype = {
	add: h(function(e) {
		0 > this._names.indexOf(e) && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
	}, "add"),
	remove: h(function(e) {
		var t = this._names.indexOf(e);
		t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
	}, "remove"),
	contains: h(function(e) {
		return this._names.indexOf(e) >= 0;
	}, "contains")
}, h(Tw, "classedAdd"), h(Tk, "classedRemove"), h(TT, "classedTrue"), h(T_, "classedFalse"), h(TE, "classedFunction"), h(TC, "default"), h(TS, "textRemove"), h(TA, "textConstant"), h(TL, "textFunction"), h(TR, "default"), h(TN, "htmlRemove"), h(TI, "htmlConstant"), h(TM, "htmlFunction"), h(TD, "default"), h(TO, "raise"), h(T$, "default"), h(TP, "lower"), h(TB, "default"), h(TF, "creatorInherit"), h(Tz, "creatorFixed"), h(TU, "default"), h(TG, "default"), h(Tq, "constantNull"), h(Tj, "default"), h(TW, "remove"), h(TY, "default"), h(TV, "selection_cloneShallow"), h(TH, "selection_cloneDeep"), h(TX, "default"), h(TK, "default"), h(TZ, "contextListener"), h(TQ, "parseTypenames"), h(TJ, "onRemove"), h(T0, "onAdd"), h(T1, "default"), h(T2, "dispatchEvent"), h(T4, "dispatchConstant"), h(T5, "dispatchFunction"), h(T3, "default"), h(T6, "default");
var T7 = [null];
function T8(e, t) {
	this._groups = e, this._parents = t;
}
function T9() {
	return new T8([[document.documentElement]], T7);
}
function _e() {
	return this;
}
function _t(e) {
	return "string" == typeof e ? new T8([[document.querySelector(e)]], [document.documentElement]) : new T8([[e]], T7);
}
function _r(e, t, r) {
	e.prototype = t.prototype = r, r.constructor = e;
}
function _i(e, t) {
	var r = Object.create(e.prototype);
	for (var i in t) r[i] = t[i];
	return r;
}
function _n() {}
h(T8, "Selection"), h(T9, "selection"), h(_e, "selection_selection"), T8.prototype = T9.prototype = {
	constructor: T8,
	select: k_,
	selectAll: kL,
	selectChild: kO,
	selectChildren: kF,
	filter: kz,
	data: kH,
	enter: kG,
	exit: kK,
	join: kZ,
	merge: kQ,
	selection: _e,
	order: kJ,
	sort: k0,
	call: k2,
	nodes: k4,
	node: k5,
	size: k3,
	empty: k6,
	each: k7,
	attr: To,
	style: Td,
	property: Ty,
	classed: TC,
	text: TR,
	html: TD,
	raise: T$,
	lower: TB,
	append: TG,
	insert: Tj,
	remove: TY,
	clone: TX,
	datum: TK,
	on: T1,
	dispatch: T3,
	[Symbol.iterator]: T6
}, h(_t, "default"), h(_r, "default"), h(_i, "extend"), h(_n, "Color");
var _a = "\\s*([+-]?\\d+)\\s*", _s = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", _o = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", _l = /^#([0-9a-f]{3,8})$/, _c = RegExp(`^rgb\\(${_a},${_a},${_a}\\)$`), _h = RegExp(`^rgb\\(${_o},${_o},${_o}\\)$`), _u = RegExp(`^rgba\\(${_a},${_a},${_a},${_s}\\)$`), _d = RegExp(`^rgba\\(${_o},${_o},${_o},${_s}\\)$`), _p = RegExp(`^hsl\\(${_s},${_o},${_o}\\)$`), _f = RegExp(`^hsla\\(${_s},${_o},${_o},${_s}\\)$`), _g = {
	aliceblue: 15792383,
	antiquewhite: 16444375,
	aqua: 65535,
	aquamarine: 8388564,
	azure: 15794175,
	beige: 16119260,
	bisque: 16770244,
	black: 0,
	blanchedalmond: 16772045,
	blue: 255,
	blueviolet: 9055202,
	brown: 10824234,
	burlywood: 14596231,
	cadetblue: 6266528,
	chartreuse: 8388352,
	chocolate: 13789470,
	coral: 16744272,
	cornflowerblue: 6591981,
	cornsilk: 16775388,
	crimson: 14423100,
	cyan: 65535,
	darkblue: 139,
	darkcyan: 35723,
	darkgoldenrod: 12092939,
	darkgray: 11119017,
	darkgreen: 25600,
	darkgrey: 11119017,
	darkkhaki: 12433259,
	darkmagenta: 9109643,
	darkolivegreen: 5597999,
	darkorange: 16747520,
	darkorchid: 10040012,
	darkred: 9109504,
	darksalmon: 15308410,
	darkseagreen: 9419919,
	darkslateblue: 4734347,
	darkslategray: 3100495,
	darkslategrey: 3100495,
	darkturquoise: 52945,
	darkviolet: 9699539,
	deeppink: 16716947,
	deepskyblue: 49151,
	dimgray: 6908265,
	dimgrey: 6908265,
	dodgerblue: 2003199,
	firebrick: 11674146,
	floralwhite: 16775920,
	forestgreen: 2263842,
	fuchsia: 16711935,
	gainsboro: 14474460,
	ghostwhite: 16316671,
	gold: 16766720,
	goldenrod: 14329120,
	gray: 8421504,
	green: 32768,
	greenyellow: 11403055,
	grey: 8421504,
	honeydew: 15794160,
	hotpink: 16738740,
	indianred: 13458524,
	indigo: 4915330,
	ivory: 16777200,
	khaki: 15787660,
	lavender: 15132410,
	lavenderblush: 16773365,
	lawngreen: 8190976,
	lemonchiffon: 16775885,
	lightblue: 11393254,
	lightcoral: 15761536,
	lightcyan: 14745599,
	lightgoldenrodyellow: 16448210,
	lightgray: 13882323,
	lightgreen: 9498256,
	lightgrey: 13882323,
	lightpink: 16758465,
	lightsalmon: 16752762,
	lightseagreen: 2142890,
	lightskyblue: 8900346,
	lightslategray: 7833753,
	lightslategrey: 7833753,
	lightsteelblue: 11584734,
	lightyellow: 16777184,
	lime: 65280,
	limegreen: 3329330,
	linen: 16445670,
	magenta: 16711935,
	maroon: 8388608,
	mediumaquamarine: 6737322,
	mediumblue: 205,
	mediumorchid: 12211667,
	mediumpurple: 9662683,
	mediumseagreen: 3978097,
	mediumslateblue: 8087790,
	mediumspringgreen: 64154,
	mediumturquoise: 4772300,
	mediumvioletred: 13047173,
	midnightblue: 1644912,
	mintcream: 16121850,
	mistyrose: 16770273,
	moccasin: 16770229,
	navajowhite: 16768685,
	navy: 128,
	oldlace: 16643558,
	olive: 8421376,
	olivedrab: 7048739,
	orange: 16753920,
	orangered: 16729344,
	orchid: 14315734,
	palegoldenrod: 15657130,
	palegreen: 10025880,
	paleturquoise: 11529966,
	palevioletred: 14381203,
	papayawhip: 16773077,
	peachpuff: 16767673,
	peru: 13468991,
	pink: 16761035,
	plum: 14524637,
	powderblue: 11591910,
	purple: 8388736,
	rebeccapurple: 6697881,
	red: 16711680,
	rosybrown: 12357519,
	royalblue: 4286945,
	saddlebrown: 9127187,
	salmon: 16416882,
	sandybrown: 16032864,
	seagreen: 3050327,
	seashell: 16774638,
	sienna: 10506797,
	silver: 12632256,
	skyblue: 8900331,
	slateblue: 6970061,
	slategray: 7372944,
	slategrey: 7372944,
	snow: 16775930,
	springgreen: 65407,
	steelblue: 4620980,
	tan: 13808780,
	teal: 32896,
	thistle: 14204888,
	tomato: 16737095,
	turquoise: 4251856,
	violet: 15631086,
	wheat: 16113331,
	white: 16777215,
	whitesmoke: 16119285,
	yellow: 16776960,
	yellowgreen: 10145074
};
function _m() {
	return this.rgb().formatHex();
}
function _y() {
	return this.rgb().formatHex8();
}
function _v() {
	return _M(this).formatHsl();
}
function _x() {
	return this.rgb().formatRgb();
}
function _b(e) {
	var t, r;
	return e = (e + "").trim().toLowerCase(), (t = _l.exec(e)) ? (r = t[1].length, t = parseInt(t[1], 16), 6 === r ? _w(t) : 3 === r ? new _E(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | 240 & t, (15 & t) << 4 | 15 & t, 1) : 8 === r ? _k(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (255 & t) / 255) : 4 === r ? _k(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | 240 & t, ((15 & t) << 4 | 15 & t) / 255) : null) : (t = _c.exec(e)) ? new _E(t[1], t[2], t[3], 1) : (t = _h.exec(e)) ? new _E(255 * t[1] / 100, 255 * t[2] / 100, 255 * t[3] / 100, 1) : (t = _u.exec(e)) ? _k(t[1], t[2], t[3], t[4]) : (t = _d.exec(e)) ? _k(255 * t[1] / 100, 255 * t[2] / 100, 255 * t[3] / 100, t[4]) : (t = _p.exec(e)) ? _I(t[1], t[2] / 100, t[3] / 100, 1) : (t = _f.exec(e)) ? _I(t[1], t[2] / 100, t[3] / 100, t[4]) : _g.hasOwnProperty(e) ? _w(_g[e]) : "transparent" === e ? new _E(NaN, NaN, NaN, 0) : null;
}
function _w(e) {
	return new _E(e >> 16 & 255, e >> 8 & 255, 255 & e, 1);
}
function _k(e, t, r, i) {
	return i <= 0 && (e = t = r = NaN), new _E(e, t, r, i);
}
function _T(e) {
	return e instanceof _n || (e = _b(e)), e ? new _E((e = e.rgb()).r, e.g, e.b, e.opacity) : new _E();
}
function __(e, t, r, i) {
	return 1 == arguments.length ? _T(e) : new _E(e, t, r, i ?? 1);
}
function _E(e, t, r, i) {
	this.r = +e, this.g = +t, this.b = +r, this.opacity = +i;
}
function _C() {
	return `#${_N(this.r)}${_N(this.g)}${_N(this.b)}`;
}
function _S() {
	return `#${_N(this.r)}${_N(this.g)}${_N(this.b)}${_N((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function _A() {
	let e = _L(this.opacity);
	return `${1 === e ? "rgb(" : "rgba("}${_R(this.r)}, ${_R(this.g)}, ${_R(this.b)}${1 === e ? ")" : `, ${e})`}`;
}
function _L(e) {
	return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function _R(e) {
	return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function _N(e) {
	return ((e = _R(e)) < 16 ? "0" : "") + e.toString(16);
}
function _I(e, t, r, i) {
	return i <= 0 ? e = t = r = NaN : r <= 0 || r >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new _O(e, t, r, i);
}
function _M(e) {
	if (e instanceof _O) return new _O(e.h, e.s, e.l, e.opacity);
	if (e instanceof _n || (e = _b(e)), !e) return new _O();
	if (e instanceof _O) return e;
	var t = (e = e.rgb()).r / 255, r = e.g / 255, i = e.b / 255, n = Math.min(t, r, i), a = Math.max(t, r, i), s = NaN, o = a - n, l = (a + n) / 2;
	return o ? (s = t === a ? (r - i) / o + (r < i) * 6 : r === a ? (i - t) / o + 2 : (t - r) / o + 4, o /= l < .5 ? a + n : 2 - a - n, s *= 60) : o = l > 0 && l < 1 ? 0 : s, new _O(s, o, l, e.opacity);
}
function _D(e, t, r, i) {
	return 1 == arguments.length ? _M(e) : new _O(e, t, r, i ?? 1);
}
function _O(e, t, r, i) {
	this.h = +e, this.s = +t, this.l = +r, this.opacity = +i;
}
function _$(e) {
	return (e = (e || 0) % 360) < 0 ? e + 360 : e;
}
function _P(e) {
	return Math.max(0, Math.min(1, e || 0));
}
function _B(e, t, r) {
	return (e < 60 ? t + (r - t) * e / 60 : e < 180 ? r : e < 240 ? t + (r - t) * (240 - e) / 60 : t) * 255;
}
_r(_n, _b, {
	copy(e) {
		return Object.assign(new this.constructor(), this, e);
	},
	displayable() {
		return this.rgb().displayable();
	},
	hex: _m,
	formatHex: _m,
	formatHex8: _y,
	formatHsl: _v,
	formatRgb: _x,
	toString: _x
}), h(_m, "color_formatHex"), h(_y, "color_formatHex8"), h(_v, "color_formatHsl"), h(_x, "color_formatRgb"), h(_b, "color"), h(_w, "rgbn"), h(_k, "rgba"), h(_T, "rgbConvert"), h(__, "rgb"), h(_E, "Rgb"), _r(_E, __, _i(_n, {
	brighter(e) {
		return e = null == e ? 1.4285714285714286 : Math.pow(1.4285714285714286, e), new _E(this.r * e, this.g * e, this.b * e, this.opacity);
	},
	darker(e) {
		return e = null == e ? .7 : Math.pow(.7, e), new _E(this.r * e, this.g * e, this.b * e, this.opacity);
	},
	rgb() {
		return this;
	},
	clamp() {
		return new _E(_R(this.r), _R(this.g), _R(this.b), _L(this.opacity));
	},
	displayable() {
		return -.5 <= this.r && this.r < 255.5 && -.5 <= this.g && this.g < 255.5 && -.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
	},
	hex: _C,
	formatHex: _C,
	formatHex8: _S,
	formatRgb: _A,
	toString: _A
})), h(_C, "rgb_formatHex"), h(_S, "rgb_formatHex8"), h(_A, "rgb_formatRgb"), h(_L, "clampa"), h(_R, "clampi"), h(_N, "hex"), h(_I, "hsla"), h(_M, "hslConvert"), h(_D, "hsl"), h(_O, "Hsl"), _r(_O, _D, _i(_n, {
	brighter(e) {
		return e = null == e ? 1.4285714285714286 : Math.pow(1.4285714285714286, e), new _O(this.h, this.s, this.l * e, this.opacity);
	},
	darker(e) {
		return e = null == e ? .7 : Math.pow(.7, e), new _O(this.h, this.s, this.l * e, this.opacity);
	},
	rgb() {
		var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, r = this.l, i = r + (r < .5 ? r : 1 - r) * t, n = 2 * r - i;
		return new _E(_B(e >= 240 ? e - 240 : e + 120, n, i), _B(e, n, i), _B(e < 120 ? e + 240 : e - 120, n, i), this.opacity);
	},
	clamp() {
		return new _O(_$(this.h), _P(this.s), _P(this.l), _L(this.opacity));
	},
	displayable() {
		return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
	},
	formatHsl() {
		let e = _L(this.opacity);
		return `${1 === e ? "hsl(" : "hsla("}${_$(this.h)}, ${100 * _P(this.s)}%, ${100 * _P(this.l)}%${1 === e ? ")" : `, ${e})`}`;
	}
})), h(_$, "clamph"), h(_P, "clampt"), h(_B, "hsl2rgb");
var _F = Math.PI / 180, _z = 180 / Math.PI, _U = 4 / 29, _G = 6 / 29, _q = 6 / 29 * 3 * (6 / 29), _j = 6 / 29 * (6 / 29) * (6 / 29);
function _W(e) {
	if (e instanceof _V) return new _V(e.l, e.a, e.b, e.opacity);
	if (e instanceof _0) return _1(e);
	e instanceof _E || (e = _T(e));
	var t, r, i = _Z(e.r), n = _Z(e.g), a = _Z(e.b), s = _H((.2225045 * i + .7168786 * n + .0606169 * a) / 1);
	return i === n && n === a ? t = r = s : (t = _H((.4360747 * i + .3850649 * n + .1430804 * a) / .96422), r = _H((.0139322 * i + .0971045 * n + .7141733 * a) / .82521)), new _V(116 * s - 16, 500 * (t - s), 200 * (s - r), e.opacity);
}
function _Y(e, t, r, i) {
	return 1 == arguments.length ? _W(e) : new _V(e, t, r, i ?? 1);
}
function _V(e, t, r, i) {
	this.l = +e, this.a = +t, this.b = +r, this.opacity = +i;
}
function _H(e) {
	return e > _j ? Math.pow(e, 1 / 3) : e / _q + _U;
}
function _X(e) {
	return e > _G ? e * e * e : _q * (e - _U);
}
function _K(e) {
	return 255 * (e <= .0031308 ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - .055);
}
function _Z(e) {
	return (e /= 255) <= .04045 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4);
}
function _Q(e) {
	if (e instanceof _0) return new _0(e.h, e.c, e.l, e.opacity);
	if (e instanceof _V || (e = _W(e)), 0 === e.a && 0 === e.b) return new _0(NaN, 0 < e.l && e.l < 100 ? 0 : NaN, e.l, e.opacity);
	var t = Math.atan2(e.b, e.a) * _z;
	return new _0(t < 0 ? t + 360 : t, Math.sqrt(e.a * e.a + e.b * e.b), e.l, e.opacity);
}
function _J(e, t, r, i) {
	return 1 == arguments.length ? _Q(e) : new _0(e, t, r, i ?? 1);
}
function _0(e, t, r, i) {
	this.h = +e, this.c = +t, this.l = +r, this.opacity = +i;
}
function _1(e) {
	if (isNaN(e.h)) return new _V(e.l, 0, 0, e.opacity);
	var t = e.h * _F;
	return new _V(e.l, Math.cos(t) * e.c, Math.sin(t) * e.c, e.opacity);
}
h(_W, "labConvert"), h(_Y, "lab"), h(_V, "Lab"), _r(_V, _Y, _i(_n, {
	brighter(e) {
		return new _V(this.l + 18 * (e ?? 1), this.a, this.b, this.opacity);
	},
	darker(e) {
		return new _V(this.l - 18 * (e ?? 1), this.a, this.b, this.opacity);
	},
	rgb() {
		var e = (this.l + 16) / 116, t = isNaN(this.a) ? e : e + this.a / 500, r = isNaN(this.b) ? e : e - this.b / 200;
		return t = .96422 * _X(t), new _E(_K(3.1338561 * t - 1.6168667 * (e = +_X(e)) - .4906146 * (r = .82521 * _X(r))), _K(-.9787684 * t + 1.9161415 * e + .033454 * r), _K(.0719453 * t - .2289914 * e + 1.4052427 * r), this.opacity);
	}
})), h(_H, "xyz2lab"), h(_X, "lab2xyz"), h(_K, "lrgb2rgb"), h(_Z, "rgb2lrgb"), h(_Q, "hclConvert"), h(_J, "hcl"), h(_0, "Hcl"), h(_1, "hcl2lab"), _r(_0, _J, _i(_n, {
	brighter(e) {
		return new _0(this.h, this.c, this.l + 18 * (e ?? 1), this.opacity);
	},
	darker(e) {
		return new _0(this.h, this.c, this.l - 18 * (e ?? 1), this.opacity);
	},
	rgb() {
		return _1(this).rgb();
	}
}));
var _2 = h((e) => () => e, "default");
function _4(e, t) {
	return function(r) {
		return e + r * t;
	};
}
function _5(e, t, r) {
	return e = Math.pow(e, r), t = Math.pow(t, r) - e, r = 1 / r, function(i) {
		return Math.pow(e + i * t, r);
	};
}
function _3(e, t) {
	var r = t - e;
	return r ? _4(e, r > 180 || r < -180 ? r - 360 * Math.round(r / 360) : r) : _2(isNaN(e) ? t : e);
}
function _6(e) {
	return 1 == (e *= 1) ? _7 : function(t, r) {
		return r - t ? _5(t, r, e) : _2(isNaN(t) ? r : t);
	};
}
function _7(e, t) {
	var r = t - e;
	return r ? _4(e, r) : _2(isNaN(e) ? t : e);
}
function _8(e) {
	return function(t, r) {
		var i = e((t = _J(t)).h, (r = _J(r)).h), n = _7(t.c, r.c), a = _7(t.l, r.l), s = _7(t.opacity, r.opacity);
		return function(e) {
			return t.h = i(e), t.c = n(e), t.l = a(e), t.opacity = s(e), t + "";
		};
	};
}
h(_4, "linear"), h(_5, "exponential"), h(_3, "hue"), h(_6, "gamma"), h(_7, "nogamma"), h(_8, "hcl");
var _9 = _8(_3);
function Ee(e, t, r, i, n) {
	var a = e * e, s = a * e;
	return ((1 - 3 * e + 3 * a - s) * t + (4 - 6 * a + 3 * s) * r + (1 + 3 * e + 3 * a - 3 * s) * i + s * n) / 6;
}
function Et(e) {
	var t = e.length - 1;
	return function(r) {
		var i = r <= 0 ? r = 0 : r >= 1 ? (r = 1, t - 1) : Math.floor(r * t), n = e[i], a = e[i + 1], s = i > 0 ? e[i - 1] : 2 * n - a, o = i < t - 1 ? e[i + 2] : 2 * a - n;
		return Ee((r - i / t) * t, s, n, a, o);
	};
}
function Er(e) {
	var t = e.length;
	return function(r) {
		var i = Math.floor(((r %= 1) < 0 ? ++r : r) * t), n = e[(i + t - 1) % t], a = e[i % t], s = e[(i + 1) % t], o = e[(i + 2) % t];
		return Ee((r - i / t) * t, n, a, s, o);
	};
}
_8(_7), h(Ee, "basis"), h(Et, "default"), h(Er, "default");
var Ei = h(function e(t) {
	var r = _6(t);
	function i(e, t) {
		var i = r((e = __(e)).r, (t = __(t)).r), n = r(e.g, t.g), a = r(e.b, t.b), s = _7(e.opacity, t.opacity);
		return function(t) {
			return e.r = i(t), e.g = n(t), e.b = a(t), e.opacity = s(t), e + "";
		};
	}
	return h(i, "rgb"), i.gamma = e, i;
}, "rgbGamma")(1);
function En(e) {
	return function(t) {
		var r, i, n = t.length, a = Array(n), s = Array(n), o = Array(n);
		for (r = 0; r < n; ++r) i = __(t[r]), a[r] = i.r || 0, s[r] = i.g || 0, o[r] = i.b || 0;
		return a = e(a), s = e(s), o = e(o), i.opacity = 1, function(e) {
			return i.r = a(e), i.g = s(e), i.b = o(e), i + "";
		};
	};
}
function Ea(e, t) {
	t || (t = []);
	var r, i = e ? Math.min(t.length, e.length) : 0, n = t.slice();
	return function(a) {
		for (r = 0; r < i; ++r) n[r] = e[r] * (1 - a) + t[r] * a;
		return n;
	};
}
function Es(e) {
	return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function Eo(e, t) {
	var r, i = t ? t.length : 0, n = e ? Math.min(i, e.length) : 0, a = Array(n), s = Array(i);
	for (r = 0; r < n; ++r) a[r] = Em(e[r], t[r]);
	for (; r < i; ++r) s[r] = t[r];
	return function(e) {
		for (r = 0; r < n; ++r) s[r] = a[r](e);
		return s;
	};
}
function El(e, t) {
	var r = /* @__PURE__ */ new Date();
	return e *= 1, t *= 1, function(i) {
		return r.setTime(e * (1 - i) + t * i), r;
	};
}
function Ec(e, t) {
	return e *= 1, t *= 1, function(r) {
		return e * (1 - r) + t * r;
	};
}
function Eh(e, t) {
	var r, i = {}, n = {};
	for (r in (null === e || "object" != typeof e) && (e = {}), (null === t || "object" != typeof t) && (t = {}), t) r in e ? i[r] = Em(e[r], t[r]) : n[r] = t[r];
	return function(e) {
		for (r in i) n[r] = i[r](e);
		return n;
	};
}
h(En, "rgbSpline"), En(Et), En(Er), h(Ea, "default"), h(Es, "isNumberArray"), h(Eo, "genericArray"), h(El, "default"), h(Ec, "default"), h(Eh, "default");
var Eu = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, Ed = RegExp(Eu.source, "g");
function Ep(e) {
	return function() {
		return e;
	};
}
function Ef(e) {
	return function(t) {
		return e(t) + "";
	};
}
function Eg(e, t) {
	var r, i, n, a = Eu.lastIndex = Ed.lastIndex = 0, s = -1, o = [], l = [];
	for (e += "", t += ""; (r = Eu.exec(e)) && (i = Ed.exec(t));) (n = i.index) > a && (n = t.slice(a, n), o[s] ? o[s] += n : o[++s] = n), (r = r[0]) === (i = i[0]) ? o[s] ? o[s] += i : o[++s] = i : (o[++s] = null, l.push({
		i: s,
		x: Ec(r, i)
	})), a = Ed.lastIndex;
	return a < t.length && (n = t.slice(a), o[s] ? o[s] += n : o[++s] = n), o.length < 2 ? l[0] ? Ef(l[0].x) : Ep(t) : (t = l.length, function(e) {
		for (var r, i = 0; i < t; ++i) o[(r = l[i]).i] = r.x(e);
		return o.join("");
	});
}
function Em(e, t) {
	var r, i = typeof t;
	return null == t || "boolean" === i ? _2(t) : ("number" === i ? Ec : "string" === i ? (r = _b(t)) ? (t = r, Ei) : Eg : t instanceof _b ? Ei : t instanceof Date ? El : Es(t) ? Ea : Array.isArray(t) ? Eo : "function" != typeof t.valueOf && "function" != typeof t.toString || isNaN(t) ? Eh : Ec)(e, t);
}
function Ey(e, t) {
	return e *= 1, t *= 1, function(r) {
		return Math.round(e * (1 - r) + t * r);
	};
}
h(Ep, "zero"), h(Ef, "one"), h(Eg, "default"), h(Em, "default"), h(Ey, "default");
var Ev = 180 / Math.PI, Ex = {
	translateX: 0,
	translateY: 0,
	rotate: 0,
	skewX: 0,
	scaleX: 1,
	scaleY: 1
};
function Eb(e, t, r, i, n, a) {
	var s, o, l;
	return (s = Math.sqrt(e * e + t * t)) && (e /= s, t /= s), (l = e * r + t * i) && (r -= e * l, i -= t * l), (o = Math.sqrt(r * r + i * i)) && (r /= o, i /= o, l /= o), e * i < t * r && (e = -e, t = -t, l = -l, s = -s), {
		translateX: n,
		translateY: a,
		rotate: Math.atan2(t, e) * Ev,
		skewX: Math.atan(l) * Ev,
		scaleX: s,
		scaleY: o
	};
}
function Ew(e) {
	let t = new ("function" == typeof DOMMatrix ? DOMMatrix : WebKitCSSMatrix)(e + "");
	return t.isIdentity ? Ex : Eb(t.a, t.b, t.c, t.d, t.e, t.f);
}
function Ek(e) {
	return null == e ? Ex : (LX || (LX = document.createElementNS("http://www.w3.org/2000/svg", "g")), LX.setAttribute("transform", e), (e = LX.transform.baseVal.consolidate()) ? Eb((e = e.matrix).a, e.b, e.c, e.d, e.e, e.f) : Ex);
}
function ET(e, t, r, i) {
	function n(e) {
		return e.length ? e.pop() + " " : "";
	}
	function a(e, i, n, a, s, o) {
		if (e !== n || i !== a) {
			var l = s.push("translate(", null, t, null, r);
			o.push({
				i: l - 4,
				x: Ec(e, n)
			}, {
				i: l - 2,
				x: Ec(i, a)
			});
		} else (n || a) && s.push("translate(" + n + t + a + r);
	}
	function s(e, t, r, a) {
		e !== t ? (e - t > 180 ? t += 360 : t - e > 180 && (e += 360), a.push({
			i: r.push(n(r) + "rotate(", null, i) - 2,
			x: Ec(e, t)
		})) : t && r.push(n(r) + "rotate(" + t + i);
	}
	function o(e, t, r, a) {
		e !== t ? a.push({
			i: r.push(n(r) + "skewX(", null, i) - 2,
			x: Ec(e, t)
		}) : t && r.push(n(r) + "skewX(" + t + i);
	}
	function l(e, t, r, i, a, s) {
		if (e !== r || t !== i) {
			var o = a.push(n(a) + "scale(", null, ",", null, ")");
			s.push({
				i: o - 4,
				x: Ec(e, r)
			}, {
				i: o - 2,
				x: Ec(t, i)
			});
		} else (1 !== r || 1 !== i) && a.push(n(a) + "scale(" + r + "," + i + ")");
	}
	return h(n, "pop"), h(a, "translate"), h(s, "rotate"), h(o, "skewX"), h(l, "scale"), function(t, r) {
		var i = [], n = [];
		return t = e(t), r = e(r), a(t.translateX, t.translateY, r.translateX, r.translateY, i, n), s(t.rotate, r.rotate, i, n), o(t.skewX, r.skewX, i, n), l(t.scaleX, t.scaleY, r.scaleX, r.scaleY, i, n), t = r = null, function(e) {
			for (var t, r = -1, a = n.length; ++r < a;) i[(t = n[r]).i] = t.x(e);
			return i.join("");
		};
	};
}
h(Eb, "default"), h(Ew, "parseCss"), h(Ek, "parseSvg"), h(ET, "interpolateTransform");
var E_ = ET(Ew, "px, ", "px)", "deg)"), EE = ET(Ek, ", ", ")", ")");
function EC(e) {
	return Math.abs(e = Math.round(e)) >= 1e21 ? e.toLocaleString("en").replace(/,/g, "") : e.toString(10);
}
function ES(e, t) {
	if ((r = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e")) < 0) return null;
	var r, i = e.slice(0, r);
	return [i.length > 1 ? i[0] + i.slice(2) : i, +e.slice(r + 1)];
}
function EA(e) {
	return (e = ES(Math.abs(e))) ? e[1] : NaN;
}
function EL(e, t) {
	return function(r, i) {
		for (var n = r.length, a = [], s = 0, o = e[0], l = 0; n > 0 && o > 0 && (l + o + 1 > i && (o = Math.max(1, i - l)), a.push(r.substring(n -= o, n + o)), !((l += o + 1) > i));) o = e[s = (s + 1) % e.length];
		return a.reverse().join(t);
	};
}
function ER(e) {
	return function(t) {
		return t.replace(/[0-9]/g, function(t) {
			return e[+t];
		});
	};
}
h(EC, "default"), h(ES, "formatDecimalParts"), h(EA, "default"), h(EL, "default"), h(ER, "default");
var EN = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function EI(e) {
	var t;
	if (!(t = EN.exec(e))) throw Error("invalid format: " + e);
	return new EM({
		fill: t[1],
		align: t[2],
		sign: t[3],
		symbol: t[4],
		zero: t[5],
		width: t[6],
		comma: t[7],
		precision: t[8] && t[8].slice(1),
		trim: t[9],
		type: t[10]
	});
}
function EM(e) {
	this.fill = void 0 === e.fill ? " " : e.fill + "", this.align = void 0 === e.align ? ">" : e.align + "", this.sign = void 0 === e.sign ? "-" : e.sign + "", this.symbol = void 0 === e.symbol ? "" : e.symbol + "", this.zero = !!e.zero, this.width = void 0 === e.width ? void 0 : +e.width, this.comma = !!e.comma, this.precision = void 0 === e.precision ? void 0 : +e.precision, this.trim = !!e.trim, this.type = void 0 === e.type ? "" : e.type + "";
}
function ED(e) {
	r: for (var t, r = e.length, i = 1, n = -1; i < r; ++i) switch (e[i]) {
		case ".":
			n = t = i;
			break;
		case "0":
			0 === n && (n = i), t = i;
			break;
		default:
			if (!+e[i]) break r;
			n > 0 && (n = 0);
	}
	return n > 0 ? e.slice(0, n) + e.slice(t + 1) : e;
}
function EO(e, t) {
	var r = ES(e, t);
	if (!r) return e + "";
	var i = r[0], n = r[1], a = n - (LK = 3 * Math.max(-8, Math.min(8, Math.floor(n / 3)))) + 1, s = i.length;
	return a === s ? i : a > s ? i + Array(a - s + 1).join("0") : a > 0 ? i.slice(0, a) + "." + i.slice(a) : "0." + Array(1 - a).join("0") + ES(e, Math.max(0, t + a - 1))[0];
}
function E$(e, t) {
	var r = ES(e, t);
	if (!r) return e + "";
	var i = r[0], n = r[1];
	return n < 0 ? "0." + Array(-n).join("0") + i : i.length > n + 1 ? i.slice(0, n + 1) + "." + i.slice(n + 1) : i + Array(n - i.length + 2).join("0");
}
h(EI, "formatSpecifier"), EI.prototype = EM.prototype, h(EM, "FormatSpecifier"), EM.prototype.toString = function() {
	return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (void 0 === this.width ? "" : Math.max(1, 0 | this.width)) + (this.comma ? "," : "") + (void 0 === this.precision ? "" : "." + Math.max(0, 0 | this.precision)) + (this.trim ? "~" : "") + this.type;
}, h(ED, "default"), h(EO, "default"), h(E$, "default");
var EP = {
	"%": h((e, t) => (100 * e).toFixed(t), "%"),
	b: h((e) => Math.round(e).toString(2), "b"),
	c: h((e) => e + "", "c"),
	d: EC,
	e: h((e, t) => e.toExponential(t), "e"),
	f: h((e, t) => e.toFixed(t), "f"),
	g: h((e, t) => e.toPrecision(t), "g"),
	o: h((e) => Math.round(e).toString(8), "o"),
	p: h((e, t) => E$(100 * e, t), "p"),
	r: E$,
	s: EO,
	X: h((e) => Math.round(e).toString(16).toUpperCase(), "X"),
	x: h((e) => Math.round(e).toString(16), "x")
};
function EB(e) {
	return e;
}
h(EB, "default");
var EF = Array.prototype.map, Ez = [
	"y",
	"z",
	"a",
	"f",
	"p",
	"n",
	"",
	"m",
	"",
	"k",
	"M",
	"G",
	"T",
	"P",
	"E",
	"Z",
	"Y"
];
function EU(e) {
	var t = void 0 === e.grouping || void 0 === e.thousands ? EB : EL(EF.call(e.grouping, Number), e.thousands + ""), r = void 0 === e.currency ? "" : e.currency[0] + "", i = void 0 === e.currency ? "" : e.currency[1] + "", n = void 0 === e.decimal ? "." : e.decimal + "", a = void 0 === e.numerals ? EB : ER(EF.call(e.numerals, String)), s = void 0 === e.percent ? "%" : e.percent + "", o = void 0 === e.minus ? "" : e.minus + "", l = void 0 === e.nan ? "NaN" : e.nan + "";
	function u(e) {
		var u = (e = EI(e)).fill, d = e.align, p = e.sign, f = e.symbol, g = e.zero, m = e.width, y = e.comma, v = e.precision, x = e.trim, b = e.type;
		"n" === b ? (y = !0, b = "g") : EP[b] || (void 0 === v && (v = 12), x = !0, b = "g"), (g || "0" === u && "=" === d) && (g = !0, u = "0", d = "=");
		var w = "$" === f ? r : "#" === f && /[boxX]/.test(b) ? "0" + b.toLowerCase() : "", k = "$" === f ? i : /[%p]/.test(b) ? s : "", T = EP[b], _ = /[defgprs%]/.test(b);
		function E(e) {
			var r, i, s, h = w, f = k;
			if ("c" === b) f = T(e) + f, e = "";
			else {
				var E = (e *= 1) < 0 || 1 / e < 0;
				if (e = isNaN(e) ? l : T(Math.abs(e), v), x && (e = ED(e)), E && 0 == +e && "+" !== p && (E = !1), h = (E ? "(" === p ? p : o : "-" === p || "(" === p ? "" : p) + h, f = ("s" === b ? Ez[8 + LK / 3] : "") + f + (E && "(" === p ? ")" : ""), _) {
					for (r = -1, i = e.length; ++r < i;) if (48 > (s = e.charCodeAt(r)) || s > 57) {
						f = (46 === s ? n + e.slice(r + 1) : e.slice(r)) + f, e = e.slice(0, r);
						break;
					}
				}
			}
			y && !g && (e = t(e, Infinity));
			var C = h.length + e.length + f.length, S = C < m ? Array(m - C + 1).join(u) : "";
			switch (y && g && (e = t(S + e, S.length ? m - f.length : Infinity), S = ""), d) {
				case "<":
					e = h + e + f + S;
					break;
				case "=":
					e = h + S + e + f;
					break;
				case "^":
					e = S.slice(0, C = S.length >> 1) + h + e + f + S.slice(C);
					break;
				default: e = S + h + e + f;
			}
			return a(e);
		}
		return v = void 0 === v ? 6 : /[gprs]/.test(b) ? Math.max(1, Math.min(21, v)) : Math.max(0, Math.min(20, v)), h(E, "format"), E.toString = function() {
			return e + "";
		}, E;
	}
	function d(e, t) {
		var r = u(((e = EI(e)).type = "f", e)), i = 3 * Math.max(-8, Math.min(8, Math.floor(EA(t) / 3))), n = Math.pow(10, -i), a = Ez[8 + i / 3];
		return function(e) {
			return r(n * e) + a;
		};
	}
	return h(u, "newFormat"), h(d, "formatPrefix"), {
		format: u,
		formatPrefix: d
	};
}
function EG(e) {
	return LQ = (LZ = EU(e)).format, LJ = LZ.formatPrefix, LZ;
}
function Eq(e) {
	return Math.max(0, -EA(Math.abs(e)));
}
function Ej(e, t) {
	return Math.max(0, 3 * Math.max(-8, Math.min(8, Math.floor(EA(t) / 3))) - EA(Math.abs(e)));
}
function EW(e, t) {
	return Math.max(0, EA(t = Math.abs(t) - (e = Math.abs(e))) - EA(e)) + 1;
}
function EY(e) {
	var t = 0, r = e.children, i = r && r.length;
	if (i) for (; --i >= 0;) t += r[i].value;
	else t = 1;
	e.value = t;
}
function EV() {
	return this.eachAfter(EY);
}
function EH(e, t) {
	let r = -1;
	for (let i of this) e.call(t, i, ++r, this);
	return this;
}
function EX(e, t) {
	for (var r, i, n = this, a = [n], s = -1; n = a.pop();) if (e.call(t, n, ++s, this), r = n.children) for (i = r.length - 1; i >= 0; --i) a.push(r[i]);
	return this;
}
function EK(e, t) {
	for (var r, i, n, a = this, s = [a], o = [], l = -1; a = s.pop();) if (o.push(a), r = a.children) for (i = 0, n = r.length; i < n; ++i) s.push(r[i]);
	for (; a = o.pop();) e.call(t, a, ++l, this);
	return this;
}
function EZ(e, t) {
	let r = -1;
	for (let i of this) if (e.call(t, i, ++r, this)) return i;
}
function EQ(e) {
	return this.eachAfter(function(t) {
		for (var r = +e(t.data) || 0, i = t.children, n = i && i.length; --n >= 0;) r += i[n].value;
		t.value = r;
	});
}
function EJ(e) {
	return this.eachBefore(function(t) {
		t.children && t.children.sort(e);
	});
}
function E0(e) {
	for (var t = this, r = E1(t, e), i = [t]; t !== r;) i.push(t = t.parent);
	for (var n = i.length; e !== r;) i.splice(n, 0, e), e = e.parent;
	return i;
}
function E1(e, t) {
	if (e === t) return e;
	var r = e.ancestors(), i = t.ancestors(), n = null;
	for (e = r.pop(), t = i.pop(); e === t;) n = e, e = r.pop(), t = i.pop();
	return n;
}
function E2() {
	for (var e = this, t = [e]; e = e.parent;) t.push(e);
	return t;
}
function E4() {
	return Array.from(this);
}
function E5() {
	var e = [];
	return this.eachBefore(function(t) {
		t.children || e.push(t);
	}), e;
}
function E3() {
	var e = this, t = [];
	return e.each(function(r) {
		r !== e && t.push({
			source: r.parent,
			target: r
		});
	}), t;
}
function* E6() {
	var e, t, r, i, n = this, a = [n];
	do
		for (e = a.reverse(), a = []; n = e.pop();) if (yield n, t = n.children) for (r = 0, i = t.length; r < i; ++r) a.push(t[r]);
	while (a.length);
}
function E7(e, t) {
	e instanceof Map ? (e = [void 0, e], void 0 === t && (t = Ce)) : void 0 === t && (t = E9);
	for (var r, i, n, a, s, o = new Ci(e), l = [o]; r = l.pop();) if ((n = t(r.data)) && (s = (n = Array.from(n)).length)) for (r.children = n, a = s - 1; a >= 0; --a) l.push(i = n[a] = new Ci(n[a])), i.parent = r, i.depth = r.depth + 1;
	return o.eachBefore(Cr);
}
function E8() {
	return E7(this).eachBefore(Ct);
}
function E9(e) {
	return e.children;
}
function Ce(e) {
	return Array.isArray(e) ? e[1] : null;
}
function Ct(e) {
	void 0 !== e.data.value && (e.value = e.data.value), e.data = e.data.data;
}
function Cr(e) {
	var t = 0;
	do
		e.height = t;
	while ((e = e.parent) && e.height < ++t);
}
function Ci(e) {
	this.data = e, this.depth = this.height = 0, this.parent = null;
}
function Cn(e) {
	e.x0 = Math.round(e.x0), e.y0 = Math.round(e.y0), e.x1 = Math.round(e.x1), e.y1 = Math.round(e.y1);
}
function Ca(e, t, r, i, n) {
	for (var a, s = e.children, o = -1, l = s.length, h = e.value && (i - t) / e.value; ++o < l;) (a = s[o]).y0 = r, a.y1 = n, a.x0 = t, a.x1 = t += a.value * h;
}
function Cs(e, t, r, i, n) {
	for (var a, s = e.children, o = -1, l = s.length, h = e.value && (n - r) / e.value; ++o < l;) (a = s[o]).x0 = t, a.x1 = i, a.y0 = r, a.y1 = r += a.value * h;
}
h(EU, "default"), EG({
	thousands: ",",
	grouping: [3],
	currency: ["$", ""]
}), h(EG, "defaultLocale"), h(Eq, "default"), h(Ej, "default"), h(EW, "default"), h(EY, "count"), h(EV, "default"), h(EH, "default"), h(EX, "default"), h(EK, "default"), h(EZ, "default"), h(EQ, "default"), h(EJ, "default"), h(E0, "default"), h(E1, "leastCommonAncestor"), h(E2, "default"), h(E4, "default"), h(E5, "default"), h(E3, "default"), h(E6, "default"), h(E7, "hierarchy"), h(E8, "node_copy"), h(E9, "objectChildren"), h(Ce, "mapChildren"), h(Ct, "copyData"), h(Cr, "computeHeight"), h(Ci, "Node"), Ci.prototype = E7.prototype = {
	constructor: Ci,
	count: EV,
	each: EH,
	eachAfter: EK,
	eachBefore: EX,
	find: EZ,
	sum: EQ,
	sort: EJ,
	path: E0,
	ancestors: E2,
	descendants: E4,
	leaves: E5,
	links: E3,
	copy: E8,
	[Symbol.iterator]: E6
}, h(Cn, "default"), h(Ca, "default"), h(Cs, "default");
var Co = (1 + Math.sqrt(5)) / 2;
function Cl(e, t, r, i, n, a) {
	for (var s, o, l, h, u, d, p, f, g, m, y, v = [], x = t.children, b = 0, w = 0, k = x.length, T = t.value; b < k;) {
		l = n - r, h = a - i;
		do
			u = x[w++].value;
		while (!u && w < k);
		for (d = p = u, g = Math.max(p / (y = u * u * (m = Math.max(h / l, l / h) / (T * e))), y / d); w < k; ++w) {
			if (u += o = x[w].value, o < d && (d = o), o > p && (p = o), (f = Math.max(p / (y = u * u * m), y / d)) > g) {
				u -= o;
				break;
			}
			g = f;
		}
		v.push(s = {
			value: u,
			dice: l < h,
			children: x.slice(b, w)
		}), s.dice ? Ca(s, r, i, n, T ? i += h * u / T : a) : Cs(s, r, i, T ? r += l * u / T : n, a), T -= u, b = w;
	}
	return v;
}
h(Cl, "squarifyRatio");
var Cc = h(function e(t) {
	function r(e, r, i, n, a) {
		Cl(t, e, r, i, n, a);
	}
	return h(r, "squarify"), r.ratio = function(t) {
		return e((t *= 1) > 1 ? t : 1);
	}, r;
}, "custom")(Co);
function Ch(e) {
	if ("function" != typeof e) throw Error();
	return e;
}
function Cu() {
	return 0;
}
function Cd(e) {
	return function() {
		return e;
	};
}
function Cp() {
	var e = Cc, t = !1, r = 1, i = 1, n = [0], a = Cu, s = Cu, o = Cu, l = Cu, u = Cu;
	function d(e) {
		return e.x0 = e.y0 = 0, e.x1 = r, e.y1 = i, e.eachBefore(p), n = [0], t && e.eachBefore(Cn), e;
	}
	function p(t) {
		var r = n[t.depth], i = t.x0 + r, h = t.y0 + r, d = t.x1 - r, p = t.y1 - r;
		d < i && (i = d = (i + d) / 2), p < h && (h = p = (h + p) / 2), t.x0 = i, t.y0 = h, t.x1 = d, t.y1 = p, t.children && (r = n[t.depth + 1] = a(t) / 2, i += u(t) - r, h += s(t) - r, d -= o(t) - r, p -= l(t) - r, d < i && (i = d = (i + d) / 2), p < h && (h = p = (h + p) / 2), e(t, i, h, d, p));
	}
	return h(d, "treemap"), h(p, "positionNode"), d.round = function(e) {
		return arguments.length ? (t = !!e, d) : t;
	}, d.size = function(e) {
		return arguments.length ? (r = +e[0], i = +e[1], d) : [r, i];
	}, d.tile = function(t) {
		return arguments.length ? (e = Ch(t), d) : e;
	}, d.padding = function(e) {
		return arguments.length ? d.paddingInner(e).paddingOuter(e) : d.paddingInner();
	}, d.paddingInner = function(e) {
		return arguments.length ? (a = "function" == typeof e ? e : Cd(+e), d) : a;
	}, d.paddingOuter = function(e) {
		return arguments.length ? d.paddingTop(e).paddingRight(e).paddingBottom(e).paddingLeft(e) : d.paddingTop();
	}, d.paddingTop = function(e) {
		return arguments.length ? (s = "function" == typeof e ? e : Cd(+e), d) : s;
	}, d.paddingRight = function(e) {
		return arguments.length ? (o = "function" == typeof e ? e : Cd(+e), d) : o;
	}, d.paddingBottom = function(e) {
		return arguments.length ? (l = "function" == typeof e ? e : Cd(+e), d) : l;
	}, d.paddingLeft = function(e) {
		return arguments.length ? (u = "function" == typeof e ? e : Cd(+e), d) : u;
	}, d;
}
function Cf(e, t) {
	switch (arguments.length) {
		case 0: break;
		case 1:
			this.range(e);
			break;
		default: this.range(t).domain(e);
	}
	return this;
}
h(Ch, "required"), h(Cu, "constantZero"), h(Cd, "default"), h(Cp, "default"), h(Cf, "initRange");
var Cg = Symbol("implicit");
function Cm() {
	var e = new ke(), t = [], r = [], i = Cg;
	function n(n) {
		let a = e.get(n);
		if (void 0 === a) {
			if (i !== Cg) return i;
			e.set(n, a = t.push(n) - 1);
		}
		return r[a % r.length];
	}
	return h(n, "scale"), n.domain = function(r) {
		if (!arguments.length) return t.slice();
		for (let i of (t = [], e = new ke(), r)) e.has(i) || e.set(i, t.push(i) - 1);
		return n;
	}, n.range = function(e) {
		return arguments.length ? (r = Array.from(e), n) : r.slice();
	}, n.unknown = function(e) {
		return arguments.length ? (i = e, n) : i;
	}, n.copy = function() {
		return Cm(t, r).unknown(i);
	}, Cf.apply(n, arguments), n;
}
function Cy(e) {
	return function() {
		return e;
	};
}
function Cv(e) {
	return +e;
}
h(Cm, "ordinal"), h(Cy, "constants"), h(Cv, "number");
var Cx = [0, 1];
function Cb(e) {
	return e;
}
function Cw(e, t) {
	return (t -= e *= 1) ? function(r) {
		return (r - e) / t;
	} : Cy(isNaN(t) ? NaN : .5);
}
function Ck(e, t) {
	var r;
	return e > t && (r = e, e = t, t = r), function(r) {
		return Math.max(e, Math.min(t, r));
	};
}
function CT(e, t, r) {
	var i = e[0], n = e[1], a = t[0], s = t[1];
	return n < i ? (i = Cw(n, i), a = r(s, a)) : (i = Cw(i, n), a = r(a, s)), function(e) {
		return a(i(e));
	};
}
function C_(e, t, r) {
	var i = Math.min(e.length, t.length) - 1, n = Array(i), a = Array(i), s = -1;
	for (e[i] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++s < i;) n[s] = Cw(e[s], e[s + 1]), a[s] = r(t[s], t[s + 1]);
	return function(t) {
		var r = w9(e, t, 1, i) - 1;
		return a[r](n[r](t));
	};
}
function CE(e, t) {
	return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown());
}
function CC() {
	var e, t, r, i, n, a, s = Cx, o = Cx, l = Em, u = Cb;
	function d() {
		var e = Math.min(s.length, o.length);
		return u !== Cb && (u = Ck(s[0], s[e - 1])), i = e > 2 ? C_ : CT, n = a = null, p;
	}
	function p(t) {
		return null == t || isNaN(t *= 1) ? r : (n || (n = i(s.map(e), o, l)))(e(u(t)));
	}
	return h(d, "rescale"), h(p, "scale"), p.invert = function(r) {
		return u(t((a || (a = i(o, s.map(e), Ec)))(r)));
	}, p.domain = function(e) {
		return arguments.length ? (s = Array.from(e, Cv), d()) : s.slice();
	}, p.range = function(e) {
		return arguments.length ? (o = Array.from(e), d()) : o.slice();
	}, p.rangeRound = function(e) {
		return o = Array.from(e), l = Ey, d();
	}, p.clamp = function(e) {
		return arguments.length ? (u = !!e || Cb, d()) : u !== Cb;
	}, p.interpolate = function(e) {
		return arguments.length ? (l = e, d()) : l;
	}, p.unknown = function(e) {
		return arguments.length ? (r = e, p) : r;
	}, function(r, i) {
		return e = r, t = i, d();
	};
}
function CS() {
	return CC()(Cb, Cb);
}
function CA(e, t, r, i) {
	var n, a = ku(e, t, r);
	switch ((i = EI(i ?? ",f")).type) {
		case "s":
			var s = Math.max(Math.abs(e), Math.abs(t));
			return null != i.precision || isNaN(n = Ej(a, s)) || (i.precision = n), LJ(i, s);
		case "":
		case "e":
		case "g":
		case "p":
		case "r":
			null != i.precision || isNaN(n = EW(a, Math.max(Math.abs(e), Math.abs(t)))) || (i.precision = n - ("e" === i.type));
			break;
		case "f":
		case "%": null != i.precision || isNaN(n = Eq(a)) || (i.precision = n - ("%" === i.type) * 2);
	}
	return LQ(i);
}
function CL(e) {
	var t = e.domain;
	return e.ticks = function(e) {
		var r = t();
		return kc(r[0], r[r.length - 1], e ?? 10);
	}, e.tickFormat = function(e, r) {
		var i = t();
		return CA(i[0], i[i.length - 1], e ?? 10, r);
	}, e.nice = function(r) {
		r ??= 10;
		var i, n, a = t(), s = 0, o = a.length - 1, l = a[s], h = a[o], u = 10;
		for (h < l && (n = l, l = h, h = n, n = s, s = o, o = n); u-- > 0;) {
			if ((n = kh(l, h, r)) === i) return a[s] = l, a[o] = h, t(a);
			if (n > 0) l = Math.floor(l / n) * n, h = Math.ceil(h / n) * n;
			else if (n < 0) l = Math.ceil(l * n) / n, h = Math.floor(h * n) / n;
			else break;
			i = n;
		}
		return e;
	}, e;
}
function CR() {
	var e = CS();
	return e.copy = function() {
		return CE(e, CR());
	}, Cf.apply(e, arguments), CL(e);
}
h(Cb, "identity"), h(Cw, "normalize"), h(Ck, "clamper"), h(CT, "bimap"), h(C_, "polymap"), h(CE, "copy"), h(CC, "transformer"), h(CS, "continuous"), h(CA, "tickFormat"), h(CL, "linearish"), h(CR, "linear");
var CN = /* @__PURE__ */ new Date(), CI = /* @__PURE__ */ new Date();
function CM(e, t, r, i) {
	function n(t) {
		return e(t = 0 == arguments.length ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+t)), t;
	}
	return h(n, "interval"), n.floor = (t) => (e(t = /* @__PURE__ */ new Date(+t)), t), n.ceil = (r) => (e(r = /* @__PURE__ */ new Date(r - 1)), t(r, 1), e(r), r), n.round = (e) => {
		let t = n(e), r = n.ceil(e);
		return e - t < r - e ? t : r;
	}, n.offset = (e, r) => (t(e = /* @__PURE__ */ new Date(+e), null == r ? 1 : Math.floor(r)), e), n.range = (r, i, a) => {
		let s, o = [];
		if (r = n.ceil(r), a = null == a ? 1 : Math.floor(a), !(r < i) || !(a > 0)) return o;
		do
			o.push(s = /* @__PURE__ */ new Date(+r)), t(r, a), e(r);
		while (s < r && r < i);
		return o;
	}, n.filter = (r) => CM((t) => {
		if (t >= t) for (; e(t), !r(t);) t.setTime(t - 1);
	}, (e, i) => {
		if (e >= e) if (i < 0) for (; ++i <= 0;) for (; t(e, -1), !r(e););
		else for (; --i >= 0;) for (; t(e, 1), !r(e););
	}), r && (n.count = (t, i) => (CN.setTime(+t), CI.setTime(+i), e(CN), e(CI), Math.floor(r(CN, CI))), n.every = (e) => isFinite(e = Math.floor(e)) && e > 0 ? e > 1 ? n.filter(i ? (t) => i(t) % e == 0 : (t) => n.count(0, t) % e == 0) : n : null), n;
}
h(CM, "timeInterval");
var CD = CM(() => {}, (e, t) => {
	e.setTime(+e + t);
}, (e, t) => t - e);
CD.every = (e) => isFinite(e = Math.floor(e)) && e > 0 ? e > 1 ? CM((t) => {
	t.setTime(Math.floor(t / e) * e);
}, (t, r) => {
	t.setTime(+t + r * e);
}, (t, r) => (r - t) / e) : CD : null, CD.range;
var CO = CM((e) => {
	e.setTime(e - e.getMilliseconds());
}, (e, t) => {
	e.setTime(+e + 1e3 * t);
}, (e, t) => (t - e) / 1e3, (e) => e.getUTCSeconds());
CO.range;
var C$ = CM((e) => {
	e.setTime(e - e.getMilliseconds() - 1e3 * e.getSeconds());
}, (e, t) => {
	e.setTime(+e + 6e4 * t);
}, (e, t) => (t - e) / 6e4, (e) => e.getMinutes());
C$.range;
var CP = CM((e) => {
	e.setUTCSeconds(0, 0);
}, (e, t) => {
	e.setTime(+e + 6e4 * t);
}, (e, t) => (t - e) / 6e4, (e) => e.getUTCMinutes());
CP.range;
var CB = CM((e) => {
	e.setTime(e - e.getMilliseconds() - 1e3 * e.getSeconds() - 6e4 * e.getMinutes());
}, (e, t) => {
	e.setTime(+e + 36e5 * t);
}, (e, t) => (t - e) / 36e5, (e) => e.getHours());
CB.range;
var CF = CM((e) => {
	e.setUTCMinutes(0, 0, 0);
}, (e, t) => {
	e.setTime(+e + 36e5 * t);
}, (e, t) => (t - e) / 36e5, (e) => e.getUTCHours());
CF.range;
var Cz = CM((e) => e.setHours(0, 0, 0, 0), (e, t) => e.setDate(e.getDate() + t), (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * 6e4) / 864e5, (e) => e.getDate() - 1);
Cz.range;
var CU = CM((e) => {
	e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
	e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / 864e5, (e) => e.getUTCDate() - 1);
CU.range;
var CG = CM((e) => {
	e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
	e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / 864e5, (e) => Math.floor(e / 864e5));
function Cq(e) {
	return CM((t) => {
		t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
	}, (e, t) => {
		e.setDate(e.getDate() + 7 * t);
	}, (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * 6e4) / 6048e5);
}
CG.range, h(Cq, "timeWeekday");
var Cj = Cq(0), CW = Cq(1), CY = Cq(2), CV = Cq(3), CH = Cq(4), CX = Cq(5), CK = Cq(6);
function CZ(e) {
	return CM((t) => {
		t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
	}, (e, t) => {
		e.setUTCDate(e.getUTCDate() + 7 * t);
	}, (e, t) => (t - e) / 6048e5);
}
Cj.range, CW.range, CY.range, CV.range, CH.range, CX.range, CK.range, h(CZ, "utcWeekday");
var CQ = CZ(0), CJ = CZ(1), C0 = CZ(2), C1 = CZ(3), C2 = CZ(4), C4 = CZ(5), C5 = CZ(6);
CQ.range, CJ.range, C0.range, C1.range, C2.range, C4.range, C5.range;
var C3 = CM((e) => {
	e.setDate(1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
	e.setMonth(e.getMonth() + t);
}, (e, t) => t.getMonth() - e.getMonth() + (t.getFullYear() - e.getFullYear()) * 12, (e) => e.getMonth());
C3.range;
var C6 = CM((e) => {
	e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
	e.setUTCMonth(e.getUTCMonth() + t);
}, (e, t) => t.getUTCMonth() - e.getUTCMonth() + (t.getUTCFullYear() - e.getUTCFullYear()) * 12, (e) => e.getUTCMonth());
C6.range;
var C7 = CM((e) => {
	e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
	e.setFullYear(e.getFullYear() + t);
}, (e, t) => t.getFullYear() - e.getFullYear(), (e) => e.getFullYear());
C7.every = (e) => isFinite(e = Math.floor(e)) && e > 0 ? CM((t) => {
	t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
}, (t, r) => {
	t.setFullYear(t.getFullYear() + r * e);
}) : null, C7.range;
var C8 = CM((e) => {
	e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
	e.setUTCFullYear(e.getUTCFullYear() + t);
}, (e, t) => t.getUTCFullYear() - e.getUTCFullYear(), (e) => e.getUTCFullYear());
function C9(e, t, r, i, n, a) {
	let s = [
		[
			CO,
			1,
			1e3
		],
		[
			CO,
			5,
			5e3
		],
		[
			CO,
			15,
			15e3
		],
		[
			CO,
			30,
			3e4
		],
		[
			a,
			1,
			6e4
		],
		[
			a,
			5,
			5 * 6e4
		],
		[
			a,
			15,
			9e5
		],
		[
			a,
			30,
			30 * 6e4
		],
		[
			n,
			1,
			36e5
		],
		[
			n,
			3,
			3 * 36e5
		],
		[
			n,
			6,
			6 * 36e5
		],
		[
			n,
			12,
			12 * 36e5
		],
		[
			i,
			1,
			864e5
		],
		[
			i,
			2,
			2 * 864e5
		],
		[
			r,
			1,
			6048e5
		],
		[
			t,
			1,
			2592e6
		],
		[
			t,
			3,
			3 * 2592e6
		],
		[
			e,
			1,
			31536e6
		]
	];
	function o(e, t, r) {
		let i = t < e;
		i && ([e, t] = [t, e]);
		let n = r && "function" == typeof r.range ? r : l(e, t, r), a = n ? n.range(e, +t + 1) : [];
		return i ? a.reverse() : a;
	}
	function l(t, r, i) {
		let n = Math.abs(r - t) / i, a = w3(([, , e]) => e).right(s, n);
		if (a === s.length) return e.every(ku(t / 31536e6, r / 31536e6, i));
		if (0 === a) return CD.every(Math.max(ku(t, r, i), 1));
		let [o, l] = s[n / s[a - 1][2] < s[a][2] / n ? a - 1 : a];
		return o.every(l);
	}
	return h(o, "ticks"), h(l, "tickInterval"), [o, l];
}
C8.every = (e) => isFinite(e = Math.floor(e)) && e > 0 ? CM((t) => {
	t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
}, (t, r) => {
	t.setUTCFullYear(t.getUTCFullYear() + r * e);
}) : null, C8.range, h(C9, "ticker");
var [Se, St] = C9(C8, C6, CQ, CG, CF, CP), [Sr, Si] = C9(C7, C3, Cj, Cz, CB, C$);
function Sn(e) {
	if (0 <= e.y && e.y < 100) {
		var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
		return t.setFullYear(e.y), t;
	}
	return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
}
function Sa(e) {
	if (0 <= e.y && e.y < 100) {
		var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
		return t.setUTCFullYear(e.y), t;
	}
	return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
}
function Ss(e, t, r) {
	return {
		y: e,
		m: t,
		d: r,
		H: 0,
		M: 0,
		S: 0,
		L: 0
	};
}
function So(e) {
	var t = e.dateTime, r = e.date, i = e.time, n = e.periods, a = e.days, s = e.shortDays, o = e.months, l = e.shortMonths, u = Sf(n), d = Sg(n), p = Sf(a), f = Sg(a), g = Sf(s), m = Sg(s), y = Sf(o), v = Sg(o), x = Sf(l), b = Sg(l), w = {
		a: O,
		A: $,
		b: P,
		B,
		c: null,
		d: S$,
		e: S$,
		f: SU,
		g: SQ,
		G: S0,
		H: SP,
		I: SB,
		j: SF,
		L: Sz,
		m: SG,
		M: Sq,
		p: F,
		q: z,
		Q: Ap,
		s: Af,
		S: Sj,
		u: SW,
		U: SY,
		V: SH,
		w: SX,
		W: SK,
		x: null,
		X: null,
		y: SZ,
		Y: SJ,
		Z: S1,
		"%": Ad
	}, k = {
		a: U,
		A: G,
		b: q,
		B: j,
		c: null,
		d: S2,
		e: S2,
		f: S7,
		g: Al,
		G: Ah,
		H: S4,
		I: S5,
		j: S3,
		L: S6,
		m: S8,
		M: S9,
		p: W,
		q: Y,
		Q: Ap,
		s: Af,
		S: Ae,
		u: At,
		U: Ar,
		V: An,
		w: Aa,
		W: As,
		x: null,
		X: null,
		y: Ao,
		Y: Ac,
		Z: Au,
		"%": Ad
	}, T = {
		a: A,
		A: L,
		b: R,
		B: N,
		c: I,
		d: SC,
		e: SC,
		f: SI,
		g: Sk,
		G: Sw,
		H: SA,
		I: SA,
		j: SS,
		L: SN,
		m: SE,
		M: SL,
		p: S,
		q: S_,
		Q: SD,
		s: SO,
		S: SR,
		u: Sy,
		U: Sv,
		V: Sx,
		w: Sm,
		W: Sb,
		x: M,
		X: D,
		y: Sk,
		Y: Sw,
		Z: ST,
		"%": SM
	};
	function _(e, t) {
		return function(r) {
			var i, n, a, s = [], o = -1, l = 0, h = e.length;
			for (r instanceof Date || (r = /* @__PURE__ */ new Date(+r)); ++o < h;) 37 === e.charCodeAt(o) && (s.push(e.slice(l, o)), null != (n = Sl[i = e.charAt(++o)]) ? i = e.charAt(++o) : n = "e" === i ? " " : "0", (a = t[i]) && (i = a(r, n)), s.push(i), l = o + 1);
			return s.push(e.slice(l, o)), s.join("");
		};
	}
	function E(e, t) {
		return function(r) {
			var i, n, a = Ss(1900, void 0, 1);
			if (C(a, e, r += "", 0) != r.length) return null;
			if ("Q" in a) return new Date(a.Q);
			if ("s" in a) return new Date(1e3 * a.s + ("L" in a ? a.L : 0));
			if (!t || "Z" in a || (a.Z = 0), "p" in a && (a.H = a.H % 12 + 12 * a.p), void 0 === a.m && (a.m = "q" in a ? a.q : 0), "V" in a) {
				if (a.V < 1 || a.V > 53) return null;
				"w" in a || (a.w = 1), "Z" in a ? (i = (n = (i = Sa(Ss(a.y, 0, 1))).getUTCDay()) > 4 || 0 === n ? CJ.ceil(i) : CJ(i), i = CU.offset(i, (a.V - 1) * 7), a.y = i.getUTCFullYear(), a.m = i.getUTCMonth(), a.d = i.getUTCDate() + (a.w + 6) % 7) : (i = (n = (i = Sn(Ss(a.y, 0, 1))).getDay()) > 4 || 0 === n ? CW.ceil(i) : CW(i), i = Cz.offset(i, (a.V - 1) * 7), a.y = i.getFullYear(), a.m = i.getMonth(), a.d = i.getDate() + (a.w + 6) % 7);
			} else ("W" in a || "U" in a) && ("w" in a || (a.w = "u" in a ? a.u % 7 : +("W" in a)), n = "Z" in a ? Sa(Ss(a.y, 0, 1)).getUTCDay() : Sn(Ss(a.y, 0, 1)).getDay(), a.m = 0, a.d = "W" in a ? (a.w + 6) % 7 + 7 * a.W - (n + 5) % 7 : a.w + 7 * a.U - (n + 6) % 7);
			return "Z" in a ? (a.H += a.Z / 100 | 0, a.M += a.Z % 100, Sa(a)) : Sn(a);
		};
	}
	function C(e, t, r, i) {
		for (var n, a, s = 0, o = t.length, l = r.length; s < o;) {
			if (i >= l) return -1;
			if (37 === (n = t.charCodeAt(s++))) {
				if (!(a = T[(n = t.charAt(s++)) in Sl ? t.charAt(s++) : n]) || (i = a(e, r, i)) < 0) return -1;
			} else if (n != r.charCodeAt(i++)) return -1;
		}
		return i;
	}
	function S(e, t, r) {
		var i = u.exec(t.slice(r));
		return i ? (e.p = d.get(i[0].toLowerCase()), r + i[0].length) : -1;
	}
	function A(e, t, r) {
		var i = g.exec(t.slice(r));
		return i ? (e.w = m.get(i[0].toLowerCase()), r + i[0].length) : -1;
	}
	function L(e, t, r) {
		var i = p.exec(t.slice(r));
		return i ? (e.w = f.get(i[0].toLowerCase()), r + i[0].length) : -1;
	}
	function R(e, t, r) {
		var i = x.exec(t.slice(r));
		return i ? (e.m = b.get(i[0].toLowerCase()), r + i[0].length) : -1;
	}
	function N(e, t, r) {
		var i = y.exec(t.slice(r));
		return i ? (e.m = v.get(i[0].toLowerCase()), r + i[0].length) : -1;
	}
	function I(e, r, i) {
		return C(e, t, r, i);
	}
	function M(e, t, i) {
		return C(e, r, t, i);
	}
	function D(e, t, r) {
		return C(e, i, t, r);
	}
	function O(e) {
		return s[e.getDay()];
	}
	function $(e) {
		return a[e.getDay()];
	}
	function P(e) {
		return l[e.getMonth()];
	}
	function B(e) {
		return o[e.getMonth()];
	}
	function F(e) {
		return n[+(e.getHours() >= 12)];
	}
	function z(e) {
		return 1 + ~~(e.getMonth() / 3);
	}
	function U(e) {
		return s[e.getUTCDay()];
	}
	function G(e) {
		return a[e.getUTCDay()];
	}
	function q(e) {
		return l[e.getUTCMonth()];
	}
	function j(e) {
		return o[e.getUTCMonth()];
	}
	function W(e) {
		return n[+(e.getUTCHours() >= 12)];
	}
	function Y(e) {
		return 1 + ~~(e.getUTCMonth() / 3);
	}
	return w.x = _(r, w), w.X = _(i, w), w.c = _(t, w), k.x = _(r, k), k.X = _(i, k), k.c = _(t, k), h(_, "newFormat"), h(E, "newParse"), h(C, "parseSpecifier"), h(S, "parsePeriod"), h(A, "parseShortWeekday"), h(L, "parseWeekday"), h(R, "parseShortMonth"), h(N, "parseMonth"), h(I, "parseLocaleDateTime"), h(M, "parseLocaleDate"), h(D, "parseLocaleTime"), h(O, "formatShortWeekday"), h($, "formatWeekday"), h(P, "formatShortMonth"), h(B, "formatMonth"), h(F, "formatPeriod"), h(z, "formatQuarter"), h(U, "formatUTCShortWeekday"), h(G, "formatUTCWeekday"), h(q, "formatUTCShortMonth"), h(j, "formatUTCMonth"), h(W, "formatUTCPeriod"), h(Y, "formatUTCQuarter"), {
		format: h(function(e) {
			var t = _(e += "", w);
			return t.toString = function() {
				return e;
			}, t;
		}, "format"),
		parse: h(function(e) {
			var t = E(e += "", !1);
			return t.toString = function() {
				return e;
			}, t;
		}, "parse"),
		utcFormat: h(function(e) {
			var t = _(e += "", k);
			return t.toString = function() {
				return e;
			}, t;
		}, "utcFormat"),
		utcParse: h(function(e) {
			var t = E(e += "", !0);
			return t.toString = function() {
				return e;
			}, t;
		}, "utcParse")
	};
}
h(Sn, "localDate"), h(Sa, "utcDate"), h(Ss, "newDate"), h(So, "formatLocale");
var Sl = {
	"-": "",
	_: " ",
	0: "0"
}, Sc = /^\s*\d+/, Sh = /^%/, Su = /[\\^$*+?|[\]().{}]/g;
function Sd(e, t, r) {
	var i = e < 0 ? "-" : "", n = (i ? -e : e) + "", a = n.length;
	return i + (a < r ? Array(r - a + 1).join(t) + n : n);
}
function Sp(e) {
	return e.replace(Su, "\\$&");
}
function Sf(e) {
	return RegExp("^(?:" + e.map(Sp).join("|") + ")", "i");
}
function Sg(e) {
	return new Map(e.map((e, t) => [e.toLowerCase(), t]));
}
function Sm(e, t, r) {
	var i = Sc.exec(t.slice(r, r + 1));
	return i ? (e.w = +i[0], r + i[0].length) : -1;
}
function Sy(e, t, r) {
	var i = Sc.exec(t.slice(r, r + 1));
	return i ? (e.u = +i[0], r + i[0].length) : -1;
}
function Sv(e, t, r) {
	var i = Sc.exec(t.slice(r, r + 2));
	return i ? (e.U = +i[0], r + i[0].length) : -1;
}
function Sx(e, t, r) {
	var i = Sc.exec(t.slice(r, r + 2));
	return i ? (e.V = +i[0], r + i[0].length) : -1;
}
function Sb(e, t, r) {
	var i = Sc.exec(t.slice(r, r + 2));
	return i ? (e.W = +i[0], r + i[0].length) : -1;
}
function Sw(e, t, r) {
	var i = Sc.exec(t.slice(r, r + 4));
	return i ? (e.y = +i[0], r + i[0].length) : -1;
}
function Sk(e, t, r) {
	var i = Sc.exec(t.slice(r, r + 2));
	return i ? (e.y = +i[0] + (+i[0] > 68 ? 1900 : 2e3), r + i[0].length) : -1;
}
function ST(e, t, r) {
	var i = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(r, r + 6));
	return i ? (e.Z = i[1] ? 0 : -(i[2] + (i[3] || "00")), r + i[0].length) : -1;
}
function S_(e, t, r) {
	var i = Sc.exec(t.slice(r, r + 1));
	return i ? (e.q = 3 * i[0] - 3, r + i[0].length) : -1;
}
function SE(e, t, r) {
	var i = Sc.exec(t.slice(r, r + 2));
	return i ? (e.m = i[0] - 1, r + i[0].length) : -1;
}
function SC(e, t, r) {
	var i = Sc.exec(t.slice(r, r + 2));
	return i ? (e.d = +i[0], r + i[0].length) : -1;
}
function SS(e, t, r) {
	var i = Sc.exec(t.slice(r, r + 3));
	return i ? (e.m = 0, e.d = +i[0], r + i[0].length) : -1;
}
function SA(e, t, r) {
	var i = Sc.exec(t.slice(r, r + 2));
	return i ? (e.H = +i[0], r + i[0].length) : -1;
}
function SL(e, t, r) {
	var i = Sc.exec(t.slice(r, r + 2));
	return i ? (e.M = +i[0], r + i[0].length) : -1;
}
function SR(e, t, r) {
	var i = Sc.exec(t.slice(r, r + 2));
	return i ? (e.S = +i[0], r + i[0].length) : -1;
}
function SN(e, t, r) {
	var i = Sc.exec(t.slice(r, r + 3));
	return i ? (e.L = +i[0], r + i[0].length) : -1;
}
function SI(e, t, r) {
	var i = Sc.exec(t.slice(r, r + 6));
	return i ? (e.L = Math.floor(i[0] / 1e3), r + i[0].length) : -1;
}
function SM(e, t, r) {
	var i = Sh.exec(t.slice(r, r + 1));
	return i ? r + i[0].length : -1;
}
function SD(e, t, r) {
	var i = Sc.exec(t.slice(r));
	return i ? (e.Q = +i[0], r + i[0].length) : -1;
}
function SO(e, t, r) {
	var i = Sc.exec(t.slice(r));
	return i ? (e.s = +i[0], r + i[0].length) : -1;
}
function S$(e, t) {
	return Sd(e.getDate(), t, 2);
}
function SP(e, t) {
	return Sd(e.getHours(), t, 2);
}
function SB(e, t) {
	return Sd(e.getHours() % 12 || 12, t, 2);
}
function SF(e, t) {
	return Sd(1 + Cz.count(C7(e), e), t, 3);
}
function Sz(e, t) {
	return Sd(e.getMilliseconds(), t, 3);
}
function SU(e, t) {
	return Sz(e, t) + "000";
}
function SG(e, t) {
	return Sd(e.getMonth() + 1, t, 2);
}
function Sq(e, t) {
	return Sd(e.getMinutes(), t, 2);
}
function Sj(e, t) {
	return Sd(e.getSeconds(), t, 2);
}
function SW(e) {
	var t = e.getDay();
	return 0 === t ? 7 : t;
}
function SY(e, t) {
	return Sd(Cj.count(C7(e) - 1, e), t, 2);
}
function SV(e) {
	var t = e.getDay();
	return t >= 4 || 0 === t ? CH(e) : CH.ceil(e);
}
function SH(e, t) {
	return e = SV(e), Sd(CH.count(C7(e), e) + (4 === C7(e).getDay()), t, 2);
}
function SX(e) {
	return e.getDay();
}
function SK(e, t) {
	return Sd(CW.count(C7(e) - 1, e), t, 2);
}
function SZ(e, t) {
	return Sd(e.getFullYear() % 100, t, 2);
}
function SQ(e, t) {
	return Sd((e = SV(e)).getFullYear() % 100, t, 2);
}
function SJ(e, t) {
	return Sd(e.getFullYear() % 1e4, t, 4);
}
function S0(e, t) {
	var r = e.getDay();
	return Sd((e = r >= 4 || 0 === r ? CH(e) : CH.ceil(e)).getFullYear() % 1e4, t, 4);
}
function S1(e) {
	var t = e.getTimezoneOffset();
	return (t > 0 ? "-" : (t *= -1, "+")) + Sd(t / 60 | 0, "0", 2) + Sd(t % 60, "0", 2);
}
function S2(e, t) {
	return Sd(e.getUTCDate(), t, 2);
}
function S4(e, t) {
	return Sd(e.getUTCHours(), t, 2);
}
function S5(e, t) {
	return Sd(e.getUTCHours() % 12 || 12, t, 2);
}
function S3(e, t) {
	return Sd(1 + CU.count(C8(e), e), t, 3);
}
function S6(e, t) {
	return Sd(e.getUTCMilliseconds(), t, 3);
}
function S7(e, t) {
	return S6(e, t) + "000";
}
function S8(e, t) {
	return Sd(e.getUTCMonth() + 1, t, 2);
}
function S9(e, t) {
	return Sd(e.getUTCMinutes(), t, 2);
}
function Ae(e, t) {
	return Sd(e.getUTCSeconds(), t, 2);
}
function At(e) {
	var t = e.getUTCDay();
	return 0 === t ? 7 : t;
}
function Ar(e, t) {
	return Sd(CQ.count(C8(e) - 1, e), t, 2);
}
function Ai(e) {
	var t = e.getUTCDay();
	return t >= 4 || 0 === t ? C2(e) : C2.ceil(e);
}
function An(e, t) {
	return e = Ai(e), Sd(C2.count(C8(e), e) + (4 === C8(e).getUTCDay()), t, 2);
}
function Aa(e) {
	return e.getUTCDay();
}
function As(e, t) {
	return Sd(CJ.count(C8(e) - 1, e), t, 2);
}
function Ao(e, t) {
	return Sd(e.getUTCFullYear() % 100, t, 2);
}
function Al(e, t) {
	return Sd((e = Ai(e)).getUTCFullYear() % 100, t, 2);
}
function Ac(e, t) {
	return Sd(e.getUTCFullYear() % 1e4, t, 4);
}
function Ah(e, t) {
	var r = e.getUTCDay();
	return Sd((e = r >= 4 || 0 === r ? C2(e) : C2.ceil(e)).getUTCFullYear() % 1e4, t, 4);
}
function Au() {
	return "+0000";
}
function Ad() {
	return "%";
}
function Ap(e) {
	return +e;
}
function Af(e) {
	return Math.floor(e / 1e3);
}
function Ag(e) {
	return L1 = (L0 = So(e)).format, L0.parse, L0.utcFormat, L0.utcParse, L0;
}
function Am(e, t) {
	e = e.slice();
	var r, i = 0, n = e.length - 1, a = e[i], s = e[n];
	return s < a && (r = i, i = n, n = r, r = a, a = s, s = r), e[i] = t.floor(a), e[n] = t.ceil(s), e;
}
function Ay(e) {
	return new Date(e);
}
function Av(e) {
	return e instanceof Date ? +e : +/* @__PURE__ */ new Date(+e);
}
function Ax(e, t, r, i, n, a, s, o, l, u) {
	var d = CS(), p = d.invert, f = d.domain, g = u(".%L"), m = u(":%S"), y = u("%I:%M"), v = u("%I %p"), x = u("%a %d"), b = u("%b %d"), w = u("%B"), k = u("%Y");
	function T(e) {
		return (l(e) < e ? g : o(e) < e ? m : s(e) < e ? y : a(e) < e ? v : i(e) < e ? n(e) < e ? x : b : r(e) < e ? w : k)(e);
	}
	return h(T, "tickFormat"), d.invert = function(e) {
		return new Date(p(e));
	}, d.domain = function(e) {
		return arguments.length ? f(Array.from(e, Av)) : f().map(Ay);
	}, d.ticks = function(t) {
		var r = f();
		return e(r[0], r[r.length - 1], t ?? 10);
	}, d.tickFormat = function(e, t) {
		return null == t ? T : u(t);
	}, d.nice = function(e) {
		var r = f();
		return e && "function" == typeof e.range || (e = t(r[0], r[r.length - 1], e ?? 10)), e ? f(Am(r, e)) : d;
	}, d.copy = function() {
		return CE(d, Ax(e, t, r, i, n, a, s, o, l, u));
	}, d;
}
function Ab() {
	return Cf.apply(Ax(Sr, Si, C7, C3, Cj, Cz, CB, C$, CO, L1).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function Aw() {
	var e, t, r = Cm().unknown(void 0), i = r.domain, n = r.range, a = 0, s = 1, o = !1, l = 0, u = 0, d = .5;
	function p() {
		var r = i().length, h = s < a, p = h ? s : a, f = h ? a : s;
		e = (f - p) / Math.max(1, r - l + 2 * u), o && (e = Math.floor(e)), p += (f - p - e * (r - l)) * d, t = e * (1 - l), o && (p = Math.round(p), t = Math.round(t));
		var g = kd(r).map(function(t) {
			return p + e * t;
		});
		return n(h ? g.reverse() : g);
	}
	return delete r.unknown, h(p, "rescale"), r.domain = function(e) {
		return arguments.length ? (i(e), p()) : i();
	}, r.range = function(e) {
		return arguments.length ? ([a, s] = e, a *= 1, s *= 1, p()) : [a, s];
	}, r.rangeRound = function(e) {
		return [a, s] = e, a *= 1, s *= 1, o = !0, p();
	}, r.bandwidth = function() {
		return t;
	}, r.step = function() {
		return e;
	}, r.round = function(e) {
		return arguments.length ? (o = !!e, p()) : o;
	}, r.padding = function(e) {
		return arguments.length ? (l = Math.min(1, u = +e), p()) : l;
	}, r.paddingInner = function(e) {
		return arguments.length ? (l = Math.min(1, e), p()) : l;
	}, r.paddingOuter = function(e) {
		return arguments.length ? (u = +e, p()) : u;
	}, r.align = function(e) {
		return arguments.length ? (d = Math.max(0, Math.min(1, e)), p()) : d;
	}, r.copy = function() {
		return Aw(i(), [a, s]).round(o).paddingInner(l).paddingOuter(u).align(d);
	}, Cf.apply(p(), arguments);
}
function Ak(e) {
	for (var t = e.length / 6 | 0, r = Array(t), i = 0; i < t;) r[i] = "#" + e.slice(6 * i, 6 * ++i);
	return r;
}
h(Sd, "pad"), h(Sp, "requote"), h(Sf, "formatRe"), h(Sg, "formatLookup"), h(Sm, "parseWeekdayNumberSunday"), h(Sy, "parseWeekdayNumberMonday"), h(Sv, "parseWeekNumberSunday"), h(Sx, "parseWeekNumberISO"), h(Sb, "parseWeekNumberMonday"), h(Sw, "parseFullYear"), h(Sk, "parseYear"), h(ST, "parseZone"), h(S_, "parseQuarter"), h(SE, "parseMonthNumber"), h(SC, "parseDayOfMonth"), h(SS, "parseDayOfYear"), h(SA, "parseHour24"), h(SL, "parseMinutes"), h(SR, "parseSeconds"), h(SN, "parseMilliseconds"), h(SI, "parseMicroseconds"), h(SM, "parseLiteralPercent"), h(SD, "parseUnixTimestamp"), h(SO, "parseUnixTimestampSeconds"), h(S$, "formatDayOfMonth"), h(SP, "formatHour24"), h(SB, "formatHour12"), h(SF, "formatDayOfYear"), h(Sz, "formatMilliseconds"), h(SU, "formatMicroseconds"), h(SG, "formatMonthNumber"), h(Sq, "formatMinutes"), h(Sj, "formatSeconds"), h(SW, "formatWeekdayNumberMonday"), h(SY, "formatWeekNumberSunday"), h(SV, "dISO"), h(SH, "formatWeekNumberISO"), h(SX, "formatWeekdayNumberSunday"), h(SK, "formatWeekNumberMonday"), h(SZ, "formatYear"), h(SQ, "formatYearISO"), h(SJ, "formatFullYear"), h(S0, "formatFullYearISO"), h(S1, "formatZone"), h(S2, "formatUTCDayOfMonth"), h(S4, "formatUTCHour24"), h(S5, "formatUTCHour12"), h(S3, "formatUTCDayOfYear"), h(S6, "formatUTCMilliseconds"), h(S7, "formatUTCMicroseconds"), h(S8, "formatUTCMonthNumber"), h(S9, "formatUTCMinutes"), h(Ae, "formatUTCSeconds"), h(At, "formatUTCWeekdayNumberMonday"), h(Ar, "formatUTCWeekNumberSunday"), h(Ai, "UTCdISO"), h(An, "formatUTCWeekNumberISO"), h(Aa, "formatUTCWeekdayNumberSunday"), h(As, "formatUTCWeekNumberMonday"), h(Ao, "formatUTCYear"), h(Al, "formatUTCYearISO"), h(Ac, "formatUTCFullYear"), h(Ah, "formatUTCFullYearISO"), h(Au, "formatUTCZone"), h(Ad, "formatLiteralPercent"), h(Ap, "formatUnixTimestamp"), h(Af, "formatUnixTimestampSeconds"), Ag({
	dateTime: "%x, %X",
	date: "%-m/%-d/%Y",
	time: "%-I:%M:%S %p",
	periods: ["AM", "PM"],
	days: [
		"Sunday",
		"Monday",
		"Tuesday",
		"Wednesday",
		"Thursday",
		"Friday",
		"Saturday"
	],
	shortDays: [
		"Sun",
		"Mon",
		"Tue",
		"Wed",
		"Thu",
		"Fri",
		"Sat"
	],
	months: [
		"January",
		"February",
		"March",
		"April",
		"May",
		"June",
		"July",
		"August",
		"September",
		"October",
		"November",
		"December"
	],
	shortMonths: [
		"Jan",
		"Feb",
		"Mar",
		"Apr",
		"May",
		"Jun",
		"Jul",
		"Aug",
		"Sep",
		"Oct",
		"Nov",
		"Dec"
	]
}), h(Ag, "defaultLocale"), h(Am, "nice"), h(Ay, "date"), h(Av, "number"), h(Ax, "calendar"), h(Ab, "time"), h(Aw, "band"), h(Ak, "default");
var AT = Ak("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");
function A_(e) {
	return h(function() {
		return e;
	}, "constant");
}
h(A_, "default");
var AE = Math.abs, AC = Math.atan2, AS = Math.cos, AA = Math.max, AL = Math.min, AR = Math.sin, AN = Math.sqrt, AI = Math.PI, AM = AI / 2, AD = 2 * AI;
function AO(e) {
	return e > 1 ? 0 : e < -1 ? AI : Math.acos(e);
}
function A$(e) {
	return e >= 1 ? AM : e <= -1 ? -AM : Math.asin(e);
}
h(AO, "acos"), h(A$, "asin");
var AP = Math.PI, AB = 2 * AP, AF = AB - 1e-6;
function Az(e) {
	this._ += e[0];
	for (let t = 1, r = e.length; t < r; ++t) this._ += arguments[t] + e[t];
}
function AU(e) {
	let t = Math.floor(e);
	if (!(t >= 0)) throw Error(`invalid digits: ${e}`);
	if (t > 15) return Az;
	let r = 10 ** t;
	return function(e) {
		this._ += e[0];
		for (let t = 1, i = e.length; t < i; ++t) this._ += Math.round(arguments[t] * r) / r + e[t];
	};
}
h(Az, "append"), h(AU, "appendRound");
var AG = class {
	static {
		h(this, "Path");
	}
	constructor(e) {
		this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = "", this._append = null == e ? Az : AU(e);
	}
	moveTo(e, t) {
		this._append`M${this._x0 = this._x1 = +e},${this._y0 = this._y1 = +t}`;
	}
	closePath() {
		null !== this._x1 && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
	}
	lineTo(e, t) {
		this._append`L${this._x1 = +e},${this._y1 = +t}`;
	}
	quadraticCurveTo(e, t, r, i) {
		this._append`Q${+e},${+t},${this._x1 = +r},${this._y1 = +i}`;
	}
	bezierCurveTo(e, t, r, i, n, a) {
		this._append`C${+e},${+t},${+r},${+i},${this._x1 = +n},${this._y1 = +a}`;
	}
	arcTo(e, t, r, i, n) {
		if (e *= 1, t *= 1, r *= 1, i *= 1, (n *= 1) < 0) throw Error(`negative radius: ${n}`);
		let a = this._x1, s = this._y1, o = r - e, l = i - t, h = a - e, u = s - t, d = h * h + u * u;
		if (null === this._x1) this._append`M${this._x1 = e},${this._y1 = t}`;
		else if (d > 1e-6) if (Math.abs(u * o - l * h) > 1e-6 && n) {
			let p = r - a, f = i - s, g = o * o + l * l, m = Math.sqrt(g), y = Math.sqrt(d), v = n * Math.tan((AP - Math.acos((g + d - (p * p + f * f)) / (2 * m * y))) / 2), x = v / y, b = v / m;
			Math.abs(x - 1) > 1e-6 && this._append`L${e + x * h},${t + x * u}`, this._append`A${n},${n},0,0,${+(u * p > h * f)},${this._x1 = e + b * o},${this._y1 = t + b * l}`;
		} else this._append`L${this._x1 = e},${this._y1 = t}`;
	}
	arc(e, t, r, i, n, a) {
		if (e *= 1, t *= 1, r *= 1, a = !!a, r < 0) throw Error(`negative radius: ${r}`);
		let s = r * Math.cos(i), o = r * Math.sin(i), l = e + s, h = t + o, u = 1 ^ a, d = a ? i - n : n - i;
		null === this._x1 ? this._append`M${l},${h}` : (Math.abs(this._x1 - l) > 1e-6 || Math.abs(this._y1 - h) > 1e-6) && this._append`L${l},${h}`, r && (d < 0 && (d = d % AB + AB), d > AF ? this._append`A${r},${r},0,1,${u},${e - s},${t - o}A${r},${r},0,1,${u},${this._x1 = l},${this._y1 = h}` : d > 1e-6 && this._append`A${r},${r},0,${+(d >= AP)},${u},${this._x1 = e + r * Math.cos(n)},${this._y1 = t + r * Math.sin(n)}`);
	}
	rect(e, t, r, i) {
		this._append`M${this._x0 = this._x1 = +e},${this._y0 = this._y1 = +t}h${r *= 1}v${+i}h${-r}Z`;
	}
	toString() {
		return this._;
	}
};
function Aq() {
	return new AG();
}
function Aj(e) {
	let t = 3;
	return e.digits = function(r) {
		if (!arguments.length) return t;
		if (null == r) t = null;
		else {
			let e = Math.floor(r);
			if (!(e >= 0)) throw RangeError(`invalid digits: ${r}`);
			t = e;
		}
		return e;
	}, () => new AG(t);
}
function AW(e) {
	return e.innerRadius;
}
function AY(e) {
	return e.outerRadius;
}
function AV(e) {
	return e.startAngle;
}
function AH(e) {
	return e.endAngle;
}
function AX(e) {
	return e && e.padAngle;
}
function AK(e, t, r, i, n, a, s, o) {
	var l = r - e, h = i - t, u = s - n, d = o - a, p = d * l - u * h;
	if (!(p * p < 1e-12)) return p = (u * (t - a) - d * (e - n)) / p, [e + p * l, t + p * h];
}
function AZ(e, t, r, i, n, a, s) {
	var o = e - r, l = t - i, h = (s ? a : -a) / AN(o * o + l * l), u = h * l, d = -h * o, p = e + u, f = t + d, g = r + u, m = i + d, y = (p + g) / 2, v = (f + m) / 2, x = g - p, b = m - f, w = x * x + b * b, k = n - a, T = p * m - g * f, _ = (b < 0 ? -1 : 1) * AN(AA(0, k * k * w - T * T)), E = (T * b - x * _) / w, C = (-T * x - b * _) / w, S = (T * b + x * _) / w, A = (-T * x + b * _) / w, L = E - y, R = C - v, N = S - y, I = A - v;
	return L * L + R * R > N * N + I * I && (E = S, C = A), {
		cx: E,
		cy: C,
		x01: -u,
		y01: -d,
		x11: E * (n / k - 1),
		y11: C * (n / k - 1)
	};
}
function AQ() {
	var e = AW, t = AY, r = A_(0), i = null, n = AV, a = AH, s = AX, o = null, l = Aj(u);
	function u() {
		var h, u, d = +e.apply(this, arguments), p = +t.apply(this, arguments), f = n.apply(this, arguments) - AM, g = a.apply(this, arguments) - AM, m = AE(g - f), y = g > f;
		if (o || (o = h = l()), p < d && (u = p, p = d, d = u), p > 1e-12) if (m > AD - 1e-12) o.moveTo(p * AS(f), p * AR(f)), o.arc(0, 0, p, f, g, !y), d > 1e-12 && (o.moveTo(d * AS(g), d * AR(g)), o.arc(0, 0, d, g, f, y));
		else {
			var v, x, b = f, w = g, k = f, T = g, _ = m, E = m, C = s.apply(this, arguments) / 2, S = C > 1e-12 && (i ? +i.apply(this, arguments) : AN(d * d + p * p)), A = AL(AE(p - d) / 2, +r.apply(this, arguments)), L = A, R = A;
			if (S > 1e-12) {
				var N = A$(S / d * AR(C)), I = A$(S / p * AR(C));
				(_ -= 2 * N) > 1e-12 ? (N *= y ? 1 : -1, k += N, T -= N) : (_ = 0, k = T = (f + g) / 2), (E -= 2 * I) > 1e-12 ? (I *= y ? 1 : -1, b += I, w -= I) : (E = 0, b = w = (f + g) / 2);
			}
			var M = p * AS(b), D = p * AR(b), O = d * AS(T), $ = d * AR(T);
			if (A > 1e-12) {
				var P, B = p * AS(w), F = p * AR(w), z = d * AS(k), U = d * AR(k);
				if (m < AI) if (P = AK(M, D, z, U, B, F, O, $)) {
					var G = M - P[0], q = D - P[1], j = B - P[0], W = F - P[1], Y = 1 / AR(AO((G * j + q * W) / (AN(G * G + q * q) * AN(j * j + W * W))) / 2), V = AN(P[0] * P[0] + P[1] * P[1]);
					L = AL(A, (d - V) / (Y - 1)), R = AL(A, (p - V) / (Y + 1));
				} else L = R = 0;
			}
			E > 1e-12 ? R > 1e-12 ? (v = AZ(z, U, M, D, p, R, y), x = AZ(B, F, O, $, p, R, y), o.moveTo(v.cx + v.x01, v.cy + v.y01), R < A ? o.arc(v.cx, v.cy, R, AC(v.y01, v.x01), AC(x.y01, x.x01), !y) : (o.arc(v.cx, v.cy, R, AC(v.y01, v.x01), AC(v.y11, v.x11), !y), o.arc(0, 0, p, AC(v.cy + v.y11, v.cx + v.x11), AC(x.cy + x.y11, x.cx + x.x11), !y), o.arc(x.cx, x.cy, R, AC(x.y11, x.x11), AC(x.y01, x.x01), !y))) : (o.moveTo(M, D), o.arc(0, 0, p, b, w, !y)) : o.moveTo(M, D), d > 1e-12 && _ > 1e-12 ? L > 1e-12 ? (v = AZ(O, $, B, F, d, -L, y), x = AZ(M, D, z, U, d, -L, y), o.lineTo(v.cx + v.x01, v.cy + v.y01), L < A ? o.arc(v.cx, v.cy, L, AC(v.y01, v.x01), AC(x.y01, x.x01), !y) : (o.arc(v.cx, v.cy, L, AC(v.y01, v.x01), AC(v.y11, v.x11), !y), o.arc(0, 0, d, AC(v.cy + v.y11, v.cx + v.x11), AC(x.cy + x.y11, x.cx + x.x11), y), o.arc(x.cx, x.cy, L, AC(x.y11, x.x11), AC(x.y01, x.x01), !y))) : o.arc(0, 0, d, T, k, y) : o.lineTo(O, $);
		}
		else o.moveTo(0, 0);
		if (o.closePath(), h) return o = null, h + "" || null;
	}
	return h(u, "arc"), u.centroid = function() {
		var r = (+e.apply(this, arguments) + +t.apply(this, arguments)) / 2, i = (+n.apply(this, arguments) + +a.apply(this, arguments)) / 2 - AI / 2;
		return [AS(i) * r, AR(i) * r];
	}, u.innerRadius = function(t) {
		return arguments.length ? (e = "function" == typeof t ? t : A_(+t), u) : e;
	}, u.outerRadius = function(e) {
		return arguments.length ? (t = "function" == typeof e ? e : A_(+e), u) : t;
	}, u.cornerRadius = function(e) {
		return arguments.length ? (r = "function" == typeof e ? e : A_(+e), u) : r;
	}, u.padRadius = function(e) {
		return arguments.length ? (i = null == e ? null : "function" == typeof e ? e : A_(+e), u) : i;
	}, u.startAngle = function(e) {
		return arguments.length ? (n = "function" == typeof e ? e : A_(+e), u) : n;
	}, u.endAngle = function(e) {
		return arguments.length ? (a = "function" == typeof e ? e : A_(+e), u) : a;
	}, u.padAngle = function(e) {
		return arguments.length ? (s = "function" == typeof e ? e : A_(+e), u) : s;
	}, u.context = function(e) {
		return arguments.length ? (o = e ?? null, u) : o;
	}, u;
}
function AJ(e) {
	this._context = e;
}
function A0(e) {
	return new AJ(e);
}
function A1(e) {
	return "object" == typeof e && "length" in e ? e : Array.from(e);
}
function A2(e) {
	return e[0];
}
function A4(e) {
	return e[1];
}
function A5(e, t) {
	var r = A_(!0), i = null, n = A0, a = null, s = Aj(o);
	function o(o) {
		var l, h, u, d = (o = A1(o)).length, p = !1;
		for (i ?? (a = n(u = s())), l = 0; l <= d; ++l) !(l < d && r(h = o[l], l, o)) === p && ((p = !p) ? a.lineStart() : a.lineEnd()), p && a.point(+e(h, l, o), +t(h, l, o));
		if (u) return a = null, u + "" || null;
	}
	return e = "function" == typeof e ? e : void 0 === e ? A2 : A_(e), t = "function" == typeof t ? t : void 0 === t ? A4 : A_(t), h(o, "line"), o.x = function(t) {
		return arguments.length ? (e = "function" == typeof t ? t : A_(+t), o) : e;
	}, o.y = function(e) {
		return arguments.length ? (t = "function" == typeof e ? e : A_(+e), o) : t;
	}, o.defined = function(e) {
		return arguments.length ? (r = "function" == typeof e ? e : A_(!!e), o) : r;
	}, o.curve = function(e) {
		return arguments.length ? (n = e, null != i && (a = n(i)), o) : n;
	}, o.context = function(e) {
		return arguments.length ? (null == e ? i = a = null : a = n(i = e), o) : i;
	}, o;
}
function A3(e, t) {
	return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function A6(e) {
	return e;
}
function A7() {
	var e = A6, t = A3, r = null, i = A_(0), n = A_(AD), a = A_(0);
	function s(s) {
		var o, l, h, u, d, p = (s = A1(s)).length, f = 0, g = Array(p), m = Array(p), y = +i.apply(this, arguments), v = Math.min(AD, Math.max(-AD, n.apply(this, arguments) - y)), x = Math.min(Math.abs(v) / p, a.apply(this, arguments)), b = x * (v < 0 ? -1 : 1);
		for (o = 0; o < p; ++o) (d = m[g[o] = o] = +e(s[o], o, s)) > 0 && (f += d);
		for (null != t ? g.sort(function(e, r) {
			return t(m[e], m[r]);
		}) : null != r && g.sort(function(e, t) {
			return r(s[e], s[t]);
		}), o = 0, h = f ? (v - p * b) / f : 0; o < p; ++o, y = u) u = y + ((d = m[l = g[o]]) > 0 ? d * h : 0) + b, m[l] = {
			data: s[l],
			index: o,
			value: d,
			startAngle: y,
			endAngle: u,
			padAngle: x
		};
		return m;
	}
	return h(s, "pie"), s.value = function(t) {
		return arguments.length ? (e = "function" == typeof t ? t : A_(+t), s) : e;
	}, s.sortValues = function(e) {
		return arguments.length ? (t = e, r = null, s) : t;
	}, s.sort = function(e) {
		return arguments.length ? (r = e, t = null, s) : r;
	}, s.startAngle = function(e) {
		return arguments.length ? (i = "function" == typeof e ? e : A_(+e), s) : i;
	}, s.endAngle = function(e) {
		return arguments.length ? (n = "function" == typeof e ? e : A_(+e), s) : n;
	}, s.padAngle = function(e) {
		return arguments.length ? (a = "function" == typeof e ? e : A_(+e), s) : a;
	}, s;
}
h(Aq, "path"), Aq.prototype = AG.prototype, h(Aj, "withPath"), h(AW, "arcInnerRadius"), h(AY, "arcOuterRadius"), h(AV, "arcStartAngle"), h(AH, "arcEndAngle"), h(AX, "arcPadAngle"), h(AK, "intersect"), h(AZ, "cornerTangents"), h(AQ, "default"), h(AJ, "Linear"), AJ.prototype = {
	areaStart: h(function() {
		this._line = 0;
	}, "areaStart"),
	areaEnd: h(function() {
		this._line = NaN;
	}, "areaEnd"),
	lineStart: h(function() {
		this._point = 0;
	}, "lineStart"),
	lineEnd: h(function() {
		(this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line;
	}, "lineEnd"),
	point: h(function(e, t) {
		switch (e *= 1, t *= 1, this._point) {
			case 0:
				this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
				break;
			case 1: this._point = 2;
			default: this._context.lineTo(e, t);
		}
	}, "point")
}, h(A0, "default"), Array.prototype.slice, h(A1, "default"), h(A2, "x"), h(A4, "y"), h(A5, "default"), h(A3, "default"), h(A6, "default"), h(A7, "default");
var A8 = class {
	static {
		h(this, "Bump");
	}
	constructor(e, t) {
		this._context = e, this._x = t;
	}
	areaStart() {
		this._line = 0;
	}
	areaEnd() {
		this._line = NaN;
	}
	lineStart() {
		this._point = 0;
	}
	lineEnd() {
		(this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line;
	}
	point(e, t) {
		switch (e *= 1, t *= 1, this._point) {
			case 0:
				this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
				break;
			case 1: this._point = 2;
			default: this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + e) / 2, this._y0, this._x0, t, e, t) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + t) / 2, e, this._y0, e, t);
		}
		this._x0 = e, this._y0 = t;
	}
};
function A9(e) {
	return new A8(e, !0);
}
function Le(e) {
	return new A8(e, !1);
}
function Lt(e, t, r) {
	e._context.bezierCurveTo((2 * e._x0 + e._x1) / 3, (2 * e._y0 + e._y1) / 3, (e._x0 + 2 * e._x1) / 3, (e._y0 + 2 * e._y1) / 3, (e._x0 + 4 * e._x1 + t) / 6, (e._y0 + 4 * e._y1 + r) / 6);
}
function Lr(e) {
	this._context = e;
}
function Li(e) {
	return new Lr(e);
}
function Ln() {}
function La(e) {
	this._context = e;
}
function Ls(e) {
	return new La(e);
}
function Lo(e) {
	this._context = e;
}
function Ll(e) {
	return new Lo(e);
}
function Lc(e, t) {
	this._basis = new Lr(e), this._beta = t;
}
h(A9, "bumpX"), h(Le, "bumpY"), h(Lt, "point"), h(Lr, "Basis"), Lr.prototype = {
	areaStart: h(function() {
		this._line = 0;
	}, "areaStart"),
	areaEnd: h(function() {
		this._line = NaN;
	}, "areaEnd"),
	lineStart: h(function() {
		this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
	}, "lineStart"),
	lineEnd: h(function() {
		switch (this._point) {
			case 3: Lt(this, this._x1, this._y1);
			case 2: this._context.lineTo(this._x1, this._y1);
		}
		(this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line;
	}, "lineEnd"),
	point: h(function(e, t) {
		switch (e *= 1, t *= 1, this._point) {
			case 0:
				this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
				break;
			case 1:
				this._point = 2;
				break;
			case 2: this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
			default: Lt(this, e, t);
		}
		this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
	}, "point")
}, h(Li, "default"), h(Ln, "default"), h(La, "BasisClosed"), La.prototype = {
	areaStart: Ln,
	areaEnd: Ln,
	lineStart: h(function() {
		this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
	}, "lineStart"),
	lineEnd: h(function() {
		switch (this._point) {
			case 1:
				this._context.moveTo(this._x2, this._y2), this._context.closePath();
				break;
			case 2:
				this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
				break;
			case 3: this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
		}
	}, "lineEnd"),
	point: h(function(e, t) {
		switch (e *= 1, t *= 1, this._point) {
			case 0:
				this._point = 1, this._x2 = e, this._y2 = t;
				break;
			case 1:
				this._point = 2, this._x3 = e, this._y3 = t;
				break;
			case 2:
				this._point = 3, this._x4 = e, this._y4 = t, this._context.moveTo((this._x0 + 4 * this._x1 + e) / 6, (this._y0 + 4 * this._y1 + t) / 6);
				break;
			default: Lt(this, e, t);
		}
		this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
	}, "point")
}, h(Ls, "default"), h(Lo, "BasisOpen"), Lo.prototype = {
	areaStart: h(function() {
		this._line = 0;
	}, "areaStart"),
	areaEnd: h(function() {
		this._line = NaN;
	}, "areaEnd"),
	lineStart: h(function() {
		this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
	}, "lineStart"),
	lineEnd: h(function() {
		(this._line || 0 !== this._line && 3 === this._point) && this._context.closePath(), this._line = 1 - this._line;
	}, "lineEnd"),
	point: h(function(e, t) {
		switch (e *= 1, t *= 1, this._point) {
			case 0:
				this._point = 1;
				break;
			case 1:
				this._point = 2;
				break;
			case 2:
				this._point = 3;
				var r = (this._x0 + 4 * this._x1 + e) / 6, i = (this._y0 + 4 * this._y1 + t) / 6;
				this._line ? this._context.lineTo(r, i) : this._context.moveTo(r, i);
				break;
			case 3: this._point = 4;
			default: Lt(this, e, t);
		}
		this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t;
	}, "point")
}, h(Ll, "default"), h(Lc, "Bundle"), Lc.prototype = {
	lineStart: h(function() {
		this._x = [], this._y = [], this._basis.lineStart();
	}, "lineStart"),
	lineEnd: h(function() {
		var e = this._x, t = this._y, r = e.length - 1;
		if (r > 0) for (var i, n = e[0], a = t[0], s = e[r] - n, o = t[r] - a, l = -1; ++l <= r;) i = l / r, this._basis.point(this._beta * e[l] + (1 - this._beta) * (n + i * s), this._beta * t[l] + (1 - this._beta) * (a + i * o));
		this._x = this._y = null, this._basis.lineEnd();
	}, "lineEnd"),
	point: h(function(e, t) {
		this._x.push(+e), this._y.push(+t);
	}, "point")
};
var Lh = h(function e(t) {
	function r(e) {
		return 1 === t ? new Lr(e) : new Lc(e, t);
	}
	return h(r, "bundle"), r.beta = function(t) {
		return e(+t);
	}, r;
}, "custom")(.85);
function Lu(e, t, r) {
	e._context.bezierCurveTo(e._x1 + e._k * (e._x2 - e._x0), e._y1 + e._k * (e._y2 - e._y0), e._x2 + e._k * (e._x1 - t), e._y2 + e._k * (e._y1 - r), e._x2, e._y2);
}
function Ld(e, t) {
	this._context = e, this._k = (1 - t) / 6;
}
h(Lu, "point"), h(Ld, "Cardinal"), Ld.prototype = {
	areaStart: h(function() {
		this._line = 0;
	}, "areaStart"),
	areaEnd: h(function() {
		this._line = NaN;
	}, "areaEnd"),
	lineStart: h(function() {
		this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
	}, "lineStart"),
	lineEnd: h(function() {
		switch (this._point) {
			case 2:
				this._context.lineTo(this._x2, this._y2);
				break;
			case 3: Lu(this, this._x1, this._y1);
		}
		(this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line;
	}, "lineEnd"),
	point: h(function(e, t) {
		switch (e *= 1, t *= 1, this._point) {
			case 0:
				this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
				break;
			case 1:
				this._point = 2, this._x1 = e, this._y1 = t;
				break;
			case 2: this._point = 3;
			default: Lu(this, e, t);
		}
		this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
	}, "point")
};
var Lp = h(function e(t) {
	function r(e) {
		return new Ld(e, t);
	}
	return h(r, "cardinal"), r.tension = function(t) {
		return e(+t);
	}, r;
}, "custom")(0);
function Lf(e, t) {
	this._context = e, this._k = (1 - t) / 6;
}
h(Lf, "CardinalClosed"), Lf.prototype = {
	areaStart: Ln,
	areaEnd: Ln,
	lineStart: h(function() {
		this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._point = 0;
	}, "lineStart"),
	lineEnd: h(function() {
		switch (this._point) {
			case 1:
				this._context.moveTo(this._x3, this._y3), this._context.closePath();
				break;
			case 2:
				this._context.lineTo(this._x3, this._y3), this._context.closePath();
				break;
			case 3: this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
		}
	}, "lineEnd"),
	point: h(function(e, t) {
		switch (e *= 1, t *= 1, this._point) {
			case 0:
				this._point = 1, this._x3 = e, this._y3 = t;
				break;
			case 1:
				this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
				break;
			case 2:
				this._point = 3, this._x5 = e, this._y5 = t;
				break;
			default: Lu(this, e, t);
		}
		this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
	}, "point")
};
var Lg = h(function e(t) {
	function r(e) {
		return new Lf(e, t);
	}
	return h(r, "cardinal"), r.tension = function(t) {
		return e(+t);
	}, r;
}, "custom")(0);
function Lm(e, t) {
	this._context = e, this._k = (1 - t) / 6;
}
h(Lm, "CardinalOpen"), Lm.prototype = {
	areaStart: h(function() {
		this._line = 0;
	}, "areaStart"),
	areaEnd: h(function() {
		this._line = NaN;
	}, "areaEnd"),
	lineStart: h(function() {
		this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
	}, "lineStart"),
	lineEnd: h(function() {
		(this._line || 0 !== this._line && 3 === this._point) && this._context.closePath(), this._line = 1 - this._line;
	}, "lineEnd"),
	point: h(function(e, t) {
		switch (e *= 1, t *= 1, this._point) {
			case 0:
				this._point = 1;
				break;
			case 1:
				this._point = 2;
				break;
			case 2:
				this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
				break;
			case 3: this._point = 4;
			default: Lu(this, e, t);
		}
		this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
	}, "point")
};
var Ly = h(function e(t) {
	function r(e) {
		return new Lm(e, t);
	}
	return h(r, "cardinal"), r.tension = function(t) {
		return e(+t);
	}, r;
}, "custom")(0);
function Lv(e, t, r) {
	var i = e._x1, n = e._y1, a = e._x2, s = e._y2;
	if (e._l01_a > 1e-12) {
		var o = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a, l = 3 * e._l01_a * (e._l01_a + e._l12_a);
		i = (i * o - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / l, n = (n * o - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / l;
	}
	if (e._l23_a > 1e-12) {
		var h = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a, u = 3 * e._l23_a * (e._l23_a + e._l12_a);
		a = (a * h + e._x1 * e._l23_2a - t * e._l12_2a) / u, s = (s * h + e._y1 * e._l23_2a - r * e._l12_2a) / u;
	}
	e._context.bezierCurveTo(i, n, a, s, e._x2, e._y2);
}
function Lx(e, t) {
	this._context = e, this._alpha = t;
}
h(Lv, "point"), h(Lx, "CatmullRom"), Lx.prototype = {
	areaStart: h(function() {
		this._line = 0;
	}, "areaStart"),
	areaEnd: h(function() {
		this._line = NaN;
	}, "areaEnd"),
	lineStart: h(function() {
		this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
	}, "lineStart"),
	lineEnd: h(function() {
		switch (this._point) {
			case 2:
				this._context.lineTo(this._x2, this._y2);
				break;
			case 3: this.point(this._x2, this._y2);
		}
		(this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line;
	}, "lineEnd"),
	point: h(function(e, t) {
		if (e *= 1, t *= 1, this._point) {
			var r = this._x2 - e, i = this._y2 - t;
			this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + i * i, this._alpha));
		}
		switch (this._point) {
			case 0:
				this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
				break;
			case 1:
				this._point = 2;
				break;
			case 2: this._point = 3;
			default: Lv(this, e, t);
		}
		this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
	}, "point")
};
var Lb = h(function e(t) {
	function r(e) {
		return t ? new Lx(e, t) : new Ld(e, 0);
	}
	return h(r, "catmullRom"), r.alpha = function(t) {
		return e(+t);
	}, r;
}, "custom")(.5);
function Lw(e, t) {
	this._context = e, this._alpha = t;
}
h(Lw, "CatmullRomClosed"), Lw.prototype = {
	areaStart: Ln,
	areaEnd: Ln,
	lineStart: h(function() {
		this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
	}, "lineStart"),
	lineEnd: h(function() {
		switch (this._point) {
			case 1:
				this._context.moveTo(this._x3, this._y3), this._context.closePath();
				break;
			case 2:
				this._context.lineTo(this._x3, this._y3), this._context.closePath();
				break;
			case 3: this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
		}
	}, "lineEnd"),
	point: h(function(e, t) {
		if (e *= 1, t *= 1, this._point) {
			var r = this._x2 - e, i = this._y2 - t;
			this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + i * i, this._alpha));
		}
		switch (this._point) {
			case 0:
				this._point = 1, this._x3 = e, this._y3 = t;
				break;
			case 1:
				this._point = 2, this._context.moveTo(this._x4 = e, this._y4 = t);
				break;
			case 2:
				this._point = 3, this._x5 = e, this._y5 = t;
				break;
			default: Lv(this, e, t);
		}
		this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
	}, "point")
};
var Lk = h(function e(t) {
	function r(e) {
		return t ? new Lw(e, t) : new Lf(e, 0);
	}
	return h(r, "catmullRom"), r.alpha = function(t) {
		return e(+t);
	}, r;
}, "custom")(.5);
function LT(e, t) {
	this._context = e, this._alpha = t;
}
h(LT, "CatmullRomOpen"), LT.prototype = {
	areaStart: h(function() {
		this._line = 0;
	}, "areaStart"),
	areaEnd: h(function() {
		this._line = NaN;
	}, "areaEnd"),
	lineStart: h(function() {
		this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
	}, "lineStart"),
	lineEnd: h(function() {
		(this._line || 0 !== this._line && 3 === this._point) && this._context.closePath(), this._line = 1 - this._line;
	}, "lineEnd"),
	point: h(function(e, t) {
		if (e *= 1, t *= 1, this._point) {
			var r = this._x2 - e, i = this._y2 - t;
			this._l23_a = Math.sqrt(this._l23_2a = Math.pow(r * r + i * i, this._alpha));
		}
		switch (this._point) {
			case 0:
				this._point = 1;
				break;
			case 1:
				this._point = 2;
				break;
			case 2:
				this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
				break;
			case 3: this._point = 4;
			default: Lv(this, e, t);
		}
		this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = t;
	}, "point")
};
var L_ = h(function e(t) {
	function r(e) {
		return t ? new LT(e, t) : new Lm(e, 0);
	}
	return h(r, "catmullRom"), r.alpha = function(t) {
		return e(+t);
	}, r;
}, "custom")(.5);
function LE(e) {
	this._context = e;
}
function LC(e) {
	return new LE(e);
}
function LS(e) {
	return e < 0 ? -1 : 1;
}
function LA(e, t, r) {
	var i = e._x1 - e._x0, n = t - e._x1, a = (e._y1 - e._y0) / (i || n < 0 && -0), s = (r - e._y1) / (n || i < 0 && -0), o = (a * n + s * i) / (i + n);
	return (LS(a) + LS(s)) * Math.min(Math.abs(a), Math.abs(s), .5 * Math.abs(o)) || 0;
}
function LL(e, t) {
	var r = e._x1 - e._x0;
	return r ? (3 * (e._y1 - e._y0) / r - t) / 2 : t;
}
function LR(e, t, r) {
	var i = e._x0, n = e._y0, a = e._x1, s = e._y1, o = (a - i) / 3;
	e._context.bezierCurveTo(i + o, n + o * t, a - o, s - o * r, a, s);
}
function LN(e) {
	this._context = e;
}
function LI(e) {
	this._context = new LM(e);
}
function LM(e) {
	this._context = e;
}
function LD(e) {
	return new LN(e);
}
function LO(e) {
	return new LI(e);
}
function L$(e) {
	this._context = e;
}
function LP(e) {
	var t, r, i = e.length - 1, n = Array(i), a = Array(i), s = Array(i);
	for (n[0] = 0, a[0] = 2, s[0] = e[0] + 2 * e[1], t = 1; t < i - 1; ++t) n[t] = 1, a[t] = 4, s[t] = 4 * e[t] + 2 * e[t + 1];
	for (n[i - 1] = 2, a[i - 1] = 7, s[i - 1] = 8 * e[i - 1] + e[i], t = 1; t < i; ++t) r = n[t] / a[t - 1], a[t] -= r, s[t] -= r * s[t - 1];
	for (n[i - 1] = s[i - 1] / a[i - 1], t = i - 2; t >= 0; --t) n[t] = (s[t] - n[t + 1]) / a[t];
	for (a[i - 1] = (e[i] + n[i - 1]) / 2, t = 0; t < i - 1; ++t) a[t] = 2 * e[t + 1] - n[t + 1];
	return [n, a];
}
function LB(e) {
	return new L$(e);
}
function LF(e, t) {
	this._context = e, this._t = t;
}
function Lz(e) {
	return new LF(e, .5);
}
function LU(e) {
	return new LF(e, 0);
}
function LG(e) {
	return new LF(e, 1);
}
h(LE, "LinearClosed"), LE.prototype = {
	areaStart: Ln,
	areaEnd: Ln,
	lineStart: h(function() {
		this._point = 0;
	}, "lineStart"),
	lineEnd: h(function() {
		this._point && this._context.closePath();
	}, "lineEnd"),
	point: h(function(e, t) {
		e *= 1, t *= 1, this._point ? this._context.lineTo(e, t) : (this._point = 1, this._context.moveTo(e, t));
	}, "point")
}, h(LC, "default"), h(LS, "sign"), h(LA, "slope3"), h(LL, "slope2"), h(LR, "point"), h(LN, "MonotoneX"), LN.prototype = {
	areaStart: h(function() {
		this._line = 0;
	}, "areaStart"),
	areaEnd: h(function() {
		this._line = NaN;
	}, "areaEnd"),
	lineStart: h(function() {
		this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
	}, "lineStart"),
	lineEnd: h(function() {
		switch (this._point) {
			case 2:
				this._context.lineTo(this._x1, this._y1);
				break;
			case 3: LR(this, this._t0, LL(this, this._t0));
		}
		(this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line = 1 - this._line;
	}, "lineEnd"),
	point: h(function(e, t) {
		var r = NaN;
		if (t *= 1, (e *= 1) !== this._x1 || t !== this._y1) {
			switch (this._point) {
				case 0:
					this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
					break;
				case 1:
					this._point = 2;
					break;
				case 2:
					this._point = 3, LR(this, LL(this, r = LA(this, e, t)), r);
					break;
				default: LR(this, this._t0, r = LA(this, e, t));
			}
			this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = r;
		}
	}, "point")
}, h(LI, "MonotoneY"), (LI.prototype = Object.create(LN.prototype)).point = function(e, t) {
	LN.prototype.point.call(this, t, e);
}, h(LM, "ReflectContext"), LM.prototype = {
	moveTo: h(function(e, t) {
		this._context.moveTo(t, e);
	}, "moveTo"),
	closePath: h(function() {
		this._context.closePath();
	}, "closePath"),
	lineTo: h(function(e, t) {
		this._context.lineTo(t, e);
	}, "lineTo"),
	bezierCurveTo: h(function(e, t, r, i, n, a) {
		this._context.bezierCurveTo(t, e, i, r, a, n);
	}, "bezierCurveTo")
}, h(LD, "monotoneX"), h(LO, "monotoneY"), h(L$, "Natural"), L$.prototype = {
	areaStart: h(function() {
		this._line = 0;
	}, "areaStart"),
	areaEnd: h(function() {
		this._line = NaN;
	}, "areaEnd"),
	lineStart: h(function() {
		this._x = [], this._y = [];
	}, "lineStart"),
	lineEnd: h(function() {
		var e = this._x, t = this._y, r = e.length;
		if (r) if (this._line ? this._context.lineTo(e[0], t[0]) : this._context.moveTo(e[0], t[0]), 2 === r) this._context.lineTo(e[1], t[1]);
		else for (var i = LP(e), n = LP(t), a = 0, s = 1; s < r; ++a, ++s) this._context.bezierCurveTo(i[0][a], n[0][a], i[1][a], n[1][a], e[s], t[s]);
		(this._line || 0 !== this._line && 1 === r) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
	}, "lineEnd"),
	point: h(function(e, t) {
		this._x.push(+e), this._y.push(+t);
	}, "point")
}, h(LP, "controlPoints"), h(LB, "default"), h(LF, "Step"), LF.prototype = {
	areaStart: h(function() {
		this._line = 0;
	}, "areaStart"),
	areaEnd: h(function() {
		this._line = NaN;
	}, "areaEnd"),
	lineStart: h(function() {
		this._x = this._y = NaN, this._point = 0;
	}, "lineStart"),
	lineEnd: h(function() {
		0 < this._t && this._t < 1 && 2 === this._point && this._context.lineTo(this._x, this._y), (this._line || 0 !== this._line && 1 === this._point) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
	}, "lineEnd"),
	point: h(function(e, t) {
		switch (e *= 1, t *= 1, this._point) {
			case 0:
				this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
				break;
			case 1: this._point = 2;
			default: if (this._t <= 0) this._context.lineTo(this._x, t), this._context.lineTo(e, t);
			else {
				var r = this._x * (1 - this._t) + e * this._t;
				this._context.lineTo(r, this._y), this._context.lineTo(r, t);
			}
		}
		this._x = e, this._y = t;
	}, "point")
}, h(Lz, "default"), h(LU, "stepBefore"), h(LG, "stepAfter");
var Lq = { value: h(() => {}, "value") };
function Lj() {
	for (var e, t = 0, r = arguments.length, i = {}; t < r; ++t) {
		if (!(e = arguments[t] + "") || e in i || /[\s.]/.test(e)) throw Error("illegal type: " + e);
		i[e] = [];
	}
	return new LW(i);
}
function LW(e) {
	this._ = e;
}
function LY(e, t) {
	return e.trim().split(/^|\s+/).map(function(e) {
		var r = "", i = e.indexOf(".");
		if (i >= 0 && (r = e.slice(i + 1), e = e.slice(0, i)), e && !t.hasOwnProperty(e)) throw Error("unknown type: " + e);
		return {
			type: e,
			name: r
		};
	});
}
function LV(e, t) {
	for (var r, i = 0, n = e.length; i < n; ++i) if ((r = e[i]).name === t) return r.value;
}
function LH(e, t, r) {
	for (var i = 0, n = e.length; i < n; ++i) if (e[i].name === t) {
		e[i] = Lq, e = e.slice(0, i).concat(e.slice(i + 1));
		break;
	}
	return null != r && e.push({
		name: t,
		value: r
	}), e;
}
h(Lj, "dispatch"), h(LW, "Dispatch"), h(LY, "parseTypenames"), LW.prototype = Lj.prototype = {
	constructor: LW,
	on: h(function(e, t) {
		var r, i = this._, n = LY(e + "", i), a = -1, s = n.length;
		if (arguments.length < 2) {
			for (; ++a < s;) if ((r = (e = n[a]).type) && (r = LV(i[r], e.name))) return r;
			return;
		}
		if (null != t && "function" != typeof t) throw Error("invalid callback: " + t);
		for (; ++a < s;) if (r = (e = n[a]).type) i[r] = LH(i[r], e.name, t);
		else if (null == t) for (r in i) i[r] = LH(i[r], e.name, null);
		return this;
	}, "on"),
	copy: h(function() {
		var e = {}, t = this._;
		for (var r in t) e[r] = t[r].slice();
		return new LW(e);
	}, "copy"),
	call: h(function(e, t) {
		if ((r = arguments.length - 2) > 0) for (var r, i, n = Array(r), a = 0; a < r; ++a) n[a] = arguments[a + 2];
		if (!this._.hasOwnProperty(e)) throw Error("unknown type: " + e);
		for (i = this._[e], a = 0, r = i.length; a < r; ++a) i[a].value.apply(t, n);
	}, "call"),
	apply: h(function(e, t, r) {
		if (!this._.hasOwnProperty(e)) throw Error("unknown type: " + e);
		for (var i = this._[e], n = 0, a = i.length; n < a; ++n) i[n].value.apply(t, r);
	}, "apply")
}, h(LV, "get"), h(LH, "set");
var LX, LK, LZ, LQ, LJ, L0, L1, L2, L4, L5 = 0, L3 = 0, L6 = 0, L7 = 0, L8 = 0, L9 = 0, Re = "object" == typeof performance && performance.now ? performance : Date, Rt = "object" == typeof window && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
	setTimeout(e, 17);
};
function Rr() {
	return L8 || (Rt(Ri), L8 = Re.now() + L9);
}
function Ri() {
	L8 = 0;
}
function Rn() {
	this._call = this._time = this._next = null;
}
function Ra(e, t, r) {
	var i = new Rn();
	return i.restart(e, t, r), i;
}
function Rs() {
	Rr(), ++L5;
	for (var e, t = L2; t;) (e = L8 - t._time) >= 0 && t._call.call(void 0, e), t = t._next;
	--L5;
}
function Ro() {
	L8 = (L7 = Re.now()) + L9, L5 = L3 = 0;
	try {
		Rs();
	} finally {
		L5 = 0, Rc(), L8 = 0;
	}
}
function Rl() {
	var e = Re.now(), t = e - L7;
	t > 1e3 && (L9 -= t, L7 = e);
}
function Rc() {
	for (var e, t, r = L2, i = Infinity; r;) r._call ? (i > r._time && (i = r._time), e = r, r = r._next) : (t = r._next, r._next = null, r = e ? e._next = t : L2 = t);
	L4 = e, Rh(i);
}
function Rh(e) {
	!L5 && (L3 && (L3 = clearTimeout(L3)), e - L8 > 24 ? (e < Infinity && (L3 = setTimeout(Ro, e - Re.now() - L9)), L6 && (L6 = clearInterval(L6))) : (L6 || (L7 = Re.now(), L6 = setInterval(Rl, 1e3)), L5 = 1, Rt(Ro)));
}
function Ru(e, t, r) {
	var i = new Rn();
	return t = null == t ? 0 : +t, i.restart((r) => {
		i.stop(), e(r + t);
	}, t, r), i;
}
h(Rr, "now"), h(Ri, "clearNow"), h(Rn, "Timer"), Rn.prototype = Ra.prototype = {
	constructor: Rn,
	restart: h(function(e, t, r) {
		if ("function" != typeof e) throw TypeError("callback is not a function");
		r = (null == r ? Rr() : +r) + (null == t ? 0 : +t), this._next || L4 === this || (L4 ? L4._next = this : L2 = this, L4 = this), this._call = e, this._time = r, Rh();
	}, "restart"),
	stop: h(function() {
		this._call && (this._call = null, this._time = Infinity, Rh());
	}, "stop")
}, h(Ra, "timer"), h(Rs, "timerFlush"), h(Ro, "wake"), h(Rl, "poke"), h(Rc, "nap"), h(Rh, "sleep"), h(Ru, "default");
var Rd = Lj("start", "end", "cancel", "interrupt"), Rp = [];
function Rf(e, t, r, i, n, a) {
	var s = e.__transition;
	if (s) {
		if (r in s) return;
	} else e.__transition = {};
	Rv(e, r, {
		name: t,
		index: i,
		group: n,
		on: Rd,
		tween: Rp,
		time: a.time,
		delay: a.delay,
		duration: a.duration,
		ease: a.ease,
		timer: null,
		state: 0
	});
}
function Rg(e, t) {
	var r = Ry(e, t);
	if (r.state > 0) throw Error("too late; already scheduled");
	return r;
}
function Rm(e, t) {
	var r = Ry(e, t);
	if (r.state > 3) throw Error("too late; already running");
	return r;
}
function Ry(e, t) {
	var r = e.__transition;
	if (!r || !(r = r[t])) throw Error("transition not found");
	return r;
}
function Rv(e, t, r) {
	var i, n = e.__transition;
	function a(e) {
		r.state = 1, r.timer.restart(s, r.delay, r.time), r.delay <= e && s(e - r.delay);
	}
	function s(a) {
		var h, u, d, p;
		if (1 !== r.state) return l();
		for (h in n) if ((p = n[h]).name === r.name) {
			if (3 === p.state) return Ru(s);
			4 === p.state ? (p.state = 6, p.timer.stop(), p.on.call("interrupt", e, e.__data__, p.index, p.group), delete n[h]) : +h < t && (p.state = 6, p.timer.stop(), p.on.call("cancel", e, e.__data__, p.index, p.group), delete n[h]);
		}
		if (Ru(function() {
			3 === r.state && (r.state = 4, r.timer.restart(o, r.delay, r.time), o(a));
		}), r.state = 2, r.on.call("start", e, e.__data__, r.index, r.group), 2 === r.state) {
			for (r.state = 3, i = Array(d = r.tween.length), h = 0, u = -1; h < d; ++h) (p = r.tween[h].value.call(e, e.__data__, r.index, r.group)) && (i[++u] = p);
			i.length = u + 1;
		}
	}
	function o(t) {
		for (var n = t < r.duration ? r.ease.call(null, t / r.duration) : (r.timer.restart(l), r.state = 5, 1), a = -1, s = i.length; ++a < s;) i[a].call(e, n);
		5 === r.state && (r.on.call("end", e, e.__data__, r.index, r.group), l());
	}
	function l() {
		for (var i in r.state = 6, r.timer.stop(), delete n[t], n) return;
		delete e.__transition;
	}
	n[t] = r, r.timer = Ra(a, 0, r.time), h(a, "schedule"), h(s, "start"), h(o, "tick"), h(l, "stop");
}
function Rx(e, t) {
	var r, i, n, a = e.__transition, s = !0;
	if (a) {
		for (n in t = null == t ? null : t + "", a) {
			if ((r = a[n]).name !== t) {
				s = !1;
				continue;
			}
			i = r.state > 2 && r.state < 5, r.state = 6, r.timer.stop(), r.on.call(i ? "interrupt" : "cancel", e, e.__data__, r.index, r.group), delete a[n];
		}
		s && delete e.__transition;
	}
}
function Rb(e) {
	return this.each(function() {
		Rx(this, e);
	});
}
function Rw(e, t) {
	var r, i;
	return function() {
		var n = Rm(this, e), a = n.tween;
		if (a !== r) {
			i = r = a;
			for (var s = 0, o = i.length; s < o; ++s) if (i[s].name === t) {
				(i = i.slice()).splice(s, 1);
				break;
			}
		}
		n.tween = i;
	};
}
function Rk(e, t, r) {
	var i, n;
	if ("function" != typeof r) throw Error();
	return function() {
		var a = Rm(this, e), s = a.tween;
		if (s !== i) {
			n = (i = s).slice();
			for (var o = {
				name: t,
				value: r
			}, l = 0, h = n.length; l < h; ++l) if (n[l].name === t) {
				n[l] = o;
				break;
			}
			l === h && n.push(o);
		}
		a.tween = n;
	};
}
function RT(e, t) {
	var r = this._id;
	if (e += "", arguments.length < 2) {
		for (var i, n = Ry(this.node(), r).tween, a = 0, s = n.length; a < s; ++a) if ((i = n[a]).name === e) return i.value;
		return null;
	}
	return this.each((null == t ? Rw : Rk)(r, e, t));
}
function R_(e, t, r) {
	var i = e._id;
	return e.each(function() {
		var e = Rm(this, i);
		(e.value || (e.value = {}))[t] = r.apply(this, arguments);
	}), function(e) {
		return Ry(e, i).value[t];
	};
}
function RE(e, t) {
	var r;
	return ("number" == typeof t ? Ec : t instanceof _b ? Ei : (r = _b(t)) ? (t = r, Ei) : Eg)(e, t);
}
function RC(e) {
	return function() {
		this.removeAttribute(e);
	};
}
function RS(e) {
	return function() {
		this.removeAttributeNS(e.space, e.local);
	};
}
function RA(e, t, r) {
	var i, n, a = r + "";
	return function() {
		var s = this.getAttribute(e);
		return s === a ? null : s === i ? n : n = t(i = s, r);
	};
}
function RL(e, t, r) {
	var i, n, a = r + "";
	return function() {
		var s = this.getAttributeNS(e.space, e.local);
		return s === a ? null : s === i ? n : n = t(i = s, r);
	};
}
function RR(e, t, r) {
	var i, n, a;
	return function() {
		var s, o, l = r(this);
		return null == l ? void this.removeAttribute(e) : (s = this.getAttribute(e)) === (o = l + "") ? null : s === i && o === n ? a : (n = o, a = t(i = s, l));
	};
}
function RN(e, t, r) {
	var i, n, a;
	return function() {
		var s, o, l = r(this);
		return null == l ? void this.removeAttributeNS(e.space, e.local) : (s = this.getAttributeNS(e.space, e.local)) === (o = l + "") ? null : s === i && o === n ? a : (n = o, a = t(i = s, l));
	};
}
function RI(e, t) {
	var r = Te(e), i = "transform" === r ? EE : RE;
	return this.attrTween(e, "function" == typeof t ? (r.local ? RN : RR)(r, i, R_(this, "attr." + e, t)) : null == t ? (r.local ? RS : RC)(r) : (r.local ? RL : RA)(r, i, t));
}
function RM(e, t) {
	return function(r) {
		this.setAttribute(e, t.call(this, r));
	};
}
function RD(e, t) {
	return function(r) {
		this.setAttributeNS(e.space, e.local, t.call(this, r));
	};
}
function RO(e, t) {
	var r, i;
	function n() {
		var n = t.apply(this, arguments);
		return n !== i && (r = (i = n) && RD(e, n)), r;
	}
	return h(n, "tween"), n._value = t, n;
}
function R$(e, t) {
	var r, i;
	function n() {
		var n = t.apply(this, arguments);
		return n !== i && (r = (i = n) && RM(e, n)), r;
	}
	return h(n, "tween"), n._value = t, n;
}
function RP(e, t) {
	var r = "attr." + e;
	if (arguments.length < 2) return (r = this.tween(r)) && r._value;
	if (null == t) return this.tween(r, null);
	if ("function" != typeof t) throw Error();
	var i = Te(e);
	return this.tween(r, (i.local ? RO : R$)(i, t));
}
function RB(e, t) {
	return function() {
		Rg(this, e).delay = +t.apply(this, arguments);
	};
}
function RF(e, t) {
	return t *= 1, function() {
		Rg(this, e).delay = t;
	};
}
function Rz(e) {
	var t = this._id;
	return arguments.length ? this.each(("function" == typeof e ? RB : RF)(t, e)) : Ry(this.node(), t).delay;
}
function RU(e, t) {
	return function() {
		Rm(this, e).duration = +t.apply(this, arguments);
	};
}
function RG(e, t) {
	return t *= 1, function() {
		Rm(this, e).duration = t;
	};
}
function Rq(e) {
	var t = this._id;
	return arguments.length ? this.each(("function" == typeof e ? RU : RG)(t, e)) : Ry(this.node(), t).duration;
}
function Rj(e, t) {
	if ("function" != typeof t) throw Error();
	return function() {
		Rm(this, e).ease = t;
	};
}
function RW(e) {
	var t = this._id;
	return arguments.length ? this.each(Rj(t, e)) : Ry(this.node(), t).ease;
}
function RY(e, t) {
	return function() {
		var r = t.apply(this, arguments);
		if ("function" != typeof r) throw Error();
		Rm(this, e).ease = r;
	};
}
function RV(e) {
	if ("function" != typeof e) throw Error();
	return this.each(RY(this._id, e));
}
function RH(e) {
	"function" != typeof e && (e = kR(e));
	for (var t = this._groups, r = t.length, i = Array(r), n = 0; n < r; ++n) for (var a, s = t[n], o = s.length, l = i[n] = [], h = 0; h < o; ++h) (a = s[h]) && e.call(a, a.__data__, h, s) && l.push(a);
	return new Np(i, this._parents, this._name, this._id);
}
function RX(e) {
	if (e._id !== this._id) throw Error();
	for (var t = this._groups, r = e._groups, i = t.length, n = r.length, a = Math.min(i, n), s = Array(i), o = 0; o < a; ++o) for (var l, h = t[o], u = r[o], d = h.length, p = s[o] = Array(d), f = 0; f < d; ++f) (l = h[f] || u[f]) && (p[f] = l);
	for (; o < i; ++o) s[o] = t[o];
	return new Np(s, this._parents, this._name, this._id);
}
function RK(e) {
	return (e + "").trim().split(/^|\s+/).every(function(e) {
		var t = e.indexOf(".");
		return t >= 0 && (e = e.slice(0, t)), !e || "start" === e;
	});
}
function RZ(e, t, r) {
	var i, n, a = RK(t) ? Rg : Rm;
	return function() {
		var s = a(this, e), o = s.on;
		o !== i && (n = (i = o).copy()).on(t, r), s.on = n;
	};
}
function RQ(e, t) {
	var r = this._id;
	return arguments.length < 2 ? Ry(this.node(), r).on.on(e) : this.each(RZ(r, e, t));
}
function RJ(e) {
	return function() {
		var t = this.parentNode;
		for (var r in this.__transition) if (+r !== e) return;
		t && t.removeChild(this);
	};
}
function R0() {
	return this.on("end.remove", RJ(this._id));
}
function R1(e) {
	var t = this._name, r = this._id;
	"function" != typeof e && (e = kT(e));
	for (var i = this._groups, n = i.length, a = Array(n), s = 0; s < n; ++s) for (var o, l, h = i[s], u = h.length, d = a[s] = Array(u), p = 0; p < u; ++p) (o = h[p]) && (l = e.call(o, o.__data__, p, h)) && ("__data__" in o && (l.__data__ = o.__data__), d[p] = l, Rf(d[p], t, r, p, d, Ry(o, r)));
	return new Np(a, this._parents, t, r);
}
function R2(e) {
	var t = this._name, r = this._id;
	"function" != typeof e && (e = kS(e));
	for (var i = this._groups, n = i.length, a = [], s = [], o = 0; o < n; ++o) for (var l, h = i[o], u = h.length, d = 0; d < u; ++d) if (l = h[d]) {
		for (var p, f = e.call(l, l.__data__, d, h), g = Ry(l, r), m = 0, y = f.length; m < y; ++m) (p = f[m]) && Rf(p, t, r, m, f, g);
		a.push(f), s.push(l);
	}
	return new Np(a, s, t, r);
}
h(Rf, "default"), h(Rg, "init"), h(Rm, "set"), h(Ry, "get"), h(Rv, "create"), h(Rx, "default"), h(Rb, "default"), h(Rw, "tweenRemove"), h(Rk, "tweenFunction"), h(RT, "default"), h(R_, "tweenValue"), h(RE, "default"), h(RC, "attrRemove"), h(RS, "attrRemoveNS"), h(RA, "attrConstant"), h(RL, "attrConstantNS"), h(RR, "attrFunction"), h(RN, "attrFunctionNS"), h(RI, "default"), h(RM, "attrInterpolate"), h(RD, "attrInterpolateNS"), h(RO, "attrTweenNS"), h(R$, "attrTween"), h(RP, "default"), h(RB, "delayFunction"), h(RF, "delayConstant"), h(Rz, "default"), h(RU, "durationFunction"), h(RG, "durationConstant"), h(Rq, "default"), h(Rj, "easeConstant"), h(RW, "default"), h(RY, "easeVarying"), h(RV, "default"), h(RH, "default"), h(RX, "default"), h(RK, "start"), h(RZ, "onFunction"), h(RQ, "default"), h(RJ, "removeFunction"), h(R0, "default"), h(R1, "default"), h(R2, "default");
var R4 = T9.prototype.constructor;
function R5() {
	return new R4(this._groups, this._parents);
}
function R3(e, t) {
	var r, i, n;
	return function() {
		var a = Tp(this, e), s = (this.style.removeProperty(e), Tp(this, e));
		return a === s ? null : a === r && s === i ? n : n = t(r = a, i = s);
	};
}
function R6(e) {
	return function() {
		this.style.removeProperty(e);
	};
}
function R7(e, t, r) {
	var i, n, a = r + "";
	return function() {
		var s = Tp(this, e);
		return s === a ? null : s === i ? n : n = t(i = s, r);
	};
}
function R8(e, t, r) {
	var i, n, a;
	return function() {
		var s = Tp(this, e), o = r(this), l = o + "";
		return o ?? (this.style.removeProperty(e), l = o = Tp(this, e)), s === l ? null : s === i && l === n ? a : (n = l, a = t(i = s, o));
	};
}
function R9(e, t) {
	var r, i, n, a, s = "style." + t, o = "end." + s;
	return function() {
		var l = Rm(this, e), h = l.on, u = null == l.value[s] ? a || (a = R6(t)) : void 0;
		(h !== r || n !== u) && (i = (r = h).copy()).on(o, n = u), l.on = i;
	};
}
function Ne(e, t, r) {
	var i = "transform" == (e += "") ? E_ : RE;
	return null == t ? this.styleTween(e, R3(e, i)).on("end.style." + e, R6(e)) : "function" == typeof t ? this.styleTween(e, R8(e, i, R_(this, "style." + e, t))).each(R9(this._id, e)) : this.styleTween(e, R7(e, i, t), r).on("end.style." + e, null);
}
function Nt(e, t, r) {
	return function(i) {
		this.style.setProperty(e, t.call(this, i), r);
	};
}
function Nr(e, t, r) {
	var i, n;
	function a() {
		var a = t.apply(this, arguments);
		return a !== n && (i = (n = a) && Nt(e, a, r)), i;
	}
	return h(a, "tween"), a._value = t, a;
}
function Ni(e, t, r) {
	var i = "style." + (e += "");
	if (arguments.length < 2) return (i = this.tween(i)) && i._value;
	if (null == t) return this.tween(i, null);
	if ("function" != typeof t) throw Error();
	return this.tween(i, Nr(e, t, r ?? ""));
}
function Nn(e) {
	return function() {
		this.textContent = e;
	};
}
function Na(e) {
	return function() {
		this.textContent = e(this) ?? "";
	};
}
function Ns(e) {
	return this.tween("text", "function" == typeof e ? Na(R_(this, "text", e)) : Nn(null == e ? "" : e + ""));
}
function No(e) {
	return function(t) {
		this.textContent = e.call(this, t);
	};
}
function Nl(e) {
	var t, r;
	function i() {
		var i = e.apply(this, arguments);
		return i !== r && (t = (r = i) && No(i)), t;
	}
	return h(i, "tween"), i._value = e, i;
}
function Nc(e) {
	var t = "text";
	if (arguments.length < 1) return (t = this.tween(t)) && t._value;
	if (null == e) return this.tween(t, null);
	if ("function" != typeof e) throw Error();
	return this.tween(t, Nl(e));
}
function Nh() {
	for (var e = this._name, t = this._id, r = Ng(), i = this._groups, n = i.length, a = 0; a < n; ++a) for (var s, o = i[a], l = o.length, h = 0; h < l; ++h) if (s = o[h]) {
		var u = Ry(s, t);
		Rf(s, e, r, h, o, {
			time: u.time + u.delay + u.duration,
			delay: 0,
			duration: u.duration,
			ease: u.ease
		});
	}
	return new Np(i, this._parents, e, r);
}
function Nu() {
	var e, t, r = this, i = r._id, n = r.size();
	return new Promise(function(a, s) {
		var o = { value: s }, l = { value: h(function() {
			0 == --n && a();
		}, "value") };
		r.each(function() {
			var r = Rm(this, i), n = r.on;
			n !== e && ((t = (e = n).copy())._.cancel.push(o), t._.interrupt.push(o), t._.end.push(l)), r.on = t;
		}), 0 === n && a();
	});
}
h(R5, "default"), h(R3, "styleNull"), h(R6, "styleRemove"), h(R7, "styleConstant"), h(R8, "styleFunction"), h(R9, "styleMaybeRemove"), h(Ne, "default"), h(Nt, "styleInterpolate"), h(Nr, "styleTween"), h(Ni, "default"), h(Nn, "textConstant"), h(Na, "textFunction"), h(Ns, "default"), h(No, "textInterpolate"), h(Nl, "textTween"), h(Nc, "default"), h(Nh, "default"), h(Nu, "default");
var Nd = 0;
function Np(e, t, r, i) {
	this._groups = e, this._parents = t, this._name = r, this._id = i;
}
function Nf(e) {
	return T9().transition(e);
}
function Ng() {
	return ++Nd;
}
h(Np, "Transition"), h(Nf, "transition"), h(Ng, "newId");
var Nm = T9.prototype;
function Ny(e) {
	return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
}
Np.prototype = Nf.prototype = {
	constructor: Np,
	select: R1,
	selectAll: R2,
	selectChild: Nm.selectChild,
	selectChildren: Nm.selectChildren,
	filter: RH,
	merge: RX,
	selection: R5,
	transition: Nh,
	call: Nm.call,
	nodes: Nm.nodes,
	node: Nm.node,
	size: Nm.size,
	empty: Nm.empty,
	each: Nm.each,
	on: RQ,
	attr: RI,
	attrTween: RP,
	style: Ne,
	styleTween: Ni,
	text: Ns,
	textTween: Nc,
	remove: R0,
	tween: RT,
	delay: Rz,
	duration: Rq,
	ease: RW,
	easeVarying: RV,
	end: Nu,
	[Symbol.iterator]: Nm[Symbol.iterator]
}, h(Ny, "cubicInOut");
var Nv = {
	time: null,
	delay: 0,
	duration: 250,
	ease: Ny
};
function Nx(e, t) {
	for (var r; !(r = e.__transition) || !(r = r[t]);) if (!(e = e.parentNode)) throw Error(`transition ${t} not found`);
	return r;
}
function Nb(e) {
	e instanceof Np ? (n = e._id, e = e._name) : (n = Ng(), (a = Nv).time = Rr(), e = null == e ? null : e + "");
	for (var t = this._groups, r = t.length, i = 0; i < r; ++i) for (var n, a, s, o = t[i], l = o.length, h = 0; h < l; ++h) (s = o[h]) && Rf(s, e, n, h, o, a || Nx(s, n));
	return new Np(t, this._parents, e, n);
}
h(Nx, "inherit"), h(Nb, "default"), T9.prototype.interrupt = Rb, T9.prototype.transition = Nb;
var { abs: Nw, max: Nk, min: NT } = Math;
function N_(e) {
	return [+e[0], +e[1]];
}
function NE(e) {
	return [N_(e[0]), N_(e[1])];
}
function NC(e) {
	return { type: e };
}
function NS(e, t, r) {
	this.k = e, this.x = t, this.y = r;
}
h(N_, "number1"), h(NE, "number2"), ["w", "e"].map(NC), h(function(e, t) {
	return null == e ? null : [[+e[0], t[0][1]], [+e[1], t[1][1]]];
}, "input"), h(function(e) {
	return e && [e[0][0], e[1][0]];
}, "output"), ["n", "s"].map(NC), h(function(e, t) {
	return null == e ? null : [[t[0][0], +e[0]], [t[1][0], +e[1]]];
}, "input"), h(function(e) {
	return e && [e[0][1], e[1][1]];
}, "output"), [
	"n",
	"w",
	"e",
	"s",
	"nw",
	"ne",
	"sw",
	"se"
].map(NC), h(function(e) {
	return null == e ? null : NE(e);
}, "input"), h(function(e) {
	return e;
}, "output"), h(NC, "type"), h(NS, "Transform"), NS.prototype = {
	constructor: NS,
	scale: h(function(e) {
		return 1 === e ? this : new NS(this.k * e, this.x, this.y);
	}, "scale"),
	translate: h(function(e, t) {
		return 0 === e & 0 === t ? this : new NS(this.k, this.x + this.k * e, this.y + this.k * t);
	}, "translate"),
	apply: h(function(e) {
		return [e[0] * this.k + this.x, e[1] * this.k + this.y];
	}, "apply"),
	applyX: h(function(e) {
		return e * this.k + this.x;
	}, "applyX"),
	applyY: h(function(e) {
		return e * this.k + this.y;
	}, "applyY"),
	invert: h(function(e) {
		return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k];
	}, "invert"),
	invertX: h(function(e) {
		return (e - this.x) / this.k;
	}, "invertX"),
	invertY: h(function(e) {
		return (e - this.y) / this.k;
	}, "invertY"),
	rescaleX: h(function(e) {
		return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e));
	}, "rescaleX"),
	rescaleY: h(function(e) {
		return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e));
	}, "rescaleY"),
	toString: h(function() {
		return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
	}, "toString")
};
var NA = new NS(1, 0, 0);
function NL(e) {
	for (; !e.__zoom;) if (!(e = e.parentNode)) return NA;
	return e.__zoom;
}
NL.prototype = NS.prototype, h(NL, "transform");
var NR = /^-{3}\s*[\n\r](.*?)[\n\r]-{3}\s*[\n\r]+/s, NN = /%{2}{\s*(?:(\w+)\s*:|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi, NI = /\s*%%.*\n/gm, NM = class extends Error {
	static {
		h(this, "UnknownDiagramError");
	}
	constructor(e) {
		super(e), this.name = "UnknownDiagramError";
	}
}, ND = {}, NO = h(function(e, t) {
	for (let [r, { detector: i }] of (e = e.replace(NR, "").replace(NN, "").replace(NI, `
`), Object.entries(ND))) if (i(e, t)) return r;
	throw new NM(`No diagram type detected matching given configuration for text: ${e}`);
}, "detectType"), N$ = h((...e) => {
	for (let { id: t, detector: r, loader: i } of e) NP(t, r, i);
}, "registerLazyLoadedDiagrams"), NP = h((e, t, r) => {
	ND[e] && wQ.warn(`Detector with key ${e} already exists. Overwriting.`), ND[e] = {
		detector: t,
		loader: r
	}, wQ.debug(`Detector with key ${e} added${r ? " with loader" : ""}`);
}, "addDetector"), NB = h((e) => ND[e].loader, "getDiagramLoader"), NF = h((e, t, { depth: r = 2, clobber: i = !1 } = {}) => {
	let n = {
		depth: r,
		clobber: i
	};
	return Array.isArray(t) && !Array.isArray(e) ? (t.forEach((t) => NF(e, t, n)), e) : Array.isArray(t) && Array.isArray(e) ? (t.forEach((t) => {
		e.includes(t) || e.push(t);
	}), e) : void 0 === e || r <= 0 ? null != e && "object" == typeof e && "object" == typeof t ? Object.assign(e, t) : t : (void 0 !== t && "object" == typeof e && "object" == typeof t && Object.keys(t).forEach((n) => {
		"object" == typeof t[n] && (void 0 === e[n] || "object" == typeof e[n]) ? (void 0 === e[n] && (e[n] = Array.isArray(t[n]) ? [] : {}), e[n] = NF(e[n], t[n], {
			depth: r - 1,
			clobber: i
		})) : (i || "object" != typeof e[n] && "object" != typeof t[n]) && (e[n] = t[n]);
	}), e);
}, "assignWithDepth"), Nz = {
	min: {
		r: 0,
		g: 0,
		b: 0,
		s: 0,
		l: 0,
		a: 0
	},
	max: {
		r: 255,
		g: 255,
		b: 255,
		h: 360,
		s: 100,
		l: 100,
		a: 1
	},
	clamp: {
		r: h((e) => e >= 255 ? 255 : e < 0 ? 0 : e, "r"),
		g: h((e) => e >= 255 ? 255 : e < 0 ? 0 : e, "g"),
		b: h((e) => e >= 255 ? 255 : e < 0 ? 0 : e, "b"),
		h: h((e) => e % 360, "h"),
		s: h((e) => e >= 100 ? 100 : e < 0 ? 0 : e, "s"),
		l: h((e) => e >= 100 ? 100 : e < 0 ? 0 : e, "l"),
		a: h((e) => e >= 1 ? 1 : e < 0 ? 0 : e, "a")
	},
	toLinear: h((e) => {
		let t = e / 255;
		return e > .03928 ? Math.pow((t + .055) / 1.055, 2.4) : t / 12.92;
	}, "toLinear"),
	hue2rgb: h((e, t, r) => (r < 0 && (r += 1), r > 1 && (r -= 1), r < .16666666666666666 ? e + (t - e) * 6 * r : r < .5 ? t : r < .6666666666666666 ? e + (t - e) * (.6666666666666666 - r) * 6 : e), "hue2rgb"),
	hsl2rgb: h(({ h: e, s: t, l: r }, i) => {
		if (!t) return 2.55 * r;
		e /= 360, t /= 100;
		let n = (r /= 100) < .5 ? r * (1 + t) : r + t - r * t, a = 2 * r - n;
		switch (i) {
			case "r": return 255 * Nz.hue2rgb(a, n, e + .3333333333333333);
			case "g": return 255 * Nz.hue2rgb(a, n, e);
			case "b": return 255 * Nz.hue2rgb(a, n, e - .3333333333333333);
		}
	}, "hsl2rgb"),
	rgb2hsl: h(({ r: e, g: t, b: r }, i) => {
		e /= 255;
		let n = Math.max(e, t /= 255, r /= 255), a = Math.min(e, t, r), s = (n + a) / 2;
		if ("l" === i) return 100 * s;
		if (n === a) return 0;
		let o = n - a;
		if ("s" === i) return 100 * (s > .5 ? o / (2 - n - a) : o / (n + a));
		switch (n) {
			case e: return ((t - r) / o + 6 * (t < r)) * 60;
			case t: return ((r - e) / o + 2) * 60;
			case r: return ((e - t) / o + 4) * 60;
			default: return -1;
		}
	}, "rgb2hsl")
}, NU = {
	channel: Nz,
	lang: {
		clamp: h((e, t, r) => t > r ? Math.min(t, Math.max(r, e)) : Math.min(r, Math.max(t, e)), "clamp"),
		round: h((e) => Math.round(1e10 * e) / 1e10, "round")
	},
	unit: { dec2hex: h((e) => {
		let t = Math.round(e).toString(16);
		return t.length > 1 ? t : `0${t}`;
	}, "dec2hex") }
}, NG = {};
for (let e = 0; e <= 255; e++) NG[e] = NU.unit.dec2hex(e);
var Nq, Nj = class {
	static {
		h(this, "Type");
	}
	constructor() {
		this.type = 0;
	}
	get() {
		return this.type;
	}
	set(e) {
		if (this.type && this.type !== e) throw Error("Cannot change both RGB and HSL channels at the same time");
		this.type = e;
	}
	reset() {
		this.type = 0;
	}
	is(e) {
		return this.type === e;
	}
}, NW = new class {
	static {
		h(this, "Channels");
	}
	constructor(e, t) {
		this.color = t, this.changed = !1, this.data = e, this.type = new Nj();
	}
	set(e, t) {
		return this.color = t, this.changed = !1, this.data = e, this.type.type = 0, this;
	}
	_ensureHSL() {
		let e = this.data, { h: t, s: r, l: i } = e;
		void 0 === t && (e.h = NU.channel.rgb2hsl(e, "h")), void 0 === r && (e.s = NU.channel.rgb2hsl(e, "s")), void 0 === i && (e.l = NU.channel.rgb2hsl(e, "l"));
	}
	_ensureRGB() {
		let e = this.data, { r: t, g: r, b: i } = e;
		void 0 === t && (e.r = NU.channel.hsl2rgb(e, "r")), void 0 === r && (e.g = NU.channel.hsl2rgb(e, "g")), void 0 === i && (e.b = NU.channel.hsl2rgb(e, "b"));
	}
	get r() {
		let e = this.data, t = e.r;
		return this.type.is(2) || void 0 === t ? (this._ensureHSL(), NU.channel.hsl2rgb(e, "r")) : t;
	}
	get g() {
		let e = this.data, t = e.g;
		return this.type.is(2) || void 0 === t ? (this._ensureHSL(), NU.channel.hsl2rgb(e, "g")) : t;
	}
	get b() {
		let e = this.data, t = e.b;
		return this.type.is(2) || void 0 === t ? (this._ensureHSL(), NU.channel.hsl2rgb(e, "b")) : t;
	}
	get h() {
		let e = this.data, t = e.h;
		return this.type.is(1) || void 0 === t ? (this._ensureRGB(), NU.channel.rgb2hsl(e, "h")) : t;
	}
	get s() {
		let e = this.data, t = e.s;
		return this.type.is(1) || void 0 === t ? (this._ensureRGB(), NU.channel.rgb2hsl(e, "s")) : t;
	}
	get l() {
		let e = this.data, t = e.l;
		return this.type.is(1) || void 0 === t ? (this._ensureRGB(), NU.channel.rgb2hsl(e, "l")) : t;
	}
	get a() {
		return this.data.a;
	}
	set r(e) {
		this.type.set(1), this.changed = !0, this.data.r = e;
	}
	set g(e) {
		this.type.set(1), this.changed = !0, this.data.g = e;
	}
	set b(e) {
		this.type.set(1), this.changed = !0, this.data.b = e;
	}
	set h(e) {
		this.type.set(2), this.changed = !0, this.data.h = e;
	}
	set s(e) {
		this.type.set(2), this.changed = !0, this.data.s = e;
	}
	set l(e) {
		this.type.set(2), this.changed = !0, this.data.l = e;
	}
	set a(e) {
		this.changed = !0, this.data.a = e;
	}
}({
	r: 0,
	g: 0,
	b: 0,
	a: 0
}, "transparent"), NY = {
	re: /^#((?:[a-f0-9]{2}){2,4}|[a-f0-9]{3})$/i,
	parse: h((e) => {
		if (35 !== e.charCodeAt(0)) return;
		let t = e.match(NY.re);
		if (!t) return;
		let r = t[1], i = parseInt(r, 16), n = r.length, a = n % 4 == 0, s = n > 4, o = s ? 1 : 17, l = s ? 8 : 4, h = a ? 0 : -1, u = s ? 255 : 15;
		return NW.set({
			r: (i >> l * (h + 3) & u) * o,
			g: (i >> l * (h + 2) & u) * o,
			b: (i >> l * (h + 1) & u) * o,
			a: a ? (i & u) * o / 255 : 1
		}, e);
	}, "parse"),
	stringify: h((e) => {
		let { r: t, g: r, b: i, a: n } = e;
		return n < 1 ? `#${NG[Math.round(t)]}${NG[Math.round(r)]}${NG[Math.round(i)]}${NG[Math.round(255 * n)]}` : `#${NG[Math.round(t)]}${NG[Math.round(r)]}${NG[Math.round(i)]}`;
	}, "stringify")
}, NV = {
	re: /^hsla?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(?:deg|grad|rad|turn)?)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(%)?))?\s*?\)$/i,
	hueRe: /^(.+?)(deg|grad|rad|turn)$/i,
	_hue2deg: h((e) => {
		let t = e.match(NV.hueRe);
		if (t) {
			let [, e, r] = t;
			switch (r) {
				case "grad": return NU.channel.clamp.h(.9 * parseFloat(e));
				case "rad": return NU.channel.clamp.h(180 * parseFloat(e) / Math.PI);
				case "turn": return NU.channel.clamp.h(360 * parseFloat(e));
			}
		}
		return NU.channel.clamp.h(parseFloat(e));
	}, "_hue2deg"),
	parse: h((e) => {
		let t = e.charCodeAt(0);
		if (104 !== t && 72 !== t) return;
		let r = e.match(NV.re);
		if (!r) return;
		let [, i, n, a, s, o] = r;
		return NW.set({
			h: NV._hue2deg(i),
			s: NU.channel.clamp.s(parseFloat(n)),
			l: NU.channel.clamp.l(parseFloat(a)),
			a: s ? NU.channel.clamp.a(o ? parseFloat(s) / 100 : parseFloat(s)) : 1
		}, e);
	}, "parse"),
	stringify: h((e) => {
		let { h: t, s: r, l: i, a: n } = e;
		return n < 1 ? `hsla(${NU.lang.round(t)}, ${NU.lang.round(r)}%, ${NU.lang.round(i)}%, ${n})` : `hsl(${NU.lang.round(t)}, ${NU.lang.round(r)}%, ${NU.lang.round(i)}%)`;
	}, "stringify")
}, NH = {
	colors: {
		aliceblue: "#f0f8ff",
		antiquewhite: "#faebd7",
		aqua: "#00ffff",
		aquamarine: "#7fffd4",
		azure: "#f0ffff",
		beige: "#f5f5dc",
		bisque: "#ffe4c4",
		black: "#000000",
		blanchedalmond: "#ffebcd",
		blue: "#0000ff",
		blueviolet: "#8a2be2",
		brown: "#a52a2a",
		burlywood: "#deb887",
		cadetblue: "#5f9ea0",
		chartreuse: "#7fff00",
		chocolate: "#d2691e",
		coral: "#ff7f50",
		cornflowerblue: "#6495ed",
		cornsilk: "#fff8dc",
		crimson: "#dc143c",
		cyanaqua: "#00ffff",
		darkblue: "#00008b",
		darkcyan: "#008b8b",
		darkgoldenrod: "#b8860b",
		darkgray: "#a9a9a9",
		darkgreen: "#006400",
		darkgrey: "#a9a9a9",
		darkkhaki: "#bdb76b",
		darkmagenta: "#8b008b",
		darkolivegreen: "#556b2f",
		darkorange: "#ff8c00",
		darkorchid: "#9932cc",
		darkred: "#8b0000",
		darksalmon: "#e9967a",
		darkseagreen: "#8fbc8f",
		darkslateblue: "#483d8b",
		darkslategray: "#2f4f4f",
		darkslategrey: "#2f4f4f",
		darkturquoise: "#00ced1",
		darkviolet: "#9400d3",
		deeppink: "#ff1493",
		deepskyblue: "#00bfff",
		dimgray: "#696969",
		dimgrey: "#696969",
		dodgerblue: "#1e90ff",
		firebrick: "#b22222",
		floralwhite: "#fffaf0",
		forestgreen: "#228b22",
		fuchsia: "#ff00ff",
		gainsboro: "#dcdcdc",
		ghostwhite: "#f8f8ff",
		gold: "#ffd700",
		goldenrod: "#daa520",
		gray: "#808080",
		green: "#008000",
		greenyellow: "#adff2f",
		grey: "#808080",
		honeydew: "#f0fff0",
		hotpink: "#ff69b4",
		indianred: "#cd5c5c",
		indigo: "#4b0082",
		ivory: "#fffff0",
		khaki: "#f0e68c",
		lavender: "#e6e6fa",
		lavenderblush: "#fff0f5",
		lawngreen: "#7cfc00",
		lemonchiffon: "#fffacd",
		lightblue: "#add8e6",
		lightcoral: "#f08080",
		lightcyan: "#e0ffff",
		lightgoldenrodyellow: "#fafad2",
		lightgray: "#d3d3d3",
		lightgreen: "#90ee90",
		lightgrey: "#d3d3d3",
		lightpink: "#ffb6c1",
		lightsalmon: "#ffa07a",
		lightseagreen: "#20b2aa",
		lightskyblue: "#87cefa",
		lightslategray: "#778899",
		lightslategrey: "#778899",
		lightsteelblue: "#b0c4de",
		lightyellow: "#ffffe0",
		lime: "#00ff00",
		limegreen: "#32cd32",
		linen: "#faf0e6",
		magenta: "#ff00ff",
		maroon: "#800000",
		mediumaquamarine: "#66cdaa",
		mediumblue: "#0000cd",
		mediumorchid: "#ba55d3",
		mediumpurple: "#9370db",
		mediumseagreen: "#3cb371",
		mediumslateblue: "#7b68ee",
		mediumspringgreen: "#00fa9a",
		mediumturquoise: "#48d1cc",
		mediumvioletred: "#c71585",
		midnightblue: "#191970",
		mintcream: "#f5fffa",
		mistyrose: "#ffe4e1",
		moccasin: "#ffe4b5",
		navajowhite: "#ffdead",
		navy: "#000080",
		oldlace: "#fdf5e6",
		olive: "#808000",
		olivedrab: "#6b8e23",
		orange: "#ffa500",
		orangered: "#ff4500",
		orchid: "#da70d6",
		palegoldenrod: "#eee8aa",
		palegreen: "#98fb98",
		paleturquoise: "#afeeee",
		palevioletred: "#db7093",
		papayawhip: "#ffefd5",
		peachpuff: "#ffdab9",
		peru: "#cd853f",
		pink: "#ffc0cb",
		plum: "#dda0dd",
		powderblue: "#b0e0e6",
		purple: "#800080",
		rebeccapurple: "#663399",
		red: "#ff0000",
		rosybrown: "#bc8f8f",
		royalblue: "#4169e1",
		saddlebrown: "#8b4513",
		salmon: "#fa8072",
		sandybrown: "#f4a460",
		seagreen: "#2e8b57",
		seashell: "#fff5ee",
		sienna: "#a0522d",
		silver: "#c0c0c0",
		skyblue: "#87ceeb",
		slateblue: "#6a5acd",
		slategray: "#708090",
		slategrey: "#708090",
		snow: "#fffafa",
		springgreen: "#00ff7f",
		tan: "#d2b48c",
		teal: "#008080",
		thistle: "#d8bfd8",
		transparent: "#00000000",
		turquoise: "#40e0d0",
		violet: "#ee82ee",
		wheat: "#f5deb3",
		white: "#ffffff",
		whitesmoke: "#f5f5f5",
		yellow: "#ffff00",
		yellowgreen: "#9acd32"
	},
	parse: h((e) => {
		e = e.toLowerCase();
		let t = NH.colors[e];
		if (t) return NY.parse(t);
	}, "parse"),
	stringify: h((e) => {
		let t = NY.stringify(e);
		for (let e in NH.colors) if (NH.colors[e] === t) return e;
	}, "stringify")
}, NX = {
	re: /^rgba?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?)))?\s*?\)$/i,
	parse: h((e) => {
		let t = e.charCodeAt(0);
		if (114 !== t && 82 !== t) return;
		let r = e.match(NX.re);
		if (!r) return;
		let [, i, n, a, s, o, l, h, u] = r;
		return NW.set({
			r: NU.channel.clamp.r(n ? 2.55 * parseFloat(i) : parseFloat(i)),
			g: NU.channel.clamp.g(s ? 2.55 * parseFloat(a) : parseFloat(a)),
			b: NU.channel.clamp.b(l ? 2.55 * parseFloat(o) : parseFloat(o)),
			a: h ? NU.channel.clamp.a(u ? parseFloat(h) / 100 : parseFloat(h)) : 1
		}, e);
	}, "parse"),
	stringify: h((e) => {
		let { r: t, g: r, b: i, a: n } = e;
		return n < 1 ? `rgba(${NU.lang.round(t)}, ${NU.lang.round(r)}, ${NU.lang.round(i)}, ${NU.lang.round(n)})` : `rgb(${NU.lang.round(t)}, ${NU.lang.round(r)}, ${NU.lang.round(i)})`;
	}, "stringify")
}, NK = {
	format: {
		keyword: NH,
		hex: NY,
		rgb: NX,
		rgba: NX,
		hsl: NV,
		hsla: NV
	},
	parse: h((e) => {
		if ("string" != typeof e) return e;
		let t = NY.parse(e) || NX.parse(e) || NV.parse(e) || NH.parse(e);
		if (t) return t;
		throw Error(`Unsupported color format: "${e}"`);
	}, "parse"),
	stringify: h((e) => !e.changed && e.color ? e.color : e.type.is(2) || void 0 === e.data.r ? NV.stringify(e) : !(e.a < 1) && Number.isInteger(e.r) && Number.isInteger(e.g) && Number.isInteger(e.b) ? NY.stringify(e) : NX.stringify(e), "stringify")
}, NZ = h((e, t) => {
	let r = NK.parse(e);
	for (let e in t) r[e] = NU.channel.clamp[e](t[e]);
	return NK.stringify(r);
}, "change"), NQ = h((e, t, r = 0, i = 1) => {
	if ("number" != typeof e) return NZ(e, { a: t });
	let n = NW.set({
		r: NU.channel.clamp.r(e),
		g: NU.channel.clamp.g(t),
		b: NU.channel.clamp.b(r),
		a: NU.channel.clamp.a(i)
	});
	return NK.stringify(n);
}, "rgba"), NJ = h((e, t) => NU.lang.round(NK.parse(e)[t]), "channel"), N0 = h((e) => {
	let { r: t, g: r, b: i } = NK.parse(e), n = .2126 * NU.channel.toLinear(t) + .7152 * NU.channel.toLinear(r) + .0722 * NU.channel.toLinear(i);
	return NU.lang.round(n);
}, "luminance"), N1 = h((e) => N0(e) >= .5, "isLight"), N2 = h((e) => !N1(e), "isDark"), N4 = h((e, t, r) => {
	let i = NK.parse(e), n = i[t], a = NU.channel.clamp[t](n + r);
	return n !== a && (i[t] = a), NK.stringify(i);
}, "adjustChannel"), N5 = h((e, t) => N4(e, "l", t), "lighten"), N3 = h((e, t) => N4(e, "l", -t), "darken"), N6 = h((e, t) => {
	let r = NK.parse(e), i = {};
	for (let e in t) t[e] && (i[e] = r[e] + t[e]);
	return NZ(e, i);
}, "adjust"), N7 = h((e, t, r = 50) => {
	let { r: i, g: n, b: a, a: s } = NK.parse(e), { r: o, g: l, b: h, a: u } = NK.parse(t), d = r / 100, p = 2 * d - 1, f = s - u, g = ((p * f == -1 ? p : (p + f) / (1 + p * f)) + 1) / 2, m = 1 - g;
	return NQ(i * g + o * m, n * g + l * m, a * g + h * m, s * d + u * (1 - d));
}, "mix"), N8 = h((e, t = 100) => {
	let r = NK.parse(e);
	return r.r = 255 - r.r, r.g = 255 - r.g, r.b = 255 - r.b, N7(r, e, t);
}, "invert"), N9 = "#ffffff", Ie = "#f2f2f2", It = h((e, t) => t ? N6(e, {
	s: -40,
	l: 10
}) : N6(e, {
	s: -40,
	l: -10
}), "mkBorder"), Ir = class {
	static {
		h(this, "Theme");
	}
	constructor() {
		this.background = "#f4f4f4", this.primaryColor = "#fff4dd", this.noteBkgColor = "#fff5ad", this.noteTextColor = "#333", this.THEME_COLOR_LIMIT = 12, this.fontFamily = "\"trebuchet ms\", verdana, arial, sans-serif", this.fontSize = "16px";
	}
	updateColors() {
		if (this.primaryTextColor = this.primaryTextColor || (this.darkMode ? "#eee" : "#333"), this.secondaryColor = this.secondaryColor || N6(this.primaryColor, { h: -120 }), this.tertiaryColor = this.tertiaryColor || N6(this.primaryColor, {
			h: 180,
			l: 5
		}), this.primaryBorderColor = this.primaryBorderColor || It(this.primaryColor, this.darkMode), this.secondaryBorderColor = this.secondaryBorderColor || It(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = this.tertiaryBorderColor || It(this.tertiaryColor, this.darkMode), this.noteBorderColor = this.noteBorderColor || It(this.noteBkgColor, this.darkMode), this.noteBkgColor = this.noteBkgColor || "#fff5ad", this.noteTextColor = this.noteTextColor || "#333", this.secondaryTextColor = this.secondaryTextColor || N8(this.secondaryColor), this.tertiaryTextColor = this.tertiaryTextColor || N8(this.tertiaryColor), this.lineColor = this.lineColor || N8(this.background), this.arrowheadColor = this.arrowheadColor || N8(this.background), this.textColor = this.textColor || this.primaryTextColor, this.border2 = this.border2 || this.tertiaryBorderColor, this.nodeBkg = this.nodeBkg || this.primaryColor, this.mainBkg = this.mainBkg || this.primaryColor, this.nodeBorder = this.nodeBorder || this.primaryBorderColor, this.clusterBkg = this.clusterBkg || this.tertiaryColor, this.clusterBorder = this.clusterBorder || this.tertiaryBorderColor, this.defaultLinkColor = this.defaultLinkColor || this.lineColor, this.titleColor = this.titleColor || this.tertiaryTextColor, this.edgeLabelBackground = this.edgeLabelBackground || (this.darkMode ? N3(this.secondaryColor, 30) : this.secondaryColor), this.nodeTextColor = this.nodeTextColor || this.primaryTextColor, this.actorBorder = this.actorBorder || this.primaryBorderColor, this.actorBkg = this.actorBkg || this.mainBkg, this.actorTextColor = this.actorTextColor || this.primaryTextColor, this.actorLineColor = this.actorLineColor || this.actorBorder, this.labelBoxBkgColor = this.labelBoxBkgColor || this.actorBkg, this.signalColor = this.signalColor || this.textColor, this.signalTextColor = this.signalTextColor || this.textColor, this.labelBoxBorderColor = this.labelBoxBorderColor || this.actorBorder, this.labelTextColor = this.labelTextColor || this.actorTextColor, this.loopTextColor = this.loopTextColor || this.actorTextColor, this.activationBorderColor = this.activationBorderColor || N3(this.secondaryColor, 10), this.activationBkgColor = this.activationBkgColor || this.secondaryColor, this.sequenceNumberColor = this.sequenceNumberColor || N8(this.lineColor), this.sectionBkgColor = this.sectionBkgColor || this.tertiaryColor, this.altSectionBkgColor = this.altSectionBkgColor || "white", this.sectionBkgColor = this.sectionBkgColor || this.secondaryColor, this.sectionBkgColor2 = this.sectionBkgColor2 || this.primaryColor, this.excludeBkgColor = this.excludeBkgColor || "#eeeeee", this.taskBorderColor = this.taskBorderColor || this.primaryBorderColor, this.taskBkgColor = this.taskBkgColor || this.primaryColor, this.activeTaskBorderColor = this.activeTaskBorderColor || this.primaryColor, this.activeTaskBkgColor = this.activeTaskBkgColor || N5(this.primaryColor, 23), this.gridColor = this.gridColor || "lightgrey", this.doneTaskBkgColor = this.doneTaskBkgColor || "lightgrey", this.doneTaskBorderColor = this.doneTaskBorderColor || "grey", this.critBorderColor = this.critBorderColor || "#ff8888", this.critBkgColor = this.critBkgColor || "red", this.todayLineColor = this.todayLineColor || "red", this.vertLineColor = this.vertLineColor || "navy", this.taskTextColor = this.taskTextColor || this.textColor, this.taskTextOutsideColor = this.taskTextOutsideColor || this.textColor, this.taskTextLightColor = this.taskTextLightColor || this.textColor, this.taskTextColor = this.taskTextColor || this.primaryTextColor, this.taskTextDarkColor = this.taskTextDarkColor || this.textColor, this.taskTextClickableColor = this.taskTextClickableColor || "#003163", this.personBorder = this.personBorder || this.primaryBorderColor, this.personBkg = this.personBkg || this.mainBkg, this.darkMode ? (this.rowOdd = this.rowOdd || N3(this.mainBkg, 5) || "#ffffff", this.rowEven = this.rowEven || N3(this.mainBkg, 10)) : (this.rowOdd = this.rowOdd || N5(this.mainBkg, 75) || "#ffffff", this.rowEven = this.rowEven || N5(this.mainBkg, 5)), this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || this.tertiaryColor, this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.nodeBorder, this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.transitionColor = this.transitionColor || this.lineColor, this.specialStateColor = this.lineColor, this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || N6(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || N6(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || N6(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || N6(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || N6(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || N6(this.primaryColor, {
			h: 210,
			l: 150
		}), this.cScale9 = this.cScale9 || N6(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || N6(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || N6(this.primaryColor, { h: 330 }), this.darkMode) for (let e = 0; e < this.THEME_COLOR_LIMIT; e++) this["cScale" + e] = N3(this["cScale" + e], 75);
		else for (let e = 0; e < this.THEME_COLOR_LIMIT; e++) this["cScale" + e] = N3(this["cScale" + e], 25);
		for (let e = 0; e < this.THEME_COLOR_LIMIT; e++) this["cScaleInv" + e] = this["cScaleInv" + e] || N8(this["cScale" + e]);
		for (let e = 0; e < this.THEME_COLOR_LIMIT; e++) this.darkMode ? this["cScalePeer" + e] = this["cScalePeer" + e] || N5(this["cScale" + e], 10) : this["cScalePeer" + e] = this["cScalePeer" + e] || N3(this["cScale" + e], 10);
		this.scaleLabelColor = this.scaleLabelColor || this.labelTextColor;
		for (let e = 0; e < this.THEME_COLOR_LIMIT; e++) this["cScaleLabel" + e] = this["cScaleLabel" + e] || this.scaleLabelColor;
		let e = this.darkMode ? -4 : -1;
		for (let t = 0; t < 5; t++) this["surface" + t] = this["surface" + t] || N6(this.mainBkg, {
			h: 180,
			s: -15,
			l: e * (5 + 3 * t)
		}), this["surfacePeer" + t] = this["surfacePeer" + t] || N6(this.mainBkg, {
			h: 180,
			s: -15,
			l: e * (8 + 3 * t)
		});
		this.classText = this.classText || this.textColor, this.fillType0 = this.fillType0 || this.primaryColor, this.fillType1 = this.fillType1 || this.secondaryColor, this.fillType2 = this.fillType2 || N6(this.primaryColor, { h: 64 }), this.fillType3 = this.fillType3 || N6(this.secondaryColor, { h: 64 }), this.fillType4 = this.fillType4 || N6(this.primaryColor, { h: -64 }), this.fillType5 = this.fillType5 || N6(this.secondaryColor, { h: -64 }), this.fillType6 = this.fillType6 || N6(this.primaryColor, { h: 128 }), this.fillType7 = this.fillType7 || N6(this.secondaryColor, { h: 128 }), this.pie1 = this.pie1 || this.primaryColor, this.pie2 = this.pie2 || this.secondaryColor, this.pie3 = this.pie3 || this.tertiaryColor, this.pie4 = this.pie4 || N6(this.primaryColor, { l: -10 }), this.pie5 = this.pie5 || N6(this.secondaryColor, { l: -10 }), this.pie6 = this.pie6 || N6(this.tertiaryColor, { l: -10 }), this.pie7 = this.pie7 || N6(this.primaryColor, {
			h: 60,
			l: -10
		}), this.pie8 = this.pie8 || N6(this.primaryColor, {
			h: -60,
			l: -10
		}), this.pie9 = this.pie9 || N6(this.primaryColor, {
			h: 120,
			l: 0
		}), this.pie10 = this.pie10 || N6(this.primaryColor, {
			h: 60,
			l: -20
		}), this.pie11 = this.pie11 || N6(this.primaryColor, {
			h: -60,
			l: -20
		}), this.pie12 = this.pie12 || N6(this.primaryColor, {
			h: 120,
			l: -10
		}), this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.radar = {
			axisColor: this.radar?.axisColor || this.lineColor,
			axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
			axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
			curveOpacity: this.radar?.curveOpacity || .5,
			curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
			graticuleColor: this.radar?.graticuleColor || "#DEDEDE",
			graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
			graticuleOpacity: this.radar?.graticuleOpacity || .3,
			legendBoxSize: this.radar?.legendBoxSize || 12,
			legendFontSize: this.radar?.legendFontSize || 12
		}, this.archEdgeColor = this.archEdgeColor || "#777", this.archEdgeArrowColor = this.archEdgeArrowColor || "#777", this.archEdgeWidth = this.archEdgeWidth || "3", this.archGroupBorderColor = this.archGroupBorderColor || "#000", this.archGroupBorderWidth = this.archGroupBorderWidth || "2px", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || N6(this.primaryColor, {
			r: 5,
			g: 5,
			b: 5
		}), this.quadrant3Fill = this.quadrant3Fill || N6(this.primaryColor, {
			r: 10,
			g: 10,
			b: 10
		}), this.quadrant4Fill = this.quadrant4Fill || N6(this.primaryColor, {
			r: 15,
			g: 15,
			b: 15
		}), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || N6(this.primaryTextColor, {
			r: -5,
			g: -5,
			b: -5
		}), this.quadrant3TextFill = this.quadrant3TextFill || N6(this.primaryTextColor, {
			r: -10,
			g: -10,
			b: -10
		}), this.quadrant4TextFill = this.quadrant4TextFill || N6(this.primaryTextColor, {
			r: -15,
			g: -15,
			b: -15
		}), this.quadrantPointFill = this.quadrantPointFill || N2(this.quadrant1Fill) ? N5(this.quadrant1Fill) : N3(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.xyChart = {
			backgroundColor: this.xyChart?.backgroundColor || this.background,
			titleColor: this.xyChart?.titleColor || this.primaryTextColor,
			xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
			xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
			xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
			xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
			yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
			yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
			yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
			yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
			plotColorPalette: this.xyChart?.plotColorPalette || "#FFF4DD,#FFD8B1,#FFA07A,#ECEFF1,#D6DBDF,#C3E0A8,#FFB6A4,#FFD74D,#738FA7,#FFFFF0"
		}, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? N3(this.secondaryColor, 30) : this.secondaryColor), this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = this.git0 || this.primaryColor, this.git1 = this.git1 || this.secondaryColor, this.git2 = this.git2 || this.tertiaryColor, this.git3 = this.git3 || N6(this.primaryColor, { h: -30 }), this.git4 = this.git4 || N6(this.primaryColor, { h: -60 }), this.git5 = this.git5 || N6(this.primaryColor, { h: -90 }), this.git6 = this.git6 || N6(this.primaryColor, { h: 60 }), this.git7 = this.git7 || N6(this.primaryColor, { h: 120 }), this.darkMode ? (this.git0 = N5(this.git0, 25), this.git1 = N5(this.git1, 25), this.git2 = N5(this.git2, 25), this.git3 = N5(this.git3, 25), this.git4 = N5(this.git4, 25), this.git5 = N5(this.git5, 25), this.git6 = N5(this.git6, 25), this.git7 = N5(this.git7, 25)) : (this.git0 = N3(this.git0, 25), this.git1 = N3(this.git1, 25), this.git2 = N3(this.git2, 25), this.git3 = N3(this.git3, 25), this.git4 = N3(this.git4, 25), this.git5 = N3(this.git5, 25), this.git6 = N3(this.git6, 25), this.git7 = N3(this.git7, 25)), this.gitInv0 = this.gitInv0 || N8(this.git0), this.gitInv1 = this.gitInv1 || N8(this.git1), this.gitInv2 = this.gitInv2 || N8(this.git2), this.gitInv3 = this.gitInv3 || N8(this.git3), this.gitInv4 = this.gitInv4 || N8(this.git4), this.gitInv5 = this.gitInv5 || N8(this.git5), this.gitInv6 = this.gitInv6 || N8(this.git6), this.gitInv7 = this.gitInv7 || N8(this.git7), this.branchLabelColor = this.branchLabelColor || (this.darkMode ? "black" : this.labelTextColor), this.gitBranchLabel0 = this.gitBranchLabel0 || this.branchLabelColor, this.gitBranchLabel1 = this.gitBranchLabel1 || this.branchLabelColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.branchLabelColor, this.gitBranchLabel3 = this.gitBranchLabel3 || this.branchLabelColor, this.gitBranchLabel4 = this.gitBranchLabel4 || this.branchLabelColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.branchLabelColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.branchLabelColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.branchLabelColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || N9, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || Ie;
	}
	calculate(e) {
		if ("object" != typeof e) return void this.updateColors();
		let t = Object.keys(e);
		t.forEach((t) => {
			this[t] = e[t];
		}), this.updateColors(), t.forEach((t) => {
			this[t] = e[t];
		});
	}
}, Ii = h((e) => {
	let t = new Ir();
	return t.calculate(e), t;
}, "getThemeVariables"), In = class {
	static {
		h(this, "Theme");
	}
	constructor() {
		this.background = "#333", this.primaryColor = "#1f2020", this.secondaryColor = N5(this.primaryColor, 16), this.tertiaryColor = N6(this.primaryColor, { h: -160 }), this.primaryBorderColor = N8(this.background), this.secondaryBorderColor = It(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = It(this.tertiaryColor, this.darkMode), this.primaryTextColor = N8(this.primaryColor), this.secondaryTextColor = N8(this.secondaryColor), this.tertiaryTextColor = N8(this.tertiaryColor), this.lineColor = N8(this.background), this.textColor = N8(this.background), this.mainBkg = "#1f2020", this.secondBkg = "calculated", this.mainContrastColor = "lightgrey", this.darkTextColor = N5(N8("#323D47"), 10), this.lineColor = "calculated", this.border1 = "#ccc", this.border2 = NQ(255, 255, 255, .25), this.arrowheadColor = "calculated", this.fontFamily = "\"trebuchet ms\", verdana, arial, sans-serif", this.fontSize = "16px", this.labelBackground = "#181818", this.textColor = "#ccc", this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "#F9FFFE", this.edgeLabelBackground = "calculated", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "calculated", this.actorLineColor = "calculated", this.signalColor = "calculated", this.signalTextColor = "calculated", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "calculated", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "#fff5ad", this.noteTextColor = "calculated", this.activationBorderColor = "calculated", this.activationBkgColor = "calculated", this.sequenceNumberColor = "black", this.sectionBkgColor = N3("#EAE8D9", 30), this.altSectionBkgColor = "calculated", this.sectionBkgColor2 = "#EAE8D9", this.excludeBkgColor = N3(this.sectionBkgColor, 10), this.taskBorderColor = NQ(255, 255, 255, 70), this.taskBkgColor = "calculated", this.taskTextColor = "calculated", this.taskTextLightColor = "calculated", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = NQ(255, 255, 255, 50), this.activeTaskBkgColor = "#81B1DB", this.gridColor = "calculated", this.doneTaskBkgColor = "calculated", this.doneTaskBorderColor = "grey", this.critBorderColor = "#E83737", this.critBkgColor = "#E83737", this.taskTextDarkColor = "calculated", this.todayLineColor = "#DB5757", this.vertLineColor = "#00BFFF", this.personBorder = this.primaryBorderColor, this.personBkg = this.mainBkg, this.archEdgeColor = "calculated", this.archEdgeArrowColor = "calculated", this.archEdgeWidth = "3", this.archGroupBorderColor = this.primaryBorderColor, this.archGroupBorderWidth = "2px", this.rowOdd = this.rowOdd || N5(this.mainBkg, 5) || "#ffffff", this.rowEven = this.rowEven || N3(this.mainBkg, 10), this.labelColor = "calculated", this.errorBkgColor = "#a44141", this.errorTextColor = "#ddd";
	}
	updateColors() {
		this.secondBkg = N5(this.mainBkg, 16), this.lineColor = this.mainContrastColor, this.arrowheadColor = this.mainContrastColor, this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.edgeLabelBackground = N5(this.labelBackground, 25), this.actorBorder = this.border1, this.actorBkg = this.mainBkg, this.actorTextColor = this.mainContrastColor, this.actorLineColor = this.actorBorder, this.signalColor = this.mainContrastColor, this.signalTextColor = this.mainContrastColor, this.labelBoxBkgColor = this.actorBkg, this.labelBoxBorderColor = this.actorBorder, this.labelTextColor = this.mainContrastColor, this.loopTextColor = this.mainContrastColor, this.noteBorderColor = this.secondaryBorderColor, this.noteBkgColor = this.secondBkg, this.noteTextColor = this.secondaryTextColor, this.activationBorderColor = this.border1, this.activationBkgColor = this.secondBkg, this.altSectionBkgColor = this.background, this.taskBkgColor = N5(this.mainBkg, 23), this.taskTextColor = this.darkTextColor, this.taskTextLightColor = this.mainContrastColor, this.taskTextOutsideColor = this.taskTextLightColor, this.gridColor = this.mainContrastColor, this.doneTaskBkgColor = this.mainContrastColor, this.taskTextDarkColor = this.darkTextColor, this.archEdgeColor = this.lineColor, this.archEdgeArrowColor = this.lineColor, this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#555", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.primaryBorderColor, this.specialStateColor = "#f4f4f4", this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = N6(this.primaryColor, { h: 64 }), this.fillType3 = N6(this.secondaryColor, { h: 64 }), this.fillType4 = N6(this.primaryColor, { h: -64 }), this.fillType5 = N6(this.secondaryColor, { h: -64 }), this.fillType6 = N6(this.primaryColor, { h: 128 }), this.fillType7 = N6(this.secondaryColor, { h: 128 }), this.cScale1 = this.cScale1 || "#0b0000", this.cScale2 = this.cScale2 || "#4d1037", this.cScale3 = this.cScale3 || "#3f5258", this.cScale4 = this.cScale4 || "#4f2f1b", this.cScale5 = this.cScale5 || "#6e0a0a", this.cScale6 = this.cScale6 || "#3b0048", this.cScale7 = this.cScale7 || "#995a01", this.cScale8 = this.cScale8 || "#154706", this.cScale9 = this.cScale9 || "#161722", this.cScale10 = this.cScale10 || "#00296f", this.cScale11 = this.cScale11 || "#01629c", this.cScale12 = this.cScale12 || "#010029", this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || N6(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || N6(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || N6(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || N6(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || N6(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || N6(this.primaryColor, { h: 210 }), this.cScale9 = this.cScale9 || N6(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || N6(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || N6(this.primaryColor, { h: 330 });
		for (let e = 0; e < this.THEME_COLOR_LIMIT; e++) this["cScaleInv" + e] = this["cScaleInv" + e] || N8(this["cScale" + e]);
		for (let e = 0; e < this.THEME_COLOR_LIMIT; e++) this["cScalePeer" + e] = this["cScalePeer" + e] || N5(this["cScale" + e], 10);
		for (let e = 0; e < 5; e++) this["surface" + e] = this["surface" + e] || N6(this.mainBkg, {
			h: 30,
			s: -30,
			l: -(-10 + 4 * e)
		}), this["surfacePeer" + e] = this["surfacePeer" + e] || N6(this.mainBkg, {
			h: 30,
			s: -30,
			l: -(-7 + 4 * e)
		});
		this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? "black" : this.labelTextColor);
		for (let e = 0; e < this.THEME_COLOR_LIMIT; e++) this["cScaleLabel" + e] = this["cScaleLabel" + e] || this.scaleLabelColor;
		for (let e = 0; e < this.THEME_COLOR_LIMIT; e++) this["pie" + e] = this["cScale" + e];
		this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || N6(this.primaryColor, {
			r: 5,
			g: 5,
			b: 5
		}), this.quadrant3Fill = this.quadrant3Fill || N6(this.primaryColor, {
			r: 10,
			g: 10,
			b: 10
		}), this.quadrant4Fill = this.quadrant4Fill || N6(this.primaryColor, {
			r: 15,
			g: 15,
			b: 15
		}), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || N6(this.primaryTextColor, {
			r: -5,
			g: -5,
			b: -5
		}), this.quadrant3TextFill = this.quadrant3TextFill || N6(this.primaryTextColor, {
			r: -10,
			g: -10,
			b: -10
		}), this.quadrant4TextFill = this.quadrant4TextFill || N6(this.primaryTextColor, {
			r: -15,
			g: -15,
			b: -15
		}), this.quadrantPointFill = this.quadrantPointFill || N2(this.quadrant1Fill) ? N5(this.quadrant1Fill) : N3(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.xyChart = {
			backgroundColor: this.xyChart?.backgroundColor || this.background,
			titleColor: this.xyChart?.titleColor || this.primaryTextColor,
			xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
			xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
			xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
			xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
			yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
			yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
			yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
			yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
			plotColorPalette: this.xyChart?.plotColorPalette || "#3498db,#2ecc71,#e74c3c,#f1c40f,#bdc3c7,#ffffff,#34495e,#9b59b6,#1abc9c,#e67e22"
		}, this.packet = {
			startByteColor: this.primaryTextColor,
			endByteColor: this.primaryTextColor,
			labelColor: this.primaryTextColor,
			titleColor: this.primaryTextColor,
			blockStrokeColor: this.primaryTextColor,
			blockFillColor: this.background
		}, this.radar = {
			axisColor: this.radar?.axisColor || this.lineColor,
			axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
			axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
			curveOpacity: this.radar?.curveOpacity || .5,
			curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
			graticuleColor: this.radar?.graticuleColor || "#DEDEDE",
			graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
			graticuleOpacity: this.radar?.graticuleOpacity || .3,
			legendBoxSize: this.radar?.legendBoxSize || 12,
			legendFontSize: this.radar?.legendFontSize || 12
		}, this.classText = this.primaryTextColor, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? N3(this.secondaryColor, 30) : this.secondaryColor), this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = N5(this.secondaryColor, 20), this.git1 = N5(this.pie2 || this.secondaryColor, 20), this.git2 = N5(this.pie3 || this.tertiaryColor, 20), this.git3 = N5(this.pie4 || N6(this.primaryColor, { h: -30 }), 20), this.git4 = N5(this.pie5 || N6(this.primaryColor, { h: -60 }), 20), this.git5 = N5(this.pie6 || N6(this.primaryColor, { h: -90 }), 10), this.git6 = N5(this.pie7 || N6(this.primaryColor, { h: 60 }), 10), this.git7 = N5(this.pie8 || N6(this.primaryColor, { h: 120 }), 20), this.gitInv0 = this.gitInv0 || N8(this.git0), this.gitInv1 = this.gitInv1 || N8(this.git1), this.gitInv2 = this.gitInv2 || N8(this.git2), this.gitInv3 = this.gitInv3 || N8(this.git3), this.gitInv4 = this.gitInv4 || N8(this.git4), this.gitInv5 = this.gitInv5 || N8(this.git5), this.gitInv6 = this.gitInv6 || N8(this.git6), this.gitInv7 = this.gitInv7 || N8(this.git7), this.gitBranchLabel0 = this.gitBranchLabel0 || N8(this.labelTextColor), this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor, this.gitBranchLabel3 = this.gitBranchLabel3 || N8(this.labelTextColor), this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || N5(this.background, 12), this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || N5(this.background, 2), this.nodeBorder = this.nodeBorder || "#999";
	}
	calculate(e) {
		if ("object" != typeof e) return void this.updateColors();
		let t = Object.keys(e);
		t.forEach((t) => {
			this[t] = e[t];
		}), this.updateColors(), t.forEach((t) => {
			this[t] = e[t];
		});
	}
}, Ia = h((e) => {
	let t = new In();
	return t.calculate(e), t;
}, "getThemeVariables"), Is = class {
	static {
		h(this, "Theme");
	}
	constructor() {
		this.background = "#f4f4f4", this.primaryColor = "#ECECFF", this.secondaryColor = N6(this.primaryColor, { h: 120 }), this.secondaryColor = "#ffffde", this.tertiaryColor = N6(this.primaryColor, { h: -160 }), this.primaryBorderColor = It(this.primaryColor, this.darkMode), this.secondaryBorderColor = It(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = It(this.tertiaryColor, this.darkMode), this.primaryTextColor = N8(this.primaryColor), this.secondaryTextColor = N8(this.secondaryColor), this.tertiaryTextColor = N8(this.tertiaryColor), this.lineColor = N8(this.background), this.textColor = N8(this.background), this.background = "white", this.mainBkg = "#ECECFF", this.secondBkg = "#ffffde", this.lineColor = "#333333", this.border1 = "#9370DB", this.border2 = "#aaaa33", this.arrowheadColor = "#333333", this.fontFamily = "\"trebuchet ms\", verdana, arial, sans-serif", this.fontSize = "16px", this.labelBackground = "rgba(232,232,232, 0.8)", this.textColor = "#333", this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "calculated", this.edgeLabelBackground = "calculated", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "black", this.actorLineColor = "calculated", this.signalColor = "calculated", this.signalTextColor = "calculated", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "calculated", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "#fff5ad", this.noteTextColor = "calculated", this.activationBorderColor = "#666", this.activationBkgColor = "#f4f4f4", this.sequenceNumberColor = "white", this.sectionBkgColor = "calculated", this.altSectionBkgColor = "calculated", this.sectionBkgColor2 = "calculated", this.excludeBkgColor = "#eeeeee", this.taskBorderColor = "calculated", this.taskBkgColor = "calculated", this.taskTextLightColor = "calculated", this.taskTextColor = this.taskTextLightColor, this.taskTextDarkColor = "calculated", this.taskTextOutsideColor = this.taskTextDarkColor, this.taskTextClickableColor = "calculated", this.activeTaskBorderColor = "calculated", this.activeTaskBkgColor = "calculated", this.gridColor = "calculated", this.doneTaskBkgColor = "calculated", this.doneTaskBorderColor = "calculated", this.critBorderColor = "calculated", this.critBkgColor = "calculated", this.todayLineColor = "calculated", this.vertLineColor = "calculated", this.sectionBkgColor = NQ(102, 102, 255, .49), this.altSectionBkgColor = "white", this.sectionBkgColor2 = "#fff400", this.taskBorderColor = "#534fbc", this.taskBkgColor = "#8a90dd", this.taskTextLightColor = "white", this.taskTextColor = "calculated", this.taskTextDarkColor = "black", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = "#534fbc", this.activeTaskBkgColor = "#bfc7ff", this.gridColor = "lightgrey", this.doneTaskBkgColor = "lightgrey", this.doneTaskBorderColor = "grey", this.critBorderColor = "#ff8888", this.critBkgColor = "red", this.todayLineColor = "red", this.vertLineColor = "navy", this.personBorder = this.primaryBorderColor, this.personBkg = this.mainBkg, this.archEdgeColor = "calculated", this.archEdgeArrowColor = "calculated", this.archEdgeWidth = "3", this.archGroupBorderColor = this.primaryBorderColor, this.archGroupBorderWidth = "2px", this.rowOdd = "calculated", this.rowEven = "calculated", this.labelColor = "black", this.errorBkgColor = "#552222", this.errorTextColor = "#552222", this.updateColors();
	}
	updateColors() {
		this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || N6(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || N6(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || N6(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || N6(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || N6(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || N6(this.primaryColor, { h: 210 }), this.cScale9 = this.cScale9 || N6(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || N6(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || N6(this.primaryColor, { h: 330 }), this.cScalePeer1 = this.cScalePeer1 || N3(this.secondaryColor, 45), this.cScalePeer2 = this.cScalePeer2 || N3(this.tertiaryColor, 40);
		for (let e = 0; e < this.THEME_COLOR_LIMIT; e++) this["cScale" + e] = N3(this["cScale" + e], 10), this["cScalePeer" + e] = this["cScalePeer" + e] || N3(this["cScale" + e], 25);
		for (let e = 0; e < this.THEME_COLOR_LIMIT; e++) this["cScaleInv" + e] = this["cScaleInv" + e] || N6(this["cScale" + e], { h: 180 });
		for (let e = 0; e < 5; e++) this["surface" + e] = this["surface" + e] || N6(this.mainBkg, {
			h: 30,
			l: -(5 + 5 * e)
		}), this["surfacePeer" + e] = this["surfacePeer" + e] || N6(this.mainBkg, {
			h: 30,
			l: -(7 + 5 * e)
		});
		if (this.scaleLabelColor = "calculated" !== this.scaleLabelColor && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor, "calculated" !== this.labelTextColor) {
			this.cScaleLabel0 = this.cScaleLabel0 || N8(this.labelTextColor), this.cScaleLabel3 = this.cScaleLabel3 || N8(this.labelTextColor);
			for (let e = 0; e < this.THEME_COLOR_LIMIT; e++) this["cScaleLabel" + e] = this["cScaleLabel" + e] || this.labelTextColor;
		}
		this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.titleColor = this.textColor, this.edgeLabelBackground = this.labelBackground, this.actorBorder = N5(this.border1, 23), this.actorBkg = this.mainBkg, this.labelBoxBkgColor = this.actorBkg, this.signalColor = this.textColor, this.signalTextColor = this.textColor, this.labelBoxBorderColor = this.actorBorder, this.labelTextColor = this.actorTextColor, this.loopTextColor = this.actorTextColor, this.noteBorderColor = this.border2, this.noteTextColor = this.actorTextColor, this.actorLineColor = this.actorBorder, this.taskTextColor = this.taskTextLightColor, this.taskTextOutsideColor = this.taskTextDarkColor, this.archEdgeColor = this.lineColor, this.archEdgeArrowColor = this.lineColor, this.rowOdd = this.rowOdd || N5(this.primaryColor, 75) || "#ffffff", this.rowEven = this.rowEven || N5(this.primaryColor, 1), this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#f0f0f0", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.nodeBorder, this.specialStateColor = this.lineColor, this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.transitionColor = this.transitionColor || this.lineColor, this.classText = this.primaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = N6(this.primaryColor, { h: 64 }), this.fillType3 = N6(this.secondaryColor, { h: 64 }), this.fillType4 = N6(this.primaryColor, { h: -64 }), this.fillType5 = N6(this.secondaryColor, { h: -64 }), this.fillType6 = N6(this.primaryColor, { h: 128 }), this.fillType7 = N6(this.secondaryColor, { h: 128 }), this.pie1 = this.pie1 || this.primaryColor, this.pie2 = this.pie2 || this.secondaryColor, this.pie3 = this.pie3 || N6(this.tertiaryColor, { l: -40 }), this.pie4 = this.pie4 || N6(this.primaryColor, { l: -10 }), this.pie5 = this.pie5 || N6(this.secondaryColor, { l: -30 }), this.pie6 = this.pie6 || N6(this.tertiaryColor, { l: -20 }), this.pie7 = this.pie7 || N6(this.primaryColor, {
			h: 60,
			l: -20
		}), this.pie8 = this.pie8 || N6(this.primaryColor, {
			h: -60,
			l: -40
		}), this.pie9 = this.pie9 || N6(this.primaryColor, {
			h: 120,
			l: -40
		}), this.pie10 = this.pie10 || N6(this.primaryColor, {
			h: 60,
			l: -40
		}), this.pie11 = this.pie11 || N6(this.primaryColor, {
			h: -90,
			l: -40
		}), this.pie12 = this.pie12 || N6(this.primaryColor, {
			h: 120,
			l: -30
		}), this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || N6(this.primaryColor, {
			r: 5,
			g: 5,
			b: 5
		}), this.quadrant3Fill = this.quadrant3Fill || N6(this.primaryColor, {
			r: 10,
			g: 10,
			b: 10
		}), this.quadrant4Fill = this.quadrant4Fill || N6(this.primaryColor, {
			r: 15,
			g: 15,
			b: 15
		}), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || N6(this.primaryTextColor, {
			r: -5,
			g: -5,
			b: -5
		}), this.quadrant3TextFill = this.quadrant3TextFill || N6(this.primaryTextColor, {
			r: -10,
			g: -10,
			b: -10
		}), this.quadrant4TextFill = this.quadrant4TextFill || N6(this.primaryTextColor, {
			r: -15,
			g: -15,
			b: -15
		}), this.quadrantPointFill = this.quadrantPointFill || N2(this.quadrant1Fill) ? N5(this.quadrant1Fill) : N3(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.radar = {
			axisColor: this.radar?.axisColor || this.lineColor,
			axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
			axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
			curveOpacity: this.radar?.curveOpacity || .5,
			curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
			graticuleColor: this.radar?.graticuleColor || "#DEDEDE",
			graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
			graticuleOpacity: this.radar?.graticuleOpacity || .3,
			legendBoxSize: this.radar?.legendBoxSize || 12,
			legendFontSize: this.radar?.legendFontSize || 12
		}, this.xyChart = {
			backgroundColor: this.xyChart?.backgroundColor || this.background,
			titleColor: this.xyChart?.titleColor || this.primaryTextColor,
			xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
			xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
			xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
			xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
			yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
			yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
			yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
			yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
			plotColorPalette: this.xyChart?.plotColorPalette || "#ECECFF,#8493A6,#FFC3A0,#DCDDE1,#B8E994,#D1A36F,#C3CDE6,#FFB6C1,#496078,#F8F3E3"
		}, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || this.labelBackground, this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = this.git0 || this.primaryColor, this.git1 = this.git1 || this.secondaryColor, this.git2 = this.git2 || this.tertiaryColor, this.git3 = this.git3 || N6(this.primaryColor, { h: -30 }), this.git4 = this.git4 || N6(this.primaryColor, { h: -60 }), this.git5 = this.git5 || N6(this.primaryColor, { h: -90 }), this.git6 = this.git6 || N6(this.primaryColor, { h: 60 }), this.git7 = this.git7 || N6(this.primaryColor, { h: 120 }), this.darkMode ? (this.git0 = N5(this.git0, 25), this.git1 = N5(this.git1, 25), this.git2 = N5(this.git2, 25), this.git3 = N5(this.git3, 25), this.git4 = N5(this.git4, 25), this.git5 = N5(this.git5, 25), this.git6 = N5(this.git6, 25), this.git7 = N5(this.git7, 25)) : (this.git0 = N3(this.git0, 25), this.git1 = N3(this.git1, 25), this.git2 = N3(this.git2, 25), this.git3 = N3(this.git3, 25), this.git4 = N3(this.git4, 25), this.git5 = N3(this.git5, 25), this.git6 = N3(this.git6, 25), this.git7 = N3(this.git7, 25)), this.gitInv0 = this.gitInv0 || N3(N8(this.git0), 25), this.gitInv1 = this.gitInv1 || N8(this.git1), this.gitInv2 = this.gitInv2 || N8(this.git2), this.gitInv3 = this.gitInv3 || N8(this.git3), this.gitInv4 = this.gitInv4 || N8(this.git4), this.gitInv5 = this.gitInv5 || N8(this.git5), this.gitInv6 = this.gitInv6 || N8(this.git6), this.gitInv7 = this.gitInv7 || N8(this.git7), this.gitBranchLabel0 = this.gitBranchLabel0 || N8(this.labelTextColor), this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor, this.gitBranchLabel3 = this.gitBranchLabel3 || N8(this.labelTextColor), this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || N9, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || Ie;
	}
	calculate(e) {
		if (Object.keys(this).forEach((e) => {
			"calculated" === this[e] && (this[e] = void 0);
		}), "object" != typeof e) return void this.updateColors();
		let t = Object.keys(e);
		t.forEach((t) => {
			this[t] = e[t];
		}), this.updateColors(), t.forEach((t) => {
			this[t] = e[t];
		});
	}
}, Io = h((e) => {
	let t = new Is();
	return t.calculate(e), t;
}, "getThemeVariables"), Il = class {
	static {
		h(this, "Theme");
	}
	constructor() {
		this.background = "#f4f4f4", this.primaryColor = "#cde498", this.secondaryColor = "#cdffb2", this.background = "white", this.mainBkg = "#cde498", this.secondBkg = "#cdffb2", this.lineColor = "green", this.border1 = "#13540c", this.border2 = "#6eaa49", this.arrowheadColor = "green", this.fontFamily = "\"trebuchet ms\", verdana, arial, sans-serif", this.fontSize = "16px", this.tertiaryColor = N5("#cde498", 10), this.primaryBorderColor = It(this.primaryColor, this.darkMode), this.secondaryBorderColor = It(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = It(this.tertiaryColor, this.darkMode), this.primaryTextColor = N8(this.primaryColor), this.secondaryTextColor = N8(this.secondaryColor), this.tertiaryTextColor = N8(this.primaryColor), this.lineColor = N8(this.background), this.textColor = N8(this.background), this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "#333", this.edgeLabelBackground = "#e8e8e8", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "black", this.actorLineColor = "calculated", this.signalColor = "#333", this.signalTextColor = "#333", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "#326932", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "#fff5ad", this.noteTextColor = "calculated", this.activationBorderColor = "#666", this.activationBkgColor = "#f4f4f4", this.sequenceNumberColor = "white", this.sectionBkgColor = "#6eaa49", this.altSectionBkgColor = "white", this.sectionBkgColor2 = "#6eaa49", this.excludeBkgColor = "#eeeeee", this.taskBorderColor = "calculated", this.taskBkgColor = "#487e3a", this.taskTextLightColor = "white", this.taskTextColor = "calculated", this.taskTextDarkColor = "black", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = "calculated", this.activeTaskBkgColor = "calculated", this.gridColor = "lightgrey", this.doneTaskBkgColor = "lightgrey", this.doneTaskBorderColor = "grey", this.critBorderColor = "#ff8888", this.critBkgColor = "red", this.todayLineColor = "red", this.vertLineColor = "#00BFFF", this.personBorder = this.primaryBorderColor, this.personBkg = this.mainBkg, this.archEdgeColor = "calculated", this.archEdgeArrowColor = "calculated", this.archEdgeWidth = "3", this.archGroupBorderColor = this.primaryBorderColor, this.archGroupBorderWidth = "2px", this.labelColor = "black", this.errorBkgColor = "#552222", this.errorTextColor = "#552222";
	}
	updateColors() {
		this.actorBorder = N3(this.mainBkg, 20), this.actorBkg = this.mainBkg, this.labelBoxBkgColor = this.actorBkg, this.labelTextColor = this.actorTextColor, this.loopTextColor = this.actorTextColor, this.noteBorderColor = this.border2, this.noteTextColor = this.actorTextColor, this.actorLineColor = this.actorBorder, this.cScale0 = this.cScale0 || this.primaryColor, this.cScale1 = this.cScale1 || this.secondaryColor, this.cScale2 = this.cScale2 || this.tertiaryColor, this.cScale3 = this.cScale3 || N6(this.primaryColor, { h: 30 }), this.cScale4 = this.cScale4 || N6(this.primaryColor, { h: 60 }), this.cScale5 = this.cScale5 || N6(this.primaryColor, { h: 90 }), this.cScale6 = this.cScale6 || N6(this.primaryColor, { h: 120 }), this.cScale7 = this.cScale7 || N6(this.primaryColor, { h: 150 }), this.cScale8 = this.cScale8 || N6(this.primaryColor, { h: 210 }), this.cScale9 = this.cScale9 || N6(this.primaryColor, { h: 270 }), this.cScale10 = this.cScale10 || N6(this.primaryColor, { h: 300 }), this.cScale11 = this.cScale11 || N6(this.primaryColor, { h: 330 }), this.cScalePeer1 = this.cScalePeer1 || N3(this.secondaryColor, 45), this.cScalePeer2 = this.cScalePeer2 || N3(this.tertiaryColor, 40);
		for (let e = 0; e < this.THEME_COLOR_LIMIT; e++) this["cScale" + e] = N3(this["cScale" + e], 10), this["cScalePeer" + e] = this["cScalePeer" + e] || N3(this["cScale" + e], 25);
		for (let e = 0; e < this.THEME_COLOR_LIMIT; e++) this["cScaleInv" + e] = this["cScaleInv" + e] || N6(this["cScale" + e], { h: 180 });
		this.scaleLabelColor = "calculated" !== this.scaleLabelColor && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor;
		for (let e = 0; e < this.THEME_COLOR_LIMIT; e++) this["cScaleLabel" + e] = this["cScaleLabel" + e] || this.scaleLabelColor;
		for (let e = 0; e < 5; e++) this["surface" + e] = this["surface" + e] || N6(this.mainBkg, {
			h: 30,
			s: -30,
			l: -(5 + 5 * e)
		}), this["surfacePeer" + e] = this["surfacePeer" + e] || N6(this.mainBkg, {
			h: 30,
			s: -30,
			l: -(8 + 5 * e)
		});
		this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.taskBorderColor = this.border1, this.taskTextColor = this.taskTextLightColor, this.taskTextOutsideColor = this.taskTextDarkColor, this.activeTaskBorderColor = this.taskBorderColor, this.activeTaskBkgColor = this.mainBkg, this.archEdgeColor = this.lineColor, this.archEdgeArrowColor = this.lineColor, this.rowOdd = this.rowOdd || N5(this.mainBkg, 75) || "#ffffff", this.rowEven = this.rowEven || N5(this.mainBkg, 20), this.transitionColor = this.transitionColor || this.lineColor, this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#f0f0f0", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.compositeBorder = this.compositeBorder || this.nodeBorder, this.innerEndBackground = this.primaryBorderColor, this.specialStateColor = this.lineColor, this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.transitionColor = this.transitionColor || this.lineColor, this.classText = this.primaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = N6(this.primaryColor, { h: 64 }), this.fillType3 = N6(this.secondaryColor, { h: 64 }), this.fillType4 = N6(this.primaryColor, { h: -64 }), this.fillType5 = N6(this.secondaryColor, { h: -64 }), this.fillType6 = N6(this.primaryColor, { h: 128 }), this.fillType7 = N6(this.secondaryColor, { h: 128 }), this.pie1 = this.pie1 || this.primaryColor, this.pie2 = this.pie2 || this.secondaryColor, this.pie3 = this.pie3 || this.tertiaryColor, this.pie4 = this.pie4 || N6(this.primaryColor, { l: -30 }), this.pie5 = this.pie5 || N6(this.secondaryColor, { l: -30 }), this.pie6 = this.pie6 || N6(this.tertiaryColor, {
			h: 40,
			l: -40
		}), this.pie7 = this.pie7 || N6(this.primaryColor, {
			h: 60,
			l: -10
		}), this.pie8 = this.pie8 || N6(this.primaryColor, {
			h: -60,
			l: -10
		}), this.pie9 = this.pie9 || N6(this.primaryColor, {
			h: 120,
			l: 0
		}), this.pie10 = this.pie10 || N6(this.primaryColor, {
			h: 60,
			l: -50
		}), this.pie11 = this.pie11 || N6(this.primaryColor, {
			h: -60,
			l: -50
		}), this.pie12 = this.pie12 || N6(this.primaryColor, {
			h: 120,
			l: -50
		}), this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || N6(this.primaryColor, {
			r: 5,
			g: 5,
			b: 5
		}), this.quadrant3Fill = this.quadrant3Fill || N6(this.primaryColor, {
			r: 10,
			g: 10,
			b: 10
		}), this.quadrant4Fill = this.quadrant4Fill || N6(this.primaryColor, {
			r: 15,
			g: 15,
			b: 15
		}), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || N6(this.primaryTextColor, {
			r: -5,
			g: -5,
			b: -5
		}), this.quadrant3TextFill = this.quadrant3TextFill || N6(this.primaryTextColor, {
			r: -10,
			g: -10,
			b: -10
		}), this.quadrant4TextFill = this.quadrant4TextFill || N6(this.primaryTextColor, {
			r: -15,
			g: -15,
			b: -15
		}), this.quadrantPointFill = this.quadrantPointFill || N2(this.quadrant1Fill) ? N5(this.quadrant1Fill) : N3(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.packet = {
			startByteColor: this.primaryTextColor,
			endByteColor: this.primaryTextColor,
			labelColor: this.primaryTextColor,
			titleColor: this.primaryTextColor,
			blockStrokeColor: this.primaryTextColor,
			blockFillColor: this.mainBkg
		}, this.radar = {
			axisColor: this.radar?.axisColor || this.lineColor,
			axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
			axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
			curveOpacity: this.radar?.curveOpacity || .5,
			curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
			graticuleColor: this.radar?.graticuleColor || "#DEDEDE",
			graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
			graticuleOpacity: this.radar?.graticuleOpacity || .3,
			legendBoxSize: this.radar?.legendBoxSize || 12,
			legendFontSize: this.radar?.legendFontSize || 12
		}, this.xyChart = {
			backgroundColor: this.xyChart?.backgroundColor || this.background,
			titleColor: this.xyChart?.titleColor || this.primaryTextColor,
			xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
			xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
			xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
			xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
			yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
			yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
			yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
			yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
			plotColorPalette: this.xyChart?.plotColorPalette || "#CDE498,#FF6B6B,#A0D2DB,#D7BDE2,#F0F0F0,#FFC3A0,#7FD8BE,#FF9A8B,#FAF3E0,#FFF176"
		}, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground, this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = this.git0 || this.primaryColor, this.git1 = this.git1 || this.secondaryColor, this.git2 = this.git2 || this.tertiaryColor, this.git3 = this.git3 || N6(this.primaryColor, { h: -30 }), this.git4 = this.git4 || N6(this.primaryColor, { h: -60 }), this.git5 = this.git5 || N6(this.primaryColor, { h: -90 }), this.git6 = this.git6 || N6(this.primaryColor, { h: 60 }), this.git7 = this.git7 || N6(this.primaryColor, { h: 120 }), this.darkMode ? (this.git0 = N5(this.git0, 25), this.git1 = N5(this.git1, 25), this.git2 = N5(this.git2, 25), this.git3 = N5(this.git3, 25), this.git4 = N5(this.git4, 25), this.git5 = N5(this.git5, 25), this.git6 = N5(this.git6, 25), this.git7 = N5(this.git7, 25)) : (this.git0 = N3(this.git0, 25), this.git1 = N3(this.git1, 25), this.git2 = N3(this.git2, 25), this.git3 = N3(this.git3, 25), this.git4 = N3(this.git4, 25), this.git5 = N3(this.git5, 25), this.git6 = N3(this.git6, 25), this.git7 = N3(this.git7, 25)), this.gitInv0 = this.gitInv0 || N8(this.git0), this.gitInv1 = this.gitInv1 || N8(this.git1), this.gitInv2 = this.gitInv2 || N8(this.git2), this.gitInv3 = this.gitInv3 || N8(this.git3), this.gitInv4 = this.gitInv4 || N8(this.git4), this.gitInv5 = this.gitInv5 || N8(this.git5), this.gitInv6 = this.gitInv6 || N8(this.git6), this.gitInv7 = this.gitInv7 || N8(this.git7), this.gitBranchLabel0 = this.gitBranchLabel0 || N8(this.labelTextColor), this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor, this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor, this.gitBranchLabel3 = this.gitBranchLabel3 || N8(this.labelTextColor), this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor, this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor, this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor, this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || N9, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || Ie;
	}
	calculate(e) {
		if ("object" != typeof e) return void this.updateColors();
		let t = Object.keys(e);
		t.forEach((t) => {
			this[t] = e[t];
		}), this.updateColors(), t.forEach((t) => {
			this[t] = e[t];
		});
	}
}, Ic = h((e) => {
	let t = new Il();
	return t.calculate(e), t;
}, "getThemeVariables"), Ih = class {
	static {
		h(this, "Theme");
	}
	constructor() {
		this.primaryColor = "#eee", this.contrast = "#707070", this.secondaryColor = N5(this.contrast, 55), this.background = "#ffffff", this.tertiaryColor = N6(this.primaryColor, { h: -160 }), this.primaryBorderColor = It(this.primaryColor, this.darkMode), this.secondaryBorderColor = It(this.secondaryColor, this.darkMode), this.tertiaryBorderColor = It(this.tertiaryColor, this.darkMode), this.primaryTextColor = N8(this.primaryColor), this.secondaryTextColor = N8(this.secondaryColor), this.tertiaryTextColor = N8(this.tertiaryColor), this.lineColor = N8(this.background), this.textColor = N8(this.background), this.mainBkg = "#eee", this.secondBkg = "calculated", this.lineColor = "#666", this.border1 = "#999", this.border2 = "calculated", this.note = "#ffa", this.text = "#333", this.critical = "#d42", this.done = "#bbb", this.arrowheadColor = "#333333", this.fontFamily = "\"trebuchet ms\", verdana, arial, sans-serif", this.fontSize = "16px", this.THEME_COLOR_LIMIT = 12, this.nodeBkg = "calculated", this.nodeBorder = "calculated", this.clusterBkg = "calculated", this.clusterBorder = "calculated", this.defaultLinkColor = "calculated", this.titleColor = "calculated", this.edgeLabelBackground = "white", this.actorBorder = "calculated", this.actorBkg = "calculated", this.actorTextColor = "calculated", this.actorLineColor = this.actorBorder, this.signalColor = "calculated", this.signalTextColor = "calculated", this.labelBoxBkgColor = "calculated", this.labelBoxBorderColor = "calculated", this.labelTextColor = "calculated", this.loopTextColor = "calculated", this.noteBorderColor = "calculated", this.noteBkgColor = "calculated", this.noteTextColor = "calculated", this.activationBorderColor = "#666", this.activationBkgColor = "#f4f4f4", this.sequenceNumberColor = "white", this.sectionBkgColor = "calculated", this.altSectionBkgColor = "white", this.sectionBkgColor2 = "calculated", this.excludeBkgColor = "#eeeeee", this.taskBorderColor = "calculated", this.taskBkgColor = "calculated", this.taskTextLightColor = "white", this.taskTextColor = "calculated", this.taskTextDarkColor = "calculated", this.taskTextOutsideColor = "calculated", this.taskTextClickableColor = "#003163", this.activeTaskBorderColor = "calculated", this.activeTaskBkgColor = "calculated", this.gridColor = "calculated", this.doneTaskBkgColor = "calculated", this.doneTaskBorderColor = "calculated", this.critBkgColor = "calculated", this.critBorderColor = "calculated", this.todayLineColor = "calculated", this.vertLineColor = "calculated", this.personBorder = this.primaryBorderColor, this.personBkg = this.mainBkg, this.archEdgeColor = "calculated", this.archEdgeArrowColor = "calculated", this.archEdgeWidth = "3", this.archGroupBorderColor = this.primaryBorderColor, this.archGroupBorderWidth = "2px", this.rowOdd = this.rowOdd || N5(this.mainBkg, 75) || "#ffffff", this.rowEven = this.rowEven || "#f4f4f4", this.labelColor = "black", this.errorBkgColor = "#552222", this.errorTextColor = "#552222";
	}
	updateColors() {
		this.secondBkg = N5(this.contrast, 55), this.border2 = this.contrast, this.actorBorder = N5(this.border1, 23), this.actorBkg = this.mainBkg, this.actorTextColor = this.text, this.actorLineColor = this.actorBorder, this.signalColor = this.text, this.signalTextColor = this.text, this.labelBoxBkgColor = this.actorBkg, this.labelBoxBorderColor = this.actorBorder, this.labelTextColor = this.text, this.loopTextColor = this.text, this.noteBorderColor = "#999", this.noteBkgColor = "#666", this.noteTextColor = "#fff", this.cScale0 = this.cScale0 || "#555", this.cScale1 = this.cScale1 || "#F4F4F4", this.cScale2 = this.cScale2 || "#555", this.cScale3 = this.cScale3 || "#BBB", this.cScale4 = this.cScale4 || "#777", this.cScale5 = this.cScale5 || "#999", this.cScale6 = this.cScale6 || "#DDD", this.cScale7 = this.cScale7 || "#FFF", this.cScale8 = this.cScale8 || "#DDD", this.cScale9 = this.cScale9 || "#BBB", this.cScale10 = this.cScale10 || "#999", this.cScale11 = this.cScale11 || "#777";
		for (let e = 0; e < this.THEME_COLOR_LIMIT; e++) this["cScaleInv" + e] = this["cScaleInv" + e] || N8(this["cScale" + e]);
		for (let e = 0; e < this.THEME_COLOR_LIMIT; e++) this.darkMode ? this["cScalePeer" + e] = this["cScalePeer" + e] || N5(this["cScale" + e], 10) : this["cScalePeer" + e] = this["cScalePeer" + e] || N3(this["cScale" + e], 10);
		this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? "black" : this.labelTextColor), this.cScaleLabel0 = this.cScaleLabel0 || this.cScale1, this.cScaleLabel2 = this.cScaleLabel2 || this.cScale1;
		for (let e = 0; e < this.THEME_COLOR_LIMIT; e++) this["cScaleLabel" + e] = this["cScaleLabel" + e] || this.scaleLabelColor;
		for (let e = 0; e < 5; e++) this["surface" + e] = this["surface" + e] || N6(this.mainBkg, { l: -(5 + 5 * e) }), this["surfacePeer" + e] = this["surfacePeer" + e] || N6(this.mainBkg, { l: -(8 + 5 * e) });
		this.nodeBkg = this.mainBkg, this.nodeBorder = this.border1, this.clusterBkg = this.secondBkg, this.clusterBorder = this.border2, this.defaultLinkColor = this.lineColor, this.titleColor = this.text, this.sectionBkgColor = N5(this.contrast, 30), this.sectionBkgColor2 = N5(this.contrast, 30), this.taskBorderColor = N3(this.contrast, 10), this.taskBkgColor = this.contrast, this.taskTextColor = this.taskTextLightColor, this.taskTextDarkColor = this.text, this.taskTextOutsideColor = this.taskTextDarkColor, this.activeTaskBorderColor = this.taskBorderColor, this.activeTaskBkgColor = this.mainBkg, this.gridColor = N5(this.border1, 30), this.doneTaskBkgColor = this.done, this.doneTaskBorderColor = this.lineColor, this.critBkgColor = this.critical, this.critBorderColor = N3(this.critBkgColor, 10), this.todayLineColor = this.critBkgColor, this.vertLineColor = this.critBkgColor, this.archEdgeColor = this.lineColor, this.archEdgeArrowColor = this.lineColor, this.transitionColor = this.transitionColor || "#000", this.transitionLabelColor = this.transitionLabelColor || this.textColor, this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor, this.stateBkg = this.stateBkg || this.mainBkg, this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg, this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor, this.altBackground = this.altBackground || "#f4f4f4", this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg, this.stateBorder = this.stateBorder || "#000", this.innerEndBackground = this.primaryBorderColor, this.specialStateColor = "#222", this.errorBkgColor = this.errorBkgColor || this.tertiaryColor, this.errorTextColor = this.errorTextColor || this.tertiaryTextColor, this.classText = this.primaryTextColor, this.fillType0 = this.primaryColor, this.fillType1 = this.secondaryColor, this.fillType2 = N6(this.primaryColor, { h: 64 }), this.fillType3 = N6(this.secondaryColor, { h: 64 }), this.fillType4 = N6(this.primaryColor, { h: -64 }), this.fillType5 = N6(this.secondaryColor, { h: -64 }), this.fillType6 = N6(this.primaryColor, { h: 128 }), this.fillType7 = N6(this.secondaryColor, { h: 128 });
		for (let e = 0; e < this.THEME_COLOR_LIMIT; e++) this["pie" + e] = this["cScale" + e];
		this.pie12 = this.pie0, this.pieTitleTextSize = this.pieTitleTextSize || "25px", this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor, this.pieSectionTextSize = this.pieSectionTextSize || "17px", this.pieSectionTextColor = this.pieSectionTextColor || this.textColor, this.pieLegendTextSize = this.pieLegendTextSize || "17px", this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor, this.pieStrokeColor = this.pieStrokeColor || "black", this.pieStrokeWidth = this.pieStrokeWidth || "2px", this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px", this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black", this.pieOpacity = this.pieOpacity || "0.7", this.quadrant1Fill = this.quadrant1Fill || this.primaryColor, this.quadrant2Fill = this.quadrant2Fill || N6(this.primaryColor, {
			r: 5,
			g: 5,
			b: 5
		}), this.quadrant3Fill = this.quadrant3Fill || N6(this.primaryColor, {
			r: 10,
			g: 10,
			b: 10
		}), this.quadrant4Fill = this.quadrant4Fill || N6(this.primaryColor, {
			r: 15,
			g: 15,
			b: 15
		}), this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor, this.quadrant2TextFill = this.quadrant2TextFill || N6(this.primaryTextColor, {
			r: -5,
			g: -5,
			b: -5
		}), this.quadrant3TextFill = this.quadrant3TextFill || N6(this.primaryTextColor, {
			r: -10,
			g: -10,
			b: -10
		}), this.quadrant4TextFill = this.quadrant4TextFill || N6(this.primaryTextColor, {
			r: -15,
			g: -15,
			b: -15
		}), this.quadrantPointFill = this.quadrantPointFill || N2(this.quadrant1Fill) ? N5(this.quadrant1Fill) : N3(this.quadrant1Fill), this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor, this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor, this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor, this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor, this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor, this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor, this.xyChart = {
			backgroundColor: this.xyChart?.backgroundColor || this.background,
			titleColor: this.xyChart?.titleColor || this.primaryTextColor,
			xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
			xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
			xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
			xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
			yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
			yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
			yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
			yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
			plotColorPalette: this.xyChart?.plotColorPalette || "#EEE,#6BB8E4,#8ACB88,#C7ACD6,#E8DCC2,#FFB2A8,#FFF380,#7E8D91,#FFD8B1,#FAF3E0"
		}, this.radar = {
			axisColor: this.radar?.axisColor || this.lineColor,
			axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
			axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
			curveOpacity: this.radar?.curveOpacity || .5,
			curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
			graticuleColor: this.radar?.graticuleColor || "#DEDEDE",
			graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
			graticuleOpacity: this.radar?.graticuleOpacity || .3,
			legendBoxSize: this.radar?.legendBoxSize || 12,
			legendFontSize: this.radar?.legendFontSize || 12
		}, this.requirementBackground = this.requirementBackground || this.primaryColor, this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor, this.requirementBorderSize = this.requirementBorderSize || "1", this.requirementTextColor = this.requirementTextColor || this.primaryTextColor, this.relationColor = this.relationColor || this.lineColor, this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground, this.relationLabelColor = this.relationLabelColor || this.actorTextColor, this.git0 = N3(this.pie1, 25) || this.primaryColor, this.git1 = this.pie2 || this.secondaryColor, this.git2 = this.pie3 || this.tertiaryColor, this.git3 = this.pie4 || N6(this.primaryColor, { h: -30 }), this.git4 = this.pie5 || N6(this.primaryColor, { h: -60 }), this.git5 = this.pie6 || N6(this.primaryColor, { h: -90 }), this.git6 = this.pie7 || N6(this.primaryColor, { h: 60 }), this.git7 = this.pie8 || N6(this.primaryColor, { h: 120 }), this.gitInv0 = this.gitInv0 || N8(this.git0), this.gitInv1 = this.gitInv1 || N8(this.git1), this.gitInv2 = this.gitInv2 || N8(this.git2), this.gitInv3 = this.gitInv3 || N8(this.git3), this.gitInv4 = this.gitInv4 || N8(this.git4), this.gitInv5 = this.gitInv5 || N8(this.git5), this.gitInv6 = this.gitInv6 || N8(this.git6), this.gitInv7 = this.gitInv7 || N8(this.git7), this.branchLabelColor = this.branchLabelColor || this.labelTextColor, this.gitBranchLabel0 = this.branchLabelColor, this.gitBranchLabel1 = "white", this.gitBranchLabel2 = this.branchLabelColor, this.gitBranchLabel3 = "white", this.gitBranchLabel4 = this.branchLabelColor, this.gitBranchLabel5 = this.branchLabelColor, this.gitBranchLabel6 = this.branchLabelColor, this.gitBranchLabel7 = this.branchLabelColor, this.tagLabelColor = this.tagLabelColor || this.primaryTextColor, this.tagLabelBackground = this.tagLabelBackground || this.primaryColor, this.tagLabelBorder = this.tagBorder || this.primaryBorderColor, this.tagLabelFontSize = this.tagLabelFontSize || "10px", this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor, this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor, this.commitLabelFontSize = this.commitLabelFontSize || "10px", this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || N9, this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || Ie;
	}
	calculate(e) {
		if ("object" != typeof e) return void this.updateColors();
		let t = Object.keys(e);
		t.forEach((t) => {
			this[t] = e[t];
		}), this.updateColors(), t.forEach((t) => {
			this[t] = e[t];
		});
	}
}, Iu = {
	base: { getThemeVariables: Ii },
	dark: { getThemeVariables: Ia },
	default: { getThemeVariables: Io },
	forest: { getThemeVariables: Ic },
	neutral: { getThemeVariables: h((e) => {
		let t = new Ih();
		return t.calculate(e), t;
	}, "getThemeVariables") }
}, Id = {
	flowchart: {
		useMaxWidth: !0,
		titleTopMargin: 25,
		subGraphTitleMargin: {
			top: 0,
			bottom: 0
		},
		diagramPadding: 8,
		htmlLabels: !0,
		nodeSpacing: 50,
		rankSpacing: 50,
		curve: "basis",
		padding: 15,
		defaultRenderer: "dagre-wrapper",
		wrappingWidth: 200,
		inheritDir: !1
	},
	sequence: {
		useMaxWidth: !0,
		hideUnusedParticipants: !1,
		activationWidth: 10,
		diagramMarginX: 50,
		diagramMarginY: 10,
		actorMargin: 50,
		width: 150,
		height: 65,
		boxMargin: 10,
		boxTextMargin: 5,
		noteMargin: 10,
		messageMargin: 35,
		messageAlign: "center",
		mirrorActors: !0,
		forceMenus: !1,
		bottomMarginAdj: 1,
		rightAngles: !1,
		showSequenceNumbers: !1,
		actorFontSize: 14,
		actorFontFamily: "\"Open Sans\", sans-serif",
		actorFontWeight: 400,
		noteFontSize: 14,
		noteFontFamily: "\"trebuchet ms\", verdana, arial, sans-serif",
		noteFontWeight: 400,
		noteAlign: "center",
		messageFontSize: 16,
		messageFontFamily: "\"trebuchet ms\", verdana, arial, sans-serif",
		messageFontWeight: 400,
		wrap: !1,
		wrapPadding: 10,
		labelBoxWidth: 50,
		labelBoxHeight: 20
	},
	gantt: {
		useMaxWidth: !0,
		titleTopMargin: 25,
		barHeight: 20,
		barGap: 4,
		topPadding: 50,
		rightPadding: 75,
		leftPadding: 75,
		gridLineStartPadding: 35,
		fontSize: 11,
		sectionFontSize: 11,
		numberSectionStyles: 4,
		axisFormat: "%Y-%m-%d",
		topAxis: !1,
		displayMode: "",
		weekday: "sunday"
	},
	journey: {
		useMaxWidth: !0,
		diagramMarginX: 50,
		diagramMarginY: 10,
		leftMargin: 150,
		maxLabelWidth: 360,
		width: 150,
		height: 50,
		boxMargin: 10,
		boxTextMargin: 5,
		noteMargin: 10,
		messageMargin: 35,
		messageAlign: "center",
		bottomMarginAdj: 1,
		rightAngles: !1,
		taskFontSize: 14,
		taskFontFamily: "\"Open Sans\", sans-serif",
		taskMargin: 50,
		activationWidth: 10,
		textPlacement: "fo",
		actorColours: [
			"#8FBC8F",
			"#7CFC00",
			"#00FFFF",
			"#20B2AA",
			"#B0E0E6",
			"#FFFFE0"
		],
		sectionFills: [
			"#191970",
			"#8B008B",
			"#4B0082",
			"#2F4F4F",
			"#800000",
			"#8B4513",
			"#00008B"
		],
		sectionColours: ["#fff"],
		titleColor: "",
		titleFontFamily: "\"trebuchet ms\", verdana, arial, sans-serif",
		titleFontSize: "4ex"
	},
	class: {
		useMaxWidth: !0,
		titleTopMargin: 25,
		arrowMarkerAbsolute: !1,
		dividerMargin: 10,
		padding: 5,
		textHeight: 10,
		defaultRenderer: "dagre-wrapper",
		htmlLabels: !1,
		hideEmptyMembersBox: !1
	},
	state: {
		useMaxWidth: !0,
		titleTopMargin: 25,
		dividerMargin: 10,
		sizeUnit: 5,
		padding: 8,
		textHeight: 10,
		titleShift: -15,
		noteMargin: 10,
		forkWidth: 70,
		forkHeight: 7,
		miniPadding: 2,
		fontSizeFactor: 5.02,
		fontSize: 24,
		labelHeight: 16,
		edgeLengthFactor: "20",
		compositTitleSize: 35,
		radius: 5,
		defaultRenderer: "dagre-wrapper"
	},
	er: {
		useMaxWidth: !0,
		titleTopMargin: 25,
		diagramPadding: 20,
		layoutDirection: "TB",
		minEntityWidth: 100,
		minEntityHeight: 75,
		entityPadding: 15,
		nodeSpacing: 140,
		rankSpacing: 80,
		stroke: "gray",
		fill: "honeydew",
		fontSize: 12
	},
	pie: {
		useMaxWidth: !0,
		textPosition: .75
	},
	quadrantChart: {
		useMaxWidth: !0,
		chartWidth: 500,
		chartHeight: 500,
		titleFontSize: 20,
		titlePadding: 10,
		quadrantPadding: 5,
		xAxisLabelPadding: 5,
		yAxisLabelPadding: 5,
		xAxisLabelFontSize: 16,
		yAxisLabelFontSize: 16,
		quadrantLabelFontSize: 16,
		quadrantTextTopPadding: 5,
		pointTextPadding: 5,
		pointLabelFontSize: 12,
		pointRadius: 5,
		xAxisPosition: "top",
		yAxisPosition: "left",
		quadrantInternalBorderStrokeWidth: 1,
		quadrantExternalBorderStrokeWidth: 2
	},
	xyChart: {
		useMaxWidth: !0,
		width: 700,
		height: 500,
		titleFontSize: 20,
		titlePadding: 10,
		showDataLabel: !1,
		showTitle: !0,
		xAxis: {
			$ref: "#/$defs/XYChartAxisConfig",
			showLabel: !0,
			labelFontSize: 14,
			labelPadding: 5,
			showTitle: !0,
			titleFontSize: 16,
			titlePadding: 5,
			showTick: !0,
			tickLength: 5,
			tickWidth: 2,
			showAxisLine: !0,
			axisLineWidth: 2
		},
		yAxis: {
			$ref: "#/$defs/XYChartAxisConfig",
			showLabel: !0,
			labelFontSize: 14,
			labelPadding: 5,
			showTitle: !0,
			titleFontSize: 16,
			titlePadding: 5,
			showTick: !0,
			tickLength: 5,
			tickWidth: 2,
			showAxisLine: !0,
			axisLineWidth: 2
		},
		chartOrientation: "vertical",
		plotReservedSpacePercent: 50
	},
	requirement: {
		useMaxWidth: !0,
		rect_fill: "#f9f9f9",
		text_color: "#333",
		rect_border_size: "0.5px",
		rect_border_color: "#bbb",
		rect_min_width: 200,
		rect_min_height: 200,
		fontSize: 14,
		rect_padding: 10,
		line_height: 20
	},
	mindmap: {
		useMaxWidth: !0,
		padding: 10,
		maxNodeWidth: 200,
		layoutAlgorithm: "cose-bilkent"
	},
	kanban: {
		useMaxWidth: !0,
		padding: 8,
		sectionWidth: 200,
		ticketBaseUrl: ""
	},
	timeline: {
		useMaxWidth: !0,
		diagramMarginX: 50,
		diagramMarginY: 10,
		leftMargin: 150,
		width: 150,
		height: 50,
		boxMargin: 10,
		boxTextMargin: 5,
		noteMargin: 10,
		messageMargin: 35,
		messageAlign: "center",
		bottomMarginAdj: 1,
		rightAngles: !1,
		taskFontSize: 14,
		taskFontFamily: "\"Open Sans\", sans-serif",
		taskMargin: 50,
		activationWidth: 10,
		textPlacement: "fo",
		actorColours: [
			"#8FBC8F",
			"#7CFC00",
			"#00FFFF",
			"#20B2AA",
			"#B0E0E6",
			"#FFFFE0"
		],
		sectionFills: [
			"#191970",
			"#8B008B",
			"#4B0082",
			"#2F4F4F",
			"#800000",
			"#8B4513",
			"#00008B"
		],
		sectionColours: ["#fff"],
		disableMulticolor: !1
	},
	gitGraph: {
		useMaxWidth: !0,
		titleTopMargin: 25,
		diagramPadding: 8,
		nodeLabel: {
			width: 75,
			height: 100,
			x: -25,
			y: 0
		},
		mainBranchName: "main",
		mainBranchOrder: 0,
		showCommitLabel: !0,
		showBranches: !0,
		rotateCommitLabel: !0,
		parallelCommits: !1,
		arrowMarkerAbsolute: !1
	},
	c4: {
		useMaxWidth: !0,
		diagramMarginX: 50,
		diagramMarginY: 10,
		c4ShapeMargin: 50,
		c4ShapePadding: 20,
		width: 216,
		height: 60,
		boxMargin: 10,
		c4ShapeInRow: 4,
		nextLinePaddingX: 0,
		c4BoundaryInRow: 2,
		personFontSize: 14,
		personFontFamily: "\"Open Sans\", sans-serif",
		personFontWeight: "normal",
		external_personFontSize: 14,
		external_personFontFamily: "\"Open Sans\", sans-serif",
		external_personFontWeight: "normal",
		systemFontSize: 14,
		systemFontFamily: "\"Open Sans\", sans-serif",
		systemFontWeight: "normal",
		external_systemFontSize: 14,
		external_systemFontFamily: "\"Open Sans\", sans-serif",
		external_systemFontWeight: "normal",
		system_dbFontSize: 14,
		system_dbFontFamily: "\"Open Sans\", sans-serif",
		system_dbFontWeight: "normal",
		external_system_dbFontSize: 14,
		external_system_dbFontFamily: "\"Open Sans\", sans-serif",
		external_system_dbFontWeight: "normal",
		system_queueFontSize: 14,
		system_queueFontFamily: "\"Open Sans\", sans-serif",
		system_queueFontWeight: "normal",
		external_system_queueFontSize: 14,
		external_system_queueFontFamily: "\"Open Sans\", sans-serif",
		external_system_queueFontWeight: "normal",
		boundaryFontSize: 14,
		boundaryFontFamily: "\"Open Sans\", sans-serif",
		boundaryFontWeight: "normal",
		messageFontSize: 12,
		messageFontFamily: "\"Open Sans\", sans-serif",
		messageFontWeight: "normal",
		containerFontSize: 14,
		containerFontFamily: "\"Open Sans\", sans-serif",
		containerFontWeight: "normal",
		external_containerFontSize: 14,
		external_containerFontFamily: "\"Open Sans\", sans-serif",
		external_containerFontWeight: "normal",
		container_dbFontSize: 14,
		container_dbFontFamily: "\"Open Sans\", sans-serif",
		container_dbFontWeight: "normal",
		external_container_dbFontSize: 14,
		external_container_dbFontFamily: "\"Open Sans\", sans-serif",
		external_container_dbFontWeight: "normal",
		container_queueFontSize: 14,
		container_queueFontFamily: "\"Open Sans\", sans-serif",
		container_queueFontWeight: "normal",
		external_container_queueFontSize: 14,
		external_container_queueFontFamily: "\"Open Sans\", sans-serif",
		external_container_queueFontWeight: "normal",
		componentFontSize: 14,
		componentFontFamily: "\"Open Sans\", sans-serif",
		componentFontWeight: "normal",
		external_componentFontSize: 14,
		external_componentFontFamily: "\"Open Sans\", sans-serif",
		external_componentFontWeight: "normal",
		component_dbFontSize: 14,
		component_dbFontFamily: "\"Open Sans\", sans-serif",
		component_dbFontWeight: "normal",
		external_component_dbFontSize: 14,
		external_component_dbFontFamily: "\"Open Sans\", sans-serif",
		external_component_dbFontWeight: "normal",
		component_queueFontSize: 14,
		component_queueFontFamily: "\"Open Sans\", sans-serif",
		component_queueFontWeight: "normal",
		external_component_queueFontSize: 14,
		external_component_queueFontFamily: "\"Open Sans\", sans-serif",
		external_component_queueFontWeight: "normal",
		wrap: !0,
		wrapPadding: 10,
		person_bg_color: "#08427B",
		person_border_color: "#073B6F",
		external_person_bg_color: "#686868",
		external_person_border_color: "#8A8A8A",
		system_bg_color: "#1168BD",
		system_border_color: "#3C7FC0",
		system_db_bg_color: "#1168BD",
		system_db_border_color: "#3C7FC0",
		system_queue_bg_color: "#1168BD",
		system_queue_border_color: "#3C7FC0",
		external_system_bg_color: "#999999",
		external_system_border_color: "#8A8A8A",
		external_system_db_bg_color: "#999999",
		external_system_db_border_color: "#8A8A8A",
		external_system_queue_bg_color: "#999999",
		external_system_queue_border_color: "#8A8A8A",
		container_bg_color: "#438DD5",
		container_border_color: "#3C7FC0",
		container_db_bg_color: "#438DD5",
		container_db_border_color: "#3C7FC0",
		container_queue_bg_color: "#438DD5",
		container_queue_border_color: "#3C7FC0",
		external_container_bg_color: "#B3B3B3",
		external_container_border_color: "#A6A6A6",
		external_container_db_bg_color: "#B3B3B3",
		external_container_db_border_color: "#A6A6A6",
		external_container_queue_bg_color: "#B3B3B3",
		external_container_queue_border_color: "#A6A6A6",
		component_bg_color: "#85BBF0",
		component_border_color: "#78A8D8",
		component_db_bg_color: "#85BBF0",
		component_db_border_color: "#78A8D8",
		component_queue_bg_color: "#85BBF0",
		component_queue_border_color: "#78A8D8",
		external_component_bg_color: "#CCCCCC",
		external_component_border_color: "#BFBFBF",
		external_component_db_bg_color: "#CCCCCC",
		external_component_db_border_color: "#BFBFBF",
		external_component_queue_bg_color: "#CCCCCC",
		external_component_queue_border_color: "#BFBFBF"
	},
	sankey: {
		useMaxWidth: !0,
		width: 600,
		height: 400,
		linkColor: "gradient",
		nodeAlignment: "justify",
		showValues: !0,
		prefix: "",
		suffix: ""
	},
	block: {
		useMaxWidth: !0,
		padding: 8
	},
	packet: {
		useMaxWidth: !0,
		rowHeight: 32,
		bitWidth: 32,
		bitsPerRow: 32,
		showBits: !0,
		paddingX: 5,
		paddingY: 5
	},
	architecture: {
		useMaxWidth: !0,
		padding: 40,
		iconSize: 80,
		fontSize: 16
	},
	radar: {
		useMaxWidth: !0,
		width: 600,
		height: 600,
		marginTop: 50,
		marginRight: 50,
		marginBottom: 50,
		marginLeft: 50,
		axisScaleFactor: 1,
		axisLabelFactor: 1.05,
		curveTension: .17
	},
	theme: "default",
	look: "classic",
	handDrawnSeed: 0,
	layout: "dagre",
	maxTextSize: 5e4,
	maxEdges: 500,
	darkMode: !1,
	fontFamily: "\"trebuchet ms\", verdana, arial, sans-serif;",
	logLevel: 5,
	securityLevel: "strict",
	startOnLoad: !0,
	arrowMarkerAbsolute: !1,
	secure: [
		"secure",
		"securityLevel",
		"startOnLoad",
		"maxTextSize",
		"suppressErrorRendering",
		"maxEdges"
	],
	legacyMathML: !1,
	forceLegacyMathML: !1,
	deterministicIds: !1,
	fontSize: 16,
	markdownAutoWrap: !0,
	suppressErrorRendering: !1
}, Ip = {
	...Id,
	deterministicIDSeed: void 0,
	elk: {
		mergeEdges: !1,
		nodePlacementStrategy: "BRANDES_KOEPF",
		forceNodeModelOrder: !1,
		considerModelOrder: "NODES_AND_EDGES"
	},
	themeCSS: void 0,
	themeVariables: Iu.default.getThemeVariables(),
	sequence: {
		...Id.sequence,
		messageFont: h(function() {
			return {
				fontFamily: this.messageFontFamily,
				fontSize: this.messageFontSize,
				fontWeight: this.messageFontWeight
			};
		}, "messageFont"),
		noteFont: h(function() {
			return {
				fontFamily: this.noteFontFamily,
				fontSize: this.noteFontSize,
				fontWeight: this.noteFontWeight
			};
		}, "noteFont"),
		actorFont: h(function() {
			return {
				fontFamily: this.actorFontFamily,
				fontSize: this.actorFontSize,
				fontWeight: this.actorFontWeight
			};
		}, "actorFont")
	},
	class: { hideEmptyMembersBox: !1 },
	gantt: {
		...Id.gantt,
		tickInterval: void 0,
		useWidth: void 0
	},
	c4: {
		...Id.c4,
		useWidth: void 0,
		personFont: h(function() {
			return {
				fontFamily: this.personFontFamily,
				fontSize: this.personFontSize,
				fontWeight: this.personFontWeight
			};
		}, "personFont"),
		flowchart: {
			...Id.flowchart,
			inheritDir: !1
		},
		external_personFont: h(function() {
			return {
				fontFamily: this.external_personFontFamily,
				fontSize: this.external_personFontSize,
				fontWeight: this.external_personFontWeight
			};
		}, "external_personFont"),
		systemFont: h(function() {
			return {
				fontFamily: this.systemFontFamily,
				fontSize: this.systemFontSize,
				fontWeight: this.systemFontWeight
			};
		}, "systemFont"),
		external_systemFont: h(function() {
			return {
				fontFamily: this.external_systemFontFamily,
				fontSize: this.external_systemFontSize,
				fontWeight: this.external_systemFontWeight
			};
		}, "external_systemFont"),
		system_dbFont: h(function() {
			return {
				fontFamily: this.system_dbFontFamily,
				fontSize: this.system_dbFontSize,
				fontWeight: this.system_dbFontWeight
			};
		}, "system_dbFont"),
		external_system_dbFont: h(function() {
			return {
				fontFamily: this.external_system_dbFontFamily,
				fontSize: this.external_system_dbFontSize,
				fontWeight: this.external_system_dbFontWeight
			};
		}, "external_system_dbFont"),
		system_queueFont: h(function() {
			return {
				fontFamily: this.system_queueFontFamily,
				fontSize: this.system_queueFontSize,
				fontWeight: this.system_queueFontWeight
			};
		}, "system_queueFont"),
		external_system_queueFont: h(function() {
			return {
				fontFamily: this.external_system_queueFontFamily,
				fontSize: this.external_system_queueFontSize,
				fontWeight: this.external_system_queueFontWeight
			};
		}, "external_system_queueFont"),
		containerFont: h(function() {
			return {
				fontFamily: this.containerFontFamily,
				fontSize: this.containerFontSize,
				fontWeight: this.containerFontWeight
			};
		}, "containerFont"),
		external_containerFont: h(function() {
			return {
				fontFamily: this.external_containerFontFamily,
				fontSize: this.external_containerFontSize,
				fontWeight: this.external_containerFontWeight
			};
		}, "external_containerFont"),
		container_dbFont: h(function() {
			return {
				fontFamily: this.container_dbFontFamily,
				fontSize: this.container_dbFontSize,
				fontWeight: this.container_dbFontWeight
			};
		}, "container_dbFont"),
		external_container_dbFont: h(function() {
			return {
				fontFamily: this.external_container_dbFontFamily,
				fontSize: this.external_container_dbFontSize,
				fontWeight: this.external_container_dbFontWeight
			};
		}, "external_container_dbFont"),
		container_queueFont: h(function() {
			return {
				fontFamily: this.container_queueFontFamily,
				fontSize: this.container_queueFontSize,
				fontWeight: this.container_queueFontWeight
			};
		}, "container_queueFont"),
		external_container_queueFont: h(function() {
			return {
				fontFamily: this.external_container_queueFontFamily,
				fontSize: this.external_container_queueFontSize,
				fontWeight: this.external_container_queueFontWeight
			};
		}, "external_container_queueFont"),
		componentFont: h(function() {
			return {
				fontFamily: this.componentFontFamily,
				fontSize: this.componentFontSize,
				fontWeight: this.componentFontWeight
			};
		}, "componentFont"),
		external_componentFont: h(function() {
			return {
				fontFamily: this.external_componentFontFamily,
				fontSize: this.external_componentFontSize,
				fontWeight: this.external_componentFontWeight
			};
		}, "external_componentFont"),
		component_dbFont: h(function() {
			return {
				fontFamily: this.component_dbFontFamily,
				fontSize: this.component_dbFontSize,
				fontWeight: this.component_dbFontWeight
			};
		}, "component_dbFont"),
		external_component_dbFont: h(function() {
			return {
				fontFamily: this.external_component_dbFontFamily,
				fontSize: this.external_component_dbFontSize,
				fontWeight: this.external_component_dbFontWeight
			};
		}, "external_component_dbFont"),
		component_queueFont: h(function() {
			return {
				fontFamily: this.component_queueFontFamily,
				fontSize: this.component_queueFontSize,
				fontWeight: this.component_queueFontWeight
			};
		}, "component_queueFont"),
		external_component_queueFont: h(function() {
			return {
				fontFamily: this.external_component_queueFontFamily,
				fontSize: this.external_component_queueFontSize,
				fontWeight: this.external_component_queueFontWeight
			};
		}, "external_component_queueFont"),
		boundaryFont: h(function() {
			return {
				fontFamily: this.boundaryFontFamily,
				fontSize: this.boundaryFontSize,
				fontWeight: this.boundaryFontWeight
			};
		}, "boundaryFont"),
		messageFont: h(function() {
			return {
				fontFamily: this.messageFontFamily,
				fontSize: this.messageFontSize,
				fontWeight: this.messageFontWeight
			};
		}, "messageFont")
	},
	pie: {
		...Id.pie,
		useWidth: 984
	},
	xyChart: {
		...Id.xyChart,
		useWidth: void 0
	},
	requirement: {
		...Id.requirement,
		useWidth: void 0
	},
	packet: { ...Id.packet },
	radar: { ...Id.radar },
	treemap: {
		useMaxWidth: !0,
		padding: 10,
		diagramPadding: 8,
		showValues: !0,
		nodeWidth: 100,
		nodeHeight: 40,
		borderWidth: 1,
		valueFontSize: 12,
		labelFontSize: 14,
		valueFormat: ","
	}
}, If = h((e, t = "") => Object.keys(e).reduce((r, i) => Array.isArray(e[i]) ? r : "object" == typeof e[i] && null !== e[i] ? [
	...r,
	t + i,
	...If(e[i], "")
] : [...r, t + i], []), "keyify"), Ig = new Set(If(Ip, "")), Im = h((e) => {
	if (wQ.debug("sanitizeDirective called with", e), "object" == typeof e && null != e) {
		if (Array.isArray(e)) return void e.forEach((e) => Im(e));
		for (let t of Object.keys(e)) {
			if (wQ.debug("Checking key", t), t.startsWith("__") || t.includes("proto") || t.includes("constr") || !Ig.has(t) || null == e[t]) {
				wQ.debug("sanitize deleting key: ", t), delete e[t];
				continue;
			}
			if ("object" == typeof e[t]) {
				wQ.debug("sanitizing object", t), Im(e[t]);
				continue;
			}
			for (let r of [
				"themeCSS",
				"fontFamily",
				"altFontFamily"
			]) t.includes(r) && (wQ.debug("sanitizing css option", t), e[t] = Iy(e[t]));
		}
		if (e.themeVariables) for (let t of Object.keys(e.themeVariables)) {
			let r = e.themeVariables[t];
			r?.match && !r.match(/^[\d "#%(),.;A-Za-z]+$/) && (e.themeVariables[t] = "");
		}
		wQ.debug("After sanitization", e);
	}
}, "sanitizeDirective"), Iy = h((e) => {
	let t = 0, r = 0;
	for (let i of e) {
		if (t < r) return "{ /* ERROR: Unbalanced CSS */ }";
		"{" === i ? t++ : "}" === i && r++;
	}
	return t !== r ? "{ /* ERROR: Unbalanced CSS */ }" : e;
}, "sanitizeCss"), Iv = Object.freeze(Ip), Ix = NF({}, Iv), Ib = [], Iw = NF({}, Iv), Ik = h((e, t) => {
	let r = NF({}, e), i = {};
	for (let e of t) IL(e), i = NF(i, e);
	if (r = NF(r, i), i.theme && i.theme in Iu) {
		let e = NF(NF({}, Nq).themeVariables || {}, i.themeVariables);
		r.theme && r.theme in Iu && (r.themeVariables = Iu[r.theme].getThemeVariables(e));
	}
	return IO(Iw = r), Iw;
}, "updateCurrentConfig"), IT = h((e) => (Ix = NF({}, Iv), Ix = NF(Ix, e), e.theme && Iu[e.theme] && (Ix.themeVariables = Iu[e.theme].getThemeVariables(e.themeVariables)), Ik(Ix, Ib), Ix), "setSiteConfig"), I_ = h((e) => {
	Nq = NF({}, e);
}, "saveConfigFromInitialize"), IE = h((e) => (Ix = NF(Ix, e), Ik(Ix, Ib), Ix), "updateSiteConfig"), IC = h(() => NF({}, Ix), "getSiteConfig"), IS = h((e) => (IO(e), NF(Iw, e), IA()), "setConfig"), IA = h(() => NF({}, Iw), "getConfig"), IL = h((e) => {
	e && (["secure", ...Ix.secure ?? []].forEach((t) => {
		Object.hasOwn(e, t) && (wQ.debug(`Denied attempt to modify a secure key ${t}`, e[t]), delete e[t]);
	}), Object.keys(e).forEach((t) => {
		t.startsWith("__") && delete e[t];
	}), Object.keys(e).forEach((t) => {
		"string" == typeof e[t] && (e[t].includes("<") || e[t].includes(">") || e[t].includes("url(data:")) && delete e[t], "object" == typeof e[t] && IL(e[t]);
	}));
}, "sanitize"), IR = h((e) => {
	Im(e), e.fontFamily && !e.themeVariables?.fontFamily && (e.themeVariables = {
		...e.themeVariables,
		fontFamily: e.fontFamily
	}), Ib.push(e), Ik(Ix, Ib);
}, "addDirective"), IN = h((e = Ix) => {
	Ik(e, Ib = []);
}, "reset"), II = { LAZY_LOAD_DEPRECATED: "The configuration options lazyLoadedDiagrams and loadExternalDiagramsAtStartup are deprecated. Please use registerExternalDiagrams instead." }, IM = {}, ID = h((e) => {
	IM[e] || (wQ.warn(II[e]), IM[e] = !0);
}, "issueWarning"), IO = h((e) => {
	e && (e.lazyLoadedDiagrams || e.loadExternalDiagramsAtStartup) && ID("LAZY_LOAD_DEPRECATED");
}, "checkConfig"), I$ = h(() => {
	let e = {};
	for (let t of (Nq && (e = NF(e, Nq)), Ib)) e = NF(e, t);
	return e;
}, "getUserDefinedConfig"), { entries: IP, setPrototypeOf: IB, isFrozen: IF, getPrototypeOf: Iz, getOwnPropertyDescriptor: IU } = Object, { freeze: IG, seal: Iq, create: Ij } = Object, { apply: IW, construct: IY } = "u" > typeof Reflect && Reflect;
IG || (IG = h(function(e) {
	return e;
}, "freeze")), Iq || (Iq = h(function(e) {
	return e;
}, "seal")), IW || (IW = h(function(e, t, r) {
	return e.apply(t, r);
}, "apply")), IY || (IY = h(function(e, t) {
	return new e(...t);
}, "construct"));
var IV = I7(Array.prototype.forEach), IH = I7(Array.prototype.lastIndexOf), IX = I7(Array.prototype.pop), IK = I7(Array.prototype.push), IZ = I7(Array.prototype.splice), IQ = I7(String.prototype.toLowerCase), IJ = I7(String.prototype.toString), I0 = I7(String.prototype.match), I1 = I7(String.prototype.replace), I2 = I7(String.prototype.indexOf), I4 = I7(String.prototype.trim), I5 = I7(Object.prototype.hasOwnProperty), I3 = I7(RegExp.prototype.test), I6 = I8(TypeError);
function I7(e) {
	return function(t) {
		t instanceof RegExp && (t.lastIndex = 0);
		for (var r = arguments.length, i = Array(r > 1 ? r - 1 : 0), n = 1; n < r; n++) i[n - 1] = arguments[n];
		return IW(e, t, i);
	};
}
function I8(e) {
	return function() {
		for (var t = arguments.length, r = Array(t), i = 0; i < t; i++) r[i] = arguments[i];
		return IY(e, r);
	};
}
function I9(e, t) {
	let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : IQ;
	IB && IB(e, null);
	let i = t.length;
	for (; i--;) {
		let n = t[i];
		if ("string" == typeof n) {
			let e = r(n);
			e !== n && (IF(t) || (t[i] = e), n = e);
		}
		e[n] = !0;
	}
	return e;
}
function Me(e) {
	for (let t = 0; t < e.length; t++) I5(e, t) || (e[t] = null);
	return e;
}
function Mt(e) {
	let t = Ij(null);
	for (let [r, i] of IP(e)) I5(e, r) && (Array.isArray(i) ? t[r] = Me(i) : i && "object" == typeof i && i.constructor === Object ? t[r] = Mt(i) : t[r] = i);
	return t;
}
function Mr(e, t) {
	for (; null !== e;) {
		let r = IU(e, t);
		if (r) {
			if (r.get) return I7(r.get);
			if ("function" == typeof r.value) return I7(r.value);
		}
		e = Iz(e);
	}
	function r() {
		return null;
	}
	return h(r, "fallbackValue"), r;
}
h(I7, "unapply"), h(I8, "unconstruct"), h(I9, "addToSet"), h(Me, "cleanArray"), h(Mt, "clone"), h(Mr, "lookupGetter");
var Mi = IG([
	"a",
	"abbr",
	"acronym",
	"address",
	"area",
	"article",
	"aside",
	"audio",
	"b",
	"bdi",
	"bdo",
	"big",
	"blink",
	"blockquote",
	"body",
	"br",
	"button",
	"canvas",
	"caption",
	"center",
	"cite",
	"code",
	"col",
	"colgroup",
	"content",
	"data",
	"datalist",
	"dd",
	"decorator",
	"del",
	"details",
	"dfn",
	"dialog",
	"dir",
	"div",
	"dl",
	"dt",
	"element",
	"em",
	"fieldset",
	"figcaption",
	"figure",
	"font",
	"footer",
	"form",
	"h1",
	"h2",
	"h3",
	"h4",
	"h5",
	"h6",
	"head",
	"header",
	"hgroup",
	"hr",
	"html",
	"i",
	"img",
	"input",
	"ins",
	"kbd",
	"label",
	"legend",
	"li",
	"main",
	"map",
	"mark",
	"marquee",
	"menu",
	"menuitem",
	"meter",
	"nav",
	"nobr",
	"ol",
	"optgroup",
	"option",
	"output",
	"p",
	"picture",
	"pre",
	"progress",
	"q",
	"rp",
	"rt",
	"ruby",
	"s",
	"samp",
	"section",
	"select",
	"shadow",
	"small",
	"source",
	"spacer",
	"span",
	"strike",
	"strong",
	"style",
	"sub",
	"summary",
	"sup",
	"table",
	"tbody",
	"td",
	"template",
	"textarea",
	"tfoot",
	"th",
	"thead",
	"time",
	"tr",
	"track",
	"tt",
	"u",
	"ul",
	"var",
	"video",
	"wbr"
]), Mn = IG([
	"svg",
	"a",
	"altglyph",
	"altglyphdef",
	"altglyphitem",
	"animatecolor",
	"animatemotion",
	"animatetransform",
	"circle",
	"clippath",
	"defs",
	"desc",
	"ellipse",
	"filter",
	"font",
	"g",
	"glyph",
	"glyphref",
	"hkern",
	"image",
	"line",
	"lineargradient",
	"marker",
	"mask",
	"metadata",
	"mpath",
	"path",
	"pattern",
	"polygon",
	"polyline",
	"radialgradient",
	"rect",
	"stop",
	"style",
	"switch",
	"symbol",
	"text",
	"textpath",
	"title",
	"tref",
	"tspan",
	"view",
	"vkern"
]), Ma = IG([
	"feBlend",
	"feColorMatrix",
	"feComponentTransfer",
	"feComposite",
	"feConvolveMatrix",
	"feDiffuseLighting",
	"feDisplacementMap",
	"feDistantLight",
	"feDropShadow",
	"feFlood",
	"feFuncA",
	"feFuncB",
	"feFuncG",
	"feFuncR",
	"feGaussianBlur",
	"feImage",
	"feMerge",
	"feMergeNode",
	"feMorphology",
	"feOffset",
	"fePointLight",
	"feSpecularLighting",
	"feSpotLight",
	"feTile",
	"feTurbulence"
]), Ms = IG([
	"animate",
	"color-profile",
	"cursor",
	"discard",
	"font-face",
	"font-face-format",
	"font-face-name",
	"font-face-src",
	"font-face-uri",
	"foreignobject",
	"hatch",
	"hatchpath",
	"mesh",
	"meshgradient",
	"meshpatch",
	"meshrow",
	"missing-glyph",
	"script",
	"set",
	"solidcolor",
	"unknown",
	"use"
]), Mo = IG([
	"math",
	"menclose",
	"merror",
	"mfenced",
	"mfrac",
	"mglyph",
	"mi",
	"mlabeledtr",
	"mmultiscripts",
	"mn",
	"mo",
	"mover",
	"mpadded",
	"mphantom",
	"mroot",
	"mrow",
	"ms",
	"mspace",
	"msqrt",
	"mstyle",
	"msub",
	"msup",
	"msubsup",
	"mtable",
	"mtd",
	"mtext",
	"mtr",
	"munder",
	"munderover",
	"mprescripts"
]), Ml = IG([
	"maction",
	"maligngroup",
	"malignmark",
	"mlongdiv",
	"mscarries",
	"mscarry",
	"msgroup",
	"mstack",
	"msline",
	"msrow",
	"semantics",
	"annotation",
	"annotation-xml",
	"mprescripts",
	"none"
]), Mc = IG(["#text"]), Mh = IG([
	"accept",
	"action",
	"align",
	"alt",
	"autocapitalize",
	"autocomplete",
	"autopictureinpicture",
	"autoplay",
	"background",
	"bgcolor",
	"border",
	"capture",
	"cellpadding",
	"cellspacing",
	"checked",
	"cite",
	"class",
	"clear",
	"color",
	"cols",
	"colspan",
	"controls",
	"controlslist",
	"coords",
	"crossorigin",
	"datetime",
	"decoding",
	"default",
	"dir",
	"disabled",
	"disablepictureinpicture",
	"disableremoteplayback",
	"download",
	"draggable",
	"enctype",
	"enterkeyhint",
	"face",
	"for",
	"headers",
	"height",
	"hidden",
	"high",
	"href",
	"hreflang",
	"id",
	"inputmode",
	"integrity",
	"ismap",
	"kind",
	"label",
	"lang",
	"list",
	"loading",
	"loop",
	"low",
	"max",
	"maxlength",
	"media",
	"method",
	"min",
	"minlength",
	"multiple",
	"muted",
	"name",
	"nonce",
	"noshade",
	"novalidate",
	"nowrap",
	"open",
	"optimum",
	"pattern",
	"placeholder",
	"playsinline",
	"popover",
	"popovertarget",
	"popovertargetaction",
	"poster",
	"preload",
	"pubdate",
	"radiogroup",
	"readonly",
	"rel",
	"required",
	"rev",
	"reversed",
	"role",
	"rows",
	"rowspan",
	"spellcheck",
	"scope",
	"selected",
	"shape",
	"size",
	"sizes",
	"span",
	"srclang",
	"start",
	"src",
	"srcset",
	"step",
	"style",
	"summary",
	"tabindex",
	"title",
	"translate",
	"type",
	"usemap",
	"valign",
	"value",
	"width",
	"wrap",
	"xmlns",
	"slot"
]), Mu = IG([
	"accent-height",
	"accumulate",
	"additive",
	"alignment-baseline",
	"amplitude",
	"ascent",
	"attributename",
	"attributetype",
	"azimuth",
	"basefrequency",
	"baseline-shift",
	"begin",
	"bias",
	"by",
	"class",
	"clip",
	"clippathunits",
	"clip-path",
	"clip-rule",
	"color",
	"color-interpolation",
	"color-interpolation-filters",
	"color-profile",
	"color-rendering",
	"cx",
	"cy",
	"d",
	"dx",
	"dy",
	"diffuseconstant",
	"direction",
	"display",
	"divisor",
	"dur",
	"edgemode",
	"elevation",
	"end",
	"exponent",
	"fill",
	"fill-opacity",
	"fill-rule",
	"filter",
	"filterunits",
	"flood-color",
	"flood-opacity",
	"font-family",
	"font-size",
	"font-size-adjust",
	"font-stretch",
	"font-style",
	"font-variant",
	"font-weight",
	"fx",
	"fy",
	"g1",
	"g2",
	"glyph-name",
	"glyphref",
	"gradientunits",
	"gradienttransform",
	"height",
	"href",
	"id",
	"image-rendering",
	"in",
	"in2",
	"intercept",
	"k",
	"k1",
	"k2",
	"k3",
	"k4",
	"kerning",
	"keypoints",
	"keysplines",
	"keytimes",
	"lang",
	"lengthadjust",
	"letter-spacing",
	"kernelmatrix",
	"kernelunitlength",
	"lighting-color",
	"local",
	"marker-end",
	"marker-mid",
	"marker-start",
	"markerheight",
	"markerunits",
	"markerwidth",
	"maskcontentunits",
	"maskunits",
	"max",
	"mask",
	"media",
	"method",
	"mode",
	"min",
	"name",
	"numoctaves",
	"offset",
	"operator",
	"opacity",
	"order",
	"orient",
	"orientation",
	"origin",
	"overflow",
	"paint-order",
	"path",
	"pathlength",
	"patterncontentunits",
	"patterntransform",
	"patternunits",
	"points",
	"preservealpha",
	"preserveaspectratio",
	"primitiveunits",
	"r",
	"rx",
	"ry",
	"radius",
	"refx",
	"refy",
	"repeatcount",
	"repeatdur",
	"restart",
	"result",
	"rotate",
	"scale",
	"seed",
	"shape-rendering",
	"slope",
	"specularconstant",
	"specularexponent",
	"spreadmethod",
	"startoffset",
	"stddeviation",
	"stitchtiles",
	"stop-color",
	"stop-opacity",
	"stroke-dasharray",
	"stroke-dashoffset",
	"stroke-linecap",
	"stroke-linejoin",
	"stroke-miterlimit",
	"stroke-opacity",
	"stroke",
	"stroke-width",
	"style",
	"surfacescale",
	"systemlanguage",
	"tabindex",
	"tablevalues",
	"targetx",
	"targety",
	"transform",
	"transform-origin",
	"text-anchor",
	"text-decoration",
	"text-rendering",
	"textlength",
	"type",
	"u1",
	"u2",
	"unicode",
	"values",
	"viewbox",
	"visibility",
	"version",
	"vert-adv-y",
	"vert-origin-x",
	"vert-origin-y",
	"width",
	"word-spacing",
	"wrap",
	"writing-mode",
	"xchannelselector",
	"ychannelselector",
	"x",
	"x1",
	"x2",
	"xmlns",
	"y",
	"y1",
	"y2",
	"z",
	"zoomandpan"
]), Md = IG([
	"accent",
	"accentunder",
	"align",
	"bevelled",
	"close",
	"columnsalign",
	"columnlines",
	"columnspan",
	"denomalign",
	"depth",
	"dir",
	"display",
	"displaystyle",
	"encoding",
	"fence",
	"frame",
	"height",
	"href",
	"id",
	"largeop",
	"length",
	"linethickness",
	"lspace",
	"lquote",
	"mathbackground",
	"mathcolor",
	"mathsize",
	"mathvariant",
	"maxsize",
	"minsize",
	"movablelimits",
	"notation",
	"numalign",
	"open",
	"rowalign",
	"rowlines",
	"rowspacing",
	"rowspan",
	"rspace",
	"rquote",
	"scriptlevel",
	"scriptminsize",
	"scriptsizemultiplier",
	"selection",
	"separator",
	"separators",
	"stretchy",
	"subscriptshift",
	"supscriptshift",
	"symmetric",
	"voffset",
	"width",
	"xmlns"
]), Mp = IG([
	"xlink:href",
	"xml:id",
	"xlink:title",
	"xml:space",
	"xmlns:xlink"
]), Mf = Iq(/\{\{[\w\W]*|[\w\W]*\}\}/gm), Mg = Iq(/<%[\w\W]*|[\w\W]*%>/gm), Mm = Iq(/\$\{[\w\W]*/gm), My = Iq(/^data-[\-\w.\u00B7-\uFFFF]+$/), Mv = Iq(/^aria-[\-\w]+$/), Mx = Iq(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i), Mb = Iq(/^(?:\w+script|data):/i), Mw = Iq(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g), Mk = Iq(/^html$/i), MT = Object.freeze({
	__proto__: null,
	ARIA_ATTR: Mv,
	ATTR_WHITESPACE: Mw,
	CUSTOM_ELEMENT: Iq(/^[a-z][.\w]*(-[.\w]+)+$/i),
	DATA_ATTR: My,
	DOCTYPE_NAME: Mk,
	ERB_EXPR: Mg,
	IS_ALLOWED_URI: Mx,
	IS_SCRIPT_OR_DATA: Mb,
	MUSTACHE_EXPR: Mf,
	TMPLIT_EXPR: Mm
}), M_ = h(function() {
	return typeof window > "u" ? null : window;
}, "getGlobal"), ME = h(function(e, t) {
	if ("object" != typeof e || "function" != typeof e.createPolicy) return null;
	let r = null, i = "data-tt-policy-suffix";
	t && t.hasAttribute(i) && (r = t.getAttribute(i));
	let n = "dompurify" + (r ? "#" + r : "");
	try {
		return e.createPolicy(n, {
			createHTML: (e) => e,
			createScriptURL: (e) => e
		});
	} catch {
		return console.warn("TrustedTypes policy " + n + " could not be created."), null;
	}
}, "_createTrustedTypesPolicy"), MC = h(function() {
	return {
		afterSanitizeAttributes: [],
		afterSanitizeElements: [],
		afterSanitizeShadowDOM: [],
		beforeSanitizeAttributes: [],
		beforeSanitizeElements: [],
		beforeSanitizeShadowDOM: [],
		uponSanitizeAttribute: [],
		uponSanitizeElement: [],
		uponSanitizeShadowNode: []
	};
}, "_createHooksMap");
function MS() {
	let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : M_(), t = h((e) => MS(e), "DOMPurify");
	if (t.version = "3.2.6", t.removed = [], !e || !e.document || 9 !== e.document.nodeType || !e.Element) return t.isSupported = !1, t;
	let { document: r } = e, i = r, n = i.currentScript, { DocumentFragment: a, HTMLTemplateElement: s, Node: o, Element: l, NodeFilter: u, NamedNodeMap: d = e.NamedNodeMap || e.MozNamedAttrMap, HTMLFormElement: p, DOMParser: f, trustedTypes: g } = e, m = l.prototype, y = Mr(m, "cloneNode"), v = Mr(m, "remove"), x = Mr(m, "nextSibling"), b = Mr(m, "childNodes"), w = Mr(m, "parentNode");
	if ("function" == typeof s) {
		let e = r.createElement("template");
		e.content && e.content.ownerDocument && (r = e.content.ownerDocument);
	}
	let k, T = "", { implementation: _, createNodeIterator: E, createDocumentFragment: C, getElementsByTagName: S } = r, { importNode: A } = i, L = MC();
	t.isSupported = "function" == typeof IP && "function" == typeof w && _ && void 0 !== _.createHTMLDocument;
	let { MUSTACHE_EXPR: R, ERB_EXPR: N, TMPLIT_EXPR: I, DATA_ATTR: M, ARIA_ATTR: D, IS_SCRIPT_OR_DATA: O, ATTR_WHITESPACE: $, CUSTOM_ELEMENT: P } = MT, { IS_ALLOWED_URI: B } = MT, F = null, z = I9({}, [
		...Mi,
		...Mn,
		...Ma,
		...Mo,
		...Mc
	]), U = null, G = I9({}, [
		...Mh,
		...Mu,
		...Md,
		...Mp
	]), q = Object.seal(Ij(null, {
		tagNameCheck: {
			writable: !0,
			configurable: !1,
			enumerable: !0,
			value: null
		},
		attributeNameCheck: {
			writable: !0,
			configurable: !1,
			enumerable: !0,
			value: null
		},
		allowCustomizedBuiltInElements: {
			writable: !0,
			configurable: !1,
			enumerable: !0,
			value: !1
		}
	})), j = null, W = null, Y = !0, V = !0, H = !1, X = !0, K = !1, Z = !0, Q = !1, J = !1, ee = !1, et = !1, er = !1, ei = !1, en = !0, ea = !1, es = !0, eo = !1, el = {}, ec = null, eh = I9({}, [
		"annotation-xml",
		"audio",
		"colgroup",
		"desc",
		"foreignobject",
		"head",
		"iframe",
		"math",
		"mi",
		"mn",
		"mo",
		"ms",
		"mtext",
		"noembed",
		"noframes",
		"noscript",
		"plaintext",
		"script",
		"style",
		"svg",
		"template",
		"thead",
		"title",
		"video",
		"xmp"
	]), eu = null, ed = I9({}, [
		"audio",
		"video",
		"img",
		"source",
		"image",
		"track"
	]), ep = null, ef = I9({}, [
		"alt",
		"class",
		"for",
		"id",
		"label",
		"name",
		"pattern",
		"placeholder",
		"role",
		"summary",
		"title",
		"value",
		"style",
		"xmlns"
	]), eg = "http://www.w3.org/1998/Math/MathML", em = "http://www.w3.org/2000/svg", ey = "http://www.w3.org/1999/xhtml", ev = ey, ex = !1, eb = null, ew = I9({}, [
		eg,
		em,
		ey
	], IJ), ek = I9({}, [
		"mi",
		"mo",
		"mn",
		"ms",
		"mtext"
	]), eT = I9({}, ["annotation-xml"]), e_ = I9({}, [
		"title",
		"style",
		"font",
		"a",
		"script"
	]), eE = null, eC = ["application/xhtml+xml", "text/html"], eS = null, eA = null, eL = r.createElement("form"), eR = h(function(e) {
		return e instanceof RegExp || e instanceof Function;
	}, "isRegexOrFunction"), eN = h(function() {
		let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
		if (!(eA && eA === e)) {
			if (e && "object" == typeof e || (e = {}), e = Mt(e), eS = "application/xhtml+xml" === (eE = -1 === eC.indexOf(e.PARSER_MEDIA_TYPE) ? "text/html" : e.PARSER_MEDIA_TYPE) ? IJ : IQ, F = I5(e, "ALLOWED_TAGS") ? I9({}, e.ALLOWED_TAGS, eS) : z, U = I5(e, "ALLOWED_ATTR") ? I9({}, e.ALLOWED_ATTR, eS) : G, eb = I5(e, "ALLOWED_NAMESPACES") ? I9({}, e.ALLOWED_NAMESPACES, IJ) : ew, ep = I5(e, "ADD_URI_SAFE_ATTR") ? I9(Mt(ef), e.ADD_URI_SAFE_ATTR, eS) : ef, eu = I5(e, "ADD_DATA_URI_TAGS") ? I9(Mt(ed), e.ADD_DATA_URI_TAGS, eS) : ed, ec = I5(e, "FORBID_CONTENTS") ? I9({}, e.FORBID_CONTENTS, eS) : eh, j = I5(e, "FORBID_TAGS") ? I9({}, e.FORBID_TAGS, eS) : Mt({}), W = I5(e, "FORBID_ATTR") ? I9({}, e.FORBID_ATTR, eS) : Mt({}), el = !!I5(e, "USE_PROFILES") && e.USE_PROFILES, Y = !1 !== e.ALLOW_ARIA_ATTR, V = !1 !== e.ALLOW_DATA_ATTR, H = e.ALLOW_UNKNOWN_PROTOCOLS || !1, X = !1 !== e.ALLOW_SELF_CLOSE_IN_ATTR, K = e.SAFE_FOR_TEMPLATES || !1, Z = !1 !== e.SAFE_FOR_XML, Q = e.WHOLE_DOCUMENT || !1, et = e.RETURN_DOM || !1, er = e.RETURN_DOM_FRAGMENT || !1, ei = e.RETURN_TRUSTED_TYPE || !1, ee = e.FORCE_BODY || !1, en = !1 !== e.SANITIZE_DOM, ea = e.SANITIZE_NAMED_PROPS || !1, es = !1 !== e.KEEP_CONTENT, eo = e.IN_PLACE || !1, B = e.ALLOWED_URI_REGEXP || Mx, ev = e.NAMESPACE || ey, ek = e.MATHML_TEXT_INTEGRATION_POINTS || ek, eT = e.HTML_INTEGRATION_POINTS || eT, q = e.CUSTOM_ELEMENT_HANDLING || {}, e.CUSTOM_ELEMENT_HANDLING && eR(e.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (q.tagNameCheck = e.CUSTOM_ELEMENT_HANDLING.tagNameCheck), e.CUSTOM_ELEMENT_HANDLING && eR(e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (q.attributeNameCheck = e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), e.CUSTOM_ELEMENT_HANDLING && "boolean" == typeof e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (q.allowCustomizedBuiltInElements = e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), K && (V = !1), er && (et = !0), el && (F = I9({}, Mc), U = [], !0 === el.html && (I9(F, Mi), I9(U, Mh)), !0 === el.svg && (I9(F, Mn), I9(U, Mu), I9(U, Mp)), !0 === el.svgFilters && (I9(F, Ma), I9(U, Mu), I9(U, Mp)), !0 === el.mathMl && (I9(F, Mo), I9(U, Md), I9(U, Mp))), e.ADD_TAGS && (F === z && (F = Mt(F)), I9(F, e.ADD_TAGS, eS)), e.ADD_ATTR && (U === G && (U = Mt(U)), I9(U, e.ADD_ATTR, eS)), e.ADD_URI_SAFE_ATTR && I9(ep, e.ADD_URI_SAFE_ATTR, eS), e.FORBID_CONTENTS && (ec === eh && (ec = Mt(ec)), I9(ec, e.FORBID_CONTENTS, eS)), es && (F["#text"] = !0), Q && I9(F, [
				"html",
				"head",
				"body"
			]), F.table && (I9(F, ["tbody"]), delete j.tbody), e.TRUSTED_TYPES_POLICY) {
				if ("function" != typeof e.TRUSTED_TYPES_POLICY.createHTML) throw I6("TRUSTED_TYPES_POLICY configuration option must provide a \"createHTML\" hook.");
				if ("function" != typeof e.TRUSTED_TYPES_POLICY.createScriptURL) throw I6("TRUSTED_TYPES_POLICY configuration option must provide a \"createScriptURL\" hook.");
				T = (k = e.TRUSTED_TYPES_POLICY).createHTML("");
			} else void 0 === k && (k = ME(g, n)), null !== k && "string" == typeof T && (T = k.createHTML(""));
			IG && IG(e), eA = e;
		}
	}, "_parseConfig"), eI = I9({}, [
		...Mn,
		...Ma,
		...Ms
	]), eM = I9({}, [...Mo, ...Ml]), eD = h(function(e) {
		let t = w(e);
		t && t.tagName || (t = {
			namespaceURI: ev,
			tagName: "template"
		});
		let r = IQ(e.tagName), i = IQ(t.tagName);
		return !!eb[e.namespaceURI] && (e.namespaceURI === em ? t.namespaceURI === ey ? "svg" === r : t.namespaceURI === eg ? "svg" === r && ("annotation-xml" === i || ek[i]) : !!eI[r] : e.namespaceURI === eg ? t.namespaceURI === ey ? "math" === r : t.namespaceURI === em ? "math" === r && eT[i] : !!eM[r] : e.namespaceURI === ey ? (t.namespaceURI !== em || !!eT[i]) && (t.namespaceURI !== eg || !!ek[i]) && !eM[r] && (e_[r] || !eI[r]) : !!("application/xhtml+xml" === eE && eb[e.namespaceURI]));
	}, "_checkValidNamespace"), eO = h(function(e) {
		IK(t.removed, { element: e });
		try {
			w(e).removeChild(e);
		} catch {
			v(e);
		}
	}, "_forceRemove"), e$ = h(function(e, r) {
		try {
			IK(t.removed, {
				attribute: r.getAttributeNode(e),
				from: r
			});
		} catch {
			IK(t.removed, {
				attribute: null,
				from: r
			});
		}
		if (r.removeAttribute(e), "is" === e) if (et || er) try {
			eO(r);
		} catch {}
		else try {
			r.setAttribute(e, "");
		} catch {}
	}, "_removeAttribute"), eP = h(function(e) {
		let t = null, i = null;
		if (ee) e = "<remove></remove>" + e;
		else {
			let t = I0(e, /^[\r\n\t ]+/);
			i = t && t[0];
		}
		"application/xhtml+xml" === eE && ev === ey && (e = "<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>" + e + "</body></html>");
		let n = k ? k.createHTML(e) : e;
		if (ev === ey) try {
			t = new f().parseFromString(n, eE);
		} catch {}
		if (!t || !t.documentElement) {
			t = _.createDocument(ev, "template", null);
			try {
				t.documentElement.innerHTML = ex ? T : n;
			} catch {}
		}
		let a = t.body || t.documentElement;
		return e && i && a.insertBefore(r.createTextNode(i), a.childNodes[0] || null), ev === ey ? S.call(t, Q ? "html" : "body")[0] : Q ? t.documentElement : a;
	}, "_initDocument"), eB = h(function(e) {
		return E.call(e.ownerDocument || e, e, u.SHOW_ELEMENT | u.SHOW_COMMENT | u.SHOW_TEXT | u.SHOW_PROCESSING_INSTRUCTION | u.SHOW_CDATA_SECTION, null);
	}, "_createNodeIterator"), eF = h(function(e) {
		return e instanceof p && ("string" != typeof e.nodeName || "string" != typeof e.textContent || "function" != typeof e.removeChild || !(e.attributes instanceof d) || "function" != typeof e.removeAttribute || "function" != typeof e.setAttribute || "string" != typeof e.namespaceURI || "function" != typeof e.insertBefore || "function" != typeof e.hasChildNodes);
	}, "_isClobbered"), ez = h(function(e) {
		return "function" == typeof o && e instanceof o;
	}, "_isNode");
	function eU(e, r, i) {
		IV(e, (e) => {
			e.call(t, r, i, eA);
		});
	}
	h(eU, "_executeHooks");
	let eG = h(function(e) {
		let r = null;
		if (eU(L.beforeSanitizeElements, e, null), eF(e)) return eO(e), !0;
		let i = eS(e.nodeName);
		if (eU(L.uponSanitizeElement, e, {
			tagName: i,
			allowedTags: F
		}), Z && e.hasChildNodes() && !ez(e.firstElementChild) && I3(/<[/\w!]/g, e.innerHTML) && I3(/<[/\w!]/g, e.textContent) || 7 === e.nodeType || Z && 8 === e.nodeType && I3(/<[/\w]/g, e.data)) return eO(e), !0;
		if (!F[i] || j[i]) {
			if (!j[i] && ej(i) && (q.tagNameCheck instanceof RegExp && I3(q.tagNameCheck, i) || q.tagNameCheck instanceof Function && q.tagNameCheck(i))) return !1;
			if (es && !ec[i]) {
				let t = w(e) || e.parentNode, r = b(e) || e.childNodes;
				if (r && t) {
					let i = r.length;
					for (let n = i - 1; n >= 0; --n) {
						let i = y(r[n], !0);
						i.__removalCount = (e.__removalCount || 0) + 1, t.insertBefore(i, x(e));
					}
				}
			}
			return eO(e), !0;
		}
		return e instanceof l && !eD(e) || ("noscript" === i || "noembed" === i || "noframes" === i) && I3(/<\/no(script|embed|frames)/i, e.innerHTML) ? (eO(e), !0) : (K && 3 === e.nodeType && (r = e.textContent, IV([
			R,
			N,
			I
		], (e) => {
			r = I1(r, e, " ");
		}), e.textContent !== r && (IK(t.removed, { element: e.cloneNode() }), e.textContent = r)), eU(L.afterSanitizeElements, e, null), !1);
	}, "_sanitizeElements"), eq = h(function(e, t, i) {
		if (en && ("id" === t || "name" === t) && (i in r || i in eL)) return !1;
		if (!(V && !W[t] && I3(M, t)) && !(Y && I3(D, t))) {
			if (!U[t] || W[t]) {
				if (!(ej(e) && (q.tagNameCheck instanceof RegExp && I3(q.tagNameCheck, e) || q.tagNameCheck instanceof Function && q.tagNameCheck(e)) && (q.attributeNameCheck instanceof RegExp && I3(q.attributeNameCheck, t) || q.attributeNameCheck instanceof Function && q.attributeNameCheck(t)) || "is" === t && q.allowCustomizedBuiltInElements && (q.tagNameCheck instanceof RegExp && I3(q.tagNameCheck, i) || q.tagNameCheck instanceof Function && q.tagNameCheck(i)))) return !1;
			} else if (!ep[t] && !I3(B, I1(i, $, "")) && !(("src" === t || "xlink:href" === t || "href" === t) && "script" !== e && 0 === I2(i, "data:") && eu[e]) && !(H && !I3(O, I1(i, $, ""))) && i) return !1;
		}
		return !0;
	}, "_isValidAttribute"), ej = h(function(e) {
		return "annotation-xml" !== e && I0(e, P);
	}, "_isBasicCustomElement"), eW = h(function(e) {
		eU(L.beforeSanitizeAttributes, e, null);
		let { attributes: r } = e;
		if (!r || eF(e)) return;
		let i = {
			attrName: "",
			attrValue: "",
			keepAttr: !0,
			allowedAttributes: U,
			forceKeepAttr: void 0
		}, n = r.length;
		for (; n--;) {
			let { name: a, namespaceURI: s, value: o } = r[n], l = eS(a), h = "value" === a ? o : I4(o);
			if (i.attrName = l, i.attrValue = h, i.keepAttr = !0, i.forceKeepAttr = void 0, eU(L.uponSanitizeAttribute, e, i), h = i.attrValue, ea && ("id" === l || "name" === l) && (e$(a, e), h = "user-content-" + h), Z && I3(/((--!?|])>)|<\/(style|title)/i, h)) {
				e$(a, e);
				continue;
			}
			if (i.forceKeepAttr) continue;
			if (!i.keepAttr || !X && I3(/\/>/i, h)) {
				e$(a, e);
				continue;
			}
			K && IV([
				R,
				N,
				I
			], (e) => {
				h = I1(h, e, " ");
			});
			let u = eS(e.nodeName);
			if (!eq(u, l, h)) {
				e$(a, e);
				continue;
			}
			if (k && "object" == typeof g && "function" == typeof g.getAttributeType && !s) switch (g.getAttributeType(u, l)) {
				case "TrustedHTML":
					h = k.createHTML(h);
					break;
				case "TrustedScriptURL": h = k.createScriptURL(h);
			}
			if (h !== o) try {
				s ? e.setAttributeNS(s, a, h) : e.setAttribute(a, h), eF(e) ? eO(e) : IX(t.removed);
			} catch {
				e$(a, e);
			}
		}
		eU(L.afterSanitizeAttributes, e, null);
	}, "_sanitizeAttributes"), eY = h(function e(t) {
		let r = null, i = eB(t);
		for (eU(L.beforeSanitizeShadowDOM, t, null); r = i.nextNode();) eU(L.uponSanitizeShadowNode, r, null), eG(r), eW(r), r.content instanceof a && e(r.content);
		eU(L.afterSanitizeShadowDOM, t, null);
	}, "_sanitizeShadowDOM");
	return t.sanitize = function(e) {
		let r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = null, s = null, l = null, h = null;
		if ((ex = !e) && (e = "<!-->"), "string" != typeof e && !ez(e)) if ("function" == typeof e.toString) {
			if ("string" != typeof (e = e.toString())) throw I6("dirty is not a string, aborting");
		} else throw I6("toString is not a function");
		if (!t.isSupported) return e;
		if (J || eN(r), t.removed = [], "string" == typeof e && (eo = !1), eo) {
			if (e.nodeName) {
				let t = eS(e.nodeName);
				if (!F[t] || j[t]) throw I6("root node is forbidden and cannot be sanitized in-place");
			}
		} else if (e instanceof o) 1 === (s = (n = eP("<!---->")).ownerDocument.importNode(e, !0)).nodeType && "BODY" === s.nodeName || "HTML" === s.nodeName ? n = s : n.appendChild(s);
		else {
			if (!et && !K && !Q && -1 === e.indexOf("<")) return k && ei ? k.createHTML(e) : e;
			if (!(n = eP(e))) return et ? null : ei ? T : "";
		}
		n && ee && eO(n.firstChild);
		let u = eB(eo ? e : n);
		for (; l = u.nextNode();) eG(l), eW(l), l.content instanceof a && eY(l.content);
		if (eo) return e;
		if (et) {
			if (er) for (h = C.call(n.ownerDocument); n.firstChild;) h.appendChild(n.firstChild);
			else h = n;
			return (U.shadowroot || U.shadowrootmode) && (h = A.call(i, h, !0)), h;
		}
		let d = Q ? n.outerHTML : n.innerHTML;
		return Q && F["!doctype"] && n.ownerDocument && n.ownerDocument.doctype && n.ownerDocument.doctype.name && I3(Mk, n.ownerDocument.doctype.name) && (d = "<!DOCTYPE " + n.ownerDocument.doctype.name + `>
` + d), K && IV([
			R,
			N,
			I
		], (e) => {
			d = I1(d, e, " ");
		}), k && ei ? k.createHTML(d) : d;
	}, t.setConfig = function() {
		eN(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}), J = !0;
	}, t.clearConfig = function() {
		eA = null, J = !1;
	}, t.isValidAttribute = function(e, t, r) {
		return eA || eN({}), eq(eS(e), eS(t), r);
	}, t.addHook = function(e, t) {
		"function" == typeof t && IK(L[e], t);
	}, t.removeHook = function(e, t) {
		if (void 0 !== t) {
			let r = IH(L[e], t);
			return -1 === r ? void 0 : IZ(L[e], r, 1)[0];
		}
		return IX(L[e]);
	}, t.removeHooks = function(e) {
		L[e] = [];
	}, t.removeAllHooks = function() {
		L = MC();
	}, t;
}
h(MS, "createDOMPurify");
var MA = MS(), ML = /<br\s*\/?>/gi, MR = h((e) => e ? Mz(e).replace(/\\n/g, "#br#").split("#br#") : [""], "getRows"), MN = (e = !1, () => {
	e || (MI(), e = !0);
});
function MI() {
	let e = "data-temp-href-target";
	MA.addHook("beforeSanitizeAttributes", (t) => {
		"A" === t.tagName && t.hasAttribute("target") && t.setAttribute(e, t.getAttribute("target") ?? "");
	}), MA.addHook("afterSanitizeAttributes", (t) => {
		"A" === t.tagName && t.hasAttribute(e) && (t.setAttribute("target", t.getAttribute(e) ?? ""), t.removeAttribute(e), "_blank" === t.getAttribute("target") && t.setAttribute("rel", "noopener"));
	});
}
h(MI, "setupDompurifyHooks");
var MM = h((e) => (MN(), MA.sanitize(e)), "removeScript"), MD = h((e, t) => {
	if (t.flowchart?.htmlLabels !== !1) {
		let r = t.securityLevel;
		"antiscript" === r || "strict" === r ? e = MM(e) : "loose" !== r && (e = MF(e = (e = (e = Mz(e)).replace(/</g, "&lt;").replace(/>/g, "&gt;")).replace(/=/g, "&equals;")));
	}
	return e;
}, "sanitizeMore"), MO = h((e, t) => e && (e = t.dompurifyConfig ? MA.sanitize(MD(e, t), t.dompurifyConfig).toString() : MA.sanitize(MD(e, t), { FORBID_TAGS: ["style"] }).toString()), "sanitizeText"), M$ = h((e, t) => "string" == typeof e ? MO(e, t) : e.flat().map((e) => MO(e, t)), "sanitizeTextOrArray"), MP = h((e) => ML.test(e), "hasBreaks"), MB = h((e) => e.split(ML), "splitBreaks"), MF = h((e) => e.replace(/#br#/g, "<br/>"), "placeholderToBreak"), Mz = h((e) => e.replace(ML, "#br#"), "breakToPlaceholder"), MU = h((e) => {
	let t = "";
	return e && (t = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search, t = CSS.escape(t)), t;
}, "getUrl"), MG = h((e) => !(!1 === e || [
	"false",
	"null",
	"0"
].includes(String(e).trim().toLowerCase())), "evaluate"), Mq = h(function(...e) {
	return Math.max(...e.filter((e) => !isNaN(e)));
}, "getMax"), Mj = h(function(...e) {
	return Math.min(...e.filter((e) => !isNaN(e)));
}, "getMin"), MW = h(function(e) {
	let t = e.split(/(,)/), r = [];
	for (let e = 0; e < t.length; e++) {
		let i = t[e];
		if ("," === i && e > 0 && e + 1 < t.length) {
			let n = t[e - 1], a = t[e + 1];
			MV(n, a) && (i = n + "," + a, e++, r.pop());
		}
		r.push(MH(i));
	}
	return r.join("");
}, "parseGenericTypes"), MY = h((e, t) => Math.max(0, e.split(t).length - 1), "countOccurrence"), MV = h((e, t) => {
	let r = MY(e, "~"), i = MY(t, "~");
	return 1 === r && 1 === i;
}, "shouldCombineSets"), MH = h((e) => {
	let t = MY(e, "~"), r = !1;
	if (t <= 1) return e;
	t % 2 != 0 && e.startsWith("~") && (e = e.substring(1), r = !0);
	let i = [...e], n = i.indexOf("~"), a = i.lastIndexOf("~");
	for (; -1 !== n && -1 !== a && n !== a;) i[n] = "<", i[a] = ">", n = i.indexOf("~"), a = i.lastIndexOf("~");
	return r && i.unshift("~"), i.join("");
}, "processSet"), MX = h(() => void 0 !== window.MathMLElement, "isMathMLSupported"), MK = /\$\$(.*)\$\$/g, MZ = h((e) => (e.match(MK)?.length ?? 0) > 0, "hasKatex"), MQ = h(async (e, t) => {
	let r = document.createElement("div");
	r.innerHTML = await M0(e, t), r.id = "katex-temp", r.style.visibility = "hidden", r.style.position = "absolute", r.style.top = "0", document.querySelector("body")?.insertAdjacentElement("beforeend", r);
	let i = {
		width: r.clientWidth,
		height: r.clientHeight
	};
	return r.remove(), i;
}, "calculateMathMLDimensions"), MJ = h(async (e, t) => {
	if (!MZ(e)) return e;
	if (!(MX() || t.legacyMathML || t.forceLegacyMathML)) return e.replace(MK, "MathML is unsupported in this environment.");
	{
		let { default: i } = await r(async () => {
			let { default: e } = await import("./vendor-mermaid.DT9Gg-GB.chunk.js");
			return { default: e };
		}, []), n = t.forceLegacyMathML || !MX() && t.legacyMathML ? "htmlAndMathml" : "mathml";
		return e.split(ML).map((e) => MZ(e) ? `<div style="display: flex; align-items: center; justify-content: center; white-space: nowrap;">${e}</div>` : `<div>${e}</div>`).join("").replace(MK, (e, t) => i.renderToString(t, {
			throwOnError: !0,
			displayMode: !0,
			output: n
		}).replace(/\n/g, " ").replace(/<annotation.*<\/annotation>/g, ""));
	}
}, "renderKatexUnsanitized"), M0 = h(async (e, t) => MO(await MJ(e, t), t), "renderKatexSanitized"), M1 = {
	getRows: MR,
	sanitizeText: MO,
	sanitizeTextOrArray: M$,
	hasBreaks: MP,
	splitBreaks: MB,
	lineBreakRegex: ML,
	removeScript: MM,
	getUrl: MU,
	evaluate: MG,
	getMax: Mq,
	getMin: Mj
}, M2 = h(function(e, t) {
	for (let r of t) e.attr(r[0], r[1]);
}, "d3Attrs"), M4 = h(function(e, t, r) {
	let i = /* @__PURE__ */ new Map();
	return r ? (i.set("width", "100%"), i.set("style", `max-width: ${t}px;`)) : (i.set("height", e), i.set("width", t)), i;
}, "calculateSvgSizeAttrs"), M5 = h(function(e, t, r, i) {
	M2(e, M4(t, r, i));
}, "configureSvgSize"), M3 = h(function(e, t, r, i) {
	let n = t.node().getBBox(), a = n.width, s = n.height;
	wQ.info(`SVG bounds: ${a}x${s}`, n);
	let o = 0, l = 0;
	wQ.info(`Graph bounds: ${o}x${l}`, e), o = a + 2 * r, l = s + 2 * r, wQ.info(`Calculated bounds: ${o}x${l}`), M5(t, l, o, i);
	let h = `${n.x - r} ${n.y - r} ${n.width + 2 * r} ${n.height + 2 * r}`;
	t.attr("viewBox", h);
}, "setupGraphViewbox"), M6 = {}, M7 = h((e, t, r) => {
	let i = "";
	return e in M6 && M6[e] ? i = M6[e](r) : wQ.warn(`No theme found for ${e}`), ` & {
    font-family: ${r.fontFamily};
    font-size: ${r.fontSize};
    fill: ${r.textColor}
  }
  @keyframes edge-animation-frame {
    from {
      stroke-dashoffset: 0;
    }
  }
  @keyframes dash {
    to {
      stroke-dashoffset: 0;
    }
  }
  & .edge-animation-slow {
    stroke-dasharray: 9,5 !important;
    stroke-dashoffset: 900;
    animation: dash 50s linear infinite;
    stroke-linecap: round;
  }
  & .edge-animation-fast {
    stroke-dasharray: 9,5 !important;
    stroke-dashoffset: 900;
    animation: dash 20s linear infinite;
    stroke-linecap: round;
  }
  /* Classes common for multiple diagrams */

  & .error-icon {
    fill: ${r.errorBkgColor};
  }
  & .error-text {
    fill: ${r.errorTextColor};
    stroke: ${r.errorTextColor};
  }

  & .edge-thickness-normal {
    stroke-width: 1px;
  }
  & .edge-thickness-thick {
    stroke-width: 3.5px
  }
  & .edge-pattern-solid {
    stroke-dasharray: 0;
  }
  & .edge-thickness-invisible {
    stroke-width: 0;
    fill: none;
  }
  & .edge-pattern-dashed{
    stroke-dasharray: 3;
  }
  .edge-pattern-dotted {
    stroke-dasharray: 2;
  }

  & .marker {
    fill: ${r.lineColor};
    stroke: ${r.lineColor};
  }
  & .marker.cross {
    stroke: ${r.lineColor};
  }

  & svg {
    font-family: ${r.fontFamily};
    font-size: ${r.fontSize};
  }
   & p {
    margin: 0
   }

  ${i}

  ${t}
`;
}, "getStyles"), M8 = h((e, t) => {
	void 0 !== t && (M6[e] = t);
}, "addStylesForDiagram"), M9 = {};
d(M9, {
	clear: () => Dn,
	getAccDescription: () => Dl,
	getAccTitle: () => Ds,
	getDiagramTitle: () => Dh,
	setAccDescription: () => Do,
	setAccTitle: () => Da,
	setDiagramTitle: () => Dc
});
var De = "", Dt = "", Dr = "", Di = h((e) => MO(e, IA()), "sanitizeText"), Dn = h(() => {
	De = "", Dr = "", Dt = "";
}, "clear"), Da = h((e) => {
	De = Di(e).replace(/^\s+/g, "");
}, "setAccTitle"), Ds = h(() => De, "getAccTitle"), Do = h((e) => {
	Dr = Di(e).replace(/\n\s+/g, `
`);
}, "setAccDescription"), Dl = h(() => Dr, "getAccDescription"), Dc = h((e) => {
	Dt = Di(e);
}, "setDiagramTitle"), Dh = h(() => Dt, "getDiagramTitle"), Du = h((e) => MO(e, IA()), "sanitizeText"), Dd = h(() => M9, "getCommonDb"), Dp = {}, Df = h((e, t, r) => {
	Dp[e] && wQ.warn(`Diagram with id ${e} already registered. Overwriting.`), Dp[e] = t, r && NP(e, r), M8(e, t.styles), t.injectUtils?.(wQ, wJ, IA, Du, M3, Dd(), () => {});
}, "registerDiagram"), Dg = h((e) => {
	if (e in Dp) return Dp[e];
	throw new Dm(e);
}, "getDiagram"), Dm = class extends Error {
	static {
		h(this, "DiagramNotFoundError");
	}
	constructor(e) {
		super(`Diagram ${e} not found.`);
	}
}, Dy = h((e) => {
	let { securityLevel: t } = IA(), r = _t("body");
	return "sandbox" === t && (r = _t((_t(`#i${e}`).node()?.contentDocument ?? document).body)), r.select(`#${e}`);
}, "selectSvgElement");
function Dv(e, t) {
	(null == t || t > e.length) && (t = e.length);
	for (var r = 0, i = Array(t); r < t; r++) i[r] = e[r];
	return i;
}
function Dx(e) {
	if (Array.isArray(e)) return e;
}
function Db(e) {
	if (Array.isArray(e)) return Dv(e);
}
function Dw(e, t) {
	if (!(e instanceof t)) throw TypeError("Cannot call a class as a function");
}
function Dk(e, t) {
	for (var r = 0; r < t.length; r++) {
		var i = t[r];
		i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, DM(i.key), i);
	}
}
function DT(e, t, r) {
	return t && Dk(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function D_(e, t) {
	var r = "u" > typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
	if (!r) {
		if (Array.isArray(e) || (r = DO(e)) || t) {
			r && (e = r);
			var i = 0, n = h(function() {}, "F");
			return {
				s: n,
				n: h(function() {
					return i >= e.length ? { done: !0 } : {
						done: !1,
						value: e[i++]
					};
				}, "n"),
				e: h(function(e) {
					throw e;
				}, "e"),
				f: n
			};
		}
		throw TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
	}
	var a, s = !0, o = !1;
	return {
		s: h(function() {
			r = r.call(e);
		}, "s"),
		n: h(function() {
			var e = r.next();
			return s = e.done, e;
		}, "n"),
		e: h(function(e) {
			o = !0, a = e;
		}, "e"),
		f: h(function() {
			try {
				s || null == r.return || r.return();
			} finally {
				if (o) throw a;
			}
		}, "f")
	};
}
function DE(e, t, r) {
	return (t = DM(t)) in e ? Object.defineProperty(e, t, {
		value: r,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[t] = r, e;
}
function DC(e) {
	if ("u" > typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e);
}
function DS(e, t) {
	var r = null == e ? null : "u" > typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
	if (null != r) {
		var i, n, a, s, o = [], l = !0, h = !1;
		try {
			if (a = (r = r.call(e)).next, 0 === t) {
				if (Object(r) !== r) return;
				l = !1;
			} else for (; !(l = (i = a.call(r)).done) && (o.push(i.value), o.length !== t); l = !0);
		} catch (e) {
			h = !0, n = e;
		} finally {
			try {
				if (!l && null != r.return && (s = r.return(), Object(s) !== s)) return;
			} finally {
				if (h) throw n;
			}
		}
		return o;
	}
}
function DA() {
	throw TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function DL() {
	throw TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function DR(e, t) {
	return Dx(e) || DS(e, t) || DO(e, t) || DA();
}
function DN(e) {
	return Db(e) || DC(e) || DO(e) || DL();
}
function DI(e, t) {
	if ("object" != typeof e || !e) return e;
	var r = e[Symbol.toPrimitive];
	if (void 0 !== r) {
		var i = r.call(e, t);
		if ("object" != typeof i) return i;
		throw TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(e);
}
function DM(e) {
	var t = DI(e, "string");
	return "symbol" == typeof t ? t : t + "";
}
function DD(e) {
	return (DD = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
		return typeof e;
	} : function(e) {
		return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
	})(e);
}
function DO(e, t) {
	if (e) {
		if ("string" == typeof e) return Dv(e, t);
		var r = {}.toString.call(e).slice(8, -1);
		return "Object" === r && e.constructor && (r = e.constructor.name), "Map" === r || "Set" === r ? Array.from(e) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? Dv(e, t) : void 0;
	}
}
h(Dv, "_arrayLikeToArray"), h(Dx, "_arrayWithHoles"), h(Db, "_arrayWithoutHoles"), h(Dw, "_classCallCheck"), h(Dk, "_defineProperties"), h(DT, "_createClass"), h(D_, "_createForOfIteratorHelper"), h(DE, "_defineProperty$1"), h(DC, "_iterableToArray"), h(DS, "_iterableToArrayLimit"), h(DA, "_nonIterableRest"), h(DL, "_nonIterableSpread"), h(DR, "_slicedToArray"), h(DN, "_toConsumableArray"), h(DI, "_toPrimitive"), h(DM, "_toPropertyKey"), h(DD, "_typeof"), h(DO, "_unsupportedIterableToArray");
var D$ = typeof window > "u" ? null : window, DP = D$ ? D$.navigator : null;
D$ && D$.document;
var DB = DD(""), DF = DD({}), Dz = DD(function() {}), DU = typeof HTMLElement > "u" ? "undefined" : DD(HTMLElement), DG = h(function(e) {
	return e && e.instanceString && Dj(e.instanceString) ? e.instanceString() : null;
}, "instanceStr"), Dq = h(function(e) {
	return null != e && DD(e) == DB;
}, "string"), Dj = h(function(e) {
	return null != e && DD(e) === Dz;
}, "fn"), DW = h(function(e) {
	return !DZ(e) && (Array.isArray ? Array.isArray(e) : null != e && e instanceof Array);
}, "array"), DY = h(function(e) {
	return null != e && DD(e) === DF && !DW(e) && e.constructor === Object;
}, "plainObject"), DV = h(function(e) {
	return null != e && DD(e) === DF;
}, "object"), DH = h(function(e) {
	return null != e && DD(e) === DD(1) && !isNaN(e);
}, "number"), DX = h(function(e) {
	return DH(e) && Math.floor(e) === e;
}, "integer"), DK = h(function(e) {
	if ("undefined" !== DU) return null != e && e instanceof HTMLElement;
}, "htmlElement"), DZ = h(function(e) {
	return DQ(e) || DJ(e);
}, "elementOrCollection"), DQ = h(function(e) {
	return "collection" === DG(e) && e._private.single;
}, "element"), DJ = h(function(e) {
	return "collection" === DG(e) && !e._private.single;
}, "collection"), D0 = h(function(e) {
	return "core" === DG(e);
}, "core"), D1 = h(function(e) {
	return "stylesheet" === DG(e);
}, "stylesheet"), D2 = h(function(e) {
	return "event" === DG(e);
}, "event"), D4 = h(function(e) {
	return null == e || !!("" === e || e.match(/^\s+$/));
}, "emptyString"), D5 = h(function(e) {
	return !(typeof HTMLElement > "u") && e instanceof HTMLElement;
}, "domElement"), D3 = h(function(e) {
	return DY(e) && DH(e.x1) && DH(e.x2) && DH(e.y1) && DH(e.y2);
}, "boundingBox"), D6 = h(function(e) {
	return DV(e) && Dj(e.then);
}, "promise"), D7 = h(function() {
	return DP && DP.userAgent.match(/msie|trident|edge/i);
}, "ms"), D8 = h(function(e, t) {
	t || (t = h(function() {
		if (1 == arguments.length) return arguments[0];
		if (0 == arguments.length) return "undefined";
		for (var e = [], t = 0; t < arguments.length; t++) e.push(arguments[t]);
		return e.join("$");
	}, "keyFn"));
	var r = h(function() {
		var i, n = arguments, a = t.apply(this, n), s = r.cache;
		return (i = s[a]) || (i = s[a] = e.apply(this, n)), i;
	}, "memoizedFn");
	return r.cache = {}, r;
}, "memoize"), D9 = D8(function(e) {
	return e.replace(/([A-Z])/g, function(e) {
		return "-" + e.toLowerCase();
	});
}), Oe = D8(function(e) {
	return e.replace(/(-\w)/g, function(e) {
		return e[1].toUpperCase();
	});
}), Ot = D8(function(e, t) {
	return e + t[0].toUpperCase() + t.substring(1);
}, function(e, t) {
	return e + "$" + t;
}), Or = h(function(e) {
	return D4(e) ? e : e.charAt(0).toUpperCase() + e.substring(1);
}, "capitalize"), Oi = h(function(e, t) {
	return e.slice(-1 * t.length) === t;
}, "endsWith"), On = "(?:[-+]?(?:(?:\\d+|\\d*\\.\\d+)(?:[Ee][+-]?\\d+)?))", Oa = "rgb[a]?\\((" + On + "[%]?)\\s*,\\s*(" + On + "[%]?)\\s*,\\s*(" + On + "[%]?)(?:\\s*,\\s*(" + On + "))?\\)", Os = "rgb[a]?\\((?:" + On + "[%]?)\\s*,\\s*(?:" + On + "[%]?)\\s*,\\s*(?:" + On + "[%]?)(?:\\s*,\\s*(?:" + On + "))?\\)", Oo = "hsl[a]?\\((" + On + ")\\s*,\\s*(" + On + "[%])\\s*,\\s*(" + On + "[%])(?:\\s*,\\s*(" + On + "))?\\)", Ol = "hsl[a]?\\((?:" + On + ")\\s*,\\s*(?:" + On + "[%])\\s*,\\s*(?:" + On + "[%])(?:\\s*,\\s*(?:" + On + "))?\\)", Oc = h(function(e, t) {
	return e < t ? -1 : +(e > t);
}, "ascending"), Oh = h(function(e, t) {
	return -1 * Oc(e, t);
}, "descending"), Ou = null != Object.assign ? Object.assign.bind(Object) : function(e) {
	for (var t = arguments, r = 1; r < t.length; r++) {
		var i = t[r];
		if (null != i) for (var n = Object.keys(i), a = 0; a < n.length; a++) {
			var s = n[a];
			e[s] = i[s];
		}
	}
	return e;
}, Od = h(function(e) {
	if ((4 === e.length || 7 === e.length) && "#" === e[0]) {
		var t, r, i;
		return 4 === e.length ? (t = parseInt(e[1] + e[1], 16), r = parseInt(e[2] + e[2], 16), i = parseInt(e[3] + e[3], 16)) : (t = parseInt(e[1] + e[2], 16), r = parseInt(e[3] + e[4], 16), i = parseInt(e[5] + e[6], 16)), [
			t,
			r,
			i
		];
	}
}, "hex2tuple"), Op = h(function(e) {
	function t(e, t, r) {
		return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? e + (t - e) * 6 * r : r < .5 ? t : r < 2 / 3 ? e + (t - e) * (2 / 3 - r) * 6 : e;
	}
	h(t, "hue2rgb");
	var r, i, n, a, s, o, l, u, d = RegExp("^" + Oo + "$").exec(e);
	if (d) {
		if ((i = parseInt(d[1])) < 0 ? i = (360 - -1 * i % 360) % 360 : i > 360 && (i %= 360), i /= 360, (n = parseFloat(d[2])) < 0 || n > 100 || (n /= 100, (a = parseFloat(d[3])) < 0 || a > 100) || (a /= 100, void 0 !== (s = d[4]) && ((s = parseFloat(s)) < 0 || s > 1))) return;
		if (0 === n) o = l = u = Math.round(255 * a);
		else {
			var p = a < .5 ? a * (1 + n) : a + n - a * n, f = 2 * a - p;
			o = Math.round(255 * t(f, p, i + 1 / 3)), l = Math.round(255 * t(f, p, i)), u = Math.round(255 * t(f, p, i - 1 / 3));
		}
		r = [
			o,
			l,
			u,
			s
		];
	}
	return r;
}, "hsl2tuple"), Of = h(function(e) {
	var t, r = RegExp("^" + Oa + "$").exec(e);
	if (r) {
		t = [];
		for (var i = [], n = 1; n <= 3; n++) {
			var a = r[n];
			if ("%" === a[a.length - 1] && (i[n] = !0), a = parseFloat(a), i[n] && (a = a / 100 * 255), a < 0 || a > 255) return;
			t.push(Math.floor(a));
		}
		var s = i[1] || i[2] || i[3], o = i[1] && i[2] && i[3];
		if (s && !o) return;
		var l = r[4];
		if (void 0 !== l) {
			if ((l = parseFloat(l)) < 0 || l > 1) return;
			t.push(l);
		}
	}
	return t;
}, "rgb2tuple"), Og = h(function(e) {
	return Oy[e.toLowerCase()];
}, "colorname2tuple"), Om = h(function(e) {
	return (DW(e) ? e : null) || Og(e) || Od(e) || Of(e) || Op(e);
}, "color2tuple"), Oy = {
	transparent: [
		0,
		0,
		0,
		0
	],
	aliceblue: [
		240,
		248,
		255
	],
	antiquewhite: [
		250,
		235,
		215
	],
	aqua: [
		0,
		255,
		255
	],
	aquamarine: [
		127,
		255,
		212
	],
	azure: [
		240,
		255,
		255
	],
	beige: [
		245,
		245,
		220
	],
	bisque: [
		255,
		228,
		196
	],
	black: [
		0,
		0,
		0
	],
	blanchedalmond: [
		255,
		235,
		205
	],
	blue: [
		0,
		0,
		255
	],
	blueviolet: [
		138,
		43,
		226
	],
	brown: [
		165,
		42,
		42
	],
	burlywood: [
		222,
		184,
		135
	],
	cadetblue: [
		95,
		158,
		160
	],
	chartreuse: [
		127,
		255,
		0
	],
	chocolate: [
		210,
		105,
		30
	],
	coral: [
		255,
		127,
		80
	],
	cornflowerblue: [
		100,
		149,
		237
	],
	cornsilk: [
		255,
		248,
		220
	],
	crimson: [
		220,
		20,
		60
	],
	cyan: [
		0,
		255,
		255
	],
	darkblue: [
		0,
		0,
		139
	],
	darkcyan: [
		0,
		139,
		139
	],
	darkgoldenrod: [
		184,
		134,
		11
	],
	darkgray: [
		169,
		169,
		169
	],
	darkgreen: [
		0,
		100,
		0
	],
	darkgrey: [
		169,
		169,
		169
	],
	darkkhaki: [
		189,
		183,
		107
	],
	darkmagenta: [
		139,
		0,
		139
	],
	darkolivegreen: [
		85,
		107,
		47
	],
	darkorange: [
		255,
		140,
		0
	],
	darkorchid: [
		153,
		50,
		204
	],
	darkred: [
		139,
		0,
		0
	],
	darksalmon: [
		233,
		150,
		122
	],
	darkseagreen: [
		143,
		188,
		143
	],
	darkslateblue: [
		72,
		61,
		139
	],
	darkslategray: [
		47,
		79,
		79
	],
	darkslategrey: [
		47,
		79,
		79
	],
	darkturquoise: [
		0,
		206,
		209
	],
	darkviolet: [
		148,
		0,
		211
	],
	deeppink: [
		255,
		20,
		147
	],
	deepskyblue: [
		0,
		191,
		255
	],
	dimgray: [
		105,
		105,
		105
	],
	dimgrey: [
		105,
		105,
		105
	],
	dodgerblue: [
		30,
		144,
		255
	],
	firebrick: [
		178,
		34,
		34
	],
	floralwhite: [
		255,
		250,
		240
	],
	forestgreen: [
		34,
		139,
		34
	],
	fuchsia: [
		255,
		0,
		255
	],
	gainsboro: [
		220,
		220,
		220
	],
	ghostwhite: [
		248,
		248,
		255
	],
	gold: [
		255,
		215,
		0
	],
	goldenrod: [
		218,
		165,
		32
	],
	gray: [
		128,
		128,
		128
	],
	grey: [
		128,
		128,
		128
	],
	green: [
		0,
		128,
		0
	],
	greenyellow: [
		173,
		255,
		47
	],
	honeydew: [
		240,
		255,
		240
	],
	hotpink: [
		255,
		105,
		180
	],
	indianred: [
		205,
		92,
		92
	],
	indigo: [
		75,
		0,
		130
	],
	ivory: [
		255,
		255,
		240
	],
	khaki: [
		240,
		230,
		140
	],
	lavender: [
		230,
		230,
		250
	],
	lavenderblush: [
		255,
		240,
		245
	],
	lawngreen: [
		124,
		252,
		0
	],
	lemonchiffon: [
		255,
		250,
		205
	],
	lightblue: [
		173,
		216,
		230
	],
	lightcoral: [
		240,
		128,
		128
	],
	lightcyan: [
		224,
		255,
		255
	],
	lightgoldenrodyellow: [
		250,
		250,
		210
	],
	lightgray: [
		211,
		211,
		211
	],
	lightgreen: [
		144,
		238,
		144
	],
	lightgrey: [
		211,
		211,
		211
	],
	lightpink: [
		255,
		182,
		193
	],
	lightsalmon: [
		255,
		160,
		122
	],
	lightseagreen: [
		32,
		178,
		170
	],
	lightskyblue: [
		135,
		206,
		250
	],
	lightslategray: [
		119,
		136,
		153
	],
	lightslategrey: [
		119,
		136,
		153
	],
	lightsteelblue: [
		176,
		196,
		222
	],
	lightyellow: [
		255,
		255,
		224
	],
	lime: [
		0,
		255,
		0
	],
	limegreen: [
		50,
		205,
		50
	],
	linen: [
		250,
		240,
		230
	],
	magenta: [
		255,
		0,
		255
	],
	maroon: [
		128,
		0,
		0
	],
	mediumaquamarine: [
		102,
		205,
		170
	],
	mediumblue: [
		0,
		0,
		205
	],
	mediumorchid: [
		186,
		85,
		211
	],
	mediumpurple: [
		147,
		112,
		219
	],
	mediumseagreen: [
		60,
		179,
		113
	],
	mediumslateblue: [
		123,
		104,
		238
	],
	mediumspringgreen: [
		0,
		250,
		154
	],
	mediumturquoise: [
		72,
		209,
		204
	],
	mediumvioletred: [
		199,
		21,
		133
	],
	midnightblue: [
		25,
		25,
		112
	],
	mintcream: [
		245,
		255,
		250
	],
	mistyrose: [
		255,
		228,
		225
	],
	moccasin: [
		255,
		228,
		181
	],
	navajowhite: [
		255,
		222,
		173
	],
	navy: [
		0,
		0,
		128
	],
	oldlace: [
		253,
		245,
		230
	],
	olive: [
		128,
		128,
		0
	],
	olivedrab: [
		107,
		142,
		35
	],
	orange: [
		255,
		165,
		0
	],
	orangered: [
		255,
		69,
		0
	],
	orchid: [
		218,
		112,
		214
	],
	palegoldenrod: [
		238,
		232,
		170
	],
	palegreen: [
		152,
		251,
		152
	],
	paleturquoise: [
		175,
		238,
		238
	],
	palevioletred: [
		219,
		112,
		147
	],
	papayawhip: [
		255,
		239,
		213
	],
	peachpuff: [
		255,
		218,
		185
	],
	peru: [
		205,
		133,
		63
	],
	pink: [
		255,
		192,
		203
	],
	plum: [
		221,
		160,
		221
	],
	powderblue: [
		176,
		224,
		230
	],
	purple: [
		128,
		0,
		128
	],
	red: [
		255,
		0,
		0
	],
	rosybrown: [
		188,
		143,
		143
	],
	royalblue: [
		65,
		105,
		225
	],
	saddlebrown: [
		139,
		69,
		19
	],
	salmon: [
		250,
		128,
		114
	],
	sandybrown: [
		244,
		164,
		96
	],
	seagreen: [
		46,
		139,
		87
	],
	seashell: [
		255,
		245,
		238
	],
	sienna: [
		160,
		82,
		45
	],
	silver: [
		192,
		192,
		192
	],
	skyblue: [
		135,
		206,
		235
	],
	slateblue: [
		106,
		90,
		205
	],
	slategray: [
		112,
		128,
		144
	],
	slategrey: [
		112,
		128,
		144
	],
	snow: [
		255,
		250,
		250
	],
	springgreen: [
		0,
		255,
		127
	],
	steelblue: [
		70,
		130,
		180
	],
	tan: [
		210,
		180,
		140
	],
	teal: [
		0,
		128,
		128
	],
	thistle: [
		216,
		191,
		216
	],
	tomato: [
		255,
		99,
		71
	],
	turquoise: [
		64,
		224,
		208
	],
	violet: [
		238,
		130,
		238
	],
	wheat: [
		245,
		222,
		179
	],
	white: [
		255,
		255,
		255
	],
	whitesmoke: [
		245,
		245,
		245
	],
	yellow: [
		255,
		255,
		0
	],
	yellowgreen: [
		154,
		205,
		50
	]
}, Ov = h(function(e) {
	for (var t = e.map, r = e.keys, i = r.length, n = 0; n < i; n++) {
		var a = r[n];
		if (DY(a)) throw Error("Tried to set map with object key");
		n < r.length - 1 ? (t[a] ?? (t[a] = {}), t = t[a]) : t[a] = e.value;
	}
}, "setMap"), Ox = h(function(e) {
	for (var t = e.map, r = e.keys, i = r.length, n = 0; n < i; n++) {
		var a = r[n];
		if (DY(a)) throw Error("Tried to get map with object key");
		if (null == (t = t[a])) break;
	}
	return t;
}, "getMap"), Ob = "u" > typeof globalThis ? globalThis : "u" > typeof window ? window : "u" > typeof global ? global : "u" > typeof self ? self : {};
function Ow(e) {
	return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function Ok() {
	if ($w) return $b;
	function e(e) {
		var t = typeof e;
		return null != e && ("object" == t || "function" == t);
	}
	return $w = 1, h(e, "isObject"), $b = e;
}
function OT() {
	return $T ? $k : ($T = 1, $k = "object" == typeof Ob && Ob && Ob.Object === Object && Ob);
}
function O_() {
	if ($E) return $_;
	$E = 1;
	var e = OT(), t = "object" == typeof self && self && self.Object === Object && self;
	return $_ = e || t || Function("return this")();
}
function OE() {
	if ($S) return $C;
	$S = 1;
	var e = O_();
	return $C = h(function() {
		return e.Date.now();
	}, "now");
}
function OC() {
	if ($L) return $A;
	$L = 1;
	var e = /\s/;
	function t(t) {
		for (var r = t.length; r-- && e.test(t.charAt(r)););
		return r;
	}
	return h(t, "trimmedEndIndex"), $A = t;
}
function OS() {
	if ($N) return $R;
	$N = 1;
	var e = OC(), t = /^\s+/;
	function r(r) {
		return r && r.slice(0, e(r) + 1).replace(t, "");
	}
	return h(r, "baseTrim"), $R = r;
}
function OA() {
	return $M ? $I : ($M = 1, $I = O_().Symbol);
}
function OL() {
	if ($O) return $D;
	$O = 1;
	var e = OA(), t = Object.prototype, r = t.hasOwnProperty, i = t.toString, n = e ? e.toStringTag : void 0;
	function a(e) {
		var t = r.call(e, n), a = e[n];
		try {
			e[n] = void 0;
			var s = !0;
		} catch {}
		var o = i.call(e);
		return s && (t ? e[n] = a : delete e[n]), o;
	}
	return h(a, "getRawTag"), $D = a;
}
function OR() {
	if ($P) return $$;
	$P = 1;
	var e = Object.prototype.toString;
	function t(t) {
		return e.call(t);
	}
	return h(t, "objectToString"), $$ = t;
}
function ON() {
	if ($F) return $B;
	$F = 1;
	var e = OA(), t = OL(), r = OR(), i = e ? e.toStringTag : void 0;
	function n(e) {
		return null == e ? void 0 === e ? "[object Undefined]" : "[object Null]" : i && i in Object(e) ? t(e) : r(e);
	}
	return h(n, "baseGetTag"), $B = n;
}
function OI() {
	if ($U) return $z;
	function e(e) {
		return null != e && "object" == typeof e;
	}
	return $U = 1, h(e, "isObjectLike"), $z = e;
}
function OM() {
	if ($q) return $G;
	$q = 1;
	var e = ON(), t = OI();
	function r(r) {
		return "symbol" == typeof r || t(r) && "[object Symbol]" == e(r);
	}
	return h(r, "isSymbol"), $G = r;
}
function OD() {
	if ($W) return $j;
	$W = 1;
	var e = OS(), t = Ok(), r = OM(), i = NaN, n = /^[-+]0x[0-9a-f]+$/i, a = /^0b[01]+$/i, s = /^0o[0-7]+$/i, o = parseInt;
	function l(l) {
		if ("number" == typeof l) return l;
		if (r(l)) return i;
		if (t(l)) {
			var h = "function" == typeof l.valueOf ? l.valueOf() : l;
			l = t(h) ? h + "" : h;
		}
		if ("string" != typeof l) return 0 === l ? l : +l;
		l = e(l);
		var u = a.test(l);
		return u || s.test(l) ? o(l.slice(2), u ? 2 : 8) : n.test(l) ? i : +l;
	}
	return h(l, "toNumber"), $j = l;
}
function OO() {
	if ($V) return $Y;
	$V = 1;
	var e = Ok(), t = OE(), r = OD(), i = Math.max, n = Math.min;
	function a(a, s, o) {
		var l, u, d, p, f, g, m = 0, y = !1, v = !1, x = !0;
		if ("function" != typeof a) throw TypeError("Expected a function");
		function b(e) {
			var t = l, r = u;
			return l = u = void 0, m = e, p = a.apply(r, t);
		}
		function w(e) {
			return m = e, f = setTimeout(_, s), y ? b(e) : p;
		}
		function k(e) {
			var t = e - g, r = e - m, i = s - t;
			return v ? n(i, d - r) : i;
		}
		function T(e) {
			var t = e - g, r = e - m;
			return void 0 === g || t >= s || t < 0 || v && r >= d;
		}
		function _() {
			var e = t();
			if (T(e)) return E(e);
			f = setTimeout(_, k(e));
		}
		function E(e) {
			return f = void 0, x && l ? b(e) : (l = u = void 0, p);
		}
		function C() {
			void 0 !== f && clearTimeout(f), m = 0, l = g = u = f = void 0;
		}
		function S() {
			return void 0 === f ? p : E(t());
		}
		function A() {
			var e = t(), r = T(e);
			if (l = arguments, u = this, g = e, r) {
				if (void 0 === f) return w(g);
				if (v) return clearTimeout(f), f = setTimeout(_, s), b(g);
			}
			return void 0 === f && (f = setTimeout(_, s)), p;
		}
		return s = r(s) || 0, e(o) && (y = !!o.leading, d = (v = "maxWait" in o) ? i(r(o.maxWait) || 0, s) : d, x = "trailing" in o ? !!o.trailing : x), h(b, "invokeFunc"), h(w, "leadingEdge"), h(k, "remainingWait"), h(T, "shouldInvoke"), h(_, "timerExpired"), h(E, "trailingEdge"), h(C, "cancel"), h(S, "flush"), h(A, "debounced"), A.cancel = C, A.flush = S, A;
	}
	return h(a, "debounce"), $Y = a;
}
h(Ow, "getDefaultExportFromCjs"), h(Ok, "requireIsObject"), h(OT, "require_freeGlobal"), h(O_, "require_root"), h(OE, "requireNow"), h(OC, "require_trimmedEndIndex"), h(OS, "require_baseTrim"), h(OA, "require_Symbol"), h(OL, "require_getRawTag"), h(OR, "require_objectToString"), h(ON, "require_baseGetTag"), h(OI, "requireIsObjectLike"), h(OM, "requireIsSymbol"), h(OD, "requireToNumber"), h(OO, "requireDebounce");
var O$ = Ow(OO()), OP = D$ ? D$.performance : null, OB = OP && OP.now ? function() {
	return OP.now();
} : function() {
	return Date.now();
}, OF = function() {
	if (D$) {
		if (D$.requestAnimationFrame) return function(e) {
			D$.requestAnimationFrame(e);
		};
		if (D$.mozRequestAnimationFrame) return function(e) {
			D$.mozRequestAnimationFrame(e);
		};
		if (D$.webkitRequestAnimationFrame) return function(e) {
			D$.webkitRequestAnimationFrame(e);
		};
		if (D$.msRequestAnimationFrame) return function(e) {
			D$.msRequestAnimationFrame(e);
		};
	}
	return function(e) {
		e && setTimeout(function() {
			e(OB());
		}, 1e3 / 60);
	};
}(), Oz = h(function(e) {
	return OF(e);
}, "requestAnimationFrame"), OU = h(function(e) {
	for (var t, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 9261; !(t = e.next()).done;) r = 65599 * r + t.value | 0;
	return r;
}, "hashIterableInts"), OG = h(function(e) {
	return (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 9261) * 65599 + e | 0;
}, "hashInt"), Oq = h(function(e) {
	var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5381;
	return (t << 5) + t + e | 0;
}, "hashIntAlt"), Oj = h(function(e, t) {
	return 2097152 * e + t;
}, "combineHashes"), OW = h(function(e) {
	return 2097152 * e[0] + e[1];
}, "combineHashesArray"), OY = h(function(e, t) {
	return [OG(e[0], t[0]), Oq(e[1], t[1])];
}, "hashArrays"), OV = h(function(e, t) {
	var r = {
		value: 0,
		done: !1
	}, i = 0, n = e.length;
	return OU({ next: h(function() {
		return i < n ? r.value = e[i++] : r.done = !0, r;
	}, "next") }, t);
}, "hashIntsArray"), OH = h(function(e, t) {
	var r = {
		value: 0,
		done: !1
	}, i = 0, n = e.length;
	return OU({ next: h(function() {
		return i < n ? r.value = e.charCodeAt(i++) : r.done = !0, r;
	}, "next") }, t);
}, "hashString"), OX = h(function() {
	return OK(arguments);
}, "hashStrings"), OK = h(function(e) {
	for (var t, r = 0; r < e.length; r++) {
		var i = e[r];
		t = 0 === r ? OH(i) : OH(i, t);
	}
	return t;
}, "hashStringsArray");
function OZ(e, t, r, i, n) {
	var a = n * Math.PI / 180;
	return {
		x: Math.cos(a) * (e - r) - Math.sin(a) * (t - i) + r,
		y: Math.sin(a) * (e - r) + Math.cos(a) * (t - i) + i
	};
}
h(OZ, "rotatePoint");
var OQ = h(function(e, t, r, i, n, a) {
	return {
		x: (e - r) * n + r,
		y: (t - i) * a + i
	};
}, "movePointByBoxAspect");
function OJ(e, t, r) {
	if (0 === r) return e;
	var i = (t.x1 + t.x2) / 2, n = (t.y1 + t.y2) / 2, a = t.w / t.h, s = OZ(e.x, e.y, i, n, r), o = OQ(s.x, s.y, i, n, a, 1 / a);
	return {
		x: o.x,
		y: o.y
	};
}
h(OJ, "rotatePosAndSkewByBox");
var O0 = !0, O1 = null != console.warn, O2 = null != console.trace, O4 = Number.MAX_SAFE_INTEGER || 9007199254740991, O5 = h(function() {
	return !0;
}, "trueify"), O3 = h(function() {
	return !1;
}, "falsify"), O6 = h(function() {
	return 0;
}, "zeroify"), O7 = h(function() {}, "noop"), O8 = h(function(e) {
	throw Error(e);
}, "error"), O9 = h(function(e) {
	if (void 0 === e) return O0;
	O0 = !!e;
}, "warnings"), $e = h(function(e) {
	O9() && (O1 ? console.warn(e) : (console.log(e), O2 && console.trace()));
}, "warn"), $t = h(function(e) {
	return Ou({}, e);
}, "clone"), $r = h(function(e) {
	return null == e ? e : DW(e) ? e.slice() : DY(e) ? $t(e) : e;
}, "copy"), $i = h(function(e) {
	return e.slice();
}, "copyArray"), $n = h(function(e, t) {
	for (t = e = ""; e++ < 36; t += 51 * e & 52 ? (15 ^ e ? 8 ^ Math.random() * (20 ^ e ? 16 : 4) : 4).toString(16) : "-");
	return t;
}, "uuid"), $a = {}, $s = h(function() {
	return $a;
}, "staticEmptyObject"), $o = h(function(e) {
	var t = Object.keys(e);
	return function(r) {
		for (var i = {}, n = 0; n < t.length; n++) {
			var a = t[n], s = r?.[a];
			i[a] = void 0 === s ? e[a] : s;
		}
		return i;
	};
}, "defaults"), $l = h(function(e, t, r) {
	for (var i = e.length - 1; i >= 0; i--) e[i] === t && e.splice(i, 1);
}, "removeFromArray"), $c = h(function(e) {
	e.splice(0, e.length);
}, "clearArray"), $h = h(function(e, t) {
	for (var r = 0; r < t.length; r++) {
		var i = t[r];
		e.push(i);
	}
}, "push"), $u = h(function(e, t, r) {
	return r && (t = Ot(r, t)), e[t];
}, "getPrefixedProperty"), $d = h(function(e, t, r, i) {
	r && (t = Ot(r, t)), e[t] = i;
}, "setPrefixedProperty"), $p = function() {
	function e() {
		Dw(this, e), this._obj = {};
	}
	return h(e, "ObjectMap"), DT(e, [
		{
			key: "set",
			value: h(function(e, t) {
				return this._obj[e] = t, this;
			}, "set")
		},
		{
			key: "delete",
			value: h(function(e) {
				return this._obj[e] = void 0, this;
			}, "_delete")
		},
		{
			key: "clear",
			value: h(function() {
				this._obj = {};
			}, "clear")
		},
		{
			key: "has",
			value: h(function(e) {
				return void 0 !== this._obj[e];
			}, "has")
		},
		{
			key: "get",
			value: h(function(e) {
				return this._obj[e];
			}, "get")
		}
	]);
}(), $f = "u" > typeof Map ? Map : $p, $g = function() {
	function e(t) {
		if (Dw(this, e), this._obj = Object.create(null), this.size = 0, null != t) {
			var r = null != t.instanceString && t.instanceString() === this.instanceString() ? t.toArray() : t;
			for (var i = 0; i < r.length; i++) this.add(r[i]);
		}
	}
	return h(e, "ObjectSet"), DT(e, [
		{
			key: "instanceString",
			value: h(function() {
				return "set";
			}, "instanceString")
		},
		{
			key: "add",
			value: h(function(e) {
				var t = this._obj;
				1 !== t[e] && (t[e] = 1, this.size++);
			}, "add")
		},
		{
			key: "delete",
			value: h(function(e) {
				var t = this._obj;
				1 === t[e] && (t[e] = 0, this.size--);
			}, "_delete")
		},
		{
			key: "clear",
			value: h(function() {
				this._obj = Object.create(null);
			}, "clear")
		},
		{
			key: "has",
			value: h(function(e) {
				return 1 === this._obj[e];
			}, "has")
		},
		{
			key: "toArray",
			value: h(function() {
				var e = this;
				return Object.keys(this._obj).filter(function(t) {
					return e.has(t);
				});
			}, "toArray")
		},
		{
			key: "forEach",
			value: h(function(e, t) {
				return this.toArray().forEach(e, t);
			}, "forEach")
		}
	]);
}(), $m = (typeof Set > "u" ? "undefined" : DD(Set)) !== "undefined" ? Set : $g, $y = h(function(e, t) {
	var r = !(arguments.length > 2) || void 0 === arguments[2] || arguments[2];
	if (void 0 === e || void 0 === t || !D0(e)) return void O8("An element must have a core reference and parameters set");
	var i = t.group;
	if (i ?? (i = t.data && null != t.data.source && null != t.data.target ? "edges" : "nodes"), "nodes" !== i && "edges" !== i) return void O8("An element must be of type `nodes` or `edges`; you specified `" + i + "`");
	this.length = 1, this[0] = this;
	var n = this._private = {
		cy: e,
		single: !0,
		data: t.data || {},
		position: t.position || {
			x: 0,
			y: 0
		},
		autoWidth: void 0,
		autoHeight: void 0,
		autoPadding: void 0,
		compoundBoundsClean: !1,
		listeners: [],
		group: i,
		style: {},
		rstyle: {},
		styleCxts: [],
		styleKeys: {},
		removed: !0,
		selected: !!t.selected,
		selectable: void 0 === t.selectable || !!t.selectable,
		locked: !!t.locked,
		grabbed: !1,
		grabbable: void 0 === t.grabbable || !!t.grabbable,
		pannable: void 0 === t.pannable ? "edges" === i : !!t.pannable,
		active: !1,
		classes: new $m(),
		animation: {
			current: [],
			queue: []
		},
		rscratch: {},
		scratch: t.scratch || {},
		edges: [],
		children: [],
		parent: t.parent && t.parent.isNode() ? t.parent : null,
		traversalCache: {},
		backgrounding: !1,
		bbCache: null,
		bbCacheShift: {
			x: 0,
			y: 0
		},
		bodyBounds: null,
		overlayBounds: null,
		labelBounds: {
			all: null,
			source: null,
			target: null,
			main: null
		},
		arrowBounds: {
			source: null,
			target: null,
			"mid-source": null,
			"mid-target": null
		}
	};
	if (n.position.x ?? (n.position.x = 0), n.position.y ?? (n.position.y = 0), t.renderedPosition) {
		var a = t.renderedPosition, s = e.pan(), o = e.zoom();
		n.position = {
			x: (a.x - s.x) / o,
			y: (a.y - s.y) / o
		};
	}
	var l = [];
	DW(t.classes) ? l = t.classes : Dq(t.classes) && (l = t.classes.split(/\s+/));
	for (var h = 0, u = l.length; h < u; h++) {
		var d = l[h];
		d && "" !== d && n.classes.add(d);
	}
	this.createEmitter(), (void 0 === r || r) && this.restore();
	var p = t.style || t.css;
	p && ($e("Setting a `style` bypass at element creation should be done only when absolutely necessary.  Try to use the stylesheet instead."), this.style(p));
}, "Element"), $v = h(function(e) {
	return e = {
		bfs: e.bfs || !e.dfs,
		dfs: e.dfs || !e.bfs
	}, h(function(t, r, i) {
		DY(t) && !DZ(t) && (t = (n = t).roots || n.root, r = n.visit, i = n.directed), i = 2 != arguments.length || Dj(r) ? i : r, r = Dj(r) ? r : function() {};
		for (var n, a, s = this._private.cy, o = t = Dq(t) ? this.filter(t) : t, l = [], u = [], d = {}, p = {}, f = {}, g = 0, m = this.byGroup(), y = m.nodes, v = m.edges, x = 0; x < o.length; x++) {
			var b = o[x], w = b.id();
			b.isNode() && (l.unshift(b), e.bfs && (f[w] = !0, u.push(b)), p[w] = 0);
		}
		for (var k, T = h(function() {
			var t = e.bfs ? l.shift() : l.pop(), n = t.id();
			if (e.dfs) {
				if (f[n]) return 0;
				f[n] = !0, u.push(t);
			}
			var s, o = p[n], h = d[n], m = null != h ? h.source() : null, x = null != h ? h.target() : null, b = null == h ? void 0 : t.same(m) ? x[0] : m[0];
			if (!0 === (s = r(t, h, b, g++, o))) return a = t, 1;
			if (!1 === s) return 1;
			for (var w = t.connectedEdges().filter(function(e) {
				return (!i || e.source().same(t)) && v.has(e);
			}), k = 0; k < w.length; k++) {
				var T = w[k], _ = T.connectedNodes().filter(function(e) {
					return !e.same(t) && y.has(e);
				}), E = _.id();
				0 === _.length || f[E] || (_ = _[0], l.push(_), e.bfs && (f[E] = !0, u.push(_)), d[E] = T, p[E] = p[n] + 1);
			}
		}, "_loop"); 0 !== l.length && (0 === (k = T()) || 1 !== k););
		for (var _ = s.collection(), E = 0; E < u.length; E++) {
			var C = u[E], S = d[C.id()];
			null != S && _.push(S), _.push(C);
		}
		return {
			path: s.collection(_),
			found: s.collection(a)
		};
	}, "searchFn");
}, "defineSearch"), $x = {
	breadthFirstSearch: $v({ bfs: !0 }),
	depthFirstSearch: $v({ dfs: !0 })
};
$x.bfs = $x.breadthFirstSearch, $x.dfs = $x.depthFirstSearch;
var $b, $w, $k, $T, $_, $E, $C, $S, $A, $L, $R, $N, $I, $M, $D, $O, $$, $P, $B, $F, $z, $U, $G, $q, $j, $W, $Y, $V, $H, $X = { exports: {} }, $K = $X.exports;
function $Z() {
	return $H || ($H = 1, (function() {
		var e, t, r, i, n, a, s, o, l, u, d, p, f, g = Math.floor, m = Math.min;
		t = h(function(e, t) {
			return e < t ? -1 : +(e > t);
		}, "defaultCmp"), o = h(function(e, r, i, n, a) {
			var s;
			if (i ??= 0, a ??= t, i < 0) throw Error("lo must be non-negative");
			for (n ??= e.length; i < n;) 0 > a(r, e[s = g((i + n) / 2)]) ? n = s : i = s + 1;
			return [].splice.apply(e, [i, i - i].concat(r)), r;
		}, "insort"), n = h(function(e, r, i) {
			return i ??= t, e.push(r), p(e, 0, e.length - 1, i);
		}, "heappush"), i = h(function(e, r) {
			var i, n;
			return r ??= t, i = e.pop(), e.length ? (n = e[0], e[0] = i, f(e, 0, r)) : n = i, n;
		}, "heappop"), s = h(function(e, r, i) {
			var n;
			return i ??= t, n = e[0], e[0] = r, f(e, 0, i), n;
		}, "heapreplace"), a = h(function(e, r, i) {
			var n;
			return i ??= t, e.length && 0 > i(e[0], r) && (r = (n = [e[0], r])[0], e[0] = n[1], f(e, 0, i)), r;
		}, "heappushpop"), r = h(function(e, r) {
			var i, n, a, s, o, l;
			for (r ??= t, s = (function() {
				l = [];
				for (var t = 0, r = g(e.length / 2); 0 <= r ? t < r : t > r; 0 <= r ? t++ : t--) l.push(t);
				return l;
			}).apply(this).reverse(), o = [], n = 0, a = s.length; n < a; n++) i = s[n], o.push(f(e, i, r));
			return o;
		}, "heapify"), d = h(function(e, r, i) {
			var n;
			if (i ??= t, -1 !== (n = e.indexOf(r))) return p(e, 0, n, i), f(e, n, i);
		}, "updateItem"), l = h(function(e, i, n) {
			var s, o, l, h;
			if (n ??= t, !(s = e.slice(0, i)).length) return s;
			for (r(s, n), h = e.slice(i), o = 0, l = h.length; o < l; o++) a(s, h[o], n);
			return s.sort(n).reverse();
		}, "nlargest"), u = h(function(e, n, a) {
			var s, l, h, u, d, p, f, g, y;
			if (a ??= t, 10 * n <= e.length) {
				if (!(h = e.slice(0, n).sort(a)).length) return h;
				for (l = h[h.length - 1], f = e.slice(n), u = 0, p = f.length; u < p; u++) 0 > a(s = f[u], l) && (o(h, s, 0, null, a), h.pop(), l = h[h.length - 1]);
				return h;
			}
			for (r(e, a), y = [], d = 0, g = m(n, e.length); 0 <= g ? d < g : d > g; 0 <= g ? ++d : --d) y.push(i(e, a));
			return y;
		}, "nsmallest"), p = h(function(e, r, i, n) {
			var a, s, o;
			for (n ??= t, a = e[i]; i > r;) {
				if (0 > n(a, s = e[o = i - 1 >> 1])) {
					e[i] = s, i = o;
					continue;
				}
				break;
			}
			return e[i] = a;
		}, "_siftdown"), f = h(function(e, r, i) {
			var n, a, s, o, l;
			for (i ??= t, a = e.length, l = r, s = e[r], n = 2 * r + 1; n < a;) (o = n + 1) < a && !(0 > i(e[n], e[o])) && (n = o), e[r] = e[n], n = 2 * (r = n) + 1;
			return e[r] = s, p(e, l, r, i);
		}, "_siftup"), e = function() {
			function e(e) {
				this.cmp = e ?? t, this.nodes = [];
			}
			return e.push = n, e.pop = i, e.replace = s, e.pushpop = a, e.heapify = r, e.updateItem = d, e.nlargest = l, e.nsmallest = u, h(e, "Heap"), e.prototype.push = function(e) {
				return n(this.nodes, e, this.cmp);
			}, e.prototype.pop = function() {
				return i(this.nodes, this.cmp);
			}, e.prototype.peek = function() {
				return this.nodes[0];
			}, e.prototype.contains = function(e) {
				return -1 !== this.nodes.indexOf(e);
			}, e.prototype.replace = function(e) {
				return s(this.nodes, e, this.cmp);
			}, e.prototype.pushpop = function(e) {
				return a(this.nodes, e, this.cmp);
			}, e.prototype.heapify = function() {
				return r(this.nodes, this.cmp);
			}, e.prototype.updateItem = function(e) {
				return d(this.nodes, e, this.cmp);
			}, e.prototype.clear = function() {
				return this.nodes = [];
			}, e.prototype.empty = function() {
				return 0 === this.nodes.length;
			}, e.prototype.size = function() {
				return this.nodes.length;
			}, e.prototype.clone = function() {
				var t;
				return (t = new e()).nodes = this.nodes.slice(0), t;
			}, e.prototype.toArray = function() {
				return this.nodes.slice(0);
			}, e.prototype.insert = e.prototype.push, e.prototype.top = e.prototype.peek, e.prototype.front = e.prototype.peek, e.prototype.has = e.prototype.contains, e.prototype.copy = e.prototype.clone, e;
		}(), $X.exports = e;
	}).call($K)), $X.exports;
}
function $Q() {
	return $0 || ($0 = 1, $J = $Z()), $J;
}
h($Z, "requireHeap$1"), h($Q, "requireHeap");
var $J, $0, $1, $2 = Ow($Q()), $4 = $o({
	root: null,
	weight: h(function(e) {
		return 1;
	}, "weight"),
	directed: !1
}), $5 = { dijkstra: h(function(e) {
	if (!DY(e)) {
		var t = arguments;
		e = {
			root: t[0],
			weight: t[1],
			directed: t[2]
		};
	}
	var r = $4(e), i = r.root, n = r.weight, a = r.directed, s = this, o = Dq(i) ? this.filter(i)[0] : i[0], l = {}, u = {}, d = {}, p = this.byGroup(), f = p.nodes, g = p.edges;
	g.unmergeBy(function(e) {
		return e.isLoop();
	});
	for (var m = h(function(e) {
		return l[e.id()];
	}, "getDist"), y = h(function(e, t) {
		l[e.id()] = t, v.updateItem(e);
	}, "setDist"), v = new $2(function(e, t) {
		return m(e) - m(t);
	}), x = 0; x < f.length; x++) {
		var b = f[x];
		l[b.id()] = b.same(o) ? 0 : Infinity, v.push(b);
	}
	for (var w = h(function(e, t) {
		for (var r, i = (a ? e.edgesTo(t) : e.edgesWith(t)).intersect(g), s = Infinity, o = 0; o < i.length; o++) {
			var l = i[o], h = n(l);
			(h < s || !r) && (s = h, r = l);
		}
		return {
			edge: r,
			dist: s
		};
	}, "distBetween"); v.size() > 0;) {
		var k = v.pop(), T = m(k);
		if (d[k.id()] = T, T !== Infinity) for (var _ = k.neighborhood().intersect(f), E = 0; E < _.length; E++) {
			var C = _[E], S = C.id(), A = w(k, C), L = T + A.dist;
			L < m(C) && (y(C, L), u[S] = {
				node: k,
				edge: A.edge
			});
		}
	}
	return {
		distanceTo: h(function(e) {
			return d[(Dq(e) ? f.filter(e)[0] : e[0]).id()];
		}, "distanceTo"),
		pathTo: h(function(e) {
			var t = Dq(e) ? f.filter(e)[0] : e[0], r = [], i = t, n = i.id();
			if (t.length > 0) for (r.unshift(t); u[n];) {
				var a = u[n];
				r.unshift(a.edge), r.unshift(a.node), n = (i = a.node).id();
			}
			return s.spawn(r);
		}, "pathTo")
	};
}, "dijkstra") }, $3 = { kruskal: h(function(e) {
	e = e || function(e) {
		return 1;
	};
	for (var t = this.byGroup(), r = t.nodes, i = t.edges, n = r.length, a = Array(n), s = h(function(e) {
		for (var t = 0; t < a.length; t++) if (a[t].has(e)) return t;
	}, "findSetIndex"), o = 0; o < n; o++) a[o] = this.spawn(r[o]);
	for (var l = i.sort(function(t, r) {
		return e(t) - e(r);
	}), u = 0; u < l.length; u++) {
		var d = l[u], p = d.source()[0], f = d.target()[0], g = s(p), m = s(f), y = a[g], v = a[m];
		g !== m && (r.merge(d), y.merge(v), a.splice(m, 1));
	}
	return r;
}, "kruskal") }, $6 = $o({
	root: null,
	goal: null,
	weight: h(function(e) {
		return 1;
	}, "weight"),
	heuristic: h(function(e) {
		return 0;
	}, "heuristic"),
	directed: !1
}), $7 = { aStar: h(function(e) {
	var t = this.cy(), r = $6(e), i = r.root, n = r.goal, a = r.heuristic, s = r.directed, o = r.weight;
	i = t.collection(i)[0], n = t.collection(n)[0];
	var l, u, d = i.id(), p = n.id(), f = {}, g = {}, m = {}, y = new $2(function(e, t) {
		return g[e.id()] - g[t.id()];
	}), v = new $m(), x = {}, b = {}, w = h(function(e, t) {
		y.push(e), v.add(t);
	}, "addToOpenSet"), k = h(function() {
		u = (l = y.pop()).id(), v.delete(u);
	}, "popFromOpenSet"), T = h(function(e) {
		return v.has(e);
	}, "isInOpenSet");
	w(i, d), f[d] = 0, g[d] = a(i);
	for (var _ = 0; y.size() > 0;) {
		if (k(), _++, u === p) {
			for (var E = [], C = n, S = p, A = b[S]; E.unshift(C), null != A && E.unshift(A), null != (C = x[S]);) A = b[S = C.id()];
			return {
				found: !0,
				distance: f[u],
				path: this.spawn(E),
				steps: _
			};
		}
		m[u] = !0;
		for (var L = l._private.edges, R = 0; R < L.length; R++) {
			var N = L[R];
			if (this.hasElementWithId(N.id()) && !(s && N.data("source") !== u)) {
				var I = N.source(), M = N.target(), D = I.id() !== u ? I : M, O = D.id();
				if (this.hasElementWithId(O) && !m[O]) {
					var $ = f[u] + o(N);
					if (!T(O)) {
						f[O] = $, g[O] = $ + a(D), w(D, O), x[O] = l, b[O] = N;
						continue;
					}
					$ < f[O] && (f[O] = $, g[O] = $ + a(D), x[O] = l, b[O] = N);
				}
			}
		}
	}
	return {
		found: !1,
		distance: void 0,
		path: void 0,
		steps: _
	};
}, "aStar") }, $8 = $o({
	weight: h(function(e) {
		return 1;
	}, "weight"),
	directed: !1
}), $9 = { floydWarshall: h(function(e) {
	for (var t = this.cy(), r = $8(e), i = r.weight, n = r.directed, a = this.byGroup(), s = a.nodes, o = a.edges, l = s.length, u = l * l, d = h(function(e) {
		return s.indexOf(e);
	}, "indexOf"), p = h(function(e) {
		return s[e];
	}, "atIndex"), f = Array(u), g = 0; g < u; g++) {
		var m = g % l;
		(g - m) / l === m ? f[g] = 0 : f[g] = Infinity;
	}
	for (var y = Array(u), v = Array(u), x = 0; x < o.length; x++) {
		var b = o[x], w = b.source()[0], k = b.target()[0];
		if (w !== k) {
			var T = d(w), _ = d(k), E = T * l + _, C = i(b);
			if (f[E] > C && (f[E] = C, y[E] = _, v[E] = b), !n) {
				var S = _ * l + T;
				!n && f[S] > C && (f[S] = C, y[S] = T, v[S] = b);
			}
		}
	}
	for (var A = 0; A < l; A++) for (var L = 0; L < l; L++) for (var R = L * l + A, N = 0; N < l; N++) {
		var I = L * l + N, M = A * l + N;
		f[R] + f[M] < f[I] && (f[I] = f[R] + f[M], y[I] = y[R]);
	}
	var D = h(function(e) {
		return (Dq(e) ? t.filter(e) : e)[0];
	}, "getArgEle"), O = h(function(e) {
		return d(D(e));
	}, "indexOfArgEle");
	return {
		distance: h(function(e, t) {
			return f[O(e) * l + O(t)];
		}, "distance"),
		path: h(function(e, r) {
			var i = O(e), n = O(r), a = p(i);
			if (i === n) return a.collection();
			if (null == y[i * l + n]) return t.collection();
			var s, o = t.collection(), h = i;
			for (o.merge(a); i !== n;) h = i, i = y[i * l + n], s = v[h * l + i], o.merge(s), o.merge(p(i));
			return o;
		}, "path")
	};
}, "floydWarshall") }, Pe = $o({
	weight: h(function(e) {
		return 1;
	}, "weight"),
	directed: !1,
	root: null
}), Pt = { bellmanFord: h(function(e) {
	var t = this, r = Pe(e), i = r.weight, n = r.directed, a = r.root, s = this, o = this.cy(), l = this.byGroup(), u = l.edges, d = l.nodes, p = d.length, f = new $f(), g = !1, m = [];
	a = o.collection(a)[0], u.unmergeBy(function(e) {
		return e.isLoop();
	});
	for (var y = u.length, v = h(function(e) {
		var t = f.get(e.id());
		return t || (t = {}, f.set(e.id(), t)), t;
	}, "getInfo"), x = h(function(e) {
		return (Dq(e) ? o.$(e) : e)[0];
	}, "getNodeFromTo"), b = h(function(e) {
		return v(x(e)).dist;
	}, "distanceTo"), w = h(function(e) {
		for (var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : a, i = x(e), n = [], o = i;;) {
			if (null == o) return t.spawn();
			var l = v(o), h = l.edge, u = l.pred;
			if (n.unshift(o[0]), o.same(r) && n.length > 0) break;
			null != h && n.unshift(h), o = u;
		}
		return s.spawn(n);
	}, "pathTo"), k = 0; k < p; k++) {
		var T = d[k], _ = v(T);
		T.same(a) ? _.dist = 0 : _.dist = Infinity, _.pred = null, _.edge = null;
	}
	for (var E = !1, C = h(function(e, t, r, i, n, a) {
		var s = i.dist + a;
		s < n.dist && !r.same(i.edge) && (n.dist = s, n.pred = e, n.edge = r, E = !0);
	}, "checkForEdgeReplacement"), S = 1; S < p; S++) {
		E = !1;
		for (var A = 0; A < y; A++) {
			var L = u[A], R = L.source(), N = L.target(), I = i(L), M = v(R), D = v(N);
			C(R, N, L, M, D, I), n || C(N, R, L, D, M, I);
		}
		if (!E) break;
	}
	if (E) for (var O = [], $ = 0; $ < y; $++) {
		var P = u[$], B = P.source(), F = P.target(), z = i(P), U = v(B).dist, G = v(F).dist;
		if (U + z < G || !n && G + z < U) if (g || ($e("Graph contains a negative weight cycle for Bellman-Ford"), g = !0), !1 !== e.findNegativeWeightCycles) {
			var q = [];
			U + z < G && q.push(B), !n && G + z < U && q.push(F);
			for (var j = q.length, W = 0; W < j; W++) {
				var Y = q[W], V = [Y];
				V.push(v(Y).edge);
				for (var H = v(Y).pred; -1 === V.indexOf(H);) V.push(H), V.push(v(H).edge), H = v(H).pred;
				V = V.slice(V.indexOf(H));
				for (var X = V[0].id(), K = 0, Z = 2; Z < V.length; Z += 2) V[Z].id() < X && (X = V[Z].id(), K = Z);
				(V = V.slice(K).concat(V.slice(0, K))).push(V[0]);
				var Q = V.map(function(e) {
					return e.id();
				}).join(",");
				-1 === O.indexOf(Q) && (m.push(s.spawn(V)), O.push(Q));
			}
		} else break;
	}
	return {
		distanceTo: b,
		pathTo: w,
		hasNegativeWeightCycle: g,
		negativeWeightCycles: m
	};
}, "bellmanFord") }, Pr = Math.sqrt(2), Pi = h(function(e, t, r) {
	0 === r.length && O8("Karger-Stein must be run on a connected (sub)graph");
	for (var i = r[e], n = i[1], a = i[2], s = t[n], o = t[a], l = r.length - 1; l >= 0; l--) {
		var h = r[l], u = h[1], d = h[2];
		(t[u] === s && t[d] === o || t[u] === o && t[d] === s) && r.splice(l, 1);
	}
	for (var p = 0; p < r.length; p++) {
		var f = r[p];
		f[1] === o ? (r[p] = f.slice(), r[p][1] = s) : f[2] === o && (r[p] = f.slice(), r[p][2] = s);
	}
	for (var g = 0; g < t.length; g++) t[g] === o && (t[g] = s);
	return r;
}, "collapse"), Pn = h(function(e, t, r, i) {
	for (; r > i;) t = Pi(Math.floor(Math.random() * t.length), e, t), r--;
	return t;
}, "contractUntil"), Pa = { kargerStein: h(function() {
	var e = this, t = this.byGroup(), r = t.nodes, i = t.edges;
	i.unmergeBy(function(e) {
		return e.isLoop();
	});
	var n = r.length, a = i.length, s = Math.ceil(Math.pow(Math.log(n) / Math.LN2, 2)), o = Math.floor(n / Pr);
	if (n < 2) return void O8("At least 2 nodes are required for Karger-Stein algorithm");
	for (var l = [], u = 0; u < a; u++) {
		var d = i[u];
		l.push([
			u,
			r.indexOf(d.source()),
			r.indexOf(d.target())
		]);
	}
	for (var p = Infinity, f = [], g = Array(n), m = Array(n), y = Array(n), v = h(function(e, t) {
		for (var r = 0; r < n; r++) t[r] = e[r];
	}, "copyNodesMap"), x = 0; x <= s; x++) {
		for (var b = 0; b < n; b++) m[b] = b;
		var w = Pn(m, l.slice(), n, o), k = w.slice();
		v(m, y);
		var T = Pn(m, w, o, 2), _ = Pn(y, k, o, 2);
		T.length <= _.length && T.length < p ? (p = T.length, f = T, v(m, g)) : _.length <= T.length && _.length < p && (p = _.length, f = _, v(y, g));
	}
	for (var E = this.spawn(f.map(function(e) {
		return i[e[0]];
	})), C = this.spawn(), S = this.spawn(), A = g[0], L = 0; L < g.length; L++) {
		var R = g[L], N = r[L];
		R === A ? C.merge(N) : S.merge(N);
	}
	var I = h(function(t) {
		var r = e.spawn();
		return t.forEach(function(t) {
			r.merge(t), t.connectedEdges().forEach(function(t) {
				e.contains(t) && !E.contains(t) && r.merge(t);
			});
		}), r;
	}, "constructComponent");
	return {
		cut: E,
		components: [I(C), I(S)],
		partition1: C,
		partition2: S
	};
}, "kargerStein") }, Ps = h(function(e) {
	return {
		x: e.x,
		y: e.y
	};
}, "copyPosition"), Po = h(function(e, t, r) {
	return {
		x: e.x * t + r.x,
		y: e.y * t + r.y
	};
}, "modelToRenderedPosition"), Pl = h(function(e, t, r) {
	return {
		x: (e.x - r.x) / t,
		y: (e.y - r.y) / t
	};
}, "renderedToModelPosition"), Pc = h(function(e) {
	return {
		x: e[0],
		y: e[1]
	};
}, "array2point"), Ph = h(function(e) {
	for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e.length, i = Infinity, n = t; n < r; n++) {
		var a = e[n];
		isFinite(a) && (i = Math.min(a, i));
	}
	return i;
}, "min"), Pu = h(function(e) {
	for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e.length, i = -Infinity, n = t; n < r; n++) {
		var a = e[n];
		isFinite(a) && (i = Math.max(a, i));
	}
	return i;
}, "max"), Pd = h(function(e) {
	for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e.length, i = 0, n = 0, a = t; a < r; a++) {
		var s = e[a];
		isFinite(s) && (i += s, n++);
	}
	return i / n;
}, "mean"), Pp = h(function(e) {
	var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : e.length, i = !(arguments.length > 3) || void 0 === arguments[3] || arguments[3], n = !(arguments.length > 4) || void 0 === arguments[4] || arguments[4], a = !(arguments.length > 5) || void 0 === arguments[5] || arguments[5];
	i ? e = e.slice(t, r) : (r < e.length && e.splice(r, e.length - r), t > 0 && e.splice(0, t));
	for (var s = 0, o = e.length - 1; o >= 0; o--) {
		var l = e[o];
		a ? isFinite(l) || (e[o] = -Infinity, s++) : e.splice(o, 1);
	}
	n && e.sort(function(e, t) {
		return e - t;
	});
	var h = e.length, u = Math.floor(h / 2);
	return h % 2 != 0 ? e[u + 1 + s] : (e[u - 1 + s] + e[u + s]) / 2;
}, "median"), Pf = h(function(e) {
	return Math.PI * e / 180;
}, "deg2rad"), Pg = h(function(e, t) {
	return Math.atan2(t, e) - Math.PI / 2;
}, "getAngleFromDisp"), Pm = Math.log2 || function(e) {
	return Math.log(e) / Math.log(2);
}, Py = h(function(e) {
	return e > 0 ? 1 : e < 0 ? -1 : 0;
}, "signum"), Pv = h(function(e, t) {
	return Math.sqrt(Px(e, t));
}, "dist"), Px = h(function(e, t) {
	var r = t.x - e.x, i = t.y - e.y;
	return r * r + i * i;
}, "sqdist"), Pb = h(function(e) {
	for (var t = e.length, r = 0, i = 0; i < t; i++) r += e[i];
	for (var n = 0; n < t; n++) e[n] = e[n] / r;
	return e;
}, "inPlaceSumNormalize"), Pw = h(function(e, t, r, i) {
	return (1 - i) * (1 - i) * e + 2 * (1 - i) * i * t + i * i * r;
}, "qbezierAt"), Pk = h(function(e, t, r, i) {
	return {
		x: Pw(e.x, t.x, r.x, i),
		y: Pw(e.y, t.y, r.y, i)
	};
}, "qbezierPtAt"), PT = h(function(e, t, r, i) {
	var n = {
		x: t.x - e.x,
		y: t.y - e.y
	}, a = Pv(e, t), s = {
		x: n.x / a,
		y: n.y / a
	};
	return r = r ?? 0, i = i ?? r * a, {
		x: e.x + s.x * i,
		y: e.y + s.y * i
	};
}, "lineAt"), P_ = h(function(e, t, r) {
	return Math.max(e, Math.min(r, t));
}, "bound"), PE = h(function(e) {
	if (null == e) return {
		x1: Infinity,
		y1: Infinity,
		x2: -Infinity,
		y2: -Infinity,
		w: 0,
		h: 0
	};
	if (null != e.x1 && null != e.y1) {
		if (null != e.x2 && null != e.y2 && e.x2 >= e.x1 && e.y2 >= e.y1) return {
			x1: e.x1,
			y1: e.y1,
			x2: e.x2,
			y2: e.y2,
			w: e.x2 - e.x1,
			h: e.y2 - e.y1
		};
		if (null != e.w && null != e.h && e.w >= 0 && e.h >= 0) return {
			x1: e.x1,
			y1: e.y1,
			x2: e.x1 + e.w,
			y2: e.y1 + e.h,
			w: e.w,
			h: e.h
		};
	}
}, "makeBoundingBox"), PC = h(function(e) {
	return {
		x1: e.x1,
		x2: e.x2,
		w: e.w,
		y1: e.y1,
		y2: e.y2,
		h: e.h
	};
}, "copyBoundingBox"), PS = h(function(e) {
	e.x1 = Infinity, e.y1 = Infinity, e.x2 = -Infinity, e.y2 = -Infinity, e.w = 0, e.h = 0;
}, "clearBoundingBox"), PA = h(function(e, t) {
	e.x1 = Math.min(e.x1, t.x1), e.x2 = Math.max(e.x2, t.x2), e.w = e.x2 - e.x1, e.y1 = Math.min(e.y1, t.y1), e.y2 = Math.max(e.y2, t.y2), e.h = e.y2 - e.y1;
}, "updateBoundingBox"), PL = h(function(e, t, r) {
	e.x1 = Math.min(e.x1, t), e.x2 = Math.max(e.x2, t), e.w = e.x2 - e.x1, e.y1 = Math.min(e.y1, r), e.y2 = Math.max(e.y2, r), e.h = e.y2 - e.y1;
}, "expandBoundingBoxByPoint"), PR = h(function(e) {
	var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
	return e.x1 -= t, e.x2 += t, e.y1 -= t, e.y2 += t, e.w = e.x2 - e.x1, e.h = e.y2 - e.y1, e;
}, "expandBoundingBox"), PN = h(function(e) {
	var t, r, i, n, a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [0];
	if (1 === a.length) t = r = i = n = a[0];
	else if (2 === a.length) t = i = a[0], n = r = a[1];
	else if (4 === a.length) {
		var s = DR(a, 4);
		t = s[0], r = s[1], i = s[2], n = s[3];
	}
	return e.x1 -= n, e.x2 += r, e.y1 -= t, e.y2 += i, e.w = e.x2 - e.x1, e.h = e.y2 - e.y1, e;
}, "expandBoundingBoxSides"), PI = h(function(e, t) {
	e.x1 = t.x1, e.y1 = t.y1, e.x2 = t.x2, e.y2 = t.y2, e.w = e.x2 - e.x1, e.h = e.y2 - e.y1;
}, "assignBoundingBox"), PM = h(function(e, t) {
	return !(e.x1 > t.x2 || t.x1 > e.x2 || e.x2 < t.x1 || t.x2 < e.x1 || e.y2 < t.y1 || t.y2 < e.y1 || e.y1 > t.y2 || t.y1 > e.y2);
}, "boundingBoxesIntersect"), PD = h(function(e, t, r) {
	return e.x1 <= t && t <= e.x2 && e.y1 <= r && r <= e.y2;
}, "inBoundingBox"), PO = h(function(e, t) {
	return PD(e, t.x, t.y);
}, "pointInBoundingBox"), P$ = h(function(e, t) {
	return PD(e, t.x1, t.y1) && PD(e, t.x2, t.y2);
}, "boundingBoxInBoundingBox"), PP = null != ($1 = Math.hypot) ? $1 : function(e, t) {
	return Math.sqrt(e * e + t * t);
};
function PB(e, t) {
	if (e.length < 3) throw Error("Need at least 3 vertices");
	var r = h(function(e, t) {
		return {
			x: e.x + t.x,
			y: e.y + t.y
		};
	}, "add"), i = h(function(e, t) {
		return {
			x: e.x - t.x,
			y: e.y - t.y
		};
	}, "sub"), n = h(function(e, t) {
		return {
			x: e.x * t,
			y: e.y * t
		};
	}, "scale"), a = h(function(e, t) {
		return e.x * t.y - e.y * t.x;
	}, "cross"), s = h(function(e) {
		var t = PP(e.x, e.y);
		return 0 === t ? {
			x: 0,
			y: 0
		} : {
			x: e.x / t,
			y: e.y / t
		};
	}, "normalize"), o = h(function(e) {
		for (var t = 0, r = 0; r < e.length; r++) {
			var i = e[r], n = e[(r + 1) % e.length];
			t += i.x * n.y - n.x * i.y;
		}
		return t / 2;
	}, "signedArea"), l = h(function(e, t, s, o) {
		var l = i(t, e), h = i(o, s), u = a(l, h);
		return 1e-9 > Math.abs(u) ? r(e, n(l, .5)) : r(e, n(l, a(i(s, e), h) / u));
	}, "intersectLines"), u = e.map(function(e) {
		return {
			x: e.x,
			y: e.y
		};
	});
	0 > o(u) && u.reverse();
	for (var d = u.length, p = [], f = 0; f < d; f++) {
		var g = u[f], m = i(u[(f + 1) % d], g), y = s({
			x: m.y,
			y: -m.x
		});
		p.push(y);
	}
	for (var v = p.map(function(e, i) {
		return {
			p1: r(u[i], n(e, t)),
			p2: r(u[(i + 1) % d], n(e, t))
		};
	}), x = [], b = 0; b < d; b++) {
		var w = v[(b - 1 + d) % d], k = v[b], T = l(w.p1, w.p2, k.p1, k.p2);
		x.push(T);
	}
	return x;
}
function PF(e, t, r, i, n, a) {
	var s = PB(P4(e, t, r, i, n), a), o = PE();
	return s.forEach(function(e) {
		return PL(o, e.x, e.y);
	}), o;
}
h(PB, "inflatePolygon"), h(PF, "miterBox");
var Pz = h(function(e, t, r, i, n, a, s) {
	var o, l, h = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : "auto", u = "auto" === h ? Be(n, a) : h, d = n / 2, p = a / 2, f = (u = Math.min(u, d, p)) !== d, g = u !== p;
	if (f) {
		var m = r - d + u - s, y = i - p - s;
		if ((l = P2(e, t, r, i, m, y, r + d - u + s, y, !1)).length > 0) return l;
	}
	if (g) {
		var v = r + d + s;
		if ((l = P2(e, t, r, i, v, i - p + u - s, v, i + p - u + s, !1)).length > 0) return l;
	}
	if (f) {
		var x = r - d + u - s, b = i + p + s;
		if ((l = P2(e, t, r, i, x, b, r + d - u + s, b, !1)).length > 0) return l;
	}
	if (g) {
		var w = r - d - s;
		if ((l = P2(e, t, r, i, w, i - p + u - s, w, i + p - u + s, !1)).length > 0) return l;
	}
	var k = r - d + u, T = i - p + u;
	if ((o = P0(e, t, r, i, k, T, u + s)).length > 0 && o[0] <= k && o[1] <= T) return [o[0], o[1]];
	var _ = r + d - u, E = i - p + u;
	if ((o = P0(e, t, r, i, _, E, u + s)).length > 0 && o[0] >= _ && o[1] <= E) return [o[0], o[1]];
	var C = r + d - u, S = i + p - u;
	if ((o = P0(e, t, r, i, C, S, u + s)).length > 0 && o[0] >= C && o[1] >= S) return [o[0], o[1]];
	var A = r - d + u, L = i + p - u;
	return (o = P0(e, t, r, i, A, L, u + s)).length > 0 && o[0] <= A && o[1] >= L ? [o[0], o[1]] : [];
}, "roundRectangleIntersectLine"), PU = h(function(e, t, r, i, n, a, s) {
	var o = Math.min(r, n), l = Math.max(r, n), h = Math.min(i, a), u = Math.max(i, a);
	return o - s <= e && e <= l + s && h - s <= t && t <= u + s;
}, "inLineVicinity"), PG = h(function(e, t, r, i, n, a, s, o, l) {
	var h = {
		x1: Math.min(r, s, n) - l,
		x2: Math.max(r, s, n) + l,
		y1: Math.min(i, o, a) - l,
		y2: Math.max(i, o, a) + l
	};
	return !(e < h.x1 || e > h.x2 || t < h.y1 || t > h.y2);
}, "inBezierVicinity"), Pq = h(function(e, t, r, i) {
	var n = t * t - 4 * e * (r -= i);
	if (n < 0) return [];
	var a = Math.sqrt(n), s = 2 * e;
	return [(-t + a) / s, (-t - a) / s];
}, "solveQuadratic"), Pj = h(function(e, t, r, i, n) {
	var a, s, o, l, h, u, d, p;
	if (0 === e && (e = 1e-5), t /= e, r /= e, i /= e, a = (s = (3 * r - t * t) / 9) * s * s + (o = (-(27 * i) + t * (9 * r - t * t * 2)) / 54) * o, n[1] = 0, d = t / 3, a > 0) {
		h = (h = o + Math.sqrt(a)) < 0 ? -Math.pow(-h, 1 / 3) : Math.pow(h, 1 / 3), u = (u = o - Math.sqrt(a)) < 0 ? -Math.pow(-u, 1 / 3) : Math.pow(u, 1 / 3), n[0] = -d + h + u, d += (h + u) / 2, n[4] = n[2] = -d, d = Math.sqrt(3) * (-u + h) / 2, n[3] = d, n[5] = -d;
		return;
	}
	if (n[5] = n[3] = 0, 0 === a) {
		p = o < 0 ? -Math.pow(-o, 1 / 3) : Math.pow(o, 1 / 3), n[0] = -d + 2 * p, n[4] = n[2] = -(p + d);
		return;
	}
	l = Math.acos(o / Math.sqrt(l = (s = -s) * s * s)), p = 2 * Math.sqrt(s), n[0] = -d + p * Math.cos(l / 3), n[2] = -d + p * Math.cos((l + 2 * Math.PI) / 3), n[4] = -d + p * Math.cos((l + 4 * Math.PI) / 3);
}, "solveCubic"), PW = h(function(e, t, r, i, n, a, s, o) {
	var l = [];
	Pj(r * r - 4 * r * n + 2 * r * s + 4 * n * n - 4 * n * s + s * s + i * i - 4 * i * a + 2 * i * o + 4 * a * a - 4 * a * o + o * o, 9 * r * n - 3 * r * r - 3 * r * s - 6 * n * n + 3 * n * s + 9 * i * a - 3 * i * i - 3 * i * o - 6 * a * a + 3 * a * o, 3 * r * r - 6 * r * n + r * s - r * e + 2 * n * n + 2 * n * e - s * e + 3 * i * i - 6 * i * a + i * o - i * t + 2 * a * a + 2 * a * t - o * t, r * n - r * r + r * e - n * e + i * a - i * i + i * t - a * t, l);
	for (var h = [], u = 0; u < 6; u += 2) 1e-7 > Math.abs(l[u + 1]) && l[u] >= 0 && l[u] <= 1 && h.push(l[u]);
	h.push(1), h.push(0);
	for (var d, p = -1, f = 0; f < h.length; f++) d = Math.pow(Math.pow(1 - h[f], 2) * r + 2 * (1 - h[f]) * h[f] * n + h[f] * h[f] * s - e, 2) + Math.pow(Math.pow(1 - h[f], 2) * i + 2 * (1 - h[f]) * h[f] * a + h[f] * h[f] * o - t, 2), p >= 0 ? d < p && (p = d) : p = d;
	return p;
}, "sqdistToQuadraticBezier"), PY = h(function(e, t, r, i, n, a) {
	var s = [e - r, t - i], o = [n - r, a - i], l = o[0] * o[0] + o[1] * o[1], h = s[0] * s[0] + s[1] * s[1], u = s[0] * o[0] + s[1] * o[1], d = u * u / l;
	return u < 0 ? h : d > l ? (e - n) * (e - n) + (t - a) * (t - a) : h - d;
}, "sqdistToFiniteLine"), PV = h(function(e, t, r) {
	for (var i, n, a, s, o = 0, l = 0; l < r.length / 2; l++) if (i = r[2 * l], n = r[2 * l + 1], l + 1 < r.length / 2 ? (a = r[(l + 1) * 2], s = r[(l + 1) * 2 + 1]) : (a = r[(l + 1 - r.length / 2) * 2], s = r[(l + 1 - r.length / 2) * 2 + 1]), i != e || a != e) if ((!(i >= e) || !(e >= a)) && (!(i <= e) || !(e <= a))) continue;
	else (e - i) / (a - i) * (s - n) + n > t && o++;
	return o % 2 != 0;
}, "pointInsidePolygonPoints"), PH = h(function(e, t, r, i, n, a, s, o, l) {
	var h, u = Array(r.length);
	null != o[0] ? (h = Math.atan(o[1] / o[0]), o[0] < 0 ? h += Math.PI / 2 : h = -h - Math.PI / 2) : h = o;
	for (var d = Math.cos(-h), p = Math.sin(-h), f = 0; f < u.length / 2; f++) u[2 * f] = a / 2 * (r[2 * f] * d - r[2 * f + 1] * p), u[2 * f + 1] = s / 2 * (r[2 * f + 1] * d + r[2 * f] * p), u[2 * f] += i, u[2 * f + 1] += n;
	return PV(e, t, l > 0 ? PK(PZ(u, -l)) : u);
}, "pointInsidePolygon"), PX = h(function(e, t, r, i, n, a, s, o) {
	for (var l = Array(2 * r.length), h = 0; h < o.length; h++) {
		var u = o[h];
		if (l[4 * h + 0] = u.startX, l[4 * h + 1] = u.startY, l[4 * h + 2] = u.stopX, l[4 * h + 3] = u.stopY, Math.pow(u.cx - e, 2) + Math.pow(u.cy - t, 2) <= Math.pow(u.radius, 2)) return !0;
	}
	return PV(e, t, l);
}, "pointInsideRoundPolygon"), PK = h(function(e) {
	for (var t, r, i, n, a, s, o, l, h = Array(e.length / 2), u = 0; u < e.length / 4; u++) {
		t = e[4 * u], r = e[4 * u + 1], i = e[4 * u + 2], n = e[4 * u + 3], u < e.length / 4 - 1 ? (a = e[(u + 1) * 4], s = e[(u + 1) * 4 + 1], o = e[(u + 1) * 4 + 2], l = e[(u + 1) * 4 + 3]) : (a = e[0], s = e[1], o = e[2], l = e[3]);
		var d = P2(t, r, i, n, a, s, o, l, !0);
		h[2 * u] = d[0], h[2 * u + 1] = d[1];
	}
	return h;
}, "joinLines"), PZ = h(function(e, t) {
	for (var r, i, n, a, s = Array(2 * e.length), o = 0; o < e.length / 2; o++) {
		r = e[2 * o], i = e[2 * o + 1], o < e.length / 2 - 1 ? (n = e[(o + 1) * 2], a = e[(o + 1) * 2 + 1]) : (n = e[0], a = e[1]);
		var l = a - i, h = -(n - r), u = Math.sqrt(l * l + h * h), d = l / u, p = h / u;
		s[4 * o] = r + d * t, s[4 * o + 1] = i + p * t, s[4 * o + 2] = n + d * t, s[4 * o + 3] = a + p * t;
	}
	return s;
}, "expandPolygon"), PQ = h(function(e, t, r, i, n, a) {
	var s = r - e, o = i - t, l = Math.sqrt((s /= n) * s + (o /= a) * o), h = l - 1;
	if (h < 0) return [];
	var u = h / l;
	return [(r - e) * u + e, (i - t) * u + t];
}, "intersectLineEllipse"), PJ = h(function(e, t, r, i, n, a, s) {
	return e -= n, t -= a, (e /= r / 2 + s) * e + (t /= i / 2 + s) * t <= 1;
}, "checkInEllipse"), P0 = h(function(e, t, r, i, n, a, s) {
	var o = [r - e, i - t], l = [e - n, t - a], h = o[0] * o[0] + o[1] * o[1], u = 2 * (l[0] * o[0] + l[1] * o[1]), d = u * u - 4 * h * (l[0] * l[0] + l[1] * l[1] - s * s);
	if (d < 0) return [];
	var p = (-u + Math.sqrt(d)) / (2 * h), f = (-u - Math.sqrt(d)) / (2 * h), g = Math.min(p, f), m = Math.max(p, f), y = [];
	if (g >= 0 && g <= 1 && y.push(g), m >= 0 && m <= 1 && y.push(m), 0 === y.length) return [];
	var v = y[0] * o[0] + e, x = y[0] * o[1] + t;
	return y.length > 1 ? y[0] == y[1] ? [v, x] : [
		v,
		x,
		y[1] * o[0] + e,
		y[1] * o[1] + t
	] : [v, x];
}, "intersectLineCircle"), P1 = h(function(e, t, r) {
	return t <= e && e <= r || r <= e && e <= t ? e : e <= t && t <= r || r <= t && t <= e ? t : r;
}, "midOfThree"), P2 = h(function(e, t, r, i, n, a, s, o, l) {
	var h = e - n, u = r - e, d = s - n, p = t - a, f = i - t, g = o - a, m = d * p - g * h, y = u * p - f * h, v = g * u - d * f;
	if (0 === v) return 0 === m || 0 === y ? P1(e, r, s) === s ? [s, o] : P1(e, r, n) === n ? [n, a] : P1(n, s, r) === r ? [r, i] : [] : [];
	var x = m / v, b = y / v;
	return -.001 <= x && x <= 1.001 && -.001 <= b && b <= 1.001 || l ? [e + x * u, t + x * f] : [];
}, "finiteLinesIntersect"), P4 = h(function(e, t, r, i, n) {
	var a = [], s = i / 2, o = n / 2;
	a.push({
		x: t + s * e[0],
		y: r + o * e[1]
	});
	for (var l = 1; l < e.length / 2; l++) a.push({
		x: t + s * e[2 * l],
		y: r + o * e[2 * l + 1]
	});
	return a;
}, "transformPoints"), P5 = h(function(e, t, r, i, n, a, s, o) {
	var l, h = [], u = Array(r.length), d = !0;
	if (a ?? (d = !1), d) {
		for (var p = 0; p < u.length / 2; p++) u[2 * p] = r[2 * p] * a + i, u[2 * p + 1] = r[2 * p + 1] * s + n;
		f = o > 0 ? PK(PZ(u, -o)) : u;
	} else f = r;
	for (var f, g, m, y, v, x = 0; x < f.length / 2; x++) g = f[2 * x], m = f[2 * x + 1], x < f.length / 2 - 1 ? (y = f[(x + 1) * 2], v = f[(x + 1) * 2 + 1]) : (y = f[0], v = f[1]), 0 !== (l = P2(e, t, i, n, g, m, y, v)).length && h.push(l[0], l[1]);
	return h;
}, "polygonIntersectLine"), P3 = h(function(e, t, r, i, n, a, s, o, l) {
	var h, u = [], d = Array(2 * r.length);
	l.forEach(function(r, a) {
		0 === a ? (d[d.length - 2] = r.startX, d[d.length - 1] = r.startY) : (d[4 * a - 2] = r.startX, d[4 * a - 1] = r.startY), d[4 * a] = r.stopX, d[4 * a + 1] = r.stopY, 0 !== (h = P0(e, t, i, n, r.cx, r.cy, r.radius)).length && u.push(h[0], h[1]);
	});
	for (var p = 0; p < d.length / 4; p++) 0 !== (h = P2(e, t, i, n, d[4 * p], d[4 * p + 1], d[4 * p + 2], d[4 * p + 3], !1)).length && u.push(h[0], h[1]);
	if (u.length > 2) {
		for (var f = [u[0], u[1]], g = Math.pow(f[0] - e, 2) + Math.pow(f[1] - t, 2), m = 1; m < u.length / 2; m++) {
			var y = Math.pow(u[2 * m] - e, 2) + Math.pow(u[2 * m + 1] - t, 2);
			y <= g && (f[0] = u[2 * m], f[1] = u[2 * m + 1], g = y);
		}
		return f;
	}
	return u;
}, "roundPolygonIntersectLine"), P6 = h(function(e, t, r) {
	var i = [e[0] - t[0], e[1] - t[1]], n = Math.sqrt(i[0] * i[0] + i[1] * i[1]), a = (n - r) / n;
	return a < 0 && (a = 1e-5), [t[0] + a * i[0], t[1] + a * i[1]];
}, "shortenIntersection"), P7 = h(function(e, t) {
	return P8(P9(e, t));
}, "generateUnitNgonPointsFitToSquare"), P8 = h(function(e) {
	for (var t, r, i = e.length / 2, n = Infinity, a = Infinity, s = -Infinity, o = -Infinity, l = 0; l < i; l++) t = e[2 * l], r = e[2 * l + 1], n = Math.min(n, t), s = Math.max(s, t), a = Math.min(a, r), o = Math.max(o, r);
	for (var h = 2 / (s - n), u = 2 / (o - a), d = 0; d < i; d++) t = e[2 * d] = e[2 * d] * h, r = e[2 * d + 1] = e[2 * d + 1] * u, n = Math.min(n, t), s = Math.max(s, t), a = Math.min(a, r), o = Math.max(o, r);
	if (a < -1) for (var p = 0; p < i; p++) r = e[2 * p + 1] = e[2 * p + 1] + (-1 - a);
	return e;
}, "fitPolygonToSquare"), P9 = h(function(e, t) {
	var r = 1 / e * 2 * Math.PI, i = e % 2 == 0 ? Math.PI / 2 + r / 2 : Math.PI / 2;
	i += t;
	for (var n, a = Array(2 * e), s = 0; s < e; s++) n = s * r + i, a[2 * s] = Math.cos(n), a[2 * s + 1] = Math.sin(-n);
	return a;
}, "generateUnitNgonPoints"), Be = h(function(e, t) {
	return Math.min(e / 4, t / 4, 8);
}, "getRoundRectangleRadius"), Bt = h(function(e, t) {
	return Math.min(e / 10, t / 10, 8);
}, "getRoundPolygonRadius"), Br = h(function() {
	return 8;
}, "getCutRectangleCornerLength"), Bi = h(function(e, t, r) {
	return [
		e - 2 * t + r,
		2 * (t - e),
		e
	];
}, "bezierPtsToQuadCoeff"), Bn = h(function(e, t) {
	return {
		heightOffset: Math.min(15, .05 * t),
		widthOffset: Math.min(100, .25 * e),
		ctrlPtOffsetPct: .05
	};
}, "getBarrelCurveConstants");
function Ba(e, t) {
	function r(e) {
		for (var t = [], r = 0; r < e.length; r++) {
			var i = e[r], n = e[(r + 1) % e.length], a = {
				x: n.x - i.x,
				y: n.y - i.y
			}, s = {
				x: -a.y,
				y: a.x
			}, o = Math.sqrt(s.x * s.x + s.y * s.y);
			t.push({
				x: s.x / o,
				y: s.y / o
			});
		}
		return t;
	}
	function i(e, t) {
		var r, i = Infinity, n = -Infinity, a = D_(e);
		try {
			for (a.s(); !(r = a.n()).done;) {
				var s = r.value, o = s.x * t.x + s.y * t.y;
				i = Math.min(i, o), n = Math.max(n, o);
			}
		} catch (e) {
			a.e(e);
		} finally {
			a.f();
		}
		return {
			min: i,
			max: n
		};
	}
	function n(e, t) {
		return !(e.max < t.min || t.max < e.min);
	}
	h(r, "getAxes"), h(i, "project"), h(n, "overlaps");
	var a, s = D_([].concat(DN(r(e)), DN(r(t))));
	try {
		for (s.s(); !(a = s.n()).done;) {
			var o = a.value;
			if (!n(i(e, o), i(t, o))) return !1;
		}
	} catch (e) {
		s.e(e);
	} finally {
		s.f();
	}
	return !0;
}
h(Ba, "satPolygonIntersection");
var Bs = $o({
	dampingFactor: .8,
	precision: 1e-6,
	iterations: 200,
	weight: h(function(e) {
		return 1;
	}, "weight")
}), Bo = { pageRank: h(function(e) {
	for (var t = Bs(e), r = t.dampingFactor, i = t.precision, n = t.iterations, a = t.weight, s = this._private.cy, o = this.byGroup(), l = o.nodes, u = o.edges, d = l.length, p = d * d, f = u.length, g = Array(p), m = Array(d), y = (1 - r) / d, v = 0; v < d; v++) {
		for (var x = 0; x < d; x++) g[v * d + x] = 0;
		m[v] = 0;
	}
	for (var b = 0; b < f; b++) {
		var w = u[b], k = w.data("source"), T = w.data("target");
		if (k !== T) {
			var _ = l.indexOfId(k), E = l.indexOfId(T), C = a(w), S = E * d + _;
			g[S] += C, m[_] += C;
		}
	}
	for (var A = 1 / d + y, L = 0; L < d; L++) if (0 === m[L]) for (var R = 0; R < d; R++) g[R * d + L] = A;
	else for (var N = 0; N < d; N++) {
		var I = N * d + L;
		g[I] = g[I] / m[L] + y;
	}
	for (var M, D = Array(d), O = Array(d), $ = 0; $ < d; $++) D[$] = 1;
	for (var P = 0; P < n; P++) {
		for (var B = 0; B < d; B++) O[B] = 0;
		for (var F = 0; F < d; F++) for (var z = 0; z < d; z++) {
			var U = F * d + z;
			O[F] += g[U] * D[z];
		}
		Pb(O), M = D, D = O, O = M;
		for (var G = 0, q = 0; q < d; q++) {
			var j = M[q] - D[q];
			G += j * j;
		}
		if (G < i) break;
	}
	return { rank: h(function(e) {
		return e = s.collection(e)[0], D[l.indexOf(e)];
	}, "rank") };
}, "pageRank") }, Bl = $o({
	root: null,
	weight: h(function(e) {
		return 1;
	}, "weight"),
	directed: !1,
	alpha: 0
}), Bc = {
	degreeCentralityNormalized: h(function(e) {
		e = Bl(e);
		var t = this.cy(), r = this.nodes(), i = r.length;
		if (e.directed) {
			for (var n = {}, a = {}, s = 0, o = 0, l = 0; l < i; l++) {
				var u = r[l], d = u.id();
				e.root = u;
				var p = this.degreeCentrality(e);
				s < p.indegree && (s = p.indegree), o < p.outdegree && (o = p.outdegree), n[d] = p.indegree, a[d] = p.outdegree;
			}
			return {
				indegree: h(function(e) {
					return 0 == s ? 0 : (Dq(e) && (e = t.filter(e)), n[e.id()] / s);
				}, "indegree"),
				outdegree: h(function(e) {
					return 0 === o ? 0 : (Dq(e) && (e = t.filter(e)), a[e.id()] / o);
				}, "outdegree")
			};
		}
		for (var f = {}, g = 0, m = 0; m < i; m++) {
			var y = r[m];
			e.root = y;
			var v = this.degreeCentrality(e);
			g < v.degree && (g = v.degree), f[y.id()] = v.degree;
		}
		return { degree: h(function(e) {
			return 0 === g ? 0 : (Dq(e) && (e = t.filter(e)), f[e.id()] / g);
		}, "degree") };
	}, "degreeCentralityNormalized"),
	degreeCentrality: h(function(e) {
		e = Bl(e);
		var t = this.cy(), r = this, i = e, n = i.root, a = i.weight, s = i.directed, o = i.alpha;
		if (n = t.collection(n)[0], s) {
			for (var l = n.connectedEdges(), h = l.filter(function(e) {
				return e.target().same(n) && r.has(e);
			}), u = l.filter(function(e) {
				return e.source().same(n) && r.has(e);
			}), d = h.length, p = u.length, f = 0, g = 0, m = 0; m < h.length; m++) f += a(h[m]);
			for (var y = 0; y < u.length; y++) g += a(u[y]);
			return {
				indegree: Math.pow(d, 1 - o) * Math.pow(f, o),
				outdegree: Math.pow(p, 1 - o) * Math.pow(g, o)
			};
		}
		for (var v = n.connectedEdges().intersection(r), x = v.length, b = 0, w = 0; w < v.length; w++) b += a(v[w]);
		return { degree: Math.pow(x, 1 - o) * Math.pow(b, o) };
	}, "degreeCentrality")
};
Bc.dc = Bc.degreeCentrality, Bc.dcn = Bc.degreeCentralityNormalised = Bc.degreeCentralityNormalized;
var Bh = $o({
	harmonic: !0,
	weight: h(function() {
		return 1;
	}, "weight"),
	directed: !1,
	root: null
}), Bu = {
	closenessCentralityNormalized: h(function(e) {
		for (var t = Bh(e), r = t.harmonic, i = t.weight, n = t.directed, a = this.cy(), s = {}, o = 0, l = this.nodes(), u = this.floydWarshall({
			weight: i,
			directed: n
		}), d = 0; d < l.length; d++) {
			for (var p = 0, f = l[d], g = 0; g < l.length; g++) if (d !== g) {
				var m = u.distance(f, l[g]);
				r ? p += 1 / m : p += m;
			}
			r || (p = 1 / p), o < p && (o = p), s[f.id()] = p;
		}
		return { closeness: h(function(e) {
			return 0 == o ? 0 : s[e = Dq(e) ? a.filter(e)[0].id() : e.id()] / o;
		}, "closeness") };
	}, "closenessCentralityNormalized"),
	closenessCentrality: h(function(e) {
		var t = Bh(e), r = t.root, i = t.weight, n = t.directed, a = t.harmonic;
		r = this.filter(r)[0];
		for (var s = this.dijkstra({
			root: r,
			weight: i,
			directed: n
		}), o = 0, l = this.nodes(), h = 0; h < l.length; h++) {
			var u = l[h];
			if (!u.same(r)) {
				var d = s.distanceTo(u);
				a ? o += 1 / d : o += d;
			}
		}
		return a ? o : 1 / o;
	}, "closenessCentrality")
};
Bu.cc = Bu.closenessCentrality, Bu.ccn = Bu.closenessCentralityNormalised = Bu.closenessCentralityNormalized;
var Bd = $o({
	weight: null,
	directed: !1
}), Bp = { betweennessCentrality: h(function(e) {
	for (var t = Bd(e), r = t.directed, i = t.weight, n = null != i, a = this.cy(), s = this.nodes(), o = {}, l = {}, u = 0, d = {
		set: h(function(e, t) {
			l[e] = t, t > u && (u = t);
		}, "set"),
		get: h(function(e) {
			return l[e];
		}, "get")
	}, p = 0; p < s.length; p++) {
		var f = s[p], g = f.id();
		r ? o[g] = f.outgoers().nodes() : o[g] = f.openNeighborhood().nodes(), d.set(g, 0);
	}
	for (var m = h(function() {
		for (var e = s[y].id(), t = [], r = {}, l = {}, h = {}, u = new $2(function(e, t) {
			return h[e] - h[t];
		}), p = 0; p < s.length; p++) {
			var f = s[p].id();
			r[f] = [], l[f] = 0, h[f] = Infinity;
		}
		for (l[e] = 1, h[e] = 0, u.push(e); !u.empty();) {
			var g = u.pop();
			if (t.push(g), n) for (var m = 0; m < o[g].length; m++) {
				var v = o[g][m], x = a.getElementById(g), w = i(x.edgesTo(v).length > 0 ? x.edgesTo(v)[0] : v.edgesTo(x)[0]);
				h[v = v.id()] > h[g] + w && (h[v] = h[g] + w, 0 > u.nodes.indexOf(v) ? u.push(v) : u.updateItem(v), l[v] = 0, r[v] = []), h[v] == h[g] + w && (l[v] = l[v] + l[g], r[v].push(g));
			}
			else for (var k = 0; k < o[g].length; k++) {
				var T = o[g][k].id();
				h[T] == Infinity && (u.push(T), h[T] = h[g] + 1), h[T] == h[g] + 1 && (l[T] = l[T] + l[g], r[T].push(g));
			}
		}
		for (var _ = {}, E = 0; E < s.length; E++) _[s[E].id()] = 0;
		for (; t.length > 0;) {
			for (var C = t.pop(), S = 0; S < r[C].length; S++) {
				var A = r[C][S];
				_[A] = _[A] + l[A] / l[C] * (1 + _[C]);
			}
			C != s[y].id() && d.set(C, d.get(C) + _[C]);
		}
	}, "_loop"), y = 0; y < s.length; y++) m();
	var v = {
		betweenness: h(function(e) {
			var t = a.collection(e).id();
			return d.get(t);
		}, "betweenness"),
		betweennessNormalized: h(function(e) {
			if (0 == u) return 0;
			var t = a.collection(e).id();
			return d.get(t) / u;
		}, "betweennessNormalized")
	};
	return v.betweennessNormalised = v.betweennessNormalized, v;
}, "betweennessCentrality") };
Bp.bc = Bp.betweennessCentrality;
var Bf = $o({
	expandFactor: 2,
	inflateFactor: 2,
	multFactor: 1,
	maxIterations: 20,
	attributes: [function(e) {
		return 1;
	}]
}), Bg = h(function(e) {
	return Bf(e);
}, "setOptions"), Bm = h(function(e, t) {
	for (var r = 0, i = 0; i < t.length; i++) r += t[i](e);
	return r;
}, "getSimilarity"), By = h(function(e, t, r) {
	for (var i = 0; i < t; i++) e[i * t + i] = r;
}, "addLoops"), Bv = h(function(e, t) {
	for (var r, i = 0; i < t; i++) {
		r = 0;
		for (var n = 0; n < t; n++) r += e[n * t + i];
		for (var a = 0; a < t; a++) e[a * t + i] = e[a * t + i] / r;
	}
}, "normalize"), Bx = h(function(e, t, r) {
	for (var i = Array(r * r), n = 0; n < r; n++) {
		for (var a = 0; a < r; a++) i[n * r + a] = 0;
		for (var s = 0; s < r; s++) for (var o = 0; o < r; o++) i[n * r + o] += e[n * r + s] * t[s * r + o];
	}
	return i;
}, "mmult"), Bb = h(function(e, t, r) {
	for (var i = e.slice(0), n = 1; n < r; n++) e = Bx(e, i, t);
	return e;
}, "expand"), Bw = h(function(e, t, r) {
	for (var i = Array(t * t), n = 0; n < t * t; n++) i[n] = Math.pow(e[n], r);
	return Bv(i, t), i;
}, "inflate"), Bk = h(function(e, t, r, i) {
	for (var n = 0; n < r; n++) if (Math.round(e[n] * Math.pow(10, i)) / Math.pow(10, i) != Math.round(t[n] * Math.pow(10, i)) / Math.pow(10, i)) return !1;
	return !0;
}, "hasConverged"), BT = h(function(e, t, r, i) {
	for (var n = [], a = 0; a < t; a++) {
		for (var s = [], o = 0; o < t; o++) Math.round(1e3 * e[a * t + o]) / 1e3 > 0 && s.push(r[o]);
		0 !== s.length && n.push(i.collection(s));
	}
	return n;
}, "assign"), B_ = h(function(e, t) {
	for (var r = 0; r < e.length; r++) if (!t[r] || e[r].id() !== t[r].id()) return !1;
	return !0;
}, "isDuplicate"), BE = h(function(e) {
	for (var t = 0; t < e.length; t++) for (var r = 0; r < e.length; r++) t != r && B_(e[t], e[r]) && e.splice(r, 1);
	return e;
}, "removeDuplicates"), BC = h(function(e) {
	for (var t = this.nodes(), r = this.edges(), i = this.cy(), n = Bg(e), a = {}, s = 0; s < t.length; s++) a[t[s].id()] = s;
	for (var o, l = t.length, h = l * l, u = Array(h), d = 0; d < h; d++) u[d] = 0;
	for (var p = 0; p < r.length; p++) {
		var f = r[p], g = a[f.source().id()], m = a[f.target().id()], y = Bm(f, n.attributes);
		u[g * l + m] += y, u[m * l + g] += y;
	}
	By(u, l, n.multFactor), Bv(u, l);
	for (var v = !0, x = 0; v && x < n.maxIterations;) v = !1, Bk(u = Bw(o = Bb(u, l, n.expandFactor), l, n.inflateFactor), o, h, 4) || (v = !0), x++;
	return BE(BT(u, l, t, i));
}, "markovClustering"), BS = h(function(e) {
	return e;
}, "identity"), BA = h(function(e, t) {
	return Math.abs(t - e);
}, "absDiff"), BL = h(function(e, t, r) {
	return e + BA(t, r);
}, "addAbsDiff"), BR = h(function(e, t, r) {
	return e + Math.pow(r - t, 2);
}, "addSquaredDiff"), BN = h(function(e) {
	return Math.sqrt(e);
}, "sqrt"), BI = h(function(e, t, r) {
	return Math.max(e, BA(t, r));
}, "maxAbsDiff"), BM = h(function(e, t, r, i, n) {
	for (var a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : BS, s = i, o = 0; o < e; o++) s = n(s, t(o), r(o));
	return a(s);
}, "getDistance"), BD = {
	euclidean: h(function(e, t, r) {
		return e >= 2 ? BM(e, t, r, 0, BR, BN) : BM(e, t, r, 0, BL);
	}, "euclidean"),
	squaredEuclidean: h(function(e, t, r) {
		return BM(e, t, r, 0, BR);
	}, "squaredEuclidean"),
	manhattan: h(function(e, t, r) {
		return BM(e, t, r, 0, BL);
	}, "manhattan"),
	max: h(function(e, t, r) {
		return BM(e, t, r, -Infinity, BI);
	}, "max")
};
function BO(e, t, r, i, n, a) {
	var s;
	return s = Dj(e) ? e : BD[e] || BD.euclidean, 0 === t && Dj(e) ? s(n, a) : s(t, r, i, n, a);
}
BD["squared-euclidean"] = BD.squaredEuclidean, BD.squaredeuclidean = BD.squaredEuclidean, h(BO, "clusteringDistance");
var B$ = $o({
	k: 2,
	m: 2,
	sensitivityThreshold: 1e-4,
	distance: "euclidean",
	maxIterations: 10,
	attributes: [],
	testMode: !1,
	testCentroids: null
}), BP = h(function(e) {
	return B$(e);
}, "setOptions"), BB = h(function(e, t, r, i, n) {
	var a = "kMedoids" !== n ? function(e) {
		return r[e];
	} : function(e) {
		return i[e](r);
	}, s = h(function(e) {
		return i[e](t);
	}, "getQ");
	return BO(e, i.length, a, s, r, t);
}, "getDist"), BF = h(function(e, t, r) {
	for (var i = r.length, n = Array(i), a = Array(i), s = Array(t), o = null, l = 0; l < i; l++) n[l] = e.min(r[l]).value, a[l] = e.max(r[l]).value;
	for (var h = 0; h < t; h++) {
		o = [];
		for (var u = 0; u < i; u++) o[u] = Math.random() * (a[u] - n[u]) + n[u];
		s[h] = o;
	}
	return s;
}, "randomCentroids"), Bz = h(function(e, t, r, i, n) {
	for (var a = Infinity, s = 0, o = 0; o < t.length; o++) {
		var l = BB(r, e, t[o], i, n);
		l < a && (a = l, s = o);
	}
	return s;
}, "classify"), BU = h(function(e, t, r) {
	for (var i = [], n = null, a = 0; a < t.length; a++) r[(n = t[a]).id()] === e && i.push(n);
	return i;
}, "buildCluster"), BG = h(function(e, t, r) {
	return Math.abs(t - e) <= r;
}, "haveValuesConverged"), Bq = h(function(e, t, r) {
	for (var i = 0; i < e.length; i++) for (var n = 0; n < e[i].length; n++) if (Math.abs(e[i][n] - t[i][n]) > r) return !1;
	return !0;
}, "haveMatricesConverged"), Bj = h(function(e, t, r) {
	for (var i = 0; i < r; i++) if (e === t[i]) return !0;
	return !1;
}, "seenBefore"), BW = h(function(e, t) {
	var r = Array(t);
	if (e.length < 50) for (var i = 0; i < t; i++) {
		for (var n = e[Math.floor(Math.random() * e.length)]; Bj(n, r, i);) n = e[Math.floor(Math.random() * e.length)];
		r[i] = n;
	}
	else for (var a = 0; a < t; a++) r[a] = e[Math.floor(Math.random() * e.length)];
	return r;
}, "randomMedoids"), BY = h(function(e, t, r) {
	for (var i = 0, n = 0; n < t.length; n++) i += BB("manhattan", t[n], e, r, "kMedoids");
	return i;
}, "findCost"), BV = h(function(e) {
	var t, r = this.cy(), i = this.nodes(), n = null, a = BP(e), s = Array(a.k), o = {};
	a.testMode ? "number" == typeof a.testCentroids ? (a.testCentroids, t = BF(i, a.k, a.attributes)) : t = "object" === DD(a.testCentroids) ? a.testCentroids : BF(i, a.k, a.attributes) : t = BF(i, a.k, a.attributes);
	for (var l = !0, h = 0; l && h < a.maxIterations;) {
		for (var u = 0; u < i.length; u++) o[(n = i[u]).id()] = Bz(n, t, a.distance, a.attributes, "kMeans");
		l = !1;
		for (var d = 0; d < a.k; d++) {
			var p = BU(d, i, o);
			if (0 !== p.length) {
				for (var f = a.attributes.length, g = t[d], m = Array(f), y = Array(f), v = 0; v < f; v++) {
					y[v] = 0;
					for (var x = 0; x < p.length; x++) n = p[x], y[v] += a.attributes[v](n);
					m[v] = y[v] / p.length, BG(m[v], g[v], a.sensitivityThreshold) || (l = !0);
				}
				t[d] = m, s[d] = r.collection(p);
			}
		}
		h++;
	}
	return s;
}, "kMeans"), BH = h(function(e) {
	var t, r, i = this.cy(), n = this.nodes(), a = null, s = BP(e), o = Array(s.k), l = {}, h = Array(s.k);
	s.testMode ? "number" == typeof s.testCentroids || (t = "object" === DD(s.testCentroids) ? s.testCentroids : BW(n, s.k)) : t = BW(n, s.k);
	for (var u = !0, d = 0; u && d < s.maxIterations;) {
		for (var p = 0; p < n.length; p++) l[(a = n[p]).id()] = Bz(a, t, s.distance, s.attributes, "kMedoids");
		u = !1;
		for (var f = 0; f < t.length; f++) {
			var g = BU(f, n, l);
			if (0 !== g.length) {
				h[f] = BY(t[f], g, s.attributes);
				for (var m = 0; m < g.length; m++) (r = BY(g[m], g, s.attributes)) < h[f] && (h[f] = r, t[f] = g[m], u = !0);
				o[f] = i.collection(g);
			}
		}
		d++;
	}
	return o;
}, "kMedoids"), BX = h(function(e, t, r, i, n) {
	for (var a, s, o = 0; o < t.length; o++) for (var l = 0; l < e.length; l++) i[o][l] = Math.pow(r[o][l], n.m);
	for (var h = 0; h < e.length; h++) for (var u = 0; u < n.attributes.length; u++) {
		a = 0, s = 0;
		for (var d = 0; d < t.length; d++) a += i[d][h] * n.attributes[u](t[d]), s += i[d][h];
		e[h][u] = a / s;
	}
}, "updateCentroids"), BK = h(function(e, t, r, i, n) {
	for (var a = 0; a < e.length; a++) t[a] = e[a].slice();
	for (var s, o = 2 / (n.m - 1), l = 0; l < r.length; l++) for (var h = 0; h < i.length; h++) {
		s = 0;
		for (var u = 0; u < r.length; u++) s += Math.pow(BB(n.distance, i[h], r[l], n.attributes, "cmeans") / BB(n.distance, i[h], r[u], n.attributes, "cmeans"), o);
		e[h][l] = 1 / s;
	}
}, "updateMembership"), BZ = h(function(e, t, r, i) {
	for (var n = Array(r.k), a = 0; a < n.length; a++) n[a] = [];
	for (var s, o, l = 0; l < t.length; l++) {
		s = -Infinity, o = -1;
		for (var h = 0; h < t[0].length; h++) t[l][h] > s && (s = t[l][h], o = h);
		n[o].push(e[l]);
	}
	for (var u = 0; u < n.length; u++) n[u] = i.collection(n[u]);
	return n;
}, "assign"), BQ = h(function(e) {
	for (var t, r, i, n = this.cy(), a = this.nodes(), s = BP(e), o = Array(a.length), l = 0; l < a.length; l++) o[l] = Array(s.k);
	r = Array(a.length);
	for (var h = 0; h < a.length; h++) r[h] = Array(s.k);
	for (var u = 0; u < a.length; u++) {
		for (var d = 0, p = 0; p < s.k; p++) r[u][p] = Math.random(), d += r[u][p];
		for (var f = 0; f < s.k; f++) r[u][f] = r[u][f] / d;
	}
	t = Array(s.k);
	for (var g = 0; g < s.k; g++) t[g] = Array(s.attributes.length);
	i = Array(a.length);
	for (var m = 0; m < a.length; m++) i[m] = Array(s.k);
	for (var y = !0, v = 0; y && v < s.maxIterations;) y = !1, BX(t, a, r, i, s), BK(r, o, t, a, s), Bq(r, o, s.sensitivityThreshold) || (y = !0), v++;
	return {
		clusters: BZ(a, r, s, n),
		degreeOfMembership: r
	};
}, "fuzzyCMeans"), BJ = $o({
	distance: "euclidean",
	linkage: "min",
	mode: "threshold",
	threshold: Infinity,
	addDendrogram: !1,
	dendrogramDepth: 0,
	attributes: []
}), B0 = {
	single: "min",
	complete: "max"
}, B1 = h(function(e) {
	var t = BJ(e), r = B0[t.linkage];
	return null != r && (t.linkage = r), t;
}, "setOptions"), B2 = h(function(e, t, r, i, n) {
	for (var a, s = 0, o = Infinity, l = n.attributes, u = h(function(e, t) {
		return BO(n.distance, l.length, function(t) {
			return l[t](e);
		}, function(e) {
			return l[e](t);
		}, e, t);
	}, "getDist"), d = 0; d < e.length; d++) {
		var p = e[d].key, f = r[p][i[p]];
		f < o && (s = p, o = f);
	}
	if ("threshold" === n.mode && o >= n.threshold || "dendrogram" === n.mode && 1 === e.length) return !1;
	var g, m = t[s], y = t[i[s]];
	g = "dendrogram" === n.mode ? {
		left: m,
		right: y,
		key: m.key
	} : {
		value: m.value.concat(y.value),
		key: m.key
	}, e[m.index] = g, e.splice(y.index, 1), t[m.key] = g;
	for (var v = 0; v < e.length; v++) {
		var x = e[v];
		m.key === x.key ? a = Infinity : "min" === n.linkage ? (a = r[m.key][x.key], r[m.key][x.key] > r[y.key][x.key] && (a = r[y.key][x.key])) : "max" === n.linkage ? (a = r[m.key][x.key], r[m.key][x.key] < r[y.key][x.key] && (a = r[y.key][x.key])) : a = "mean" === n.linkage ? (r[m.key][x.key] * m.size + r[y.key][x.key] * y.size) / (m.size + y.size) : "dendrogram" === n.mode ? u(x.value, m.value) : u(x.value[0], m.value[0]), r[m.key][x.key] = r[x.key][m.key] = a;
	}
	for (var b = 0; b < e.length; b++) {
		var w = e[b].key;
		if (i[w] === m.key || i[w] === y.key) {
			for (var k = w, T = 0; T < e.length; T++) {
				var _ = e[T].key;
				r[w][_] < r[w][k] && (k = _);
			}
			i[w] = k;
		}
		e[b].index = b;
	}
	return m.key = y.key = m.index = y.index = null, !0;
}, "mergeClosest"), B4 = h(function(e, t, r) {
	e && (e.value ? t.push(e.value) : (e.left && B4(e.left, t), e.right && B4(e.right, t)));
}, "getAllChildren"), B5 = h(function(e, t) {
	if (!e) return "";
	if (e.left && e.right) {
		var r = B5(e.left, t), i = B5(e.right, t), n = t.add({
			group: "nodes",
			data: { id: r + "," + i }
		});
		return t.add({
			group: "edges",
			data: {
				source: r,
				target: n.id()
			}
		}), t.add({
			group: "edges",
			data: {
				source: i,
				target: n.id()
			}
		}), n.id();
	}
	if (e.value) return e.value.id();
}, "buildDendrogram"), B3 = h(function(e, t, r) {
	if (!e) return [];
	var i = [], n = [], a = [];
	return 0 === t ? (e.left && B4(e.left, i), e.right && B4(e.right, n), a = i.concat(n), [r.collection(a)]) : 1 === t ? e.value ? [r.collection(e.value)] : (e.left && B4(e.left, i), e.right && B4(e.right, n), [r.collection(i), r.collection(n)]) : e.value ? [r.collection(e.value)] : (e.left && (i = B3(e.left, t - 1, r)), e.right && (n = B3(e.right, t - 1, r)), i.concat(n));
}, "buildClustersFromTree"), B6 = h(function(e) {
	for (var t, r = this.cy(), i = this.nodes(), n = B1(e), a = n.attributes, s = h(function(e, t) {
		return BO(n.distance, a.length, function(t) {
			return a[t](e);
		}, function(e) {
			return a[e](t);
		}, e, t);
	}, "getDist"), o = [], l = [], u = [], d = [], p = 0; p < i.length; p++) {
		var f = {
			value: "dendrogram" === n.mode ? i[p] : [i[p]],
			key: p,
			index: p
		};
		o[p] = f, d[p] = f, l[p] = [], u[p] = 0;
	}
	for (var g = 0; g < o.length; g++) for (var m = 0; m <= g; m++) {
		var y = void 0;
		y = "dendrogram" === n.mode ? g === m ? Infinity : s(o[g].value, o[m].value) : g === m ? Infinity : s(o[g].value[0], o[m].value[0]), l[g][m] = y, l[m][g] = y, y < l[g][u[g]] && (u[g] = m);
	}
	for (var v = B2(o, d, l, u, n); v;) v = B2(o, d, l, u, n);
	return "dendrogram" === n.mode ? (t = B3(o[0], n.dendrogramDepth, r), n.addDendrogram && B5(o[0], r)) : (t = Array(o.length), o.forEach(function(e, i) {
		e.key = e.index = null, t[i] = r.collection(e.value);
	})), t;
}, "hierarchicalClustering"), B7 = $o({
	distance: "euclidean",
	preference: "median",
	damping: .8,
	maxIterations: 1e3,
	minIterations: 100,
	attributes: []
}), B8 = h(function(e) {
	var t = e.damping, r = e.preference;
	.5 <= t && t < 1 || O8("Damping must range on [0.5, 1).  Got: ".concat(t));
	var i = [
		"median",
		"mean",
		"min",
		"max"
	];
	return i.some(function(e) {
		return e === r;
	}) || DH(r) || O8("Preference must be one of [".concat(i.map(function(e) {
		return "'".concat(e, "'");
	}).join(", "), "] or a number.  Got: ").concat(r)), B7(e);
}, "setOptions"), B9 = h(function(e, t, r, i) {
	var n = h(function(e, t) {
		return i[t](e);
	}, "attr");
	return -BO(e, i.length, function(e) {
		return n(t, e);
	}, function(e) {
		return n(r, e);
	}, t, r);
}, "getSimilarity"), Fe = h(function(e, t) {
	return "median" === t ? Pp(e) : "mean" === t ? Pd(e) : "min" === t ? Ph(e) : "max" === t ? Pu(e) : t;
}, "getPreference"), Ft = h(function(e, t, r) {
	for (var i = [], n = 0; n < e; n++) t[n * e + n] + r[n * e + n] > 0 && i.push(n);
	return i;
}, "findExemplars"), Fr = h(function(e, t, r) {
	for (var i = [], n = 0; n < e; n++) {
		for (var a = -1, s = -Infinity, o = 0; o < r.length; o++) {
			var l = r[o];
			t[n * e + l] > s && (a = l, s = t[n * e + l]);
		}
		a > 0 && i.push(a);
	}
	for (var h = 0; h < r.length; h++) i[r[h]] = r[h];
	return i;
}, "assignClusters"), Fi = h(function(e, t, r) {
	for (var i = Fr(e, t, r), n = 0; n < r.length; n++) {
		for (var a = [], s = 0; s < i.length; s++) i[s] === r[n] && a.push(s);
		for (var o = -1, l = -Infinity, h = 0; h < a.length; h++) {
			for (var u = 0, d = 0; d < a.length; d++) u += t[a[d] * e + a[h]];
			u > l && (o = h, l = u);
		}
		r[n] = a[o];
	}
	return Fr(e, t, r);
}, "assign"), Fn = h(function(e) {
	for (var t, r = this.cy(), i = this.nodes(), n = B8(e), a = {}, s = 0; s < i.length; s++) a[i[s].id()] = s;
	for (var o, l, h, u = i.length, d = u * u, p = Array(d), f = 0; f < d; f++) p[f] = -Infinity;
	for (var g = 0; g < u; g++) for (var m = 0; m < u; m++) g !== m && (p[g * u + m] = B9(n.distance, i[g], i[m], n.attributes));
	o = Fe(p, n.preference);
	for (var y = 0; y < u; y++) p[y * u + y] = o;
	l = Array(d);
	for (var v = 0; v < d; v++) l[v] = 0;
	h = Array(d);
	for (var x = 0; x < d; x++) h[x] = 0;
	for (var b = Array(u), w = Array(u), k = Array(u), T = 0; T < u; T++) b[T] = 0, w[T] = 0, k[T] = 0;
	for (var _ = Array(u * n.minIterations), E = 0; E < _.length; E++) _[E] = 0;
	for (t = 0; t < n.maxIterations; t++) {
		for (var C = 0; C < u; C++) {
			for (var S = -Infinity, A = -Infinity, L = -1, R = 0, N = 0; N < u; N++) b[N] = l[C * u + N], (R = h[C * u + N] + p[C * u + N]) >= S ? (A = S, S = R, L = N) : R > A && (A = R);
			for (var I = 0; I < u; I++) l[C * u + I] = (1 - n.damping) * (p[C * u + I] - S) + n.damping * b[I];
			l[C * u + L] = (1 - n.damping) * (p[C * u + L] - A) + n.damping * b[L];
		}
		for (var M = 0; M < u; M++) {
			for (var D = 0, O = 0; O < u; O++) b[O] = h[O * u + M], w[O] = Math.max(0, l[O * u + M]), D += w[O];
			D -= w[M], w[M] = l[M * u + M], D += w[M];
			for (var $ = 0; $ < u; $++) h[$ * u + M] = (1 - n.damping) * Math.min(0, D - w[$]) + n.damping * b[$];
			h[M * u + M] = (1 - n.damping) * (D - w[M]) + n.damping * b[M];
		}
		for (var P = 0, B = 0; B < u; B++) {
			var F = +(h[B * u + B] + l[B * u + B] > 0);
			_[t % n.minIterations * u + B] = F, P += F;
		}
		if (P > 0 && (t >= n.minIterations - 1 || t == n.maxIterations - 1)) {
			for (var z = 0, U = 0; U < u; U++) {
				k[U] = 0;
				for (var G = 0; G < n.minIterations; G++) k[U] += _[G * u + U];
				(0 === k[U] || k[U] === n.minIterations) && z++;
			}
			if (z === u) break;
		}
	}
	for (var q = Ft(u, l, h), j = Fi(u, p, q), W = {}, Y = 0; Y < q.length; Y++) W[q[Y]] = [];
	for (var V = 0; V < i.length; V++) {
		var H = j[a[i[V].id()]];
		null != H && W[H].push(i[V]);
	}
	for (var X = Array(q.length), K = 0; K < q.length; K++) X[K] = r.collection(W[q[K]]);
	return X;
}, "affinityPropagation"), Fa = $o({
	root: void 0,
	directed: !1
}), Fs = { hierholzer: h(function(e) {
	if (!DY(e)) {
		var t = arguments;
		e = {
			root: t[0],
			directed: t[1]
		};
	}
	var r, i, n, a = Fa(e), s = a.root, o = a.directed, l = !1;
	s && (n = Dq(s) ? this.filter(s)[0].id() : s[0].id());
	var u = {}, d = {};
	o ? this.forEach(function(e) {
		var t = e.id();
		if (e.isNode()) {
			var n = e.indegree(!0), a = e.outdegree(!0), s = n - a, o = a - n;
			1 == s ? r ? l = !0 : r = t : 1 == o ? i ? l = !0 : i = t : (o > 1 || s > 1) && (l = !0), u[t] = [], e.outgoers().forEach(function(e) {
				e.isEdge() && u[t].push(e.id());
			});
		} else d[t] = [void 0, e.target().id()];
	}) : this.forEach(function(e) {
		var t = e.id();
		e.isNode() ? (e.degree(!0) % 2 && (r ? i ? l = !0 : i = t : r = t), u[t] = [], e.connectedEdges().forEach(function(e) {
			return u[t].push(e.id());
		})) : d[t] = [e.source().id(), e.target().id()];
	});
	var p = {
		found: !1,
		trail: void 0
	};
	if (l) return p;
	if (i && r) if (o) {
		if (n && i != n) return p;
		n = i;
	} else {
		if (n && i != n && r != n) return p;
		n || (n = i);
	}
	else n || (n = this[0].id());
	var f = h(function(e) {
		for (var t, r, i, n = e, a = [e]; u[n].length;) r = d[t = u[n].shift()][0], n != (i = d[t][1]) ? (u[i] = u[i].filter(function(e) {
			return e != t;
		}), n = i) : o || n == r || (u[r] = u[r].filter(function(e) {
			return e != t;
		}), n = r), a.unshift(t), a.unshift(n);
		return a;
	}, "walk"), g = [], m = [];
	for (m = f(n); 1 != m.length;) 0 == u[m[0]].length ? (g.unshift(this.getElementById(m.shift())), g.unshift(this.getElementById(m.shift()))) : m = f(m.shift()).concat(m);
	for (var y in g.unshift(this.getElementById(m.shift())), u) if (u[y].length) return p;
	return p.found = !0, p.trail = this.spawn(g, !0), p;
}, "hierholzer") }, Fo = h(function() {
	var e = this, t = {}, r = 0, i = 0, n = [], a = [], s = {}, o = h(function(r, i) {
		for (var s = a.length - 1, o = [], l = e.spawn(); a[s].x != r || a[s].y != i;) o.push(a.pop().edge), s--;
		o.push(a.pop().edge), o.forEach(function(r) {
			var i = r.connectedNodes().intersection(e);
			l.merge(r), i.forEach(function(r) {
				var i = r.id(), n = r.connectedEdges().intersection(e);
				l.merge(r), t[i].cutVertex ? l.merge(n.filter(function(e) {
					return e.isLoop();
				})) : l.merge(n);
			});
		}), n.push(l);
	}, "buildComponent"), l = h(function(h, u, d) {
		h === d && (i += 1), t[u] = {
			id: r,
			low: r++,
			cutVertex: !1
		};
		var p, f, g, m, y = e.getElementById(u).connectedEdges().intersection(e);
		0 === y.size() ? n.push(e.spawn(e.getElementById(u))) : y.forEach(function(e) {
			p = e.source().id(), f = e.target().id(), (g = p === u ? f : p) !== d && (s[m = e.id()] || (s[m] = !0, a.push({
				x: u,
				y: g,
				edge: e
			})), g in t ? t[u].low = Math.min(t[u].low, t[g].id) : (l(h, g, u), t[u].low = Math.min(t[u].low, t[g].low), t[u].id <= t[g].low && (t[u].cutVertex = !0, o(u, g))));
		});
	}, "biconnectedSearch");
	e.forEach(function(e) {
		if (e.isNode()) {
			var r = e.id();
			r in t || (i = 0, l(r, r), t[r].cutVertex = i > 1);
		}
	});
	var u = Object.keys(t).filter(function(e) {
		return t[e].cutVertex;
	}).map(function(t) {
		return e.getElementById(t);
	});
	return {
		cut: e.spawn(u),
		components: n
	};
}, "hopcroftTarjanBiconnected"), Fl = h(function() {
	var e = this, t = {}, r = 0, i = [], n = [], a = e.spawn(e), s = h(function(o) {
		if (n.push(o), t[o] = {
			index: r,
			low: r++,
			explored: !1
		}, e.getElementById(o).connectedEdges().intersection(e).forEach(function(e) {
			var r = e.target().id();
			r !== o && (r in t || s(r), t[r].explored || (t[o].low = Math.min(t[o].low, t[r].low)));
		}), t[o].index === t[o].low) {
			for (var l = e.spawn();;) {
				var h = n.pop();
				if (l.merge(e.getElementById(h)), t[h].low = t[o].index, t[h].explored = !0, h === o) break;
			}
			var u = l.edgesWith(l), d = l.merge(u);
			i.push(d), a = a.difference(d);
		}
	}, "stronglyConnectedSearch");
	return e.forEach(function(e) {
		if (e.isNode()) {
			var r = e.id();
			r in t || s(r);
		}
	}), {
		cut: a,
		components: i
	};
}, "tarjanStronglyConnected"), Fc = {};
[
	$x,
	$5,
	$3,
	$7,
	$9,
	Pt,
	Pa,
	Bo,
	Bc,
	Bu,
	Bp,
	{
		markovClustering: BC,
		mcl: BC
	},
	{
		kMeans: BV,
		kMedoids: BH,
		fuzzyCMeans: BQ,
		fcm: BQ
	},
	{
		hierarchicalClustering: B6,
		hca: B6
	},
	{
		affinityPropagation: Fn,
		ap: Fn
	},
	Fs,
	{
		hopcroftTarjanBiconnected: Fo,
		htbc: Fo,
		htb: Fo,
		hopcroftTarjanBiconnectedComponents: Fo
	},
	{
		tarjanStronglyConnected: Fl,
		tsc: Fl,
		tscc: Fl,
		tarjanStronglyConnectedComponents: Fl
	}
].forEach(function(e) {
	Ou(Fc, e);
});
var Fh = h(function(e) {
	if (!(this instanceof Fh)) return new Fh(e);
	this.id = "Thenable/1.0.7", this.state = 0, this.fulfillValue = void 0, this.rejectReason = void 0, this.onFulfilled = [], this.onRejected = [], this.proxy = { then: this.then.bind(this) }, "function" == typeof e && e.call(this, this.fulfill.bind(this), this.reject.bind(this));
}, "api");
Fh.prototype = {
	fulfill: h(function(e) {
		return Fu(this, 1, "fulfillValue", e);
	}, "fulfill"),
	reject: h(function(e) {
		return Fu(this, 2, "rejectReason", e);
	}, "reject"),
	then: h(function(e, t) {
		var r = new Fh();
		return this.onFulfilled.push(Ff(e, r, "fulfill")), this.onRejected.push(Ff(t, r, "reject")), Fd(this), r.proxy;
	}, "then")
};
var Fu = h(function(e, t, r, i) {
	return 0 === e.state && (e.state = t, e[r] = i, Fd(e)), e;
}, "deliver"), Fd = h(function(e) {
	1 === e.state ? Fp(e, "onFulfilled", e.fulfillValue) : 2 === e.state && Fp(e, "onRejected", e.rejectReason);
}, "execute"), Fp = h(function(e, t, r) {
	if (0 !== e[t].length) {
		var i = e[t];
		e[t] = [];
		var n = h(function() {
			for (var e = 0; e < i.length; e++) i[e](r);
		}, "func");
		"function" == typeof setImmediate ? setImmediate(n) : setTimeout(n, 0);
	}
}, "execute_handlers"), Ff = h(function(e, t, r) {
	return function(i) {
		if ("function" != typeof e) t[r].call(t, i);
		else {
			var n;
			try {
				n = e(i);
			} catch (e) {
				t.reject(e);
				return;
			}
			Fg(t, n);
		}
	};
}, "resolver"), Fg = h(function(e, t) {
	if (e === t || e.proxy === t) return void e.reject(TypeError("cannot resolve promise with itself"));
	if ("object" === DD(t) && null !== t || "function" == typeof t) try {
		r = t.then;
	} catch (t) {
		e.reject(t);
		return;
	}
	if ("function" == typeof r) {
		var r, i = !1;
		try {
			r.call(t, function(r) {
				i || (i = !0, r === t ? e.reject(TypeError("circular thenable chain")) : Fg(e, r));
			}, function(t) {
				i || (i = !0, e.reject(t));
			});
		} catch (t) {
			i || e.reject(t);
		}
		return;
	}
	e.fulfill(t);
}, "resolve");
Fh.all = function(e) {
	return new Fh(function(t, r) {
		for (var i = Array(e.length), n = 0, a = h(function(r, a) {
			i[r] = a, ++n === e.length && t(i);
		}, "fulfill"), s = 0; s < e.length; s++) (function(t) {
			var i = e[t];
			null != i && null != i.then ? i.then(function(e) {
				a(t, e);
			}, function(e) {
				r(e);
			}) : a(t, i);
		})(s);
	});
}, Fh.resolve = function(e) {
	return new Fh(function(t, r) {
		t(e);
	});
}, Fh.reject = function(e) {
	return new Fh(function(t, r) {
		r(e);
	});
};
var Fm = "u" > typeof Promise ? Promise : Fh, Fy = h(function(e, t, r) {
	var i = D0(e), n = this._private = Ou({ duration: 1e3 }, t, r);
	if (n.target = e, n.style = n.style || n.css, n.started = !1, n.playing = !1, n.hooked = !1, n.applying = !1, n.progress = 0, n.completes = [], n.frames = [], n.complete && Dj(n.complete) && n.completes.push(n.complete), !i) {
		var a = e.position();
		n.startPosition = n.startPosition || {
			x: a.x,
			y: a.y
		}, n.startStyle = n.startStyle || e.cy().style().getAnimationStartStyle(e, n.style);
	}
	if (i) {
		var s = e.pan();
		n.startPan = {
			x: s.x,
			y: s.y
		}, n.startZoom = e.zoom();
	}
	this.length = 1, this[0] = this;
}, "Animation"), Fv = Fy.prototype;
Ou(Fv, {
	instanceString: h(function() {
		return "animation";
	}, "instanceString"),
	hook: h(function() {
		var e = this._private;
		if (!e.hooked) {
			var t = e.target._private.animation;
			(e.queue ? t.queue : t.current).push(this), DZ(e.target) && e.target.cy().addToAnimationPool(e.target), e.hooked = !0;
		}
		return this;
	}, "hook"),
	play: h(function() {
		var e = this._private;
		return 1 === e.progress && (e.progress = 0), e.playing = !0, e.started = !1, e.stopped = !1, this.hook(), this;
	}, "play"),
	playing: h(function() {
		return this._private.playing;
	}, "playing"),
	apply: h(function() {
		var e = this._private;
		return e.applying = !0, e.started = !1, e.stopped = !1, this.hook(), this;
	}, "apply"),
	applying: h(function() {
		return this._private.applying;
	}, "applying"),
	pause: h(function() {
		var e = this._private;
		return e.playing = !1, e.started = !1, this;
	}, "pause"),
	stop: h(function() {
		var e = this._private;
		return e.playing = !1, e.started = !1, e.stopped = !0, this;
	}, "stop"),
	rewind: h(function() {
		return this.progress(0);
	}, "rewind"),
	fastforward: h(function() {
		return this.progress(1);
	}, "fastforward"),
	time: h(function(e) {
		var t = this._private;
		return void 0 === e ? t.progress * t.duration : this.progress(e / t.duration);
	}, "time"),
	progress: h(function(e) {
		var t = this._private, r = t.playing;
		return void 0 === e ? t.progress : (r && this.pause(), t.progress = e, t.started = !1, r && this.play(), this);
	}, "progress"),
	completed: h(function() {
		return 1 === this._private.progress;
	}, "completed"),
	reverse: h(function() {
		var e = this._private, t = e.playing;
		t && this.pause(), e.progress = 1 - e.progress, e.started = !1;
		var r = h(function(t, r) {
			var i = e[t];
			null != i && (e[t] = e[r], e[r] = i);
		}, "swap");
		if (r("zoom", "startZoom"), r("pan", "startPan"), r("position", "startPosition"), e.style) for (var i = 0; i < e.style.length; i++) {
			var n = e.style[i], a = n.name, s = e.startStyle[a];
			e.startStyle[a] = n, e.style[i] = s;
		}
		return t && this.play(), this;
	}, "reverse"),
	promise: h(function(e) {
		var t, r = this._private;
		return t = "frame" === e ? r.frames : r.completes, new Fm(function(e, r) {
			t.push(function() {
				e();
			});
		});
	}, "promise")
}), Fv.complete = Fv.completed, Fv.run = Fv.play, Fv.running = Fv.playing;
var Fx, Fb, Fw = {
	animated: h(function() {
		return h(function() {
			var e = void 0 !== this.length ? this : [this];
			if (!(this._private.cy || this).styleEnabled()) return !1;
			var t = e[0];
			if (t) return t._private.animation.current.length > 0;
		}, "animatedImpl");
	}, "animated"),
	clearQueue: h(function() {
		return h(function() {
			var e = void 0 !== this.length ? this : [this];
			if (!(this._private.cy || this).styleEnabled()) return this;
			for (var t = 0; t < e.length; t++) e[t]._private.animation.queue = [];
			return this;
		}, "clearQueueImpl");
	}, "clearQueue"),
	delay: h(function() {
		return h(function(e, t) {
			return (this._private.cy || this).styleEnabled() ? this.animate({
				delay: e,
				duration: e,
				complete: t
			}) : this;
		}, "delayImpl");
	}, "delay"),
	delayAnimation: h(function() {
		return h(function(e, t) {
			return (this._private.cy || this).styleEnabled() ? this.animation({
				delay: e,
				duration: e,
				complete: t
			}) : this;
		}, "delayAnimationImpl");
	}, "delayAnimation"),
	animation: h(function() {
		return h(function(e, t) {
			var r = void 0 !== this.length, i = r ? this : [this], n = this._private.cy || this, a = !r, s = !a;
			if (!n.styleEnabled()) return this;
			var o = n.style();
			if (0 === Object.keys(e = Ou({}, e, t)).length) return new Fy(i[0], e);
			switch (void 0 === e.duration && (e.duration = 400), e.duration) {
				case "slow":
					e.duration = 600;
					break;
				case "fast": e.duration = 200;
			}
			if (s && (e.style = o.getPropsList(e.style || e.css), e.css = void 0), s && null != e.renderedPosition) {
				var l = e.renderedPosition, h = n.pan();
				e.position = Pl(l, n.zoom(), h);
			}
			if (a && null != e.panBy) {
				var u = e.panBy, d = n.pan();
				e.pan = {
					x: d.x + u.x,
					y: d.y + u.y
				};
			}
			var p = e.center || e.centre;
			if (a && null != p) {
				var f = n.getCenterPan(p.eles, e.zoom);
				null != f && (e.pan = f);
			}
			if (a && null != e.fit) {
				var g = e.fit, m = n.getFitViewport(g.eles || g.boundingBox, g.padding);
				null != m && (e.pan = m.pan, e.zoom = m.zoom);
			}
			if (a && DY(e.zoom)) {
				var y = n.getZoomedViewport(e.zoom);
				null != y ? (y.zoomed && (e.zoom = y.zoom), y.panned && (e.pan = y.pan)) : e.zoom = null;
			}
			return new Fy(i[0], e);
		}, "animationImpl");
	}, "animation"),
	animate: h(function() {
		return h(function(e, t) {
			var r = void 0 !== this.length ? this : [this];
			if (!(this._private.cy || this).styleEnabled()) return this;
			t && (e = Ou({}, e, t));
			for (var i = 0; i < r.length; i++) {
				var n = r[i], a = n.animated() && (void 0 === e.queue || e.queue);
				n.animation(e, a ? { queue: !0 } : void 0).play();
			}
			return this;
		}, "animateImpl");
	}, "animate"),
	stop: h(function() {
		return h(function(e, t) {
			var r = void 0 !== this.length ? this : [this], i = this._private.cy || this;
			if (!i.styleEnabled()) return this;
			for (var n = 0; n < r.length; n++) {
				for (var a = r[n]._private, s = a.animation.current, o = 0; o < s.length; o++) {
					var l = s[o]._private;
					t && (l.duration = 0);
				}
				e && (a.animation.queue = []), t || (a.animation.current = []);
			}
			return i.notify("draw"), this;
		}, "stopImpl");
	}, "stop")
};
function Fk() {
	return Fb ? Fx : (Fb = 1, Fx = Array.isArray);
}
function FT() {
	if (zr) return zt;
	zr = 1;
	var e = Fk(), t = OM(), r = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, i = /^\w*$/;
	function n(n, a) {
		if (e(n)) return !1;
		var s = typeof n;
		return !!("number" == s || "symbol" == s || "boolean" == s || null == n || t(n)) || i.test(n) || !r.test(n) || null != a && n in Object(a);
	}
	return h(n, "isKey"), zt = n;
}
function F_() {
	if (zn) return zi;
	zn = 1;
	var e = ON(), t = Ok();
	function r(r) {
		if (!t(r)) return !1;
		var i = e(r);
		return "[object Function]" == i || "[object GeneratorFunction]" == i || "[object AsyncFunction]" == i || "[object Proxy]" == i;
	}
	return h(r, "isFunction"), zi = r;
}
function FE() {
	return zs ? za : (zs = 1, za = O_()["__core-js_shared__"]);
}
function FC() {
	if (zl) return zo;
	zl = 1;
	var e, t = FE(), r = (e = /[^.]+$/.exec(t && t.keys && t.keys.IE_PROTO || "")) ? "Symbol(src)_1." + e : "";
	function i(e) {
		return !!r && r in e;
	}
	return h(i, "isMasked"), zo = i;
}
function FS() {
	if (zh) return zc;
	zh = 1;
	var e = Function.prototype.toString;
	function t(t) {
		if (null != t) {
			try {
				return e.call(t);
			} catch {}
			try {
				return t + "";
			} catch {}
		}
		return "";
	}
	return h(t, "toSource"), zc = t;
}
function FA() {
	if (zd) return zu;
	zd = 1;
	var e = F_(), t = FC(), r = Ok(), i = FS(), n = /^\[object .+?Constructor\]$/, a = Object.prototype, s = Function.prototype.toString, o = a.hasOwnProperty, l = RegExp("^" + s.call(o).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
	function u(a) {
		return !(!r(a) || t(a)) && (e(a) ? l : n).test(i(a));
	}
	return h(u, "baseIsNative"), zu = u;
}
function FL() {
	if (zf) return zp;
	function e(e, t) {
		return e?.[t];
	}
	return zf = 1, h(e, "getValue"), zp = e;
}
function FR() {
	if (zm) return zg;
	zm = 1;
	var e = FA(), t = FL();
	function r(r, i) {
		var n = t(r, i);
		return e(n) ? n : void 0;
	}
	return h(r, "getNative"), zg = r;
}
function FN() {
	return zv ? zy : (zv = 1, zy = FR()(Object, "create"));
}
function FI() {
	if (zb) return zx;
	zb = 1;
	var e = FN();
	function t() {
		this.__data__ = e ? e(null) : {}, this.size = 0;
	}
	return h(t, "hashClear"), zx = t;
}
function FM() {
	if (zk) return zw;
	function e(e) {
		var t = this.has(e) && delete this.__data__[e];
		return this.size -= !!t, t;
	}
	return zk = 1, h(e, "hashDelete"), zw = e;
}
function FD() {
	if (z_) return zT;
	z_ = 1;
	var e = FN(), t = Object.prototype.hasOwnProperty;
	function r(r) {
		var i = this.__data__;
		if (e) {
			var n = i[r];
			return "__lodash_hash_undefined__" === n ? void 0 : n;
		}
		return t.call(i, r) ? i[r] : void 0;
	}
	return h(r, "hashGet"), zT = r;
}
function FO() {
	if (zC) return zE;
	zC = 1;
	var e = FN(), t = Object.prototype.hasOwnProperty;
	function r(r) {
		var i = this.__data__;
		return e ? void 0 !== i[r] : t.call(i, r);
	}
	return h(r, "hashHas"), zE = r;
}
function F$() {
	if (zA) return zS;
	zA = 1;
	var e = FN();
	function t(t, r) {
		var i = this.__data__;
		return this.size += +!this.has(t), i[t] = e && void 0 === r ? "__lodash_hash_undefined__" : r, this;
	}
	return h(t, "hashSet"), zS = t;
}
function FP() {
	if (zR) return zL;
	zR = 1;
	var e = FI(), t = FM(), r = FD(), i = FO(), n = F$();
	function a(e) {
		var t = -1, r = null == e ? 0 : e.length;
		for (this.clear(); ++t < r;) {
			var i = e[t];
			this.set(i[0], i[1]);
		}
	}
	return h(a, "Hash"), a.prototype.clear = e, a.prototype.delete = t, a.prototype.get = r, a.prototype.has = i, a.prototype.set = n, zL = a;
}
function FB() {
	if (zI) return zN;
	function e() {
		this.__data__ = [], this.size = 0;
	}
	return zI = 1, h(e, "listCacheClear"), zN = e;
}
function FF() {
	if (zD) return zM;
	function e(e, t) {
		return e === t || e != e && t != t;
	}
	return zD = 1, h(e, "eq"), zM = e;
}
function Fz() {
	if (z$) return zO;
	z$ = 1;
	var e = FF();
	function t(t, r) {
		for (var i = t.length; i--;) if (e(t[i][0], r)) return i;
		return -1;
	}
	return h(t, "assocIndexOf"), zO = t;
}
function FU() {
	if (zB) return zP;
	zB = 1;
	var e = Fz(), t = Array.prototype.splice;
	function r(r) {
		var i = this.__data__, n = e(i, r);
		return !(n < 0) && (n == i.length - 1 ? i.pop() : t.call(i, n, 1), --this.size, !0);
	}
	return h(r, "listCacheDelete"), zP = r;
}
function FG() {
	if (zz) return zF;
	zz = 1;
	var e = Fz();
	function t(t) {
		var r = this.__data__, i = e(r, t);
		return i < 0 ? void 0 : r[i][1];
	}
	return h(t, "listCacheGet"), zF = t;
}
function Fq() {
	if (zG) return zU;
	zG = 1;
	var e = Fz();
	function t(t) {
		return e(this.__data__, t) > -1;
	}
	return h(t, "listCacheHas"), zU = t;
}
function Fj() {
	if (zj) return zq;
	zj = 1;
	var e = Fz();
	function t(t, r) {
		var i = this.__data__, n = e(i, t);
		return n < 0 ? (++this.size, i.push([t, r])) : i[n][1] = r, this;
	}
	return h(t, "listCacheSet"), zq = t;
}
function FW() {
	if (zY) return zW;
	zY = 1;
	var e = FB(), t = FU(), r = FG(), i = Fq(), n = Fj();
	function a(e) {
		var t = -1, r = null == e ? 0 : e.length;
		for (this.clear(); ++t < r;) {
			var i = e[t];
			this.set(i[0], i[1]);
		}
	}
	return h(a, "ListCache"), a.prototype.clear = e, a.prototype.delete = t, a.prototype.get = r, a.prototype.has = i, a.prototype.set = n, zW = a;
}
function FY() {
	return zH ? zV : (zH = 1, zV = FR()(O_(), "Map"));
}
function FV() {
	if (zK) return zX;
	zK = 1;
	var e = FP(), t = FW(), r = FY();
	function i() {
		this.size = 0, this.__data__ = {
			hash: new e(),
			map: new (r || t)(),
			string: new e()
		};
	}
	return h(i, "mapCacheClear"), zX = i;
}
function FH() {
	if (zQ) return zZ;
	function e(e) {
		var t = typeof e;
		return "string" == t || "number" == t || "symbol" == t || "boolean" == t ? "__proto__" !== e : null === e;
	}
	return zQ = 1, h(e, "isKeyable"), zZ = e;
}
function FX() {
	if (z0) return zJ;
	z0 = 1;
	var e = FH();
	function t(t, r) {
		var i = t.__data__;
		return e(r) ? i["string" == typeof r ? "string" : "hash"] : i.map;
	}
	return h(t, "getMapData"), zJ = t;
}
function FK() {
	if (z2) return z1;
	z2 = 1;
	var e = FX();
	function t(t) {
		var r = e(this, t).delete(t);
		return this.size -= !!r, r;
	}
	return h(t, "mapCacheDelete"), z1 = t;
}
function FZ() {
	if (z5) return z4;
	z5 = 1;
	var e = FX();
	function t(t) {
		return e(this, t).get(t);
	}
	return h(t, "mapCacheGet"), z4 = t;
}
function FQ() {
	if (z6) return z3;
	z6 = 1;
	var e = FX();
	function t(t) {
		return e(this, t).has(t);
	}
	return h(t, "mapCacheHas"), z3 = t;
}
function FJ() {
	if (z8) return z7;
	z8 = 1;
	var e = FX();
	function t(t, r) {
		var i = e(this, t), n = i.size;
		return i.set(t, r), this.size += +(i.size != n), this;
	}
	return h(t, "mapCacheSet"), z7 = t;
}
function F0() {
	if (Ue) return z9;
	Ue = 1;
	var e = FV(), t = FK(), r = FZ(), i = FQ(), n = FJ();
	function a(e) {
		var t = -1, r = null == e ? 0 : e.length;
		for (this.clear(); ++t < r;) {
			var i = e[t];
			this.set(i[0], i[1]);
		}
	}
	return h(a, "MapCache"), a.prototype.clear = e, a.prototype.delete = t, a.prototype.get = r, a.prototype.has = i, a.prototype.set = n, z9 = a;
}
function F1() {
	if (Ur) return Ut;
	Ur = 1;
	var e = F0();
	function t(r, i) {
		if ("function" != typeof r || null != i && "function" != typeof i) throw TypeError("Expected a function");
		var n = h(function() {
			var e = arguments, t = i ? i.apply(this, e) : e[0], a = n.cache;
			if (a.has(t)) return a.get(t);
			var s = r.apply(this, e);
			return n.cache = a.set(t, s) || a, s;
		}, "memoized");
		return n.cache = new (t.Cache || e)(), n;
	}
	return h(t, "memoize"), t.Cache = e, Ut = t;
}
function F2() {
	if (Un) return Ui;
	Un = 1;
	var e = F1();
	function t(t) {
		var r = e(t, function(e) {
			return 500 === i.size && i.clear(), e;
		}), i = r.cache;
		return r;
	}
	return h(t, "memoizeCapped"), Ui = t;
}
function F4() {
	if (Us) return Ua;
	Us = 1;
	var e = F2(), t = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, r = /\\(\\)?/g;
	return Ua = e(function(e) {
		var i = [];
		return 46 === e.charCodeAt(0) && i.push(""), e.replace(t, function(e, t, n, a) {
			i.push(n ? a.replace(r, "$1") : t || e);
		}), i;
	});
}
function F5() {
	if (Ul) return Uo;
	function e(e, t) {
		for (var r = -1, i = null == e ? 0 : e.length, n = Array(i); ++r < i;) n[r] = t(e[r], r, e);
		return n;
	}
	return Ul = 1, h(e, "arrayMap"), Uo = e;
}
function F3() {
	if (Uh) return Uc;
	Uh = 1;
	var e = OA(), t = F5(), r = Fk(), i = OM(), n = e ? e.prototype : void 0, a = n ? n.toString : void 0;
	function s(e) {
		if ("string" == typeof e) return e;
		if (r(e)) return t(e, s) + "";
		if (i(e)) return a ? a.call(e) : "";
		var n = e + "";
		return "0" == n && 1 / e == -Infinity ? "-0" : n;
	}
	return h(s, "baseToString"), Uc = s;
}
function F6() {
	if (Ud) return Uu;
	Ud = 1;
	var e = F3();
	function t(t) {
		return null == t ? "" : e(t);
	}
	return h(t, "toString"), Uu = t;
}
function F7() {
	if (Uf) return Up;
	Uf = 1;
	var e = Fk(), t = FT(), r = F4(), i = F6();
	function n(n, a) {
		return e(n) ? n : t(n, a) ? [n] : r(i(n));
	}
	return h(n, "castPath"), Up = n;
}
function F8() {
	if (Um) return Ug;
	Um = 1;
	var e = OM();
	function t(t) {
		if ("string" == typeof t || e(t)) return t;
		var r = t + "";
		return "0" == r && 1 / t == -Infinity ? "-0" : r;
	}
	return h(t, "toKey"), Ug = t;
}
function F9() {
	if (Uv) return Uy;
	Uv = 1;
	var e = F7(), t = F8();
	function r(r, i) {
		i = e(i, r);
		for (var n = 0, a = i.length; null != r && n < a;) r = r[t(i[n++])];
		return n && n == a ? r : void 0;
	}
	return h(r, "baseGet"), Uy = r;
}
function ze() {
	if (Ub) return Ux;
	Ub = 1;
	var e = F9();
	function t(t, r, i) {
		var n = null == t ? void 0 : e(t, r);
		return void 0 === n ? i : n;
	}
	return h(t, "get"), Ux = t;
}
h(Fk, "requireIsArray"), h(FT, "require_isKey"), h(F_, "requireIsFunction"), h(FE, "require_coreJsData"), h(FC, "require_isMasked"), h(FS, "require_toSource"), h(FA, "require_baseIsNative"), h(FL, "require_getValue"), h(FR, "require_getNative"), h(FN, "require_nativeCreate"), h(FI, "require_hashClear"), h(FM, "require_hashDelete"), h(FD, "require_hashGet"), h(FO, "require_hashHas"), h(F$, "require_hashSet"), h(FP, "require_Hash"), h(FB, "require_listCacheClear"), h(FF, "requireEq"), h(Fz, "require_assocIndexOf"), h(FU, "require_listCacheDelete"), h(FG, "require_listCacheGet"), h(Fq, "require_listCacheHas"), h(Fj, "require_listCacheSet"), h(FW, "require_ListCache"), h(FY, "require_Map"), h(FV, "require_mapCacheClear"), h(FH, "require_isKeyable"), h(FX, "require_getMapData"), h(FK, "require_mapCacheDelete"), h(FZ, "require_mapCacheGet"), h(FQ, "require_mapCacheHas"), h(FJ, "require_mapCacheSet"), h(F0, "require_MapCache"), h(F1, "requireMemoize"), h(F2, "require_memoizeCapped"), h(F4, "require_stringToPath"), h(F5, "require_arrayMap"), h(F3, "require_baseToString"), h(F6, "requireToString"), h(F7, "require_castPath"), h(F8, "require_toKey"), h(F9, "require_baseGet"), h(ze, "requireGet");
var zt, zr, zi, zn, za, zs, zo, zl, zc, zh, zu, zd, zp, zf, zg, zm, zy, zv, zx, zb, zw, zk, zT, z_, zE, zC, zS, zA, zL, zR, zN, zI, zM, zD, zO, z$, zP, zB, zF, zz, zU, zG, zq, zj, zW, zY, zV, zH, zX, zK, zZ, zQ, zJ, z0, z1, z2, z4, z5, z3, z6, z7, z8, z9, Ue, Ut, Ur, Ui, Un, Ua, Us, Uo, Ul, Uc, Uh, Uu, Ud, Up, Uf, Ug, Um, Uy, Uv, Ux, Ub, Uw, Uk, UT = Ow(ze());
function U_() {
	if (Uk) return Uw;
	Uk = 1;
	var e = FR();
	return Uw = function() {
		try {
			var t = e(Object, "defineProperty");
			return t({}, "", {}), t;
		} catch {}
	}();
}
function UE() {
	if (UN) return UR;
	UN = 1;
	var e = U_();
	function t(t, r, i) {
		"__proto__" == r && e ? e(t, r, {
			configurable: !0,
			enumerable: !0,
			value: i,
			writable: !0
		}) : t[r] = i;
	}
	return h(t, "baseAssignValue"), UR = t;
}
function UC() {
	if (UM) return UI;
	UM = 1;
	var e = UE(), t = FF(), r = Object.prototype.hasOwnProperty;
	function i(i, n, a) {
		var s = i[n];
		r.call(i, n) && t(s, a) && (void 0 !== a || n in i) || e(i, n, a);
	}
	return h(i, "assignValue"), UI = i;
}
function US() {
	if (UO) return UD;
	UO = 1;
	var e = /^(?:0|[1-9]\d*)$/;
	function t(t, r) {
		var i = typeof t;
		return !!(r = r ?? 9007199254740991) && ("number" == i || "symbol" != i && e.test(t)) && t > -1 && t % 1 == 0 && t < r;
	}
	return h(t, "isIndex"), UD = t;
}
function UA() {
	if (UP) return U$;
	UP = 1;
	var e = UC(), t = F7(), r = US(), i = Ok(), n = F8();
	function a(a, s, o, l) {
		if (!i(a)) return a;
		s = t(s, a);
		for (var h = -1, u = s.length, d = u - 1, p = a; null != p && ++h < u;) {
			var f = n(s[h]), g = o;
			if ("__proto__" === f || "constructor" === f || "prototype" === f) break;
			if (h != d) {
				var m = p[f];
				void 0 === (g = l ? l(m, f, p) : void 0) && (g = i(m) ? m : r(s[h + 1]) ? [] : {});
			}
			e(p, f, g), p = p[f];
		}
		return a;
	}
	return h(a, "baseSet"), U$ = a;
}
function UL() {
	if (UF) return UB;
	UF = 1;
	var e = UA();
	function t(t, r, i) {
		return null == t ? t : e(t, r, i);
	}
	return h(t, "set"), UB = t;
}
h(U_, "require_defineProperty"), h(UE, "require_baseAssignValue"), h(UC, "require_assignValue"), h(US, "require_isIndex"), h(UA, "require_baseSet"), h(UL, "requireSet");
var UR, UN, UI, UM, UD, UO, U$, UP, UB, UF, Uz, UU, UG = Ow(UL());
function Uq() {
	if (UU) return Uz;
	function e(e, t) {
		var r = -1, i = e.length;
		for (t || (t = Array(i)); ++r < i;) t[r] = e[r];
		return t;
	}
	return UU = 1, h(e, "copyArray"), Uz = e;
}
function Uj() {
	if (Gw) return Gb;
	Gw = 1;
	var e = F5(), t = Uq(), r = Fk(), i = OM(), n = F4(), a = F8(), s = F6();
	function o(o) {
		return r(o) ? e(o, a) : i(o) ? [o] : t(n(s(o)));
	}
	return h(o, "toPath"), Gb = o;
}
h(Uq, "require_copyArray"), h(Uj, "requireToPath");
var UW = Ow(Uj()), UY = {
	data: h(function(e) {
		return e = Ou({}, {
			field: "data",
			bindingEvent: "data",
			allowBinding: !1,
			allowSetting: !1,
			allowGetting: !1,
			settingEvent: "data",
			settingTriggersEvent: !1,
			triggerFnName: "trigger",
			immutableKeys: {},
			updateStyle: !1,
			beforeGet: h(function(e) {}, "beforeGet"),
			beforeSet: h(function(e, t) {}, "beforeSet"),
			onSet: h(function(e) {}, "onSet"),
			canSet: h(function(e) {
				return !0;
			}, "canSet")
		}, e), h(function(t, r) {
			var i, n = e, a = void 0 !== this.length, s = a ? this : [this], o = a ? this[0] : this;
			if (Dq(t)) {
				var l, h = -1 !== t.indexOf(".") && UW(t);
				if (n.allowGetting && void 0 === r) return o && (n.beforeGet(o), l = h && void 0 === o._private[n.field][t] ? UT(o._private[n.field], h) : o._private[n.field][t]), l;
				if (n.allowSetting && void 0 !== r && !n.immutableKeys[t]) {
					var u = DE({}, t, r);
					n.beforeSet(this, u);
					for (var d = 0, p = s.length; d < p; d++) {
						var f = s[d];
						n.canSet(f) && (h && void 0 === o._private[n.field][t] ? UG(f._private[n.field], h, r) : f._private[n.field][t] = r);
					}
					n.updateStyle && this.updateStyle(), n.onSet(this), n.settingTriggersEvent && this[n.triggerFnName](n.settingEvent);
				}
			} else if (n.allowSetting && DY(t)) {
				var g, m, y = Object.keys(t);
				n.beforeSet(this, t);
				for (var v = 0; v < y.length; v++) if (m = t[g = y[v]], !n.immutableKeys[g]) for (var x = 0; x < s.length; x++) {
					var b = s[x];
					n.canSet(b) && (b._private[n.field][g] = m);
				}
				n.updateStyle && this.updateStyle(), n.onSet(this), n.settingTriggersEvent && this[n.triggerFnName](n.settingEvent);
			} else if (n.allowBinding && Dj(t)) this.on(n.bindingEvent, t);
			else if (n.allowGetting && void 0 === t) return o && (n.beforeGet(o), i = o._private[n.field]), i;
			return this;
		}, "dataImpl");
	}, "data"),
	removeData: h(function(e) {
		return e = Ou({}, {
			field: "data",
			event: "data",
			triggerFnName: "trigger",
			triggerEvent: !1,
			immutableKeys: {}
		}, e), h(function(t) {
			var r = e, i = void 0 !== this.length ? this : [this];
			if (Dq(t)) {
				for (var n = t.split(/\s+/), a = n.length, s = 0; s < a; s++) {
					var o = n[s];
					if (!D4(o) && !r.immutableKeys[o]) for (var l = 0, h = i.length; l < h; l++) i[l]._private[r.field][o] = void 0;
				}
				r.triggerEvent && this[r.triggerFnName](r.event);
			} else if (void 0 === t) {
				for (var u = 0, d = i.length; u < d; u++) for (var p = i[u]._private[r.field], f = Object.keys(p), g = 0; g < f.length; g++) {
					var m = f[g];
					r.immutableKeys[m] || (p[m] = void 0);
				}
				r.triggerEvent && this[r.triggerFnName](r.event);
			}
			return this;
		}, "removeDataImpl");
	}, "removeData")
}, UV = { eventAliasesOn: h(function(e) {
	e.addListener = e.listen = e.bind = e.on, e.unlisten = e.unbind = e.off = e.removeListener, e.trigger = e.emit, e.pon = e.promiseOn = function(e, t) {
		var r = this, i = Array.prototype.slice.call(arguments, 0);
		return new Fm(function(e, t) {
			var n = h(function(t) {
				r.off.apply(r, s), e(t);
			}, "callback"), a = i.concat([n]), s = a.concat([]);
			r.on.apply(r, a);
		});
	};
}, "eventAliasesOn") }, UH = {};
[
	Fw,
	UY,
	UV
].forEach(function(e) {
	Ou(UH, e);
});
var UX = {
	animate: UH.animate(),
	animation: UH.animation(),
	animated: UH.animated(),
	clearQueue: UH.clearQueue(),
	delay: UH.delay(),
	delayAnimation: UH.delayAnimation(),
	stop: UH.stop()
}, UK = {
	classes: h(function(e) {
		if (void 0 === e) {
			var t = [];
			return this[0]._private.classes.forEach(function(e) {
				return t.push(e);
			}), t;
		}
		DW(e) || (e = (e || "").match(/\S+/g) || []);
		for (var r = [], i = new $m(e), n = 0; n < this.length; n++) {
			for (var a = this[n], s = a._private, o = s.classes, l = !1, h = 0; h < e.length; h++) {
				var u = e[h];
				if (!o.has(u)) {
					l = !0;
					break;
				}
			}
			l || (l = o.size !== e.length), l && (s.classes = i, r.push(a));
		}
		return r.length > 0 && this.spawn(r).updateStyle().emit("class"), this;
	}, "classes"),
	addClass: h(function(e) {
		return this.toggleClass(e, !0);
	}, "addClass"),
	hasClass: h(function(e) {
		var t = this[0];
		return null != t && t._private.classes.has(e);
	}, "hasClass"),
	toggleClass: h(function(e, t) {
		DW(e) || (e = e.match(/\S+/g) || []);
		for (var r = void 0 === t, i = [], n = 0, a = this.length; n < a; n++) for (var s = this[n], o = s._private.classes, l = !1, h = 0; h < e.length; h++) {
			var u = e[h], d = o.has(u), p = !1;
			t || r && !d ? (o.add(u), p = !0) : (!t || r && d) && (o.delete(u), p = !0), !l && p && (i.push(s), l = !0);
		}
		return i.length > 0 && this.spawn(i).updateStyle().emit("class"), this;
	}, "toggleClass"),
	removeClass: h(function(e) {
		return this.toggleClass(e, !1);
	}, "removeClass"),
	flashClass: h(function(e, t) {
		var r = this;
		if (null == t) t = 250;
		else if (0 === t) return r;
		return r.addClass(e), setTimeout(function() {
			r.removeClass(e);
		}, t), r;
	}, "flashClass")
};
UK.className = UK.classNames = UK.classes;
var UZ = {
	metaChar: "[\\!\\\"\\#\\$\\%\\&\\'\\(\\)\\*\\+\\,\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\]\\^\\`\\{\\|\\}\\~]",
	comparatorOp: "=|\\!=|>|>=|<|<=|\\$=|\\^=|\\*=",
	boolOp: "\\?|\\!|\\^",
	string: "\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'",
	number: On,
	meta: "degree|indegree|outdegree",
	separator: "\\s*,\\s*",
	descendant: "\\s+",
	child: "\\s+>\\s+",
	subject: "\\$",
	group: "node|edge|\\*",
	directedEdge: "\\s+->\\s+",
	undirectedEdge: "\\s+<->\\s+"
};
for (UZ.variable = "(?:[\\w-.]|(?:\\\\" + UZ.metaChar + "))+", UZ.className = "(?:[\\w-]|(?:\\\\" + UZ.metaChar + "))+", UZ.value = UZ.string + "|" + UZ.number, UZ.id = UZ.variable, Gy = UZ.comparatorOp.split("|"), Gx = 0; Gx < Gy.length; Gx++) Gv = Gy[Gx], UZ.comparatorOp += "|@" + Gv;
for (Gy = UZ.comparatorOp.split("|"), Gx = 0; Gx < Gy.length; Gx++) (Gv = Gy[Gx]).indexOf("!") >= 0 || "=" === Gv || (UZ.comparatorOp += "|\\!" + Gv);
var UQ = h(function() {
	return { checks: [] };
}, "newQuery"), UJ = [
	{
		selector: ":selected",
		matches: h(function(e) {
			return e.selected();
		}, "matches")
	},
	{
		selector: ":unselected",
		matches: h(function(e) {
			return !e.selected();
		}, "matches")
	},
	{
		selector: ":selectable",
		matches: h(function(e) {
			return e.selectable();
		}, "matches")
	},
	{
		selector: ":unselectable",
		matches: h(function(e) {
			return !e.selectable();
		}, "matches")
	},
	{
		selector: ":locked",
		matches: h(function(e) {
			return e.locked();
		}, "matches")
	},
	{
		selector: ":unlocked",
		matches: h(function(e) {
			return !e.locked();
		}, "matches")
	},
	{
		selector: ":visible",
		matches: h(function(e) {
			return e.visible();
		}, "matches")
	},
	{
		selector: ":hidden",
		matches: h(function(e) {
			return !e.visible();
		}, "matches")
	},
	{
		selector: ":transparent",
		matches: h(function(e) {
			return e.transparent();
		}, "matches")
	},
	{
		selector: ":grabbed",
		matches: h(function(e) {
			return e.grabbed();
		}, "matches")
	},
	{
		selector: ":free",
		matches: h(function(e) {
			return !e.grabbed();
		}, "matches")
	},
	{
		selector: ":removed",
		matches: h(function(e) {
			return e.removed();
		}, "matches")
	},
	{
		selector: ":inside",
		matches: h(function(e) {
			return !e.removed();
		}, "matches")
	},
	{
		selector: ":grabbable",
		matches: h(function(e) {
			return e.grabbable();
		}, "matches")
	},
	{
		selector: ":ungrabbable",
		matches: h(function(e) {
			return !e.grabbable();
		}, "matches")
	},
	{
		selector: ":animated",
		matches: h(function(e) {
			return e.animated();
		}, "matches")
	},
	{
		selector: ":unanimated",
		matches: h(function(e) {
			return !e.animated();
		}, "matches")
	},
	{
		selector: ":parent",
		matches: h(function(e) {
			return e.isParent();
		}, "matches")
	},
	{
		selector: ":childless",
		matches: h(function(e) {
			return e.isChildless();
		}, "matches")
	},
	{
		selector: ":child",
		matches: h(function(e) {
			return e.isChild();
		}, "matches")
	},
	{
		selector: ":orphan",
		matches: h(function(e) {
			return e.isOrphan();
		}, "matches")
	},
	{
		selector: ":nonorphan",
		matches: h(function(e) {
			return e.isChild();
		}, "matches")
	},
	{
		selector: ":compound",
		matches: h(function(e) {
			return e.isNode() ? e.isParent() : e.source().isParent() || e.target().isParent();
		}, "matches")
	},
	{
		selector: ":loop",
		matches: h(function(e) {
			return e.isLoop();
		}, "matches")
	},
	{
		selector: ":simple",
		matches: h(function(e) {
			return e.isSimple();
		}, "matches")
	},
	{
		selector: ":active",
		matches: h(function(e) {
			return e.active();
		}, "matches")
	},
	{
		selector: ":inactive",
		matches: h(function(e) {
			return !e.active();
		}, "matches")
	},
	{
		selector: ":backgrounding",
		matches: h(function(e) {
			return e.backgrounding();
		}, "matches")
	},
	{
		selector: ":nonbackgrounding",
		matches: h(function(e) {
			return !e.backgrounding();
		}, "matches")
	}
].sort(function(e, t) {
	return Oh(e.selector, t.selector);
}), U0 = function() {
	for (var e, t = {}, r = 0; r < UJ.length; r++) t[(e = UJ[r]).selector] = e.matches;
	return t;
}(), U1 = h(function(e, t) {
	return U0[e](t);
}, "stateSelectorMatches"), U2 = "(" + UJ.map(function(e) {
	return e.selector;
}).join("|") + ")", U4 = h(function(e) {
	return e.replace(RegExp("\\\\(" + UZ.metaChar + ")", "g"), function(e, t) {
		return t;
	});
}, "cleanMetaChars"), U5 = h(function(e, t, r) {
	e[e.length - 1] = r;
}, "replaceLastQuery"), U3 = [
	{
		name: "group",
		query: !0,
		regex: "(" + UZ.group + ")",
		populate: h(function(e, t, r) {
			var i = DR(r, 1)[0];
			t.checks.push({
				type: 0,
				value: "*" === i ? i : i + "s"
			});
		}, "populate")
	},
	{
		name: "state",
		query: !0,
		regex: U2,
		populate: h(function(e, t, r) {
			var i = DR(r, 1)[0];
			t.checks.push({
				type: 7,
				value: i
			});
		}, "populate")
	},
	{
		name: "id",
		query: !0,
		regex: "\\#(" + UZ.id + ")",
		populate: h(function(e, t, r) {
			var i = DR(r, 1)[0];
			t.checks.push({
				type: 8,
				value: U4(i)
			});
		}, "populate")
	},
	{
		name: "className",
		query: !0,
		regex: "\\.(" + UZ.className + ")",
		populate: h(function(e, t, r) {
			var i = DR(r, 1)[0];
			t.checks.push({
				type: 9,
				value: U4(i)
			});
		}, "populate")
	},
	{
		name: "dataExists",
		query: !0,
		regex: "\\[\\s*(" + UZ.variable + ")\\s*\\]",
		populate: h(function(e, t, r) {
			var i = DR(r, 1)[0];
			t.checks.push({
				type: 4,
				field: U4(i)
			});
		}, "populate")
	},
	{
		name: "dataCompare",
		query: !0,
		regex: "\\[\\s*(" + UZ.variable + ")\\s*(" + UZ.comparatorOp + ")\\s*(" + UZ.value + ")\\s*\\]",
		populate: h(function(e, t, r) {
			var i = DR(r, 3), n = i[0], a = i[1], s = i[2];
			s = null != RegExp("^" + UZ.string + "$").exec(s) ? s.substring(1, s.length - 1) : parseFloat(s), t.checks.push({
				type: 3,
				field: U4(n),
				operator: a,
				value: s
			});
		}, "populate")
	},
	{
		name: "dataBool",
		query: !0,
		regex: "\\[\\s*(" + UZ.boolOp + ")\\s*(" + UZ.variable + ")\\s*\\]",
		populate: h(function(e, t, r) {
			var i = DR(r, 2), n = i[0], a = i[1];
			t.checks.push({
				type: 5,
				field: U4(a),
				operator: n
			});
		}, "populate")
	},
	{
		name: "metaCompare",
		query: !0,
		regex: "\\[\\[\\s*(" + UZ.meta + ")\\s*(" + UZ.comparatorOp + ")\\s*(" + UZ.number + ")\\s*\\]\\]",
		populate: h(function(e, t, r) {
			var i = DR(r, 3), n = i[0], a = i[1], s = i[2];
			t.checks.push({
				type: 6,
				field: U4(n),
				operator: a,
				value: parseFloat(s)
			});
		}, "populate")
	},
	{
		name: "nextQuery",
		separator: !0,
		regex: UZ.separator,
		populate: h(function(e, t) {
			var r = e.currentSubject, i = e.edgeCount, n = e.compoundCount, a = e[e.length - 1];
			return null != r && (a.subject = r, e.currentSubject = null), a.edgeCount = i, a.compoundCount = n, e.edgeCount = 0, e.compoundCount = 0, e[e.length++] = UQ();
		}, "populate")
	},
	{
		name: "directedEdge",
		separator: !0,
		regex: UZ.directedEdge,
		populate: h(function(e, t) {
			if (null == e.currentSubject) {
				var r = UQ(), i = UQ();
				return r.checks.push({
					type: 11,
					source: t,
					target: i
				}), U5(e, t, r), e.edgeCount++, i;
			}
			var n = UQ(), a = UQ();
			return n.checks.push({
				type: 12,
				source: t,
				target: a
			}), U5(e, t, n), e.edgeCount++, a;
		}, "populate")
	},
	{
		name: "undirectedEdge",
		separator: !0,
		regex: UZ.undirectedEdge,
		populate: h(function(e, t) {
			if (null == e.currentSubject) {
				var r = UQ(), i = UQ();
				return r.checks.push({
					type: 10,
					nodes: [t, i]
				}), U5(e, t, r), e.edgeCount++, i;
			}
			var n = UQ(), a = UQ();
			return n.checks.push({
				type: 14,
				node: t,
				neighbor: a
			}), U5(e, t, n), a;
		}, "populate")
	},
	{
		name: "child",
		separator: !0,
		regex: UZ.child,
		populate: h(function(e, t) {
			if (null == e.currentSubject) {
				var r = UQ(), i = UQ(), n = e[e.length - 1];
				return r.checks.push({
					type: 15,
					parent: n,
					child: i
				}), U5(e, t, r), e.compoundCount++, i;
			}
			if (e.currentSubject === t) {
				var a = UQ(), s = e[e.length - 1], o = UQ(), l = UQ(), h = UQ(), u = UQ();
				return a.checks.push({
					type: 19,
					left: s,
					right: o,
					subject: l
				}), l.checks = t.checks, t.checks = [{ type: 20 }], u.checks.push({ type: 20 }), o.checks.push({
					type: 17,
					parent: u,
					child: h
				}), U5(e, s, a), e.currentSubject = l, e.compoundCount++, h;
			}
			var d = UQ(), p = UQ(), f = [{
				type: 17,
				parent: d,
				child: p
			}];
			return d.checks = t.checks, t.checks = f, e.compoundCount++, p;
		}, "populate")
	},
	{
		name: "descendant",
		separator: !0,
		regex: UZ.descendant,
		populate: h(function(e, t) {
			if (null == e.currentSubject) {
				var r = UQ(), i = UQ(), n = e[e.length - 1];
				return r.checks.push({
					type: 16,
					ancestor: n,
					descendant: i
				}), U5(e, t, r), e.compoundCount++, i;
			}
			if (e.currentSubject === t) {
				var a = UQ(), s = e[e.length - 1], o = UQ(), l = UQ(), h = UQ(), u = UQ();
				return a.checks.push({
					type: 19,
					left: s,
					right: o,
					subject: l
				}), l.checks = t.checks, t.checks = [{ type: 20 }], u.checks.push({ type: 20 }), o.checks.push({
					type: 18,
					ancestor: u,
					descendant: h
				}), U5(e, s, a), e.currentSubject = l, e.compoundCount++, h;
			}
			var d = UQ(), p = UQ(), f = [{
				type: 18,
				ancestor: d,
				descendant: p
			}];
			return d.checks = t.checks, t.checks = f, e.compoundCount++, p;
		}, "populate")
	},
	{
		name: "subject",
		modifier: !0,
		regex: UZ.subject,
		populate: h(function(e, t) {
			if (null != e.currentSubject && e.currentSubject !== t) return $e("Redefinition of subject in selector `" + e.toString() + "`"), !1;
			e.currentSubject = t;
			var r = e[e.length - 1].checks[0], i = null == r ? null : r.type;
			11 === i ? r.type = 13 : 10 === i && (r.type = 14, r.node = r.nodes[1], r.neighbor = r.nodes[0], r.nodes = null);
		}, "populate")
	}
];
U3.forEach(function(e) {
	return e.regexObj = RegExp("^" + e.regex);
});
var U6 = h(function(e) {
	for (var t, r, i, n = 0; n < U3.length; n++) {
		var a = U3[n], s = a.name, o = e.match(a.regexObj);
		if (null != o) {
			r = o, t = a, i = s;
			var l = o[0];
			e = e.substring(l.length);
			break;
		}
	}
	return {
		expr: t,
		match: r,
		name: i,
		remaining: e
	};
}, "consumeExpr"), U7 = h(function(e) {
	var t = e.match(/^\s+/);
	if (t) {
		var r = t[0];
		e = e.substring(r.length);
	}
	return e;
}, "consumeWhitespace"), U8 = {
	parse: h(function(e) {
		var t = this.inputText = e, r = this[0] = UQ();
		for (this.length = 1, t = U7(t);;) {
			var i = U6(t);
			if (null == i.expr) return $e("The selector `" + e + "`is invalid"), !1;
			var n = i.match.slice(1), a = i.expr.populate(this, r, n);
			if (!1 === a) return !1;
			if (null != a && (r = a), (t = i.remaining).match(/^\s*$/)) break;
		}
		var s = this[this.length - 1];
		null != this.currentSubject && (s.subject = this.currentSubject), s.edgeCount = this.edgeCount, s.compoundCount = this.compoundCount;
		for (var o = 0; o < this.length; o++) {
			var l = this[o];
			if (l.compoundCount > 0 && l.edgeCount > 0) return $e("The selector `" + e + "` is invalid because it uses both a compound selector and an edge selector"), !1;
			if (l.edgeCount > 1) return $e("The selector `" + e + "` is invalid because it uses multiple edge selectors"), !1;
			1 === l.edgeCount && $e("The selector `" + e + "` is deprecated.  Edge selectors do not take effect on changes to source and target nodes after an edge is added, for performance reasons.  Use a class or data selector on edges instead, updating the class or data of an edge when your app detects a change in source or target nodes.");
		}
		return !0;
	}, "parse"),
	toString: h(function() {
		if (null != this.toStringCache) return this.toStringCache;
		for (var e = h(function(e) {
			return e ?? "";
		}, "clean"), t = h(function(t) {
			return Dq(t) ? "\"" + t + "\"" : e(t);
		}, "cleanVal"), r = h(function(e) {
			return " " + e + " ";
		}, "space"), i = h(function(i, a) {
			var s = i.type, o = i.value;
			switch (s) {
				case 0:
					var l = e(o);
					return l.substring(0, l.length - 1);
				case 3: return "[" + i.field + r(e(i.operator)) + t(o) + "]";
				case 5:
					var h = i.operator, u = i.field;
					return "[" + e(h) + u + "]";
				case 4: return "[" + i.field + "]";
				case 6:
					var d = i.operator;
					return "[[" + i.field + r(e(d)) + t(o) + "]]";
				case 7: return o;
				case 8: return "#" + o;
				case 9: return "." + o;
				case 17:
				case 15: return n(i.parent, a) + r(">") + n(i.child, a);
				case 18:
				case 16: return n(i.ancestor, a) + " " + n(i.descendant, a);
				case 19:
					var p = n(i.left, a), f = n(i.subject, a), g = n(i.right, a);
					return p + (p.length > 0 ? " " : "") + f + g;
				case 20: return "";
			}
		}, "checkToString"), n = h(function(e, t) {
			return e.checks.reduce(function(r, n, a) {
				return r + (t === e && 0 === a ? "$" : "") + i(n, t);
			}, "");
		}, "queryToString"), a = "", s = 0; s < this.length; s++) {
			var o = this[s];
			a += n(o, o.subject), this.length > 1 && s < this.length - 1 && (a += ", ");
		}
		return this.toStringCache = a, a;
	}, "toString")
}, U9 = h(function(e, t, r) {
	var i, n, a, s = Dq(e), o = DH(e), l = Dq(r), h = !1, u = !1, d = !1;
	switch (t.indexOf("!") >= 0 && (t = t.replace("!", ""), u = !0), t.indexOf("@") >= 0 && (t = t.replace("@", ""), h = !0), (s || l || h) && (n = !s && !o ? "" : "" + e, a = "" + r), h && (e = n = n.toLowerCase(), r = a = a.toLowerCase()), t) {
		case "*=":
			i = n.indexOf(a) >= 0;
			break;
		case "$=":
			i = n.indexOf(a, n.length - a.length) >= 0;
			break;
		case "^=":
			i = 0 === n.indexOf(a);
			break;
		case "=":
			i = e === r;
			break;
		case ">":
			d = !0, i = e > r;
			break;
		case ">=":
			d = !0, i = e >= r;
			break;
		case "<":
			d = !0, i = e < r;
			break;
		case "<=":
			d = !0, i = e <= r;
			break;
		default: i = !1;
	}
	return u && (null != e || !d) && (i = !i), i;
}, "valCmp"), Ge = h(function(e, t) {
	switch (t) {
		case "?": return !!e;
		case "!": return !e;
		case "^": return void 0 === e;
	}
}, "boolCmp"), Gt = h(function(e) {
	return void 0 !== e;
}, "existCmp"), Gr = h(function(e, t) {
	return e.data(t);
}, "data"), Gi = h(function(e, t) {
	return e[t]();
}, "meta"), Gn = [], Ga = h(function(e, t) {
	return e.checks.every(function(e) {
		return Gn[e.type](e, t);
	});
}, "matches");
Gn[0] = function(e, t) {
	var r = e.value;
	return "*" === r || r === t.group();
}, Gn[7] = function(e, t) {
	return U1(e.value, t);
}, Gn[8] = function(e, t) {
	var r = e.value;
	return t.id() === r;
}, Gn[9] = function(e, t) {
	var r = e.value;
	return t.hasClass(r);
}, Gn[6] = function(e, t) {
	var r = e.field, i = e.operator, n = e.value;
	return U9(Gi(t, r), i, n);
}, Gn[3] = function(e, t) {
	var r = e.field, i = e.operator, n = e.value;
	return U9(Gr(t, r), i, n);
}, Gn[5] = function(e, t) {
	var r = e.field, i = e.operator;
	return Ge(Gr(t, r), i);
}, Gn[4] = function(e, t) {
	var r = e.field;
	return e.operator, Gt(Gr(t, r));
}, Gn[10] = function(e, t) {
	var r = e.nodes[0], i = e.nodes[1], n = t.source(), a = t.target();
	return Ga(r, n) && Ga(i, a) || Ga(i, n) && Ga(r, a);
}, Gn[14] = function(e, t) {
	return Ga(e.node, t) && t.neighborhood().some(function(t) {
		return t.isNode() && Ga(e.neighbor, t);
	});
}, Gn[11] = function(e, t) {
	return Ga(e.source, t.source()) && Ga(e.target, t.target());
}, Gn[12] = function(e, t) {
	return Ga(e.source, t) && t.outgoers().some(function(t) {
		return t.isNode() && Ga(e.target, t);
	});
}, Gn[13] = function(e, t) {
	return Ga(e.target, t) && t.incomers().some(function(t) {
		return t.isNode() && Ga(e.source, t);
	});
}, Gn[15] = function(e, t) {
	return Ga(e.child, t) && Ga(e.parent, t.parent());
}, Gn[17] = function(e, t) {
	return Ga(e.parent, t) && t.children().some(function(t) {
		return Ga(e.child, t);
	});
}, Gn[16] = function(e, t) {
	return Ga(e.descendant, t) && t.ancestors().some(function(t) {
		return Ga(e.ancestor, t);
	});
}, Gn[18] = function(e, t) {
	return Ga(e.ancestor, t) && t.descendants().some(function(t) {
		return Ga(e.descendant, t);
	});
}, Gn[19] = function(e, t) {
	return Ga(e.subject, t) && Ga(e.left, t) && Ga(e.right, t);
}, Gn[20] = function() {
	return !0;
}, Gn[1] = function(e, t) {
	return e.value.has(t);
}, Gn[2] = function(e, t) {
	return (0, e.value)(t);
};
var Gs = h(function(e) {
	var t = this;
	if (1 === t.length && 1 === t[0].checks.length && 8 === t[0].checks[0].type) return e.getElementById(t[0].checks[0].value).collection();
	var r = h(function(e) {
		for (var r = 0; r < t.length; r++) if (Ga(t[r], e)) return !0;
		return !1;
	}, "selectorFunction");
	return t.text() ?? (r = h(function() {
		return !0;
	}, "selectorFunction")), e.filter(r);
}, "filter"), Go = {
	matches: h(function(e) {
		for (var t = 0; t < this.length; t++) if (Ga(this[t], e)) return !0;
		return !1;
	}, "matches"),
	filter: Gs
}, Gl = h(function(e) {
	this.inputText = e, this.currentSubject = null, this.compoundCount = 0, this.edgeCount = 0, this.length = 0, null == e || Dq(e) && e.match(/^\s*$/) || (DZ(e) ? this.addQuery({ checks: [{
		type: 1,
		value: e.collection()
	}] }) : Dj(e) ? this.addQuery({ checks: [{
		type: 2,
		value: e
	}] }) : Dq(e) ? this.parse(e) || (this.invalid = !0) : O8("A selector must be created from a string; found "));
}, "Selector"), Gc = Gl.prototype;
[U8, Go].forEach(function(e) {
	return Ou(Gc, e);
}), Gc.text = function() {
	return this.inputText;
}, Gc.size = function() {
	return this.length;
}, Gc.eq = function(e) {
	return this[e];
}, Gc.sameText = function(e) {
	return !this.invalid && !e.invalid && this.text() === e.text();
}, Gc.addQuery = function(e) {
	this[this.length++] = e;
}, Gc.selector = Gc.toString;
var Gh = {
	allAre: h(function(e) {
		var t = new Gl(e);
		return this.every(function(e) {
			return t.matches(e);
		});
	}, "allAre"),
	is: h(function(e) {
		var t = new Gl(e);
		return this.some(function(e) {
			return t.matches(e);
		});
	}, "is"),
	some: h(function(e, t) {
		for (var r = 0; r < this.length; r++) if (t ? e.apply(t, [
			this[r],
			r,
			this
		]) : e(this[r], r, this)) return !0;
		return !1;
	}, "some"),
	every: h(function(e, t) {
		for (var r = 0; r < this.length; r++) if (!(t ? e.apply(t, [
			this[r],
			r,
			this
		]) : e(this[r], r, this))) return !1;
		return !0;
	}, "every"),
	same: h(function(e) {
		if (this === e) return !0;
		e = this.cy().collection(e);
		var t = this.length;
		return t === e.length && (1 === t ? this[0] === e[0] : this.every(function(t) {
			return e.hasElementWithId(t.id());
		}));
	}, "same"),
	anySame: h(function(e) {
		return e = this.cy().collection(e), this.some(function(t) {
			return e.hasElementWithId(t.id());
		});
	}, "anySame"),
	allAreNeighbors: h(function(e) {
		e = this.cy().collection(e);
		var t = this.neighborhood();
		return e.every(function(e) {
			return t.hasElementWithId(e.id());
		});
	}, "allAreNeighbors"),
	contains: h(function(e) {
		e = this.cy().collection(e);
		var t = this;
		return e.every(function(e) {
			return t.hasElementWithId(e.id());
		});
	}, "contains")
};
Gh.allAreNeighbours = Gh.allAreNeighbors, Gh.has = Gh.contains, Gh.equal = Gh.equals = Gh.same;
var Gu = h(function(e, t) {
	return h(function(r, i, n, a) {
		if (null == r ? s = "" : DZ(r) && 1 === r.length && (s = r.id()), 1 !== this.length || !s) return e.call(this, r, i, n, a);
		var s, o = this[0]._private, l = o.traversalCache = o.traversalCache || {}, h = l[t] = l[t] || [], u = OH(s);
		return h[u] || (h[u] = e.call(this, r, i, n, a));
	}, "traversalCache");
}, "cache"), Gd = {
	parent: h(function(e) {
		var t = [];
		if (1 === this.length) {
			var r = this[0]._private.parent;
			if (r) return r;
		}
		for (var i = 0; i < this.length; i++) {
			var n = this[i]._private.parent;
			n && t.push(n);
		}
		return this.spawn(t, !0).filter(e);
	}, "parent"),
	parents: h(function(e) {
		for (var t = [], r = this.parent(); r.nonempty();) {
			for (var i = 0; i < r.length; i++) {
				var n = r[i];
				t.push(n);
			}
			r = r.parent();
		}
		return this.spawn(t, !0).filter(e);
	}, "parents"),
	commonAncestors: h(function(e) {
		for (var t, r = 0; r < this.length; r++) {
			var i = this[r].parents();
			t = (t = t || i).intersect(i);
		}
		return t.filter(e);
	}, "commonAncestors"),
	orphans: h(function(e) {
		return this.stdFilter(function(e) {
			return e.isOrphan();
		}).filter(e);
	}, "orphans"),
	nonorphans: h(function(e) {
		return this.stdFilter(function(e) {
			return e.isChild();
		}).filter(e);
	}, "nonorphans"),
	children: Gu(function(e) {
		for (var t = [], r = 0; r < this.length; r++) for (var i = this[r], n = i._private.children, a = 0; a < n.length; a++) t.push(n[a]);
		return this.spawn(t, !0).filter(e);
	}, "children"),
	siblings: h(function(e) {
		return this.parent().children().not(this).filter(e);
	}, "siblings"),
	isParent: h(function() {
		var e = this[0];
		if (e) return e.isNode() && 0 !== e._private.children.length;
	}, "isParent"),
	isChildless: h(function() {
		var e = this[0];
		if (e) return e.isNode() && 0 === e._private.children.length;
	}, "isChildless"),
	isChild: h(function() {
		var e = this[0];
		if (e) return e.isNode() && null != e._private.parent;
	}, "isChild"),
	isOrphan: h(function() {
		var e = this[0];
		if (e) return e.isNode() && null == e._private.parent;
	}, "isOrphan"),
	descendants: h(function(e) {
		var t = [];
		function r(e) {
			for (var i = 0; i < e.length; i++) {
				var n = e[i];
				t.push(n), n.children().nonempty() && r(n.children());
			}
		}
		return h(r, "add"), r(this.children()), this.spawn(t, !0).filter(e);
	}, "descendants")
};
function Gp(e, t, r, i) {
	for (var n = [], a = new $m(), s = e.cy().hasCompoundNodes(), o = 0; o < e.length; o++) {
		var l = e[o];
		r ? n.push(l) : s && i(n, a, l);
	}
	for (; n.length > 0;) {
		var h = n.shift();
		t(h), a.add(h.id()), s && i(n, a, h);
	}
	return e;
}
function Gf(e, t, r) {
	if (r.isParent()) for (var i = r._private.children, n = 0; n < i.length; n++) {
		var a = i[n];
		t.has(a.id()) || e.push(a);
	}
}
function Gg(e, t, r) {
	if (r.isChild()) {
		var i = r._private.parent;
		t.has(i.id()) || e.push(i);
	}
}
function Gm(e, t, r) {
	Gg(e, t, r), Gf(e, t, r);
}
h(Gp, "forEachCompound"), h(Gf, "addChildren"), Gd.forEachDown = function(e) {
	var t = !(arguments.length > 1) || void 0 === arguments[1] || arguments[1];
	return Gp(this, e, t, Gf);
}, h(Gg, "addParent"), Gd.forEachUp = function(e) {
	var t = !(arguments.length > 1) || void 0 === arguments[1] || arguments[1];
	return Gp(this, e, t, Gg);
}, h(Gm, "addParentAndChildren"), Gd.forEachUpAndDown = function(e) {
	var t = !(arguments.length > 1) || void 0 === arguments[1] || arguments[1];
	return Gp(this, e, t, Gm);
}, Gd.ancestors = Gd.parents;
var Gy, Gv, Gx, Gb, Gw, Gk, GT = Gk = {
	data: UH.data({
		field: "data",
		bindingEvent: "data",
		allowBinding: !0,
		allowSetting: !0,
		settingEvent: "data",
		settingTriggersEvent: !0,
		triggerFnName: "trigger",
		allowGetting: !0,
		immutableKeys: {
			id: !0,
			source: !0,
			target: !0,
			parent: !0
		},
		updateStyle: !0
	}),
	removeData: UH.removeData({
		field: "data",
		event: "data",
		triggerFnName: "trigger",
		triggerEvent: !0,
		immutableKeys: {
			id: !0,
			source: !0,
			target: !0,
			parent: !0
		},
		updateStyle: !0
	}),
	scratch: UH.data({
		field: "scratch",
		bindingEvent: "scratch",
		allowBinding: !0,
		allowSetting: !0,
		settingEvent: "scratch",
		settingTriggersEvent: !0,
		triggerFnName: "trigger",
		allowGetting: !0,
		updateStyle: !0
	}),
	removeScratch: UH.removeData({
		field: "scratch",
		event: "scratch",
		triggerFnName: "trigger",
		triggerEvent: !0,
		updateStyle: !0
	}),
	rscratch: UH.data({
		field: "rscratch",
		allowBinding: !1,
		allowSetting: !0,
		settingTriggersEvent: !1,
		allowGetting: !0
	}),
	removeRscratch: UH.removeData({
		field: "rscratch",
		triggerEvent: !1
	}),
	id: h(function() {
		var e = this[0];
		if (e) return e._private.data.id;
	}, "id")
};
GT.attr = GT.data, GT.removeAttr = GT.removeData;
var G_ = {};
function GE(e) {
	return function(t) {
		if (void 0 === t && (t = !0), 0 !== this.length) if (!this.isNode() || this.removed()) return;
		else {
			for (var r = 0, i = this[0], n = i._private.edges, a = 0; a < n.length; a++) {
				var s = n[a];
				!t && s.isLoop() || (r += e(i, s));
			}
			return r;
		}
	};
}
function GC(e, t) {
	return function(r) {
		for (var i, n = this.nodes(), a = 0; a < n.length; a++) {
			var s = n[a][e](r);
			void 0 !== s && (void 0 === i || t(s, i)) && (i = s);
		}
		return i;
	};
}
h(GE, "defineDegreeFunction"), Ou(G_, {
	degree: GE(function(e, t) {
		return t.source().same(t.target()) ? 2 : 1;
	}),
	indegree: GE(function(e, t) {
		return +!!t.target().same(e);
	}),
	outdegree: GE(function(e, t) {
		return +!!t.source().same(e);
	})
}), h(GC, "defineDegreeBoundsFunction"), Ou(G_, {
	minDegree: GC("degree", function(e, t) {
		return e < t;
	}),
	maxDegree: GC("degree", function(e, t) {
		return e > t;
	}),
	minIndegree: GC("indegree", function(e, t) {
		return e < t;
	}),
	maxIndegree: GC("indegree", function(e, t) {
		return e > t;
	}),
	minOutdegree: GC("outdegree", function(e, t) {
		return e < t;
	}),
	maxOutdegree: GC("outdegree", function(e, t) {
		return e > t;
	})
}), Ou(G_, { totalDegree: h(function(e) {
	for (var t = 0, r = this.nodes(), i = 0; i < r.length; i++) t += r[i].degree(e);
	return t;
}, "totalDegree") });
var GS, GA, GL = h(function(e, t, r) {
	for (var i = 0; i < e.length; i++) {
		var n = e[i];
		if (!n.locked()) {
			var a = n._private.position, s = {
				x: null != t.x ? t.x - a.x : 0,
				y: null != t.y ? t.y - a.y : 0
			};
			n.isParent() && (0 !== s.x || 0 !== s.y) && n.children().shift(s, r), n.dirtyBoundingBoxCache();
		}
	}
}, "beforePositionSet"), GR = {
	field: "position",
	bindingEvent: "position",
	allowBinding: !0,
	allowSetting: !0,
	settingEvent: "position",
	settingTriggersEvent: !0,
	triggerFnName: "emitAndNotify",
	allowGetting: !0,
	validKeys: ["x", "y"],
	beforeGet: h(function(e) {
		e.updateCompoundBounds();
	}, "beforeGet"),
	beforeSet: h(function(e, t) {
		GL(e, t, !1);
	}, "beforeSet"),
	onSet: h(function(e) {
		e.dirtyCompoundBoundsCache();
	}, "onSet"),
	canSet: h(function(e) {
		return !e.locked();
	}, "canSet")
};
(GS = GA = {
	position: UH.data(GR),
	silentPosition: UH.data(Ou({}, GR, {
		allowBinding: !1,
		allowSetting: !0,
		settingTriggersEvent: !1,
		allowGetting: !1,
		beforeSet: h(function(e, t) {
			GL(e, t, !0);
		}, "beforeSet"),
		onSet: h(function(e) {
			e.dirtyCompoundBoundsCache();
		}, "onSet")
	})),
	positions: h(function(e, t) {
		if (DY(e)) t ? this.silentPosition(e) : this.position(e);
		else if (Dj(e)) {
			var r = this.cy();
			r.startBatch();
			for (var i = 0; i < this.length; i++) {
				var n = this[i], a = void 0;
				(a = e(n, i)) && (t ? n.silentPosition(a) : n.position(a));
			}
			r.endBatch();
		}
		return this;
	}, "positions"),
	silentPositions: h(function(e) {
		return this.positions(e, !0);
	}, "silentPositions"),
	shift: h(function(e, t, r) {
		var i;
		if (DY(e) ? (i = {
			x: DH(e.x) ? e.x : 0,
			y: DH(e.y) ? e.y : 0
		}, r = t) : Dq(e) && DH(t) && ((i = {
			x: 0,
			y: 0
		})[e] = t), null != i) {
			var n = this.cy();
			n.startBatch();
			for (var a = 0; a < this.length; a++) {
				var s = this[a];
				if (!(n.hasCompoundNodes() && s.isChild() && s.ancestors().anySame(this))) {
					var o = s.position(), l = {
						x: o.x + i.x,
						y: o.y + i.y
					};
					r ? s.silentPosition(l) : s.position(l);
				}
			}
			n.endBatch();
		}
		return this;
	}, "shift"),
	silentShift: h(function(e, t) {
		return DY(e) ? this.shift(e, !0) : Dq(e) && DH(t) && this.shift(e, t, !0), this;
	}, "silentShift"),
	renderedPosition: h(function(e, t) {
		var r = this[0], i = this.cy(), n = i.zoom(), a = i.pan(), s = DY(e) ? e : void 0, o = void 0 !== s || void 0 !== t && Dq(e);
		if (r && r.isNode()) if (!o) return s = Po(r.position(), n, a), void 0 === e ? s : s[e];
		else for (var l = 0; l < this.length; l++) {
			var h = this[l];
			void 0 !== t ? h.position(e, (t - a[e]) / n) : void 0 !== s && h.position(Pl(s, n, a));
		}
		else if (!o) return;
		return this;
	}, "renderedPosition"),
	relativePosition: h(function(e, t) {
		var r = this[0], i = this.cy(), n = DY(e) ? e : void 0, a = void 0 !== n || void 0 !== t && Dq(e), s = i.hasCompoundNodes();
		if (r && r.isNode()) if (a) for (var o = 0; o < this.length; o++) {
			var l = this[o], h = s ? l.parent() : null, u = h && h.length > 0;
			u && (h = h[0]);
			var d = u ? h.position() : {
				x: 0,
				y: 0
			};
			void 0 !== t ? l.position(e, t + d[e]) : void 0 !== n && l.position({
				x: n.x + d.x,
				y: n.y + d.y
			});
		}
		else {
			var p = r.position(), f = s ? r.parent() : null, g = f && f.length > 0;
			g && (f = f[0]);
			var m = g ? f.position() : {
				x: 0,
				y: 0
			};
			return n = {
				x: p.x - m.x,
				y: p.y - m.y
			}, void 0 === e ? n : n[e];
		}
		else if (!a) return;
		return this;
	}, "relativePosition")
}).modelPosition = GS.point = GS.position, GS.modelPositions = GS.points = GS.positions, GS.renderedPoint = GS.renderedPosition, GS.relativePoint = GS.relativePosition;
var GN, GI = GN = {};
GN.renderedBoundingBox = function(e) {
	var t = this.boundingBox(e), r = this.cy(), i = r.zoom(), n = r.pan(), a = t.x1 * i + n.x, s = t.x2 * i + n.x, o = t.y1 * i + n.y, l = t.y2 * i + n.y;
	return {
		x1: a,
		x2: s,
		y1: o,
		y2: l,
		w: s - a,
		h: l - o
	};
}, GN.dirtyCompoundBoundsCache = function() {
	var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], t = this.cy();
	return t.styleEnabled() && t.hasCompoundNodes() && this.forEachUp(function(t) {
		if (t.isParent()) {
			var r = t._private;
			r.compoundBoundsClean = !1, r.bbCache = null, e || t.emitAndNotify("bounds");
		}
	}), this;
}, GN.updateCompoundBounds = function() {
	var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], t = this.cy();
	if (!t.styleEnabled() || !t.hasCompoundNodes() || !e && t.batching()) return this;
	function r(e) {
		if (e.isParent()) {
			var t = e._private, r = e.children(), i = "include" === e.pstyle("compound-sizing-wrt-labels").value, n = {
				width: {
					val: e.pstyle("min-width").pfValue,
					left: e.pstyle("min-width-bias-left"),
					right: e.pstyle("min-width-bias-right")
				},
				height: {
					val: e.pstyle("min-height").pfValue,
					top: e.pstyle("min-height-bias-top"),
					bottom: e.pstyle("min-height-bias-bottom")
				}
			}, a = r.boundingBox({
				includeLabels: i,
				includeOverlays: !1,
				useCache: !1
			}), s = t.position;
			(0 === a.w || 0 === a.h) && ((a = {
				w: e.pstyle("width").pfValue,
				h: e.pstyle("height").pfValue
			}).x1 = s.x - a.w / 2, a.x2 = s.x + a.w / 2, a.y1 = s.y - a.h / 2, a.y2 = s.y + a.h / 2), h(x, "computeBiasValues"), h(b, "computePaddingValues");
			var o = n.width.left.value;
			"px" === n.width.left.units && n.width.val > 0 && (o = 100 * o / n.width.val);
			var l = n.width.right.value;
			"px" === n.width.right.units && n.width.val > 0 && (l = 100 * l / n.width.val);
			var u = n.height.top.value;
			"px" === n.height.top.units && n.height.val > 0 && (u = 100 * u / n.height.val);
			var d = n.height.bottom.value;
			"px" === n.height.bottom.units && n.height.val > 0 && (d = 100 * d / n.height.val);
			var p = x(n.width.val - a.w, o, l), f = p.biasDiff, g = p.biasComplementDiff, m = x(n.height.val - a.h, u, d), y = m.biasDiff, v = m.biasComplementDiff;
			t.autoPadding = b(a.w, a.h, e.pstyle("padding"), e.pstyle("padding-relative-to").value), t.autoWidth = Math.max(a.w, n.width.val), s.x = (-f + a.x1 + a.x2 + g) / 2, t.autoHeight = Math.max(a.h, n.height.val), s.y = (-y + a.y1 + a.y2 + v) / 2;
		}
		function x(e, t, r) {
			var i = 0, n = 0, a = t + r;
			return e > 0 && a > 0 && (i = t / a * e, n = r / a * e), {
				biasDiff: i,
				biasComplementDiff: n
			};
		}
		function b(e, t, r, i) {
			if ("%" !== r.units) return "px" === r.units ? r.pfValue : 0;
			switch (i) {
				case "width": return e > 0 ? r.pfValue * e : 0;
				case "height": return t > 0 ? r.pfValue * t : 0;
				case "average": return e > 0 && t > 0 ? r.pfValue * (e + t) / 2 : 0;
				case "min": return e > 0 && t > 0 ? e > t ? r.pfValue * t : r.pfValue * e : 0;
				case "max": return e > 0 && t > 0 ? e > t ? r.pfValue * e : r.pfValue * t : 0;
				default: return 0;
			}
		}
	}
	h(r, "update");
	for (var i = 0; i < this.length; i++) {
		var n = this[i], a = n._private;
		(!a.compoundBoundsClean || e) && (r(n), t.batching() || (a.compoundBoundsClean = !0));
	}
	return this;
};
var GM = h(function(e) {
	return e === Infinity || e === -Infinity ? 0 : e;
}, "noninf"), GD = h(function(e, t, r, i, n) {
	i - t == 0 || n - r == 0 || null == t || null == r || null == i || null == n || (e.x1 = t < e.x1 ? t : e.x1, e.x2 = i > e.x2 ? i : e.x2, e.y1 = r < e.y1 ? r : e.y1, e.y2 = n > e.y2 ? n : e.y2, e.w = e.x2 - e.x1, e.h = e.y2 - e.y1);
}, "updateBounds"), GO = h(function(e, t) {
	return null == t ? e : GD(e, t.x1, t.y1, t.x2, t.y2);
}, "updateBoundsFromBox"), G$ = h(function(e, t, r) {
	return $u(e, t, r);
}, "prefixedProperty"), GP = h(function(e, t, r) {
	if (!t.cy().headless()) {
		var i, n, a = t._private, s = a.rstyle, o = s.arrowWidth / 2;
		if ("none" !== t.pstyle(r + "-arrow-shape").value) {
			"source" === r ? (i = s.srcX, n = s.srcY) : "target" === r ? (i = s.tgtX, n = s.tgtY) : (i = s.midX, n = s.midY);
			var l = a.arrowBounds = a.arrowBounds || {}, h = l[r] = l[r] || {};
			h.x1 = i - o, h.y1 = n - o, h.x2 = i + o, h.y2 = n + o, h.w = h.x2 - h.x1, h.h = h.y2 - h.y1, PR(h, 1), GD(e, h.x1, h.y1, h.x2, h.y2);
		}
	}
}, "updateBoundsFromArrow"), GB = h(function(e, t, r) {
	if (!t.cy().headless()) {
		a = r ? r + "-" : "";
		var i = t._private, n = i.rstyle;
		if (t.pstyle(a + "label").strValue) {
			var a, s, o, l, u, d = t.pstyle("text-halign"), p = t.pstyle("text-valign"), f = G$(n, "labelWidth", r), g = G$(n, "labelHeight", r), m = G$(n, "labelX", r), y = G$(n, "labelY", r), v = t.pstyle(a + "text-margin-x").pfValue, x = t.pstyle(a + "text-margin-y").pfValue, b = t.isEdge(), w = t.pstyle(a + "text-rotation"), k = t.pstyle("text-outline-width").pfValue, T = t.pstyle("text-border-width").pfValue / 2, _ = t.pstyle("text-background-padding").pfValue, E = f / 2, C = g / 2;
			if (b) s = m - E, o = m + E, l = y - C, u = y + C;
			else {
				switch (d.value) {
					case "left":
						s = m - f, o = m;
						break;
					case "center":
						s = m - E, o = m + E;
						break;
					case "right": s = m, o = m + f;
				}
				switch (p.value) {
					case "top":
						l = y - g, u = y;
						break;
					case "center":
						l = y - C, u = y + C;
						break;
					case "bottom": l = y, u = y + g;
				}
			}
			var S = v - Math.max(k, T) - _ - 2, A = v + Math.max(k, T) + _ + 2, L = x - Math.max(k, T) - _ - 2, R = x + Math.max(k, T) + _ + 2;
			s += S, o += A, l += L, u += R;
			var N = r || "main", I = i.labelBounds, M = I[N] = I[N] || {};
			M.x1 = s, M.y1 = l, M.x2 = o, M.y2 = u, M.w = o - s, M.h = u - l, M.leftPad = S, M.rightPad = A, M.topPad = L, M.botPad = R;
			var D = b && "autorotate" === w.strValue, O = null != w.pfValue && 0 !== w.pfValue;
			if (D || O) {
				var $ = D ? G$(i.rstyle, "labelAngle", r) : w.pfValue, P = Math.cos($), B = Math.sin($), F = (s + o) / 2, z = (l + u) / 2;
				if (!b) {
					switch (d.value) {
						case "left":
							F = o;
							break;
						case "right": F = s;
					}
					switch (p.value) {
						case "top":
							z = u;
							break;
						case "bottom": z = l;
					}
				}
				var U = h(function(e, t) {
					return {
						x: (e -= F) * P - (t -= z) * B + F,
						y: e * B + t * P + z
					};
				}, "rotate"), G = U(s, l), q = U(s, u), j = U(o, l), W = U(o, u);
				s = Math.min(G.x, q.x, j.x, W.x), o = Math.max(G.x, q.x, j.x, W.x), l = Math.min(G.y, q.y, j.y, W.y), u = Math.max(G.y, q.y, j.y, W.y);
			}
			var Y = N + "Rot", V = I[Y] = I[Y] || {};
			V.x1 = s, V.y1 = l, V.x2 = o, V.y2 = u, V.w = o - s, V.h = u - l, GD(e, s, l, o, u), GD(i.labelBounds.all, s, l, o, u);
		}
		return e;
	}
}, "updateBoundsFromLabel"), GF = h(function(e, t) {
	if (!t.cy().headless()) {
		var r = t.pstyle("outline-opacity").value, i = t.pstyle("outline-width").value + t.pstyle("outline-offset").value;
		Gz(e, t, r, i, "outside", i / 2);
	}
}, "updateBoundsFromOutline"), Gz = h(function(e, t, r, i, n, a) {
	if (!(0 === r || i <= 0 || "inside" === n)) {
		var s = t.cy(), o = t.pstyle("shape").value, l = s.renderer().nodeShapes[o], h = t.position(), u = h.x, d = h.y, p = t.width(), f = t.height();
		l.hasMiterBounds ? ("center" === n && (i /= 2), GO(e, l.miterBounds(u, d, p, f, i))) : null != a && a > 0 && PN(e, [
			a,
			a,
			a,
			a
		]);
	}
}, "updateBoundsFromMiter"), GU = h(function(e, t) {
	if (!t.cy().headless()) {
		var r = t.pstyle("border-opacity").value, i = t.pstyle("border-width").pfValue, n = t.pstyle("border-position").value;
		Gz(e, t, r, i, n);
	}
}, "updateBoundsFromMiterBorder"), GG = h(function(e, t) {
	var r, i, n, a, s, o, l = e._private.cy, u = l.styleEnabled(), d = l.headless(), p = PE(), f = e._private, g = e.isNode(), m = e.isEdge(), y = f.rstyle, v = g && u ? e.pstyle("bounds-expansion").pfValue : [0], x = h(function(e) {
		return "none" !== e.pstyle("display").value;
	}, "isDisplayed"), b = !u || x(e) && (!m || x(e.source()) && x(e.target()));
	if (b) {
		var w = 0;
		u && t.includeOverlays && 0 !== e.pstyle("overlay-opacity").value && (w = e.pstyle("overlay-padding").value);
		var k = 0;
		u && t.includeUnderlays && 0 !== e.pstyle("underlay-opacity").value && (k = e.pstyle("underlay-padding").value);
		var T = Math.max(w, k), _ = 0;
		if (u && (_ = e.pstyle("width").pfValue / 2), g && t.includeNodes) {
			var E = e.position();
			s = E.x, o = E.y;
			var C = e.outerWidth() / 2, S = e.outerHeight() / 2;
			r = s - C, i = s + C, GD(p, r, n = o - S, i, a = o + S), u && GF(p, e), u && t.includeOutlines && !d && GF(p, e), u && GU(p, e);
		} else if (m && t.includeEdges) if (u && !d) {
			var A, L = e.pstyle("curve-style").strValue;
			if (r = Math.min(y.srcX, y.midX, y.tgtX), i = Math.max(y.srcX, y.midX, y.tgtX), n = Math.min(y.srcY, y.midY, y.tgtY), a = Math.max(y.srcY, y.midY, y.tgtY), r -= _, i += _, GD(p, r, n -= _, i, a += _), "haystack" === L) {
				var R = y.haystackPts;
				if (R && 2 === R.length) {
					if (r = R[0].x, n = R[0].y, i = R[1].x, a = R[1].y, r > i) {
						var N = r;
						r = i, i = N;
					}
					if (n > a) {
						var I = n;
						n = a, a = I;
					}
					GD(p, r - _, n - _, i + _, a + _);
				}
			} else if ("bezier" === L || "unbundled-bezier" === L || Oi(L, "segments") || Oi(L, "taxi")) {
				switch (L) {
					case "bezier":
					case "unbundled-bezier":
						A = y.bezierPts;
						break;
					case "segments":
					case "taxi":
					case "round-segments":
					case "round-taxi": A = y.linePts;
				}
				if (null != A) for (var M = 0; M < A.length; M++) {
					var D = A[M];
					r = D.x - _, i = D.x + _, GD(p, r, n = D.y - _, i, a = D.y + _);
				}
			}
		} else {
			var O = e.source().position(), $ = e.target().position();
			if (r = O.x, i = $.x, n = O.y, a = $.y, r > i) {
				var P = r;
				r = i, i = P;
			}
			if (n > a) {
				var B = n;
				n = a, a = B;
			}
			r -= _, i += _, GD(p, r, n -= _, i, a += _);
		}
		if (u && t.includeEdges && m && (GP(p, e, "mid-source"), GP(p, e, "mid-target"), GP(p, e, "source"), GP(p, e, "target")), u && "yes" === e.pstyle("ghost").value) {
			var F = e.pstyle("ghost-offset-x").pfValue, z = e.pstyle("ghost-offset-y").pfValue;
			GD(p, p.x1 + F, p.y1 + z, p.x2 + F, p.y2 + z);
		}
		var U = f.bodyBounds = f.bodyBounds || {};
		PI(U, p), PN(U, v), PR(U, 1), u && (r = p.x1, i = p.x2, n = p.y1, a = p.y2, GD(p, r - T, n - T, i + T, a + T));
		var G = f.overlayBounds = f.overlayBounds || {};
		PI(G, p), PN(G, v), PR(G, 1);
		var q = f.labelBounds = f.labelBounds || {};
		null != q.all ? PS(q.all) : q.all = PE(), u && t.includeLabels && (t.includeMainLabels && GB(p, e, null), m && (t.includeSourceLabels && GB(p, e, "source"), t.includeTargetLabels && GB(p, e, "target")));
	}
	return p.x1 = GM(p.x1), p.y1 = GM(p.y1), p.x2 = GM(p.x2), p.y2 = GM(p.y2), p.w = GM(p.x2 - p.x1), p.h = GM(p.y2 - p.y1), p.w > 0 && p.h > 0 && b && (PN(p, v), PR(p, 1)), p;
}, "boundingBoxImpl"), Gq = h(function(e) {
	var t = 0, r = h(function(e) {
		return !!e << t++;
	}, "tf");
	return 0 + r(e.incudeNodes) + r(e.includeEdges) + r(e.includeLabels) + r(e.includeMainLabels) + r(e.includeSourceLabels) + r(e.includeTargetLabels) + r(e.includeOverlays) + r(e.includeOutlines);
}, "getKey"), Gj = h(function(e) {
	var t = h(function(e) {
		return Math.round(e);
	}, "r");
	if (e.isEdge()) {
		var r = e.source().position(), i = e.target().position();
		return OV([
			t(r.x),
			t(r.y),
			t(i.x),
			t(i.y)
		]);
	}
	var n = e.position();
	return OV([t(n.x), t(n.y)]);
}, "getBoundingBoxPosKey"), GW = h(function(e, t) {
	var r, i = e._private, n = e.isEdge(), a = (null == t ? GV : Gq(t)) === GV;
	if (null == i.bbCache ? (i.bbCache = r = GG(e, GY), i.bbCachePosKey = Gj(e)) : r = i.bbCache, !a) {
		var s = e.isNode();
		r = PE(), (t.includeNodes && s || t.includeEdges && !s) && (t.includeOverlays ? GO(r, i.overlayBounds) : GO(r, i.bodyBounds)), t.includeLabels && (t.includeMainLabels && (!n || t.includeSourceLabels && t.includeTargetLabels) ? GO(r, i.labelBounds.all) : (t.includeMainLabels && GO(r, i.labelBounds.mainRot), t.includeSourceLabels && GO(r, i.labelBounds.sourceRot), t.includeTargetLabels && GO(r, i.labelBounds.targetRot))), r.w = r.x2 - r.x1, r.h = r.y2 - r.y1;
	}
	return r;
}, "cachedBoundingBoxImpl"), GY = {
	includeNodes: !0,
	includeEdges: !0,
	includeLabels: !0,
	includeMainLabels: !0,
	includeSourceLabels: !0,
	includeTargetLabels: !0,
	includeOverlays: !0,
	includeUnderlays: !0,
	includeOutlines: !0,
	useCache: !0
}, GV = Gq(GY), GH = $o(GY);
GN.boundingBox = function(e) {
	var t, r = void 0 === e || void 0 === e.useCache || !0 === e.useCache, i = D8(function(e) {
		var t = e._private;
		return null == t.bbCache || t.styleDirty || t.bbCachePosKey !== Gj(e);
	}, function(e) {
		return e.id();
	});
	if (r && 1 === this.length && !i(this[0])) e = void 0 === e ? GY : GH(e), t = GW(this[0], e);
	else {
		t = PE();
		var n = GH(e = e || GY), a = this.cy().styleEnabled();
		this.edges().forEach(i), this.nodes().forEach(i), a && this.recalculateRenderedStyle(r), this.updateCompoundBounds(!r);
		for (var s = 0; s < this.length; s++) {
			var o = this[s];
			i(o) && o.dirtyBoundingBoxCache(), GO(t, GW(o, n));
		}
	}
	return t.x1 = GM(t.x1), t.y1 = GM(t.y1), t.x2 = GM(t.x2), t.y2 = GM(t.y2), t.w = GM(t.x2 - t.x1), t.h = GM(t.y2 - t.y1), t;
}, GN.dirtyBoundingBoxCache = function() {
	for (var e = 0; e < this.length; e++) {
		var t = this[e]._private;
		t.bbCache = null, t.bbCachePosKey = null, t.bodyBounds = null, t.overlayBounds = null, t.labelBounds.all = null, t.labelBounds.source = null, t.labelBounds.target = null, t.labelBounds.main = null, t.labelBounds.sourceRot = null, t.labelBounds.targetRot = null, t.labelBounds.mainRot = null, t.arrowBounds.source = null, t.arrowBounds.target = null, t.arrowBounds["mid-source"] = null, t.arrowBounds["mid-target"] = null;
	}
	return this.emitAndNotify("bounds"), this;
}, GN.boundingBoxAt = function(e) {
	var t = this.nodes(), r = this.cy(), i = r.hasCompoundNodes(), n = r.collection();
	if (i && (n = t.filter(function(e) {
		return e.isParent();
	}), t = t.not(n)), DY(e)) {
		var a = e;
		e = h(function() {
			return a;
		}, "fn");
	}
	var s = h(function(t, r) {
		return t._private.bbAtOldPos = e(t, r);
	}, "storeOldPos"), o = h(function(e) {
		return e._private.bbAtOldPos;
	}, "getOldPos");
	r.startBatch(), t.forEach(s).silentPositions(e), i && (n.dirtyCompoundBoundsCache(), n.dirtyBoundingBoxCache(), n.updateCompoundBounds(!0));
	var l = PC(this.boundingBox({ useCache: !1 }));
	return t.silentPositions(o), i && (n.dirtyCompoundBoundsCache(), n.dirtyBoundingBoxCache(), n.updateCompoundBounds(!0)), r.endBatch(), l;
}, GI.boundingbox = GI.bb = GI.boundingBox, GI.renderedBoundingbox = GI.renderedBoundingBox;
var GX, GK = GX = {}, GZ = h(function(e) {
	e.uppercaseName = Or(e.name), e.autoName = "auto" + e.uppercaseName, e.labelName = "label" + e.uppercaseName, e.outerName = "outer" + e.uppercaseName, e.uppercaseOuterName = Or(e.outerName), GK[e.name] = h(function() {
		var t = this[0], r = t._private, i = r.cy._private.styleEnabled;
		if (t) if (!i) return 1;
		else {
			if (t.isParent()) return t.updateCompoundBounds(), r[e.autoName] || 0;
			var n = t.pstyle(e.name);
			return "label" === n.strValue ? (t.recalculateRenderedStyle(), r.rstyle[e.labelName] || 0) : n.pfValue;
		}
	}, "dimImpl"), GK["outer" + e.uppercaseName] = h(function() {
		var t = this[0], r = t._private.cy._private.styleEnabled;
		if (t) if (!r) return 1;
		else {
			var i = t[e.name](), n = t.pstyle("border-position").value;
			return i + ("center" === n ? t.pstyle("border-width").pfValue : "outside" === n ? 2 * t.pstyle("border-width").pfValue : 0) + 2 * t.padding();
		}
	}, "outerDimImpl"), GK["rendered" + e.uppercaseName] = h(function() {
		var t = this[0];
		if (t) return t[e.name]() * this.cy().zoom();
	}, "renderedDimImpl"), GK["rendered" + e.uppercaseOuterName] = h(function() {
		var t = this[0];
		if (t) return t[e.outerName]() * this.cy().zoom();
	}, "renderedOuterDimImpl");
}, "defineDimFns");
GZ({ name: "width" }), GZ({ name: "height" }), GX.padding = function() {
	var e = this[0], t = e._private;
	return e.isParent() ? (e.updateCompoundBounds(), void 0 !== t.autoPadding ? t.autoPadding : e.pstyle("padding").pfValue) : e.pstyle("padding").pfValue;
}, GX.paddedHeight = function() {
	var e = this[0];
	return e.height() + 2 * e.padding();
}, GX.paddedWidth = function() {
	var e = this[0];
	return e.width() + 2 * e.padding();
};
var GQ = h(function(e, t) {
	if (e.isEdge() && e.takesUpSpace()) return t(e);
}, "ifEdge"), GJ = h(function(e, t) {
	if (e.isEdge() && e.takesUpSpace()) {
		var r = e.cy();
		return Po(t(e), r.zoom(), r.pan());
	}
}, "ifEdgeRenderedPosition"), G0 = h(function(e, t) {
	if (e.isEdge() && e.takesUpSpace()) {
		var r = e.cy(), i = r.pan(), n = r.zoom();
		return t(e).map(function(e) {
			return Po(e, n, i);
		});
	}
}, "ifEdgeRenderedPositions"), G1 = {
	controlPoints: {
		get: h(function(e) {
			return e.renderer().getControlPoints(e);
		}, "controlPoints"),
		mult: !0
	},
	segmentPoints: {
		get: h(function(e) {
			return e.renderer().getSegmentPoints(e);
		}, "segmentPoints"),
		mult: !0
	},
	sourceEndpoint: { get: h(function(e) {
		return e.renderer().getSourceEndpoint(e);
	}, "sourceEndpoint") },
	targetEndpoint: { get: h(function(e) {
		return e.renderer().getTargetEndpoint(e);
	}, "targetEndpoint") },
	midpoint: { get: h(function(e) {
		return e.renderer().getEdgeMidpoint(e);
	}, "midpoint") }
}, G2 = h(function(e) {
	return "rendered" + e[0].toUpperCase() + e.substr(1);
}, "renderedName"), G4 = Ou({}, GA, GN, GX, Object.keys(G1).reduce(function(e, t) {
	var r = G1[t], i = G2(t);
	return e[t] = function() {
		return GQ(this, r.get);
	}, r.mult ? e[i] = function() {
		return G0(this, r.get);
	} : e[i] = function() {
		return GJ(this, r.get);
	}, e;
}, {})), G5 = h(function(e, t) {
	this.recycle(e, t);
}, "Event");
function G3() {
	return !1;
}
function G6() {
	return !0;
}
h(G3, "returnFalse"), h(G6, "returnTrue"), G5.prototype = {
	instanceString: h(function() {
		return "event";
	}, "instanceString"),
	recycle: h(function(e, t) {
		if (this.isImmediatePropagationStopped = this.isPropagationStopped = this.isDefaultPrevented = G3, null != e && e.preventDefault ? (this.type = e.type, this.isDefaultPrevented = e.defaultPrevented ? G6 : G3) : null != e && e.type ? t = e : this.type = e, null != t && (this.originalEvent = t.originalEvent, this.type = null != t.type ? t.type : this.type, this.cy = t.cy, this.target = t.target, this.position = t.position, this.renderedPosition = t.renderedPosition, this.namespace = t.namespace, this.layout = t.layout), null != this.cy && null != this.position && null == this.renderedPosition) {
			var r = this.position, i = this.cy.zoom(), n = this.cy.pan();
			this.renderedPosition = {
				x: r.x * i + n.x,
				y: r.y * i + n.y
			};
		}
		this.timeStamp = e && e.timeStamp || Date.now();
	}, "recycle"),
	preventDefault: h(function() {
		this.isDefaultPrevented = G6;
		var e = this.originalEvent;
		e && e.preventDefault && e.preventDefault();
	}, "preventDefault"),
	stopPropagation: h(function() {
		this.isPropagationStopped = G6;
		var e = this.originalEvent;
		e && e.stopPropagation && e.stopPropagation();
	}, "stopPropagation"),
	stopImmediatePropagation: h(function() {
		this.isImmediatePropagationStopped = G6, this.stopPropagation();
	}, "stopImmediatePropagation"),
	isDefaultPrevented: G3,
	isPropagationStopped: G3,
	isImmediatePropagationStopped: G3
};
var G7 = /^([^.]+)(\.(?:[^.]+))?$/, G8 = {
	qualifierCompare: h(function(e, t) {
		return e === t;
	}, "qualifierCompare"),
	eventMatches: h(function() {
		return !0;
	}, "eventMatches"),
	addEventFields: h(function() {}, "addEventFields"),
	callbackContext: h(function(e) {
		return e;
	}, "callbackContext"),
	beforeEmit: h(function() {}, "beforeEmit"),
	afterEmit: h(function() {}, "afterEmit"),
	bubble: h(function() {
		return !1;
	}, "bubble"),
	parent: h(function() {
		return null;
	}, "parent"),
	context: null
}, G9 = Object.keys(G8), qe = {};
function qt() {
	for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : qe, t = arguments.length > 1 ? arguments[1] : void 0, r = 0; r < G9.length; r++) {
		var i = G9[r];
		this[i] = e[i] || G8[i];
	}
	this.context = t || this.context, this.listeners = [], this.emitting = 0;
}
h(qt, "Emitter");
var qr = qt.prototype, qi = h(function(e, t, r, i, n, a, s) {
	Dj(i) && (n = i, i = null), s && (a = null == a ? s : Ou({}, a, s));
	for (var o = DW(r) ? r : r.split(/\s+/), l = 0; l < o.length; l++) {
		var h = o[l];
		if (!D4(h)) {
			var u = h.match(G7);
			if (u && !1 === t(e, h, u[1], u[2] ? u[2] : null, i, n, a)) break;
		}
	}
}, "forEachEvent"), qn = h(function(e, t) {
	return e.addEventFields(e.context, t), new G5(t.type, t);
}, "makeEventObj"), qa = h(function(e, t, r) {
	if (D2(r)) return void t(e, r);
	if (DY(r)) return void t(e, qn(e, r));
	for (var i = DW(r) ? r : r.split(/\s+/), n = 0; n < i.length; n++) {
		var a = i[n];
		if (!D4(a)) {
			var s = a.match(G7);
			s && t(e, qn(e, {
				type: s[1],
				namespace: s[2] ? s[2] : null,
				target: e.context
			}));
		}
	}
}, "forEachEventObj");
qr.on = qr.addListener = function(e, t, r, i, n) {
	return qi(this, function(e, t, r, i, n, a, s) {
		Dj(a) && e.listeners.push({
			event: t,
			callback: a,
			type: r,
			namespace: i,
			qualifier: n,
			conf: s
		});
	}, e, t, r, i, n), this;
}, qr.one = function(e, t, r, i) {
	return this.on(e, t, r, i, { one: !0 });
}, qr.removeListener = qr.off = function(e, t, r, i) {
	var n = this;
	0 !== this.emitting && (this.listeners = $i(this.listeners));
	for (var a = this.listeners, s = h(function(s) {
		var o = a[s];
		qi(n, function(t, r, i, n, l, h) {
			if ((o.type === i || "*" === e) && (!n && ".*" !== o.namespace || o.namespace === n) && (!l || t.qualifierCompare(o.qualifier, l)) && (!h || o.callback === h)) return a.splice(s, 1), !1;
		}, e, t, r, i);
	}, "_loop"), o = a.length - 1; o >= 0; o--) s(o);
	return this;
}, qr.removeAllListeners = function() {
	return this.removeListener("*");
}, qr.emit = qr.trigger = function(e, t, r) {
	var i = this.listeners, n = i.length;
	return this.emitting++, DW(t) || (t = [t]), qa(this, function(e, a) {
		null != r && (n = (i = [{
			event: a.event,
			type: a.type,
			namespace: a.namespace,
			callback: r
		}]).length);
		for (var s = h(function() {
			var r = i[o];
			if (r.type === a.type && (!r.namespace || r.namespace === a.namespace || ".*" === r.namespace) && e.eventMatches(e.context, r, a)) {
				var n = [a];
				null != t && $h(n, t), e.beforeEmit(e.context, r, a), r.conf && r.conf.one && (e.listeners = e.listeners.filter(function(e) {
					return e !== r;
				}));
				var s = e.callbackContext(e.context, r, a), l = r.callback.apply(s, n);
				e.afterEmit(e.context, r, a), !1 === l && (a.stopPropagation(), a.preventDefault());
			}
		}, "_loop2"), o = 0; o < n; o++) s();
		e.bubble(e.context) && !a.isPropagationStopped() && e.parent(e.context).emit(a, t);
	}, e), this.emitting--, this;
};
var qs = {
	qualifierCompare: h(function(e, t) {
		return null == e || null == t ? null == e && null == t : e.sameText(t);
	}, "qualifierCompare"),
	eventMatches: h(function(e, t, r) {
		var i = t.qualifier;
		return null == i || e !== r.target && DQ(r.target) && i.matches(r.target);
	}, "eventMatches"),
	addEventFields: h(function(e, t) {
		t.cy = e.cy(), t.target = e;
	}, "addEventFields"),
	callbackContext: h(function(e, t, r) {
		return null != t.qualifier ? r.target : e;
	}, "callbackContext"),
	beforeEmit: h(function(e, t) {
		t.conf && t.conf.once && t.conf.onceCollection.removeListener(t.event, t.qualifier, t.callback);
	}, "beforeEmit"),
	bubble: h(function() {
		return !0;
	}, "bubble"),
	parent: h(function(e) {
		return e.isChild() ? e.parent() : e.cy();
	}, "parent")
}, qo = h(function(e) {
	return Dq(e) ? new Gl(e) : e;
}, "argSelector"), ql = {
	createEmitter: h(function() {
		for (var e = 0; e < this.length; e++) {
			var t = this[e], r = t._private;
			r.emitter || (r.emitter = new qt(qs, t));
		}
		return this;
	}, "createEmitter"),
	emitter: h(function() {
		return this._private.emitter;
	}, "emitter"),
	on: h(function(e, t, r) {
		for (var i = qo(t), n = 0; n < this.length; n++) this[n].emitter().on(e, i, r);
		return this;
	}, "on"),
	removeListener: h(function(e, t, r) {
		for (var i = qo(t), n = 0; n < this.length; n++) this[n].emitter().removeListener(e, i, r);
		return this;
	}, "removeListener"),
	removeAllListeners: h(function() {
		for (var e = 0; e < this.length; e++) this[e].emitter().removeAllListeners();
		return this;
	}, "removeAllListeners"),
	one: h(function(e, t, r) {
		for (var i = qo(t), n = 0; n < this.length; n++) this[n].emitter().one(e, i, r);
		return this;
	}, "one"),
	once: h(function(e, t, r) {
		for (var i = qo(t), n = 0; n < this.length; n++) this[n].emitter().on(e, i, r, {
			once: !0,
			onceCollection: this
		});
	}, "once"),
	emit: h(function(e, t) {
		for (var r = 0; r < this.length; r++) this[r].emitter().emit(e, t);
		return this;
	}, "emit"),
	emitAndNotify: h(function(e, t) {
		if (0 !== this.length) return this.cy().notify(e, this), this.emit(e, t), this;
	}, "emitAndNotify")
};
UH.eventAliasesOn(ql);
var qc = {
	nodes: h(function(e) {
		return this.filter(function(e) {
			return e.isNode();
		}).filter(e);
	}, "nodes"),
	edges: h(function(e) {
		return this.filter(function(e) {
			return e.isEdge();
		}).filter(e);
	}, "edges"),
	byGroup: h(function() {
		for (var e = this.spawn(), t = this.spawn(), r = 0; r < this.length; r++) {
			var i = this[r];
			i.isNode() ? e.push(i) : t.push(i);
		}
		return {
			nodes: e,
			edges: t
		};
	}, "byGroup"),
	filter: h(function(e, t) {
		if (void 0 === e) return this;
		if (Dq(e) || DZ(e)) return new Gl(e).filter(this);
		if (Dj(e)) {
			for (var r = this.spawn(), i = 0; i < this.length; i++) {
				var n = this[i];
				(t ? e.apply(t, [
					n,
					i,
					this
				]) : e(n, i, this)) && r.push(n);
			}
			return r;
		}
		return this.spawn();
	}, "filter"),
	not: h(function(e) {
		if (!e) return this;
		Dq(e) && (e = this.filter(e));
		for (var t = this.spawn(), r = 0; r < this.length; r++) {
			var i = this[r];
			e.has(i) || t.push(i);
		}
		return t;
	}, "not"),
	absoluteComplement: h(function() {
		return this.cy().mutableElements().not(this);
	}, "absoluteComplement"),
	intersect: h(function(e) {
		if (Dq(e)) return this.filter(e);
		for (var t = this.spawn(), r = this.length < e.length, i = r ? this : e, n = r ? e : this, a = 0; a < i.length; a++) {
			var s = i[a];
			n.has(s) && t.push(s);
		}
		return t;
	}, "intersect"),
	xor: h(function(e) {
		var t = this._private.cy;
		Dq(e) && (e = t.$(e));
		var r = this.spawn(), i = e, n = h(function(e, t) {
			for (var i = 0; i < e.length; i++) {
				var n = e[i], a = n._private.data.id;
				t.hasElementWithId(a) || r.push(n);
			}
		}, "add");
		return n(this, i), n(i, this), r;
	}, "xor"),
	diff: h(function(e) {
		var t = this._private.cy;
		Dq(e) && (e = t.$(e));
		var r = this.spawn(), i = this.spawn(), n = this.spawn(), a = e, s = h(function(e, t, r) {
			for (var i = 0; i < e.length; i++) {
				var a = e[i], s = a._private.data.id;
				t.hasElementWithId(s) ? n.merge(a) : r.push(a);
			}
		}, "add");
		return s(this, a, r), s(a, this, i), {
			left: r,
			right: i,
			both: n
		};
	}, "diff"),
	add: h(function(e) {
		var t = this._private.cy;
		if (!e) return this;
		if (Dq(e)) {
			var r = e;
			e = t.mutableElements().filter(r);
		}
		for (var i = this.spawnSelf(), n = 0; n < e.length; n++) {
			var a = e[n];
			this.has(a) || i.push(a);
		}
		return i;
	}, "add"),
	merge: h(function(e) {
		var t = this._private, r = t.cy;
		if (!e) return this;
		if (e && Dq(e)) {
			var i = e;
			e = r.mutableElements().filter(i);
		}
		for (var n = t.map, a = 0; a < e.length; a++) {
			var s = e[a], o = s._private.data.id;
			if (!n.has(o)) {
				var l = this.length++;
				this[l] = s, n.set(o, {
					ele: s,
					index: l
				});
			}
		}
		return this;
	}, "merge"),
	unmergeAt: h(function(e) {
		var t = this[e].id(), r = this._private.map;
		this[e] = void 0, r.delete(t);
		var i = e === this.length - 1;
		if (this.length > 1 && !i) {
			var n = this.length - 1, a = this[n], s = a._private.data.id;
			this[n] = void 0, this[e] = a, r.set(s, {
				ele: a,
				index: e
			});
		}
		return this.length--, this;
	}, "unmergeAt"),
	unmergeOne: h(function(e) {
		e = e[0];
		var t = this._private, r = e._private.data.id, i = t.map.get(r);
		if (!i) return this;
		var n = i.index;
		return this.unmergeAt(n), this;
	}, "unmergeOne"),
	unmerge: h(function(e) {
		var t = this._private.cy;
		if (!e) return this;
		if (e && Dq(e)) {
			var r = e;
			e = t.mutableElements().filter(r);
		}
		for (var i = 0; i < e.length; i++) this.unmergeOne(e[i]);
		return this;
	}, "unmerge"),
	unmergeBy: h(function(e) {
		for (var t = this.length - 1; t >= 0; t--) e(this[t]) && this.unmergeAt(t);
		return this;
	}, "unmergeBy"),
	map: h(function(e, t) {
		for (var r = [], i = 0; i < this.length; i++) {
			var n = this[i], a = t ? e.apply(t, [
				n,
				i,
				this
			]) : e(n, i, this);
			r.push(a);
		}
		return r;
	}, "map"),
	reduce: h(function(e, t) {
		for (var r = t, i = 0; i < this.length; i++) r = e(r, this[i], i, this);
		return r;
	}, "reduce"),
	max: h(function(e, t) {
		for (var r, i = -Infinity, n = 0; n < this.length; n++) {
			var a = this[n], s = t ? e.apply(t, [
				a,
				n,
				this
			]) : e(a, n, this);
			s > i && (i = s, r = a);
		}
		return {
			value: i,
			ele: r
		};
	}, "max"),
	min: h(function(e, t) {
		for (var r, i = Infinity, n = 0; n < this.length; n++) {
			var a = this[n], s = t ? e.apply(t, [
				a,
				n,
				this
			]) : e(a, n, this);
			s < i && (i = s, r = a);
		}
		return {
			value: i,
			ele: r
		};
	}, "min")
};
qc.u = qc["|"] = qc["+"] = qc.union = qc.or = qc.add, qc["\\"] = qc["!"] = qc["-"] = qc.difference = qc.relativeComplement = qc.subtract = qc.not, qc.n = qc["&"] = qc["."] = qc.and = qc.intersection = qc.intersect, qc["^"] = qc["(+)"] = qc["(-)"] = qc.symmetricDifference = qc.symdiff = qc.xor, qc.fnFilter = qc.filterFn = qc.stdFilter = qc.filter, qc.complement = qc.abscomp = qc.absoluteComplement;
var qh = {
	isNode: h(function() {
		return "nodes" === this.group();
	}, "isNode"),
	isEdge: h(function() {
		return "edges" === this.group();
	}, "isEdge"),
	isLoop: h(function() {
		return this.isEdge() && this.source()[0] === this.target()[0];
	}, "isLoop"),
	isSimple: h(function() {
		return this.isEdge() && this.source()[0] !== this.target()[0];
	}, "isSimple"),
	group: h(function() {
		var e = this[0];
		if (e) return e._private.group;
	}, "group")
}, qu = h(function(e, t) {
	var r = e.cy().hasCompoundNodes();
	function i(e) {
		var t = e.pstyle("z-compound-depth");
		return "auto" === t.value ? r ? e.zDepth() : 0 : "bottom" === t.value ? -1 : "top" === t.value ? O4 : 0;
	}
	h(i, "getDepth");
	var n = i(e) - i(t);
	if (0 !== n) return n;
	function a(e) {
		return "auto" === e.pstyle("z-index-compare").value && e.isNode() ? 1 : 0;
	}
	h(a, "getEleDepth");
	var s = a(e) - a(t);
	if (0 !== s) return s;
	var o = e.pstyle("z-index").value - t.pstyle("z-index").value;
	return 0 !== o ? o : e.poolIndex() - t.poolIndex();
}, "zIndexSort"), qd = {
	forEach: h(function(e, t) {
		if (Dj(e)) for (var r = this.length, i = 0; i < r; i++) {
			var n = this[i];
			if ((t ? e.apply(t, [
				n,
				i,
				this
			]) : e(n, i, this)) === !1) break;
		}
		return this;
	}, "forEach"),
	toArray: h(function() {
		for (var e = [], t = 0; t < this.length; t++) e.push(this[t]);
		return e;
	}, "toArray"),
	slice: h(function(e, t) {
		var r = [], i = this.length;
		t ??= i, (e ??= 0) < 0 && (e = i + e), t < 0 && (t = i + t);
		for (var n = e; n >= 0 && n < t && n < i; n++) r.push(this[n]);
		return this.spawn(r);
	}, "slice"),
	size: h(function() {
		return this.length;
	}, "size"),
	eq: h(function(e) {
		return this[e] || this.spawn();
	}, "eq"),
	first: h(function() {
		return this[0] || this.spawn();
	}, "first"),
	last: h(function() {
		return this[this.length - 1] || this.spawn();
	}, "last"),
	empty: h(function() {
		return 0 === this.length;
	}, "empty"),
	nonempty: h(function() {
		return !this.empty();
	}, "nonempty"),
	sort: h(function(e) {
		if (!Dj(e)) return this;
		var t = this.toArray().sort(e);
		return this.spawn(t);
	}, "sort"),
	sortByZIndex: h(function() {
		return this.sort(qu);
	}, "sortByZIndex"),
	zDepth: h(function() {
		var e = this[0];
		if (e) {
			var t = e._private;
			if ("nodes" === t.group) {
				var r = t.data.parent ? e.parents().size() : 0;
				return e.isParent() ? r : O4 - 1;
			}
			var i = t.source, n = t.target;
			return Math.max(i.zDepth(), n.zDepth(), 0);
		}
	}, "zDepth")
};
qd.each = qd.forEach, h(function() {
	var e = "undefined";
	(typeof Symbol > "u" ? "undefined" : DD(Symbol)) != e && DD(Symbol.iterator) != e && (qd[Symbol.iterator] = function() {
		var e = this, t = {
			value: void 0,
			done: !1
		}, r = 0, i = this.length;
		return DE({ next: h(function() {
			return r < i ? t.value = e[r++] : (t.value = void 0, t.done = !0), t;
		}, "next") }, Symbol.iterator, function() {
			return this;
		});
	});
}, "defineSymbolIterator")();
var qp = $o({ nodeDimensionsIncludeLabels: !1 }), qf = {
	layoutDimensions: h(function(e) {
		if (e = qp(e), this.takesUpSpace()) if (e.nodeDimensionsIncludeLabels) {
			var t, r = this.boundingBox();
			t = {
				w: r.w,
				h: r.h
			};
		} else t = {
			w: this.outerWidth(),
			h: this.outerHeight()
		};
		else t = {
			w: 0,
			h: 0
		};
		return (0 === t.w || 0 === t.h) && (t.w = t.h = 1), t;
	}, "layoutDimensions"),
	layoutPositions: h(function(e, t, r) {
		var i = this.nodes().filter(function(e) {
			return !e.isParent();
		}), n = this.cy(), a = t.eles, s = h(function(e) {
			return e.id();
		}, "getMemoizeKey"), o = D8(r, s);
		e.emit({
			type: "layoutstart",
			layout: e
		}), e.animations = [];
		var l = h(function(e, t, r) {
			var i = {
				x: t.x1 + t.w / 2,
				y: t.y1 + t.h / 2
			}, n = {
				x: (r.x - i.x) * e,
				y: (r.y - i.y) * e
			};
			return {
				x: i.x + n.x,
				y: i.y + n.y
			};
		}, "calculateSpacing"), u = t.spacingFactor && 1 !== t.spacingFactor, d = h(function() {
			if (!u) return null;
			for (var e = PE(), t = 0; t < i.length; t++) {
				var r = o(i[t], t);
				PL(e, r.x, r.y);
			}
			return e;
		}, "spacingBb")(), p = D8(function(e, r) {
			var i = o(e, r);
			return u && (i = l(Math.abs(t.spacingFactor), d, i)), null != t.transform && (i = t.transform(e, i)), i;
		}, s);
		if (t.animate) {
			for (var f = 0; f < i.length; f++) {
				var g = i[f], m = p(g, f);
				if (null == t.animateFilter || t.animateFilter(g, f)) {
					var y = g.animation({
						position: m,
						duration: t.animationDuration,
						easing: t.animationEasing
					});
					e.animations.push(y);
				} else g.position(m);
			}
			if (t.fit) {
				var v = n.animation({
					fit: {
						boundingBox: a.boundingBoxAt(p),
						padding: t.padding
					},
					duration: t.animationDuration,
					easing: t.animationEasing
				});
				e.animations.push(v);
			} else if (void 0 !== t.zoom && void 0 !== t.pan) {
				var x = n.animation({
					zoom: t.zoom,
					pan: t.pan,
					duration: t.animationDuration,
					easing: t.animationEasing
				});
				e.animations.push(x);
			}
			e.animations.forEach(function(e) {
				return e.play();
			}), e.one("layoutready", t.ready), e.emit({
				type: "layoutready",
				layout: e
			}), Fm.all(e.animations.map(function(e) {
				return e.promise();
			})).then(function() {
				e.one("layoutstop", t.stop), e.emit({
					type: "layoutstop",
					layout: e
				});
			});
		} else i.positions(p), t.fit && n.fit(t.eles, t.padding), null != t.zoom && n.zoom(t.zoom), t.pan && n.pan(t.pan), e.one("layoutready", t.ready), e.emit({
			type: "layoutready",
			layout: e
		}), e.one("layoutstop", t.stop), e.emit({
			type: "layoutstop",
			layout: e
		});
		return this;
	}, "layoutPositions"),
	layout: h(function(e) {
		return this.cy().makeLayout(Ou({}, e, { eles: this }));
	}, "layout")
};
function qg(e, t, r) {
	var i, n = r._private, a = n.styleCache = n.styleCache || [];
	return (i = a[e]) ?? (i = a[e] = t(r)), i;
}
function qm(e, t) {
	return e = OH(e), h(function(r) {
		return qg(e, t, r);
	}, "cachedStyleFunction");
}
function qy(e, t) {
	e = OH(e);
	var r = h(function(e) {
		return t.call(e);
	}, "selfFn");
	return h(function() {
		var t = this[0];
		if (t) return qg(e, r, t);
	}, "cachedPrototypeStyleFunction");
}
qf.createLayout = qf.makeLayout = qf.layout, h(qg, "styleCache"), h(qm, "cacheStyleFunction"), h(qy, "cachePrototypeStyleFunction");
var qv = {
	recalculateRenderedStyle: h(function(e) {
		var t = this.cy(), r = t.renderer(), i = t.styleEnabled();
		return r && i && r.recalculateRenderedStyle(this, e), this;
	}, "recalculateRenderedStyle"),
	dirtyStyleCache: h(function() {
		var e = this.cy(), t = h(function(e) {
			return e._private.styleCache = null;
		}, "dirty");
		if (e.hasCompoundNodes()) {
			var r = this.spawnSelf().merge(this.descendants()).merge(this.parents());
			r.merge(r.connectedEdges()), r.forEach(t);
		} else this.forEach(function(e) {
			t(e), e.connectedEdges().forEach(t);
		});
		return this;
	}, "dirtyStyleCache"),
	updateStyle: h(function(e) {
		var t = this._private.cy;
		if (!t.styleEnabled()) return this;
		if (t.batching()) return t._private.batchStyleEles.merge(this), this;
		var r = t.hasCompoundNodes(), i = this;
		e = !!(e || void 0 === e), r && (i = this.spawnSelf().merge(this.descendants()).merge(this.parents()));
		var n = i;
		return e ? n.emitAndNotify("style") : n.emit("style"), i.forEach(function(e) {
			return e._private.styleDirty = !0;
		}), this;
	}, "updateStyle"),
	cleanStyle: h(function() {
		var e = this.cy();
		if (e.styleEnabled()) for (var t = 0; t < this.length; t++) {
			var r = this[t];
			r._private.styleDirty && (r._private.styleDirty = !1, e.style().apply(r));
		}
	}, "cleanStyle"),
	parsedStyle: h(function(e) {
		var t = !(arguments.length > 1) || void 0 === arguments[1] || arguments[1], r = this[0], i = r.cy();
		if (i.styleEnabled() && r) return r._private.styleDirty && (r._private.styleDirty = !1, i.style().apply(r)), r._private.style[e] ?? (t ? i.style().getDefaultProperty(e) : null);
	}, "parsedStyle"),
	numericStyle: h(function(e) {
		var t = this[0];
		if (t.cy().styleEnabled() && t) {
			var r = t.pstyle(e);
			return void 0 !== r.pfValue ? r.pfValue : r.value;
		}
	}, "numericStyle"),
	numericStyleUnits: h(function(e) {
		var t = this[0];
		if (t.cy().styleEnabled() && t) return t.pstyle(e).units;
	}, "numericStyleUnits"),
	renderedStyle: h(function(e) {
		var t = this.cy();
		if (!t.styleEnabled()) return this;
		var r = this[0];
		if (r) return t.style().getRenderedStyle(r, e);
	}, "renderedStyle"),
	style: h(function(e, t) {
		var r = this.cy();
		if (!r.styleEnabled()) return this;
		var i = r.style();
		if (DY(e)) i.applyBypass(this, e, !1), this.emitAndNotify("style");
		else if (Dq(e)) if (void 0 === t) {
			var n = this[0];
			return n ? i.getStylePropertyValue(n, e) : void 0;
		} else i.applyBypass(this, e, t, !1), this.emitAndNotify("style");
		else if (void 0 === e) {
			var a = this[0];
			return a ? i.getRawStyle(a) : void 0;
		}
		return this;
	}, "style"),
	removeStyle: h(function(e) {
		var t = this.cy();
		if (!t.styleEnabled()) return this;
		var r = t.style();
		if (void 0 === e) for (var i = 0; i < this.length; i++) {
			var n = this[i];
			r.removeAllBypasses(n, !1);
		}
		else {
			e = e.split(/\s+/);
			for (var a = 0; a < this.length; a++) {
				var s = this[a];
				r.removeBypasses(s, e, !1);
			}
		}
		return this.emitAndNotify("style"), this;
	}, "removeStyle"),
	show: h(function() {
		return this.css("display", "element"), this;
	}, "show"),
	hide: h(function() {
		return this.css("display", "none"), this;
	}, "hide"),
	effectiveOpacity: h(function() {
		var e = this.cy();
		if (!e.styleEnabled()) return 1;
		var t = e.hasCompoundNodes(), r = this[0];
		if (r) {
			var i = r._private, n = r.pstyle("opacity").value;
			if (!t) return n;
			var a = i.data.parent ? r.parents() : null;
			if (a) for (var s = 0; s < a.length; s++) n = a[s].pstyle("opacity").value * n;
			return n;
		}
	}, "effectiveOpacity"),
	transparent: h(function() {
		if (!this.cy().styleEnabled()) return !1;
		var e = this[0], t = e.cy().hasCompoundNodes();
		if (e) return t ? 0 === e.effectiveOpacity() : 0 === e.pstyle("opacity").value;
	}, "transparent"),
	backgrounding: h(function() {
		return !!this.cy().styleEnabled() && !!this[0]._private.backgrounding;
	}, "backgrounding")
};
function qx(e, t) {
	var r = e._private.data.parent ? e.parents() : null;
	if (r) {
		for (var i = 0; i < r.length; i++) if (!t(r[i])) return !1;
	}
	return !0;
}
function qb(e) {
	var t = e.ok, r = e.edgeOkViaNode || e.ok, i = e.parentOk || e.ok;
	return function() {
		var e = this.cy();
		if (!e.styleEnabled()) return !0;
		var n = this[0], a = e.hasCompoundNodes();
		if (n) {
			var s = n._private;
			if (!t(n)) return !1;
			if (n.isNode()) return !a || qx(n, i);
			var o = s.source, l = s.target;
			return r(o) && (!a || qx(o, r)) && (o === l || r(l) && (!a || qx(l, r)));
		}
	};
}
h(qx, "checkCompound"), h(qb, "defineDerivedStateFunction");
var qw = qm("eleTakesUpSpace", function(e) {
	return "element" === e.pstyle("display").value && 0 !== e.width() && (!e.isNode() || 0 !== e.height());
});
qv.takesUpSpace = qy("takesUpSpace", qb({ ok: qw })), qv.interactive = qy("interactive", qb({
	ok: qm("eleInteractive", function(e) {
		return "yes" === e.pstyle("events").value && "visible" === e.pstyle("visibility").value && qw(e);
	}),
	parentOk: qm("parentInteractive", function(e) {
		return "visible" === e.pstyle("visibility").value && qw(e);
	}),
	edgeOkViaNode: qw
})), qv.noninteractive = function() {
	var e = this[0];
	if (e) return !e.interactive();
}, qv.visible = qy("visible", qb({
	ok: qm("eleVisible", function(e) {
		return "visible" === e.pstyle("visibility").value && 0 !== e.pstyle("opacity").pfValue && qw(e);
	}),
	edgeOkViaNode: qw
})), qv.hidden = function() {
	var e = this[0];
	if (e) return !e.visible();
}, qv.isBundledBezier = qy("isBundledBezier", function() {
	return !!this.cy().styleEnabled() && !this.removed() && "bezier" === this.pstyle("curve-style").value && this.takesUpSpace();
}), qv.bypass = qv.css = qv.style, qv.renderedCss = qv.renderedStyle, qv.removeBypass = qv.removeCss = qv.removeStyle, qv.pstyle = qv.parsedStyle;
var qk = {};
function qT(e) {
	return function() {
		var t = arguments, r = [];
		if (2 === t.length) {
			var i = t[0], n = t[1];
			this.on(e.event, i, n);
		} else if (1 === t.length && Dj(t[0])) {
			var a = t[0];
			this.on(e.event, a);
		} else if (0 === t.length || 1 === t.length && DW(t[0])) {
			for (var s = 1 === t.length ? t[0] : null, o = 0; o < this.length; o++) {
				var l = this[o], h = !e.ableField || l._private[e.ableField], u = l._private[e.field] != e.value;
				if (e.overrideAble) {
					var d = e.overrideAble(l);
					if (void 0 !== d && (h = d, !d)) return this;
				}
				h && (l._private[e.field] = e.value, u && r.push(l));
			}
			var p = this.spawn(r);
			p.updateStyle(), p.emit(e.event), s && p.emit(s);
		}
		return this;
	};
}
function q_(e) {
	qk[e.field] = function() {
		var t = this[0];
		if (t) {
			if (e.overrideField) {
				var r = e.overrideField(t);
				if (void 0 !== r) return r;
			}
			return t._private[e.field];
		}
	}, qk[e.on] = qT({
		event: e.on,
		field: e.field,
		ableField: e.ableField,
		overrideAble: e.overrideAble,
		value: !0
	}), qk[e.off] = qT({
		event: e.off,
		field: e.field,
		ableField: e.ableField,
		overrideAble: e.overrideAble,
		value: !1
	});
}
h(qT, "defineSwitchFunction"), h(q_, "defineSwitchSet"), q_({
	field: "locked",
	overrideField: h(function(e) {
		return !!e.cy().autolock() || void 0;
	}, "overrideField"),
	on: "lock",
	off: "unlock"
}), q_({
	field: "grabbable",
	overrideField: h(function(e) {
		return !(e.cy().autoungrabify() || e.pannable()) && void 0;
	}, "overrideField"),
	on: "grabify",
	off: "ungrabify"
}), q_({
	field: "selected",
	ableField: "selectable",
	overrideAble: h(function(e) {
		return !e.cy().autounselectify() && void 0;
	}, "overrideAble"),
	on: "select",
	off: "unselect"
}), q_({
	field: "selectable",
	overrideField: h(function(e) {
		return !e.cy().autounselectify() && void 0;
	}, "overrideField"),
	on: "selectify",
	off: "unselectify"
}), qk.deselect = qk.unselect, qk.grabbed = function() {
	var e = this[0];
	if (e) return e._private.grabbed;
}, q_({
	field: "active",
	on: "activate",
	off: "unactivate"
}), q_({
	field: "pannable",
	on: "panify",
	off: "unpanify"
}), qk.inactive = function() {
	var e = this[0];
	if (e) return !e._private.active;
};
var qE = {}, qC = h(function(e) {
	return h(function(t) {
		for (var r = [], i = 0; i < this.length; i++) {
			var n = this[i];
			if (n.isNode()) {
				for (var a = !1, s = n.connectedEdges(), o = 0; o < s.length; o++) {
					var l = s[o], h = l.source(), u = l.target();
					if (e.noIncomingEdges && u === n && h !== n || e.noOutgoingEdges && h === n && u !== n) {
						a = !0;
						break;
					}
				}
				a || r.push(n);
			}
		}
		return this.spawn(r, !0).filter(t);
	}, "dagExtremityImpl");
}, "defineDagExtremity"), qS = h(function(e) {
	return function(t) {
		for (var r = [], i = 0; i < this.length; i++) {
			var n = this[i];
			if (n.isNode()) for (var a = n.connectedEdges(), s = 0; s < a.length; s++) {
				var o = a[s], l = o.source(), h = o.target();
				e.outgoing && l === n ? (r.push(o), r.push(h)) : e.incoming && h === n && (r.push(o), r.push(l));
			}
		}
		return this.spawn(r, !0).filter(t);
	};
}, "defineDagOneHop"), qA = h(function(e) {
	return function(t) {
		for (var r = this, i = [], n = {};;) {
			var a = e.outgoing ? r.outgoers() : r.incomers();
			if (0 === a.length) break;
			for (var s = !1, o = 0; o < a.length; o++) {
				var l = a[o], h = l.id();
				n[h] || (n[h] = !0, i.push(l), s = !0);
			}
			if (!s) break;
			r = a;
		}
		return this.spawn(i, !0).filter(t);
	};
}, "defineDagAllHops");
function qL(e) {
	return h(function(t) {
		for (var r = [], i = 0; i < this.length; i++) {
			var n = this[i]._private[e.attr];
			n && r.push(n);
		}
		return this.spawn(r, !0).filter(t);
	}, "sourceImpl");
}
function qR(e) {
	return h(function(t) {
		var r = [], i = this._private.cy, n = e || {};
		Dq(t) && (t = i.$(t));
		for (var a = 0; a < t.length; a++) for (var s = t[a]._private.edges, o = 0; o < s.length; o++) {
			var l = s[o], h = l._private.data, u = this.hasElementWithId(h.source) && t.hasElementWithId(h.target), d = t.hasElementWithId(h.source) && this.hasElementWithId(h.target);
			(u || d) && ((n.thisIsSrc || n.thisIsTgt) && (n.thisIsSrc && !u || n.thisIsTgt && !d) || r.push(l));
		}
		return this.spawn(r, !0);
	}, "edgesWithImpl");
}
function qN(e) {
	return e = Ou({}, { codirected: !1 }, e), h(function(t) {
		for (var r = [], i = this.edges(), n = e, a = 0; a < i.length; a++) for (var s = i[a], o = s._private, l = o.source, h = l._private.data.id, u = o.data.target, d = l._private.edges, p = 0; p < d.length; p++) {
			var f = d[p], g = f._private.data, m = g.target, y = g.source, v = m === u && y === h, x = h === m && u === y;
			(n.codirected && v || !n.codirected && (v || x)) && r.push(f);
		}
		return this.spawn(r, !0).filter(t);
	}, "parallelEdgesImpl");
}
qE.clearTraversalCache = function() {
	for (var e = 0; e < this.length; e++) this[e]._private.traversalCache = null;
}, Ou(qE, {
	roots: qC({ noIncomingEdges: !0 }),
	leaves: qC({ noOutgoingEdges: !0 }),
	outgoers: Gu(qS({ outgoing: !0 }), "outgoers"),
	successors: qA({ outgoing: !0 }),
	incomers: Gu(qS({ incoming: !0 }), "incomers"),
	predecessors: qA({})
}), Ou(qE, {
	neighborhood: Gu(function(e) {
		for (var t = [], r = this.nodes(), i = 0; i < r.length; i++) for (var n = r[i], a = n.connectedEdges(), s = 0; s < a.length; s++) {
			var o = a[s], l = o.source(), h = o.target(), u = n === l ? h : l;
			u.length > 0 && t.push(u[0]), t.push(o[0]);
		}
		return this.spawn(t, !0).filter(e);
	}, "neighborhood"),
	closedNeighborhood: h(function(e) {
		return this.neighborhood().add(this).filter(e);
	}, "closedNeighborhood"),
	openNeighborhood: h(function(e) {
		return this.neighborhood(e);
	}, "openNeighborhood")
}), qE.neighbourhood = qE.neighborhood, qE.closedNeighbourhood = qE.closedNeighborhood, qE.openNeighbourhood = qE.openNeighborhood, Ou(qE, {
	source: Gu(h(function(e) {
		var t, r = this[0];
		return r && (t = r._private.source || r.cy().collection()), t && e ? t.filter(e) : t;
	}, "sourceImpl"), "source"),
	target: Gu(h(function(e) {
		var t, r = this[0];
		return r && (t = r._private.target || r.cy().collection()), t && e ? t.filter(e) : t;
	}, "targetImpl"), "target"),
	sources: qL({ attr: "source" }),
	targets: qL({ attr: "target" })
}), h(qL, "defineSourceFunction"), Ou(qE, {
	edgesWith: Gu(qR(), "edgesWith"),
	edgesTo: Gu(qR({ thisIsSrc: !0 }), "edgesTo")
}), h(qR, "defineEdgesWithFunction"), Ou(qE, {
	connectedEdges: Gu(function(e) {
		for (var t = [], r = 0; r < this.length; r++) {
			var i = this[r];
			if (i.isNode()) for (var n = i._private.edges, a = 0; a < n.length; a++) {
				var s = n[a];
				t.push(s);
			}
		}
		return this.spawn(t, !0).filter(e);
	}, "connectedEdges"),
	connectedNodes: Gu(function(e) {
		for (var t = [], r = 0; r < this.length; r++) {
			var i = this[r];
			i.isEdge() && (t.push(i.source()[0]), t.push(i.target()[0]));
		}
		return this.spawn(t, !0).filter(e);
	}, "connectedNodes"),
	parallelEdges: Gu(qN(), "parallelEdges"),
	codirectedEdges: Gu(qN({ codirected: !0 }), "codirectedEdges")
}), h(qN, "defineParallelEdgesFunction"), Ou(qE, {
	components: h(function(e) {
		var t = this, r = t.cy(), i = r.collection(), n = null == e ? t.nodes() : e.nodes(), a = [];
		null != e && n.empty() && (n = e.sources());
		var s = h(function(e, t) {
			i.merge(e), n.unmerge(e), t.merge(e);
		}, "visitInComponent");
		if (n.empty()) return t.spawn();
		var o = h(function() {
			var e = r.collection();
			a.push(e);
			var i = n[0];
			s(i, e), t.bfs({
				directed: !1,
				roots: i,
				visit: h(function(t) {
					return s(t, e);
				}, "visit")
			}), e.forEach(function(r) {
				r.connectedEdges().forEach(function(r) {
					t.has(r) && e.has(r.source()) && e.has(r.target()) && e.merge(r);
				});
			});
		}, "_loop");
		do
			o();
		while (n.length > 0);
		return a;
	}, "components"),
	component: h(function() {
		var e = this[0];
		return e.cy().mutableElements().components(e)[0];
	}, "component")
}), qE.componentsOf = qE.components;
var qI = h(function(e, t) {
	var r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
	if (void 0 === e) return void O8("A collection must have a reference to the core");
	var n = new $f(), a = !1;
	if (t) {
		if (t.length > 0 && DY(t[0]) && !DQ(t[0])) {
			a = !0;
			for (var s = [], o = new $m(), l = 0, u = t.length; l < u; l++) {
				var d = t[l];
				d.data ??= {};
				var p = d.data;
				if (null == p.id) p.id = $n();
				else if (e.hasElementWithId(p.id) || o.has(p.id)) continue;
				var f = new $y(e, d, !1);
				s.push(f), o.add(p.id);
			}
			t = s;
		}
	} else t = [];
	this.length = 0;
	for (var g = 0, m = t.length; g < m; g++) {
		var y = t[g][0];
		if (null != y) {
			var v = y._private.data.id;
			(!r || !n.has(v)) && (r && n.set(v, {
				index: this.length,
				ele: y
			}), this[this.length] = y, this.length++);
		}
	}
	this._private = {
		eles: this,
		cy: e,
		get map() {
			return this.lazyMap ?? this.rebuildMap(), this.lazyMap;
		},
		set map(b$7) {
			this.lazyMap = b$7;
		},
		rebuildMap: h(function() {
			for (var e = this.lazyMap = new $f(), t = this.eles, r = 0; r < t.length; r++) {
				var i = t[r];
				e.set(i.id(), {
					index: r,
					ele: i
				});
			}
		}, "rebuildMap")
	}, r && (this._private.map = n), a && !i && this.restore();
}, "Collection"), qM = $y.prototype = qI.prototype = Object.create(Array.prototype);
qM.instanceString = function() {
	return "collection";
}, qM.spawn = function(e, t) {
	return new qI(this.cy(), e, t);
}, qM.spawnSelf = function() {
	return this.spawn(this);
}, qM.cy = function() {
	return this._private.cy;
}, qM.renderer = function() {
	return this._private.cy.renderer();
}, qM.element = function() {
	return this[0];
}, qM.collection = function() {
	return DJ(this) ? this : new qI(this._private.cy, [this]);
}, qM.unique = function() {
	return new qI(this._private.cy, this, !0);
}, qM.hasElementWithId = function(e) {
	return e = "" + e, this._private.map.has(e);
}, qM.getElementById = function(e) {
	e = "" + e;
	var t = this._private.cy, r = this._private.map.get(e);
	return r ? r.ele : new qI(t);
}, qM.$id = qM.getElementById, qM.poolIndex = function() {
	var e = this._private.cy._private.elements, t = this[0]._private.data.id;
	return e._private.map.get(t).index;
}, qM.indexOf = function(e) {
	var t = e[0]._private.data.id;
	return this._private.map.get(t).index;
}, qM.indexOfId = function(e) {
	return e = "" + e, this._private.map.get(e).index;
}, qM.json = function(e) {
	var t = this.element(), r = this.cy();
	if (null == t && e) return this;
	if (null != t) {
		var i = t._private;
		if (DY(e)) {
			if (r.startBatch(), e.data) {
				t.data(e.data);
				var n = i.data;
				if (t.isEdge()) {
					var a = !1, s = {}, o = e.data.source, l = e.data.target;
					null != o && o != n.source && (s.source = "" + o, a = !0), null != l && l != n.target && (s.target = "" + l, a = !0), a && (t = t.move(s));
				} else {
					var u = "parent" in e.data, d = e.data.parent;
					u && (null != d || null != n.parent) && d != n.parent && (void 0 === d && (d = null), null != d && (d = "" + d), t = t.move({ parent: d }));
				}
			}
			e.position && t.position(e.position);
			var p = h(function(r, n, a) {
				var s = e[r];
				null != s && s !== i[r] && (s ? t[n]() : t[a]());
			}, "checkSwitch");
			return p("removed", "remove", "restore"), p("selected", "select", "unselect"), p("selectable", "selectify", "unselectify"), p("locked", "lock", "unlock"), p("grabbable", "grabify", "ungrabify"), p("pannable", "panify", "unpanify"), null != e.classes && t.classes(e.classes), r.endBatch(), this;
		}
		if (void 0 === e) {
			var f = {
				data: $r(i.data),
				position: $r(i.position),
				group: i.group,
				removed: i.removed,
				selected: i.selected,
				selectable: i.selectable,
				locked: i.locked,
				grabbable: i.grabbable,
				pannable: i.pannable,
				classes: null
			};
			f.classes = "";
			var g = 0;
			return i.classes.forEach(function(e) {
				return f.classes += 0 == g++ ? e : " " + e;
			}), f;
		}
	}
}, qM.jsons = function() {
	for (var e = [], t = 0; t < this.length; t++) {
		var r = this[t].json();
		e.push(r);
	}
	return e;
}, qM.clone = function() {
	for (var e = this.cy(), t = [], r = 0; r < this.length; r++) {
		var i = new $y(e, this[r].json(), !1);
		t.push(i);
	}
	return new qI(e, t);
}, qM.copy = qM.clone, qM.restore = function() {
	for (var e, t = !(arguments.length > 0) || void 0 === arguments[0] || arguments[0], r = !(arguments.length > 1) || void 0 === arguments[1] || arguments[1], i = this.cy(), n = i._private, a = [], s = [], o = 0, l = this.length; o < l; o++) {
		var u = this[o];
		r && !u.removed() || (u.isNode() ? a.push(u) : s.push(u));
	}
	e = a.concat(s);
	var d, p = h(function() {
		e.splice(d, 1), d--;
	}, "removeFromElements");
	for (d = 0; d < e.length; d++) {
		var f = e[d], g = f._private, m = g.data;
		if (f.clearTraversalCache(), !(!r && !g.removed)) {
			if (void 0 === m.id) m.id = $n();
			else if (DH(m.id)) m.id = "" + m.id;
			else if (D4(m.id) || !Dq(m.id)) {
				O8("Can not create element with invalid string ID `" + m.id + "`"), p();
				continue;
			} else if (i.hasElementWithId(m.id)) {
				O8("Can not create second element with ID `" + m.id + "`"), p();
				continue;
			}
		}
		var y = m.id;
		if (f.isNode()) {
			var v = g.position;
			v.x ??= 0, v.y ??= 0;
		}
		if (f.isEdge()) {
			for (var x = ["source", "target"], b = x.length, w = !1, k = 0; k < b; k++) {
				var T = x[k], _ = m[T];
				DH(_) && (_ = m[T] = "" + m[T]), null == _ || "" === _ ? (O8("Can not create edge `" + y + "` with unspecified " + T), w = !0) : i.hasElementWithId(_) || (O8("Can not create edge `" + y + "` with nonexistant " + T + " `" + _ + "`"), w = !0);
			}
			if (w) {
				p();
				continue;
			}
			var E = i.getElementById(m.source), C = i.getElementById(m.target);
			E.same(C) ? E._private.edges.push(f) : (E._private.edges.push(f), C._private.edges.push(f)), f._private.source = E, f._private.target = C;
		}
		g.map = new $f(), g.map.set(y, {
			ele: f,
			index: 0
		}), g.removed = !1, r && i.addToPool(f);
	}
	for (var S = 0; S < a.length; S++) {
		var A = a[S], L = A._private.data;
		DH(L.parent) && (L.parent = "" + L.parent);
		var R = L.parent;
		if (null != R || A._private.parent) {
			var N = A._private.parent ? i.collection().merge(A._private.parent) : i.getElementById(R);
			if (N.empty()) L.parent = void 0;
			else if (N[0].removed()) $e("Node added with missing parent, reference to parent removed"), L.parent = void 0, A._private.parent = null;
			else {
				for (var I = !1, M = N; !M.empty();) {
					if (A.same(M)) {
						I = !0, L.parent = void 0;
						break;
					}
					M = M.parent();
				}
				I || (N[0]._private.children.push(A), A._private.parent = N[0], n.hasCompoundNodes = !0);
			}
		}
	}
	if (e.length > 0) {
		for (var O = e.length === this.length ? this : new qI(i, e), $ = 0; $ < O.length; $++) {
			var P = O[$];
			P.isNode() || (P.parallelEdges().clearTraversalCache(), P.source().clearTraversalCache(), P.target().clearTraversalCache());
		}
		(n.hasCompoundNodes ? i.collection().merge(O).merge(O.connectedNodes()).merge(O.parent()) : O).dirtyCompoundBoundsCache().dirtyBoundingBoxCache().updateStyle(t), t ? O.emitAndNotify("add") : r && O.emit("add");
	}
	return this;
}, qM.removed = function() {
	var e = this[0];
	return e && e._private.removed;
}, qM.inside = function() {
	var e = this[0];
	return e && !e._private.removed;
}, qM.remove = function() {
	var e = !(arguments.length > 0) || void 0 === arguments[0] || arguments[0], t = !(arguments.length > 1) || void 0 === arguments[1] || arguments[1], r = [], i = {}, n = this._private.cy;
	function a(e) {
		for (var t = e._private.edges, r = 0; r < t.length; r++) o(t[r]);
	}
	function s(e) {
		for (var t = e._private.children, r = 0; r < t.length; r++) o(t[r]);
	}
	function o(e) {
		var n = i[e.id()];
		t && e.removed() || n || (i[e.id()] = !0, e.isNode() ? (r.push(e), a(e), s(e)) : r.unshift(e));
	}
	h(a, "addConnectedEdges"), h(s, "addChildren"), h(o, "add");
	for (var l = 0, u = this.length; l < u; l++) o(this[l]);
	function d(e, t) {
		$l(e._private.edges, t), e.clearTraversalCache();
	}
	function p(e) {
		e.clearTraversalCache();
	}
	h(d, "removeEdgeRef"), h(p, "removeParallelRef");
	var f = [];
	function g(e, t) {
		t = t[0];
		var r = (e = e[0])._private.children, i = e.id();
		$l(r, t), t._private.parent = null, f.ids[i] || (f.ids[i] = !0, f.push(e));
	}
	f.ids = {}, h(g, "removeChildRef"), this.dirtyCompoundBoundsCache(), t && n.removeFromPool(r);
	for (var m = 0; m < r.length; m++) {
		var y = r[m];
		if (y.isEdge()) {
			var v = y.source()[0], x = y.target()[0];
			d(v, y), d(x, y);
			for (var b = y.parallelEdges(), w = 0; w < b.length; w++) {
				var k = b[w];
				p(k), k.isBundledBezier() && k.dirtyBoundingBoxCache();
			}
		} else {
			var T = y.parent();
			0 !== T.length && g(T, y);
		}
		t && (y._private.removed = !0);
	}
	var _ = n._private.elements;
	n._private.hasCompoundNodes = !1;
	for (var E = 0; E < _.length; E++) if (_[E].isParent()) {
		n._private.hasCompoundNodes = !0;
		break;
	}
	var C = new qI(this.cy(), r);
	C.size() > 0 && (e ? C.emitAndNotify("remove") : t && C.emit("remove"));
	for (var S = 0; S < f.length; S++) {
		var A = f[S];
		t && A.removed() || A.updateStyle();
	}
	return C;
}, qM.move = function(e) {
	var t = this._private.cy, r = this, i = h(function(e) {
		return null == e ? e : "" + e;
	}, "toString");
	if (void 0 !== e.source || void 0 !== e.target) {
		var n = i(e.source), a = i(e.target), s = null != n && t.hasElementWithId(n), o = null != a && t.hasElementWithId(a);
		(s || o) && (t.batch(function() {
			r.remove(!1, !1), r.emitAndNotify("moveout");
			for (var e = 0; e < r.length; e++) {
				var t = r[e], i = t._private.data;
				t.isEdge() && (s && (i.source = n), o && (i.target = a));
			}
			r.restore(!1, !1);
		}), r.emitAndNotify("move"));
	} else if (void 0 !== e.parent) {
		var l = i(e.parent);
		if (null === l || t.hasElementWithId(l)) {
			var u = null === l ? void 0 : l;
			t.batch(function() {
				var e = r.remove(!1, !1);
				e.emitAndNotify("moveout");
				for (var t = 0; t < r.length; t++) {
					var i = r[t], n = i._private.data;
					i.isNode() && (n.parent = u);
				}
				e.restore(!1, !1);
			}), r.emitAndNotify("move");
		}
	}
	return this;
}, [
	Fc,
	UX,
	UK,
	Gh,
	Gd,
	Gk,
	G_,
	G4,
	ql,
	qc,
	qh,
	qd,
	qf,
	qv,
	qk,
	qE
].forEach(function(e) {
	Ou(qM, e);
});
var qD = {
	add: h(function(e) {
		var t;
		if (DZ(e)) if (e._private.cy === this) t = e.restore();
		else {
			for (var r = [], i = 0; i < e.length; i++) {
				var n = e[i];
				r.push(n.json());
			}
			t = new qI(this, r);
		}
		else if (DW(e)) t = new qI(this, e);
		else if (DY(e) && (DW(e.nodes) || DW(e.edges))) {
			for (var a = [], s = ["nodes", "edges"], o = 0, l = s.length; o < l; o++) {
				var h = s[o], u = e[h];
				if (DW(u)) for (var d = 0, p = u.length; d < p; d++) {
					var f = Ou({ group: h }, u[d]);
					a.push(f);
				}
			}
			t = new qI(this, a);
		} else t = new $y(this, e).collection();
		return t;
	}, "add"),
	remove: h(function(e) {
		if (!DZ(e) && Dq(e)) {
			var t = e;
			e = this.$(t);
		}
		return e.remove();
	}, "remove")
};
function qO(e, t, r, i) {
	var n = "u" > typeof Float32Array;
	if (4 != arguments.length) return !1;
	for (var a = 0; a < 4; ++a) if ("number" != typeof arguments[a] || isNaN(arguments[a]) || !isFinite(arguments[a])) return !1;
	e = Math.min(e, 1), r = Math.min(r, 1), e = Math.max(e, 0), r = Math.max(r, 0);
	var s = n ? new Float32Array(11) : Array(11);
	function o(e, t) {
		return 1 - 3 * t + 3 * e;
	}
	function l(e, t) {
		return 3 * t - 6 * e;
	}
	function u(e) {
		return 3 * e;
	}
	function d(e, t, r) {
		return ((o(t, r) * e + l(t, r)) * e + u(t)) * e;
	}
	function p(e, t, r) {
		return 3 * o(t, r) * e * e + 2 * l(t, r) * e + u(t);
	}
	function f(t, i) {
		for (var n = 0; n < 4; ++n) {
			var a = p(i, e, r);
			if (0 === a) break;
			var s = d(i, e, r) - t;
			i -= s / a;
		}
		return i;
	}
	function g() {
		for (var t = 0; t < 11; ++t) s[t] = d(.1 * t, e, r);
	}
	function m(t, i, n) {
		var a, s, o = 0;
		do
			(a = d(s = i + (n - i) / 2, e, r) - t) > 0 ? n = s : i = s;
		while (Math.abs(a) > 1e-7 && ++o < 10);
		return s;
	}
	function y(t) {
		for (var i = 0, n = 1; 10 !== n && s[n] <= t; ++n) i += .1;
		var a = i + (t - s[--n]) / (s[n + 1] - s[n]) * .1, o = p(a, e, r);
		return o >= .001 ? f(t, a) : 0 === o ? a : m(t, i, i + .1);
	}
	h(o, "A"), h(l, "B"), h(u, "C"), h(d, "calcBezier"), h(p, "getSlope"), h(f, "newtonRaphsonIterate"), h(g, "calcSampleValues"), h(m, "binarySubdivide"), h(y, "getTForX");
	var v = !1;
	function x() {
		v = !0, (e !== t || r !== i) && g();
	}
	h(x, "precompute");
	var b = h(function(n) {
		return v || x(), e === t && r === i ? n : 0 === n ? 0 : 1 === n ? 1 : d(y(n), t, i);
	}, "f");
	b.getControlPoints = function() {
		return [{
			x: e,
			y: t
		}, {
			x: r,
			y: i
		}];
	};
	var w = "generateBezier(" + [
		e,
		t,
		r,
		i
	] + ")";
	return b.toString = function() {
		return w;
	}, b;
}
h(qO, "generateCubicBezier");
var q$ = function() {
	function e(e) {
		return -e.tension * e.x - e.friction * e.v;
	}
	function t(t, r, i) {
		var n = {
			x: t.x + i.dx * r,
			v: t.v + i.dv * r,
			tension: t.tension,
			friction: t.friction
		};
		return {
			dx: n.v,
			dv: e(n)
		};
	}
	function r(r, i) {
		var n = {
			dx: r.v,
			dv: e(r)
		}, a = t(r, .5 * i, n), s = t(r, .5 * i, a), o = t(r, i, s), l = 1 / 6 * (n.dx + 2 * (a.dx + s.dx) + o.dx), h = 1 / 6 * (n.dv + 2 * (a.dv + s.dv) + o.dv);
		return r.x = r.x + l * i, r.v = r.v + h * i, r;
	}
	return h(e, "springAccelerationForState"), h(t, "springEvaluateStateWithDerivative"), h(r, "springIntegrateState"), h(function e(t, i, n) {
		var a, s, o, l = {
			x: -1,
			v: 0,
			tension: null,
			friction: null
		}, h = [0], u = 0, d = 1 / 1e4;
		for (t = parseFloat(t) || 500, i = parseFloat(i) || 20, n = n || null, l.tension = t, l.friction = i, s = (a = null !== n) ? (u = e(t, i)) / n * .016 : .016; o = r(o || l, s), h.push(1 + o.x), u += 16, Math.abs(o.x) > d && Math.abs(o.v) > d;);
		return a ? function(e) {
			return h[e * (h.length - 1) | 0];
		} : u;
	}, "springRK4Factory");
}(), qP = h(function(e, t, r, i) {
	var n = qO(e, t, r, i);
	return function(e, t, r) {
		return e + (t - e) * n(r);
	};
}, "cubicBezier"), qB = {
	linear: h(function(e, t, r) {
		return e + (t - e) * r;
	}, "linear"),
	ease: qP(.25, .1, .25, 1),
	"ease-in": qP(.42, 0, 1, 1),
	"ease-out": qP(0, 0, .58, 1),
	"ease-in-out": qP(.42, 0, .58, 1),
	"ease-in-sine": qP(.47, 0, .745, .715),
	"ease-out-sine": qP(.39, .575, .565, 1),
	"ease-in-out-sine": qP(.445, .05, .55, .95),
	"ease-in-quad": qP(.55, .085, .68, .53),
	"ease-out-quad": qP(.25, .46, .45, .94),
	"ease-in-out-quad": qP(.455, .03, .515, .955),
	"ease-in-cubic": qP(.55, .055, .675, .19),
	"ease-out-cubic": qP(.215, .61, .355, 1),
	"ease-in-out-cubic": qP(.645, .045, .355, 1),
	"ease-in-quart": qP(.895, .03, .685, .22),
	"ease-out-quart": qP(.165, .84, .44, 1),
	"ease-in-out-quart": qP(.77, 0, .175, 1),
	"ease-in-quint": qP(.755, .05, .855, .06),
	"ease-out-quint": qP(.23, 1, .32, 1),
	"ease-in-out-quint": qP(.86, 0, .07, 1),
	"ease-in-expo": qP(.95, .05, .795, .035),
	"ease-out-expo": qP(.19, 1, .22, 1),
	"ease-in-out-expo": qP(1, 0, 0, 1),
	"ease-in-circ": qP(.6, .04, .98, .335),
	"ease-out-circ": qP(.075, .82, .165, 1),
	"ease-in-out-circ": qP(.785, .135, .15, .86),
	spring: h(function(e, t, r) {
		if (0 === r) return qB.linear;
		var i = q$(e, t, r);
		return function(e, t, r) {
			return e + (t - e) * i(r);
		};
	}, "spring"),
	"cubic-bezier": qP
};
function qF(e, t, r, i, n) {
	if (1 === i || t === r) return r;
	var a = n(t, r, i);
	return null == e || ((e.roundValue || e.color) && (a = Math.round(a)), void 0 !== e.min && (a = Math.max(a, e.min)), void 0 !== e.max && (a = Math.min(a, e.max))), a;
}
function qz(e, t) {
	return null != e.pfValue || null != e.value ? null != e.pfValue && (null == t || "%" !== t.type.units) ? e.pfValue : e.value : e;
}
function qU(e, t, r, i, n) {
	var a = null != n ? n.type : null;
	r < 0 ? r = 0 : r > 1 && (r = 1);
	var s = qz(e, n), o = qz(t, n);
	if (DH(s) && DH(o)) return qF(a, s, o, r, i);
	if (DW(s) && DW(o)) {
		for (var l = [], h = 0; h < o.length; h++) {
			var u = s[h], d = o[h];
			if (null != u && null != d) {
				var p = qF(a, u, d, r, i);
				l.push(p);
			} else l.push(d);
		}
		return l;
	}
}
function qG(e, t, r, i) {
	var n = !i, a = e._private, s = t._private, o = s.easing, l = s.startTime, h = (i ? e : e.cy()).style();
	s.easingImpl || (null == o ? s.easingImpl = qB.linear : (u = Dq(o) ? h.parse("transition-timing-function", o).value : o, Dq(u) ? (d = u, p = []) : (d = u[1], p = u.slice(2).map(function(e) {
		return +e;
	})), p.length > 0 ? ("spring" === d && p.push(s.duration), s.easingImpl = qB[d].apply(null, p)) : s.easingImpl = qB[d]));
	var u, d, p, f, g = s.easingImpl;
	if (f = 0 === s.duration ? 1 : (r - l) / s.duration, s.applying && (f = s.progress), f < 0 ? f = 0 : f > 1 && (f = 1), null == s.delay) {
		var m = s.startPosition, y = s.position;
		if (y && n && !e.locked()) {
			var v = {};
			qq(m.x, y.x) && (v.x = qU(m.x, y.x, f, g)), qq(m.y, y.y) && (v.y = qU(m.y, y.y, f, g)), e.position(v);
		}
		var x = s.startPan, b = s.pan, w = a.pan, k = null != b && i;
		k && (qq(x.x, b.x) && (w.x = qU(x.x, b.x, f, g)), qq(x.y, b.y) && (w.y = qU(x.y, b.y, f, g)), e.emit("pan"));
		var T = s.startZoom, _ = s.zoom, E = null != _ && i;
		E && (qq(T, _) && (a.zoom = P_(a.minZoom, qU(T, _, f, g), a.maxZoom)), e.emit("zoom")), (k || E) && e.emit("viewport");
		var C = s.style;
		if (C && C.length > 0 && n) {
			for (var S = 0; S < C.length; S++) {
				var A = C[S], L = A.name, R = s.startStyle[L], N = h.properties[R.name], I = qU(R, A, f, g, N);
				h.overrideBypass(e, L, I);
			}
			e.emit("style");
		}
	}
	return s.progress = f, f;
}
function qq(e, t) {
	return null != e && null != t && (!!(DH(e) && DH(t)) || !!(e && t));
}
function qj(e, t, r, i) {
	var n = t._private;
	n.started = !0, n.startTime = r - n.progress * n.duration;
}
function qW(e, t) {
	var r = t._private.aniEles, i = [];
	function n(t, r) {
		var n = t._private, a = n.animation.current, s = n.animation.queue, o = !1;
		if (0 === a.length) {
			var l = s.shift();
			l && a.push(l);
		}
		for (var u = h(function(e) {
			for (var t = e.length - 1; t >= 0; t--) (0, e[t])();
			e.splice(0, e.length);
		}, "callbacks"), d = a.length - 1; d >= 0; d--) {
			var p = a[d], f = p._private;
			if (f.stopped) {
				a.splice(d, 1), f.hooked = !1, f.playing = !1, f.started = !1, u(f.frames);
				continue;
			}
			(f.playing || f.applying) && (f.playing && f.applying && (f.applying = !1), f.started || qj(t, p, e), qG(t, p, e, r), f.applying && (f.applying = !1), u(f.frames), null != f.step && f.step(e), p.completed() && (a.splice(d, 1), f.hooked = !1, f.playing = !1, f.started = !1, u(f.completes)), o = !0);
		}
		return r || 0 !== a.length || 0 !== s.length || i.push(t), o;
	}
	h(n, "stepOne");
	for (var a = !1, s = 0; s < r.length; s++) {
		var o = n(r[s]);
		a = a || o;
	}
	var l = n(t, !0);
	(a || l) && (r.length > 0 ? t.notify("draw", r) : t.notify("draw")), r.unmerge(i), t.emit("step");
}
h(qF, "getEasedValue"), h(qz, "getValue"), h(qU, "ease"), h(qG, "step$1"), h(qq, "valid"), h(qj, "startAnimation"), h(qW, "stepAll");
var qY = {
	animate: UH.animate(),
	animation: UH.animation(),
	animated: UH.animated(),
	clearQueue: UH.clearQueue(),
	delay: UH.delay(),
	delayAnimation: UH.delayAnimation(),
	stop: UH.stop(),
	addToAnimationPool: h(function(e) {
		this.styleEnabled() && this._private.aniEles.merge(e);
	}, "addToAnimationPool"),
	stopAnimationLoop: h(function() {
		this._private.animationsRunning = !1;
	}, "stopAnimationLoop"),
	startAnimationLoop: h(function() {
		var e = this;
		if (e._private.animationsRunning = !0, e.styleEnabled()) {
			h(r, "headlessStep");
			var t = e.renderer();
			t && t.beforeRender ? t.beforeRender(h(function(t, r) {
				qW(r, e);
			}, "rendererAnimationStep"), t.beforeRenderPriorities.animations) : r();
		}
		function r() {
			e._private.animationsRunning && Oz(h(function(t) {
				qW(t, e), r();
			}, "animationStep"));
		}
	}, "startAnimationLoop")
}, qV = {
	qualifierCompare: h(function(e, t) {
		return null == e || null == t ? null == e && null == t : e.sameText(t);
	}, "qualifierCompare"),
	eventMatches: h(function(e, t, r) {
		var i = t.qualifier;
		return null == i || e !== r.target && DQ(r.target) && i.matches(r.target);
	}, "eventMatches"),
	addEventFields: h(function(e, t) {
		t.cy = e, t.target = e;
	}, "addEventFields"),
	callbackContext: h(function(e, t, r) {
		return null != t.qualifier ? r.target : e;
	}, "callbackContext")
}, qH = h(function(e) {
	return Dq(e) ? new Gl(e) : e;
}, "argSelector"), qX = {
	createEmitter: h(function() {
		var e = this._private;
		return e.emitter || (e.emitter = new qt(qV, this)), this;
	}, "createEmitter"),
	emitter: h(function() {
		return this._private.emitter;
	}, "emitter"),
	on: h(function(e, t, r) {
		return this.emitter().on(e, qH(t), r), this;
	}, "on"),
	removeListener: h(function(e, t, r) {
		return this.emitter().removeListener(e, qH(t), r), this;
	}, "removeListener"),
	removeAllListeners: h(function() {
		return this.emitter().removeAllListeners(), this;
	}, "removeAllListeners"),
	one: h(function(e, t, r) {
		return this.emitter().one(e, qH(t), r), this;
	}, "one"),
	once: h(function(e, t, r) {
		return this.emitter().one(e, qH(t), r), this;
	}, "once"),
	emit: h(function(e, t) {
		return this.emitter().emit(e, t), this;
	}, "emit"),
	emitAndNotify: h(function(e, t) {
		return this.emit(e), this.notify(e, t), this;
	}, "emitAndNotify")
};
UH.eventAliasesOn(qX);
var qK = {
	png: h(function(e) {
		return e = e || {}, this._private.renderer.png(e);
	}, "png"),
	jpg: h(function(e) {
		var t = this._private.renderer;
		return (e = e || {}).bg = e.bg || "#fff", t.jpg(e);
	}, "jpg")
};
qK.jpeg = qK.jpg;
var qZ = { layout: h(function(e) {
	if (null == e) return void O8("Layout options must be specified to make a layout");
	if (null == e.name) return void O8("A `name` must be specified to make a layout");
	var t, r = e.name, i = this.extension("layout", r);
	return null == i ? void O8("No such layout `" + r + "` found.  Did you forget to import it and `cytoscape.use()` it?") : (t = Dq(e.eles) ? this.$(e.eles) : null != e.eles ? e.eles : this.$(), new i(Ou({}, e, {
		cy: this,
		eles: t
	})));
}, "layout") };
qZ.createLayout = qZ.makeLayout = qZ.layout;
var qQ = {
	notify: h(function(e, t) {
		var r = this._private;
		if (this.batching()) {
			r.batchNotifications = r.batchNotifications || {};
			var i = r.batchNotifications[e] = r.batchNotifications[e] || this.collection();
			null != t && i.merge(t);
			return;
		}
		if (r.notificationsEnabled) {
			var n = this.renderer();
			this.destroyed() || !n || n.notify(e, t);
		}
	}, "notify"),
	notifications: h(function(e) {
		var t = this._private;
		return void 0 === e ? t.notificationsEnabled : (t.notificationsEnabled = !!e, this);
	}, "notifications"),
	noNotifications: h(function(e) {
		this.notifications(!1), e(), this.notifications(!0);
	}, "noNotifications"),
	batching: h(function() {
		return this._private.batchCount > 0;
	}, "batching"),
	startBatch: h(function() {
		var e = this._private;
		return e.batchCount ??= 0, 0 === e.batchCount && (e.batchStyleEles = this.collection(), e.batchNotifications = {}), e.batchCount++, this;
	}, "startBatch"),
	endBatch: h(function() {
		var e = this._private;
		if (0 === e.batchCount) return this;
		if (e.batchCount--, 0 === e.batchCount) {
			e.batchStyleEles.updateStyle();
			var t = this.renderer();
			Object.keys(e.batchNotifications).forEach(function(r) {
				var i = e.batchNotifications[r];
				i.empty() ? t.notify(r) : t.notify(r, i);
			});
		}
		return this;
	}, "endBatch"),
	batch: h(function(e) {
		return this.startBatch(), e(), this.endBatch(), this;
	}, "batch"),
	batchData: h(function(e) {
		var t = this;
		return this.batch(function() {
			for (var r = Object.keys(e), i = 0; i < r.length; i++) {
				var n = r[i], a = e[n];
				t.getElementById(n).data(a);
			}
		});
	}, "batchData")
}, qJ = $o({
	hideEdgesOnViewport: !1,
	textureOnViewport: !1,
	motionBlur: !1,
	motionBlurOpacity: .05,
	pixelRatio: void 0,
	desktopTapThreshold: 4,
	touchTapThreshold: 8,
	wheelSensitivity: 1,
	debug: !1,
	showFps: !1,
	webgl: !1,
	webglDebug: !1,
	webglDebugShowAtlases: !1,
	webglTexSize: 2048,
	webglTexRows: 36,
	webglTexRowsNodes: 18,
	webglBatchSize: 2048,
	webglTexPerBatch: 14,
	webglBgColor: [
		255,
		255,
		255
	]
}), q0 = {
	renderTo: h(function(e, t, r, i) {
		return this._private.renderer.renderTo(e, t, r, i), this;
	}, "renderTo"),
	renderer: h(function() {
		return this._private.renderer;
	}, "renderer"),
	forceRender: h(function() {
		return this.notify("draw"), this;
	}, "forceRender"),
	resize: h(function() {
		return this.invalidateSize(), this.emitAndNotify("resize"), this;
	}, "resize"),
	initRenderer: h(function(e) {
		var t = this.extension("renderer", e.name);
		if (null == t) return void O8("Can not initialise: No such renderer `".concat(e.name, "` found. Did you forget to import it and `cytoscape.use()` it?"));
		void 0 !== e.wheelSensitivity && $e("You have set a custom wheel sensitivity.  This will make your app zoom unnaturally when using mainstream mice.  You should change this value from the default only if you can guarantee that all your users will use the same hardware and OS configuration as your current machine.");
		var r = qJ(e);
		r.cy = this, this._private.renderer = new t(r), this.notify("init");
	}, "initRenderer"),
	destroyRenderer: h(function() {
		this.notify("destroy");
		var e = this.container();
		if (e) for (e._cyreg = null; e.childNodes.length > 0;) e.removeChild(e.childNodes[0]);
		this._private.renderer = null, this.mutableElements().forEach(function(e) {
			var t = e._private;
			t.rscratch = {}, t.rstyle = {}, t.animation.current = [], t.animation.queue = [];
		});
	}, "destroyRenderer"),
	onRender: h(function(e) {
		return this.on("render", e);
	}, "onRender"),
	offRender: h(function(e) {
		return this.off("render", e);
	}, "offRender")
};
q0.invalidateDimensions = q0.resize;
var q1 = {
	collection: h(function(e, t) {
		return Dq(e) ? this.$(e) : DZ(e) ? e.collection() : DW(e) ? (t || (t = {}), new qI(this, e, t.unique, t.removed)) : new qI(this);
	}, "collection"),
	nodes: h(function(e) {
		var t = this.$(function(e) {
			return e.isNode();
		});
		return e ? t.filter(e) : t;
	}, "nodes"),
	edges: h(function(e) {
		var t = this.$(function(e) {
			return e.isEdge();
		});
		return e ? t.filter(e) : t;
	}, "edges"),
	$: h(function(e) {
		var t = this._private.elements;
		return e ? t.filter(e) : t.spawnSelf();
	}, "$"),
	mutableElements: h(function() {
		return this._private.elements;
	}, "mutableElements")
};
q1.elements = q1.filter = q1.$;
var q2 = {};
q2.apply = function(e) {
	for (var t = this._private.cy.collection(), r = 0; r < e.length; r++) {
		var i = e[r], n = this.getContextMeta(i);
		if (!n.empty) {
			var a = this.getContextStyle(n), s = this.applyContextStyle(n, a, i);
			i._private.appliedInitStyle ? this.updateTransitions(i, s.diffProps) : i._private.appliedInitStyle = !0, this.updateStyleHints(i) && t.push(i);
		}
	}
	return t;
}, q2.getPropertiesDiff = function(e, t) {
	var r = this._private.propDiffs = this._private.propDiffs || {}, i = e + "-" + t, n = r[i];
	if (n) return n;
	for (var a = [], s = {}, o = 0; o < this.length; o++) {
		var l = this[o], h = "t" === e[o], u = "t" === t[o], d = h !== u, p = l.mappedProperties.length > 0;
		if (d || u && p) {
			var f = void 0;
			d && p || d ? f = l.properties : p && (f = l.mappedProperties);
			for (var g = 0; g < f.length; g++) {
				for (var m = f[g], y = m.name, v = !1, x = o + 1; x < this.length; x++) {
					var b = this[x];
					if ("t" === t[x] && (v = null != b.properties[m.name])) break;
				}
				s[y] || v || (s[y] = !0, a.push(y));
			}
		}
	}
	return r[i] = a, a;
}, q2.getContextMeta = function(e) {
	for (var t, r = "", i = e._private.styleCxtKey || "", n = 0; n < this.length; n++) {
		var a = this[n];
		a.selector && a.selector.matches(e) ? r += "t" : r += "f";
	}
	return t = this.getPropertiesDiff(i, r), e._private.styleCxtKey = r, {
		key: r,
		diffPropNames: t,
		empty: 0 === t.length
	};
}, q2.getContextStyle = function(e) {
	var t = e.key, r = this._private.contextStyles = this._private.contextStyles || {};
	if (r[t]) return r[t];
	for (var i = { _private: { key: t } }, n = 0; n < this.length; n++) {
		var a = this[n];
		if ("t" === t[n]) for (var s = 0; s < a.properties.length; s++) {
			var o = a.properties[s];
			i[o.name] = o;
		}
	}
	return r[t] = i, i;
}, q2.applyContextStyle = function(e, t, r) {
	for (var i = e.diffPropNames, n = {}, a = this.types, s = 0; s < i.length; s++) {
		var o = i[s], l = t[o], h = r.pstyle(o);
		if (!l) if (!h) continue;
		else l = h.bypass ? {
			name: o,
			deleteBypassed: !0
		} : {
			name: o,
			delete: !0
		};
		if (h !== l) {
			if (l.mapped === a.fn && null != h && null != h.mapping && h.mapping.value === l.value) {
				var u = h.mapping;
				if ((u.fnValue = l.value(r)) === u.prevFnValue) continue;
			}
			var d = n[o] = { prev: h };
			this.applyParsedProperty(r, l), d.next = r.pstyle(o), d.next && d.next.bypass && (d.next = d.next.bypassed);
		}
	}
	return { diffProps: n };
}, q2.updateStyleHints = function(e) {
	var t = e._private, r = this, i = r.propertyGroupNames, n = r.propertyGroupKeys, a = h(function(e, t, i) {
		return r.getPropertiesHash(e, t, i);
	}, "propHash"), s = t.styleKey;
	if (e.removed()) return !1;
	var o = "nodes" === t.group, l = e._private.style;
	i = Object.keys(l);
	for (var u = 0; u < n.length; u++) {
		var d = n[u];
		t.styleKeys[d] = [9261, 5381];
	}
	for (var p = h(function(e, r) {
		return t.styleKeys[r][0] = OG(e, t.styleKeys[r][0]);
	}, "updateGrKey1"), f = h(function(e, r) {
		return t.styleKeys[r][1] = Oq(e, t.styleKeys[r][1]);
	}, "updateGrKey2"), g = h(function(e, t) {
		p(e, t), f(e, t);
	}, "updateGrKey"), m = h(function(e, t) {
		for (var r = 0; r < e.length; r++) {
			var i = e.charCodeAt(r);
			p(i, t), f(i, t);
		}
	}, "updateGrKeyWStr"), y = h(function(e) {
		return -128 < e && e < 128 && Math.floor(e) !== e ? 2e9 - (1024 * e | 0) : e;
	}, "cleanNum"), v = 0; v < i.length; v++) {
		var x = i[v], b = l[x];
		if (null != b) {
			var w = this.properties[x], k = w.type, T = w.groupKey, _ = void 0;
			null != w.hashOverride ? _ = w.hashOverride(e, b) : null != b.pfValue && (_ = b.pfValue);
			var E = null == w.enums ? b.value : null, C = null != _, S = C || null != E, A = b.units;
			k.number && S && !k.multiple ? (g(y(C ? _ : E), T), C || null == A || m(A, T)) : m(b.strValue, T);
		}
	}
	for (var L = [9261, 5381], R = 0; R < n.length; R++) {
		var N = n[R], I = t.styleKeys[N];
		L[0] = OG(I[0], L[0]), L[1] = Oq(I[1], L[1]);
	}
	t.styleKey = Oj(L[0], L[1]);
	var M = t.styleKeys;
	t.labelDimsKey = OW(M.labelDimensions);
	var D = a(e, ["label"], M.labelDimensions);
	if (t.labelKey = OW(D), t.labelStyleKey = OW(OY(M.commonLabel, D)), !o) {
		var O = a(e, ["source-label"], M.labelDimensions);
		t.sourceLabelKey = OW(O), t.sourceLabelStyleKey = OW(OY(M.commonLabel, O));
		var $ = a(e, ["target-label"], M.labelDimensions);
		t.targetLabelKey = OW($), t.targetLabelStyleKey = OW(OY(M.commonLabel, $));
	}
	if (o) {
		var P = t.styleKeys, B = P.nodeBody, F = P.nodeBorder, z = P.nodeOutline, U = P.backgroundImage, G = P.compound, q = P.pie, j = P.stripe;
		t.nodeKey = OW([
			B,
			F,
			z,
			U,
			G,
			q,
			j
		].filter(function(e) {
			return null != e;
		}).reduce(OY, [9261, 5381])), t.hasPie = null != q && 9261 !== q[0] && 5381 !== q[1], t.hasStripe = null != j && 9261 !== j[0] && 5381 !== j[1];
	}
	return s !== t.styleKey;
}, q2.clearStyleHints = function(e) {
	var t = e._private;
	t.styleCxtKey = "", t.styleKeys = {}, t.styleKey = null, t.labelKey = null, t.labelStyleKey = null, t.sourceLabelKey = null, t.sourceLabelStyleKey = null, t.targetLabelKey = null, t.targetLabelStyleKey = null, t.nodeKey = null, t.hasPie = null, t.hasStripe = null;
}, q2.applyParsedProperty = function(e, t) {
	var r, i = this, n = t, a = e._private.style, s = i.types, o = i.properties[n.name].type, l = n.bypass, u = a[n.name], d = u && u.bypass, p = e._private, f = "mapping", g = h(function(e) {
		return null == e ? null : null != e.pfValue ? e.pfValue : e.value;
	}, "getVal"), m = h(function() {
		var t = g(u), r = g(n);
		i.checkTriggers(e, n.name, t, r);
	}, "checkTriggers");
	if ("curve-style" === t.name && e.isEdge() && ("bezier" !== t.value && e.isLoop() || "haystack" === t.value && (e.source().isParent() || e.target().isParent())) && (n = t = this.parse(t.name, "bezier", l)), n.delete) return a[n.name] = void 0, m(), !0;
	if (n.deleteBypassed) return u ? !!u.bypass && (u.bypassed = void 0, m(), !0) : (m(), !0);
	if (n.deleteBypass) return u ? !!u.bypass && (a[n.name] = u.bypassed, m(), !0) : (m(), !0);
	var y = h(function() {
		$e("Do not assign mappings to elements without corresponding data (i.e. ele `" + e.id() + "` has no mapping for property `" + n.name + "` with data field `" + n.field + "`); try a `[" + n.field + "]` selector to limit scope to elements with `" + n.field + "` defined");
	}, "printMappingErr");
	switch (n.mapped) {
		case s.mapData:
			for (var v, x = n.field.split("."), b = p.data, w = 0; w < x.length && b; w++) b = b[x[w]];
			if (null == b) return y(), !1;
			if (!DH(b)) return $e("Do not use continuous mappers without specifying numeric data (i.e. `" + n.field + ": " + b + "` for `" + e.id() + "` is non-numeric)"), !1;
			var k = n.fieldMax - n.fieldMin;
			if ((v = 0 === k ? 0 : (b - n.fieldMin) / k) < 0 ? v = 0 : v > 1 && (v = 1), o.color) {
				var T = n.valueMin[0], _ = n.valueMax[0], E = n.valueMin[1], C = n.valueMax[1], S = n.valueMin[2], A = n.valueMax[2], L = null == n.valueMin[3] ? 1 : n.valueMin[3], R = [
					Math.round(T + (_ - T) * v),
					Math.round(E + (C - E) * v),
					Math.round(S + (A - S) * v),
					Math.round(L + ((null == n.valueMax[3] ? 1 : n.valueMax[3]) - L) * v)
				];
				r = {
					bypass: n.bypass,
					name: n.name,
					value: R,
					strValue: "rgb(" + R[0] + ", " + R[1] + ", " + R[2] + ")"
				};
			} else {
				if (!o.number) return !1;
				var N = n.valueMin + (n.valueMax - n.valueMin) * v;
				r = this.parse(n.name, N, n.bypass, f);
			}
			if (!r) return y(), !1;
			r.mapping = n, n = r;
			break;
		case s.data:
			for (var I = n.field.split("."), M = p.data, D = 0; D < I.length && M; D++) M = M[I[D]];
			if (null != M && (r = this.parse(n.name, M, n.bypass, f)), !r) return y(), !1;
			r.mapping = n, n = r;
			break;
		case s.fn:
			var O = n.value, $ = null != n.fnValue ? n.fnValue : O(e);
			if (n.prevFnValue = $, null == $) return $e("Custom function mappers may not return null (i.e. `" + n.name + "` for ele `" + e.id() + "` is null)"), !1;
			if (!(r = this.parse(n.name, $, n.bypass, f))) return $e("Custom function mappers may not return invalid values for the property type (i.e. `" + n.name + "` for ele `" + e.id() + "` is invalid)"), !1;
			r.mapping = $r(n), n = r;
			break;
		case void 0: break;
		default: return !1;
	}
	return l ? (d ? n.bypassed = u.bypassed : n.bypassed = u, a[n.name] = n) : d ? u.bypassed = n : a[n.name] = n, m(), !0;
}, q2.cleanElements = function(e, t) {
	for (var r = 0; r < e.length; r++) {
		var i = e[r];
		if (this.clearStyleHints(i), i.dirtyCompoundBoundsCache(), i.dirtyBoundingBoxCache(), t) for (var n = i._private.style, a = Object.keys(n), s = 0; s < a.length; s++) {
			var o = a[s], l = n[o];
			null != l && (l.bypass ? l.bypassed = null : n[o] = null);
		}
		else i._private.style = {};
	}
}, q2.update = function() {
	this._private.cy.mutableElements().updateStyle();
}, q2.updateTransitions = function(e, t) {
	var r = this, i = e._private, n = e.pstyle("transition-property").value, a = e.pstyle("transition-duration").pfValue, s = e.pstyle("transition-delay").pfValue;
	if (n.length > 0 && a > 0) {
		for (var o = {}, l = !1, h = 0; h < n.length; h++) {
			var u = n[h], d = e.pstyle(u), p = t[u];
			if (p) {
				var f = p.prev, g = null != p.next ? p.next : d, m = !1, y = void 0;
				f && (DH(f.pfValue) && DH(g.pfValue) ? (m = g.pfValue - f.pfValue, y = f.pfValue + 1e-6 * m) : DH(f.value) && DH(g.value) ? (m = g.value - f.value, y = f.value + 1e-6 * m) : DW(f.value) && DW(g.value) && (m = f.value[0] !== g.value[0] || f.value[1] !== g.value[1] || f.value[2] !== g.value[2], y = f.strValue), m && (o[u] = g.strValue, this.applyBypass(e, u, y), l = !0));
			}
		}
		if (!l) return;
		i.transitioning = !0, new Fm(function(t) {
			s > 0 ? e.delayAnimation(s).play().promise().then(t) : t();
		}).then(function() {
			return e.animation({
				style: o,
				duration: a,
				easing: e.pstyle("transition-timing-function").value,
				queue: !1
			}).play().promise();
		}).then(function() {
			r.removeBypasses(e, n), e.emitAndNotify("style"), i.transitioning = !1;
		});
	} else i.transitioning && (this.removeBypasses(e, n), e.emitAndNotify("style"), i.transitioning = !1);
}, q2.checkTrigger = function(e, t, r, i, n, a) {
	var s = this.properties[t], o = n(s);
	e.removed() || null != o && o(r, i, e) && a(s);
}, q2.checkZOrderTrigger = function(e, t, r, i) {
	var n = this;
	this.checkTrigger(e, t, r, i, function(e) {
		return e.triggersZOrder;
	}, function() {
		n._private.cy.notify("zorder", e);
	});
}, q2.checkBoundsTrigger = function(e, t, r, i) {
	this.checkTrigger(e, t, r, i, function(e) {
		return e.triggersBounds;
	}, function(t) {
		e.dirtyCompoundBoundsCache(), e.dirtyBoundingBoxCache();
	});
}, q2.checkConnectedEdgesBoundsTrigger = function(e, t, r, i) {
	this.checkTrigger(e, t, r, i, function(e) {
		return e.triggersBoundsOfConnectedEdges;
	}, function(t) {
		e.connectedEdges().forEach(function(e) {
			e.dirtyBoundingBoxCache();
		});
	});
}, q2.checkParallelEdgesBoundsTrigger = function(e, t, r, i) {
	this.checkTrigger(e, t, r, i, function(e) {
		return e.triggersBoundsOfParallelEdges;
	}, function(t) {
		e.parallelEdges().forEach(function(e) {
			e.dirtyBoundingBoxCache();
		});
	});
}, q2.checkTriggers = function(e, t, r, i) {
	e.dirtyStyleCache(), this.checkZOrderTrigger(e, t, r, i), this.checkBoundsTrigger(e, t, r, i), this.checkConnectedEdgesBoundsTrigger(e, t, r, i), this.checkParallelEdgesBoundsTrigger(e, t, r, i);
};
var q4 = {};
q4.applyBypass = function(e, t, r, i) {
	var n = [];
	if ("*" === t || "**" === t) {
		if (void 0 !== r) for (var a = 0; a < this.properties.length; a++) {
			var s = this.properties[a].name, o = this.parse(s, r, !0);
			o && n.push(o);
		}
	} else if (Dq(t)) {
		var l = this.parse(t, r, !0);
		l && n.push(l);
	} else {
		if (!DY(t)) return !1;
		i = r;
		for (var h = Object.keys(t), u = 0; u < h.length; u++) {
			var d = h[u], p = t[d];
			if (void 0 === p && (p = t[Oe(d)]), void 0 !== p) {
				var f = this.parse(d, p, !0);
				f && n.push(f);
			}
		}
	}
	if (0 === n.length) return !1;
	for (var g = !1, m = 0; m < e.length; m++) {
		for (var y = e[m], v = {}, x = void 0, b = 0; b < n.length; b++) {
			var w = n[b];
			if (i) {
				var k = y.pstyle(w.name);
				x = v[w.name] = { prev: k };
			}
			g = this.applyParsedProperty(y, $r(w)) || g, i && (x.next = y.pstyle(w.name));
		}
		g && this.updateStyleHints(y), i && this.updateTransitions(y, v, !0);
	}
	return g;
}, q4.overrideBypass = function(e, t, r) {
	t = D9(t);
	for (var i = 0; i < e.length; i++) {
		var n = e[i], a = n._private.style[t], s = this.properties[t].type, o = s.color, l = s.mutiple, h = a ? null != a.pfValue ? a.pfValue : a.value : null;
		a && a.bypass ? (a.value = r, null != a.pfValue && (a.pfValue = r), o ? a.strValue = "rgb(" + r.join(",") + ")" : l ? a.strValue = r.join(" ") : a.strValue = "" + r, this.updateStyleHints(n)) : this.applyBypass(n, t, r), this.checkTriggers(n, t, h, r);
	}
}, q4.removeAllBypasses = function(e, t) {
	return this.removeBypasses(e, this.propertyNames, t);
}, q4.removeBypasses = function(e, t, r) {
	for (var i = 0; i < e.length; i++) {
		for (var n = e[i], a = {}, s = 0; s < t.length; s++) {
			var o = t[s], l = this.properties[o], h = n.pstyle(l.name);
			if (!(!h || !h.bypass)) {
				var u = this.parse(o, "", !0), d = a[l.name] = { prev: h };
				this.applyParsedProperty(n, u), d.next = n.pstyle(l.name);
			}
		}
		this.updateStyleHints(n), r && this.updateTransitions(n, a, !0);
	}
};
var q5 = {};
q5.getEmSizeInPixels = function() {
	var e = this.containerCss("font-size");
	return null != e ? parseFloat(e) : 1;
}, q5.containerCss = function(e) {
	var t = this._private.cy, r = t.container(), i = t.window();
	if (i && r && i.getComputedStyle) return i.getComputedStyle(r).getPropertyValue(e);
};
var q3 = {};
q3.getRenderedStyle = function(e, t) {
	return t ? this.getStylePropertyValue(e, t, !0) : this.getRawStyle(e, !0);
}, q3.getRawStyle = function(e, t) {
	if (e = e[0]) {
		for (var r = {}, i = 0; i < this.properties.length; i++) {
			var n = this.properties[i], a = this.getStylePropertyValue(e, n.name, t);
			null != a && (r[n.name] = a, r[Oe(n.name)] = a);
		}
		return r;
	}
}, q3.getIndexedStyle = function(e, t, r, i) {
	return e.pstyle(t)[r][i] ?? e.cy().style().getDefaultProperty(t)[r][0];
}, q3.getStylePropertyValue = function(e, t, r) {
	if (e = e[0]) {
		var i = this.properties[t];
		i.alias && (i = i.pointsTo);
		var n = i.type, a = e.pstyle(i.name);
		if (a) {
			var s = a.value, o = a.units, l = a.strValue;
			if (r && n.number && null != s && DH(s)) {
				var u = e.cy().zoom(), d = h(function(e) {
					return e * u;
				}, "getRenderedValue"), p = h(function(e, t) {
					return d(e) + t;
				}, "getValueStringWithUnits"), f = DW(s);
				return (f ? o.every(function(e) {
					return null != e;
				}) : null != o) ? f ? s.map(function(e, t) {
					return p(e, o[t]);
				}).join(" ") : p(s, o) : f ? s.map(function(e) {
					return Dq(e) ? e : "" + d(e);
				}).join(" ") : "" + d(s);
			}
			if (null != l) return l;
		}
		return null;
	}
}, q3.getAnimationStartStyle = function(e, t) {
	for (var r = {}, i = 0; i < t.length; i++) {
		var n = t[i].name, a = e.pstyle(n);
		void 0 !== a && (a = DY(a) ? this.parse(n, a.strValue) : this.parse(n, a)), a && (r[n] = a);
	}
	return r;
}, q3.getPropsList = function(e) {
	var t = [], r = this.properties;
	if (e) for (var i = Object.keys(e), n = 0; n < i.length; n++) {
		var a = i[n], s = e[a], o = r[a] || r[D9(a)], l = this.parse(o.name, s);
		l && t.push(l);
	}
	return t;
}, q3.getNonDefaultPropertiesHash = function(e, t, r) {
	var i, n, a, s, o, l, h = r.slice();
	for (o = 0; o < t.length; o++) if (i = t[o], null != (n = e.pstyle(i, !1))) if (null != n.pfValue) h[0] = OG(s, h[0]), h[1] = Oq(s, h[1]);
	else for (a = n.strValue, l = 0; l < a.length; l++) s = a.charCodeAt(l), h[0] = OG(s, h[0]), h[1] = Oq(s, h[1]);
	return h;
}, q3.getPropertiesHash = q3.getNonDefaultPropertiesHash;
var q6 = {};
q6.appendFromJson = function(e) {
	for (var t = 0; t < e.length; t++) {
		var r = e[t], i = r.selector, n = r.style || r.css, a = Object.keys(n);
		this.selector(i);
		for (var s = 0; s < a.length; s++) {
			var o = a[s], l = n[o];
			this.css(o, l);
		}
	}
	return this;
}, q6.fromJson = function(e) {
	return this.resetToDefault(), this.appendFromJson(e), this;
}, q6.json = function() {
	for (var e = [], t = this.defaultLength; t < this.length; t++) {
		for (var r = this[t], i = r.selector, n = r.properties, a = {}, s = 0; s < n.length; s++) {
			var o = n[s];
			a[o.name] = o.strValue;
		}
		e.push({
			selector: i ? i.toString() : "core",
			style: a
		});
	}
	return e;
};
var q7 = {};
q7.appendFromString = function(e) {
	var t, r, i, n = "" + e;
	function a() {
		n = n.length > t.length ? n.substr(t.length) : "";
	}
	function s() {
		r = r.length > i.length ? r.substr(i.length) : "";
	}
	for (n = n.replace(/[/][*](\s|.)+?[*][/]/g, ""), h(a, "removeSelAndBlockFromRemaining"), h(s, "removePropAndValFromRem"); !n.match(/^\s*$/);) {
		var o = n.match(/^\s*((?:.|\s)+?)\s*\{((?:.|\s)+?)\}/);
		if (!o) {
			$e("Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: " + n);
			break;
		}
		t = o[0];
		var l = o[1];
		if ("core" !== l && new Gl(l).invalid) {
			$e("Skipping parsing of block: Invalid selector found in string stylesheet: " + l), a();
			continue;
		}
		var u = o[2], d = !1;
		r = u;
		for (var p = []; !r.match(/^\s*$/);) {
			var f = r.match(/^\s*(.+?)\s*:\s*(.+?)(?:\s*;|\s*$)/);
			if (!f) {
				$e("Skipping parsing of block: Invalid formatting of style property and value definitions found in:" + u), d = !0;
				break;
			}
			i = f[0];
			var g = f[1], m = f[2];
			if (!this.properties[g]) {
				$e("Skipping property: Invalid property name in: " + i), s();
				continue;
			}
			if (!this.parse(g, m)) {
				$e("Skipping property: Invalid property definition in: " + i), s();
				continue;
			}
			p.push({
				name: g,
				val: m
			}), s();
		}
		if (d) {
			a();
			break;
		}
		this.selector(l);
		for (var y = 0; y < p.length; y++) {
			var v = p[y];
			this.css(v.name, v.val);
		}
		a();
	}
	return this;
}, q7.fromString = function(e) {
	return this.resetToDefault(), this.appendFromString(e), this;
};
var q8 = {};
(function() {
	var e = h(function(e) {
		return "^" + e + "\\s*\\(\\s*([\\w\\.]+)\\s*\\)$";
	}, "data"), t = h(function(e) {
		var t = On + "|\\w+|" + Os + "|" + Ol + "|\\#[0-9a-fA-F]{3}|\\#[0-9a-fA-F]{6}";
		return "^" + e + "\\s*\\(([\\w\\.]+)\\s*\\,\\s*(" + On + ")\\s*\\,\\s*(" + On + ")\\s*,\\s*(" + t + ")\\s*\\,\\s*(" + t + ")\\)$";
	}, "mapData"), r = [
		"^url\\s*\\(\\s*['\"]?(.+?)['\"]?\\s*\\)$",
		"^(none)$",
		"^(.+)$"
	];
	q8.types = {
		time: {
			number: !0,
			min: 0,
			units: "s|ms",
			implicitUnits: "ms"
		},
		percent: {
			number: !0,
			min: 0,
			max: 100,
			units: "%",
			implicitUnits: "%"
		},
		percentages: {
			number: !0,
			min: 0,
			max: 100,
			units: "%",
			implicitUnits: "%",
			multiple: !0
		},
		zeroOneNumber: {
			number: !0,
			min: 0,
			max: 1,
			unitless: !0
		},
		zeroOneNumbers: {
			number: !0,
			min: 0,
			max: 1,
			unitless: !0,
			multiple: !0
		},
		nOneOneNumber: {
			number: !0,
			min: -1,
			max: 1,
			unitless: !0
		},
		nonNegativeInt: {
			number: !0,
			min: 0,
			integer: !0,
			unitless: !0
		},
		nonNegativeNumber: {
			number: !0,
			min: 0,
			unitless: !0
		},
		position: { enums: ["parent", "origin"] },
		nodeSize: {
			number: !0,
			min: 0,
			enums: ["label"]
		},
		number: {
			number: !0,
			unitless: !0
		},
		numbers: {
			number: !0,
			unitless: !0,
			multiple: !0
		},
		positiveNumber: {
			number: !0,
			unitless: !0,
			min: 0,
			strictMin: !0
		},
		size: {
			number: !0,
			min: 0
		},
		bidirectionalSize: { number: !0 },
		bidirectionalSizeMaybePercent: {
			number: !0,
			allowPercent: !0
		},
		bidirectionalSizes: {
			number: !0,
			multiple: !0
		},
		sizeMaybePercent: {
			number: !0,
			min: 0,
			allowPercent: !0
		},
		axisDirection: { enums: [
			"horizontal",
			"leftward",
			"rightward",
			"vertical",
			"upward",
			"downward",
			"auto"
		] },
		axisDirectionExplicit: { enums: [
			"leftward",
			"rightward",
			"upward",
			"downward"
		] },
		axisDirectionPrimary: { enums: ["horizontal", "vertical"] },
		paddingRelativeTo: { enums: [
			"width",
			"height",
			"average",
			"min",
			"max"
		] },
		bgWH: {
			number: !0,
			min: 0,
			allowPercent: !0,
			enums: ["auto"],
			multiple: !0
		},
		bgPos: {
			number: !0,
			allowPercent: !0,
			multiple: !0
		},
		bgRelativeTo: {
			enums: ["inner", "include-padding"],
			multiple: !0
		},
		bgRepeat: {
			enums: [
				"repeat",
				"repeat-x",
				"repeat-y",
				"no-repeat"
			],
			multiple: !0
		},
		bgFit: {
			enums: [
				"none",
				"contain",
				"cover"
			],
			multiple: !0
		},
		bgCrossOrigin: {
			enums: [
				"anonymous",
				"use-credentials",
				"null"
			],
			multiple: !0
		},
		bgClip: {
			enums: ["none", "node"],
			multiple: !0
		},
		bgContainment: {
			enums: ["inside", "over"],
			multiple: !0
		},
		boxSelection: { enums: [
			"contain",
			"overlap",
			"none"
		] },
		color: { color: !0 },
		colors: {
			color: !0,
			multiple: !0
		},
		fill: { enums: [
			"solid",
			"linear-gradient",
			"radial-gradient"
		] },
		bool: { enums: ["yes", "no"] },
		bools: {
			enums: ["yes", "no"],
			multiple: !0
		},
		lineStyle: { enums: [
			"solid",
			"dotted",
			"dashed"
		] },
		lineCap: { enums: [
			"butt",
			"round",
			"square"
		] },
		linePosition: { enums: [
			"center",
			"inside",
			"outside"
		] },
		lineJoin: { enums: [
			"round",
			"bevel",
			"miter"
		] },
		borderStyle: { enums: [
			"solid",
			"dotted",
			"dashed",
			"double"
		] },
		curveStyle: { enums: [
			"bezier",
			"unbundled-bezier",
			"haystack",
			"segments",
			"straight",
			"straight-triangle",
			"taxi",
			"round-segments",
			"round-taxi"
		] },
		radiusType: {
			enums: ["arc-radius", "influence-radius"],
			multiple: !0
		},
		fontFamily: { regex: "^([\\w- \\\"]+(?:\\s*,\\s*[\\w- \\\"]+)*)$" },
		fontStyle: { enums: [
			"italic",
			"normal",
			"oblique"
		] },
		fontWeight: { enums: [
			"normal",
			"bold",
			"bolder",
			"lighter",
			"100",
			"200",
			"300",
			"400",
			"500",
			"600",
			"800",
			"900",
			100,
			200,
			300,
			400,
			500,
			600,
			700,
			800,
			900
		] },
		textDecoration: { enums: [
			"none",
			"underline",
			"overline",
			"line-through"
		] },
		textTransform: { enums: [
			"none",
			"uppercase",
			"lowercase"
		] },
		textWrap: { enums: [
			"none",
			"wrap",
			"ellipsis"
		] },
		textOverflowWrap: { enums: ["whitespace", "anywhere"] },
		textBackgroundShape: { enums: [
			"rectangle",
			"roundrectangle",
			"round-rectangle",
			"circle"
		] },
		nodeShape: { enums: [
			"rectangle",
			"roundrectangle",
			"round-rectangle",
			"cutrectangle",
			"cut-rectangle",
			"bottomroundrectangle",
			"bottom-round-rectangle",
			"barrel",
			"ellipse",
			"triangle",
			"round-triangle",
			"square",
			"pentagon",
			"round-pentagon",
			"hexagon",
			"round-hexagon",
			"concavehexagon",
			"concave-hexagon",
			"heptagon",
			"round-heptagon",
			"octagon",
			"round-octagon",
			"tag",
			"round-tag",
			"star",
			"diamond",
			"round-diamond",
			"vee",
			"rhomboid",
			"right-rhomboid",
			"polygon"
		] },
		overlayShape: { enums: [
			"roundrectangle",
			"round-rectangle",
			"ellipse"
		] },
		cornerRadius: {
			number: !0,
			min: 0,
			units: "px|em",
			implicitUnits: "px",
			enums: ["auto"]
		},
		compoundIncludeLabels: { enums: ["include", "exclude"] },
		arrowShape: { enums: [
			"tee",
			"triangle",
			"triangle-tee",
			"circle-triangle",
			"triangle-cross",
			"triangle-backcurve",
			"vee",
			"square",
			"circle",
			"diamond",
			"chevron",
			"none"
		] },
		arrowFill: { enums: ["filled", "hollow"] },
		arrowWidth: {
			number: !0,
			units: "%|px|em",
			implicitUnits: "px",
			enums: ["match-line"]
		},
		display: { enums: ["element", "none"] },
		visibility: { enums: ["hidden", "visible"] },
		zCompoundDepth: { enums: [
			"bottom",
			"orphan",
			"auto",
			"top"
		] },
		zIndexCompare: { enums: ["auto", "manual"] },
		valign: { enums: [
			"top",
			"center",
			"bottom"
		] },
		halign: { enums: [
			"left",
			"center",
			"right"
		] },
		justification: { enums: [
			"left",
			"center",
			"right",
			"auto"
		] },
		text: { string: !0 },
		data: {
			mapping: !0,
			regex: e("data")
		},
		layoutData: {
			mapping: !0,
			regex: e("layoutData")
		},
		scratch: {
			mapping: !0,
			regex: e("scratch")
		},
		mapData: {
			mapping: !0,
			regex: t("mapData")
		},
		mapLayoutData: {
			mapping: !0,
			regex: t("mapLayoutData")
		},
		mapScratch: {
			mapping: !0,
			regex: t("mapScratch")
		},
		fn: {
			mapping: !0,
			fn: !0
		},
		url: {
			regexes: r,
			singleRegexMatchValue: !0
		},
		urls: {
			regexes: r,
			singleRegexMatchValue: !0,
			multiple: !0
		},
		propList: { propList: !0 },
		angle: {
			number: !0,
			units: "deg|rad",
			implicitUnits: "rad"
		},
		textRotation: {
			number: !0,
			units: "deg|rad",
			implicitUnits: "rad",
			enums: ["none", "autorotate"]
		},
		polygonPointList: {
			number: !0,
			multiple: !0,
			evenMultiple: !0,
			min: -1,
			max: 1,
			unitless: !0
		},
		edgeDistances: { enums: [
			"intersection",
			"node-position",
			"endpoints"
		] },
		edgeEndpoint: {
			number: !0,
			multiple: !0,
			units: "%|px|em|deg|rad",
			implicitUnits: "px",
			enums: [
				"inside-to-node",
				"outside-to-node",
				"outside-to-node-or-label",
				"outside-to-line",
				"outside-to-line-or-label"
			],
			singleEnum: !0,
			validate: h(function(e, t) {
				switch (e.length) {
					case 2: return "deg" !== t[0] && "rad" !== t[0] && "deg" !== t[1] && "rad" !== t[1];
					case 1: return Dq(e[0]) || "deg" === t[0] || "rad" === t[0];
					default: return !1;
				}
			}, "validate")
		},
		easing: {
			regexes: ["^(spring)\\s*\\(\\s*(" + On + ")\\s*,\\s*(" + On + ")\\s*\\)$", "^(cubic-bezier)\\s*\\(\\s*(" + On + ")\\s*,\\s*(" + On + ")\\s*,\\s*(" + On + ")\\s*,\\s*(" + On + ")\\s*\\)$"],
			enums: [
				"linear",
				"ease",
				"ease-in",
				"ease-out",
				"ease-in-out",
				"ease-in-sine",
				"ease-out-sine",
				"ease-in-out-sine",
				"ease-in-quad",
				"ease-out-quad",
				"ease-in-out-quad",
				"ease-in-cubic",
				"ease-out-cubic",
				"ease-in-out-cubic",
				"ease-in-quart",
				"ease-out-quart",
				"ease-in-out-quart",
				"ease-in-quint",
				"ease-out-quint",
				"ease-in-out-quint",
				"ease-in-expo",
				"ease-out-expo",
				"ease-in-out-expo",
				"ease-in-circ",
				"ease-out-circ",
				"ease-in-out-circ"
			]
		},
		gradientDirection: { enums: [
			"to-bottom",
			"to-top",
			"to-left",
			"to-right",
			"to-bottom-right",
			"to-bottom-left",
			"to-top-right",
			"to-top-left",
			"to-right-bottom",
			"to-left-bottom",
			"to-right-top",
			"to-left-top"
		] },
		boundsExpansion: {
			number: !0,
			multiple: !0,
			min: 0,
			validate: h(function(e) {
				var t = e.length;
				return 1 === t || 2 === t || 4 === t;
			}, "validate")
		}
	};
	var i = {
		zeroNonZero: h(function(e, t) {
			return (null == e || null == t) && e !== t || 0 == e && 0 != t || 0 != e && 0 == t;
		}, "zeroNonZero"),
		any: h(function(e, t) {
			return e != t;
		}, "any"),
		emptyNonEmpty: h(function(e, t) {
			var r = D4(e), i = D4(t);
			return r && !i || !r && i;
		}, "emptyNonEmpty")
	}, n = q8.types, a = [
		{
			name: "label",
			type: n.text,
			triggersBounds: i.any,
			triggersZOrder: i.emptyNonEmpty
		},
		{
			name: "text-rotation",
			type: n.textRotation,
			triggersBounds: i.any
		},
		{
			name: "text-margin-x",
			type: n.bidirectionalSize,
			triggersBounds: i.any
		},
		{
			name: "text-margin-y",
			type: n.bidirectionalSize,
			triggersBounds: i.any
		}
	], s = [
		{
			name: "source-label",
			type: n.text,
			triggersBounds: i.any
		},
		{
			name: "source-text-rotation",
			type: n.textRotation,
			triggersBounds: i.any
		},
		{
			name: "source-text-margin-x",
			type: n.bidirectionalSize,
			triggersBounds: i.any
		},
		{
			name: "source-text-margin-y",
			type: n.bidirectionalSize,
			triggersBounds: i.any
		},
		{
			name: "source-text-offset",
			type: n.size,
			triggersBounds: i.any
		}
	], o = [
		{
			name: "target-label",
			type: n.text,
			triggersBounds: i.any
		},
		{
			name: "target-text-rotation",
			type: n.textRotation,
			triggersBounds: i.any
		},
		{
			name: "target-text-margin-x",
			type: n.bidirectionalSize,
			triggersBounds: i.any
		},
		{
			name: "target-text-margin-y",
			type: n.bidirectionalSize,
			triggersBounds: i.any
		},
		{
			name: "target-text-offset",
			type: n.size,
			triggersBounds: i.any
		}
	], l = [
		{
			name: "font-family",
			type: n.fontFamily,
			triggersBounds: i.any
		},
		{
			name: "font-style",
			type: n.fontStyle,
			triggersBounds: i.any
		},
		{
			name: "font-weight",
			type: n.fontWeight,
			triggersBounds: i.any
		},
		{
			name: "font-size",
			type: n.size,
			triggersBounds: i.any
		},
		{
			name: "text-transform",
			type: n.textTransform,
			triggersBounds: i.any
		},
		{
			name: "text-wrap",
			type: n.textWrap,
			triggersBounds: i.any
		},
		{
			name: "text-overflow-wrap",
			type: n.textOverflowWrap,
			triggersBounds: i.any
		},
		{
			name: "text-max-width",
			type: n.size,
			triggersBounds: i.any
		},
		{
			name: "text-outline-width",
			type: n.size,
			triggersBounds: i.any
		},
		{
			name: "line-height",
			type: n.positiveNumber,
			triggersBounds: i.any
		}
	], u = [
		{
			name: "text-valign",
			type: n.valign,
			triggersBounds: i.any
		},
		{
			name: "text-halign",
			type: n.halign,
			triggersBounds: i.any
		},
		{
			name: "color",
			type: n.color
		},
		{
			name: "text-outline-color",
			type: n.color
		},
		{
			name: "text-outline-opacity",
			type: n.zeroOneNumber
		},
		{
			name: "text-background-color",
			type: n.color
		},
		{
			name: "text-background-opacity",
			type: n.zeroOneNumber
		},
		{
			name: "text-background-padding",
			type: n.size,
			triggersBounds: i.any
		},
		{
			name: "text-border-opacity",
			type: n.zeroOneNumber
		},
		{
			name: "text-border-color",
			type: n.color
		},
		{
			name: "text-border-width",
			type: n.size,
			triggersBounds: i.any
		},
		{
			name: "text-border-style",
			type: n.borderStyle,
			triggersBounds: i.any
		},
		{
			name: "text-background-shape",
			type: n.textBackgroundShape,
			triggersBounds: i.any
		},
		{
			name: "text-justification",
			type: n.justification
		},
		{
			name: "box-select-labels",
			type: n.bool,
			triggersBounds: i.any
		}
	], d = [
		{
			name: "events",
			type: n.bool,
			triggersZOrder: i.any
		},
		{
			name: "text-events",
			type: n.bool,
			triggersZOrder: i.any
		},
		{
			name: "box-selection",
			type: n.boxSelection,
			triggersZOrder: i.any
		}
	], p = [
		{
			name: "display",
			type: n.display,
			triggersZOrder: i.any,
			triggersBounds: i.any,
			triggersBoundsOfConnectedEdges: i.any,
			triggersBoundsOfParallelEdges: h(function(e, t, r) {
				return e !== t && "bezier" === r.pstyle("curve-style").value;
			}, "triggersBoundsOfParallelEdges")
		},
		{
			name: "visibility",
			type: n.visibility,
			triggersZOrder: i.any
		},
		{
			name: "opacity",
			type: n.zeroOneNumber,
			triggersZOrder: i.zeroNonZero
		},
		{
			name: "text-opacity",
			type: n.zeroOneNumber
		},
		{
			name: "min-zoomed-font-size",
			type: n.size
		},
		{
			name: "z-compound-depth",
			type: n.zCompoundDepth,
			triggersZOrder: i.any
		},
		{
			name: "z-index-compare",
			type: n.zIndexCompare,
			triggersZOrder: i.any
		},
		{
			name: "z-index",
			type: n.number,
			triggersZOrder: i.any
		}
	], f = [
		{
			name: "overlay-padding",
			type: n.size,
			triggersBounds: i.any
		},
		{
			name: "overlay-color",
			type: n.color
		},
		{
			name: "overlay-opacity",
			type: n.zeroOneNumber,
			triggersBounds: i.zeroNonZero
		},
		{
			name: "overlay-shape",
			type: n.overlayShape,
			triggersBounds: i.any
		},
		{
			name: "overlay-corner-radius",
			type: n.cornerRadius
		}
	], g = [
		{
			name: "underlay-padding",
			type: n.size,
			triggersBounds: i.any
		},
		{
			name: "underlay-color",
			type: n.color
		},
		{
			name: "underlay-opacity",
			type: n.zeroOneNumber,
			triggersBounds: i.zeroNonZero
		},
		{
			name: "underlay-shape",
			type: n.overlayShape,
			triggersBounds: i.any
		},
		{
			name: "underlay-corner-radius",
			type: n.cornerRadius
		}
	], m = [
		{
			name: "transition-property",
			type: n.propList
		},
		{
			name: "transition-duration",
			type: n.time
		},
		{
			name: "transition-delay",
			type: n.time
		},
		{
			name: "transition-timing-function",
			type: n.easing
		}
	], y = h(function(e, t) {
		return "label" === t.value ? -e.poolIndex() : t.pfValue;
	}, "nodeSizeHashOverride"), v = [
		{
			name: "height",
			type: n.nodeSize,
			triggersBounds: i.any,
			hashOverride: y
		},
		{
			name: "width",
			type: n.nodeSize,
			triggersBounds: i.any,
			hashOverride: y
		},
		{
			name: "shape",
			type: n.nodeShape,
			triggersBounds: i.any
		},
		{
			name: "shape-polygon-points",
			type: n.polygonPointList,
			triggersBounds: i.any
		},
		{
			name: "corner-radius",
			type: n.cornerRadius
		},
		{
			name: "background-color",
			type: n.color
		},
		{
			name: "background-fill",
			type: n.fill
		},
		{
			name: "background-opacity",
			type: n.zeroOneNumber
		},
		{
			name: "background-blacken",
			type: n.nOneOneNumber
		},
		{
			name: "background-gradient-stop-colors",
			type: n.colors
		},
		{
			name: "background-gradient-stop-positions",
			type: n.percentages
		},
		{
			name: "background-gradient-direction",
			type: n.gradientDirection
		},
		{
			name: "padding",
			type: n.sizeMaybePercent,
			triggersBounds: i.any
		},
		{
			name: "padding-relative-to",
			type: n.paddingRelativeTo,
			triggersBounds: i.any
		},
		{
			name: "bounds-expansion",
			type: n.boundsExpansion,
			triggersBounds: i.any
		}
	], x = [
		{
			name: "border-color",
			type: n.color
		},
		{
			name: "border-opacity",
			type: n.zeroOneNumber
		},
		{
			name: "border-width",
			type: n.size,
			triggersBounds: i.any
		},
		{
			name: "border-style",
			type: n.borderStyle
		},
		{
			name: "border-cap",
			type: n.lineCap
		},
		{
			name: "border-join",
			type: n.lineJoin
		},
		{
			name: "border-dash-pattern",
			type: n.numbers
		},
		{
			name: "border-dash-offset",
			type: n.number
		},
		{
			name: "border-position",
			type: n.linePosition
		}
	], b = [
		{
			name: "outline-color",
			type: n.color
		},
		{
			name: "outline-opacity",
			type: n.zeroOneNumber
		},
		{
			name: "outline-width",
			type: n.size,
			triggersBounds: i.any
		},
		{
			name: "outline-style",
			type: n.borderStyle
		},
		{
			name: "outline-offset",
			type: n.size,
			triggersBounds: i.any
		}
	], w = [
		{
			name: "background-image",
			type: n.urls
		},
		{
			name: "background-image-crossorigin",
			type: n.bgCrossOrigin
		},
		{
			name: "background-image-opacity",
			type: n.zeroOneNumbers
		},
		{
			name: "background-image-containment",
			type: n.bgContainment
		},
		{
			name: "background-image-smoothing",
			type: n.bools
		},
		{
			name: "background-position-x",
			type: n.bgPos
		},
		{
			name: "background-position-y",
			type: n.bgPos
		},
		{
			name: "background-width-relative-to",
			type: n.bgRelativeTo
		},
		{
			name: "background-height-relative-to",
			type: n.bgRelativeTo
		},
		{
			name: "background-repeat",
			type: n.bgRepeat
		},
		{
			name: "background-fit",
			type: n.bgFit
		},
		{
			name: "background-clip",
			type: n.bgClip
		},
		{
			name: "background-width",
			type: n.bgWH
		},
		{
			name: "background-height",
			type: n.bgWH
		},
		{
			name: "background-offset-x",
			type: n.bgPos
		},
		{
			name: "background-offset-y",
			type: n.bgPos
		}
	], k = [
		{
			name: "position",
			type: n.position,
			triggersBounds: i.any
		},
		{
			name: "compound-sizing-wrt-labels",
			type: n.compoundIncludeLabels,
			triggersBounds: i.any
		},
		{
			name: "min-width",
			type: n.size,
			triggersBounds: i.any
		},
		{
			name: "min-width-bias-left",
			type: n.sizeMaybePercent,
			triggersBounds: i.any
		},
		{
			name: "min-width-bias-right",
			type: n.sizeMaybePercent,
			triggersBounds: i.any
		},
		{
			name: "min-height",
			type: n.size,
			triggersBounds: i.any
		},
		{
			name: "min-height-bias-top",
			type: n.sizeMaybePercent,
			triggersBounds: i.any
		},
		{
			name: "min-height-bias-bottom",
			type: n.sizeMaybePercent,
			triggersBounds: i.any
		}
	], T = [
		{
			name: "line-style",
			type: n.lineStyle
		},
		{
			name: "line-color",
			type: n.color
		},
		{
			name: "line-fill",
			type: n.fill
		},
		{
			name: "line-cap",
			type: n.lineCap
		},
		{
			name: "line-opacity",
			type: n.zeroOneNumber
		},
		{
			name: "line-dash-pattern",
			type: n.numbers
		},
		{
			name: "line-dash-offset",
			type: n.number
		},
		{
			name: "line-outline-width",
			type: n.size
		},
		{
			name: "line-outline-color",
			type: n.color
		},
		{
			name: "line-gradient-stop-colors",
			type: n.colors
		},
		{
			name: "line-gradient-stop-positions",
			type: n.percentages
		},
		{
			name: "curve-style",
			type: n.curveStyle,
			triggersBounds: i.any,
			triggersBoundsOfParallelEdges: h(function(e, t) {
				return e !== t && ("bezier" === e || "bezier" === t);
			}, "triggersBoundsOfParallelEdges")
		},
		{
			name: "haystack-radius",
			type: n.zeroOneNumber,
			triggersBounds: i.any
		},
		{
			name: "source-endpoint",
			type: n.edgeEndpoint,
			triggersBounds: i.any
		},
		{
			name: "target-endpoint",
			type: n.edgeEndpoint,
			triggersBounds: i.any
		},
		{
			name: "control-point-step-size",
			type: n.size,
			triggersBounds: i.any
		},
		{
			name: "control-point-distances",
			type: n.bidirectionalSizes,
			triggersBounds: i.any
		},
		{
			name: "control-point-weights",
			type: n.numbers,
			triggersBounds: i.any
		},
		{
			name: "segment-distances",
			type: n.bidirectionalSizes,
			triggersBounds: i.any
		},
		{
			name: "segment-weights",
			type: n.numbers,
			triggersBounds: i.any
		},
		{
			name: "segment-radii",
			type: n.numbers,
			triggersBounds: i.any
		},
		{
			name: "radius-type",
			type: n.radiusType,
			triggersBounds: i.any
		},
		{
			name: "taxi-turn",
			type: n.bidirectionalSizeMaybePercent,
			triggersBounds: i.any
		},
		{
			name: "taxi-turn-min-distance",
			type: n.size,
			triggersBounds: i.any
		},
		{
			name: "taxi-direction",
			type: n.axisDirection,
			triggersBounds: i.any
		},
		{
			name: "taxi-radius",
			type: n.number,
			triggersBounds: i.any
		},
		{
			name: "edge-distances",
			type: n.edgeDistances,
			triggersBounds: i.any
		},
		{
			name: "arrow-scale",
			type: n.positiveNumber,
			triggersBounds: i.any
		},
		{
			name: "loop-direction",
			type: n.angle,
			triggersBounds: i.any
		},
		{
			name: "loop-sweep",
			type: n.angle,
			triggersBounds: i.any
		},
		{
			name: "source-distance-from-node",
			type: n.size,
			triggersBounds: i.any
		},
		{
			name: "target-distance-from-node",
			type: n.size,
			triggersBounds: i.any
		}
	], _ = [
		{
			name: "ghost",
			type: n.bool,
			triggersBounds: i.any
		},
		{
			name: "ghost-offset-x",
			type: n.bidirectionalSize,
			triggersBounds: i.any
		},
		{
			name: "ghost-offset-y",
			type: n.bidirectionalSize,
			triggersBounds: i.any
		},
		{
			name: "ghost-opacity",
			type: n.zeroOneNumber
		}
	], E = [
		{
			name: "selection-box-color",
			type: n.color
		},
		{
			name: "selection-box-opacity",
			type: n.zeroOneNumber
		},
		{
			name: "selection-box-border-color",
			type: n.color
		},
		{
			name: "selection-box-border-width",
			type: n.size
		},
		{
			name: "active-bg-color",
			type: n.color
		},
		{
			name: "active-bg-opacity",
			type: n.zeroOneNumber
		},
		{
			name: "active-bg-size",
			type: n.size
		},
		{
			name: "outside-texture-bg-color",
			type: n.color
		},
		{
			name: "outside-texture-bg-opacity",
			type: n.zeroOneNumber
		}
	], C = [];
	q8.pieBackgroundN = 16, C.push({
		name: "pie-size",
		type: n.sizeMaybePercent
	}), C.push({
		name: "pie-hole",
		type: n.sizeMaybePercent
	}), C.push({
		name: "pie-start-angle",
		type: n.angle
	});
	for (var S = 1; S <= q8.pieBackgroundN; S++) C.push({
		name: "pie-" + S + "-background-color",
		type: n.color
	}), C.push({
		name: "pie-" + S + "-background-size",
		type: n.percent
	}), C.push({
		name: "pie-" + S + "-background-opacity",
		type: n.zeroOneNumber
	});
	var A = [];
	q8.stripeBackgroundN = 16, A.push({
		name: "stripe-size",
		type: n.sizeMaybePercent
	}), A.push({
		name: "stripe-direction",
		type: n.axisDirectionPrimary
	});
	for (var L = 1; L <= q8.stripeBackgroundN; L++) A.push({
		name: "stripe-" + L + "-background-color",
		type: n.color
	}), A.push({
		name: "stripe-" + L + "-background-size",
		type: n.percent
	}), A.push({
		name: "stripe-" + L + "-background-opacity",
		type: n.zeroOneNumber
	});
	var R = [], N = q8.arrowPrefixes = [
		"source",
		"mid-source",
		"target",
		"mid-target"
	];
	[
		{
			name: "arrow-shape",
			type: n.arrowShape,
			triggersBounds: i.any
		},
		{
			name: "arrow-color",
			type: n.color
		},
		{
			name: "arrow-fill",
			type: n.arrowFill
		},
		{
			name: "arrow-width",
			type: n.arrowWidth
		}
	].forEach(function(e) {
		N.forEach(function(t) {
			var r = t + "-" + e.name, i = e.type, n = e.triggersBounds;
			R.push({
				name: r,
				type: i,
				triggersBounds: n
			});
		});
	}, {});
	var I = q8.properties = [].concat(d, m, p, f, g, _, u, l, a, s, o, v, x, b, w, C, A, k, T, R, E), M = q8.propertyGroups = {
		behavior: d,
		transition: m,
		visibility: p,
		overlay: f,
		underlay: g,
		ghost: _,
		commonLabel: u,
		labelDimensions: l,
		mainLabel: a,
		sourceLabel: s,
		targetLabel: o,
		nodeBody: v,
		nodeBorder: x,
		nodeOutline: b,
		backgroundImage: w,
		pie: C,
		stripe: A,
		compound: k,
		edgeLine: T,
		edgeArrow: R,
		core: E
	}, D = q8.propertyGroupNames = {};
	(q8.propertyGroupKeys = Object.keys(M)).forEach(function(e) {
		D[e] = M[e].map(function(e) {
			return e.name;
		}), M[e].forEach(function(t) {
			return t.groupKey = e;
		});
	});
	var O = q8.aliases = [
		{
			name: "content",
			pointsTo: "label"
		},
		{
			name: "control-point-distance",
			pointsTo: "control-point-distances"
		},
		{
			name: "control-point-weight",
			pointsTo: "control-point-weights"
		},
		{
			name: "segment-distance",
			pointsTo: "segment-distances"
		},
		{
			name: "segment-weight",
			pointsTo: "segment-weights"
		},
		{
			name: "segment-radius",
			pointsTo: "segment-radii"
		},
		{
			name: "edge-text-rotation",
			pointsTo: "text-rotation"
		},
		{
			name: "padding-left",
			pointsTo: "padding"
		},
		{
			name: "padding-right",
			pointsTo: "padding"
		},
		{
			name: "padding-top",
			pointsTo: "padding"
		},
		{
			name: "padding-bottom",
			pointsTo: "padding"
		}
	];
	q8.propertyNames = I.map(function(e) {
		return e.name;
	});
	for (var $ = 0; $ < I.length; $++) {
		var P = I[$];
		I[P.name] = P;
	}
	for (var B = 0; B < O.length; B++) {
		var F = O[B], z = I[F.pointsTo], U = {
			name: F.name,
			alias: !0,
			pointsTo: z
		};
		I.push(U), I[F.name] = U;
	}
})(), q8.getDefaultProperty = function(e) {
	return this.getDefaultProperties()[e];
}, q8.getDefaultProperties = function() {
	var e = this._private;
	if (null != e.defaultProperties) return e.defaultProperties;
	for (var t = Ou({
		"selection-box-color": "#ddd",
		"selection-box-opacity": .65,
		"selection-box-border-color": "#aaa",
		"selection-box-border-width": 1,
		"active-bg-color": "black",
		"active-bg-opacity": .15,
		"active-bg-size": 30,
		"outside-texture-bg-color": "#000",
		"outside-texture-bg-opacity": .125,
		events: "yes",
		"text-events": "no",
		"text-valign": "top",
		"text-halign": "center",
		"text-justification": "auto",
		"line-height": 1,
		color: "#000",
		"box-selection": "contain",
		"text-outline-color": "#000",
		"text-outline-width": 0,
		"text-outline-opacity": 1,
		"text-opacity": 1,
		"text-decoration": "none",
		"text-transform": "none",
		"text-wrap": "none",
		"text-overflow-wrap": "whitespace",
		"text-max-width": 9999,
		"text-background-color": "#000",
		"text-background-opacity": 0,
		"text-background-shape": "rectangle",
		"text-background-padding": 0,
		"text-border-opacity": 0,
		"text-border-width": 0,
		"text-border-style": "solid",
		"text-border-color": "#000",
		"font-family": "Helvetica Neue, Helvetica, sans-serif",
		"font-style": "normal",
		"font-weight": "normal",
		"font-size": 16,
		"min-zoomed-font-size": 0,
		"text-rotation": "none",
		"source-text-rotation": "none",
		"target-text-rotation": "none",
		visibility: "visible",
		display: "element",
		opacity: 1,
		"z-compound-depth": "auto",
		"z-index-compare": "auto",
		"z-index": 0,
		label: "",
		"text-margin-x": 0,
		"text-margin-y": 0,
		"source-label": "",
		"source-text-offset": 0,
		"source-text-margin-x": 0,
		"source-text-margin-y": 0,
		"target-label": "",
		"target-text-offset": 0,
		"target-text-margin-x": 0,
		"target-text-margin-y": 0,
		"overlay-opacity": 0,
		"overlay-color": "#000",
		"overlay-padding": 10,
		"overlay-shape": "round-rectangle",
		"overlay-corner-radius": "auto",
		"underlay-opacity": 0,
		"underlay-color": "#000",
		"underlay-padding": 10,
		"underlay-shape": "round-rectangle",
		"underlay-corner-radius": "auto",
		"transition-property": "none",
		"transition-duration": 0,
		"transition-delay": 0,
		"transition-timing-function": "linear",
		"box-select-labels": "no",
		"background-blacken": 0,
		"background-color": "#999",
		"background-fill": "solid",
		"background-opacity": 1,
		"background-image": "none",
		"background-image-crossorigin": "anonymous",
		"background-image-opacity": 1,
		"background-image-containment": "inside",
		"background-image-smoothing": "yes",
		"background-position-x": "50%",
		"background-position-y": "50%",
		"background-offset-x": 0,
		"background-offset-y": 0,
		"background-width-relative-to": "include-padding",
		"background-height-relative-to": "include-padding",
		"background-repeat": "no-repeat",
		"background-fit": "none",
		"background-clip": "node",
		"background-width": "auto",
		"background-height": "auto",
		"border-color": "#000",
		"border-opacity": 1,
		"border-width": 0,
		"border-style": "solid",
		"border-dash-pattern": [4, 2],
		"border-dash-offset": 0,
		"border-cap": "butt",
		"border-join": "miter",
		"border-position": "center",
		"outline-color": "#999",
		"outline-opacity": 1,
		"outline-width": 0,
		"outline-offset": 0,
		"outline-style": "solid",
		height: 30,
		width: 30,
		shape: "ellipse",
		"shape-polygon-points": "-1, -1,   1, -1,   1, 1,   -1, 1",
		"corner-radius": "auto",
		"bounds-expansion": 0,
		"background-gradient-direction": "to-bottom",
		"background-gradient-stop-colors": "#999",
		"background-gradient-stop-positions": "0%",
		ghost: "no",
		"ghost-offset-y": 0,
		"ghost-offset-x": 0,
		"ghost-opacity": 0,
		padding: 0,
		"padding-relative-to": "width",
		position: "origin",
		"compound-sizing-wrt-labels": "include",
		"min-width": 0,
		"min-width-bias-left": 0,
		"min-width-bias-right": 0,
		"min-height": 0,
		"min-height-bias-top": 0,
		"min-height-bias-bottom": 0
	}, {
		"pie-size": "100%",
		"pie-hole": 0,
		"pie-start-angle": "0deg"
	}, [
		{
			name: "pie-{{i}}-background-color",
			value: "black"
		},
		{
			name: "pie-{{i}}-background-size",
			value: "0%"
		},
		{
			name: "pie-{{i}}-background-opacity",
			value: 1
		}
	].reduce(function(e, t) {
		for (var r = 1; r <= q8.pieBackgroundN; r++) e[t.name.replace("{{i}}", r)] = t.value;
		return e;
	}, {}), {
		"stripe-size": "100%",
		"stripe-direction": "horizontal"
	}, [
		{
			name: "stripe-{{i}}-background-color",
			value: "black"
		},
		{
			name: "stripe-{{i}}-background-size",
			value: "0%"
		},
		{
			name: "stripe-{{i}}-background-opacity",
			value: 1
		}
	].reduce(function(e, t) {
		for (var r = 1; r <= q8.stripeBackgroundN; r++) e[t.name.replace("{{i}}", r)] = t.value;
		return e;
	}, {}), {
		"line-style": "solid",
		"line-color": "#999",
		"line-fill": "solid",
		"line-cap": "butt",
		"line-opacity": 1,
		"line-outline-width": 0,
		"line-outline-color": "#000",
		"line-gradient-stop-colors": "#999",
		"line-gradient-stop-positions": "0%",
		"control-point-step-size": 40,
		"control-point-weights": .5,
		"segment-weights": .5,
		"segment-distances": 20,
		"segment-radii": 15,
		"radius-type": "arc-radius",
		"taxi-turn": "50%",
		"taxi-radius": 15,
		"taxi-turn-min-distance": 10,
		"taxi-direction": "auto",
		"edge-distances": "intersection",
		"curve-style": "haystack",
		"haystack-radius": 0,
		"arrow-scale": 1,
		"loop-direction": "-45deg",
		"loop-sweep": "-90deg",
		"source-distance-from-node": 0,
		"target-distance-from-node": 0,
		"source-endpoint": "outside-to-node",
		"target-endpoint": "outside-to-node",
		"line-dash-pattern": [6, 3],
		"line-dash-offset": 0
	}, [
		{
			name: "arrow-shape",
			value: "none"
		},
		{
			name: "arrow-color",
			value: "#999"
		},
		{
			name: "arrow-fill",
			value: "filled"
		},
		{
			name: "arrow-width",
			value: 1
		}
	].reduce(function(e, t) {
		return q8.arrowPrefixes.forEach(function(r) {
			e[r + "-" + t.name] = t.value;
		}), e;
	}, {})), r = {}, i = 0; i < this.properties.length; i++) {
		var n = this.properties[i];
		if (!n.pointsTo) {
			var a = n.name, s = t[a];
			r[a] = this.parse(a, s);
		}
	}
	return e.defaultProperties = r, e.defaultProperties;
}, q8.addDefaultStylesheet = function() {
	this.selector(":parent").css({
		shape: "rectangle",
		padding: 10,
		"background-color": "#eee",
		"border-color": "#ccc",
		"border-width": 1
	}).selector("edge").css({ width: 3 }).selector(":loop").css({ "curve-style": "bezier" }).selector("edge:compound").css({
		"curve-style": "bezier",
		"source-endpoint": "outside-to-line",
		"target-endpoint": "outside-to-line"
	}).selector(":selected").css({
		"background-color": "#0169D9",
		"line-color": "#0169D9",
		"source-arrow-color": "#0169D9",
		"target-arrow-color": "#0169D9",
		"mid-source-arrow-color": "#0169D9",
		"mid-target-arrow-color": "#0169D9"
	}).selector(":parent:selected").css({
		"background-color": "#CCE1F9",
		"border-color": "#aec8e5"
	}).selector(":active").css({
		"overlay-color": "black",
		"overlay-padding": 10,
		"overlay-opacity": .25
	}), this.defaultLength = this.length;
};
var q9 = {};
q9.parse = function(e, t, r, i) {
	if (Dj(t)) return this.parseImplWarn(e, t, r, i);
	var n, a = OX(e, "" + t, r ? "t" : "f", "mapping" === i || !0 === i || !1 === i || null == i ? "dontcare" : i), s = this.propCache = this.propCache || [];
	return (n = s[a]) || (n = s[a] = this.parseImplWarn(e, t, r, i)), (r || "mapping" === i) && (n = $r(n)) && (n.value = $r(n.value)), n;
}, q9.parseImplWarn = function(e, t, r, i) {
	var n = this.parseImpl(e, t, r, i);
	return n || null == t || $e("The style property `".concat(e, ": ").concat(t, "` is invalid")), n && ("width" === n.name || "height" === n.name) && "label" === t && $e("The style value of `label` is deprecated for `" + n.name + "`"), n;
}, q9.parseImpl = function(e, t, r, i) {
	e = D9(e);
	var n = this.properties[e], a = t, s = this.types;
	if (!n || void 0 === t) return null;
	n.alias && (e = (n = n.pointsTo).name);
	var o = Dq(t);
	o && (t = t.trim());
	var l = n.type;
	if (!l) return null;
	if (r && ("" === t || null === t)) return {
		name: e,
		value: t,
		bypass: !0,
		deleteBypass: !0
	};
	if (Dj(t)) return {
		name: e,
		value: t,
		strValue: "fn",
		mapped: s.fn,
		bypass: r
	};
	if (!(!o || i || t.length < 7 || "a" !== t[1])) {
		if (t.length >= 7 && "d" === t[0] && (E = new RegExp(s.data.regex).exec(t))) {
			if (r) return !1;
			var u = s.data;
			return {
				name: e,
				value: E,
				strValue: "" + t,
				mapped: u,
				field: E[1],
				bypass: r
			};
		} else if (t.length >= 10 && "m" === t[0] && (C = new RegExp(s.mapData.regex).exec(t))) {
			if (r || l.multiple) return !1;
			var d = s.mapData;
			if (!(l.color || l.number)) return !1;
			var p = this.parse(e, C[4]);
			if (!p || p.mapped) return !1;
			var f = this.parse(e, C[5]);
			if (!f || f.mapped) return !1;
			if (p.pfValue === f.pfValue || p.strValue === f.strValue) return $e("`" + e + ": " + t + "` is not a valid mapper because the output range is zero; converting to `" + e + ": " + p.strValue + "`"), this.parse(e, p.strValue);
			if (l.color) {
				var g = p.value, m = f.value;
				if (g[0] === m[0] && g[1] === m[1] && g[2] === m[2] && (g[3] === m[3] || (null == g[3] || 1 === g[3]) && (null == m[3] || 1 === m[3]))) return !1;
			}
			return {
				name: e,
				value: C,
				strValue: "" + t,
				mapped: d,
				field: C[1],
				fieldMin: parseFloat(C[2]),
				fieldMax: parseFloat(C[3]),
				valueMin: p.value,
				valueMax: f.value,
				bypass: r
			};
		}
	}
	if (l.multiple && "multiple" !== i) {
		if (S = o ? t.split(/\s+/) : DW(t) ? t : [t], l.evenMultiple && S.length % 2 != 0) return null;
		for (var y = [], v = [], x = [], b = "", w = !1, k = 0; k < S.length; k++) {
			var T = this.parse(e, S[k], r, "multiple");
			w = w || Dq(T.value), y.push(T.value), x.push(null != T.pfValue ? T.pfValue : T.value), v.push(T.units), b += (k > 0 ? " " : "") + T.strValue;
		}
		return l.validate && !l.validate(y, v) ? null : l.singleEnum && w ? 1 === y.length && Dq(y[0]) ? {
			name: e,
			value: y[0],
			strValue: y[0],
			bypass: r
		} : null : {
			name: e,
			value: y,
			pfValue: x,
			strValue: b,
			bypass: r,
			units: v
		};
	}
	var _ = h(function() {
		for (var i = 0; i < l.enums.length; i++) if (l.enums[i] === t) return {
			name: e,
			value: t,
			strValue: "" + t,
			bypass: r
		};
		return null;
	}, "checkEnums");
	if (l.number) {
		var E, C, S, A, L = "px";
		if (l.units && (A = l.units), l.implicitUnits && (L = l.implicitUnits), !l.unitless) if (o) {
			var R = "px|em" + (l.allowPercent ? "|\\%" : "");
			A && (R = A);
			var N = t.match("^(" + On + ")(" + R + ")?$");
			N && (t = N[1], A = N[2] || L);
		} else (!A || l.implicitUnits) && (A = L);
		if (isNaN(t = parseFloat(t)) && void 0 === l.enums) return null;
		if (isNaN(t) && void 0 !== l.enums) return t = a, _();
		if (l.integer && !DX(t) || void 0 !== l.min && (t < l.min || l.strictMin && t === l.min) || void 0 !== l.max && (t > l.max || l.strictMax && t === l.max)) return null;
		var I = {
			name: e,
			value: t,
			strValue: "" + t + (A || ""),
			units: A,
			bypass: r
		};
		return l.unitless || "px" !== A && "em" !== A ? I.pfValue = t : I.pfValue = "px" !== A && A ? this.getEmSizeInPixels() * t : t, ("ms" === A || "s" === A) && (I.pfValue = "ms" === A ? t : 1e3 * t), ("deg" === A || "rad" === A) && (I.pfValue = "rad" === A ? t : Pf(t)), "%" === A && (I.pfValue = t / 100), I;
	}
	if (l.propList) {
		var M = [], D = "" + t;
		if ("none" !== D) {
			for (var O = D.split(/\s*,\s*|\s+/), $ = 0; $ < O.length; $++) {
				var P = O[$].trim();
				this.properties[P] ? M.push(P) : $e("`" + P + "` is not a valid property name");
			}
			if (0 === M.length) return null;
		}
		return {
			name: e,
			value: M,
			strValue: 0 === M.length ? "none" : M.join(" "),
			bypass: r
		};
	}
	if (l.color) {
		var B = Om(t);
		return B ? {
			name: e,
			value: B,
			pfValue: B,
			strValue: "rgb(" + B[0] + "," + B[1] + "," + B[2] + ")",
			bypass: r
		} : null;
	}
	if (!l.regex && !l.regexes) return l.string ? {
		name: e,
		value: "" + t,
		strValue: "" + t,
		bypass: r
	} : l.enums ? _() : null;
	if (l.enums) {
		var F = _();
		if (F) return F;
	}
	for (var z = l.regexes ? l.regexes : [l.regex], U = 0; U < z.length; U++) {
		var G = new RegExp(z[U]).exec(t);
		if (G) return {
			name: e,
			value: l.singleRegexMatchValue ? G[1] : G,
			strValue: "" + t,
			bypass: r
		};
	}
	return null;
};
var je = h(function(e) {
	return this instanceof je ? D0(e) ? void (this._private = {
		cy: e,
		coreStyle: {}
	}, this.length = 0, this.resetToDefault()) : void O8("A style must have a core reference") : new je(e);
}, "Style"), jt = je.prototype;
jt.instanceString = function() {
	return "style";
}, jt.clear = function() {
	for (var e = this._private, t = e.cy.elements(), r = 0; r < this.length; r++) this[r] = void 0;
	return this.length = 0, e.contextStyles = {}, e.propDiffs = {}, this.cleanElements(t, !0), t.forEach(function(e) {
		var t = e[0]._private;
		t.styleDirty = !0, t.appliedInitStyle = !1;
	}), this;
}, jt.resetToDefault = function() {
	return this.clear(), this.addDefaultStylesheet(), this;
}, jt.core = function(e) {
	return this._private.coreStyle[e] || this.getDefaultProperty(e);
}, jt.selector = function(e) {
	var t = "core" === e ? null : new Gl(e), r = this.length++;
	return this[r] = {
		selector: t,
		properties: [],
		mappedProperties: [],
		index: r
	}, this;
}, jt.css = function() {
	var e = arguments;
	if (1 === e.length) for (var t = e[0], r = 0; r < this.properties.length; r++) {
		var i = this.properties[r], n = t[i.name];
		void 0 === n && (n = t[Oe(i.name)]), void 0 !== n && this.cssRule(i.name, n);
	}
	else 2 === e.length && this.cssRule(e[0], e[1]);
	return this;
}, jt.style = jt.css, jt.cssRule = function(e, t) {
	var r = this.parse(e, t);
	if (r) {
		var i = this.length - 1;
		this[i].properties.push(r), this[i].properties[r.name] = r, r.name.match(/pie-(\d+)-background-size/) && r.value && (this._private.hasPie = !0), r.name.match(/stripe-(\d+)-background-size/) && r.value && (this._private.hasStripe = !0), r.mapped && this[i].mappedProperties.push(r), this[i].selector || (this._private.coreStyle[r.name] = r);
	}
	return this;
}, jt.append = function(e) {
	return D1(e) ? e.appendToStyle(this) : DW(e) ? this.appendFromJson(e) : Dq(e) && this.appendFromString(e), this;
}, je.fromJson = function(e, t) {
	var r = new je(e);
	return r.fromJson(t), r;
}, je.fromString = function(e, t) {
	return new je(e).fromString(t);
}, [
	q2,
	q4,
	q5,
	q3,
	q6,
	q7,
	q8,
	q9
].forEach(function(e) {
	Ou(jt, e);
}), je.types = jt.types, je.properties = jt.properties, je.propertyGroups = jt.propertyGroups, je.propertyGroupNames = jt.propertyGroupNames, je.propertyGroupKeys = jt.propertyGroupKeys;
var jr = {
	style: h(function(e) {
		return e && this.setStyle(e).update(), this._private.style;
	}, "style"),
	setStyle: h(function(e) {
		var t = this._private;
		return D1(e) ? t.style = e.generateStyle(this) : DW(e) ? t.style = je.fromJson(this, e) : Dq(e) ? t.style = je.fromString(this, e) : t.style = je(this), t.style;
	}, "setStyle"),
	updateStyle: h(function() {
		this.mutableElements().updateStyle();
	}, "updateStyle")
}, ji = {
	autolock: h(function(e) {
		return void 0 === e ? this._private.autolock : (this._private.autolock = !!e, this);
	}, "autolock"),
	autoungrabify: h(function(e) {
		return void 0 === e ? this._private.autoungrabify : (this._private.autoungrabify = !!e, this);
	}, "autoungrabify"),
	autounselectify: h(function(e) {
		return void 0 === e ? this._private.autounselectify : (this._private.autounselectify = !!e, this);
	}, "autounselectify"),
	selectionType: h(function(e) {
		var t = this._private;
		return (t.selectionType ??= "single", void 0 === e) ? t.selectionType : (("additive" === e || "single" === e) && (t.selectionType = e), this);
	}, "selectionType"),
	panningEnabled: h(function(e) {
		return void 0 === e ? this._private.panningEnabled : (this._private.panningEnabled = !!e, this);
	}, "panningEnabled"),
	userPanningEnabled: h(function(e) {
		return void 0 === e ? this._private.userPanningEnabled : (this._private.userPanningEnabled = !!e, this);
	}, "userPanningEnabled"),
	zoomingEnabled: h(function(e) {
		return void 0 === e ? this._private.zoomingEnabled : (this._private.zoomingEnabled = !!e, this);
	}, "zoomingEnabled"),
	userZoomingEnabled: h(function(e) {
		return void 0 === e ? this._private.userZoomingEnabled : (this._private.userZoomingEnabled = !!e, this);
	}, "userZoomingEnabled"),
	boxSelectionEnabled: h(function(e) {
		return void 0 === e ? this._private.boxSelectionEnabled : (this._private.boxSelectionEnabled = !!e, this);
	}, "boxSelectionEnabled"),
	pan: h(function() {
		var e, t, r, i, n, a = arguments, s = this._private.pan;
		switch (a.length) {
			case 0: return s;
			case 1:
				if (Dq(a[0])) return s[e = a[0]];
				if (DY(a[0])) {
					if (!this._private.panningEnabled) return this;
					i = (r = a[0]).x, n = r.y, DH(i) && (s.x = i), DH(n) && (s.y = n), this.emit("pan viewport");
				}
				break;
			case 2:
				if (!this._private.panningEnabled) return this;
				e = a[0], t = a[1], ("x" === e || "y" === e) && DH(t) && (s[e] = t), this.emit("pan viewport");
		}
		return this.notify("viewport"), this;
	}, "pan"),
	panBy: h(function(e, t) {
		var r, i, n, a = arguments, s = this._private.pan;
		if (!this._private.panningEnabled) return this;
		switch (a.length) {
			case 1:
				DY(e) && (i = (r = a[0]).x, n = r.y, DH(i) && (s.x += i), DH(n) && (s.y += n), this.emit("pan viewport"));
				break;
			case 2: ("x" === e || "y" === e) && DH(t) && (s[e] += t), this.emit("pan viewport");
		}
		return this.notify("viewport"), this;
	}, "panBy"),
	gc: h(function() {
		this.notify("gc");
	}, "gc"),
	fit: h(function(e, t) {
		var r = this.getFitViewport(e, t);
		if (r) {
			var i = this._private;
			i.zoom = r.zoom, i.pan = r.pan, this.emit("pan zoom viewport"), this.notify("viewport");
		}
		return this;
	}, "fit"),
	getFitViewport: h(function(e, t) {
		if (DH(e) && void 0 === t && (t = e, e = void 0), !(!this._private.panningEnabled || !this._private.zoomingEnabled)) {
			var r;
			if (Dq(e)) {
				var i = e;
				e = this.$(i);
			} else if (D3(e)) {
				var n = e;
				(r = {
					x1: n.x1,
					y1: n.y1,
					x2: n.x2,
					y2: n.y2
				}).w = r.x2 - r.x1, r.h = r.y2 - r.y1;
			} else DZ(e) || (e = this.mutableElements());
			if (!(DZ(e) && e.empty())) {
				r = r || e.boundingBox();
				var a, s = this.width(), o = this.height();
				if (t = DH(t) ? t : 0, !isNaN(s) && !isNaN(o) && s > 0 && o > 0 && !isNaN(r.w) && !isNaN(r.h) && r.w > 0 && r.h > 0) {
					a = (a = (a = Math.min((s - 2 * t) / r.w, (o - 2 * t) / r.h)) > this._private.maxZoom ? this._private.maxZoom : a) < this._private.minZoom ? this._private.minZoom : a;
					var l = {
						x: (s - a * (r.x1 + r.x2)) / 2,
						y: (o - a * (r.y1 + r.y2)) / 2
					};
					return {
						zoom: a,
						pan: l
					};
				}
			}
		}
	}, "getFitViewport"),
	zoomRange: h(function(e, t) {
		var r = this._private;
		if (null == t) {
			var i = e;
			e = i.min, t = i.max;
		}
		return DH(e) && DH(t) && e <= t ? (r.minZoom = e, r.maxZoom = t) : DH(e) && void 0 === t && e <= r.maxZoom ? r.minZoom = e : DH(t) && void 0 === e && t >= r.minZoom && (r.maxZoom = t), this;
	}, "zoomRange"),
	minZoom: h(function(e) {
		return void 0 === e ? this._private.minZoom : this.zoomRange({ min: e });
	}, "minZoom"),
	maxZoom: h(function(e) {
		return void 0 === e ? this._private.maxZoom : this.zoomRange({ max: e });
	}, "maxZoom"),
	getZoomedViewport: h(function(e) {
		var t, r, i = this._private, n = i.pan, a = i.zoom, s = !1;
		if (i.zoomingEnabled || (s = !0), DH(e) ? r = e : DY(e) && (r = e.level, null != e.position ? t = Po(e.position, a, n) : null != e.renderedPosition && (t = e.renderedPosition), null == t || i.panningEnabled || (s = !0)), r = (r = r > i.maxZoom ? i.maxZoom : r) < i.minZoom ? i.minZoom : r, s || !DH(r) || r === a || null != t && (!DH(t.x) || !DH(t.y))) return null;
		if (null == t) return {
			zoomed: !0,
			panned: !1,
			zoom: r,
			pan: n
		};
		var o = r;
		return {
			zoomed: !0,
			panned: !0,
			zoom: o,
			pan: {
				x: -o / a * (t.x - n.x) + t.x,
				y: -o / a * (t.y - n.y) + t.y
			}
		};
	}, "getZoomedViewport"),
	zoom: h(function(e) {
		if (void 0 === e) return this._private.zoom;
		var t = this.getZoomedViewport(e), r = this._private;
		return null != t && t.zoomed && (r.zoom = t.zoom, t.panned && (r.pan.x = t.pan.x, r.pan.y = t.pan.y), this.emit("zoom" + (t.panned ? " pan" : "") + " viewport"), this.notify("viewport")), this;
	}, "zoom"),
	viewport: h(function(e) {
		var t = this._private, r = !0, i = !0, n = [], a = !1, s = !1;
		if (!e || (DH(e.zoom) || (r = !1), DY(e.pan) || (i = !1), !r && !i)) return this;
		if (r) {
			var o = e.zoom;
			o < t.minZoom || o > t.maxZoom || !t.zoomingEnabled ? a = !0 : (t.zoom = o, n.push("zoom"));
		}
		if (i && (!a || !e.cancelOnFailedZoom) && t.panningEnabled) {
			var l = e.pan;
			DH(l.x) && (t.pan.x = l.x, s = !1), DH(l.y) && (t.pan.y = l.y, s = !1), s || n.push("pan");
		}
		return n.length > 0 && (n.push("viewport"), this.emit(n.join(" ")), this.notify("viewport")), this;
	}, "viewport"),
	center: h(function(e) {
		var t = this.getCenterPan(e);
		return t && (this._private.pan = t, this.emit("pan viewport"), this.notify("viewport")), this;
	}, "center"),
	getCenterPan: h(function(e, t) {
		if (this._private.panningEnabled) {
			if (Dq(e)) {
				var r = e;
				e = this.mutableElements().filter(r);
			} else DZ(e) || (e = this.mutableElements());
			if (0 !== e.length) {
				var i = e.boundingBox(), n = this.width(), a = this.height();
				return {
					x: (n - (t = void 0 === t ? this._private.zoom : t) * (i.x1 + i.x2)) / 2,
					y: (a - t * (i.y1 + i.y2)) / 2
				};
			}
		}
	}, "getCenterPan"),
	reset: h(function() {
		return this._private.panningEnabled && this._private.zoomingEnabled && this.viewport({
			pan: {
				x: 0,
				y: 0
			},
			zoom: 1
		}), this;
	}, "reset"),
	invalidateSize: h(function() {
		this._private.sizeCache = null;
	}, "invalidateSize"),
	size: h(function() {
		var e, t, r = this._private, i = r.container;
		return r.sizeCache = r.sizeCache || (i ? (e = this.window().getComputedStyle(i), t = h(function(t) {
			return parseFloat(e.getPropertyValue(t));
		}, "val"), {
			width: i.clientWidth - t("padding-left") - t("padding-right"),
			height: i.clientHeight - t("padding-top") - t("padding-bottom")
		}) : {
			width: 1,
			height: 1
		});
	}, "size"),
	width: h(function() {
		return this.size().width;
	}, "width"),
	height: h(function() {
		return this.size().height;
	}, "height"),
	extent: h(function() {
		var e = this._private.pan, t = this._private.zoom, r = this.renderedExtent(), i = {
			x1: (r.x1 - e.x) / t,
			x2: (r.x2 - e.x) / t,
			y1: (r.y1 - e.y) / t,
			y2: (r.y2 - e.y) / t
		};
		return i.w = i.x2 - i.x1, i.h = i.y2 - i.y1, i;
	}, "extent"),
	renderedExtent: h(function() {
		var e = this.width(), t = this.height();
		return {
			x1: 0,
			y1: 0,
			x2: e,
			y2: t,
			w: e,
			h: t
		};
	}, "renderedExtent"),
	multiClickDebounceTime: h(function(e) {
		return e ? (this._private.multiClickDebounceTime = e, this) : this._private.multiClickDebounceTime;
	}, "multiClickDebounceTime")
};
ji.centre = ji.center, ji.autolockNodes = ji.autolock, ji.autoungrabifyNodes = ji.autoungrabify;
var jn = {
	data: UH.data({
		field: "data",
		bindingEvent: "data",
		allowBinding: !0,
		allowSetting: !0,
		settingEvent: "data",
		settingTriggersEvent: !0,
		triggerFnName: "trigger",
		allowGetting: !0,
		updateStyle: !0
	}),
	removeData: UH.removeData({
		field: "data",
		event: "data",
		triggerFnName: "trigger",
		triggerEvent: !0,
		updateStyle: !0
	}),
	scratch: UH.data({
		field: "scratch",
		bindingEvent: "scratch",
		allowBinding: !0,
		allowSetting: !0,
		settingEvent: "scratch",
		settingTriggersEvent: !0,
		triggerFnName: "trigger",
		allowGetting: !0,
		updateStyle: !0
	}),
	removeScratch: UH.removeData({
		field: "scratch",
		event: "scratch",
		triggerFnName: "trigger",
		triggerEvent: !0,
		updateStyle: !0
	})
};
jn.attr = jn.data, jn.removeAttr = jn.removeData;
var ja = h(function(e) {
	var t = this, r = (e = Ou({}, e)).container;
	r && !DK(r) && DK(r[0]) && (r = r[0]);
	var i = r ? r._cyreg : null;
	(i = i || {}).cy && (i.cy.destroy(), i = {});
	var n = i.readies = i.readies || [];
	r && (r._cyreg = i), i.cy = t;
	var a = void 0 !== D$ && void 0 !== r && !e.headless, s = e;
	s.layout = Ou({ name: a ? "grid" : "null" }, s.layout), s.renderer = Ou({ name: a ? "canvas" : "null" }, s.renderer);
	var o = h(function(e, t, r) {
		return void 0 !== t ? t : void 0 !== r ? r : e;
	}, "defVal"), l = this._private = {
		container: r,
		ready: !1,
		options: s,
		elements: new qI(this),
		listeners: [],
		aniEles: new qI(this),
		data: s.data || {},
		scratch: {},
		layout: null,
		renderer: null,
		destroyed: !1,
		notificationsEnabled: !0,
		minZoom: 1e-50,
		maxZoom: 1e50,
		zoomingEnabled: o(!0, s.zoomingEnabled),
		userZoomingEnabled: o(!0, s.userZoomingEnabled),
		panningEnabled: o(!0, s.panningEnabled),
		userPanningEnabled: o(!0, s.userPanningEnabled),
		boxSelectionEnabled: o(!0, s.boxSelectionEnabled),
		autolock: o(!1, s.autolock, s.autolockNodes),
		autoungrabify: o(!1, s.autoungrabify, s.autoungrabifyNodes),
		autounselectify: o(!1, s.autounselectify),
		styleEnabled: void 0 === s.styleEnabled ? a : s.styleEnabled,
		zoom: DH(s.zoom) ? s.zoom : 1,
		pan: {
			x: DY(s.pan) && DH(s.pan.x) ? s.pan.x : 0,
			y: DY(s.pan) && DH(s.pan.y) ? s.pan.y : 0
		},
		animation: {
			current: [],
			queue: []
		},
		hasCompoundNodes: !1,
		multiClickDebounceTime: o(250, s.multiClickDebounceTime)
	};
	this.createEmitter(), this.selectionType(s.selectionType), this.zoomRange({
		min: s.minZoom,
		max: s.maxZoom
	});
	var u = h(function(e, t) {
		if (e.some(D6)) return Fm.all(e).then(t);
		t(e);
	}, "loadExtData");
	l.styleEnabled && t.setStyle([]);
	var d = Ou({}, s, s.renderer);
	t.initRenderer(d);
	var p = h(function(e, r, i) {
		t.notifications(!1);
		var n = t.mutableElements();
		n.length > 0 && n.remove(), null != e && (DY(e) || DW(e)) && t.add(e), t.one("layoutready", function(e) {
			t.notifications(!0), t.emit(e), t.one("load", r), t.emitAndNotify("load");
		}).one("layoutstop", function() {
			t.one("done", i), t.emit("done");
		});
		var a = Ou({}, t._private.options.layout);
		a.eles = t.elements(), t.layout(a).run();
	}, "setElesAndLayout");
	u([s.style, s.elements], function(e) {
		var r = e[0], a = e[1];
		l.styleEnabled && t.style().append(r), p(a, function() {
			t.startAnimationLoop(), l.ready = !0, Dj(s.ready) && t.on("ready", s.ready);
			for (var e = 0; e < n.length; e++) {
				var r = n[e];
				t.on("ready", r);
			}
			i && (i.readies = []), t.emit("ready");
		}, s.done);
	});
}, "Core"), js = ja.prototype;
Ou(js, {
	instanceString: h(function() {
		return "core";
	}, "instanceString"),
	isReady: h(function() {
		return this._private.ready;
	}, "isReady"),
	destroyed: h(function() {
		return this._private.destroyed;
	}, "destroyed"),
	ready: h(function(e) {
		return this.isReady() ? this.emitter().emit("ready", [], e) : this.on("ready", e), this;
	}, "ready"),
	destroy: h(function() {
		if (!this.destroyed()) return this.stopAnimationLoop(), this.destroyRenderer(), this.emit("destroy"), this._private.destroyed = !0, this;
	}, "destroy"),
	hasElementWithId: h(function(e) {
		return this._private.elements.hasElementWithId(e);
	}, "hasElementWithId"),
	getElementById: h(function(e) {
		return this._private.elements.getElementById(e);
	}, "getElementById"),
	hasCompoundNodes: h(function() {
		return this._private.hasCompoundNodes;
	}, "hasCompoundNodes"),
	headless: h(function() {
		return this._private.renderer.isHeadless();
	}, "headless"),
	styleEnabled: h(function() {
		return this._private.styleEnabled;
	}, "styleEnabled"),
	addToPool: h(function(e) {
		return this._private.elements.merge(e), this;
	}, "addToPool"),
	removeFromPool: h(function(e) {
		return this._private.elements.unmerge(e), this;
	}, "removeFromPool"),
	container: h(function() {
		return this._private.container || null;
	}, "container"),
	window: h(function() {
		if (null == this._private.container) return D$;
		var e = this._private.container.ownerDocument;
		return void 0 === e || null == e ? D$ : e.defaultView || D$;
	}, "window"),
	mount: h(function(e) {
		if (null != e) {
			var t = this._private, r = t.options;
			return !DK(e) && DK(e[0]) && (e = e[0]), this.stopAnimationLoop(), this.destroyRenderer(), t.container = e, t.styleEnabled = !0, this.invalidateSize(), this.initRenderer(Ou({}, r, r.renderer, { name: "null" === r.renderer.name ? "canvas" : r.renderer.name })), this.startAnimationLoop(), this.style(r.style), this.emit("mount"), this;
		}
	}, "mount"),
	unmount: h(function() {
		return this.stopAnimationLoop(), this.destroyRenderer(), this.initRenderer({ name: "null" }), this.emit("unmount"), this;
	}, "unmount"),
	options: h(function() {
		return $r(this._private.options);
	}, "options"),
	json: h(function(e) {
		var t = this, r = t._private, i = t.mutableElements(), n = h(function(e) {
			return t.getElementById(e.id());
		}, "getFreshRef");
		if (DY(e)) {
			if (t.startBatch(), e.elements) {
				var a = {}, s = h(function(e, r) {
					for (var i = [], n = [], s = 0; s < e.length; s++) {
						var o = e[s];
						if (!o.data.id) {
							$e("cy.json() cannot handle elements without an ID attribute");
							continue;
						}
						var l = "" + o.data.id, h = t.getElementById(l);
						a[l] = !0, 0 !== h.length ? n.push({
							ele: h,
							json: o
						}) : (r && (o.group = r), i.push(o));
					}
					t.add(i);
					for (var u = 0; u < n.length; u++) {
						var d = n[u], p = d.ele, f = d.json;
						p.json(f);
					}
				}, "updateEles");
				if (DW(e.elements)) s(e.elements);
				else for (var o = ["nodes", "edges"], l = 0; l < o.length; l++) {
					var u = o[l], d = e.elements[u];
					DW(d) && s(d, u);
				}
				var p = t.collection();
				i.filter(function(e) {
					return !a[e.id()];
				}).forEach(function(e) {
					e.isParent() ? p.merge(e) : e.remove();
				}), p.forEach(function(e) {
					return e.children().move({ parent: null });
				}), p.forEach(function(e) {
					return n(e).remove();
				});
			}
			e.style && t.style(e.style), null != e.zoom && e.zoom !== r.zoom && t.zoom(e.zoom), e.pan && (e.pan.x !== r.pan.x || e.pan.y !== r.pan.y) && t.pan(e.pan), e.data && t.data(e.data);
			for (var f = [
				"minZoom",
				"maxZoom",
				"zoomingEnabled",
				"userZoomingEnabled",
				"panningEnabled",
				"userPanningEnabled",
				"boxSelectionEnabled",
				"autolock",
				"autoungrabify",
				"autounselectify",
				"multiClickDebounceTime"
			], g = 0; g < f.length; g++) {
				var m = f[g];
				null != e[m] && t[m](e[m]);
			}
			return t.endBatch(), this;
		}
		var y = {};
		e ? y.elements = this.elements().map(function(e) {
			return e.json();
		}) : (y.elements = {}, i.forEach(function(e) {
			var t = e.group();
			y.elements[t] || (y.elements[t] = []), y.elements[t].push(e.json());
		})), this._private.styleEnabled && (y.style = t.style().json()), y.data = $r(t.data());
		var v = r.options;
		return y.zoomingEnabled = r.zoomingEnabled, y.userZoomingEnabled = r.userZoomingEnabled, y.zoom = r.zoom, y.minZoom = r.minZoom, y.maxZoom = r.maxZoom, y.panningEnabled = r.panningEnabled, y.userPanningEnabled = r.userPanningEnabled, y.pan = $r(r.pan), y.boxSelectionEnabled = r.boxSelectionEnabled, y.renderer = $r(v.renderer), y.hideEdgesOnViewport = v.hideEdgesOnViewport, y.textureOnViewport = v.textureOnViewport, y.wheelSensitivity = v.wheelSensitivity, y.motionBlur = v.motionBlur, y.multiClickDebounceTime = v.multiClickDebounceTime, y;
	}, "json")
}), js.$id = js.getElementById, [
	qD,
	qY,
	qX,
	qK,
	qZ,
	qQ,
	q0,
	q1,
	jr,
	ji,
	jn
].forEach(function(e) {
	Ou(js, e);
});
var jo = {
	fit: !0,
	directed: !1,
	direction: "downward",
	padding: 30,
	circle: !1,
	grid: !1,
	spacingFactor: 1.75,
	boundingBox: void 0,
	avoidOverlap: !0,
	nodeDimensionsIncludeLabels: !1,
	roots: void 0,
	depthSort: void 0,
	animate: !1,
	animationDuration: 500,
	animationEasing: void 0,
	animateFilter: h(function(e, t) {
		return !0;
	}, "animateFilter"),
	ready: void 0,
	stop: void 0,
	transform: h(function(e, t) {
		return t;
	}, "transform")
}, jl = {
	maximal: !1,
	acyclic: !1
}, jc = h(function(e) {
	return e.scratch("breadthfirst");
}, "getInfo"), jh = h(function(e, t) {
	return e.scratch("breadthfirst", t);
}, "setInfo");
function ju(e) {
	this.options = Ou({}, jo, jl, e);
}
h(ju, "BreadthFirstLayout"), ju.prototype.run = function() {
	var e, t = this.options, r = t.cy, i = t.eles, n = i.nodes().filter(function(e) {
		return e.isChildless();
	}), a = t.directed, s = t.acyclic || t.maximal || t.maximalAdjustments > 0, o = !!t.boundingBox, l = PE(o ? t.boundingBox : structuredClone(r.extent()));
	if (DZ(t.roots)) e = t.roots;
	else if (DW(t.roots)) {
		for (var u = [], d = 0; d < t.roots.length; d++) {
			var p = t.roots[d], f = r.getElementById(p);
			u.push(f);
		}
		e = r.collection(u);
	} else if (Dq(t.roots)) e = r.$(t.roots);
	else if (a) e = n.roots();
	else {
		var g = i.components();
		e = r.collection();
		for (var m = h(function() {
			var t = g[y], r = t.maxDegree(!1), i = t.filter(function(e) {
				return e.degree(!1) === r;
			});
			e = e.add(i);
		}, "_loop"), y = 0; y < g.length; y++) m();
	}
	var v = [], x = {}, b = h(function(e, t) {
		v[t] ?? (v[t] = []);
		var r = v[t].length;
		v[t].push(e), jh(e, {
			index: r,
			depth: t
		});
	}, "addToDepth"), w = h(function(e, t) {
		var r = jc(e), i = r.depth, n = r.index;
		v[i][n] = null, e.isChildless() && b(e, t);
	}, "changeDepth");
	i.bfs({
		roots: e,
		directed: t.directed,
		visit: h(function(e, t, r, i, n) {
			var a = e[0], s = a.id();
			a.isChildless() && b(a, n), x[s] = !0;
		}, "visit")
	});
	for (var k = [], T = 0; T < n.length; T++) {
		var _ = n[T];
		x[_.id()] || k.push(_);
	}
	var E = h(function(e) {
		for (var t = v[e], r = 0; r < t.length; r++) {
			var i = t[r];
			if (null == i) {
				t.splice(r, 1), r--;
				continue;
			}
			jh(i, {
				depth: e,
				index: r
			});
		}
	}, "assignDepthsAt"), C = h(function(e, r) {
		for (var n = jc(e), a = e.incomers().filter(function(e) {
			return e.isNode() && i.has(e);
		}), s = -1, o = e.id(), l = 0; l < a.length; l++) s = Math.max(s, jc(a[l]).depth);
		if (n.depth <= s) {
			if (!t.acyclic && r[o]) return null;
			var h = s + 1;
			return w(e, h), r[o] = h, !0;
		}
		return !1;
	}, "adjustMaximally");
	if (a && s) {
		var S = [], A = {}, L = h(function(e) {
			return S.push(e);
		}, "enqueue"), R = h(function() {
			return S.shift();
		}, "dequeue");
		for (n.forEach(function(e) {
			return S.push(e);
		}); S.length > 0;) {
			var N = R(), I = C(N, A);
			if (I) N.outgoers().filter(function(e) {
				return e.isNode() && i.has(e);
			}).forEach(L);
			else if (null === I) {
				$e("Detected double maximal shift for node `" + N.id() + "`.  Bailing maximal adjustment due to cycle.  Use `options.maximal: true` only on DAGs.");
				break;
			}
		}
	}
	var M = 0;
	if (t.avoidOverlap) for (var D = 0; D < n.length; D++) {
		var O = n[D].layoutDimensions(t), $ = O.w, P = O.h;
		M = Math.max(M, $, P);
	}
	var B = {}, F = h(function(e) {
		if (B[e.id()]) return B[e.id()];
		for (var t = jc(e).depth, r = e.neighborhood(), i = 0, a = 0, s = 0; s < r.length; s++) {
			var o = r[s];
			if (!(o.isEdge() || o.isParent() || !n.has(o))) {
				var l = jc(o);
				if (null != l) {
					var h = l.index, u = l.depth;
					if (null != h && null != u) {
						var d = v[u].length;
						u < t && (i += h / d, a++);
					}
				}
			}
		}
		return i /= a = Math.max(1, a), 0 === a && (i = 0), B[e.id()] = i, i;
	}, "getWeightedPercent"), z = h(function(e, t) {
		var r = F(e) - F(t);
		return 0 === r ? Oc(e.id(), t.id()) : r;
	}, "sortFn");
	void 0 !== t.depthSort && (z = t.depthSort);
	for (var U = v.length, G = 0; G < U; G++) v[G].sort(z), E(G);
	for (var q = [], j = 0; j < k.length; j++) q.push(k[j]);
	var W = h(function() {
		for (var e = 0; e < U; e++) E(e);
	}, "assignDepths");
	q.length && (v.unshift(q), U = v.length, W());
	for (var Y = 0, V = 0; V < U; V++) Y = Math.max(v[V].length, Y);
	var H = {
		x: l.x1 + l.w / 2,
		y: l.y1 + l.h / 2
	}, X = n.reduce(function(e, r) {
		var i;
		return i = r.boundingBox({ includeLabels: t.nodeDimensionsIncludeLabels }), {
			w: -1 === e.w ? i.w : (e.w + i.w) / 2,
			h: -1 === e.h ? i.h : (e.h + i.h) / 2
		};
	}, {
		w: -1,
		h: -1
	}), K = Math.max(1 === U ? 0 : o ? (l.h - 2 * t.padding - X.h) / (U - 1) : (l.h - 2 * t.padding - X.h) / (U + 1), M), Z = v.reduce(function(e, t) {
		return Math.max(e, t.length);
	}, 0), Q = h(function(e) {
		var r = jc(e), i = r.depth, n = r.index;
		if (t.circle) {
			var a = Math.min(l.w / 2 / U, l.h / 2 / U), s = (a = Math.max(a, M)) * i + a - (U > 0 && v[0].length <= 3 ? a / 2 : 0), h = 2 * Math.PI / v[i].length * n;
			return 0 === i && 1 === v[0].length && (s = 1), {
				x: H.x + s * Math.cos(h),
				y: H.y + s * Math.sin(h)
			};
		}
		var u = v[i].length, d = Math.max(1 === u ? 0 : o ? (l.w - 2 * t.padding - X.w) / ((t.grid ? Z : u) - 1) : (l.w - 2 * t.padding - X.w) / ((t.grid ? Z : u) + 1), M);
		return {
			x: H.x + (n + 1 - (u + 1) / 2) * d,
			y: H.y + (i + 1 - (U + 1) / 2) * K
		};
	}, "getPositionTopBottom"), J = {
		downward: 0,
		leftward: 90,
		upward: 180,
		rightward: -90
	};
	-1 === Object.keys(J).indexOf(t.direction) && O8("Invalid direction '".concat(t.direction, "' specified for breadthfirst layout. Valid values are: ").concat(Object.keys(J).join(", ")));
	var ee = h(function(e) {
		return OJ(Q(e), l, J[t.direction]);
	}, "getPosition");
	return i.nodes().layoutPositions(this, t, ee), this;
};
var jd = {
	fit: !0,
	padding: 30,
	boundingBox: void 0,
	avoidOverlap: !0,
	nodeDimensionsIncludeLabels: !1,
	spacingFactor: void 0,
	radius: void 0,
	startAngle: 1.5 * Math.PI,
	sweep: void 0,
	clockwise: !0,
	sort: void 0,
	animate: !1,
	animationDuration: 500,
	animationEasing: void 0,
	animateFilter: h(function(e, t) {
		return !0;
	}, "animateFilter"),
	ready: void 0,
	stop: void 0,
	transform: h(function(e, t) {
		return t;
	}, "transform")
};
function jp(e) {
	this.options = Ou({}, jd, e);
}
h(jp, "CircleLayout"), jp.prototype.run = function() {
	var e = this.options, t = e.cy, r = e.eles, i = void 0 !== e.counterclockwise ? !e.counterclockwise : e.clockwise, n = r.nodes().not(":parent");
	e.sort && (n = n.sort(e.sort));
	for (var a, s = PE(e.boundingBox ? e.boundingBox : {
		x1: 0,
		y1: 0,
		w: t.width(),
		h: t.height()
	}), o = {
		x: s.x1 + s.w / 2,
		y: s.y1 + s.h / 2
	}, l = (void 0 === e.sweep ? 2 * Math.PI - 2 * Math.PI / n.length : e.sweep) / Math.max(1, n.length - 1), u = 0, d = 0; d < n.length; d++) {
		var p = n[d].layoutDimensions(e);
		u = Math.max(u, p.w, p.h);
	}
	if (a = DH(e.radius) ? e.radius : n.length <= 1 ? 0 : Math.min(s.h, s.w) / 2 - u, n.length > 1 && e.avoidOverlap) {
		var f = Math.cos(l) - 1, g = Math.sin(l) - 0;
		a = Math.max(Math.sqrt((u *= 1.75) * u / (f * f + g * g)), a);
	}
	var m = h(function(t, r) {
		var n = e.startAngle + r * l * (i ? 1 : -1), s = a * Math.cos(n), h = a * Math.sin(n);
		return {
			x: o.x + s,
			y: o.y + h
		};
	}, "getPos");
	return r.nodes().layoutPositions(this, e, m), this;
};
var jf = {
	fit: !0,
	padding: 30,
	startAngle: 1.5 * Math.PI,
	sweep: void 0,
	clockwise: !0,
	equidistant: !1,
	minNodeSpacing: 10,
	boundingBox: void 0,
	avoidOverlap: !0,
	nodeDimensionsIncludeLabels: !1,
	height: void 0,
	width: void 0,
	spacingFactor: void 0,
	concentric: h(function(e) {
		return e.degree();
	}, "concentric"),
	levelWidth: h(function(e) {
		return e.maxDegree() / 4;
	}, "levelWidth"),
	animate: !1,
	animationDuration: 500,
	animationEasing: void 0,
	animateFilter: h(function(e, t) {
		return !0;
	}, "animateFilter"),
	ready: void 0,
	stop: void 0,
	transform: h(function(e, t) {
		return t;
	}, "transform")
};
function jg(e) {
	this.options = Ou({}, jf, e);
}
h(jg, "ConcentricLayout"), jg.prototype.run = function() {
	for (var e = this.options, t = void 0 !== e.counterclockwise ? !e.counterclockwise : e.clockwise, r = e.cy, i = e.eles, n = i.nodes().not(":parent"), a = PE(e.boundingBox ? e.boundingBox : {
		x1: 0,
		y1: 0,
		w: r.width(),
		h: r.height()
	}), s = {
		x: a.x1 + a.w / 2,
		y: a.y1 + a.h / 2
	}, o = [], l = 0, h = 0; h < n.length; h++) {
		var u = n[h], d = void 0;
		d = e.concentric(u), o.push({
			value: d,
			node: u
		}), u._private.scratch.concentric = d;
	}
	n.updateStyle();
	for (var p = 0; p < n.length; p++) {
		var f = n[p].layoutDimensions(e);
		l = Math.max(l, f.w, f.h);
	}
	o.sort(function(e, t) {
		return t.value - e.value;
	});
	for (var g = e.levelWidth(n), m = [[]], y = m[0], v = 0; v < o.length; v++) {
		var x = o[v];
		y.length > 0 && Math.abs(y[0].value - x.value) >= g && (y = [], m.push(y)), y.push(x);
	}
	var b = l + e.minNodeSpacing;
	if (!e.avoidOverlap) {
		var w = m.length > 0 && m[0].length > 1, k = (Math.min(a.w, a.h) / 2 - b) / (m.length + w ? 1 : 0);
		b = Math.min(b, k);
	}
	for (var T = 0, _ = 0; _ < m.length; _++) {
		var E = m[_], C = E.dTheta = (void 0 === e.sweep ? 2 * Math.PI - 2 * Math.PI / E.length : e.sweep) / Math.max(1, E.length - 1);
		if (E.length > 1 && e.avoidOverlap) {
			var S = Math.cos(C) - 1, A = Math.sin(C) - 0;
			T = Math.max(Math.sqrt(b * b / (S * S + A * A)), T);
		}
		E.r = T, T += b;
	}
	if (e.equidistant) {
		for (var L = 0, R = 0, N = 0; N < m.length; N++) L = Math.max(L, m[N].r - R);
		R = 0;
		for (var I = 0; I < m.length; I++) {
			var M = m[I];
			0 === I && (R = M.r), M.r = R, R += L;
		}
	}
	for (var D = {}, O = 0; O < m.length; O++) for (var $ = m[O], P = $.dTheta, B = $.r, F = 0; F < $.length; F++) {
		var z = $[F], U = e.startAngle + (t ? 1 : -1) * P * F, G = {
			x: s.x + B * Math.cos(U),
			y: s.y + B * Math.sin(U)
		};
		D[z.node.id()] = G;
	}
	return i.nodes().layoutPositions(this, e, function(e) {
		return D[e.id()];
	}), this;
};
var jm, jy = {
	ready: h(function() {}, "ready"),
	stop: h(function() {}, "stop"),
	animate: !0,
	animationEasing: void 0,
	animationDuration: void 0,
	animateFilter: h(function(e, t) {
		return !0;
	}, "animateFilter"),
	animationThreshold: 250,
	refresh: 20,
	fit: !0,
	padding: 30,
	boundingBox: void 0,
	nodeDimensionsIncludeLabels: !1,
	randomize: !1,
	componentSpacing: 40,
	nodeRepulsion: h(function(e) {
		return 2048;
	}, "nodeRepulsion"),
	nodeOverlap: 4,
	idealEdgeLength: h(function(e) {
		return 32;
	}, "idealEdgeLength"),
	edgeElasticity: h(function(e) {
		return 32;
	}, "edgeElasticity"),
	nestingFactor: 1.2,
	gravity: 1,
	numIter: 1e3,
	initialTemp: 1e3,
	coolingFactor: .99,
	minTemp: 1
};
function jv(e) {
	this.options = Ou({}, jy, e), this.options.layout = this;
	var t = this.options.eles.nodes(), r = this.options.eles.edges().filter(function(e) {
		var r = e.source().data("id"), i = e.target().data("id"), n = t.some(function(e) {
			return e.data("id") === r;
		}), a = t.some(function(e) {
			return e.data("id") === i;
		});
		return !n || !a;
	});
	this.options.eles = this.options.eles.not(r);
}
h(jv, "CoseLayout"), jv.prototype.run = function() {
	var e = this.options, t = e.cy, r = this;
	r.stopped = !1, (!0 === e.animate || !1 === e.animate) && r.emit({
		type: "layoutstart",
		layout: r
	}), jm = !0 === e.debug;
	var i = jb(t, r, e);
	jm && jx(i), e.randomize && jT(i);
	var n = OB(), a = h(function() {
		jE(i, t, e), !0 === e.fit && t.fit(e.padding);
	}, "refresh"), s = h(function(t) {
		return !(r.stopped || t >= e.numIter || (jC(i, e), i.temperature = i.temperature * e.coolingFactor, i.temperature < e.minTemp));
	}, "mainLoop"), o = h(function() {
		if (!0 === e.animate || !1 === e.animate) a(), r.one("layoutstop", e.stop), r.emit({
			type: "layoutstop",
			layout: r
		});
		else {
			var t = e.eles.nodes(), n = j_(i, e, t);
			t.layoutPositions(r, e, n);
		}
	}, "done"), l = 0, u = !0;
	if (!0 === e.animate) {
		var d = h(function() {
			for (var t = 0; u && t < e.refresh;) u = s(l), l++, t++;
			u ? (OB() - n >= e.animationThreshold && a(), Oz(d)) : (jB(i, e), o());
		}, "frame");
		d();
	} else {
		for (; u;) u = s(l), l++;
		jB(i, e), o();
	}
	return this;
}, jv.prototype.stop = function() {
	return this.stopped = !0, this.thread && this.thread.stop(), this.emit("layoutstop"), this;
}, jv.prototype.destroy = function() {
	return this.thread && this.thread.stop(), this;
};
var jx, jb = h(function(e, t, r) {
	for (var i = r.eles.edges(), n = r.eles.nodes(), a = PE(r.boundingBox ? r.boundingBox : {
		x1: 0,
		y1: 0,
		w: e.width(),
		h: e.height()
	}), s = {
		isCompound: e.hasCompoundNodes(),
		layoutNodes: [],
		idToIndex: {},
		nodeSize: n.size(),
		graphSet: [],
		indexToGraph: [],
		layoutEdges: [],
		edgeSize: i.size(),
		temperature: r.initialTemp,
		clientWidth: a.w,
		clientHeight: a.h,
		boundingBox: a
	}, o = r.eles.components(), l = {}, h = 0; h < o.length; h++) for (var u = o[h], d = 0; d < u.length; d++) {
		var p = u[d];
		l[p.id()] = h;
	}
	for (var h = 0; h < s.nodeSize; h++) {
		var f = n[h], g = f.layoutDimensions(r), m = {};
		m.isLocked = f.locked(), m.id = f.data("id"), m.parentId = f.data("parent"), m.cmptId = l[f.id()], m.children = [], m.positionX = f.position("x"), m.positionY = f.position("y"), m.offsetX = 0, m.offsetY = 0, m.height = g.w, m.width = g.h, m.maxX = m.positionX + m.width / 2, m.minX = m.positionX - m.width / 2, m.maxY = m.positionY + m.height / 2, m.minY = m.positionY - m.height / 2, m.padLeft = parseFloat(f.style("padding")), m.padRight = parseFloat(f.style("padding")), m.padTop = parseFloat(f.style("padding")), m.padBottom = parseFloat(f.style("padding")), m.nodeRepulsion = Dj(r.nodeRepulsion) ? r.nodeRepulsion(f) : r.nodeRepulsion, s.layoutNodes.push(m), s.idToIndex[m.id] = h;
	}
	for (var y = [], v = 0, x = -1, b = [], h = 0; h < s.nodeSize; h++) {
		var f = s.layoutNodes[h], w = f.parentId;
		null != w ? s.layoutNodes[s.idToIndex[w]].children.push(f.id) : (y[++x] = f.id, b.push(f.id));
	}
	for (s.graphSet.push(b); v <= x;) {
		var k = y[v++], T = s.idToIndex[k], p = s.layoutNodes[T], _ = p.children;
		if (_.length > 0) {
			s.graphSet.push(_);
			for (var h = 0; h < _.length; h++) y[++x] = _[h];
		}
	}
	for (var h = 0; h < s.graphSet.length; h++) for (var E = s.graphSet[h], d = 0; d < E.length; d++) {
		var C = s.idToIndex[E[d]];
		s.indexToGraph[C] = h;
	}
	for (var h = 0; h < s.edgeSize; h++) {
		var S = i[h], A = {};
		A.id = S.data("id"), A.sourceId = S.data("source"), A.targetId = S.data("target");
		var L = Dj(r.idealEdgeLength) ? r.idealEdgeLength(S) : r.idealEdgeLength, R = Dj(r.edgeElasticity) ? r.edgeElasticity(S) : r.edgeElasticity, N = s.idToIndex[A.sourceId], I = s.idToIndex[A.targetId];
		if (s.indexToGraph[N] != s.indexToGraph[I]) {
			for (var M = jw(A.sourceId, A.targetId, s), D = s.graphSet[M], O = 0, m = s.layoutNodes[N]; -1 === D.indexOf(m.id);) m = s.layoutNodes[s.idToIndex[m.parentId]], O++;
			for (m = s.layoutNodes[I]; -1 === D.indexOf(m.id);) m = s.layoutNodes[s.idToIndex[m.parentId]], O++;
			L *= O * r.nestingFactor;
		}
		A.idealLength = L, A.elasticity = R, s.layoutEdges.push(A);
	}
	return s;
}, "createLayoutInfo"), jw = h(function(e, t, r) {
	var i = jk(e, t, 0, r);
	return 2 > i.count ? 0 : i.graph;
}, "findLCA"), jk = h(function(e, t, r, i) {
	var n = i.graphSet[r];
	if (-1 < n.indexOf(e) && -1 < n.indexOf(t)) return {
		count: 2,
		graph: r
	};
	for (var a = 0, s = 0; s < n.length; s++) {
		var o = n[s], l = i.idToIndex[o], h = i.layoutNodes[l].children;
		if (0 !== h.length) {
			var u = jk(e, t, i.indexToGraph[i.idToIndex[h[0]]], i);
			if (0 !== u.count) {
				if (1 !== u.count) return u;
				else if (2 == ++a) break;
			}
		}
	}
	return {
		count: a,
		graph: r
	};
}, "findLCA_aux"), jT = h(function(e, t) {
	for (var r = e.clientWidth, i = e.clientHeight, n = 0; n < e.nodeSize; n++) {
		var a = e.layoutNodes[n];
		0 !== a.children.length || a.isLocked || (a.positionX = Math.random() * r, a.positionY = Math.random() * i);
	}
}, "randomizePositions"), j_ = h(function(e, t, r) {
	var i = e.boundingBox, n = {
		x1: Infinity,
		x2: -Infinity,
		y1: Infinity,
		y2: -Infinity
	};
	return t.boundingBox && (r.forEach(function(t) {
		var r = e.layoutNodes[e.idToIndex[t.data("id")]];
		n.x1 = Math.min(n.x1, r.positionX), n.x2 = Math.max(n.x2, r.positionX), n.y1 = Math.min(n.y1, r.positionY), n.y2 = Math.max(n.y2, r.positionY);
	}), n.w = n.x2 - n.x1, n.h = n.y2 - n.y1), function(r, a) {
		var s = e.layoutNodes[e.idToIndex[r.data("id")]];
		if (!t.boundingBox) return {
			x: s.positionX,
			y: s.positionY
		};
		var o = 0 === n.w ? .5 : (s.positionX - n.x1) / n.w, l = 0 === n.h ? .5 : (s.positionY - n.y1) / n.h;
		return {
			x: i.x1 + o * i.w,
			y: i.y1 + l * i.h
		};
	};
}, "getScaleInBoundsFn"), jE = h(function(e, t, r) {
	var i = r.layout, n = r.eles.nodes(), a = j_(e, r, n);
	n.positions(a), !0 !== e.ready && (e.ready = !0, i.one("layoutready", r.ready), i.emit({
		type: "layoutready",
		layout: this
	}));
}, "refreshPositions"), jC = h(function(e, t, r) {
	jS(e, t), jI(e), jM(e, t), jD(e), jO(e);
}, "step"), jS = h(function(e, t) {
	for (var r = 0; r < e.graphSet.length; r++) for (var i = e.graphSet[r], n = i.length, a = 0; a < n; a++) for (var s = e.layoutNodes[e.idToIndex[i[a]]], o = a + 1; o < n; o++) jL(s, e.layoutNodes[e.idToIndex[i[o]]], e, t);
}, "calculateNodeForces"), jA = h(function(e) {
	return -1 + 2 * e * Math.random();
}, "randomDistance"), jL = h(function(e, t, r, i) {
	if (!(e.cmptId !== t.cmptId && !r.isCompound)) {
		var n = t.positionX - e.positionX, a = t.positionY - e.positionY;
		0 === n && 0 === a && (n = jA(1), a = jA(1));
		var s = jR(e, t, n, a);
		if (s > 0) var o = i.nodeOverlap * s, l = Math.sqrt(n * n + a * a), h = o * n / l, u = o * a / l;
		else var d = jN(e, n, a), p = jN(t, -1 * n, -1 * a), f = p.x - d.x, g = p.y - d.y, m = f * f + g * g, l = Math.sqrt(m), o = (e.nodeRepulsion + t.nodeRepulsion) / m, h = o * f / l, u = o * g / l;
		e.isLocked || (e.offsetX -= h, e.offsetY -= u), t.isLocked || (t.offsetX += h, t.offsetY += u);
	}
}, "nodeRepulsion"), jR = h(function(e, t, r, i) {
	if (r > 0) var n = e.maxX - t.minX;
	else var n = t.maxX - e.minX;
	if (i > 0) var a = e.maxY - t.minY;
	else var a = t.maxY - e.minY;
	return n >= 0 && a >= 0 ? Math.sqrt(n * n + a * a) : 0;
}, "nodesOverlap"), jN = h(function(e, t, r) {
	var i = e.positionX, n = e.positionY, a = e.height || 1, s = e.width || 1, o = r / t, l = a / s, h = {};
	return 0 === t && 0 < r || 0 === t && 0 > r ? (h.x = i, h.y = n + a / 2) : 0 < t && -1 * l <= o && o <= l ? (h.x = i + s / 2, h.y = n + s * r / 2 / t) : 0 > t && -1 * l <= o && o <= l ? (h.x = i - s / 2, h.y = n - s * r / 2 / t) : 0 < r && (o <= -1 * l || o >= l) ? (h.x = i + a * t / 2 / r, h.y = n + a / 2) : 0 > r && (o <= -1 * l || o >= l) && (h.x = i - a * t / 2 / r, h.y = n - a / 2), h;
}, "findClippingPoint"), jI = h(function(e, t) {
	for (var r = 0; r < e.edgeSize; r++) {
		var i = e.layoutEdges[r], n = e.idToIndex[i.sourceId], a = e.layoutNodes[n], s = e.idToIndex[i.targetId], o = e.layoutNodes[s], l = o.positionX - a.positionX, h = o.positionY - a.positionY;
		if (0 !== l || 0 !== h) {
			var u = jN(a, l, h), d = jN(o, -1 * l, -1 * h), p = d.x - u.x, f = d.y - u.y, g = Math.sqrt(p * p + f * f), m = Math.pow(i.idealLength - g, 2) / i.elasticity;
			if (0 !== g) var y = m * p / g, v = m * f / g;
			else var y = 0, v = 0;
			a.isLocked || (a.offsetX += y, a.offsetY += v), o.isLocked || (o.offsetX -= y, o.offsetY -= v);
		}
	}
}, "calculateEdgeForces"), jM = h(function(e, t) {
	if (0 !== t.gravity) for (var r = 0; r < e.graphSet.length; r++) {
		var i = e.graphSet[r], n = i.length;
		if (0 === r) var a = e.clientHeight / 2, s = e.clientWidth / 2;
		else var o = e.layoutNodes[e.idToIndex[i[0]]], l = e.layoutNodes[e.idToIndex[o.parentId]], a = l.positionX, s = l.positionY;
		for (var h = 0; h < n; h++) {
			var u = e.layoutNodes[e.idToIndex[i[h]]];
			if (!u.isLocked) {
				var d = a - u.positionX, p = s - u.positionY, f = Math.sqrt(d * d + p * p);
				if (f > 1) {
					var g = t.gravity * d / f, m = t.gravity * p / f;
					u.offsetX += g, u.offsetY += m;
				}
			}
		}
	}
}, "calculateGravityForces"), jD = h(function(e, t) {
	var r = [], i = 0, n = -1;
	for (r.push.apply(r, e.graphSet[0]), n += e.graphSet[0].length; i <= n;) {
		var a = r[i++], s = e.idToIndex[a], o = e.layoutNodes[s], l = o.children;
		if (0 < l.length && !o.isLocked) {
			for (var h = o.offsetX, u = o.offsetY, d = 0; d < l.length; d++) {
				var p = e.layoutNodes[e.idToIndex[l[d]]];
				p.offsetX += h, p.offsetY += u, r[++n] = l[d];
			}
			o.offsetX = 0, o.offsetY = 0;
		}
	}
}, "propagateForces"), jO = h(function(e, t) {
	for (var r = 0; r < e.nodeSize; r++) {
		var i = e.layoutNodes[r];
		0 < i.children.length && (i.maxX = void 0, i.minX = void 0, i.maxY = void 0, i.minY = void 0);
	}
	for (var r = 0; r < e.nodeSize; r++) {
		var i = e.layoutNodes[r];
		if (!(0 < i.children.length || i.isLocked)) {
			var n = j$(i.offsetX, i.offsetY, e.temperature);
			i.positionX += n.x, i.positionY += n.y, i.offsetX = 0, i.offsetY = 0, i.minX = i.positionX - i.width, i.maxX = i.positionX + i.width, i.minY = i.positionY - i.height, i.maxY = i.positionY + i.height, jP(i, e);
		}
	}
	for (var r = 0; r < e.nodeSize; r++) {
		var i = e.layoutNodes[r];
		0 < i.children.length && !i.isLocked && (i.positionX = (i.maxX + i.minX) / 2, i.positionY = (i.maxY + i.minY) / 2, i.width = i.maxX - i.minX, i.height = i.maxY - i.minY);
	}
}, "updatePositions"), j$ = h(function(e, t, r) {
	var i = Math.sqrt(e * e + t * t);
	if (i > r) var n = {
		x: r * e / i,
		y: r * t / i
	};
	else var n = {
		x: e,
		y: t
	};
	return n;
}, "limitForce"), jP = h(function(e, t) {
	var r = e.parentId;
	if (null != r) {
		var i = t.layoutNodes[t.idToIndex[r]], n = !1;
		if ((null == i.maxX || e.maxX + i.padRight > i.maxX) && (i.maxX = e.maxX + i.padRight, n = !0), (null == i.minX || e.minX - i.padLeft < i.minX) && (i.minX = e.minX - i.padLeft, n = !0), (null == i.maxY || e.maxY + i.padBottom > i.maxY) && (i.maxY = e.maxY + i.padBottom, n = !0), (null == i.minY || e.minY - i.padTop < i.minY) && (i.minY = e.minY - i.padTop, n = !0), n) return jP(i, t);
	}
}, "updateAncestryBoundaries"), jB = h(function(e, t) {
	for (var r = e.layoutNodes, i = [], n = 0; n < r.length; n++) {
		var a = r[n], s = a.cmptId;
		(i[s] = i[s] || []).push(a);
	}
	for (var o = 0, n = 0; n < i.length; n++) {
		var l = i[n];
		if (l) {
			l.x1 = Infinity, l.x2 = -Infinity, l.y1 = Infinity, l.y2 = -Infinity;
			for (var h = 0; h < l.length; h++) {
				var u = l[h];
				l.x1 = Math.min(l.x1, u.positionX - u.width / 2), l.x2 = Math.max(l.x2, u.positionX + u.width / 2), l.y1 = Math.min(l.y1, u.positionY - u.height / 2), l.y2 = Math.max(l.y2, u.positionY + u.height / 2);
			}
			l.w = l.x2 - l.x1, l.h = l.y2 - l.y1, o += l.w * l.h;
		}
	}
	i.sort(function(e, t) {
		return t.w * t.h - e.w * e.h;
	});
	for (var d = 0, p = 0, f = 0, g = 0, m = Math.sqrt(o) * e.clientWidth / e.clientHeight, n = 0; n < i.length; n++) {
		var l = i[n];
		if (l) {
			for (var h = 0; h < l.length; h++) {
				var u = l[h];
				u.isLocked || (u.positionX += d - l.x1, u.positionY += p - l.y1);
			}
			d += l.w + t.componentSpacing, f += l.w + t.componentSpacing, g = Math.max(g, l.h), f > m && (p += g + t.componentSpacing, d = 0, f = 0, g = 0);
		}
	}
}, "separateComponents"), jF = {
	fit: !0,
	padding: 30,
	boundingBox: void 0,
	avoidOverlap: !0,
	avoidOverlapPadding: 10,
	nodeDimensionsIncludeLabels: !1,
	spacingFactor: void 0,
	condense: !1,
	rows: void 0,
	cols: void 0,
	position: h(function(e) {}, "position"),
	sort: void 0,
	animate: !1,
	animationDuration: 500,
	animationEasing: void 0,
	animateFilter: h(function(e, t) {
		return !0;
	}, "animateFilter"),
	ready: void 0,
	stop: void 0,
	transform: h(function(e, t) {
		return t;
	}, "transform")
};
function jz(e) {
	this.options = Ou({}, jF, e);
}
h(jz, "GridLayout"), jz.prototype.run = function() {
	var e = this.options, t = e.cy, r = e.eles, i = r.nodes().not(":parent");
	e.sort && (i = i.sort(e.sort));
	var n = PE(e.boundingBox ? e.boundingBox : {
		x1: 0,
		y1: 0,
		w: t.width(),
		h: t.height()
	});
	if (0 === n.h || 0 === n.w) r.nodes().layoutPositions(this, e, function(e) {
		return {
			x: n.x1,
			y: n.y1
		};
	});
	else {
		var a = i.size(), s = Math.sqrt(a * n.h / n.w), o = Math.round(s), l = Math.round(n.w / n.h * s), u = h(function(e) {
			if (null == e) return Math.min(o, l);
			Math.min(o, l) == o ? o = e : l = e;
		}, "small"), d = h(function(e) {
			if (null == e) return Math.max(o, l);
			Math.max(o, l) == o ? o = e : l = e;
		}, "large"), p = e.rows, f = null != e.cols ? e.cols : e.columns;
		if (null != p && null != f) o = p, l = f;
		else if (null != p && null == f) l = Math.ceil(a / (o = p));
		else if (null == p && null != f) o = Math.ceil(a / (l = f));
		else if (l * o > a) {
			var g = u(), m = d();
			(g - 1) * m >= a ? u(g - 1) : (m - 1) * g >= a && d(m - 1);
		} else for (; l * o < a;) {
			var y = u(), v = d();
			(v + 1) * y >= a ? d(v + 1) : u(y + 1);
		}
		var x = n.w / l, b = n.h / o;
		if (e.condense && (x = 0, b = 0), e.avoidOverlap) for (var w = 0; w < i.length; w++) {
			var k = i[w], T = k._private.position;
			(null == T.x || null == T.y) && (T.x = 0, T.y = 0);
			var _ = k.layoutDimensions(e), E = e.avoidOverlapPadding, C = _.w + E, S = _.h + E;
			x = Math.max(x, C), b = Math.max(b, S);
		}
		for (var A = {}, L = h(function(e, t) {
			return !!A["c-" + e + "-" + t];
		}, "used"), R = h(function(e, t) {
			A["c-" + e + "-" + t] = !0;
		}, "use"), N = 0, I = 0, M = h(function() {
			++I >= l && (I = 0, N++);
		}, "moveToNextCell"), D = {}, O = 0; O < i.length; O++) {
			var $ = i[O], P = e.position($);
			if (P && (void 0 !== P.row || void 0 !== P.col)) {
				var B = {
					row: P.row,
					col: P.col
				};
				if (void 0 === B.col) for (B.col = 0; L(B.row, B.col);) B.col++;
				else if (void 0 === B.row) for (B.row = 0; L(B.row, B.col);) B.row++;
				D[$.id()] = B, R(B.row, B.col);
			}
		}
		var F = h(function(e, t) {
			if (e.locked() || e.isParent()) return !1;
			var r, i, a = D[e.id()];
			if (a) r = a.col * x + x / 2 + n.x1, i = a.row * b + b / 2 + n.y1;
			else {
				for (; L(N, I);) M();
				r = I * x + x / 2 + n.x1, i = N * b + b / 2 + n.y1, R(N, I), M();
			}
			return {
				x: r,
				y: i
			};
		}, "getPos");
		i.layoutPositions(this, e, F);
	}
	return this;
};
var jU = {
	ready: h(function() {}, "ready"),
	stop: h(function() {}, "stop")
};
function jG(e) {
	this.options = Ou({}, jU, e);
}
h(jG, "NullLayout"), jG.prototype.run = function() {
	var e = this.options, t = e.eles;
	return e.cy, this.emit("layoutstart"), t.nodes().positions(function() {
		return {
			x: 0,
			y: 0
		};
	}), this.one("layoutready", e.ready), this.emit("layoutready"), this.one("layoutstop", e.stop), this.emit("layoutstop"), this;
}, jG.prototype.stop = function() {
	return this;
};
var jq = {
	positions: void 0,
	zoom: void 0,
	pan: void 0,
	fit: !0,
	padding: 30,
	spacingFactor: void 0,
	animate: !1,
	animationDuration: 500,
	animationEasing: void 0,
	animateFilter: h(function(e, t) {
		return !0;
	}, "animateFilter"),
	ready: void 0,
	stop: void 0,
	transform: h(function(e, t) {
		return t;
	}, "transform")
};
function jj(e) {
	this.options = Ou({}, jq, e);
}
h(jj, "PresetLayout"), jj.prototype.run = function() {
	var e = this.options, t = e.eles.nodes(), r = Dj(e.positions);
	function i(t) {
		return null == e.positions ? Ps(t.position()) : r ? e.positions(t) : e.positions[t._private.data.id] ?? null;
	}
	return h(i, "getPosition"), t.layoutPositions(this, e, function(e, t) {
		var r = i(e);
		return !e.locked() && null != r && r;
	}), this;
};
var jW = {
	fit: !0,
	padding: 30,
	boundingBox: void 0,
	animate: !1,
	animationDuration: 500,
	animationEasing: void 0,
	animateFilter: h(function(e, t) {
		return !0;
	}, "animateFilter"),
	ready: void 0,
	stop: void 0,
	transform: h(function(e, t) {
		return t;
	}, "transform")
};
function jY(e) {
	this.options = Ou({}, jW, e);
}
h(jY, "RandomLayout"), jY.prototype.run = function() {
	var e = this.options, t = e.cy, r = e.eles, i = PE(e.boundingBox ? e.boundingBox : {
		x1: 0,
		y1: 0,
		w: t.width(),
		h: t.height()
	}), n = h(function(e, t) {
		return {
			x: i.x1 + Math.round(Math.random() * i.w),
			y: i.y1 + Math.round(Math.random() * i.h)
		};
	}, "getPos");
	return r.nodes().layoutPositions(this, e, n), this;
};
var jV = [
	{
		name: "breadthfirst",
		impl: ju
	},
	{
		name: "circle",
		impl: jp
	},
	{
		name: "concentric",
		impl: jg
	},
	{
		name: "cose",
		impl: jv
	},
	{
		name: "grid",
		impl: jz
	},
	{
		name: "null",
		impl: jG
	},
	{
		name: "preset",
		impl: jj
	},
	{
		name: "random",
		impl: jY
	}
];
function jH(e) {
	this.options = e, this.notifications = 0;
}
h(jH, "NullRenderer");
var jX = h(function() {}, "noop"), jK = h(function() {
	throw Error("A headless instance can not render images");
}, "throwImgErr");
jH.prototype = {
	recalculateRenderedStyle: jX,
	notify: h(function() {
		this.notifications++;
	}, "notify"),
	init: jX,
	isHeadless: h(function() {
		return !0;
	}, "isHeadless"),
	png: jK,
	jpg: jK
};
var jZ = {};
jZ.arrowShapeWidth = .3, jZ.registerArrowShapes = function() {
	var e = this.arrowShapes = {}, t = this, r = h(function(e, t, r, i, n, a, s) {
		var o = n.x - r / 2 - s, l = n.x + r / 2 + s, h = n.y - r / 2 - s, u = n.y + r / 2 + s;
		return o <= e && e <= l && h <= t && t <= u;
	}, "bbCollide"), i = h(function(e, t, r, i, n) {
		var a = e * Math.cos(i) - t * Math.sin(i), s = e * Math.sin(i) + t * Math.cos(i);
		return {
			x: a * r + n.x,
			y: s * r + n.y
		};
	}, "transform"), n = h(function(e, t, r, n) {
		for (var a = [], s = 0; s < e.length; s += 2) {
			var o = e[s], l = e[s + 1];
			a.push(i(o, l, t, r, n));
		}
		return a;
	}, "transformPoints"), a = h(function(e) {
		for (var t = [], r = 0; r < e.length; r++) {
			var i = e[r];
			t.push(i.x, i.y);
		}
		return t;
	}, "pointsToArr"), s = h(function(e) {
		return e.pstyle("width").pfValue * e.pstyle("arrow-scale").pfValue * 2;
	}, "standardGap"), o = h(function(i, o) {
		Dq(o) && (o = e[o]), e[i] = Ou({
			name: i,
			points: [
				-.15,
				-.3,
				.15,
				-.3,
				.15,
				.3,
				-.15,
				.3
			],
			collide: h(function(e, t, r, i, s, o) {
				return PV(e, t, a(n(this.points, r + 2 * o, i, s)));
			}, "collide"),
			roughCollide: r,
			draw: h(function(e, r, i, a) {
				var s = n(this.points, r, i, a);
				t.arrowShapeImpl("polygon")(e, s);
			}, "draw"),
			spacing: h(function(e) {
				return 0;
			}, "spacing"),
			gap: s
		}, o);
	}, "defineArrowShape");
	o("none", {
		collide: O3,
		roughCollide: O3,
		draw: O7,
		spacing: O6,
		gap: O6
	}), o("triangle", { points: [
		-.15,
		-.3,
		0,
		0,
		.15,
		-.3
	] }), o("arrow", "triangle"), o("triangle-backcurve", {
		points: e.triangle.points,
		controlPoint: [0, -.15],
		roughCollide: r,
		draw: h(function(e, r, a, s, o) {
			var l = n(this.points, r, a, s), h = this.controlPoint, u = i(h[0], h[1], r, a, s);
			t.arrowShapeImpl(this.name)(e, l, u);
		}, "draw"),
		gap: h(function(e) {
			return .8 * s(e);
		}, "gap")
	}), o("triangle-tee", {
		points: [
			0,
			0,
			.15,
			-.3,
			-.15,
			-.3,
			0,
			0
		],
		pointsTee: [
			-.15,
			-.4,
			-.15,
			-.5,
			.15,
			-.5,
			.15,
			-.4
		],
		collide: h(function(e, t, r, i, s, o, l) {
			var h = a(n(this.points, r + 2 * l, i, s)), u = a(n(this.pointsTee, r + 2 * l, i, s));
			return PV(e, t, h) || PV(e, t, u);
		}, "collide"),
		draw: h(function(e, r, i, a, s) {
			var o = n(this.points, r, i, a), l = n(this.pointsTee, r, i, a);
			t.arrowShapeImpl(this.name)(e, o, l);
		}, "draw")
	}), o("circle-triangle", {
		radius: .15,
		pointsTr: [
			0,
			-.15,
			.15,
			-.45,
			-.15,
			-.45,
			0,
			-.15
		],
		collide: h(function(e, t, r, i, s, o, l) {
			var h = Math.pow(s.x - e, 2) + Math.pow(s.y - t, 2) <= Math.pow((r + 2 * l) * this.radius, 2);
			return PV(e, t, a(n(this.points, r + 2 * l, i, s))) || h;
		}, "collide"),
		draw: h(function(e, r, i, a, s) {
			var o = n(this.pointsTr, r, i, a);
			t.arrowShapeImpl(this.name)(e, o, a.x, a.y, this.radius * r);
		}, "draw"),
		spacing: h(function(e) {
			return t.getArrowWidth(e.pstyle("width").pfValue, e.pstyle("arrow-scale").value) * this.radius;
		}, "spacing")
	}), o("triangle-cross", {
		points: [
			0,
			0,
			.15,
			-.3,
			-.15,
			-.3,
			0,
			0
		],
		baseCrossLinePts: [
			-.15,
			-.4,
			-.15,
			-.4,
			.15,
			-.4,
			.15,
			-.4
		],
		crossLinePts: h(function(e, t) {
			var r = this.baseCrossLinePts.slice(), i = t / e;
			return r[3] = r[3] - i, r[5] = r[5] - i, r;
		}, "crossLinePts"),
		collide: h(function(e, t, r, i, s, o, l) {
			var h = a(n(this.points, r + 2 * l, i, s)), u = a(n(this.crossLinePts(r, o), r + 2 * l, i, s));
			return PV(e, t, h) || PV(e, t, u);
		}, "collide"),
		draw: h(function(e, r, i, a, s) {
			var o = n(this.points, r, i, a), l = n(this.crossLinePts(r, s), r, i, a);
			t.arrowShapeImpl(this.name)(e, o, l);
		}, "draw")
	}), o("vee", {
		points: [
			-.15,
			-.3,
			0,
			0,
			.15,
			-.3,
			0,
			-.15
		],
		gap: h(function(e) {
			return .525 * s(e);
		}, "gap")
	}), o("circle", {
		radius: .15,
		collide: h(function(e, t, r, i, n, a, s) {
			return Math.pow(n.x - e, 2) + Math.pow(n.y - t, 2) <= Math.pow((r + 2 * s) * this.radius, 2);
		}, "collide"),
		draw: h(function(e, r, i, n, a) {
			t.arrowShapeImpl(this.name)(e, n.x, n.y, this.radius * r);
		}, "draw"),
		spacing: h(function(e) {
			return t.getArrowWidth(e.pstyle("width").pfValue, e.pstyle("arrow-scale").value) * this.radius;
		}, "spacing")
	}), o("tee", {
		points: [
			-.15,
			0,
			-.15,
			-.1,
			.15,
			-.1,
			.15,
			0
		],
		spacing: h(function(e) {
			return 1;
		}, "spacing"),
		gap: h(function(e) {
			return 1;
		}, "gap")
	}), o("square", { points: [
		-.15,
		0,
		.15,
		0,
		.15,
		-.3,
		-.15,
		-.3
	] }), o("diamond", {
		points: [
			-.15,
			-.15,
			0,
			-.3,
			.15,
			-.15,
			0,
			0
		],
		gap: h(function(e) {
			return e.pstyle("width").pfValue * e.pstyle("arrow-scale").value;
		}, "gap")
	}), o("chevron", {
		points: [
			0,
			0,
			-.15,
			-.15,
			-.1,
			-.2,
			0,
			-.1,
			.1,
			-.2,
			.15,
			-.15
		],
		gap: h(function(e) {
			return .95 * e.pstyle("width").pfValue * e.pstyle("arrow-scale").value;
		}, "gap")
	});
};
var jQ = {};
jQ.projectIntoViewport = function(e, t) {
	var r = this.cy, i = this.findContainerClientCoords(), n = i[0], a = i[1], s = i[4], o = r.pan(), l = r.zoom();
	return [((e - n) / s - o.x) / l, ((t - a) / s - o.y) / l];
}, jQ.findContainerClientCoords = function() {
	if (this.containerBB) return this.containerBB;
	var e = this.container, t = e.getBoundingClientRect(), r = this.cy.window().getComputedStyle(e), i = h(function(e) {
		return parseFloat(r.getPropertyValue(e));
	}, "styleValue"), n = {
		left: i("padding-left"),
		right: i("padding-right"),
		top: i("padding-top"),
		bottom: i("padding-bottom")
	}, a = {
		left: i("border-left-width"),
		right: i("border-right-width"),
		top: i("border-top-width"),
		bottom: i("border-bottom-width")
	}, s = e.clientWidth, o = e.clientHeight, l = n.left + n.right, u = n.top + n.bottom, d = a.left + a.right, p = t.width / (s + d);
	return this.containerBB = [
		t.left + n.left + a.left,
		t.top + n.top + a.top,
		s - l,
		o - u,
		p
	];
}, jQ.invalidateContainerClientCoordsCache = function() {
	this.containerBB = null;
}, jQ.findNearestElement = function(e, t, r, i) {
	return this.findNearestElements(e, t, r, i)[0];
}, jQ.findNearestElements = function(e, t, r, i) {
	var n, a, s = this, o = this, l = o.getCachedZSortedEles(), u = [], d = o.cy.zoom(), p = o.cy.hasCompoundNodes(), f = (i ? 24 : 8) / d, g = (i ? 8 : 2) / d, m = (i ? 8 : 2) / d, y = Infinity;
	function v(e, t) {
		if (e.isNode()) {
			if (a) return;
			a = e, u.push(e);
		}
		if (e.isEdge() && (null == t || t < y)) if (n) {
			if (n.pstyle("z-compound-depth").value === e.pstyle("z-compound-depth").value && n.pstyle("z-compound-depth").value === e.pstyle("z-compound-depth").value) {
				for (var r = 0; r < u.length; r++) if (u[r].isEdge()) {
					u[r] = e, n = e, y = t ?? y;
					break;
				}
			}
		} else u.push(e), n = e, y = t ?? y;
	}
	function x(r) {
		var i = r.outerWidth() + 2 * g, n = r.outerHeight() + 2 * g, a = i / 2, l = n / 2, h = r.position(), u = "auto" === r.pstyle("corner-radius").value ? "auto" : r.pstyle("corner-radius").pfValue, d = r._private.rscratch;
		if (h.x - a <= e && e <= h.x + a && h.y - l <= t && t <= h.y + l && o.nodeShapes[s.getNodeShape(r)].checkPoint(e, t, 0, i, n, h.x, h.y, u, d)) return v(r, 0), !0;
	}
	function b(r) {
		var i, n = r._private, a = n.rscratch, l = r.pstyle("width").pfValue, h = r.pstyle("arrow-scale").value, d = l / 2 + f, g = d * d, m = 2 * d, y = n.source, b = n.target;
		if ("segments" === a.edgeType || "straight" === a.edgeType || "haystack" === a.edgeType) {
			for (var w = a.allpts, k = 0; k + 3 < w.length; k += 2) if (PU(e, t, w[k], w[k + 1], w[k + 2], w[k + 3], m) && g > (i = PY(e, t, w[k], w[k + 1], w[k + 2], w[k + 3]))) return v(r, i), !0;
		} else if ("bezier" === a.edgeType || "multibezier" === a.edgeType || "self" === a.edgeType || "compound" === a.edgeType) {
			for (var w = a.allpts, k = 0; k + 5 < a.allpts.length; k += 4) if (PG(e, t, w[k], w[k + 1], w[k + 2], w[k + 3], w[k + 4], w[k + 5], m) && g > (i = PW(e, t, w[k], w[k + 1], w[k + 2], w[k + 3], w[k + 4], w[k + 5]))) return v(r, i), !0;
		}
		for (var y = y || n.source, b = b || n.target, T = s.getArrowWidth(l, h), _ = [
			{
				name: "source",
				x: a.arrowStartX,
				y: a.arrowStartY,
				angle: a.srcArrowAngle
			},
			{
				name: "target",
				x: a.arrowEndX,
				y: a.arrowEndY,
				angle: a.tgtArrowAngle
			},
			{
				name: "mid-source",
				x: a.midX,
				y: a.midY,
				angle: a.midsrcArrowAngle
			},
			{
				name: "mid-target",
				x: a.midX,
				y: a.midY,
				angle: a.midtgtArrowAngle
			}
		], k = 0; k < _.length; k++) {
			var E = _[k], C = o.arrowShapes[r.pstyle(E.name + "-arrow-shape").value], S = r.pstyle("width").pfValue;
			if (C.roughCollide(e, t, T, E.angle, {
				x: E.x,
				y: E.y
			}, S, f) && C.collide(e, t, T, E.angle, {
				x: E.x,
				y: E.y
			}, S, f)) return v(r), !0;
		}
		p && u.length > 0 && (x(y), x(b));
	}
	function w(e, t, r) {
		return $u(e, t, r);
	}
	function k(r, i) {
		var n, a = r._private;
		n = i ? i + "-" : "", r.boundingBox();
		var s = a.labelBounds[i || "main"], o = r.pstyle(n + "label").value;
		if (!("yes" !== r.pstyle("text-events").strValue || !o)) {
			var l = w(a.rscratch, "labelX", i), u = w(a.rscratch, "labelY", i), d = w(a.rscratch, "labelAngle", i), p = r.pstyle(n + "text-margin-x").pfValue, f = r.pstyle(n + "text-margin-y").pfValue, g = s.x1 - m - p, y = s.x2 + m - p, x = s.y1 - m - f, b = s.y2 + m - f;
			if (d) {
				var k = Math.cos(d), T = Math.sin(d), _ = h(function(e, t) {
					return {
						x: (e -= l) * k - (t -= u) * T + l,
						y: e * T + t * k + u
					};
				}, "rotate"), E = _(g, x), C = _(g, b), S = _(y, x), A = _(y, b);
				if (PV(e, t, [
					E.x + p,
					E.y + f,
					S.x + p,
					S.y + f,
					A.x + p,
					A.y + f,
					C.x + p,
					C.y + f
				])) return v(r), !0;
			} else if (PD(s, e, t)) return v(r), !0;
		}
	}
	r && (l = l.interactive), h(v, "addEle"), h(x, "checkNode"), h(b, "checkEdge"), h(w, "preprop"), h(k, "checkLabel");
	for (var T = l.length - 1; T >= 0; T--) {
		var _ = l[T];
		_.isNode() ? x(_) || k(_) : b(_) || k(_) || k(_, "source") || k(_, "target");
	}
	return u;
}, jQ.getAllInBox = function(e, t, r, i) {
	var n = this.getCachedZSortedEles().interactive, a = 2 / this.cy.zoom(), s = [], o = Math.min(e, r), l = Math.max(e, r), u = Math.min(t, i), d = Math.max(t, i);
	e = o, r = l;
	var p = PE({
		x1: e,
		y1: t = u,
		x2: r,
		y2: i = d
	}), f = [
		{
			x: p.x1,
			y: p.y1
		},
		{
			x: p.x2,
			y: p.y1
		},
		{
			x: p.x2,
			y: p.y2
		},
		{
			x: p.x1,
			y: p.y2
		}
	], g = [
		[f[0], f[1]],
		[f[1], f[2]],
		[f[2], f[3]],
		[f[3], f[0]]
	];
	function m(e, t, r) {
		return $u(e, t, r);
	}
	function y(e, t) {
		var r = e._private;
		e.boundingBox();
		var i = r.labelBounds.main;
		if (!i) return null;
		var n = m(r.rscratch, "labelX", t), s = m(r.rscratch, "labelY", t), o = m(r.rscratch, "labelAngle", t), l = e.pstyle("text-margin-x").pfValue, u = e.pstyle("text-margin-y").pfValue, d = i.x1 - a - l, p = i.x2 + a - l, f = i.y1 - a - u, g = i.y2 + a - u;
		if (!o) return [
			{
				x: d,
				y: f
			},
			{
				x: p,
				y: f
			},
			{
				x: p,
				y: g
			},
			{
				x: d,
				y: g
			}
		];
		var y = Math.cos(o), v = Math.sin(o), x = h(function(e, t) {
			return {
				x: (e -= n) * y - (t -= s) * v + n,
				y: e * v + t * y + s
			};
		}, "rotate");
		return [
			x(d, f),
			x(p, f),
			x(p, g),
			x(d, g)
		];
	}
	function v(e, t, r, i) {
		function n(e, t, r) {
			return (r.y - e.y) * (t.x - e.x) > (t.y - e.y) * (r.x - e.x);
		}
		return h(n, "ccw"), n(e, r, i) !== n(t, r, i) && n(e, t, r) !== n(e, t, i);
	}
	h(m, "preprop"), h(y, "getRotatedLabelBox"), h(v, "doLinesIntersect");
	for (var x = 0; x < n.length; x++) {
		var b = n[x];
		if (b.isNode()) {
			var w = "yes" === b.pstyle("text-events").strValue, k = b.pstyle("box-selection").strValue, T = "yes" === b.pstyle("box-select-labels").strValue;
			if ("none" === k) continue;
			var _ = ("overlap" === k || T) && w, E = b.boundingBox({
				includeNodes: !0,
				includeEdges: !1,
				includeLabels: _
			});
			if ("contain" === k) {
				var C = !1;
				if (T && w) {
					var S = y(b);
					S && Ba(S, f) && (s.push(b), C = !0);
				}
				!C && P$(p, E) && s.push(b);
			} else if ("overlap" === k && PM(p, E)) {
				var A = b.boundingBox({
					includeNodes: !0,
					includeEdges: !0,
					includeLabels: !1,
					includeMainLabels: !1,
					includeSourceLabels: !1,
					includeTargetLabels: !1
				});
				if (Ba([
					{
						x: A.x1,
						y: A.y1
					},
					{
						x: A.x2,
						y: A.y1
					},
					{
						x: A.x2,
						y: A.y2
					},
					{
						x: A.x1,
						y: A.y2
					}
				], f)) s.push(b);
				else {
					var L = y(b);
					L && Ba(L, f) && s.push(b);
				}
			}
		} else {
			var R = b._private, N = R.rscratch, I = b.pstyle("box-selection").strValue;
			if ("none" === I) continue;
			if ("contain" === I) {
				if (null != N.startX && null != N.startY && !PD(p, N.startX, N.startY) || null != N.endX && null != N.endY && !PD(p, N.endX, N.endY)) continue;
				if ("bezier" === N.edgeType || "multibezier" === N.edgeType || "self" === N.edgeType || "compound" === N.edgeType || "segments" === N.edgeType || "haystack" === N.edgeType) {
					for (var M = R.rstyle.bezierPts || R.rstyle.linePts || R.rstyle.haystackPts, D = !0, O = 0; O < M.length; O++) if (!PO(p, M[O])) {
						D = !1;
						break;
					}
					D && s.push(b);
				} else "straight" === N.edgeType && s.push(b);
			} else if ("overlap" === I) {
				var $ = !1;
				if (null != N.startX && null != N.startY && null != N.endX && null != N.endY && (PD(p, N.startX, N.startY) || PD(p, N.endX, N.endY))) s.push(b), $ = !0;
				else if (!$ && "haystack" === N.edgeType) {
					for (var P = R.rstyle.haystackPts, B = 0; B < P.length; B++) if (PO(p, P[B])) {
						s.push(b), $ = !0;
						break;
					}
				}
				if (!$) {
					var F = R.rstyle.bezierPts || R.rstyle.linePts || R.rstyle.haystackPts;
					if ((!F || F.length < 2) && "straight" === N.edgeType && null != N.startX && null != N.startY && null != N.endX && null != N.endY && (F = [{
						x: N.startX,
						y: N.startY
					}, {
						x: N.endX,
						y: N.endY
					}]), !F || F.length < 2) continue;
					for (var z = 0; z < F.length - 1; z++) {
						for (var U = F[z], G = F[z + 1], q = 0; q < g.length; q++) {
							var j = DR(g[q], 2);
							if (v(U, G, j[0], j[1])) {
								s.push(b), $ = !0;
								break;
							}
						}
						if ($) break;
					}
				}
			}
		}
	}
	return s;
};
var jJ = {};
jJ.calculateArrowAngles = function(e) {
	var t, r, i, n, a, s, o, l, h = e._private.rscratch, u = "haystack" === h.edgeType, d = "bezier" === h.edgeType, p = "multibezier" === h.edgeType, f = "segments" === h.edgeType, g = "compound" === h.edgeType, m = "self" === h.edgeType;
	if (u ? (i = h.haystackPts[0], n = h.haystackPts[1], a = h.haystackPts[2], s = h.haystackPts[3]) : (i = h.arrowStartX, n = h.arrowStartY, a = h.arrowEndX, s = h.arrowEndY), o = h.midX, l = h.midY, f) t = i - h.segpts[0], r = n - h.segpts[1];
	else if (p || g || m || d) {
		var y = h.allpts, v = Pw(y[0], y[2], y[4], .1), x = Pw(y[1], y[3], y[5], .1);
		t = i - v, r = n - x;
	} else t = i - o, r = n - l;
	h.srcArrowAngle = Pg(t, r);
	var o = h.midX, l = h.midY;
	if (u && (o = (i + a) / 2, l = (n + s) / 2), t = a - i, r = s - n, f) {
		var y = h.allpts;
		if (y.length / 2 % 2 == 0) {
			var b = y.length / 2, w = b - 2;
			t = y[b] - y[w], r = y[b + 1] - y[w + 1];
		} else if (h.isRound) t = h.midVector[1], r = -h.midVector[0];
		else {
			var b = y.length / 2 - 1, w = b - 2;
			t = y[b] - y[w], r = y[b + 1] - y[w + 1];
		}
	} else if (p || g || m) {
		var k, T, _, E, y = h.allpts;
		if (h.ctrlpts.length / 2 % 2 == 0) {
			var C = y.length / 2 - 1, S = C + 2, A = S + 2;
			k = Pw(y[C], y[S], y[A], 0), T = Pw(y[C + 1], y[S + 1], y[A + 1], 0), _ = Pw(y[C], y[S], y[A], 1e-4), E = Pw(y[C + 1], y[S + 1], y[A + 1], 1e-4);
		} else {
			var S = y.length / 2 - 1, C = S - 2, A = S + 2;
			k = Pw(y[C], y[S], y[A], .4999), T = Pw(y[C + 1], y[S + 1], y[A + 1], .4999), _ = Pw(y[C], y[S], y[A], .5), E = Pw(y[C + 1], y[S + 1], y[A + 1], .5);
		}
		t = _ - k, r = E - T;
	}
	if (h.midtgtArrowAngle = Pg(t, r), h.midDispX = t, h.midDispY = r, t *= -1, r *= -1, f) {
		var y = h.allpts;
		if (y.length / 2 % 2 != 0 && !h.isRound) {
			var b = y.length / 2 - 1, L = b + 2;
			t = -(y[L] - y[b]), r = -(y[L + 1] - y[b + 1]);
		}
	}
	if (h.midsrcArrowAngle = Pg(t, r), f) t = a - h.segpts[h.segpts.length - 2], r = s - h.segpts[h.segpts.length - 1];
	else if (p || g || m || d) {
		var y = h.allpts, R = y.length, v = Pw(y[R - 6], y[R - 4], y[R - 2], .9), x = Pw(y[R - 5], y[R - 3], y[R - 1], .9);
		t = a - v, r = s - x;
	} else t = a - o, r = s - l;
	h.tgtArrowAngle = Pg(t, r);
}, jJ.getArrowWidth = jJ.getArrowHeight = function(e, t) {
	var r = this.arrowWidthCache = this.arrowWidthCache || {}, i = r[e + ", " + t];
	return i || (i = Math.max(Math.pow(13.37 * e, .9), 29) * t, r[e + ", " + t] = i, i);
};
var j0, j1, j2, j4, j5, j3, j6, j7, j8, j9, We, Wt, Wr, Wi, Wn, Wa, Ws, Wo = {}, Wl = {}, Wc = h(function(e, t, r) {
	r.x = t.x - e.x, r.y = t.y - e.y, r.len = Math.sqrt(r.x * r.x + r.y * r.y), r.nx = r.x / r.len, r.ny = r.y / r.len, r.ang = Math.atan2(r.ny, r.nx);
}, "asVec"), Wh = h(function(e, t) {
	t.x = -1 * e.x, t.y = -1 * e.y, t.nx = -1 * e.nx, t.ny = -1 * e.ny, t.ang = e.ang > 0 ? -(Math.PI - e.ang) : Math.PI + e.ang;
}, "invertVec"), Wu = h(function(e, t, r, i, n) {
	if (e !== Ws ? Wc(t, e, Wo) : Wh(Wl, Wo), Wc(t, r, Wl), j2 = Wo.nx * Wl.ny - Wo.ny * Wl.nx, j4 = Wo.nx * Wl.nx - -(Wo.ny * Wl.ny), 1e-6 > Math.abs(j6 = Math.asin(Math.max(-1, Math.min(1, j2))))) {
		j0 = t.x, j1 = t.y, j8 = We = 0;
		return;
	}
	j5 = 1, j3 = !1, j4 < 0 ? j6 < 0 ? j6 = Math.PI + j6 : (j6 = Math.PI - j6, j5 = -1, j3 = !0) : j6 > 0 && (j5 = -1, j3 = !0), We = void 0 !== t.radius ? t.radius : i, j7 = j6 / 2, Wt = Math.min(Wo.len / 2, Wl.len / 2), j8 = n ? (j9 = Math.abs(Math.cos(j7) * We / Math.sin(j7))) > Wt ? Math.abs((j9 = Wt) * Math.sin(j7) / Math.cos(j7)) : We : Math.abs((j9 = Math.min(Wt, We)) * Math.sin(j7) / Math.cos(j7)), Wn = t.x + Wl.nx * j9, Wa = t.y + Wl.ny * j9, j0 = Wn - Wl.ny * j8 * j5, j1 = Wa + Wl.nx * j8 * j5, Wr = t.x + Wo.nx * j9, Wi = t.y + Wo.ny * j9, Ws = t;
}, "calcCornerArc");
function Wd(e, t) {
	0 === t.radius ? e.lineTo(t.cx, t.cy) : e.arc(t.cx, t.cy, t.radius, t.startAngle, t.endAngle, t.counterClockwise);
}
function Wp(e, t, r, i) {
	var n = !(arguments.length > 4) || void 0 === arguments[4] || arguments[4];
	return 0 === i || 0 === t.radius ? {
		cx: t.x,
		cy: t.y,
		radius: 0,
		startX: t.x,
		startY: t.y,
		stopX: t.x,
		stopY: t.y,
		startAngle: void 0,
		endAngle: void 0,
		counterClockwise: void 0
	} : (Wu(e, t, r, i, n), {
		cx: j0,
		cy: j1,
		radius: j8,
		startX: Wr,
		startY: Wi,
		stopX: Wn,
		stopY: Wa,
		startAngle: Wo.ang + Math.PI / 2 * j5,
		endAngle: Wl.ang - Math.PI / 2 * j5,
		counterClockwise: j3
	});
}
h(Wd, "drawPreparedRoundCorner"), h(Wp, "getRoundCorner");
var Wf = Math.sqrt(.02), Wg = {};
function Wm(e) {
	var t = [];
	if (null != e) {
		for (var r = 0; r < e.length; r += 2) {
			var i = e[r], n = e[r + 1];
			t.push({
				x: i,
				y: n
			});
		}
		return t;
	}
}
Wg.findMidptPtsEtc = function(e, t) {
	var r, i = t.posPts, n = t.intersectionPts, a = t.vectorNormInverse, s = e.pstyle("source-endpoint"), o = e.pstyle("target-endpoint"), l = null != s.units && null != o.units, u = h(function(e, t, r, i) {
		var n = i - t, a = r - e, s = Math.sqrt(a * a + n * n);
		return {
			x: -n / s,
			y: a / s
		};
	}, "recalcVectorNormInverse");
	switch (e.pstyle("edge-distances").value) {
		case "node-position":
			r = i;
			break;
		case "intersection":
			r = n;
			break;
		case "endpoints": if (l) {
			var d = DR(this.manualEndptToPx(e.source()[0], s), 2), p = d[0], f = d[1], g = DR(this.manualEndptToPx(e.target()[0], o), 2), m = g[0], y = g[1];
			a = u(p, f, m, y), r = {
				x1: p,
				y1: f,
				x2: m,
				y2: y
			};
		} else $e("Edge ".concat(e.id(), " has edge-distances:endpoints specified without manual endpoints specified via source-endpoint and target-endpoint.  Falling back on edge-distances:intersection (default).")), r = n;
	}
	return {
		midptPts: r,
		vectorNormInverse: a
	};
}, Wg.findHaystackPoints = function(e) {
	for (var t = 0; t < e.length; t++) {
		var r = e[t], i = r._private, n = i.rscratch;
		if (!n.haystack) {
			var a = 2 * Math.random() * Math.PI;
			n.source = {
				x: Math.cos(a),
				y: Math.sin(a)
			}, n.target = {
				x: Math.cos(a = 2 * Math.random() * Math.PI),
				y: Math.sin(a)
			};
		}
		var s = i.source, o = i.target, l = s.position(), h = o.position(), u = s.width(), d = o.width(), p = s.height(), f = o.height(), g = r.pstyle("haystack-radius").value / 2;
		n.haystackPts = n.allpts = [
			n.source.x * u * g + l.x,
			n.source.y * p * g + l.y,
			n.target.x * d * g + h.x,
			n.target.y * f * g + h.y
		], n.midX = (n.allpts[0] + n.allpts[2]) / 2, n.midY = (n.allpts[1] + n.allpts[3]) / 2, n.edgeType = "haystack", n.haystack = !0, this.storeEdgeProjections(r), this.calculateArrowAngles(r), this.recalculateEdgeLabelProjections(r), this.calculateLabelAngles(r);
	}
}, Wg.findSegmentsPoints = function(e, t) {
	var r = e._private.rscratch, i = e.pstyle("segment-weights"), n = e.pstyle("segment-distances"), a = e.pstyle("segment-radii"), s = e.pstyle("radius-type"), o = Math.min(i.pfValue.length, n.pfValue.length), l = a.pfValue[a.pfValue.length - 1], h = s.pfValue[s.pfValue.length - 1];
	r.edgeType = "segments", r.segpts = [], r.radii = [], r.isArcRadius = [];
	for (var u = 0; u < o; u++) {
		var d = i.pfValue[u], p = n.pfValue[u], f = 1 - d, g = this.findMidptPtsEtc(e, t), m = g.midptPts, y = g.vectorNormInverse, v = {
			x: m.x1 * f + m.x2 * d,
			y: m.y1 * f + m.y2 * d
		};
		r.segpts.push(v.x + y.x * p, v.y + y.y * p), r.radii.push(void 0 !== a.pfValue[u] ? a.pfValue[u] : l), r.isArcRadius.push((void 0 !== s.pfValue[u] ? s.pfValue[u] : h) === "arc-radius");
	}
}, Wg.findLoopPoints = function(e, t, r, i) {
	var n = e._private.rscratch, a = t.dirCounts, s = t.srcPos, o = e.pstyle("control-point-distances"), l = o ? o.pfValue[0] : void 0, h = e.pstyle("loop-direction").pfValue, u = e.pstyle("loop-sweep").pfValue, d = e.pstyle("control-point-step-size").pfValue;
	n.edgeType = "self";
	var p = r, f = d;
	i && (p = 0, f = l);
	var g = h - Math.PI / 2, m = g - u / 2, y = g + u / 2, v = h + "_" + u;
	p = void 0 === a[v] ? a[v] = 0 : ++a[v], n.ctrlpts = [
		s.x + 1.4 * Math.cos(m) * f * (p / 3 + 1),
		s.y + 1.4 * Math.sin(m) * f * (p / 3 + 1),
		s.x + 1.4 * Math.cos(y) * f * (p / 3 + 1),
		s.y + 1.4 * Math.sin(y) * f * (p / 3 + 1)
	];
}, Wg.findCompoundLoopPoints = function(e, t, r, i) {
	var n = e._private.rscratch;
	n.edgeType = "compound";
	var a = t.srcPos, s = t.tgtPos, o = t.srcW, l = t.srcH, h = t.tgtW, u = t.tgtH, d = e.pstyle("control-point-step-size").pfValue, p = e.pstyle("control-point-distances"), f = p ? p.pfValue[0] : void 0, g = r, m = d;
	i && (g = 0, m = f);
	var y = {
		x: a.x - o / 2,
		y: a.y - l / 2
	}, v = {
		x: s.x - h / 2,
		y: s.y - u / 2
	}, x = {
		x: Math.min(y.x, v.x),
		y: Math.min(y.y, v.y)
	}, b = Math.max(.5, Math.log(.01 * o)), w = Math.max(.5, Math.log(.01 * h));
	n.ctrlpts = [
		x.x,
		x.y - 1.7995514309304248 * m * (g / 3 + 1) * b,
		x.x - 1.7995514309304248 * m * (g / 3 + 1) * w,
		x.y
	];
}, Wg.findStraightEdgePoints = function(e) {
	e._private.rscratch.edgeType = "straight";
}, Wg.findBezierPoints = function(e, t, r, i, n) {
	var a = e._private.rscratch, s = e.pstyle("control-point-step-size").pfValue, o = e.pstyle("control-point-distances"), l = e.pstyle("control-point-weights"), h = o && l ? Math.min(o.value.length, l.value.length) : 1, u = o ? o.pfValue[0] : void 0, d = l.value[0];
	a.edgeType = i ? "multibezier" : "bezier", a.ctrlpts = [];
	for (var p = 0; p < h; p++) {
		var f = (.5 - t.eles.length / 2 + r) * s * (n ? -1 : 1), g = void 0, m = Py(f);
		i && (u = o ? o.pfValue[p] : s, d = l.value[p]);
		var y = void 0 !== (g = i ? u : void 0 !== u ? m * u : void 0) ? g : f, v = 1 - d, x = d, b = this.findMidptPtsEtc(e, t), w = b.midptPts, k = b.vectorNormInverse, T = {
			x: w.x1 * v + w.x2 * x,
			y: w.y1 * v + w.y2 * x
		};
		a.ctrlpts.push(T.x + k.x * y, T.y + k.y * y);
	}
}, Wg.findTaxiPoints = function(e, t) {
	var r, i = e._private.rscratch;
	i.edgeType = "segments";
	var n = "vertical", a = "horizontal", s = "leftward", o = "rightward", l = "downward", u = "upward", d = t.posPts, p = t.srcW, f = t.srcH, g = t.tgtW, m = t.tgtH, y = "node-position" !== e.pstyle("edge-distances").value, v = e.pstyle("taxi-direction").value, x = v, b = e.pstyle("taxi-turn"), w = "%" === b.units, k = b.pfValue, T = k < 0, _ = e.pstyle("taxi-turn-min-distance").pfValue, E = d.x2 - d.x1, C = d.y2 - d.y1, S = h(function(e, t) {
		return e > 0 ? Math.max(e - t, 0) : Math.min(e + t, 0);
	}, "subDWH"), A = S(E, y ? (p + g) / 2 : 0), L = S(C, y ? (f + m) / 2 : 0), R = !1;
	"auto" === x ? v = Math.abs(A) > Math.abs(L) ? a : n : x === u || x === l ? (v = n, R = !0) : (x === s || x === o) && (v = a, R = !0);
	var N = v === n, I = N ? L : A, M = N ? C : E, D = Py(M), O = !1;
	!(R && (w || T)) && (x === l && M < 0 || x === u && M > 0 || x === s && M > 0 || x === o && M < 0) && (D *= -1, I = D * Math.abs(I), O = !0), r = w ? (k < 0 ? 1 + k : k) * I : (k < 0 ? I : 0) + k * D;
	var $ = h(function(e) {
		return Math.abs(e) < _ || Math.abs(e) >= Math.abs(I);
	}, "getIsTooClose"), P = $(r), B = $(Math.abs(I) - Math.abs(r));
	if ((P || B) && !O) if (N) {
		var F = Math.abs(E) <= g / 2;
		if (Math.abs(M) <= f / 2) {
			var z = (d.x1 + d.x2) / 2;
			i.segpts = [
				z,
				d.y1,
				z,
				d.y2
			];
		} else if (F) {
			var U = (d.y1 + d.y2) / 2;
			i.segpts = [
				d.x1,
				U,
				d.x2,
				U
			];
		} else i.segpts = [d.x1, d.y2];
	} else {
		var G = Math.abs(C) <= m / 2;
		if (Math.abs(M) <= p / 2) {
			var q = (d.y1 + d.y2) / 2;
			i.segpts = [
				d.x1,
				q,
				d.x2,
				q
			];
		} else if (G) {
			var j = (d.x1 + d.x2) / 2;
			i.segpts = [
				j,
				d.y1,
				j,
				d.y2
			];
		} else i.segpts = [d.x2, d.y1];
	}
	else if (N) {
		var W = d.y1 + r + (y ? f / 2 * D : 0);
		i.segpts = [
			d.x1,
			W,
			d.x2,
			W
		];
	} else {
		var Y = d.x1 + r + (y ? p / 2 * D : 0);
		i.segpts = [
			Y,
			d.y1,
			Y,
			d.y2
		];
	}
	if (i.isRound) {
		var V = e.pstyle("taxi-radius").value, H = "arc-radius" === e.pstyle("radius-type").value[0];
		i.radii = Array(i.segpts.length / 2).fill(V), i.isArcRadius = Array(i.segpts.length / 2).fill(H);
	}
}, Wg.tryToCorrectInvalidPoints = function(e, t) {
	var r = e._private.rscratch;
	if ("bezier" === r.edgeType) {
		var i = t.srcPos, n = t.tgtPos, a = t.srcW, s = t.srcH, o = t.tgtW, l = t.tgtH, h = t.srcShape, u = t.tgtShape, d = t.srcCornerRadius, p = t.tgtCornerRadius, f = t.srcRs, g = t.tgtRs, m = !DH(r.startX) || !DH(r.startY), y = !DH(r.arrowStartX) || !DH(r.arrowStartY), v = !DH(r.endX) || !DH(r.endY), x = !DH(r.arrowEndX) || !DH(r.arrowEndY), b = 3 * (this.getArrowWidth(e.pstyle("width").pfValue, e.pstyle("arrow-scale").value) * this.arrowShapeWidth), w = Pv({
			x: r.ctrlpts[0],
			y: r.ctrlpts[1]
		}, {
			x: r.startX,
			y: r.startY
		}), k = w < b, T = Pv({
			x: r.ctrlpts[0],
			y: r.ctrlpts[1]
		}, {
			x: r.endX,
			y: r.endY
		}), _ = T < b, E = !1;
		if (m || y || k) {
			E = !0;
			var C = {
				x: r.ctrlpts[0] - i.x,
				y: r.ctrlpts[1] - i.y
			}, S = Math.sqrt(C.x * C.x + C.y * C.y), A = {
				x: C.x / S,
				y: C.y / S
			}, L = Math.max(a, s), R = {
				x: r.ctrlpts[0] + 2 * A.x * L,
				y: r.ctrlpts[1] + 2 * A.y * L
			}, N = h.intersectLine(i.x, i.y, a, s, R.x, R.y, 0, d, f);
			k ? (r.ctrlpts[0] = r.ctrlpts[0] + A.x * (b - w), r.ctrlpts[1] = r.ctrlpts[1] + A.y * (b - w)) : (r.ctrlpts[0] = N[0] + A.x * b, r.ctrlpts[1] = N[1] + A.y * b);
		}
		if (v || x || _) {
			E = !0;
			var I = {
				x: r.ctrlpts[0] - n.x,
				y: r.ctrlpts[1] - n.y
			}, M = Math.sqrt(I.x * I.x + I.y * I.y), D = {
				x: I.x / M,
				y: I.y / M
			}, O = Math.max(a, s), $ = {
				x: r.ctrlpts[0] + 2 * D.x * O,
				y: r.ctrlpts[1] + 2 * D.y * O
			}, P = u.intersectLine(n.x, n.y, o, l, $.x, $.y, 0, p, g);
			_ ? (r.ctrlpts[0] = r.ctrlpts[0] + D.x * (b - T), r.ctrlpts[1] = r.ctrlpts[1] + D.y * (b - T)) : (r.ctrlpts[0] = P[0] + D.x * b, r.ctrlpts[1] = P[1] + D.y * b);
		}
		E && this.findEndpoints(e);
	}
}, Wg.storeAllpts = function(e) {
	var t = e._private.rscratch;
	if ("multibezier" === t.edgeType || "bezier" === t.edgeType || "self" === t.edgeType || "compound" === t.edgeType) {
		t.allpts = [], t.allpts.push(t.startX, t.startY);
		for (var r, i = 0; i + 1 < t.ctrlpts.length; i += 2) t.allpts.push(t.ctrlpts[i], t.ctrlpts[i + 1]), i + 3 < t.ctrlpts.length && t.allpts.push((t.ctrlpts[i] + t.ctrlpts[i + 2]) / 2, (t.ctrlpts[i + 1] + t.ctrlpts[i + 3]) / 2);
		t.allpts.push(t.endX, t.endY), t.ctrlpts.length / 2 % 2 == 0 ? (r = t.allpts.length / 2 - 1, t.midX = t.allpts[r], t.midY = t.allpts[r + 1]) : (r = t.allpts.length / 2 - 3, t.midX = Pw(t.allpts[r], t.allpts[r + 2], t.allpts[r + 4], .5), t.midY = Pw(t.allpts[r + 1], t.allpts[r + 3], t.allpts[r + 5], .5));
	} else if ("straight" === t.edgeType) t.allpts = [
		t.startX,
		t.startY,
		t.endX,
		t.endY
	], t.midX = (t.startX + t.endX + t.arrowStartX + t.arrowEndX) / 4, t.midY = (t.startY + t.endY + t.arrowStartY + t.arrowEndY) / 4;
	else if ("segments" === t.edgeType) {
		if (t.allpts = [], t.allpts.push(t.startX, t.startY), t.allpts.push.apply(t.allpts, t.segpts), t.allpts.push(t.endX, t.endY), t.isRound) {
			t.roundCorners = [];
			for (var n = 2; n + 3 < t.allpts.length; n += 2) {
				var a = t.radii[n / 2 - 1], s = t.isArcRadius[n / 2 - 1];
				t.roundCorners.push(Wp({
					x: t.allpts[n - 2],
					y: t.allpts[n - 1]
				}, {
					x: t.allpts[n],
					y: t.allpts[n + 1],
					radius: a
				}, {
					x: t.allpts[n + 2],
					y: t.allpts[n + 3]
				}, a, s));
			}
		}
		if (t.segpts.length % 4 == 0) {
			var o = t.segpts.length / 2, l = o - 2;
			t.midX = (t.segpts[l] + t.segpts[o]) / 2, t.midY = (t.segpts[l + 1] + t.segpts[o + 1]) / 2;
		} else {
			var h = t.segpts.length / 2 - 1;
			if (t.isRound) {
				var u = {
					x: t.segpts[h],
					y: t.segpts[h + 1]
				}, d = t.roundCorners[h / 2];
				if (0 === d.radius) {
					var p = {
						x: t.segpts[h + 2],
						y: t.segpts[h + 3]
					};
					t.midX = u.x, t.midY = u.y, t.midVector = [u.y - p.y, p.x - u.x];
				} else {
					var f = [u.x - d.cx, u.y - d.cy], g = d.radius / Math.sqrt(Math.pow(f[0], 2) + Math.pow(f[1], 2));
					f = f.map(function(e) {
						return e * g;
					}), t.midX = d.cx + f[0], t.midY = d.cy + f[1], t.midVector = f;
				}
			} else t.midX = t.segpts[h], t.midY = t.segpts[h + 1];
		}
	}
}, Wg.checkForInvalidEdgeWarning = function(e) {
	var t = e[0]._private.rscratch;
	t.nodesOverlap || DH(t.startX) && DH(t.startY) && DH(t.endX) && DH(t.endY) ? t.loggedErr = !1 : t.loggedErr || (t.loggedErr = !0, $e("Edge `" + e.id() + "` has invalid endpoints and so it is impossible to draw.  Adjust your edge style (e.g. control points) accordingly or use an alternative edge type.  This is expected behaviour when the source node and the target node overlap."));
}, Wg.findEdgeControlPoints = function(e) {
	var t = this;
	if (!(!e || 0 === e.length)) {
		for (var r = this, i = r.cy.hasCompoundNodes(), n = new $f(), a = h(function(e, t) {
			return [].concat(DN(e), [+!!t]).join("-");
		}, "getKey"), s = [], o = [], l = 0; l < e.length; l++) {
			var u = e[l], d = u._private, p = u.pstyle("curve-style").value;
			if (!(u.removed() || !u.takesUpSpace())) {
				if ("haystack" === p) {
					o.push(u);
					continue;
				}
				var f = "unbundled-bezier" === p || Oi(p, "segments") || "straight" === p || "straight-triangle" === p || Oi(p, "taxi"), g = "unbundled-bezier" === p || "bezier" === p, m = d.source, y = d.target, v = [m.poolIndex(), y.poolIndex()].sort(), x = a(v, f), b = n.get(x);
				b ?? (b = { eles: [] }, s.push({
					pairId: v,
					edgeIsUnbundled: f
				}), n.set(x, b)), b.eles.push(u), f && (b.hasUnbundled = !0), g && (b.hasBezier = !0);
			}
		}
		for (var w = h(function() {
			var e, o = s[k], l = a(o.pairId, o.edgeIsUnbundled), h = n.get(l);
			if (!h.hasUnbundled) {
				var u = h.eles[0].parallelEdges().filter(function(e) {
					return e.isBundledBezier();
				});
				$c(h.eles), u.forEach(function(e) {
					return h.eles.push(e);
				}), h.eles.sort(function(e, t) {
					return e.poolIndex() - t.poolIndex();
				});
			}
			var d = h.eles[0], p = d.source(), f = d.target();
			if (p.poolIndex() > f.poolIndex()) {
				var g = p;
				p = f, f = g;
			}
			var m = h.srcPos = p.position(), y = h.tgtPos = f.position(), v = h.srcW = p.outerWidth(), x = h.srcH = p.outerHeight(), b = h.tgtW = f.outerWidth(), w = h.tgtH = f.outerHeight(), T = h.srcShape = r.nodeShapes[t.getNodeShape(p)], _ = h.tgtShape = r.nodeShapes[t.getNodeShape(f)], E = h.srcCornerRadius = "auto" === p.pstyle("corner-radius").value ? "auto" : p.pstyle("corner-radius").pfValue, C = h.tgtCornerRadius = "auto" === f.pstyle("corner-radius").value ? "auto" : f.pstyle("corner-radius").pfValue, S = h.tgtRs = f._private.rscratch, A = h.srcRs = p._private.rscratch;
			h.dirCounts = {
				north: 0,
				west: 0,
				south: 0,
				east: 0,
				northwest: 0,
				southwest: 0,
				northeast: 0,
				southeast: 0
			};
			for (var L = 0; L < h.eles.length; L++) {
				var R = h.eles[L], N = R[0]._private.rscratch, I = R.pstyle("curve-style").value, M = "unbundled-bezier" === I || Oi(I, "segments") || Oi(I, "taxi"), D = !p.same(R.source());
				if (!h.calculatedIntersection && p !== f && (h.hasBezier || h.hasUnbundled)) {
					h.calculatedIntersection = !0;
					var O = T.intersectLine(m.x, m.y, v, x, y.x, y.y, 0, E, A), $ = h.srcIntn = O, P = _.intersectLine(y.x, y.y, b, w, m.x, m.y, 0, C, S), B = h.tgtIntn = P, F = h.intersectionPts = {
						x1: O[0],
						x2: P[0],
						y1: O[1],
						y2: P[1]
					}, z = h.posPts = {
						x1: m.x,
						x2: y.x,
						y1: m.y,
						y2: y.y
					}, U = P[1] - O[1], G = P[0] - O[0], q = Math.sqrt(G * G + U * U);
					DH(q) && q >= Wf || (q = Math.sqrt(Math.max(G * G, .01) + Math.max(U * U, .01)));
					var j = h.vector = {
						x: G,
						y: U
					}, W = h.vectorNorm = {
						x: j.x / q,
						y: j.y / q
					}, Y = {
						x: -W.y,
						y: W.x
					};
					h.nodesOverlap = !DH(q) || _.checkPoint(O[0], O[1], 0, b, w, y.x, y.y, C, S) || T.checkPoint(P[0], P[1], 0, v, x, m.x, m.y, E, A), h.vectorNormInverse = Y, e = {
						nodesOverlap: h.nodesOverlap,
						dirCounts: h.dirCounts,
						calculatedIntersection: !0,
						hasBezier: h.hasBezier,
						hasUnbundled: h.hasUnbundled,
						eles: h.eles,
						srcPos: y,
						srcRs: S,
						tgtPos: m,
						tgtRs: A,
						srcW: b,
						srcH: w,
						tgtW: v,
						tgtH: x,
						srcIntn: B,
						tgtIntn: $,
						srcShape: _,
						tgtShape: T,
						posPts: {
							x1: z.x2,
							y1: z.y2,
							x2: z.x1,
							y2: z.y1
						},
						intersectionPts: {
							x1: F.x2,
							y1: F.y2,
							x2: F.x1,
							y2: F.y1
						},
						vector: {
							x: -j.x,
							y: -j.y
						},
						vectorNorm: {
							x: -W.x,
							y: -W.y
						},
						vectorNormInverse: {
							x: -Y.x,
							y: -Y.y
						}
					};
				}
				var V = D ? e : h;
				N.nodesOverlap = V.nodesOverlap, N.srcIntn = V.srcIntn, N.tgtIntn = V.tgtIntn, N.isRound = I.startsWith("round"), i && (p.isParent() || p.isChild() || f.isParent() || f.isChild()) && (p.parents().anySame(f) || f.parents().anySame(p) || p.same(f) && p.isParent()) ? t.findCompoundLoopPoints(R, V, L, M) : p === f ? t.findLoopPoints(R, V, L, M) : I.endsWith("segments") ? t.findSegmentsPoints(R, V) : I.endsWith("taxi") ? t.findTaxiPoints(R, V) : "straight" !== I && (M || h.eles.length % 2 != 1 || L !== Math.floor(h.eles.length / 2)) ? t.findBezierPoints(R, V, L, M, D) : t.findStraightEdgePoints(R), t.findEndpoints(R), t.tryToCorrectInvalidPoints(R, V), t.checkForInvalidEdgeWarning(R), t.storeAllpts(R), t.storeEdgeProjections(R), t.calculateArrowAngles(R), t.recalculateEdgeLabelProjections(R), t.calculateLabelAngles(R);
			}
		}, "_loop"), k = 0; k < s.length; k++) w();
		this.findHaystackPoints(o);
	}
}, h(Wm, "getPts"), Wg.getSegmentPoints = function(e) {
	var t = e[0]._private.rscratch;
	if (this.recalculateRenderedStyle(e), "segments" === t.edgeType) return Wm(t.segpts);
}, Wg.getControlPoints = function(e) {
	var t = e[0]._private.rscratch;
	this.recalculateRenderedStyle(e);
	var r = t.edgeType;
	if ("bezier" === r || "multibezier" === r || "self" === r || "compound" === r) return Wm(t.ctrlpts);
}, Wg.getEdgeMidpoint = function(e) {
	var t = e[0]._private.rscratch;
	return this.recalculateRenderedStyle(e), {
		x: t.midX,
		y: t.midY
	};
};
var Wy = {};
Wy.manualEndptToPx = function(e, t) {
	var r = e.position(), i = e.outerWidth(), n = e.outerHeight(), a = e._private.rscratch;
	if (2 === t.value.length) {
		var s = [t.pfValue[0], t.pfValue[1]];
		return "%" === t.units[0] && (s[0] = s[0] * i), "%" === t.units[1] && (s[1] = s[1] * n), s[0] += r.x, s[1] += r.y, s;
	}
	var o = t.pfValue[0];
	o = -Math.PI / 2 + o;
	var l = 2 * Math.max(i, n), h = [r.x + Math.cos(o) * l, r.y + Math.sin(o) * l];
	return this.nodeShapes[this.getNodeShape(e)].intersectLine(r.x, r.y, i, n, h[0], h[1], 0, "auto" === e.pstyle("corner-radius").value ? "auto" : e.pstyle("corner-radius").pfValue, a);
}, Wy.findEndpoints = function(e) {
	var t, r, i, n, a, s = e.source()[0], o = e.target()[0], l = s.position(), h = o.position(), u = e.pstyle("target-arrow-shape").value, d = e.pstyle("source-arrow-shape").value, p = e.pstyle("target-distance-from-node").pfValue, f = e.pstyle("source-distance-from-node").pfValue, g = s._private.rscratch, m = o._private.rscratch, y = e.pstyle("curve-style").value, v = e._private.rscratch, x = v.edgeType, b = Oi(y, "taxi"), w = "self" === x || "compound" === x, k = "bezier" === x || "multibezier" === x || w, T = "bezier" !== x, _ = "straight" === x || "segments" === x, E = "segments" === x, C = w || b, S = e.pstyle("source-endpoint"), A = C ? "outside-to-node" : S.value, L = "auto" === s.pstyle("corner-radius").value ? "auto" : s.pstyle("corner-radius").pfValue, R = e.pstyle("target-endpoint"), N = C ? "outside-to-node" : R.value, I = "auto" === o.pstyle("corner-radius").value ? "auto" : o.pstyle("corner-radius").pfValue;
	v.srcManEndpt = S, v.tgtManEndpt = R;
	var M, D, O, $, P = null != (t = (null == R || null == (r = R.pfValue) ? void 0 : r.length) === 2 ? R.pfValue : null) ? t : [0, 0], B = null != (i = (null == S || null == (n = S.pfValue) ? void 0 : n.length) === 2 ? S.pfValue : null) ? i : [0, 0];
	if (k) {
		var F = [v.ctrlpts[0], v.ctrlpts[1]];
		M = T ? [v.ctrlpts[v.ctrlpts.length - 2], v.ctrlpts[v.ctrlpts.length - 1]] : F, D = F;
	} else if (_) {
		var z = E ? v.segpts.slice(0, 2) : [h.x + P[0], h.y + P[1]];
		M = E ? v.segpts.slice(v.segpts.length - 2) : [l.x + B[0], l.y + B[1]], D = z;
	}
	if ("inside-to-node" === N) a = [h.x, h.y];
	else if (R.units) a = this.manualEndptToPx(o, R);
	else if ("outside-to-line" === N) a = v.tgtIntn;
	else if ("outside-to-node" === N || "outside-to-node-or-label" === N ? O = M : ("outside-to-line" === N || "outside-to-line-or-label" === N) && (O = [l.x, l.y]), a = this.nodeShapes[this.getNodeShape(o)].intersectLine(h.x, h.y, o.outerWidth(), o.outerHeight(), O[0], O[1], 0, I, m), "outside-to-node-or-label" === N || "outside-to-line-or-label" === N) {
		var U = o._private.rscratch, G = U.labelWidth, q = U.labelHeight, j = U.labelX, W = U.labelY, Y = G / 2, V = q / 2, H = o.pstyle("text-valign").value;
		"top" === H ? W -= V : "bottom" === H && (W += V);
		var X = o.pstyle("text-halign").value;
		"left" === X ? j -= Y : "right" === X && (j += Y);
		var K = P5(O[0], O[1], [
			j - Y,
			W - V,
			j + Y,
			W - V,
			j + Y,
			W + V,
			j - Y,
			W + V
		], h.x, h.y);
		if (K.length > 0) {
			var Z = Px(l, Pc(a)), Q = Px(l, Pc(K)), J = Z;
			Q < Z && (a = K, J = Q), K.length > 2 && Px(l, {
				x: K[2],
				y: K[3]
			}) < J && (a = [K[2], K[3]]);
		}
	}
	var ee = P6(a, M, this.arrowShapes[u].spacing(e) + p), et = P6(a, M, this.arrowShapes[u].gap(e) + p);
	if (v.endX = et[0], v.endY = et[1], v.arrowEndX = ee[0], v.arrowEndY = ee[1], "inside-to-node" === A) a = [l.x, l.y];
	else if (S.units) a = this.manualEndptToPx(s, S);
	else if ("outside-to-line" === A) a = v.srcIntn;
	else if ("outside-to-node" === A || "outside-to-node-or-label" === A ? $ = D : ("outside-to-line" === A || "outside-to-line-or-label" === A) && ($ = [h.x, h.y]), a = this.nodeShapes[this.getNodeShape(s)].intersectLine(l.x, l.y, s.outerWidth(), s.outerHeight(), $[0], $[1], 0, L, g), "outside-to-node-or-label" === A || "outside-to-line-or-label" === A) {
		var er = s._private.rscratch, ei = er.labelWidth, en = er.labelHeight, ea = er.labelX, es = er.labelY, eo = ei / 2, el = en / 2, ec = s.pstyle("text-valign").value;
		"top" === ec ? es -= el : "bottom" === ec && (es += el);
		var eh = s.pstyle("text-halign").value;
		"left" === eh ? ea -= eo : "right" === eh && (ea += eo);
		var eu = P5($[0], $[1], [
			ea - eo,
			es - el,
			ea + eo,
			es - el,
			ea + eo,
			es + el,
			ea - eo,
			es + el
		], l.x, l.y);
		if (eu.length > 0) {
			var ed = Px(h, Pc(a)), ep = Px(h, Pc(eu)), ef = ed;
			ep < ed && (a = [eu[0], eu[1]], ef = ep), eu.length > 2 && Px(h, {
				x: eu[2],
				y: eu[3]
			}) < ef && (a = [eu[2], eu[3]]);
		}
	}
	var eg = P6(a, D, this.arrowShapes[d].spacing(e) + f), em = P6(a, D, this.arrowShapes[d].gap(e) + f);
	v.startX = em[0], v.startY = em[1], v.arrowStartX = eg[0], v.arrowStartY = eg[1], (k || T || _) && (DH(v.startX) && DH(v.startY) && DH(v.endX) && DH(v.endY) ? v.badLine = !1 : v.badLine = !0);
}, Wy.getSourceEndpoint = function(e) {
	var t = e[0]._private.rscratch;
	return (this.recalculateRenderedStyle(e), "haystack" === t.edgeType) ? {
		x: t.haystackPts[0],
		y: t.haystackPts[1]
	} : {
		x: t.arrowStartX,
		y: t.arrowStartY
	};
}, Wy.getTargetEndpoint = function(e) {
	var t = e[0]._private.rscratch;
	return (this.recalculateRenderedStyle(e), "haystack" === t.edgeType) ? {
		x: t.haystackPts[2],
		y: t.haystackPts[3]
	} : {
		x: t.arrowEndX,
		y: t.arrowEndY
	};
};
var Wv = {};
function Wx(e, t, r) {
	for (var i = h(function(e, t, r, i) {
		return Pw(e, t, r, i);
	}, "qbezierAt$1"), n = t._private.rstyle.bezierPts, a = 0; a < e.bezierProjPcts.length; a++) {
		var s = e.bezierProjPcts[a];
		n.push({
			x: i(r[0], r[2], r[4], s),
			y: i(r[1], r[3], r[5], s)
		});
	}
}
h(Wx, "pushBezierPts"), Wv.storeEdgeProjections = function(e) {
	var t = e._private, r = t.rscratch, i = r.edgeType;
	if (t.rstyle.bezierPts = null, t.rstyle.linePts = null, t.rstyle.haystackPts = null, "multibezier" === i || "bezier" === i || "self" === i || "compound" === i) {
		t.rstyle.bezierPts = [];
		for (var n = 0; n + 5 < r.allpts.length; n += 4) Wx(this, e, r.allpts.slice(n, n + 6));
	} else if ("segments" === i) for (var a = t.rstyle.linePts = [], n = 0; n + 1 < r.allpts.length; n += 2) a.push({
		x: r.allpts[n],
		y: r.allpts[n + 1]
	});
	else if ("haystack" === i) {
		var s = r.haystackPts;
		t.rstyle.haystackPts = [{
			x: s[0],
			y: s[1]
		}, {
			x: s[2],
			y: s[3]
		}];
	}
	t.rstyle.arrowWidth = this.getArrowWidth(e.pstyle("width").pfValue, e.pstyle("arrow-scale").value) * this.arrowShapeWidth;
}, Wv.recalculateEdgeProjections = function(e) {
	this.findEdgeControlPoints(e);
};
var Wb = {};
Wb.recalculateNodeLabelProjection = function(e) {
	if (!D4(e.pstyle("label").strValue)) {
		var t, r, i = e._private, n = e.width(), a = e.height(), s = e.padding(), o = e.position(), l = e.pstyle("text-halign").strValue, h = e.pstyle("text-valign").strValue, u = i.rscratch, d = i.rstyle;
		switch (l) {
			case "left":
				t = o.x - n / 2 - s;
				break;
			case "right":
				t = o.x + n / 2 + s;
				break;
			default: t = o.x;
		}
		switch (h) {
			case "top":
				r = o.y - a / 2 - s;
				break;
			case "bottom":
				r = o.y + a / 2 + s;
				break;
			default: r = o.y;
		}
		u.labelX = t, u.labelY = r, d.labelX = t, d.labelY = r, this.calculateLabelAngles(e), this.applyLabelDimensions(e);
	}
};
var Ww = h(function(e, t) {
	var r = Math.atan(t / e);
	return 0 === e && r < 0 && (r *= -1), r;
}, "lineAngleFromDelta"), Wk = h(function(e, t) {
	return Ww(t.x - e.x, t.y - e.y);
}, "lineAngle"), WT = h(function(e, t, r, i) {
	var n = P_(0, i - .001, 1), a = P_(0, i + .001, 1);
	return Wk(Pk(e, t, r, n), Pk(e, t, r, a));
}, "bezierAngle");
Wb.recalculateEdgeLabelProjections = function(e) {
	var t, r = e._private, i = r.rscratch, n = this, a = {
		mid: e.pstyle("label").strValue,
		source: e.pstyle("source-label").strValue,
		target: e.pstyle("target-label").strValue
	};
	if (a.mid || a.source || a.target) {
		t = {
			x: i.midX,
			y: i.midY
		};
		var s = h(function(e, t, i) {
			$d(r.rscratch, e, t, i), $d(r.rstyle, e, t, i);
		}, "setRs");
		s("labelX", null, t.x), s("labelY", null, t.y), s("labelAutoAngle", null, Ww(i.midDispX, i.midDispY));
		var o = h(function() {
			if (o.cache) return o.cache;
			for (var e = [], t = 0; t + 5 < i.allpts.length; t += 4) {
				var a = {
					x: i.allpts[t],
					y: i.allpts[t + 1]
				}, s = {
					x: i.allpts[t + 2],
					y: i.allpts[t + 3]
				}, l = {
					x: i.allpts[t + 4],
					y: i.allpts[t + 5]
				};
				e.push({
					p0: a,
					p1: s,
					p2: l,
					startDist: 0,
					length: 0,
					segments: []
				});
			}
			var u = r.rstyle.bezierPts, d = n.bezierProjPcts.length;
			function p(e, t, r, i, n) {
				var a = Pv(t, r), s = e.segments[e.segments.length - 1], o = {
					p0: t,
					p1: r,
					t0: i,
					t1: n,
					startDist: s ? s.startDist + s.length : 0,
					length: a
				};
				e.segments.push(o), e.length += a;
			}
			h(p, "addSegment");
			for (var f = 0; f < e.length; f++) {
				var g = e[f], m = e[f - 1];
				m && (g.startDist = m.startDist + m.length), p(g, g.p0, u[f * d], 0, n.bezierProjPcts[0]);
				for (var y = 0; y < d - 1; y++) p(g, u[f * d + y], u[f * d + y + 1], n.bezierProjPcts[y], n.bezierProjPcts[y + 1]);
				p(g, u[f * d + d - 1], g.p2, n.bezierProjPcts[d - 1], 1);
			}
			return o.cache = e;
		}, "createControlPointInfo"), l = h(function(r) {
			var n, l = "source" === r;
			if (a[r]) {
				var h = e.pstyle(r + "-text-offset").pfValue;
				switch (i.edgeType) {
					case "self":
					case "compound":
					case "bezier":
					case "multibezier":
						for (var u, d = o(), p = 0, f = 0, g = 0; g < d.length; g++) {
							for (var m = d[l ? g : d.length - 1 - g], y = 0; y < m.segments.length; y++) {
								var v = m.segments[l ? y : m.segments.length - 1 - y], x = g === d.length - 1 && y === m.segments.length - 1;
								if (p = f, (f += v.length) >= h || x) {
									u = {
										cp: m,
										segment: v
									};
									break;
								}
							}
							if (u) break;
						}
						var b = u.cp, w = u.segment, k = (h - p) / w.length, T = w.t1 - w.t0, _ = l ? w.t0 + T * k : w.t1 - T * k;
						_ = P_(0, _, 1), t = Pk(b.p0, b.p1, b.p2, _), n = WT(b.p0, b.p1, b.p2, _);
						break;
					case "straight":
					case "segments":
					case "haystack":
						for (var E, C, S, A, L = 0, R = i.allpts.length, N = 0; N + 3 < R && (l ? (S = {
							x: i.allpts[N],
							y: i.allpts[N + 1]
						}, A = {
							x: i.allpts[N + 2],
							y: i.allpts[N + 3]
						}) : (S = {
							x: i.allpts[R - 2 - N],
							y: i.allpts[R - 1 - N]
						}, A = {
							x: i.allpts[R - 4 - N],
							y: i.allpts[R - 3 - N]
						}), E = Pv(S, A), C = L, !((L += E) >= h)); N += 2);
						var I = (h - C) / E;
						t = PT(S, A, I = P_(0, I, 1)), n = Wk(S, A);
				}
				s("labelX", r, t.x), s("labelY", r, t.y), s("labelAutoAngle", r, n);
			}
		}, "calculateEndProjection");
		l("source"), l("target"), this.applyLabelDimensions(e);
	}
}, Wb.applyLabelDimensions = function(e) {
	this.applyPrefixedLabelDimensions(e), e.isEdge() && (this.applyPrefixedLabelDimensions(e, "source"), this.applyPrefixedLabelDimensions(e, "target"));
}, Wb.applyPrefixedLabelDimensions = function(e, t) {
	var r = e._private, i = this.getLabelText(e, t), n = OH(i, e._private.labelDimsKey);
	if ($u(r.rscratch, "prefixedLabelDimsKey", t) !== n) {
		$d(r.rscratch, "prefixedLabelDimsKey", t, n);
		var a = this.calculateLabelDimensions(e, i), s = e.pstyle("line-height").pfValue, o = e.pstyle("text-wrap").strValue, l = $u(r.rscratch, "labelWrapCachedLines", t) || [], h = "wrap" !== o ? 1 : Math.max(l.length, 1), u = a.height / h, d = a.width, p = a.height + (h - 1) * (s - 1) * u;
		$d(r.rstyle, "labelWidth", t, d), $d(r.rscratch, "labelWidth", t, d), $d(r.rstyle, "labelHeight", t, p), $d(r.rscratch, "labelHeight", t, p), $d(r.rscratch, "labelLineHeight", t, u * s);
	}
}, Wb.getLabelText = function(e, t) {
	var r = e._private, i = t ? t + "-" : "", n = e.pstyle(i + "label").strValue, a = e.pstyle("text-transform").value, s = h(function(e, i) {
		return i ? ($d(r.rscratch, e, t, i), i) : $u(r.rscratch, e, t);
	}, "rscratch");
	if (!n) return "";
	"none" == a || ("uppercase" == a ? n = n.toUpperCase() : "lowercase" == a && (n = n.toLowerCase()));
	var o = e.pstyle("text-wrap").value;
	if ("wrap" === o) {
		var l = s("labelKey");
		if (null != l && s("labelWrapKey") === l) return s("labelWrapCachedText");
		for (var u = n.split(`
`), d = e.pstyle("text-max-width").pfValue, p = "anywhere" === e.pstyle("text-overflow-wrap").value, f = [], g = /[\s\u200b]+|$/g, m = 0; m < u.length; m++) {
			var y = u[m], v = this.calculateLabelDimensions(e, y).width;
			if (p && (y = y.split("").join("")), v > d) {
				var x, b = y.matchAll(g), w = "", k = 0, T = D_(b);
				try {
					for (T.s(); !(x = T.n()).done;) {
						var _ = x.value, E = _[0], C = y.substring(k, _.index);
						k = _.index + E.length;
						var S = 0 === w.length ? C : w + C + E;
						this.calculateLabelDimensions(e, S).width <= d ? w += C + E : (w && f.push(w), w = C + E);
					}
				} catch (e) {
					T.e(e);
				} finally {
					T.f();
				}
				w.match(/^[\s\u200b]+$/) || f.push(w);
			} else f.push(y);
		}
		s("labelWrapCachedLines", f), n = s("labelWrapCachedText", f.join(`
`)), s("labelWrapKey", l);
	} else if ("ellipsis" === o) {
		var A = e.pstyle("text-max-width").pfValue, L = "", R = !1;
		if (this.calculateLabelDimensions(e, n).width < A) return n;
		for (var N = 0; N < n.length && !(this.calculateLabelDimensions(e, L + n[N] + "").width > A); N++) L += n[N], N === n.length - 1 && (R = !0);
		return R || (L += ""), L;
	}
	return n;
}, Wb.getLabelJustification = function(e) {
	var t = e.pstyle("text-justification").strValue, r = e.pstyle("text-halign").strValue;
	if ("auto" !== t) return t;
	if (!e.isNode()) return "center";
	switch (r) {
		case "left": return "right";
		case "right": return "left";
		default: return "center";
	}
}, Wb.calculateLabelDimensions = function(e, t) {
	var r = this.cy.window().document, i = e.pstyle("font-style").strValue, n = e.pstyle("font-size").pfValue, a = e.pstyle("font-family").strValue, s = e.pstyle("font-weight").strValue, o = this.labelCalcCanvas, l = this.labelCalcCanvasContext;
	if (!o) {
		o = this.labelCalcCanvas = r.createElement("canvas"), l = this.labelCalcCanvasContext = o.getContext("2d");
		var h = o.style;
		h.position = "absolute", h.left = "-9999px", h.top = "-9999px", h.zIndex = "-1", h.visibility = "hidden", h.pointerEvents = "none";
	}
	l.font = "".concat(i, " ").concat(s, " ").concat(n, "px ").concat(a);
	for (var u = 0, d = 0, p = t.split(`
`), f = 0; f < p.length; f++) {
		var g = p[f];
		u = Math.max(Math.ceil(l.measureText(g).width), u), d += n;
	}
	return {
		width: u += 0,
		height: d += 0
	};
}, Wb.calculateLabelAngle = function(e, t) {
	var r = e._private.rscratch, i = e.isEdge(), n = e.pstyle((t ? t + "-" : "") + "text-rotation"), a = n.strValue;
	return "none" === a ? 0 : i && "autorotate" === a ? r.labelAutoAngle : "autorotate" === a ? 0 : n.pfValue;
}, Wb.calculateLabelAngles = function(e) {
	var t = e.isEdge(), r = e._private.rscratch;
	r.labelAngle = this.calculateLabelAngle(e), t && (r.sourceLabelAngle = this.calculateLabelAngle(e, "source"), r.targetLabelAngle = this.calculateLabelAngle(e, "target"));
};
var W_ = {}, WE = !1;
W_.getNodeShape = function(e) {
	var t = e.pstyle("shape").value;
	if ("cutrectangle" === t && (28 > e.width() || 28 > e.height())) return WE || ($e("The `cutrectangle` node shape can not be used at small sizes so `rectangle` is used instead"), WE = !0), "rectangle";
	if (e.isParent()) return "rectangle" === t || "roundrectangle" === t || "round-rectangle" === t || "cutrectangle" === t || "cut-rectangle" === t || "barrel" === t ? t : "rectangle";
	if ("polygon" === t) {
		var r = e.pstyle("shape-polygon-points").value;
		return this.nodeShapes.makePolygon(r).name;
	}
	return t;
};
var WC = {};
WC.registerCalculationListeners = function() {
	var e = this.cy, t = e.collection(), r = this, i = h(function(e) {
		var r = !(arguments.length > 1) || void 0 === arguments[1] || arguments[1];
		if (t.merge(e), r) for (var i = 0; i < e.length; i++) {
			var n = e[i]._private.rstyle;
			n.clean = !1, n.cleanConnected = !1;
		}
	}, "enqueue");
	r.binder(e).on("bounds.* dirty.*", h(function(e) {
		i(e.target);
	}, "onDirtyBounds")).on("style.* background.*", h(function(e) {
		i(e.target, !1);
	}, "onDirtyStyle"));
	var n = h(function(n) {
		if (n) {
			var a = r.onUpdateEleCalcsFns;
			t.cleanStyle();
			for (var s = 0; s < t.length; s++) {
				var o = t[s], l = o._private.rstyle;
				o.isNode() && !l.cleanConnected && (i(o.connectedEdges()), l.cleanConnected = !0);
			}
			if (a) for (var h = 0; h < a.length; h++) (0, a[h])(n, t);
			r.recalculateRenderedStyle(t), t = e.collection();
		}
	}, "updateEleCalcs");
	r.flushRenderedStyleQueue = function() {
		n(!0);
	}, r.beforeRender(n, r.beforeRenderPriorities.eleCalcs);
}, WC.onUpdateEleCalcs = function(e) {
	(this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || []).push(e);
}, WC.recalculateRenderedStyle = function(e, t) {
	var r = h(function(e) {
		return e._private.rstyle.cleanConnected;
	}, "isCleanConnected");
	if (0 !== e.length) {
		var i = [], n = [];
		if (!this.destroyed) {
			void 0 === t && (t = !0);
			for (var a = 0; a < e.length; a++) {
				var s = e[a], o = s._private, l = o.rstyle;
				!s.isEdge() || r(s.source()) && r(s.target()) || (l.clean = !1), s.isEdge() && s.isBundledBezier() && s.parallelEdges().some(function(e) {
					return !e._private.rstyle.clean && e.isBundledBezier();
				}) && (l.clean = !1), t && l.clean || s.removed() || "none" === s.pstyle("display").value || ("nodes" === o.group ? n.push(s) : i.push(s), l.clean = !0);
			}
			for (var u = 0; u < n.length; u++) {
				var d = n[u], p = d._private.rstyle, f = d.position();
				this.recalculateNodeLabelProjection(d), p.nodeX = f.x, p.nodeY = f.y, p.nodeW = d.pstyle("width").pfValue, p.nodeH = d.pstyle("height").pfValue;
			}
			this.recalculateEdgeProjections(i);
			for (var g = 0; g < i.length; g++) {
				var m = i[g]._private, y = m.rstyle, v = m.rscratch;
				y.srcX = v.arrowStartX, y.srcY = v.arrowStartY, y.tgtX = v.arrowEndX, y.tgtY = v.arrowEndY, y.midX = v.midX, y.midY = v.midY, y.labelAngle = v.labelAngle, y.sourceLabelAngle = v.sourceLabelAngle, y.targetLabelAngle = v.targetLabelAngle;
			}
		}
	}
};
var WS = {};
WS.updateCachedGrabbedEles = function() {
	var e = this.cachedZSortedEles;
	if (e) {
		e.drag = [], e.nondrag = [];
		for (var t = [], r = 0; r < e.length; r++) {
			var i = e[r], n = i._private.rscratch;
			i.grabbed() && !i.isParent() ? t.push(i) : n.inDragLayer ? e.drag.push(i) : e.nondrag.push(i);
		}
		for (var r = 0; r < t.length; r++) {
			var i = t[r];
			e.drag.push(i);
		}
	}
}, WS.invalidateCachedZSortedEles = function() {
	this.cachedZSortedEles = null;
}, WS.getCachedZSortedEles = function(e) {
	if (e || !this.cachedZSortedEles) {
		var t = this.cy.mutableElements().toArray();
		t.sort(qu), t.interactive = t.filter(function(e) {
			return e.interactive();
		}), this.cachedZSortedEles = t, this.updateCachedGrabbedEles();
	} else t = this.cachedZSortedEles;
	return t;
};
var WA = {};
[
	jQ,
	jJ,
	Wg,
	Wy,
	Wv,
	Wb,
	W_,
	WC,
	WS
].forEach(function(e) {
	Ou(WA, e);
});
var WL = {};
WL.getCachedImage = function(e, t, r) {
	var i = this.imageCache = this.imageCache || {}, n = i[e];
	if (n) return n.image.complete || n.image.addEventListener("load", r), n.image;
	var a = (n = i[e] = i[e] || {}).image = new Image();
	a.addEventListener("load", r), a.addEventListener("error", function() {
		a.error = !0;
	});
	var s = "data:";
	return e.substring(0, s.length).toLowerCase() === s || (a.crossOrigin = t = "null" === t ? null : t), a.src = e, a;
};
var WR = {};
WR.registerBinding = function(e, t, r, i) {
	var n = Array.prototype.slice.apply(arguments, [1]);
	if (Array.isArray(e)) {
		for (var a = [], s = 0; s < e.length; s++) {
			var o = e[s];
			if (void 0 !== o) {
				var l = this.binder(o);
				a.push(l.on.apply(l, n));
			}
		}
		return a;
	}
	var l = this.binder(e);
	return l.on.apply(l, n);
}, WR.binder = function(e) {
	var t = this, r = t.cy.window(), i = e === r || e === r.document || e === r.document.body || D5(e);
	if (null == t.supportsPassiveEvents) {
		var n = !1;
		try {
			var a = Object.defineProperty({}, "passive", { get: h(function() {
				return n = !0, !0;
			}, "get") });
			r.addEventListener("test", null, a);
		} catch {}
		t.supportsPassiveEvents = n;
	}
	var s = h(function(r, n, a) {
		var s = Array.prototype.slice.call(arguments);
		return i && t.supportsPassiveEvents && (s[2] = {
			capture: a ?? !1,
			passive: !1,
			once: !1
		}), t.bindings.push({
			target: e,
			args: s
		}), (e.addEventListener || e.on).apply(e, s), this;
	}, "on");
	return {
		on: s,
		addEventListener: s,
		addListener: s,
		bind: s
	};
}, WR.nodeIsDraggable = function(e) {
	return e && e.isNode() && !e.locked() && e.grabbable();
}, WR.nodeIsGrabbable = function(e) {
	return this.nodeIsDraggable(e) && e.interactive();
}, WR.load = function() {
	var e, t, r, i, n, a, s = this, o = s.cy.window(), l = h(function(e) {
		return e.selected();
	}, "isSelected"), u = h(function(e) {
		var t = e.getRootNode();
		if (t && 11 === t.nodeType && void 0 !== t.host) return t;
	}, "getShadowRoot"), d = h(function(e, t, r, i) {
		e ??= s.cy;
		for (var n = 0; n < t.length; n++) {
			var a = t[n];
			e.emit({
				originalEvent: r,
				type: a,
				position: i
			});
		}
	}, "triggerEvents"), p = h(function(e) {
		return e.shiftKey || e.metaKey || e.ctrlKey;
	}, "isMultSelKeyDown"), f = h(function(e, t) {
		var r = !0;
		if (s.cy.hasCompoundNodes() && e && e.pannable()) for (var i = 0; t && i < t.length; i++) {
			var e = t[i];
			if (e.isNode() && e.isParent() && !e.pannable()) {
				r = !1;
				break;
			}
		}
		else r = !0;
		return r;
	}, "allowPanningPassthrough"), g = h(function(e) {
		e[0]._private.grabbed = !0;
	}, "setGrabbed"), m = h(function(e) {
		e[0]._private.grabbed = !1;
	}, "setFreed"), y = h(function(e) {
		e[0]._private.rscratch.inDragLayer = !0;
	}, "setInDragLayer"), v = h(function(e) {
		e[0]._private.rscratch.inDragLayer = !1;
	}, "setOutDragLayer"), x = h(function(e) {
		e[0]._private.rscratch.isGrabTarget = !0;
	}, "setGrabTarget"), b = h(function(e) {
		e[0]._private.rscratch.isGrabTarget = !1;
	}, "removeGrabTarget"), w = h(function(e, t) {
		var r = t.addToList;
		!r.has(e) && e.grabbable() && !e.locked() && (r.merge(e), g(e));
	}, "addToDragList"), k = h(function(e, t) {
		if (e.cy().hasCompoundNodes() && (null != t.inDragLayer || null != t.addToList)) {
			var r = e.descendants();
			t.inDragLayer && (r.forEach(y), r.connectedEdges().forEach(y)), t.addToList && w(r, t);
		}
	}, "addDescendantsToDrag"), T = h(function(e, t) {
		t = t || {};
		var r = e.cy().hasCompoundNodes();
		t.inDragLayer && (e.forEach(y), e.neighborhood().stdFilter(function(e) {
			return !r || e.isEdge();
		}).forEach(y)), t.addToList && e.forEach(function(e) {
			w(e, t);
		}), k(e, t), E(e, { inDragLayer: t.inDragLayer }), s.updateCachedGrabbedEles();
	}, "addNodesToDrag"), _ = h(function(e) {
		e && (s.getCachedZSortedEles().forEach(function(e) {
			m(e), v(e), b(e);
		}), s.updateCachedGrabbedEles());
	}, "freeDraggedElements"), E = h(function(e, t) {
		if ((null != t.inDragLayer || null != t.addToList) && e.cy().hasCompoundNodes()) {
			var r = e.ancestors().orphans();
			if (!r.same(e)) {
				var i = r.descendants().spawnSelf().merge(r).unmerge(e).unmerge(e.descendants()), n = i.connectedEdges();
				t.inDragLayer && (n.forEach(y), i.forEach(y)), t.addToList && i.forEach(function(e) {
					w(e, t);
				});
			}
		}
	}, "updateAncestorsInDragLayer"), C = h(function() {
		null != document.activeElement && null != document.activeElement.blur && document.activeElement.blur();
	}, "blurActiveDomElement"), S = "u" > typeof MutationObserver, A = "u" > typeof ResizeObserver;
	S ? (s.removeObserver = new MutationObserver(function(e) {
		for (var t = 0; t < e.length; t++) {
			var r = e[t].removedNodes;
			if (r) {
				for (var i = 0; i < r.length; i++) if (r[i] === s.container) {
					s.destroy();
					break;
				}
			}
		}
	}), s.container.parentNode && s.removeObserver.observe(s.container.parentNode, { childList: !0 })) : s.registerBinding(s.container, "DOMNodeRemoved", function(e) {
		s.destroy();
	});
	var L = O$(function() {
		s.cy.resize();
	}, 100);
	S && (s.styleObserver = new MutationObserver(L), s.styleObserver.observe(s.container, { attributes: !0 })), s.registerBinding(o, "resize", L), A && (s.resizeObserver = new ResizeObserver(L), s.resizeObserver.observe(s.container));
	var R = h(function(e, t) {
		for (; null != e;) t(e), e = e.parentNode;
	}, "forEachUp"), N = h(function() {
		s.invalidateContainerClientCoordsCache();
	}, "invalidateCoords");
	R(s.container, function(e) {
		s.registerBinding(e, "transitionend", N), s.registerBinding(e, "animationend", N), s.registerBinding(e, "scroll", N);
	}), s.registerBinding(s.container, "contextmenu", function(e) {
		e.preventDefault();
	});
	var I = h(function() {
		return 0 !== s.selection[4];
	}, "inBoxSelection"), M = h(function(e) {
		for (var t = s.findContainerClientCoords(), r = t[0], i = t[1], n = t[2], a = t[3], o = e.touches ? e.touches : [e], l = !1, h = 0; h < o.length; h++) {
			var u = o[h];
			if (r <= u.clientX && u.clientX <= r + n && i <= u.clientY && u.clientY <= i + a) {
				l = !0;
				break;
			}
		}
		if (!l) return !1;
		for (var d = s.container, p = e.target.parentNode, f = !1; p;) {
			if (p === d) {
				f = !0;
				break;
			}
			p = p.parentNode;
		}
		return !!f;
	}, "eventInContainer");
	s.registerBinding(s.container, "mousedown", h(function(e) {
		if (M(e) && (1 !== s.hoverData.which || 1 === e.which)) {
			e.preventDefault(), C(), s.hoverData.capture = !0, s.hoverData.which = e.which;
			var t = s.cy, r = [e.clientX, e.clientY], i = s.projectIntoViewport(r[0], r[1]), n = s.selection, a = s.findNearestElements(i[0], i[1], !0, !1), o = a[0], l = s.dragData.possibleDragElements;
			s.hoverData.mdownPos = i, s.hoverData.mdownGPos = r;
			var u = h(function(t) {
				return {
					originalEvent: e,
					type: t,
					position: {
						x: i[0],
						y: i[1]
					}
				};
			}, "makeEvent"), p = h(function() {
				s.hoverData.tapholdCancelled = !1, clearTimeout(s.hoverData.tapholdTimeout), s.hoverData.tapholdTimeout = setTimeout(function() {
					if (!s.hoverData.tapholdCancelled) {
						var e = s.hoverData.down;
						e ? e.emit(u("taphold")) : t.emit(u("taphold"));
					}
				}, s.tapholdDuration);
			}, "checkForTaphold");
			if (3 == e.which) {
				s.hoverData.cxtStarted = !0;
				var f = {
					originalEvent: e,
					type: "cxttapstart",
					position: {
						x: i[0],
						y: i[1]
					}
				};
				o ? (o.activate(), o.emit(f), s.hoverData.down = o) : t.emit(f), s.hoverData.downTime = (/* @__PURE__ */ new Date()).getTime(), s.hoverData.cxtDragged = !1;
			} else if (1 == e.which) {
				if (o && o.activate(), null != o && s.nodeIsGrabbable(o)) {
					var g = h(function(e) {
						e.emit(u("grab"));
					}, "triggerGrab");
					if (x(o), o.selected()) {
						l = s.dragData.possibleDragElements = t.collection();
						var m = t.$(function(e) {
							return e.isNode() && e.selected() && s.nodeIsGrabbable(e);
						});
						T(m, { addToList: l }), o.emit(u("grabon")), m.forEach(g);
					} else T(o, { addToList: l = s.dragData.possibleDragElements = t.collection() }), o.emit(u("grabon")).emit(u("grab"));
					s.redrawHint("eles", !0), s.redrawHint("drag", !0);
				}
				s.hoverData.down = o, s.hoverData.downs = a, s.hoverData.downTime = (/* @__PURE__ */ new Date()).getTime(), d(o, [
					"mousedown",
					"tapstart",
					"vmousedown"
				], e, {
					x: i[0],
					y: i[1]
				}), null == o ? (n[4] = 1, s.data.bgActivePosistion = {
					x: i[0],
					y: i[1]
				}, s.redrawHint("select", !0), s.redraw()) : o.pannable() && (n[4] = 1), p();
			}
			n[0] = n[2] = i[0], n[1] = n[3] = i[1];
		}
	}, "mousedownHandler"), !1);
	var D = u(s.container);
	s.registerBinding([o, D], "mousemove", h(function(e) {
		if (!(!s.hoverData.capture && !M(e))) {
			var t, r = !1, i = s.cy, n = i.zoom(), a = [e.clientX, e.clientY], o = s.projectIntoViewport(a[0], a[1]), l = s.hoverData.mdownPos, u = s.hoverData.mdownGPos, g = s.selection, m = null;
			s.hoverData.draggingEles || s.hoverData.dragging || s.hoverData.selecting || (m = s.findNearestElement(o[0], o[1], !0, !1));
			var y, v = s.hoverData.last, x = s.hoverData.down, b = [o[0] - g[2], o[1] - g[3]], w = s.dragData.possibleDragElements;
			if (u) {
				var k = a[0] - u[0], E = a[1] - u[1];
				s.hoverData.isOverThresholdDrag = y = k * k + E * E >= s.desktopTapThreshold2;
			}
			var C = p(e);
			y && (s.hoverData.tapholdCancelled = !0);
			var S = h(function() {
				var e = s.hoverData.dragDelta = s.hoverData.dragDelta || [];
				0 === e.length ? (e.push(b[0]), e.push(b[1])) : (e[0] += b[0], e[1] += b[1]);
			}, "updateDragDelta");
			r = !0, d(m, [
				"mousemove",
				"vmousemove",
				"tapdrag"
			], e, {
				x: o[0],
				y: o[1]
			});
			var A = h(function(t) {
				return {
					originalEvent: e,
					type: t,
					position: {
						x: o[0],
						y: o[1]
					}
				};
			}, "makeEvent"), L = h(function() {
				s.data.bgActivePosistion = void 0, s.hoverData.selecting || i.emit(A("boxstart")), g[4] = 1, s.hoverData.selecting = !0, s.redrawHint("select", !0), s.redraw();
			}, "goIntoBoxMode");
			if (3 === s.hoverData.which) {
				if (y) {
					var R = A("cxtdrag");
					x ? x.emit(R) : i.emit(R), s.hoverData.cxtDragged = !0, (!s.hoverData.cxtOver || m !== s.hoverData.cxtOver) && (s.hoverData.cxtOver && s.hoverData.cxtOver.emit(A("cxtdragout")), s.hoverData.cxtOver = m, m && m.emit(A("cxtdragover")));
				}
			} else if (s.hoverData.dragging) {
				if (r = !0, i.panningEnabled() && i.userPanningEnabled()) {
					if (s.hoverData.justStartedPan) {
						var N = s.hoverData.mdownPos;
						t = {
							x: (o[0] - N[0]) * n,
							y: (o[1] - N[1]) * n
						}, s.hoverData.justStartedPan = !1;
					} else t = {
						x: b[0] * n,
						y: b[1] * n
					};
					i.panBy(t), i.emit(A("dragpan")), s.hoverData.dragged = !0;
				}
				o = s.projectIntoViewport(e.clientX, e.clientY);
			} else if (1 == g[4] && (null == x || x.pannable())) y && (!s.hoverData.dragging && i.boxSelectionEnabled() && (C || !i.panningEnabled() || !i.userPanningEnabled()) ? L() : !s.hoverData.selecting && i.panningEnabled() && i.userPanningEnabled() && f(x, s.hoverData.downs) && (s.hoverData.dragging = !0, s.hoverData.justStartedPan = !0, g[4] = 0, s.data.bgActivePosistion = Pc(l), s.redrawHint("select", !0), s.redraw()), x && x.pannable() && x.active() && x.unactivate());
			else {
				if (x && x.pannable() && x.active() && x.unactivate(), x && x.grabbed() || m == v || (v && d(v, ["mouseout", "tapdragout"], e, {
					x: o[0],
					y: o[1]
				}), m && d(m, ["mouseover", "tapdragover"], e, {
					x: o[0],
					y: o[1]
				}), s.hoverData.last = m), x) if (y) {
					if (i.boxSelectionEnabled() && C) x && x.grabbed() && (_(w), x.emit(A("freeon")), w.emit(A("free")), s.dragData.didDrag && (x.emit(A("dragfreeon")), w.emit(A("dragfree")))), L();
					else if (x && x.grabbed() && s.nodeIsDraggable(x)) {
						var I = !s.dragData.didDrag;
						I && s.redrawHint("eles", !0), s.dragData.didDrag = !0, s.hoverData.draggingEles || T(w, { inDragLayer: !0 });
						var D = {
							x: 0,
							y: 0
						};
						if (DH(b[0]) && DH(b[1]) && (D.x += b[0], D.y += b[1], I)) {
							var O = s.hoverData.dragDelta;
							O && DH(O[0]) && DH(O[1]) && (D.x += O[0], D.y += O[1]);
						}
						s.hoverData.draggingEles = !0, w.silentShift(D).emit(A("position")).emit(A("drag")), s.redrawHint("drag", !0), s.redraw();
					}
				} else S();
				r = !0;
			}
			if (g[2] = o[0], g[3] = o[1], r) return e.stopPropagation && e.stopPropagation(), e.preventDefault && e.preventDefault(), !1;
		}
	}, "mousemoveHandler"), !1), s.registerBinding(o, "mouseup", h(function(e) {
		if (!(1 === s.hoverData.which && 1 !== e.which && s.hoverData.capture) && s.hoverData.capture) {
			s.hoverData.capture = !1;
			var t = s.cy, r = s.projectIntoViewport(e.clientX, e.clientY), i = s.selection, n = s.findNearestElement(r[0], r[1], !0, !1), a = s.dragData.possibleDragElements, o = s.hoverData.down, u = p(e);
			s.data.bgActivePosistion && (s.redrawHint("select", !0), s.redraw()), s.hoverData.tapholdCancelled = !0, s.data.bgActivePosistion = void 0, o && o.unactivate();
			var f = h(function(t) {
				return {
					originalEvent: e,
					type: t,
					position: {
						x: r[0],
						y: r[1]
					}
				};
			}, "makeEvent");
			if (3 === s.hoverData.which) {
				var g = f("cxttapend");
				if (o ? o.emit(g) : t.emit(g), !s.hoverData.cxtDragged) {
					var m = f("cxttap");
					o ? o.emit(m) : t.emit(m);
				}
				s.hoverData.cxtDragged = !1, s.hoverData.which = null;
			} else if (1 === s.hoverData.which) {
				if (d(n, [
					"mouseup",
					"tapend",
					"vmouseup"
				], e, {
					x: r[0],
					y: r[1]
				}), s.dragData.didDrag || s.hoverData.dragged || s.hoverData.selecting || s.hoverData.isOverThresholdDrag || (d(o, [
					"click",
					"tap",
					"vclick"
				], e, {
					x: r[0],
					y: r[1]
				}), $ = !1, e.timeStamp - P <= t.multiClickDebounceTime() ? (O && clearTimeout(O), $ = !0, P = null, d(o, [
					"dblclick",
					"dbltap",
					"vdblclick"
				], e, {
					x: r[0],
					y: r[1]
				})) : (O = setTimeout(function() {
					$ || d(o, [
						"oneclick",
						"onetap",
						"voneclick"
					], e, {
						x: r[0],
						y: r[1]
					});
				}, t.multiClickDebounceTime()), P = e.timeStamp)), null != o || s.dragData.didDrag || s.hoverData.selecting || s.hoverData.dragged || p(e) || (t.$(l).unselect(["tapunselect"]), a.length > 0 && s.redrawHint("eles", !0), s.dragData.possibleDragElements = a = t.collection()), n != o || s.dragData.didDrag || s.hoverData.selecting || null == n || !n._private.selectable || (s.hoverData.dragging || ("additive" === t.selectionType() || u ? n.selected() ? n.unselect(["tapunselect"]) : n.select(["tapselect"]) : u || (t.$(l).unmerge(n).unselect(["tapunselect"]), n.select(["tapselect"]))), s.redrawHint("eles", !0)), s.hoverData.selecting) {
					var y = t.collection(s.getAllInBox(i[0], i[1], i[2], i[3]));
					s.redrawHint("select", !0), y.length > 0 && s.redrawHint("eles", !0), t.emit(f("boxend"));
					var v = h(function(e) {
						return e.selectable() && !e.selected();
					}, "eleWouldBeSelected");
					"additive" === t.selectionType() || u || t.$(l).unmerge(y).unselect(), y.emit(f("box")).stdFilter(v).select().emit(f("boxselect")), s.redraw();
				}
				if (s.hoverData.dragging && (s.hoverData.dragging = !1, s.redrawHint("select", !0), s.redrawHint("eles", !0), s.redraw()), !i[4]) {
					s.redrawHint("drag", !0), s.redrawHint("eles", !0);
					var x = o && o.grabbed();
					_(a), x && (o.emit(f("freeon")), a.emit(f("free")), s.dragData.didDrag && (o.emit(f("dragfreeon")), a.emit(f("dragfree"))));
				}
			}
			i[4] = 0, s.hoverData.down = null, s.hoverData.cxtStarted = !1, s.hoverData.draggingEles = !1, s.hoverData.selecting = !1, s.hoverData.isOverThresholdDrag = !1, s.dragData.didDrag = !1, s.hoverData.dragged = !1, s.hoverData.dragDelta = [], s.hoverData.mdownPos = null, s.hoverData.mdownGPos = null, s.hoverData.which = null;
		}
	}, "mouseupHandler"), !1);
	var O, $, P, B, F = [], z = 1e5, U = h(function(e, t) {
		for (var r = 0; r < e.length; r++) if (e[r] % t != 0) return !1;
		return !0;
	}, "allAreDivisibleBy"), G = h(function(e) {
		for (var t = Math.abs(e[0]), r = 1; r < e.length; r++) if (Math.abs(e[r]) !== t) return !1;
		return !0;
	}, "allAreSameMagnitude"), q = h(function(e) {
		var t = !1, r = e.deltaY;
		if (r ?? (null != e.wheelDeltaY ? r = e.wheelDeltaY / 4 : null != e.wheelDelta && (r = e.wheelDelta / 4)), 0 !== r) {
			if (null == B) if (F.length >= 4) {
				if (!(B = U(F, 5))) {
					var i = Math.abs(F[0]);
					B = G(F) && i > 5;
				}
				if (B) for (var n = 0; n < F.length; n++) z = Math.min(Math.abs(F[n]), z);
			} else F.push(r), t = !0;
			else B && (z = Math.min(Math.abs(r), z));
			if (!s.scrollingPage) {
				var a = s.cy, o = a.zoom(), l = a.pan(), h = s.projectIntoViewport(e.clientX, e.clientY), u = [h[0] * o + l.x, h[1] * o + l.y];
				if (s.hoverData.draggingEles || s.hoverData.dragging || s.hoverData.cxtStarted || I()) return void e.preventDefault();
				if (a.panningEnabled() && a.userPanningEnabled() && a.zoomingEnabled() && a.userZoomingEnabled()) {
					e.preventDefault(), s.data.wheelZooming = !0, clearTimeout(s.data.wheelTimeout), s.data.wheelTimeout = setTimeout(function() {
						s.data.wheelZooming = !1, s.redrawHint("eles", !0), s.redraw();
					}, 150), t && Math.abs(r) > 5 && (r = 5 * Py(r)), d = -(r / 250), B && (d /= z, d *= 3), d *= s.wheelSensitivity, 1 === e.deltaMode && (d *= 33);
					var d, p = a.zoom() * Math.pow(10, d);
					"gesturechange" === e.type && (p = s.gestureStartZoom * e.scale), a.zoom({
						level: p,
						renderedPosition: {
							x: u[0],
							y: u[1]
						}
					}), a.emit({
						type: "gesturechange" === e.type ? "pinchzoom" : "scrollzoom",
						originalEvent: e,
						position: {
							x: h[0],
							y: h[1]
						}
					});
				}
			}
		}
	}, "wheelHandler");
	s.registerBinding(s.container, "wheel", q, !0), s.registerBinding(o, "scroll", h(function(e) {
		s.scrollingPage = !0, clearTimeout(s.scrollingPageTimeout), s.scrollingPageTimeout = setTimeout(function() {
			s.scrollingPage = !1;
		}, 250);
	}, "scrollHandler"), !0), s.registerBinding(s.container, "gesturestart", h(function(e) {
		s.gestureStartZoom = s.cy.zoom(), s.hasTouchStarted || e.preventDefault();
	}, "gestureStartHandler"), !0), s.registerBinding(s.container, "gesturechange", function(e) {
		s.hasTouchStarted || q(e);
	}, !0), s.registerBinding(s.container, "mouseout", h(function(e) {
		var t = s.projectIntoViewport(e.clientX, e.clientY);
		s.cy.emit({
			originalEvent: e,
			type: "mouseout",
			position: {
				x: t[0],
				y: t[1]
			}
		});
	}, "mouseOutHandler"), !1), s.registerBinding(s.container, "mouseover", h(function(e) {
		var t = s.projectIntoViewport(e.clientX, e.clientY);
		s.cy.emit({
			originalEvent: e,
			type: "mouseover",
			position: {
				x: t[0],
				y: t[1]
			}
		});
	}, "mouseOverHandler"), !1);
	var j, W, Y, V, H, X, K, Z, Q, J, ee, et, er, ei, en = h(function(e, t, r, i) {
		return Math.sqrt((r - e) * (r - e) + (i - t) * (i - t));
	}, "distance"), ea = h(function(e, t, r, i) {
		return (r - e) * (r - e) + (i - t) * (i - t);
	}, "distanceSq");
	if (s.registerBinding(s.container, "touchstart", ei = h(function(e) {
		if (s.hasTouchStarted = !0, M(e)) {
			C(), s.touchData.capture = !0, s.data.bgActivePosistion = void 0;
			var t = s.cy, r = s.touchData.now, i = s.touchData.earlier;
			if (e.touches[0]) {
				var n = s.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
				r[0] = n[0], r[1] = n[1];
			}
			if (e.touches[1]) {
				var n = s.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
				r[2] = n[0], r[3] = n[1];
			}
			if (e.touches[2]) {
				var n = s.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
				r[4] = n[0], r[5] = n[1];
			}
			var a = h(function(t) {
				return {
					originalEvent: e,
					type: t,
					position: {
						x: r[0],
						y: r[1]
					}
				};
			}, "makeEvent");
			if (e.touches[1]) {
				s.touchData.singleTouchMoved = !0, _(s.dragData.touchDragEles);
				var o = s.findContainerClientCoords();
				Q = o[0], J = o[1], ee = o[2], et = o[3], j = e.touches[0].clientX - Q, W = e.touches[0].clientY - J, Y = e.touches[1].clientX - Q, V = e.touches[1].clientY - J, er = 0 <= j && j <= ee && 0 <= Y && Y <= ee && 0 <= W && W <= et && 0 <= V && V <= et;
				var l = t.pan(), u = t.zoom();
				if (H = en(j, W, Y, V), X = ea(j, W, Y, V), Z = [((K = [(j + Y) / 2, (W + V) / 2])[0] - l.x) / u, (K[1] - l.y) / u], X < 4e4 && !e.touches[2]) {
					var p = s.findNearestElement(r[0], r[1], !0, !0), f = s.findNearestElement(r[2], r[3], !0, !0);
					p && p.isNode() ? (p.activate().emit(a("cxttapstart")), s.touchData.start = p) : f && f.isNode() ? (f.activate().emit(a("cxttapstart")), s.touchData.start = f) : t.emit(a("cxttapstart")), s.touchData.start && (s.touchData.start._private.grabbed = !1), s.touchData.cxt = !0, s.touchData.cxtDragged = !1, s.data.bgActivePosistion = void 0, s.redraw();
					return;
				}
			}
			if (e.touches[2]) t.boxSelectionEnabled() && e.preventDefault();
			else if (!e.touches[1] && e.touches[0]) {
				var g = s.findNearestElements(r[0], r[1], !0, !0), m = g[0];
				if (null != m && (m.activate(), s.touchData.start = m, s.touchData.starts = g, s.nodeIsGrabbable(m))) {
					var y = s.dragData.touchDragEles = t.collection(), v = null;
					s.redrawHint("eles", !0), s.redrawHint("drag", !0), m.selected() ? T(v = t.$(function(e) {
						return e.selected() && s.nodeIsGrabbable(e);
					}), { addToList: y }) : T(m, { addToList: y }), x(m), m.emit(a("grabon")), v ? v.forEach(function(e) {
						e.emit(a("grab"));
					}) : m.emit(a("grab"));
				}
				d(m, [
					"touchstart",
					"tapstart",
					"vmousedown"
				], e, {
					x: r[0],
					y: r[1]
				}), m ?? (s.data.bgActivePosistion = {
					x: n[0],
					y: n[1]
				}, s.redrawHint("select", !0), s.redraw()), s.touchData.singleTouchMoved = !1, s.touchData.singleTouchStartTime = +/* @__PURE__ */ new Date(), clearTimeout(s.touchData.tapholdTimeout), s.touchData.tapholdTimeout = setTimeout(function() {
					!1 !== s.touchData.singleTouchMoved || s.pinching || s.touchData.selecting || d(s.touchData.start, ["taphold"], e, {
						x: r[0],
						y: r[1]
					});
				}, s.tapholdDuration);
			}
			if (e.touches.length >= 1) {
				for (var b = s.touchData.startPosition = [
					null,
					null,
					null,
					null,
					null,
					null
				], w = 0; w < r.length; w++) b[w] = i[w] = r[w];
				var k = e.touches[0];
				s.touchData.startGPosition = [k.clientX, k.clientY];
			}
		}
	}, "touchstartHandler"), !1), s.registerBinding(o, "touchmove", e = h(function(e) {
		var t = s.touchData.capture;
		if (!(!t && !M(e))) {
			var r = s.selection, i = s.cy, n = s.touchData.now, a = s.touchData.earlier, o = i.zoom();
			if (e.touches[0]) {
				var l = s.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
				n[0] = l[0], n[1] = l[1];
			}
			if (e.touches[1]) {
				var l = s.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
				n[2] = l[0], n[3] = l[1];
			}
			if (e.touches[2]) {
				var l = s.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
				n[4] = l[0], n[5] = l[1];
			}
			var u, p = h(function(t) {
				return {
					originalEvent: e,
					type: t,
					position: {
						x: n[0],
						y: n[1]
					}
				};
			}, "makeEvent"), g = s.touchData.startGPosition;
			if (t && e.touches[0] && g) {
				for (var m = [], y = 0; y < n.length; y++) m[y] = n[y] - a[y];
				var v = e.touches[0].clientX - g[0], x = v * v, b = e.touches[0].clientY - g[1];
				u = x + b * b >= s.touchTapThreshold2;
			}
			if (t && s.touchData.cxt) {
				e.preventDefault();
				var w = e.touches[0].clientX - Q, k = e.touches[0].clientY - J, E = e.touches[1].clientX - Q, C = e.touches[1].clientY - J, S = ea(w, k, E, C);
				if (S / X >= 2.25 || S >= 22500) {
					s.touchData.cxt = !1, s.data.bgActivePosistion = void 0, s.redrawHint("select", !0);
					var A = p("cxttapend");
					s.touchData.start ? (s.touchData.start.unactivate().emit(A), s.touchData.start = null) : i.emit(A);
				}
			}
			if (t && s.touchData.cxt) {
				var A = p("cxtdrag");
				s.data.bgActivePosistion = void 0, s.redrawHint("select", !0), s.touchData.start ? s.touchData.start.emit(A) : i.emit(A), s.touchData.start && (s.touchData.start._private.grabbed = !1), s.touchData.cxtDragged = !0;
				var L = s.findNearestElement(n[0], n[1], !0, !0);
				(!s.touchData.cxtOver || L !== s.touchData.cxtOver) && (s.touchData.cxtOver && s.touchData.cxtOver.emit(p("cxtdragout")), s.touchData.cxtOver = L, L && L.emit(p("cxtdragover")));
			} else if (t && e.touches[2] && i.boxSelectionEnabled()) e.preventDefault(), s.data.bgActivePosistion = void 0, this.lastThreeTouch = +/* @__PURE__ */ new Date(), s.touchData.selecting || i.emit(p("boxstart")), s.touchData.selecting = !0, s.touchData.didSelect = !0, r[4] = 1, r && 0 !== r.length && void 0 !== r[0] ? (r[2] = (n[0] + n[2] + n[4]) / 3, r[3] = (n[1] + n[3] + n[5]) / 3) : (r[0] = (n[0] + n[2] + n[4]) / 3, r[1] = (n[1] + n[3] + n[5]) / 3, r[2] = (n[0] + n[2] + n[4]) / 3 + 1, r[3] = (n[1] + n[3] + n[5]) / 3 + 1), s.redrawHint("select", !0), s.redraw();
			else if (t && e.touches[1] && !s.touchData.didSelect && i.zoomingEnabled() && i.panningEnabled() && i.userZoomingEnabled() && i.userPanningEnabled()) {
				e.preventDefault(), s.data.bgActivePosistion = void 0, s.redrawHint("select", !0);
				var R = s.dragData.touchDragEles;
				if (R) {
					s.redrawHint("drag", !0);
					for (var N = 0; N < R.length; N++) {
						var I = R[N]._private;
						I.grabbed = !1, I.rscratch.inDragLayer = !1;
					}
				}
				var D = s.touchData.start, w = e.touches[0].clientX - Q, k = e.touches[0].clientY - J, E = e.touches[1].clientX - Q, C = e.touches[1].clientY - J, O = en(w, k, E, C), $ = O / H;
				if (er) {
					var P = w - j, B = k - W, F = E - Y, z = C - V, U = i.zoom(), G = U * $, q = i.pan(), K = Z[0] * U + q.x, ee = Z[1] * U + q.y, et = {
						x: -G / U * (K - q.x - (P + F) / 2) + K,
						y: -G / U * (ee - q.y - (B + z) / 2) + ee
					};
					if (D && D.active()) {
						var R = s.dragData.touchDragEles;
						_(R), s.redrawHint("drag", !0), s.redrawHint("eles", !0), D.unactivate().emit(p("freeon")), R.emit(p("free")), s.dragData.didDrag && (D.emit(p("dragfreeon")), R.emit(p("dragfree")));
					}
					i.viewport({
						zoom: G,
						pan: et,
						cancelOnFailedZoom: !0
					}), i.emit(p("pinchzoom")), H = O, j = w, W = k, Y = E, V = C, s.pinching = !0;
				}
				if (e.touches[0]) {
					var l = s.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
					n[0] = l[0], n[1] = l[1];
				}
				if (e.touches[1]) {
					var l = s.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
					n[2] = l[0], n[3] = l[1];
				}
				if (e.touches[2]) {
					var l = s.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
					n[4] = l[0], n[5] = l[1];
				}
			} else if (e.touches[0] && !s.touchData.didSelect) {
				var L, ei = s.touchData.start, es = s.touchData.last;
				if (s.hoverData.draggingEles || s.swipePanning || (L = s.findNearestElement(n[0], n[1], !0, !0)), t && null != ei && e.preventDefault(), t && null != ei && s.nodeIsDraggable(ei)) if (u) {
					var R = s.dragData.touchDragEles, eo = !s.dragData.didDrag;
					eo && T(R, { inDragLayer: !0 }), s.dragData.didDrag = !0;
					var el = {
						x: 0,
						y: 0
					};
					if (DH(m[0]) && DH(m[1]) && (el.x += m[0], el.y += m[1], eo)) {
						s.redrawHint("eles", !0);
						var ec = s.touchData.dragDelta;
						ec && DH(ec[0]) && DH(ec[1]) && (el.x += ec[0], el.y += ec[1]);
					}
					s.hoverData.draggingEles = !0, R.silentShift(el).emit(p("position")).emit(p("drag")), s.redrawHint("drag", !0), s.touchData.startPosition[0] == a[0] && s.touchData.startPosition[1] == a[1] && s.redrawHint("eles", !0), s.redraw();
				} else {
					var ec = s.touchData.dragDelta = s.touchData.dragDelta || [];
					0 === ec.length ? (ec.push(m[0]), ec.push(m[1])) : (ec[0] += m[0], ec[1] += m[1]);
				}
				if (d(ei || L, [
					"touchmove",
					"tapdrag",
					"vmousemove"
				], e, {
					x: n[0],
					y: n[1]
				}), ei && ei.grabbed() || L == es || (es && es.emit(p("tapdragout")), L && L.emit(p("tapdragover"))), s.touchData.last = L, t) for (var N = 0; N < n.length; N++) n[N] && s.touchData.startPosition[N] && u && (s.touchData.singleTouchMoved = !0);
				if (t && (null == ei || ei.pannable()) && i.panningEnabled() && i.userPanningEnabled()) {
					f(ei, s.touchData.starts) && (e.preventDefault(), s.data.bgActivePosistion || (s.data.bgActivePosistion = Pc(s.touchData.startPosition)), s.swipePanning ? (i.panBy({
						x: m[0] * o,
						y: m[1] * o
					}), i.emit(p("dragpan"))) : u && (s.swipePanning = !0, i.panBy({
						x: v * o,
						y: b * o
					}), i.emit(p("dragpan")), ei && (ei.unactivate(), s.redrawHint("select", !0), s.touchData.start = null)));
					var l = s.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
					n[0] = l[0], n[1] = l[1];
				}
			}
			for (var y = 0; y < n.length; y++) a[y] = n[y];
			t && e.touches.length > 0 && !s.hoverData.draggingEles && !s.swipePanning && null != s.data.bgActivePosistion && (s.data.bgActivePosistion = void 0, s.redrawHint("select", !0), s.redraw());
		}
	}, "touchmoveHandler"), !1), s.registerBinding(o, "touchcancel", t = h(function(e) {
		var t = s.touchData.start;
		s.touchData.capture = !1, t && t.unactivate();
	}, "touchcancelHandler")), s.registerBinding(o, "touchend", r = h(function(e) {
		var t, r = s.touchData.start;
		if (s.touchData.capture) {
			0 === e.touches.length && (s.touchData.capture = !1), e.preventDefault();
			var o = s.selection;
			s.swipePanning = !1, s.hoverData.draggingEles = !1;
			var u = s.cy, p = u.zoom(), f = s.touchData.now, g = s.touchData.earlier;
			if (e.touches[0]) {
				var m = s.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
				f[0] = m[0], f[1] = m[1];
			}
			if (e.touches[1]) {
				var m = s.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);
				f[2] = m[0], f[3] = m[1];
			}
			if (e.touches[2]) {
				var m = s.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);
				f[4] = m[0], f[5] = m[1];
			}
			var y = h(function(t) {
				return {
					originalEvent: e,
					type: t,
					position: {
						x: f[0],
						y: f[1]
					}
				};
			}, "makeEvent");
			if (r && r.unactivate(), s.touchData.cxt) {
				if (t = y("cxttapend"), r ? r.emit(t) : u.emit(t), !s.touchData.cxtDragged) {
					var v = y("cxttap");
					r ? r.emit(v) : u.emit(v);
				}
				s.touchData.start && (s.touchData.start._private.grabbed = !1), s.touchData.cxt = !1, s.touchData.start = null, s.redraw();
				return;
			}
			if (!e.touches[2] && u.boxSelectionEnabled() && s.touchData.selecting) {
				s.touchData.selecting = !1;
				var x = u.collection(s.getAllInBox(o[0], o[1], o[2], o[3]));
				o[0] = void 0, o[1] = void 0, o[2] = void 0, o[3] = void 0, o[4] = 0, s.redrawHint("select", !0), u.emit(y("boxend"));
				var b = h(function(e) {
					return e.selectable() && !e.selected();
				}, "eleWouldBeSelected");
				x.emit(y("box")).stdFilter(b).select().emit(y("boxselect")), x.nonempty() && s.redrawHint("eles", !0), s.redraw();
			}
			if (r?.unactivate(), e.touches[2]) s.data.bgActivePosistion = void 0, s.redrawHint("select", !0);
			else if (!e.touches[1] && !e.touches[0] && !e.touches[0]) {
				s.data.bgActivePosistion = void 0, s.redrawHint("select", !0);
				var w = s.dragData.touchDragEles;
				if (null != r) {
					var k = r._private.grabbed;
					_(w), s.redrawHint("drag", !0), s.redrawHint("eles", !0), k && (r.emit(y("freeon")), w.emit(y("free")), s.dragData.didDrag && (r.emit(y("dragfreeon")), w.emit(y("dragfree")))), d(r, [
						"touchend",
						"tapend",
						"vmouseup",
						"tapdragout"
					], e, {
						x: f[0],
						y: f[1]
					}), r.unactivate(), s.touchData.start = null;
				} else d(s.findNearestElement(f[0], f[1], !0, !0), [
					"touchend",
					"tapend",
					"vmouseup",
					"tapdragout"
				], e, {
					x: f[0],
					y: f[1]
				});
				var T = s.touchData.startPosition[0] - f[0], E = s.touchData.startPosition[1] - f[1];
				s.touchData.singleTouchMoved || (r || u.$(":selected").unselect(["tapunselect"]), d(r, ["tap", "vclick"], e, {
					x: f[0],
					y: f[1]
				}), i = !1, e.timeStamp - a <= u.multiClickDebounceTime() ? (n && clearTimeout(n), i = !0, a = null, d(r, ["dbltap", "vdblclick"], e, {
					x: f[0],
					y: f[1]
				})) : (n = setTimeout(function() {
					i || d(r, ["onetap", "voneclick"], e, {
						x: f[0],
						y: f[1]
					});
				}, u.multiClickDebounceTime()), a = e.timeStamp)), null != r && !s.dragData.didDrag && r._private.selectable && (T * T + E * E) * p * p < s.touchTapThreshold2 && !s.pinching && ("single" === u.selectionType() ? (u.$(l).unmerge(r).unselect(["tapunselect"]), r.select(["tapselect"])) : r.selected() ? r.unselect(["tapunselect"]) : r.select(["tapselect"]), s.redrawHint("eles", !0)), s.touchData.singleTouchMoved = !0;
			}
			for (var C = 0; C < f.length; C++) g[C] = f[C];
			s.dragData.didDrag = !1, 0 === e.touches.length && (s.touchData.dragDelta = [], s.touchData.startPosition = [
				null,
				null,
				null,
				null,
				null,
				null
			], s.touchData.startGPosition = null, s.touchData.didSelect = !1), e.touches.length < 2 && (1 === e.touches.length && (s.touchData.startGPosition = [e.touches[0].clientX, e.touches[0].clientY]), s.pinching = !1, s.redrawHint("eles", !0), s.redraw());
		}
	}, "touchendHandler"), !1), typeof TouchEvent > "u") {
		var es = [], eo = h(function(e) {
			return {
				clientX: e.clientX,
				clientY: e.clientY,
				force: 1,
				identifier: e.pointerId,
				pageX: e.pageX,
				pageY: e.pageY,
				radiusX: e.width / 2,
				radiusY: e.height / 2,
				screenX: e.screenX,
				screenY: e.screenY,
				target: e.target
			};
		}, "makeTouch"), el = h(function(e) {
			return {
				event: e,
				touch: eo(e)
			};
		}, "makePointer"), ec = h(function(e) {
			es.push(el(e));
		}, "addPointer"), eh = h(function(e) {
			for (var t = 0; t < es.length; t++) if (es[t].event.pointerId === e.pointerId) return void es.splice(t, 1);
		}, "removePointer"), eu = h(function(e) {
			var t = es.filter(function(t) {
				return t.event.pointerId === e.pointerId;
			})[0];
			t.event = e, t.touch = eo(e);
		}, "updatePointer"), ed = h(function(e) {
			e.touches = es.map(function(e) {
				return e.touch;
			});
		}, "addTouchesToEvent"), ep = h(function(e) {
			return "mouse" === e.pointerType || 4 === e.pointerType;
		}, "pointerIsMouse");
		s.registerBinding(s.container, "pointerdown", function(e) {
			ep(e) || (e.preventDefault(), ec(e), ed(e), ei(e));
		}), s.registerBinding(s.container, "pointerup", function(e) {
			ep(e) || (eh(e), ed(e), r(e));
		}), s.registerBinding(s.container, "pointercancel", function(e) {
			ep(e) || (eh(e), ed(e), t(e));
		}), s.registerBinding(s.container, "pointermove", function(t) {
			ep(t) || (t.preventDefault(), eu(t), ed(t), e(t));
		});
	}
};
var WN = {};
WN.generatePolygon = function(e, t) {
	return this.nodeShapes[e] = {
		renderer: this,
		name: e,
		points: t,
		draw: h(function(e, t, r, i, n, a) {
			this.renderer.nodeShapeImpl("polygon", e, t, r, i, n, this.points);
		}, "draw"),
		intersectLine: h(function(e, t, r, i, n, a, s, o) {
			return P5(n, a, this.points, e, t, r / 2, i / 2, s);
		}, "intersectLine"),
		checkPoint: h(function(e, t, r, i, n, a, s, o) {
			return PH(e, t, this.points, a, s, i, n, [0, -1], r);
		}, "checkPoint"),
		hasMiterBounds: "rectangle" !== e,
		miterBounds: h(function(e, t, r, i, n, a) {
			return PF(this.points, e, t, r, i, n);
		}, "miterBounds")
	};
}, WN.generateEllipse = function() {
	return this.nodeShapes.ellipse = {
		renderer: this,
		name: "ellipse",
		draw: h(function(e, t, r, i, n, a) {
			this.renderer.nodeShapeImpl(this.name, e, t, r, i, n);
		}, "draw"),
		intersectLine: h(function(e, t, r, i, n, a, s, o) {
			return PQ(n, a, e, t, r / 2 + s, i / 2 + s);
		}, "intersectLine"),
		checkPoint: h(function(e, t, r, i, n, a, s, o) {
			return PJ(e, t, i, n, a, s, r);
		}, "checkPoint")
	};
}, WN.generateRoundPolygon = function(e, t) {
	return this.nodeShapes[e] = {
		renderer: this,
		name: e,
		points: t,
		getOrCreateCorners: h(function(e, r, i, n, a, s, o) {
			if (void 0 !== s[o] && s[o + "-cx"] === e && s[o + "-cy"] === r) return s[o];
			s[o] = Array(t.length / 2), s[o + "-cx"] = e, s[o + "-cy"] = r;
			var l = i / 2, h = n / 2;
			a = "auto" === a ? Bt(i, n) : a;
			for (var u = Array(t.length / 2), d = 0; d < t.length / 2; d++) u[d] = {
				x: e + l * t[2 * d],
				y: r + h * t[2 * d + 1]
			};
			var p, f, g, m, y = u.length;
			for (f = u[y - 1], p = 0; p < y; p++) g = u[p % y], m = u[(p + 1) % y], s[o][p] = Wp(f, g, m, a), f = g, g = m;
			return s[o];
		}, "getOrCreateCorners"),
		draw: h(function(e, t, r, i, n, a, s) {
			this.renderer.nodeShapeImpl("round-polygon", e, t, r, i, n, this.points, this.getOrCreateCorners(t, r, i, n, a, s, "drawCorners"));
		}, "draw"),
		intersectLine: h(function(e, t, r, i, n, a, s, o, l) {
			return P3(n, a, this.points, e, t, r, i, s, this.getOrCreateCorners(e, t, r, i, o, l, "corners"));
		}, "intersectLine"),
		checkPoint: h(function(e, t, r, i, n, a, s, o, l) {
			return PX(e, t, this.points, a, s, i, n, this.getOrCreateCorners(a, s, i, n, o, l, "corners"));
		}, "checkPoint")
	};
}, WN.generateRoundRectangle = function() {
	return this.nodeShapes["round-rectangle"] = this.nodeShapes.roundrectangle = {
		renderer: this,
		name: "round-rectangle",
		points: P7(4, 0),
		draw: h(function(e, t, r, i, n, a) {
			this.renderer.nodeShapeImpl(this.name, e, t, r, i, n, this.points, a);
		}, "draw"),
		intersectLine: h(function(e, t, r, i, n, a, s, o) {
			return Pz(n, a, e, t, r, i, s, o);
		}, "intersectLine"),
		checkPoint: h(function(e, t, r, i, n, a, s, o) {
			var l = i / 2, h = n / 2, u = 2 * (o = Math.min(l, h, o = "auto" === o ? Be(i, n) : o));
			return !!(PH(e, t, this.points, a, s, i, n - u, [0, -1], r) || PH(e, t, this.points, a, s, i - u, n, [0, -1], r) || PJ(e, t, u, u, a - l + o, s - h + o, r) || PJ(e, t, u, u, a + l - o, s - h + o, r) || PJ(e, t, u, u, a + l - o, s + h - o, r) || PJ(e, t, u, u, a - l + o, s + h - o, r));
		}, "checkPoint")
	};
}, WN.generateCutRectangle = function() {
	return this.nodeShapes["cut-rectangle"] = this.nodeShapes.cutrectangle = {
		renderer: this,
		name: "cut-rectangle",
		cornerLength: Br(),
		points: P7(4, 0),
		draw: h(function(e, t, r, i, n, a) {
			this.renderer.nodeShapeImpl(this.name, e, t, r, i, n, null, a);
		}, "draw"),
		generateCutTrianglePts: h(function(e, t, r, i, n) {
			var a = "auto" === n ? this.cornerLength : n, s = t / 2, o = e / 2, l = r - o, h = r + o, u = i - s, d = i + s;
			return {
				topLeft: [
					l,
					u + a,
					l + a,
					u,
					l + a,
					u + a
				],
				topRight: [
					h - a,
					u,
					h,
					u + a,
					h - a,
					u + a
				],
				bottomRight: [
					h,
					d - a,
					h - a,
					d,
					h - a,
					d - a
				],
				bottomLeft: [
					l + a,
					d,
					l,
					d - a,
					l + a,
					d - a
				]
			};
		}, "generateCutTrianglePts"),
		intersectLine: h(function(e, t, r, i, n, a, s, o) {
			var l = this.generateCutTrianglePts(r + 2 * s, i + 2 * s, e, t, o);
			return P5(n, a, [].concat.apply([], [
				l.topLeft.splice(0, 4),
				l.topRight.splice(0, 4),
				l.bottomRight.splice(0, 4),
				l.bottomLeft.splice(0, 4)
			]), e, t);
		}, "intersectLine"),
		checkPoint: h(function(e, t, r, i, n, a, s, o) {
			var l = "auto" === o ? this.cornerLength : o;
			if (PH(e, t, this.points, a, s, i, n - 2 * l, [0, -1], r) || PH(e, t, this.points, a, s, i - 2 * l, n, [0, -1], r)) return !0;
			var h = this.generateCutTrianglePts(i, n, a, s);
			return PV(e, t, h.topLeft) || PV(e, t, h.topRight) || PV(e, t, h.bottomRight) || PV(e, t, h.bottomLeft);
		}, "checkPoint")
	};
}, WN.generateBarrel = function() {
	return this.nodeShapes.barrel = {
		renderer: this,
		name: "barrel",
		points: P7(4, 0),
		draw: h(function(e, t, r, i, n, a) {
			this.renderer.nodeShapeImpl(this.name, e, t, r, i, n);
		}, "draw"),
		intersectLine: h(function(e, t, r, i, n, a, s, o) {
			var l = this.generateBarrelBezierPts(r + 2 * s, i + 2 * s, e, t), u = h(function(e) {
				var t = Pk({
					x: e[0],
					y: e[1]
				}, {
					x: e[2],
					y: e[3]
				}, {
					x: e[4],
					y: e[5]
				}, .15), r = Pk({
					x: e[0],
					y: e[1]
				}, {
					x: e[2],
					y: e[3]
				}, {
					x: e[4],
					y: e[5]
				}, .5), i = Pk({
					x: e[0],
					y: e[1]
				}, {
					x: e[2],
					y: e[3]
				}, {
					x: e[4],
					y: e[5]
				}, .85);
				return [
					e[0],
					e[1],
					t.x,
					t.y,
					r.x,
					r.y,
					i.x,
					i.y,
					e[4],
					e[5]
				];
			}, "approximateBarrelCurvePts");
			return P5(n, a, [].concat(u(l.topLeft), u(l.topRight), u(l.bottomRight), u(l.bottomLeft)), e, t);
		}, "intersectLine"),
		generateBarrelBezierPts: h(function(e, t, r, i) {
			var n = t / 2, a = e / 2, s = r - a, o = r + a, l = i - n, h = i + n, u = Bn(e, t), d = u.heightOffset, p = u.widthOffset, f = u.ctrlPtOffsetPct * e, g = {
				topLeft: [
					s,
					l + d,
					s + f,
					l,
					s + p,
					l
				],
				topRight: [
					o - p,
					l,
					o - f,
					l,
					o,
					l + d
				],
				bottomRight: [
					o,
					h - d,
					o - f,
					h,
					o - p,
					h
				],
				bottomLeft: [
					s + p,
					h,
					s + f,
					h,
					s,
					h - d
				]
			};
			return g.topLeft.isTop = !0, g.topRight.isTop = !0, g.bottomLeft.isBottom = !0, g.bottomRight.isBottom = !0, g;
		}, "generateBarrelBezierPts"),
		checkPoint: h(function(e, t, r, i, n, a, s, o) {
			var l = Bn(i, n), u = l.heightOffset, d = l.widthOffset;
			if (PH(e, t, this.points, a, s, i, n - 2 * u, [0, -1], r) || PH(e, t, this.points, a, s, i - 2 * d, n, [0, -1], r)) return !0;
			for (var p = this.generateBarrelBezierPts(i, n, a, s), f = h(function(e, t, r) {
				var i = r[4], n = r[2], a = r[0], s = r[5], o = r[1];
				if (Math.min(i, a) <= e && e <= Math.max(i, a) && Math.min(s, o) <= t && t <= Math.max(s, o)) {
					var l = Bi(i, n, a), h = Pq(l[0], l[1], l[2], e).filter(function(e) {
						return 0 <= e && e <= 1;
					});
					if (h.length > 0) return h[0];
				}
				return null;
			}, "getCurveT"), g = Object.keys(p), m = 0; m < g.length; m++) {
				var y = p[g[m]], v = f(e, t, y);
				if (null != v) {
					var x = Pw(y[5], y[3], y[1], v);
					if (y.isTop && x <= t || y.isBottom && t <= x) return !0;
				}
			}
			return !1;
		}, "checkPoint")
	};
}, WN.generateBottomRoundrectangle = function() {
	return this.nodeShapes["bottom-round-rectangle"] = this.nodeShapes.bottomroundrectangle = {
		renderer: this,
		name: "bottom-round-rectangle",
		points: P7(4, 0),
		draw: h(function(e, t, r, i, n, a) {
			this.renderer.nodeShapeImpl(this.name, e, t, r, i, n, this.points, a);
		}, "draw"),
		intersectLine: h(function(e, t, r, i, n, a, s, o) {
			var l = e - (r / 2 + s), h = t - (i / 2 + s), u = P2(n, a, e, t, l, h, e + (r / 2 + s), h, !1);
			return u.length > 0 ? u : Pz(n, a, e, t, r, i, s, o);
		}, "intersectLine"),
		checkPoint: h(function(e, t, r, i, n, a, s, o) {
			var l = 2 * (o = "auto" === o ? Be(i, n) : o);
			if (PH(e, t, this.points, a, s, i, n - l, [0, -1], r) || PH(e, t, this.points, a, s, i - l, n, [0, -1], r)) return !0;
			var h = i / 2 + 2 * r, u = n / 2 + 2 * r;
			return !!(PV(e, t, [
				a - h,
				s - u,
				a - h,
				s,
				a + h,
				s,
				a + h,
				s - u
			]) || PJ(e, t, l, l, a + i / 2 - o, s + n / 2 - o, r) || PJ(e, t, l, l, a - i / 2 + o, s + n / 2 - o, r));
		}, "checkPoint")
	};
}, WN.registerNodeShapes = function() {
	var e = this.nodeShapes = {}, t = this;
	this.generateEllipse(), this.generatePolygon("triangle", P7(3, 0)), this.generateRoundPolygon("round-triangle", P7(3, 0)), this.generatePolygon("rectangle", P7(4, 0)), e.square = e.rectangle, this.generateRoundRectangle(), this.generateCutRectangle(), this.generateBarrel(), this.generateBottomRoundrectangle();
	var r = [
		0,
		1,
		1,
		0,
		0,
		-1,
		-1,
		0
	];
	this.generatePolygon("diamond", r), this.generateRoundPolygon("round-diamond", r), this.generatePolygon("pentagon", P7(5, 0)), this.generateRoundPolygon("round-pentagon", P7(5, 0)), this.generatePolygon("hexagon", P7(6, 0)), this.generateRoundPolygon("round-hexagon", P7(6, 0)), this.generatePolygon("heptagon", P7(7, 0)), this.generateRoundPolygon("round-heptagon", P7(7, 0)), this.generatePolygon("octagon", P7(8, 0)), this.generateRoundPolygon("round-octagon", P7(8, 0));
	var i = Array(20), n = P9(5, 0), a = P9(5, Math.PI / 5), s = .5 * (3 - Math.sqrt(5));
	s *= 1.57;
	for (var o = 0; o < a.length / 2; o++) a[2 * o] *= s, a[2 * o + 1] *= s;
	for (var o = 0; o < 5; o++) i[4 * o] = n[2 * o], i[4 * o + 1] = n[2 * o + 1], i[4 * o + 2] = a[2 * o], i[4 * o + 3] = a[2 * o + 1];
	i = P8(i), this.generatePolygon("star", i), this.generatePolygon("vee", [
		-1,
		-1,
		0,
		-.333,
		1,
		-1,
		0,
		1
	]), this.generatePolygon("rhomboid", [
		-1,
		-1,
		.333,
		-1,
		1,
		1,
		-.333,
		1
	]), this.generatePolygon("right-rhomboid", [
		-.333,
		-1,
		1,
		-1,
		.333,
		1,
		-1,
		1
	]), this.nodeShapes.concavehexagon = this.generatePolygon("concave-hexagon", [
		-1,
		-.95,
		-.75,
		0,
		-1,
		.95,
		1,
		.95,
		.75,
		0,
		1,
		-.95
	]);
	var l = [
		-1,
		-1,
		.25,
		-1,
		1,
		0,
		.25,
		1,
		-1,
		1
	];
	this.generatePolygon("tag", l), this.generateRoundPolygon("round-tag", l), e.makePolygon = function(e) {
		var r, i = "polygon-" + e.join("$");
		return (r = this[i]) ? r : t.generatePolygon(i, e);
	};
};
var WI = {};
WI.timeToRender = function() {
	return this.redrawTotalTime / this.redrawCount;
}, WI.redraw = function(e) {
	e = e || $s(), void 0 === this.averageRedrawTime && (this.averageRedrawTime = 0), void 0 === this.lastRedrawTime && (this.lastRedrawTime = 0), void 0 === this.lastDrawTime && (this.lastDrawTime = 0), this.requestedFrame = !0, this.renderOptions = e;
}, WI.beforeRender = function(e, t) {
	if (!this.destroyed) {
		t ?? O8("Priority is not optional for beforeRender");
		var r = this.beforeRenderCallbacks;
		r.push({
			fn: e,
			priority: t
		}), r.sort(function(e, t) {
			return t.priority - e.priority;
		});
	}
};
var WM = h(function(e, t, r) {
	for (var i = e.beforeRenderCallbacks, n = 0; n < i.length; n++) i[n].fn(t, r);
}, "beforeRenderCallbacks");
WI.startRenderLoop = function() {
	var e = this, t = e.cy;
	if (!e.renderLoopStarted) {
		e.renderLoopStarted = !0;
		var r = h(function(i) {
			if (!e.destroyed) {
				if (!t.batching()) if (e.requestedFrame && !e.skipFrame) {
					WM(e, !0, i);
					var n = OB();
					e.render(e.renderOptions);
					var a = e.lastDrawTime = OB();
					void 0 === e.averageRedrawTime && (e.averageRedrawTime = a - n), void 0 === e.redrawCount && (e.redrawCount = 0), e.redrawCount++, void 0 === e.redrawTotalTime && (e.redrawTotalTime = 0);
					var s = a - n;
					e.redrawTotalTime += s, e.lastRedrawTime = s, e.averageRedrawTime = e.averageRedrawTime / 2 + s / 2, e.requestedFrame = !1;
				} else WM(e, !1, i);
				e.skipFrame = !1, Oz(r);
			}
		}, "renderFn");
		Oz(r);
	}
};
var WD = h(function(e) {
	this.init(e);
}, "BaseRenderer"), WO = WD.prototype;
WO.clientFunctions = [
	"redrawHint",
	"render",
	"renderTo",
	"matchCanvasSize",
	"nodeShapeImpl",
	"arrowShapeImpl"
], WO.init = function(e) {
	this.options = e, this.cy = e.cy;
	var t = this.container = e.cy.container(), r = this.cy.window();
	if (r) {
		var i = r.document, n = i.head, a = "__________cytoscape_stylesheet", s = "__________cytoscape_container", o = null != i.getElementById(a);
		if (0 > t.className.indexOf(s) && (t.className = (t.className || "") + " " + s), !o) {
			var l = i.createElement("style");
			l.id = a, l.textContent = "." + s + " { position: relative; }", n.insertBefore(l, n.children[0]);
		}
		"static" === r.getComputedStyle(t).getPropertyValue("position") && $e("A Cytoscape container has style position:static and so can not use UI extensions properly");
	}
	this.selection = [
		void 0,
		void 0,
		void 0,
		void 0,
		0
	], this.bezierProjPcts = [
		.05,
		.225,
		.4,
		.5,
		.6,
		.775,
		.95
	], this.hoverData = {
		down: null,
		last: null,
		downTime: null,
		triggerMode: null,
		dragging: !1,
		initialPan: [null, null],
		capture: !1
	}, this.dragData = { possibleDragElements: [] }, this.touchData = {
		start: null,
		capture: !1,
		startPosition: [
			null,
			null,
			null,
			null,
			null,
			null
		],
		singleTouchStartTime: null,
		singleTouchMoved: !0,
		now: [
			null,
			null,
			null,
			null,
			null,
			null
		],
		earlier: [
			null,
			null,
			null,
			null,
			null,
			null
		]
	}, this.redraws = 0, this.showFps = e.showFps, this.debug = e.debug, this.webgl = e.webgl, this.hideEdgesOnViewport = e.hideEdgesOnViewport, this.textureOnViewport = e.textureOnViewport, this.wheelSensitivity = e.wheelSensitivity, this.motionBlurEnabled = e.motionBlur, this.forcedPixelRatio = DH(e.pixelRatio) ? e.pixelRatio : null, this.motionBlur = e.motionBlur, this.motionBlurOpacity = e.motionBlurOpacity, this.motionBlurTransparency = 1 - this.motionBlurOpacity, this.motionBlurPxRatio = 1, this.mbPxRBlurry = 1, this.minMbLowQualFrames = 4, this.fullQualityMb = !1, this.clearedForMotionBlur = [], this.desktopTapThreshold = e.desktopTapThreshold, this.desktopTapThreshold2 = e.desktopTapThreshold * e.desktopTapThreshold, this.touchTapThreshold = e.touchTapThreshold, this.touchTapThreshold2 = e.touchTapThreshold * e.touchTapThreshold, this.tapholdDuration = 500, this.bindings = [], this.beforeRenderCallbacks = [], this.beforeRenderPriorities = {
		animations: 400,
		eleCalcs: 300,
		eleTxrDeq: 200,
		lyrTxrDeq: 150,
		lyrTxrSkip: 100
	}, this.registerNodeShapes(), this.registerArrowShapes(), this.registerCalculationListeners();
}, WO.notify = function(e, t) {
	var r = this.cy;
	if (!this.destroyed) {
		if ("init" === e) return void this.load();
		if ("destroy" === e) return void this.destroy();
		("add" === e || "remove" === e || "move" === e && r.hasCompoundNodes() || "load" === e || "zorder" === e || "mount" === e) && this.invalidateCachedZSortedEles(), "viewport" === e && this.redrawHint("select", !0), "gc" === e && this.redrawHint("gc", !0), ("load" === e || "resize" === e || "mount" === e) && (this.invalidateContainerClientCoordsCache(), this.matchCanvasSize(this.container)), this.redrawHint("eles", !0), this.redrawHint("drag", !0), this.startRenderLoop(), this.redraw();
	}
}, WO.destroy = function() {
	this.destroyed = !0, this.cy.stopAnimationLoop();
	for (var e = 0; e < this.bindings.length; e++) {
		var t = this.bindings[e], r = t.target;
		(r.off || r.removeEventListener).apply(r, t.args);
	}
	if (this.bindings = [], this.beforeRenderCallbacks = [], this.onUpdateEleCalcsFns = [], this.removeObserver && this.removeObserver.disconnect(), this.styleObserver && this.styleObserver.disconnect(), this.resizeObserver && this.resizeObserver.disconnect(), this.labelCalcDiv) try {
		document.body.removeChild(this.labelCalcDiv);
	} catch {}
}, WO.isHeadless = function() {
	return !1;
}, [
	jZ,
	WA,
	WL,
	WR,
	WN,
	WI
].forEach(function(e) {
	Ou(WO, e);
});
var W$ = 1e3 / 60, WP = { setupDequeueing: h(function(e) {
	return h(function() {
		var t = this, r = this.renderer;
		if (!t.dequeueingSetup) {
			t.dequeueingSetup = !0;
			var i = O$(function() {
				r.redrawHint("eles", !0), r.redrawHint("drag", !0), r.redraw();
			}, e.deqRedrawThreshold), n = h(function(n, a) {
				var s = OB(), o = r.averageRedrawTime, l = r.lastRedrawTime, h = [], u = r.cy.extent(), d = r.getPixelRatio();
				for (n || r.flushRenderedStyleQueue();;) {
					var p = OB(), f = p - s, g = p - a;
					if (l < W$) {
						var m = W$ - (n ? o : 0);
						if (g >= e.deqFastCost * m) break;
					} else if (n) {
						if (f >= e.deqCost * l || f >= e.deqAvgCost * o) break;
					} else if (g >= e.deqNoDrawCost * W$) break;
					var y = e.deq(t, d, u);
					if (y.length > 0) for (var v = 0; v < y.length; v++) h.push(y[v]);
					else break;
				}
				h.length > 0 && (e.onDeqd(t, h), !n && e.shouldRedraw(t, h, d, u) && i());
			}, "dequeue"), a = e.priority || O7;
			r.beforeRender(n, a(t));
		}
	}, "setupDequeueingImpl");
}, "setupDequeueing") }, WB = function() {
	function e(t) {
		var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : O3;
		Dw(this, e), this.idsByKey = new $f(), this.keyForId = new $f(), this.cachesByLvl = new $f(), this.lvls = [], this.getKey = t, this.doesEleInvalidateKey = r;
	}
	return h(e, "ElementTextureCacheLookup"), DT(e, [
		{
			key: "getIdsFor",
			value: h(function(e) {
				e ?? O8("Can not get id list for null key");
				var t = this.idsByKey, r = this.idsByKey.get(e);
				return r || (r = new $m(), t.set(e, r)), r;
			}, "getIdsFor")
		},
		{
			key: "addIdForKey",
			value: h(function(e, t) {
				null != e && this.getIdsFor(e).add(t);
			}, "addIdForKey")
		},
		{
			key: "deleteIdForKey",
			value: h(function(e, t) {
				null != e && this.getIdsFor(e).delete(t);
			}, "deleteIdForKey")
		},
		{
			key: "getNumberOfIdsForKey",
			value: h(function(e) {
				return null == e ? 0 : this.getIdsFor(e).size;
			}, "getNumberOfIdsForKey")
		},
		{
			key: "updateKeyMappingFor",
			value: h(function(e) {
				var t = e.id(), r = this.keyForId.get(t), i = this.getKey(e);
				this.deleteIdForKey(r, t), this.addIdForKey(i, t), this.keyForId.set(t, i);
			}, "updateKeyMappingFor")
		},
		{
			key: "deleteKeyMappingFor",
			value: h(function(e) {
				var t = e.id(), r = this.keyForId.get(t);
				this.deleteIdForKey(r, t), this.keyForId.delete(t);
			}, "deleteKeyMappingFor")
		},
		{
			key: "keyHasChangedFor",
			value: h(function(e) {
				var t = e.id();
				return this.keyForId.get(t) !== this.getKey(e);
			}, "keyHasChangedFor")
		},
		{
			key: "isInvalid",
			value: h(function(e) {
				return this.keyHasChangedFor(e) || this.doesEleInvalidateKey(e);
			}, "isInvalid")
		},
		{
			key: "getCachesAt",
			value: h(function(e) {
				var t = this.cachesByLvl, r = this.lvls, i = t.get(e);
				return i || (i = new $f(), t.set(e, i), r.push(e)), i;
			}, "getCachesAt")
		},
		{
			key: "getCache",
			value: h(function(e, t) {
				return this.getCachesAt(t).get(e);
			}, "getCache")
		},
		{
			key: "get",
			value: h(function(e, t) {
				var r = this.getKey(e), i = this.getCache(r, t);
				return null != i && this.updateKeyMappingFor(e), i;
			}, "get")
		},
		{
			key: "getForCachedKey",
			value: h(function(e, t) {
				var r = this.keyForId.get(e.id());
				return this.getCache(r, t);
			}, "getForCachedKey")
		},
		{
			key: "hasCache",
			value: h(function(e, t) {
				return this.getCachesAt(t).has(e);
			}, "hasCache")
		},
		{
			key: "has",
			value: h(function(e, t) {
				var r = this.getKey(e);
				return this.hasCache(r, t);
			}, "has")
		},
		{
			key: "setCache",
			value: h(function(e, t, r) {
				r.key = e, this.getCachesAt(t).set(e, r);
			}, "setCache")
		},
		{
			key: "set",
			value: h(function(e, t, r) {
				var i = this.getKey(e);
				this.setCache(i, t, r), this.updateKeyMappingFor(e);
			}, "set")
		},
		{
			key: "deleteCache",
			value: h(function(e, t) {
				this.getCachesAt(t).delete(e);
			}, "deleteCache")
		},
		{
			key: "delete",
			value: h(function(e, t) {
				var r = this.getKey(e);
				this.deleteCache(r, t);
			}, "_delete")
		},
		{
			key: "invalidateKey",
			value: h(function(e) {
				var t = this;
				this.lvls.forEach(function(r) {
					return t.deleteCache(e, r);
				});
			}, "invalidateKey")
		},
		{
			key: "invalidate",
			value: h(function(e) {
				var t = e.id(), r = this.keyForId.get(t);
				this.deleteKeyMappingFor(e);
				var i = this.doesEleInvalidateKey(e);
				return i && this.invalidateKey(r), i || 0 === this.getNumberOfIdsForKey(r);
			}, "invalidate")
		}
	]);
}(), WF = {
	dequeue: "dequeue",
	downscale: "downscale",
	highQuality: "highQuality"
}, Wz = $o({
	getKey: null,
	doesEleInvalidateKey: O3,
	drawElement: null,
	getBoundingBox: null,
	getRotationPoint: null,
	getRotationOffset: null,
	isVisible: O5,
	allowEdgeTxrCaching: !0,
	allowParentTxrCaching: !0
}), WU = h(function(e, t) {
	this.renderer = e, this.onDequeues = [];
	var r = Wz(t);
	Ou(this, r), this.lookup = new WB(r.getKey, r.doesEleInvalidateKey), this.setupDequeueing();
}, "ElementTextureCache"), WG = WU.prototype;
WG.reasons = WF, WG.getTextureQueue = function(e) {
	return this.eleImgCaches = this.eleImgCaches || {}, this.eleImgCaches[e] = this.eleImgCaches[e] || [];
}, WG.getRetiredTextureQueue = function(e) {
	var t = this.eleImgCaches.retired = this.eleImgCaches.retired || {};
	return t[e] = t[e] || [];
}, WG.getElementQueue = function() {
	return this.eleCacheQueue = this.eleCacheQueue || new $2(function(e, t) {
		return t.reqs - e.reqs;
	});
}, WG.getElementKeyToQueue = function() {
	return this.eleKeyToCacheQueue = this.eleKeyToCacheQueue || {};
}, WG.getElement = function(e, t, r, i, n) {
	var a, s = this, o = this.renderer, l = o.cy.zoom(), u = this.lookup;
	if (!t || 0 === t.w || 0 === t.h || isNaN(t.w) || isNaN(t.h) || !e.visible() || e.removed() || !s.allowEdgeTxrCaching && e.isEdge() || !s.allowParentTxrCaching && e.isParent()) return null;
	if ((i ??= Math.ceil(Pm(l * r))) < -4) i = -4;
	else if (l >= 7.99 || i > 3) return null;
	var d = Math.pow(2, i), p = t.h * d, f = t.w * d, g = o.eleTextBiggerThanMin(e, d);
	if (!this.isVisible(e, g)) return null;
	var m = u.get(e, i);
	if (m && m.invalidated && (m.invalidated = !1, m.texture.invalidatedWidth -= m.width), m) return m;
	if (b = p <= 25 ? 25 : p <= 50 ? 50 : 50 * Math.ceil(p / 50), p > 1024 || f > 1024) return null;
	var y = s.getTextureQueue(b), v = y[y.length - 2], x = h(function() {
		return s.recycleTexture(b, f) || s.addTexture(b, f);
	}, "addNewTxr");
	v || (v = y[y.length - 1]), v || (v = x()), v.width - v.usedWidth < f && (v = x());
	for (var b, w, k = h(function(e) {
		return e && e.scaledLabelShown === g;
	}, "scalableFrom"), T = n && n === WF.dequeue, _ = n && n === WF.highQuality, E = n && n === WF.downscale, C = i + 1; C <= 3; C++) {
		var S = u.get(e, C);
		if (S) {
			w = S;
			break;
		}
	}
	var A = w && w.level === i + 1 ? w : null, L = h(function() {
		v.context.drawImage(A.texture.canvas, A.x, 0, A.width, A.height, v.usedWidth, 0, f, p);
	}, "downscale");
	if (v.context.setTransform(1, 0, 0, 1, 0, 0), v.context.clearRect(v.usedWidth, 0, f, b), k(A)) L();
	else if (k(w)) if (!_) return s.queueElement(e, w.level - 1), w;
	else {
		for (var R = w.level; R > i; R--) A = s.getElement(e, t, r, R, WF.downscale);
		L();
	}
	else {
		if (!T && !_ && !E) for (var N = i - 1; N >= -4; N--) {
			var I = u.get(e, N);
			if (I) {
				a = I;
				break;
			}
		}
		if (k(a)) return s.queueElement(e, i), a;
		v.context.translate(v.usedWidth, 0), v.context.scale(d, d), this.drawElement(v.context, e, t, g, !1), v.context.scale(1 / d, 1 / d), v.context.translate(-v.usedWidth, 0);
	}
	return m = {
		x: v.usedWidth,
		texture: v,
		level: i,
		scale: d,
		width: f,
		height: p,
		scaledLabelShown: g
	}, v.usedWidth += Math.ceil(f + 8), v.eleCaches.push(m), u.set(e, i, m), s.checkTextureFullness(v), m;
}, WG.invalidateElements = function(e) {
	for (var t = 0; t < e.length; t++) this.invalidateElement(e[t]);
}, WG.invalidateElement = function(e) {
	var t = this.lookup, r = [];
	if (t.isInvalid(e)) {
		for (var i = -4; i <= 3; i++) {
			var n = t.getForCachedKey(e, i);
			n && r.push(n);
		}
		if (t.invalidate(e)) for (var a = 0; a < r.length; a++) {
			var s = r[a], o = s.texture;
			o.invalidatedWidth += s.width, s.invalidated = !0, this.checkTextureUtility(o);
		}
		this.removeFromQueue(e);
	}
}, WG.checkTextureUtility = function(e) {
	e.invalidatedWidth >= .2 * e.width && this.retireTexture(e);
}, WG.checkTextureFullness = function(e) {
	var t = this.getTextureQueue(e.height);
	e.usedWidth / e.width > .8 && e.fullnessChecks >= 10 ? $l(t, e) : e.fullnessChecks++;
}, WG.retireTexture = function(e) {
	var t = e.height, r = this.getTextureQueue(t), i = this.lookup;
	$l(r, e), e.retired = !0;
	for (var n = e.eleCaches, a = 0; a < n.length; a++) {
		var s = n[a];
		i.deleteCache(s.key, s.level);
	}
	$c(n), this.getRetiredTextureQueue(t).push(e);
}, WG.addTexture = function(e, t) {
	var r = this.getTextureQueue(e), i = {};
	return r.push(i), i.eleCaches = [], i.height = e, i.width = Math.max(1024, t), i.usedWidth = 0, i.invalidatedWidth = 0, i.fullnessChecks = 0, i.canvas = this.renderer.makeOffscreenCanvas(i.width, i.height), i.context = i.canvas.getContext("2d"), i;
}, WG.recycleTexture = function(e, t) {
	for (var r = this.getTextureQueue(e), i = this.getRetiredTextureQueue(e), n = 0; n < i.length; n++) {
		var a = i[n];
		if (a.width >= t) return a.retired = !1, a.usedWidth = 0, a.invalidatedWidth = 0, a.fullnessChecks = 0, $c(a.eleCaches), a.context.setTransform(1, 0, 0, 1, 0, 0), a.context.clearRect(0, 0, a.width, a.height), $l(i, a), r.push(a), a;
	}
}, WG.queueElement = function(e, t) {
	var r = this.getElementQueue(), i = this.getElementKeyToQueue(), n = this.getKey(e), a = i[n];
	if (a) a.level = Math.max(a.level, t), a.eles.merge(e), a.reqs++, r.updateItem(a);
	else {
		var s = {
			eles: e.spawn().merge(e),
			level: t,
			reqs: 1,
			key: n
		};
		r.push(s), i[n] = s;
	}
}, WG.dequeue = function(e) {
	for (var t = this.getElementQueue(), r = this.getElementKeyToQueue(), i = [], n = this.lookup, a = 0; a < 1 && t.size() > 0; a++) {
		var s = t.pop(), o = s.key, l = s.eles[0], h = n.hasCache(l, s.level);
		if (r[o] = null, !h) {
			i.push(s);
			var u = this.getBoundingBox(l);
			this.getElement(l, u, e, s.level, WF.dequeue);
		}
	}
	return i;
}, WG.removeFromQueue = function(e) {
	var t = this.getElementQueue(), r = this.getElementKeyToQueue(), i = this.getKey(e), n = r[i];
	null != n && (1 === n.eles.length ? (n.reqs = O4, t.updateItem(n), t.pop(), r[i] = null) : n.eles.unmerge(e));
}, WG.onDequeue = function(e) {
	this.onDequeues.push(e);
}, WG.offDequeue = function(e) {
	$l(this.onDequeues, e);
}, WG.setupDequeueing = WP.setupDequeueing({
	deqRedrawThreshold: 100,
	deqCost: .15,
	deqAvgCost: .1,
	deqNoDrawCost: .9,
	deqFastCost: .9,
	deq: h(function(e, t, r) {
		return e.dequeue(t, r);
	}, "deq"),
	onDeqd: h(function(e, t) {
		for (var r = 0; r < e.onDequeues.length; r++) (0, e.onDequeues[r])(t);
	}, "onDeqd"),
	shouldRedraw: h(function(e, t, r, i) {
		for (var n = 0; n < t.length; n++) for (var a = t[n].eles, s = 0; s < a.length; s++) if (PM(a[s].boundingBox(), i)) return !0;
		return !1;
	}, "shouldRedraw"),
	priority: h(function(e) {
		return e.renderer.beforeRenderPriorities.eleTxrDeq;
	}, "priority")
});
var Wq = 4e3 * 4e3, Wj = h(function(e) {
	var t = this, r = t.renderer = e, i = r.cy;
	t.layersByLevel = {}, t.firstGet = !0, t.lastInvalidationTime = OB() - 500, t.skipping = !1, t.eleTxrDeqs = i.collection(), t.scheduleElementRefinement = O$(function() {
		t.refineElementTextures(t.eleTxrDeqs), t.eleTxrDeqs.unmerge(t.eleTxrDeqs);
	}, 50), r.beforeRender(function(e, r) {
		r - t.lastInvalidationTime <= 250 ? t.skipping = !0 : t.skipping = !1;
	}, r.beforeRenderPriorities.lyrTxrSkip), t.layersQueue = new $2(h(function(e, t) {
		return t.reqs - e.reqs;
	}, "qSort")), t.setupDequeueing();
}, "LayeredTextureCache"), WW = Wj.prototype, WY = 0;
WW.makeLayer = function(e, t) {
	var r = Math.pow(2, t), i = Math.ceil(e.w * r), n = Math.ceil(e.h * r), a = this.renderer.makeOffscreenCanvas(i, n), s = {
		id: WY = ++WY % 9007199254740991,
		bb: e,
		level: t,
		width: i,
		height: n,
		canvas: a,
		context: a.getContext("2d"),
		eles: [],
		elesQueue: [],
		reqs: 0
	}, o = s.context, l = -s.bb.x1, h = -s.bb.y1;
	return o.scale(r, r), o.translate(l, h), s;
}, WW.getLayers = function(e, t, r) {
	var i = this, n = i.renderer.cy.zoom(), a = i.firstGet;
	if (i.firstGet = !1, null == r) {
		if ((r = Math.ceil(Pm(n * t))) < -4) r = -4;
		else if (n >= 3.99 || r > 2) return null;
	}
	i.validateLayersElesOrdering(r, e);
	var s, o, l = i.layersByLevel, u = Math.pow(2, r), d = l[r] = l[r] || [], p = i.levelIsComplete(r, e), f = h(function() {
		var t = h(function(t) {
			if (i.validateLayersElesOrdering(t, e), i.levelIsComplete(t, e)) return o = l[t], !0;
		}, "canUseAsTmpLvl"), n = h(function(e) {
			if (!o) for (var i = r + e; -4 <= i && i <= 2 && !t(i); i += e);
		}, "checkLvls");
		n(1), n(-1);
		for (var a = d.length - 1; a >= 0; a--) {
			var s = d[a];
			s.invalid && $l(d, s);
		}
	}, "checkTempLevels");
	if (p) return d;
	f();
	var g = h(function() {
		if (!s) {
			s = PE();
			for (var t = 0; t < e.length; t++) PA(s, e[t].boundingBox());
		}
		return s;
	}, "getBb"), m = h(function(e) {
		var t = (e = e || {}).after;
		g();
		var n = Math.ceil(s.w * u), a = Math.ceil(s.h * u);
		if (n > 32767 || a > 32767 || n * a > Wq) return null;
		var o = i.makeLayer(s, r);
		if (null != t) {
			var l = d.indexOf(t) + 1;
			d.splice(l, 0, o);
		} else (void 0 === e.insert || e.insert) && d.unshift(o);
		return o;
	}, "makeLayer");
	if (i.skipping && !a) return null;
	for (var y = null, v = e.length / 1, x = !a, b = 0; b < e.length; b++) {
		var w = e[b], k = w._private.rscratch, T = k.imgLayerCaches = k.imgLayerCaches || {}, _ = T[r];
		if (_) {
			y = _;
			continue;
		}
		if ((!y || y.eles.length >= v || !P$(y.bb, w.boundingBox())) && !(y = m({
			insert: !0,
			after: y
		}))) return null;
		o || x ? i.queueLayer(y, w) : i.drawEleInLayer(y, w, r, t), y.eles.push(w), T[r] = y;
	}
	return o || (x ? null : d);
}, WW.getEleLevelForLayerLevel = function(e, t) {
	return e;
}, WW.drawEleInLayer = function(e, t, r, i) {
	var n = this.renderer, a = e.context, s = t.boundingBox();
	0 !== s.w && 0 !== s.h && t.visible() && (r = this.getEleLevelForLayerLevel(r, i), n.setImgSmoothing(a, !1), n.drawCachedElement(a, t, null, null, r, !0), n.setImgSmoothing(a, !0));
}, WW.levelIsComplete = function(e, t) {
	var r = this.layersByLevel[e];
	if (!r || 0 === r.length) return !1;
	for (var i = 0, n = 0; n < r.length; n++) {
		var a = r[n];
		if (a.reqs > 0 || a.invalid) return !1;
		i += a.eles.length;
	}
	return i === t.length;
}, WW.validateLayersElesOrdering = function(e, t) {
	var r = this.layersByLevel[e];
	if (r) for (var i = 0; i < r.length; i++) {
		for (var n = r[i], a = -1, s = 0; s < t.length; s++) if (n.eles[0] === t[s]) {
			a = s;
			break;
		}
		if (a < 0) {
			this.invalidateLayer(n);
			continue;
		}
		for (var o = a, s = 0; s < n.eles.length; s++) if (n.eles[s] !== t[o + s]) {
			this.invalidateLayer(n);
			break;
		}
	}
}, WW.updateElementsInLayers = function(e, t) {
	for (var r = DQ(e[0]), i = 0; i < e.length; i++) for (var n = r ? null : e[i], a = r ? e[i] : e[i].ele, s = a._private.rscratch, o = s.imgLayerCaches = s.imgLayerCaches || {}, l = -4; l <= 2; l++) {
		var h = o[l];
		h && (n && this.getEleLevelForLayerLevel(h.level) !== n.level || t(h, a, n));
	}
}, WW.haveLayers = function() {
	for (var e = !1, t = -4; t <= 2; t++) {
		var r = this.layersByLevel[t];
		if (r && r.length > 0) {
			e = !0;
			break;
		}
	}
	return e;
}, WW.invalidateElements = function(e) {
	var t = this;
	0 === e.length || (t.lastInvalidationTime = OB(), 0 !== e.length && t.haveLayers() && t.updateElementsInLayers(e, h(function(e, r, i) {
		t.invalidateLayer(e);
	}, "invalAssocLayers")));
}, WW.invalidateLayer = function(e) {
	if (this.lastInvalidationTime = OB(), !e.invalid) {
		var t = e.level, r = e.eles;
		$l(this.layersByLevel[t], e), e.elesQueue = [], e.invalid = !0, e.replacement && (e.replacement.invalid = !0);
		for (var i = 0; i < r.length; i++) {
			var n = r[i]._private.rscratch.imgLayerCaches;
			n && (n[t] = null);
		}
	}
}, WW.refineElementTextures = function(e) {
	var t = this;
	t.updateElementsInLayers(e, h(function(e, r, i) {
		var n = e.replacement;
		if (n || ((n = e.replacement = t.makeLayer(e.bb, e.level)).replaces = e, n.eles = e.eles), !n.reqs) for (var a = 0; a < n.eles.length; a++) t.queueLayer(n, n.eles[a]);
	}, "refineEachEle"));
}, WW.enqueueElementRefinement = function(e) {
	this.eleTxrDeqs.merge(e), this.scheduleElementRefinement();
}, WW.queueLayer = function(e, t) {
	var r = this.layersQueue, i = e.elesQueue, n = i.hasId = i.hasId || {};
	if (!e.replacement) {
		if (t) {
			if (n[t.id()]) return;
			i.push(t), n[t.id()] = !0;
		}
		e.reqs ? (e.reqs++, r.updateItem(e)) : (e.reqs = 1, r.push(e));
	}
}, WW.dequeue = function(e) {
	for (var t = this.layersQueue, r = [], i = 0; i < 1 && 0 !== t.size();) {
		var n = t.peek();
		if (n.replacement || n.replaces && n !== n.replaces.replacement || n.invalid) {
			t.pop();
			continue;
		}
		var a = n.elesQueue.shift();
		a && (this.drawEleInLayer(n, a, n.level, e), i++), 0 === r.length && r.push(!0), 0 === n.elesQueue.length && (t.pop(), n.reqs = 0, n.replaces && this.applyLayerReplacement(n), this.requestRedraw());
	}
	return r;
}, WW.applyLayerReplacement = function(e) {
	var t = this.layersByLevel[e.level], r = e.replaces, i = t.indexOf(r);
	if (!(i < 0 || r.invalid)) {
		t[i] = e;
		for (var n = 0; n < e.eles.length; n++) {
			var a = e.eles[n]._private, s = a.imgLayerCaches = a.imgLayerCaches || {};
			s && (s[e.level] = e);
		}
		this.requestRedraw();
	}
}, WW.requestRedraw = O$(function() {
	var e = this.renderer;
	e.redrawHint("eles", !0), e.redrawHint("drag", !0), e.redraw();
}, 100), WW.setupDequeueing = WP.setupDequeueing({
	deqRedrawThreshold: 50,
	deqCost: .15,
	deqAvgCost: .1,
	deqNoDrawCost: .9,
	deqFastCost: .9,
	deq: h(function(e, t) {
		return e.dequeue(t);
	}, "deq"),
	onDeqd: O7,
	shouldRedraw: O5,
	priority: h(function(e) {
		return e.renderer.beforeRenderPriorities.lyrTxrDeq;
	}, "priority")
});
var WV, WH = {};
function WX(e, t) {
	for (var r = 0; r < t.length; r++) {
		var i = t[r];
		e.lineTo(i.x, i.y);
	}
}
function WK(e, t, r) {
	for (var i, n = 0; n < t.length; n++) {
		var a = t[n];
		0 === n && (i = a), e.lineTo(a.x, a.y);
	}
	e.quadraticCurveTo(r.x, r.y, i.x, i.y);
}
function WZ(e, t, r) {
	e.beginPath && e.beginPath();
	for (var i = 0; i < t.length; i++) {
		var n = t[i];
		e.lineTo(n.x, n.y);
	}
	var a = r[0];
	e.moveTo(a.x, a.y);
	for (var i = 1; i < r.length; i++) {
		var n = r[i];
		e.lineTo(n.x, n.y);
	}
	e.closePath && e.closePath();
}
function WQ(e, t, r, i, n) {
	e.beginPath && e.beginPath(), e.arc(r, i, n, 0, 2 * Math.PI, !1);
	var a = t[0];
	e.moveTo(a.x, a.y);
	for (var s = 0; s < t.length; s++) {
		var o = t[s];
		e.lineTo(o.x, o.y);
	}
	e.closePath && e.closePath();
}
function WJ(e, t, r, i) {
	e.arc(t, r, i, 0, 2 * Math.PI, !1);
}
h(WX, "polygon"), h(WK, "triangleBackcurve"), h(WZ, "triangleTee"), h(WQ, "circleTriangle"), h(WJ, "circle$1"), WH.arrowShapeImpl = function(e) {
	return (WV || (WV = {
		polygon: WX,
		"triangle-backcurve": WK,
		"triangle-tee": WZ,
		"circle-triangle": WQ,
		"triangle-cross": WZ,
		circle: WJ
	}))[e];
};
var W0 = {};
W0.drawElement = function(e, t, r, i, n, a) {
	t.isNode() ? this.drawNode(e, t, r, i, n, a) : this.drawEdge(e, t, r, i, n, a);
}, W0.drawElementOverlay = function(e, t) {
	t.isNode() ? this.drawNodeOverlay(e, t) : this.drawEdgeOverlay(e, t);
}, W0.drawElementUnderlay = function(e, t) {
	t.isNode() ? this.drawNodeUnderlay(e, t) : this.drawEdgeUnderlay(e, t);
}, W0.drawCachedElementPortion = function(e, t, r, i, n, a, s, o) {
	var l = r.getBoundingBox(t);
	if (0 !== l.w && 0 !== l.h) {
		var h = r.getElement(t, l, i, n, a);
		if (null != h) {
			var u, d = o(this, t);
			if (0 === d) return;
			var p, f, g, m, y, v = s(this, t), x = l.x1, b = l.y1, w = l.w, k = l.h;
			if (0 !== v) {
				var T = r.getRotationPoint(t);
				g = T.x, m = T.y, e.translate(g, m), e.rotate(v), (y = this.getImgSmoothing(e)) || this.setImgSmoothing(e, !0);
				var _ = r.getRotationOffset(t);
				p = _.x, f = _.y;
			} else p = x, f = b;
			1 !== d && (u = e.globalAlpha, e.globalAlpha = u * d), e.drawImage(h.texture.canvas, h.x, 0, h.width, h.height, p, f, w, k), 1 !== d && (e.globalAlpha = u), 0 !== v && (e.rotate(-v), e.translate(-g, -m), y || this.setImgSmoothing(e, !1));
		} else r.drawElement(e, t);
	}
};
var W1 = h(function() {
	return 0;
}, "getZeroRotation"), W2 = h(function(e, t) {
	return e.getTextAngle(t, null);
}, "getLabelRotation"), W4 = h(function(e, t) {
	return e.getTextAngle(t, "source");
}, "getSourceLabelRotation"), W5 = h(function(e, t) {
	return e.getTextAngle(t, "target");
}, "getTargetLabelRotation"), W3 = h(function(e, t) {
	return t.effectiveOpacity();
}, "getOpacity"), W6 = h(function(e, t) {
	return t.pstyle("text-opacity").pfValue * t.effectiveOpacity();
}, "getTextOpacity");
W0.drawCachedElement = function(e, t, r, i, n, a) {
	var s = this.data, o = s.eleTxrCache, l = s.lblTxrCache, h = s.slbTxrCache, u = s.tlbTxrCache, d = t.boundingBox(), p = !0 === a ? o.reasons.highQuality : null;
	if (!(0 === d.w || 0 === d.h || !t.visible()) && (!i || PM(d, i))) {
		var f = t.isEdge(), g = t.element()._private.rscratch.badLine;
		this.drawElementUnderlay(e, t), this.drawCachedElementPortion(e, t, o, r, n, p, W1, W3), f && g || this.drawCachedElementPortion(e, t, l, r, n, p, W2, W6), f && !g && (this.drawCachedElementPortion(e, t, h, r, n, p, W4, W6), this.drawCachedElementPortion(e, t, u, r, n, p, W5, W6)), this.drawElementOverlay(e, t);
	}
}, W0.drawElements = function(e, t) {
	for (var r = 0; r < t.length; r++) {
		var i = t[r];
		this.drawElement(e, i);
	}
}, W0.drawCachedElements = function(e, t, r, i) {
	for (var n = 0; n < t.length; n++) {
		var a = t[n];
		this.drawCachedElement(e, a, r, i);
	}
}, W0.drawCachedNodes = function(e, t, r, i) {
	for (var n = 0; n < t.length; n++) {
		var a = t[n];
		a.isNode() && this.drawCachedElement(e, a, r, i);
	}
}, W0.drawLayeredElements = function(e, t, r, i) {
	var n = this.data.lyrTxrCache.getLayers(t, r);
	if (n) for (var a = 0; a < n.length; a++) {
		var s = n[a], o = s.bb;
		0 === o.w || 0 === o.h || e.drawImage(s.canvas, o.x1, o.y1, o.w, o.h);
	}
	else this.drawCachedElements(e, t, r, i);
};
var W7 = {};
W7.drawEdge = function(e, t, r) {
	var i = !(arguments.length > 3) || void 0 === arguments[3] || arguments[3], n = !(arguments.length > 4) || void 0 === arguments[4] || arguments[4], a = !(arguments.length > 5) || void 0 === arguments[5] || arguments[5], s = this, o = t._private.rscratch;
	if (!(a && !t.visible()) && !(o.badLine || null == o.allpts || isNaN(o.allpts[0]))) {
		r && (l = r, e.translate(-l.x1, -l.y1));
		var l, u = a ? t.pstyle("opacity").value : 1, d = a ? t.pstyle("line-opacity").value : 1, p = t.pstyle("curve-style").value, f = t.pstyle("line-style").value, g = t.pstyle("width").pfValue, m = t.pstyle("line-cap").value, y = t.pstyle("line-outline-width").value, v = t.pstyle("line-outline-color").value, x = u * d, b = u * d, w = h(function() {
			var r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : x;
			"straight-triangle" === p ? (s.eleStrokeStyle(e, t, r), s.drawEdgeTrianglePath(t, e, o.allpts)) : (e.lineWidth = g, e.lineCap = m, s.eleStrokeStyle(e, t, r), s.drawEdgePath(t, e, o.allpts, f), e.lineCap = "butt");
		}, "drawLine"), k = h(function() {
			var r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : x;
			if (e.lineWidth = g + y, e.lineCap = m, y > 0) s.colorStrokeStyle(e, v[0], v[1], v[2], r);
			else {
				e.lineCap = "butt";
				return;
			}
			"straight-triangle" === p ? s.drawEdgeTrianglePath(t, e, o.allpts) : (s.drawEdgePath(t, e, o.allpts, f), e.lineCap = "butt");
		}, "drawLineOutline"), T = h(function() {
			n && s.drawEdgeOverlay(e, t);
		}, "drawOverlay"), _ = h(function() {
			n && s.drawEdgeUnderlay(e, t);
		}, "drawUnderlay"), E = h(function() {
			var r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : b;
			s.drawArrowheads(e, t, r);
		}, "drawArrows"), C = h(function() {
			s.drawElementText(e, t, null, i);
		}, "drawText");
		if (e.lineJoin = "round", "yes" === t.pstyle("ghost").value) {
			var S = t.pstyle("ghost-offset-x").pfValue, A = t.pstyle("ghost-offset-y").pfValue, L = x * t.pstyle("ghost-opacity").value;
			e.translate(S, A), w(L), E(L), e.translate(-S, -A);
		} else k();
		_(), w(), E(), T(), C(), r && e.translate(l.x1, l.y1);
	}
};
var W8 = h(function(e) {
	if (!["overlay", "underlay"].includes(e)) throw Error("Invalid state");
	return function(t, r) {
		if (r.visible()) {
			var i = r.pstyle("".concat(e, "-opacity")).value;
			if (0 !== i) {
				var n = this.usePaths(), a = r._private.rscratch, s = 2 * r.pstyle("".concat(e, "-padding")).pfValue, o = r.pstyle("".concat(e, "-color")).value;
				t.lineWidth = s, "self" !== a.edgeType || n ? t.lineCap = "round" : t.lineCap = "butt", this.colorStrokeStyle(t, o[0], o[1], o[2], i), this.drawEdgePath(r, t, a.allpts, "solid");
			}
		}
	};
}, "drawEdgeOverlayUnderlay");
W7.drawEdgeOverlay = W8("overlay"), W7.drawEdgeUnderlay = W8("underlay"), W7.drawEdgePath = function(e, t, r, i) {
	var n, a = e._private.rscratch, s = t, o = !1, l = this.usePaths(), h = e.pstyle("line-dash-pattern").pfValue, u = e.pstyle("line-dash-offset").pfValue;
	if (l) {
		var d = r.join("$");
		a.pathCacheKey && a.pathCacheKey === d ? (n = t = a.pathCache, o = !0) : (n = t = new Path2D(), a.pathCacheKey = d, a.pathCache = n);
	}
	if (s.setLineDash) switch (i) {
		case "dotted":
			s.setLineDash([1, 1]);
			break;
		case "dashed":
			s.setLineDash(h), s.lineDashOffset = u;
			break;
		case "solid": s.setLineDash([]);
	}
	if (!o && !a.badLine) switch (t.beginPath && t.beginPath(), t.moveTo(r[0], r[1]), a.edgeType) {
		case "bezier":
		case "self":
		case "compound":
		case "multibezier":
			for (var p = 2; p + 3 < r.length; p += 4) t.quadraticCurveTo(r[p], r[p + 1], r[p + 2], r[p + 3]);
			break;
		case "straight":
		case "haystack":
			for (var f = 2; f + 1 < r.length; f += 2) t.lineTo(r[f], r[f + 1]);
			break;
		case "segments": if (a.isRound) {
			var g, m = D_(a.roundCorners);
			try {
				for (m.s(); !(g = m.n()).done;) {
					var y = g.value;
					Wd(t, y);
				}
			} catch (e) {
				m.e(e);
			} finally {
				m.f();
			}
			t.lineTo(r[r.length - 2], r[r.length - 1]);
		} else for (var v = 2; v + 1 < r.length; v += 2) t.lineTo(r[v], r[v + 1]);
	}
	t = s, l ? t.stroke(n) : t.stroke(), t.setLineDash && t.setLineDash([]);
}, W7.drawEdgeTrianglePath = function(e, t, r) {
	t.fillStyle = t.strokeStyle;
	for (var i = e.pstyle("width").pfValue, n = 0; n + 1 < r.length; n += 2) {
		var a = [r[n + 2] - r[n], r[n + 3] - r[n + 1]], s = Math.sqrt(a[0] * a[0] + a[1] * a[1]), o = [a[1] / s, -a[0] / s], l = [o[0] * i / 2, o[1] * i / 2];
		t.beginPath(), t.moveTo(r[n] - l[0], r[n + 1] - l[1]), t.lineTo(r[n] + l[0], r[n + 1] + l[1]), t.lineTo(r[n + 2], r[n + 3]), t.closePath(), t.fill();
	}
}, W7.drawArrowheads = function(e, t, r) {
	var i = t._private.rscratch, n = "haystack" === i.edgeType;
	n || this.drawArrowhead(e, t, "source", i.arrowStartX, i.arrowStartY, i.srcArrowAngle, r), this.drawArrowhead(e, t, "mid-target", i.midX, i.midY, i.midtgtArrowAngle, r), this.drawArrowhead(e, t, "mid-source", i.midX, i.midY, i.midsrcArrowAngle, r), n || this.drawArrowhead(e, t, "target", i.arrowEndX, i.arrowEndY, i.tgtArrowAngle, r);
}, W7.drawArrowhead = function(e, t, r, i, n, a, s) {
	if (!(isNaN(i) || null == i || isNaN(n) || null == n || isNaN(a) || null == a)) {
		var o = t.pstyle(r + "-arrow-shape").value;
		if ("none" !== o) {
			var l = "hollow" === t.pstyle(r + "-arrow-fill").value ? "both" : "filled", h = t.pstyle(r + "-arrow-fill").value, u = t.pstyle("width").pfValue, d = t.pstyle(r + "-arrow-width"), p = "match-line" === d.value ? u : d.pfValue;
			"%" === d.units && (p *= u);
			var f = t.pstyle("opacity").value;
			void 0 === s && (s = f);
			var g = e.globalCompositeOperation;
			(1 !== s || "hollow" === h) && (e.globalCompositeOperation = "destination-out", this.colorFillStyle(e, 255, 255, 255, 1), this.colorStrokeStyle(e, 255, 255, 255, 1), this.drawArrowShape(t, e, l, u, o, p, i, n, a), e.globalCompositeOperation = g);
			var m = t.pstyle(r + "-arrow-color").value;
			this.colorFillStyle(e, m[0], m[1], m[2], s), this.colorStrokeStyle(e, m[0], m[1], m[2], s), this.drawArrowShape(t, e, h, u, o, p, i, n, a);
		}
	}
}, W7.drawArrowShape = function(e, t, r, i, n, a, s, o, l) {
	var h, u = this.usePaths() && "triangle-cross" !== n, d = !1, p = t, f = e.pstyle("arrow-scale").value, g = this.getArrowWidth(i, f), m = this.arrowShapes[n];
	if (u) {
		var y = this.arrowPathCache = this.arrowPathCache || [], v = OH(n), x = y[v];
		null != x ? (h = t = x, d = !0) : (h = t = new Path2D(), y[v] = h);
	}
	d || (t.beginPath && t.beginPath(), u ? m.draw(t, 1, 0, {
		x: 0,
		y: 0
	}, 1) : m.draw(t, g, l, {
		x: s,
		y: o
	}, i), t.closePath && t.closePath()), t = p, u && (t.translate(s, o), t.rotate(l), t.scale(g, g)), ("filled" === r || "both" === r) && (u ? t.fill(h) : t.fill()), ("hollow" === r || "both" === r) && (t.lineWidth = a / (u ? g : 1), t.lineJoin = "miter", u ? t.stroke(h) : t.stroke()), u && (t.scale(1 / g, 1 / g), t.rotate(-l), t.translate(-s, -o));
};
var W9 = {};
W9.safeDrawImage = function(e, t, r, i, n, a, s, o, l, h) {
	if (!(n <= 0 || a <= 0 || l <= 0 || h <= 0)) try {
		e.drawImage(t, r, i, n, a, s, o, l, h);
	} catch (e) {
		$e(e);
	}
}, W9.drawInscribedImage = function(e, t, r, i, n) {
	var a = r.position(), s = a.x, o = a.y, l = r.cy().style(), h = l.getIndexedStyle.bind(l), u = h(r, "background-fit", "value", i), d = h(r, "background-repeat", "value", i), p = r.width(), f = r.height(), g = 2 * r.padding(), m = p + ("inner" === h(r, "background-width-relative-to", "value", i) ? 0 : g), y = f + ("inner" === h(r, "background-height-relative-to", "value", i) ? 0 : g), v = r._private.rscratch, x = "node" === h(r, "background-clip", "value", i), b = h(r, "background-image-opacity", "value", i) * n, w = h(r, "background-image-smoothing", "value", i), k = r.pstyle("corner-radius").value;
	"auto" !== k && (k = r.pstyle("corner-radius").pfValue);
	var T = t.width || t.cachedW, _ = t.height || t.cachedH;
	(null == T || null == _) && (document.body.appendChild(t), T = t.cachedW = t.width || t.offsetWidth, _ = t.cachedH = t.height || t.offsetHeight, document.body.removeChild(t));
	var E = T, C = _;
	if ("auto" !== h(r, "background-width", "value", i) && (E = "%" === h(r, "background-width", "units", i) ? h(r, "background-width", "pfValue", i) * m : h(r, "background-width", "pfValue", i)), "auto" !== h(r, "background-height", "value", i) && (C = "%" === h(r, "background-height", "units", i) ? h(r, "background-height", "pfValue", i) * y : h(r, "background-height", "pfValue", i)), 0 !== E && 0 !== C) {
		if ("contain" === u) {
			var S = Math.min(m / E, y / C);
			E *= S, C *= S;
		} else if ("cover" === u) {
			var S = Math.max(m / E, y / C);
			E *= S, C *= S;
		}
		var A = s - m / 2, L = h(r, "background-position-x", "units", i), R = h(r, "background-position-x", "pfValue", i);
		"%" === L ? A += (m - E) * R : A += R;
		var N = h(r, "background-offset-x", "units", i), I = h(r, "background-offset-x", "pfValue", i);
		"%" === N ? A += (m - E) * I : A += I;
		var M = o - y / 2, D = h(r, "background-position-y", "units", i), O = h(r, "background-position-y", "pfValue", i);
		"%" === D ? M += (y - C) * O : M += O;
		var $ = h(r, "background-offset-y", "units", i), P = h(r, "background-offset-y", "pfValue", i);
		"%" === $ ? M += (y - C) * P : M += P, v.pathCache && (A -= s, M -= o, s = 0, o = 0);
		var B = e.globalAlpha;
		e.globalAlpha = b;
		var F = this.getImgSmoothing(e), z = !1;
		("no" === w && F ? (this.setImgSmoothing(e, !1), z = !0) : "yes" !== w || F || (this.setImgSmoothing(e, !0), z = !0), "no-repeat" === d) ? (x && (e.save(), v.pathCache ? e.clip(v.pathCache) : (this.nodeShapes[this.getNodeShape(r)].draw(e, s, o, m, y, k, v), e.clip())), this.safeDrawImage(e, t, 0, 0, T, _, A, M, E, C), x && e.restore()) : (e.fillStyle = e.createPattern(t, d), this.nodeShapes[this.getNodeShape(r)].draw(e, s, o, m, y, k, v), e.translate(A, M), e.fill(), e.translate(-A, -M)), e.globalAlpha = B, z && this.setImgSmoothing(e, F);
	}
};
var Ye = {};
function Yt(e, t, r, i, n) {
	var a = Math.min(i, n) / 2;
	e.beginPath(), e.arc(t + i / 2, r + n / 2, a, 0, 2 * Math.PI), e.closePath();
}
function Yr(e, t, r, i, n) {
	var a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 5, s = Math.min(a, i / 2, n / 2);
	e.beginPath(), e.moveTo(t + s, r), e.lineTo(t + i - s, r), e.quadraticCurveTo(t + i, r, t + i, r + s), e.lineTo(t + i, r + n - s), e.quadraticCurveTo(t + i, r + n, t + i - s, r + n), e.lineTo(t + s, r + n), e.quadraticCurveTo(t, r + n, t, r + n - s), e.lineTo(t, r + s), e.quadraticCurveTo(t, r, t + s, r), e.closePath();
}
Ye.eleTextBiggerThanMin = function(e, t) {
	return t || (t = Math.pow(2, Math.ceil(Pm(e.cy().zoom() * this.getPixelRatio())))), !(e.pstyle("font-size").pfValue * t < e.pstyle("min-zoomed-font-size").pfValue);
}, Ye.drawElementText = function(e, t, r, i, n) {
	var a = !(arguments.length > 5) || void 0 === arguments[5] || arguments[5];
	if (null == i) {
		if (a && !this.eleTextBiggerThanMin(t)) return;
	} else if (!1 === i) return;
	if (t.isNode()) {
		var s = t.pstyle("label");
		if (!s || !s.value) return;
		e.textAlign = this.getLabelJustification(t), e.textBaseline = "bottom";
	} else {
		var o = t.element()._private.rscratch.badLine, l = t.pstyle("label"), h = t.pstyle("source-label"), u = t.pstyle("target-label");
		if (o || (!l || !l.value) && (!h || !h.value) && (!u || !u.value)) return;
		e.textAlign = "center", e.textBaseline = "bottom";
	}
	var d, p = !r;
	r && (d = r, e.translate(-d.x1, -d.y1)), null == n ? (this.drawText(e, t, null, p, a), t.isEdge() && (this.drawText(e, t, "source", p, a), this.drawText(e, t, "target", p, a))) : this.drawText(e, t, n, p, a), r && e.translate(d.x1, d.y1);
}, Ye.getFontCache = function(e) {
	var t;
	this.fontCaches = this.fontCaches || [];
	for (var r = 0; r < this.fontCaches.length; r++) if ((t = this.fontCaches[r]).context === e) return t;
	return t = { context: e }, this.fontCaches.push(t), t;
}, Ye.setupTextStyle = function(e, t) {
	var r = !(arguments.length > 2) || void 0 === arguments[2] || arguments[2], i = t.pstyle("font-style").strValue, n = t.pstyle("font-size").pfValue + "px", a = t.pstyle("font-family").strValue, s = t.pstyle("font-weight").strValue, o = r ? t.effectiveOpacity() * t.pstyle("text-opacity").value : 1, l = t.pstyle("text-outline-opacity").value * o, h = t.pstyle("color").value, u = t.pstyle("text-outline-color").value;
	e.font = i + " " + s + " " + n + " " + a, e.lineJoin = "round", this.colorFillStyle(e, h[0], h[1], h[2], o), this.colorStrokeStyle(e, u[0], u[1], u[2], l);
}, h(Yt, "circle"), h(Yr, "roundRect"), Ye.getTextAngle = function(e, t) {
	var r, i = e._private.rscratch, n = t ? t + "-" : "", a = e.pstyle(n + "text-rotation");
	if ("autorotate" === a.strValue) {
		var s = $u(i, "labelAngle", t);
		r = e.isEdge() ? s : 0;
	} else r = "none" === a.strValue ? 0 : a.pfValue;
	return r;
}, Ye.drawText = function(e, t, r) {
	var i = !(arguments.length > 3) || void 0 === arguments[3] || arguments[3], n = !(arguments.length > 4) || void 0 === arguments[4] || arguments[4], a = t._private.rscratch, s = n ? t.effectiveOpacity() : 1;
	if (!(n && (0 === s || 0 === t.pstyle("text-opacity").value))) {
		"main" === r && (r = null);
		var o, l, h = $u(a, "labelX", r), u = $u(a, "labelY", r), d = this.getLabelText(t, r);
		if (null != d && "" !== d && !isNaN(h) && !isNaN(u)) {
			this.setupTextStyle(e, t, n);
			var p, f = r ? r + "-" : "", g = $u(a, "labelWidth", r), m = $u(a, "labelHeight", r), y = t.pstyle(f + "text-margin-x").pfValue, v = t.pstyle(f + "text-margin-y").pfValue, x = t.isEdge(), b = t.pstyle("text-halign").value, w = t.pstyle("text-valign").value;
			switch (x && (b = "center", w = "center"), h += y, u += v, 0 !== (p = i ? this.getTextAngle(t, r) : 0) && (o = h, l = u, e.translate(o, l), e.rotate(p), h = 0, u = 0), w) {
				case "top": break;
				case "center":
					u += m / 2;
					break;
				case "bottom": u += m;
			}
			var k = t.pstyle("text-background-opacity").value, T = t.pstyle("text-border-opacity").value, _ = t.pstyle("text-border-width").pfValue, E = t.pstyle("text-background-padding").pfValue, C = t.pstyle("text-background-shape").strValue, S = "round-rectangle" === C || "roundrectangle" === C;
			if (k > 0 || _ > 0 && T > 0) {
				var A = e.fillStyle, L = e.strokeStyle, R = e.lineWidth, N = t.pstyle("text-background-color").value, I = t.pstyle("text-border-color").value, M = t.pstyle("text-border-style").value, D = k > 0, O = _ > 0 && T > 0, $ = h - E;
				switch (b) {
					case "left":
						$ -= g;
						break;
					case "center": $ -= g / 2;
				}
				var P = u - m - E, B = g + 2 * E, F = m + 2 * E;
				if (D && (e.fillStyle = "rgba(".concat(N[0], ",").concat(N[1], ",").concat(N[2], ",").concat(k * s, ")")), O && (e.strokeStyle = "rgba(".concat(I[0], ",").concat(I[1], ",").concat(I[2], ",").concat(T * s, ")"), e.lineWidth = _, e.setLineDash)) switch (M) {
					case "dotted":
						e.setLineDash([1, 1]);
						break;
					case "dashed":
						e.setLineDash([4, 2]);
						break;
					case "double":
						e.lineWidth = _ / 4, e.setLineDash([]);
						break;
					default: e.setLineDash([]);
				}
				if (S ? (e.beginPath(), Yr(e, $, P, B, F, 2)) : "circle" === C ? (e.beginPath(), Yt(e, $, P, B, F)) : (e.beginPath(), e.rect($, P, B, F)), D && e.fill(), O && e.stroke(), O && "double" === M) {
					var z = _ / 2;
					e.beginPath(), S ? Yr(e, $ + z, P + z, B - 2 * z, F - 2 * z, 2) : e.rect($ + z, P + z, B - 2 * z, F - 2 * z), e.stroke();
				}
				e.fillStyle = A, e.strokeStyle = L, e.lineWidth = R, e.setLineDash && e.setLineDash([]);
			}
			var U = 2 * t.pstyle("text-outline-width").pfValue;
			if (U > 0 && (e.lineWidth = U), "wrap" === t.pstyle("text-wrap").value) {
				var G = $u(a, "labelWrapCachedLines", r), q = $u(a, "labelLineHeight", r), j = g / 2, W = this.getLabelJustification(t);
				switch ("auto" === W || ("left" === b ? "left" === W ? h += -g : "center" === W && (h += -j) : "center" === b ? "left" === W ? h += -j : "right" === W && (h += j) : "right" === b && ("center" === W ? h += j : "right" === W && (h += g))), w) {
					case "top":
					case "center":
					case "bottom": u -= (G.length - 1) * q;
				}
				for (var Y = 0; Y < G.length; Y++) U > 0 && e.strokeText(G[Y], h, u), e.fillText(G[Y], h, u), u += q;
			} else U > 0 && e.strokeText(d, h, u), e.fillText(d, h, u);
			0 !== p && (e.rotate(-p), e.translate(-o, -l));
		}
	}
};
var Yi = {};
Yi.drawNode = function(e, t, r) {
	var i, n, a = !(arguments.length > 3) || void 0 === arguments[3] || arguments[3], s = !(arguments.length > 4) || void 0 === arguments[4] || arguments[4], o = !(arguments.length > 5) || void 0 === arguments[5] || arguments[5], l = this, u = t._private, d = u.rscratch, p = t.position();
	if (!(!DH(p.x) || !DH(p.y)) && !(o && !t.visible())) {
		var f, g, m = o ? t.effectiveOpacity() : 1, y = l.usePaths(), v = !1, x = t.padding();
		i = t.width() + 2 * x, n = t.height() + 2 * x, r && (f = r, e.translate(-f.x1, -f.y1));
		for (var b = t.pstyle("background-image").value, w = Array(b.length), k = Array(b.length), T = 0, _ = 0; _ < b.length; _++) {
			var E = b[_];
			if (w[_] = null != E && "none" !== E) {
				var C = t.cy().style().getIndexedStyle(t, "background-image-crossorigin", "value", _);
				T++, k[_] = l.getCachedImage(E, C, function() {
					u.backgroundTimestamp = Date.now(), t.emitAndNotify("background");
				});
			}
		}
		var S = t.pstyle("background-blacken").value, A = t.pstyle("border-width").pfValue, L = t.pstyle("background-opacity").value * m, R = t.pstyle("border-color").value, N = t.pstyle("border-style").value, I = t.pstyle("border-join").value, M = t.pstyle("border-cap").value, D = t.pstyle("border-position").value, O = t.pstyle("border-dash-pattern").pfValue, $ = t.pstyle("border-dash-offset").pfValue, P = t.pstyle("border-opacity").value * m, B = t.pstyle("outline-width").pfValue, F = t.pstyle("outline-color").value, z = t.pstyle("outline-style").value, U = t.pstyle("outline-opacity").value * m, G = t.pstyle("outline-offset").value, q = t.pstyle("corner-radius").value;
		"auto" !== q && (q = t.pstyle("corner-radius").pfValue);
		var j = h(function() {
			var r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : L;
			l.eleFillStyle(e, t, r);
		}, "setupShapeColor"), W = h(function() {
			var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : P;
			l.colorStrokeStyle(e, R[0], R[1], R[2], t);
		}, "setupBorderColor"), Y = h(function() {
			var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : U;
			l.colorStrokeStyle(e, F[0], F[1], F[2], t);
		}, "setupOutlineColor"), V = h(function(e, t, r, i) {
			var n, a = l.nodePathCache = l.nodePathCache || [], s = OX("polygon" === r ? r + "," + i.join(",") : r, "" + t, "" + e, "" + q), o = a[s], h = !1;
			return null != o ? (h = !0, d.pathCache = n = o) : (n = new Path2D(), a[s] = d.pathCache = n), {
				path: n,
				cacheHit: h
			};
		}, "getPath"), H = t.pstyle("shape").strValue, X = t.pstyle("shape-polygon-points").pfValue;
		if (y) {
			e.translate(p.x, p.y);
			var K = V(i, n, H, X);
			g = K.path, v = K.cacheHit;
		}
		var Z = h(function() {
			if (!v) {
				var r = p;
				y && (r = {
					x: 0,
					y: 0
				}), l.nodeShapes[l.getNodeShape(t)].draw(g || e, r.x, r.y, i, n, q, d);
			}
			y ? e.fill(g) : e.fill();
		}, "drawShape"), Q = h(function() {
			for (var r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : m, i = !(arguments.length > 1) || void 0 === arguments[1] || arguments[1], n = u.backgrounding, a = 0, s = 0; s < k.length; s++) {
				var o = t.cy().style().getIndexedStyle(t, "background-image-containment", "value", s);
				if (i && "over" === o || !i && "inside" === o) {
					a++;
					continue;
				}
				w[s] && k[s].complete && !k[s].error && (a++, l.drawInscribedImage(e, k[s], t, s, r));
			}
			u.backgrounding = a !== T, n !== u.backgrounding && t.updateStyle(!1);
		}, "drawImages"), J = h(function() {
			var r = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : m;
			l.hasPie(t) && (l.drawPie(e, t, a), r && (y || l.nodeShapes[l.getNodeShape(t)].draw(e, p.x, p.y, i, n, q, d)));
		}, "drawPie"), ee = h(function() {
			var r = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : m;
			l.hasStripe(t) && (e.save(), y ? e.clip(d.pathCache) : (l.nodeShapes[l.getNodeShape(t)].draw(e, p.x, p.y, i, n, q, d), e.clip()), l.drawStripe(e, t, a), e.restore(), r && (y || l.nodeShapes[l.getNodeShape(t)].draw(e, p.x, p.y, i, n, q, d)));
		}, "drawStripe"), et = h(function() {
			var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : m, r = S > 0 ? 0 : 255;
			0 !== S && (l.colorFillStyle(e, r, r, r, (S > 0 ? S : -S) * t), y ? e.fill(g) : e.fill());
		}, "darken"), er = h(function() {
			if (A > 0) {
				if (e.lineWidth = A, e.lineCap = M, e.lineJoin = I, e.setLineDash) switch (N) {
					case "dotted":
						e.setLineDash([1, 1]);
						break;
					case "dashed":
						e.setLineDash(O), e.lineDashOffset = $;
						break;
					case "solid":
					case "double": e.setLineDash([]);
				}
				if ("center" !== D) {
					if (e.save(), e.lineWidth *= 2, "inside" === D) y ? e.clip(g) : e.clip();
					else {
						var t = new Path2D();
						t.rect(-i / 2 - A, -n / 2 - A, i + 2 * A, n + 2 * A), t.addPath(g), e.clip(t, "evenodd");
					}
					y ? e.stroke(g) : e.stroke(), e.restore();
				} else y ? e.stroke(g) : e.stroke();
				if ("double" === N) {
					e.lineWidth = A / 3;
					var r = e.globalCompositeOperation;
					e.globalCompositeOperation = "destination-out", y ? e.stroke(g) : e.stroke(), e.globalCompositeOperation = r;
				}
				e.setLineDash && e.setLineDash([]);
			}
		}, "drawBorder"), ei = h(function() {
			if (B > 0) {
				if (e.lineWidth = B, e.lineCap = "butt", e.setLineDash) switch (z) {
					case "dotted":
						e.setLineDash([1, 1]);
						break;
					case "dashed":
						e.setLineDash([4, 2]);
						break;
					case "solid":
					case "double": e.setLineDash([]);
				}
				var r = p;
				y && (r = {
					x: 0,
					y: 0
				});
				var a = l.getNodeShape(t), s = A;
				"inside" === D && (s = 0), "outside" === D && (s *= 2);
				var o, h = (i + s + (B + G)) / i, u = (n + s + (B + G)) / n, d = i * h, f = n * u, g = l.nodeShapes[a].points;
				if (y && (o = V(d, f, a, g).path), "ellipse" === a) l.drawEllipsePath(o || e, r.x, r.y, d, f);
				else if ([
					"round-diamond",
					"round-heptagon",
					"round-hexagon",
					"round-octagon",
					"round-pentagon",
					"round-polygon",
					"round-triangle",
					"round-tag"
				].includes(a)) {
					var m = 0, v = 0, x = 0;
					"round-diamond" === a ? m = (s + G + B) * 1.4 : "round-heptagon" === a ? (m = (s + G + B) * 1.075, x = -(s / 2 + G + B) / 35) : "round-hexagon" === a ? m = (s + G + B) * 1.12 : "round-pentagon" === a ? (m = (s + G + B) * 1.13, x = -(s / 2 + G + B) / 15) : "round-tag" === a ? (m = (s + G + B) * 1.12, v = (s / 2 + B + G) * .07) : "round-triangle" === a && (m = Math.PI / 2 * (s + G + B), x = -(s + G / 2 + B) / Math.PI), 0 !== m && (h = (i + m) / i, d = i * h, ["round-hexagon", "round-tag"].includes(a) || (u = (n + m) / n, f = n * u)), q = "auto" === q ? Bt(d, f) : q;
					for (var b = d / 2, w = f / 2, k = q + (s + B + G) / 2, T = Array(g.length / 2), _ = Array(g.length / 2), E = 0; E < g.length / 2; E++) T[E] = {
						x: r.x + v + b * g[2 * E],
						y: r.y + x + w * g[2 * E + 1]
					};
					var C, S, L, R, N = T.length;
					for (S = T[N - 1], C = 0; C < N; C++) L = T[C % N], R = T[(C + 1) % N], _[C] = Wp(S, L, R, k), S = L, L = R;
					l.drawRoundPolygonPath(o || e, r.x + v, r.y + x, i * h, n * u, g, _);
				} else ["roundrectangle", "round-rectangle"].includes(a) ? (q = "auto" === q ? Be(d, f) : q, l.drawRoundRectanglePath(o || e, r.x, r.y, d, f, q + (s + B + G) / 2)) : ["cutrectangle", "cut-rectangle"].includes(a) ? (q = "auto" === q ? Br() : q, l.drawCutRectanglePath(o || e, r.x, r.y, d, f, null, q + (s + B + G) / 4)) : ["bottomroundrectangle", "bottom-round-rectangle"].includes(a) ? (q = "auto" === q ? Be(d, f) : q, l.drawBottomRoundRectanglePath(o || e, r.x, r.y, d, f, q + (s + B + G) / 2)) : "barrel" === a ? l.drawBarrelPath(o || e, r.x, r.y, d, f) : (g = a.startsWith("polygon") || [
					"rhomboid",
					"right-rhomboid",
					"round-tag",
					"tag",
					"vee"
				].includes(a) ? PK(PZ(g, (s + B + G) / i)) : PK(PZ(g, -((s + B + G) / i))), l.drawPolygonPath(o || e, r.x, r.y, i, n, g));
				if (y ? e.stroke(o) : e.stroke(), "double" === z) {
					e.lineWidth = s / 3;
					var I = e.globalCompositeOperation;
					e.globalCompositeOperation = "destination-out", y ? e.stroke(o) : e.stroke(), e.globalCompositeOperation = I;
				}
				e.setLineDash && e.setLineDash([]);
			}
		}, "drawOutline"), en = h(function() {
			s && l.drawNodeOverlay(e, t, p, i, n);
		}, "drawOverlay"), ea = h(function() {
			s && l.drawNodeUnderlay(e, t, p, i, n);
		}, "drawUnderlay"), es = h(function() {
			l.drawElementText(e, t, null, a);
		}, "drawText");
		if ("yes" === t.pstyle("ghost").value) {
			var eo = t.pstyle("ghost-offset-x").pfValue, el = t.pstyle("ghost-offset-y").pfValue, ec = t.pstyle("ghost-opacity").value, eh = ec * m;
			e.translate(eo, el), Y(), ei(), j(ec * L), Z(), Q(eh, !0), W(ec * P), er(), J(0 !== S || 0 !== A), ee(0 !== S || 0 !== A), Q(eh, !1), et(eh), e.translate(-eo, -el);
		}
		y && e.translate(-p.x, -p.y), ea(), y && e.translate(p.x, p.y), Y(), ei(), j(), Z(), Q(m, !0), W(), er(), J(0 !== S || 0 !== A), ee(0 !== S || 0 !== A), Q(m, !1), et(), y && e.translate(-p.x, -p.y), es(), en(), r && e.translate(f.x1, f.y1);
	}
};
var Yn = h(function(e) {
	if (!["overlay", "underlay"].includes(e)) throw Error("Invalid state");
	return function(t, r, i, n, a) {
		if (r.visible()) {
			var s = r.pstyle("".concat(e, "-padding")).pfValue, o = r.pstyle("".concat(e, "-opacity")).value, l = r.pstyle("".concat(e, "-color")).value, h = r.pstyle("".concat(e, "-shape")).value, u = r.pstyle("".concat(e, "-corner-radius")).value;
			if (o > 0) {
				if (i = i || r.position(), null == n || null == a) {
					var d = r.padding();
					n = r.width() + 2 * d, a = r.height() + 2 * d;
				}
				this.colorFillStyle(t, l[0], l[1], l[2], o), this.nodeShapes[h].draw(t, i.x, i.y, n + 2 * s, a + 2 * s, u), t.fill();
			}
		}
	};
}, "drawNodeOverlayUnderlay");
Yi.drawNodeOverlay = Yn("overlay"), Yi.drawNodeUnderlay = Yn("underlay"), Yi.hasPie = function(e) {
	return (e = e[0])._private.hasPie;
}, Yi.hasStripe = function(e) {
	return (e = e[0])._private.hasStripe;
}, Yi.drawPie = function(e, t, r, i) {
	t = t[0], i = i || t.position();
	var n, a = t.cy().style(), s = t.pstyle("pie-size"), o = t.pstyle("pie-hole"), l = t.pstyle("pie-start-angle").pfValue, h = i.x, u = i.y, d = Math.min(t.width(), t.height()) / 2, p = 0;
	if (this.usePaths() && (h = 0, u = 0), "%" === s.units ? d *= s.pfValue : void 0 !== s.pfValue && (d = s.pfValue / 2), "%" === o.units ? n = d * o.pfValue : void 0 !== o.pfValue && (n = o.pfValue / 2), !(n >= d)) for (var f = 1; f <= a.pieBackgroundN; f++) {
		var g = t.pstyle("pie-" + f + "-background-size").value, m = t.pstyle("pie-" + f + "-background-color").value, y = t.pstyle("pie-" + f + "-background-opacity").value * r, v = g / 100;
		v + p > 1 && (v = 1 - p);
		var x = 1.5 * Math.PI + 2 * Math.PI * p, b = 2 * Math.PI * v, w = (x += l) + b;
		0 === g || p >= 1 || p + v > 1 || (0 === n ? (e.beginPath(), e.moveTo(h, u), e.arc(h, u, d, x, w)) : (e.beginPath(), e.arc(h, u, d, x, w), e.arc(h, u, n, w, x, !0)), e.closePath(), this.colorFillStyle(e, m[0], m[1], m[2], y), e.fill(), p += v);
	}
}, Yi.drawStripe = function(e, t, r, i) {
	t = t[0], i = i || t.position();
	var n = t.cy().style(), a = i.x, s = i.y, o = t.width(), l = t.height(), h = 0, u = this.usePaths();
	e.save();
	var d = t.pstyle("stripe-direction").value, p = t.pstyle("stripe-size");
	switch (d) {
		case "vertical": break;
		case "righward": e.rotate(-Math.PI / 2);
	}
	var f = o, g = l;
	"%" === p.units ? (f *= p.pfValue, g *= p.pfValue) : void 0 !== p.pfValue && (f = p.pfValue, g = p.pfValue), u && (a = 0, s = 0), s -= f / 2, a -= g / 2;
	for (var m = 1; m <= n.stripeBackgroundN; m++) {
		var y = t.pstyle("stripe-" + m + "-background-size").value, v = t.pstyle("stripe-" + m + "-background-color").value, x = t.pstyle("stripe-" + m + "-background-opacity").value * r, b = y / 100;
		b + h > 1 && (b = 1 - h), 0 === y || h >= 1 || h + b > 1 || (e.beginPath(), e.rect(a, s + g * h, f, g * b), e.closePath(), this.colorFillStyle(e, v[0], v[1], v[2], x), e.fill(), h += b);
	}
	e.restore();
};
var Ya = {};
function Ys(e, t, r) {
	var i = e.createShader(t);
	if (e.shaderSource(i, r), e.compileShader(i), !e.getShaderParameter(i, e.COMPILE_STATUS)) throw Error(e.getShaderInfoLog(i));
	return i;
}
function Yo(e, t, r) {
	var i = Ys(e, e.VERTEX_SHADER, t), n = Ys(e, e.FRAGMENT_SHADER, r), a = e.createProgram();
	if (e.attachShader(a, i), e.attachShader(a, n), e.linkProgram(a), !e.getProgramParameter(a, e.LINK_STATUS)) throw Error("Could not initialize shaders");
	return a;
}
function Yl(e, t, r) {
	void 0 === r && (r = t);
	var i = e.makeOffscreenCanvas(t, r), n = i.context = i.getContext("2d");
	return i.clear = function() {
		return n.clearRect(0, 0, i.width, i.height);
	}, i.clear(), i;
}
function Yc(e) {
	var t = e.pixelRatio, r = e.cy.zoom(), i = e.cy.pan();
	return {
		zoom: r * t,
		pan: {
			x: i.x * t,
			y: i.y * t
		}
	};
}
function Yh(e) {
	var t = e.pixelRatio;
	return e.cy.zoom() * t;
}
function Yu(e, t, r, i, n) {
	var a = i * r + t.x, s = n * r + t.y;
	return [a, s = Math.round(e.canvasHeight - s)];
}
function Yd(e) {
	return "solid" === e.pstyle("background-fill").value && "none" === e.pstyle("background-image").strValue && (0 === e.pstyle("border-width").value || 0 === e.pstyle("border-opacity").value || "solid" === e.pstyle("border-style").value);
}
function Yp(e, t) {
	if (e.length !== t.length) return !1;
	for (var r = 0; r < e.length; r++) if (e[r] !== t[r]) return !1;
	return !0;
}
function Yf(e, t, r) {
	var i = e[0] / 255, n = e[1] / 255, a = e[2] / 255, s = r || [
		,
		,
		,
		,
	];
	return s[0] = i * t, s[1] = n * t, s[2] = a * t, s[3] = t, s;
}
function Yg(e, t) {
	var r = t || [
		,
		,
		,
		,
	];
	return r[0] = (255 & e) / 255, r[1] = (e >> 8 & 255) / 255, r[2] = (e >> 16 & 255) / 255, r[3] = (e >> 24 & 255) / 255, r;
}
function Ym(e) {
	return e[0] + (e[1] << 8) + (e[2] << 16) + (e[3] << 24);
}
function Yy(e, t) {
	var r = e.createTexture();
	return r.buffer = function(t) {
		e.bindTexture(e.TEXTURE_2D, r), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR_MIPMAP_NEAREST), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t), e.generateMipmap(e.TEXTURE_2D), e.bindTexture(e.TEXTURE_2D, null);
	}, r.deleteTexture = function() {
		e.deleteTexture(r);
	}, r;
}
function Yv(e, t) {
	switch (t) {
		case "float": return [
			1,
			e.FLOAT,
			4
		];
		case "vec2": return [
			2,
			e.FLOAT,
			4
		];
		case "vec3": return [
			3,
			e.FLOAT,
			4
		];
		case "vec4": return [
			4,
			e.FLOAT,
			4
		];
		case "int": return [
			1,
			e.INT,
			4
		];
		case "ivec2": return [
			2,
			e.INT,
			4
		];
	}
}
function Yx(e, t, r) {
	switch (t) {
		case e.FLOAT: return new Float32Array(r);
		case e.INT: return new Int32Array(r);
	}
}
function Yb(e, t, r, i, n, a) {
	switch (t) {
		case e.FLOAT: return new Float32Array(r.buffer, a * i, n);
		case e.INT: return new Int32Array(r.buffer, a * i, n);
	}
}
function Yw(e, t, r, i) {
	var n = DR(Yv(e, t), 2), a = n[0], s = n[1], o = Yx(e, s, i), l = e.createBuffer();
	return e.bindBuffer(e.ARRAY_BUFFER, l), e.bufferData(e.ARRAY_BUFFER, o, e.STATIC_DRAW), s === e.FLOAT ? e.vertexAttribPointer(r, a, s, !1, 0, 0) : s === e.INT && e.vertexAttribIPointer(r, a, s, 0, 0), e.enableVertexAttribArray(r), e.bindBuffer(e.ARRAY_BUFFER, null), l;
}
function Yk(e, t, r, i) {
	var n = DR(Yv(e, r), 3), a = n[0], s = n[1], o = n[2], l = Yx(e, s, t * a), h = a * o, u = e.createBuffer();
	e.bindBuffer(e.ARRAY_BUFFER, u), e.bufferData(e.ARRAY_BUFFER, t * h, e.DYNAMIC_DRAW), e.enableVertexAttribArray(i), s === e.FLOAT ? e.vertexAttribPointer(i, a, s, !1, h, 0) : s === e.INT && e.vertexAttribIPointer(i, a, s, h, 0), e.vertexAttribDivisor(i, 1), e.bindBuffer(e.ARRAY_BUFFER, null);
	for (var d = Array(t), p = 0; p < t; p++) d[p] = Yb(e, s, l, h, a, p);
	return u.dataArray = l, u.stride = h, u.size = a, u.getView = function(e) {
		return d[e];
	}, u.setPoint = function(e, t, r) {
		var i = d[e];
		i[0] = t, i[1] = r;
	}, u.bufferSubData = function(t) {
		e.bindBuffer(e.ARRAY_BUFFER, u), t ? e.bufferSubData(e.ARRAY_BUFFER, 0, l, 0, t * a) : e.bufferSubData(e.ARRAY_BUFFER, 0, l);
	}, u;
}
function YT(e, t, r) {
	for (var i = new Float32Array(9 * t), n = Array(t), a = 0; a < t; a++) {
		var s = 9 * a * 4;
		n[a] = new Float32Array(i.buffer, s, 9);
	}
	var o = e.createBuffer();
	e.bindBuffer(e.ARRAY_BUFFER, o), e.bufferData(e.ARRAY_BUFFER, i.byteLength, e.DYNAMIC_DRAW);
	for (var l = 0; l < 3; l++) {
		var h = r + l;
		e.enableVertexAttribArray(h), e.vertexAttribPointer(h, 3, e.FLOAT, !1, 36, 12 * l), e.vertexAttribDivisor(h, 1);
	}
	return e.bindBuffer(e.ARRAY_BUFFER, null), o.getMatrixView = function(e) {
		return n[e];
	}, o.setData = function(e, t) {
		n[t].set(e, 0);
	}, o.bufferSubData = function() {
		e.bindBuffer(e.ARRAY_BUFFER, o), e.bufferSubData(e.ARRAY_BUFFER, 0, i);
	}, o;
}
function Y_(e) {
	var t = e.createFramebuffer();
	e.bindFramebuffer(e.FRAMEBUFFER, t);
	var r = e.createTexture();
	return e.bindTexture(e.TEXTURE_2D, r), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, r, 0), e.bindFramebuffer(e.FRAMEBUFFER, null), t.setFramebufferAttachmentSizes = function(t, i) {
		e.bindTexture(e.TEXTURE_2D, r), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, t, i, 0, e.RGBA, e.UNSIGNED_BYTE, null);
	}, t;
}
Ya.getPixelRatio = function() {
	var e = this.data.contexts[0];
	if (null != this.forcedPixelRatio) return this.forcedPixelRatio;
	var t = this.cy.window(), r = e.backingStorePixelRatio || e.webkitBackingStorePixelRatio || e.mozBackingStorePixelRatio || e.msBackingStorePixelRatio || e.oBackingStorePixelRatio || e.backingStorePixelRatio || 1;
	return (t.devicePixelRatio || 1) / r;
}, Ya.paintCache = function(e) {
	for (var t, r = this.paintCaches = this.paintCaches || [], i = !0, n = 0; n < r.length; n++) if ((t = r[n]).context === e) {
		i = !1;
		break;
	}
	return i && (t = { context: e }, r.push(t)), t;
}, Ya.createGradientStyleFor = function(e, t, r, i, n) {
	var a, s = this.usePaths(), o = r.pstyle(t + "-gradient-stop-colors").value, l = r.pstyle(t + "-gradient-stop-positions").pfValue;
	if ("radial-gradient" === i) if (r.isEdge()) {
		var h = r.sourceEndpoint(), u = r.targetEndpoint(), d = r.midpoint(), p = Pv(h, d), f = Pv(u, d);
		a = e.createRadialGradient(d.x, d.y, 0, d.x, d.y, Math.max(p, f));
	} else {
		var g = s ? {
			x: 0,
			y: 0
		} : r.position(), m = r.paddedWidth(), y = r.paddedHeight();
		a = e.createRadialGradient(g.x, g.y, 0, g.x, g.y, Math.max(m, y));
	}
	else if (r.isEdge()) {
		var v = r.sourceEndpoint(), x = r.targetEndpoint();
		a = e.createLinearGradient(v.x, v.y, x.x, x.y);
	} else {
		var b = s ? {
			x: 0,
			y: 0
		} : r.position(), w = r.paddedWidth(), k = r.paddedHeight(), T = w / 2, _ = k / 2;
		switch (r.pstyle("background-gradient-direction").value) {
			case "to-bottom":
				a = e.createLinearGradient(b.x, b.y - _, b.x, b.y + _);
				break;
			case "to-top":
				a = e.createLinearGradient(b.x, b.y + _, b.x, b.y - _);
				break;
			case "to-left":
				a = e.createLinearGradient(b.x + T, b.y, b.x - T, b.y);
				break;
			case "to-right":
				a = e.createLinearGradient(b.x - T, b.y, b.x + T, b.y);
				break;
			case "to-bottom-right":
			case "to-right-bottom":
				a = e.createLinearGradient(b.x - T, b.y - _, b.x + T, b.y + _);
				break;
			case "to-top-right":
			case "to-right-top":
				a = e.createLinearGradient(b.x - T, b.y + _, b.x + T, b.y - _);
				break;
			case "to-bottom-left":
			case "to-left-bottom":
				a = e.createLinearGradient(b.x + T, b.y - _, b.x - T, b.y + _);
				break;
			case "to-top-left":
			case "to-left-top": a = e.createLinearGradient(b.x + T, b.y + _, b.x - T, b.y - _);
		}
	}
	if (!a) return null;
	for (var E = l.length === o.length, C = o.length, S = 0; S < C; S++) a.addColorStop(E ? l[S] : S / (C - 1), "rgba(" + o[S][0] + "," + o[S][1] + "," + o[S][2] + "," + n + ")");
	return a;
}, Ya.gradientFillStyle = function(e, t, r, i) {
	var n = this.createGradientStyleFor(e, "background", t, r, i);
	if (!n) return null;
	e.fillStyle = n;
}, Ya.colorFillStyle = function(e, t, r, i, n) {
	e.fillStyle = "rgba(" + t + "," + r + "," + i + "," + n + ")";
}, Ya.eleFillStyle = function(e, t, r) {
	var i = t.pstyle("background-fill").value;
	if ("linear-gradient" === i || "radial-gradient" === i) this.gradientFillStyle(e, t, i, r);
	else {
		var n = t.pstyle("background-color").value;
		this.colorFillStyle(e, n[0], n[1], n[2], r);
	}
}, Ya.gradientStrokeStyle = function(e, t, r, i) {
	var n = this.createGradientStyleFor(e, "line", t, r, i);
	if (!n) return null;
	e.strokeStyle = n;
}, Ya.colorStrokeStyle = function(e, t, r, i, n) {
	e.strokeStyle = "rgba(" + t + "," + r + "," + i + "," + n + ")";
}, Ya.eleStrokeStyle = function(e, t, r) {
	var i = t.pstyle("line-fill").value;
	if ("linear-gradient" === i || "radial-gradient" === i) this.gradientStrokeStyle(e, t, i, r);
	else {
		var n = t.pstyle("line-color").value;
		this.colorStrokeStyle(e, n[0], n[1], n[2], r);
	}
}, Ya.matchCanvasSize = function(e) {
	var t = this.data, r = this.findContainerClientCoords(), i = r[2], n = r[3], a = this.getPixelRatio(), s = this.motionBlurPxRatio;
	(e === this.data.bufferCanvases[this.MOTIONBLUR_BUFFER_NODE] || e === this.data.bufferCanvases[this.MOTIONBLUR_BUFFER_DRAG]) && (a = s);
	var o, l = i * a, h = n * a;
	if (l !== this.canvasWidth || h !== this.canvasHeight) {
		this.fontCaches = null;
		var u = t.canvasContainer;
		u.style.width = i + "px", u.style.height = n + "px";
		for (var d = 0; d < this.CANVAS_LAYERS; d++) (o = t.canvases[d]).width = l, o.height = h, o.style.width = i + "px", o.style.height = n + "px";
		for (var d = 0; d < this.BUFFER_COUNT; d++) (o = t.bufferCanvases[d]).width = l, o.height = h, o.style.width = i + "px", o.style.height = n + "px";
		this.textureMult = 1, a <= 1 && (o = t.bufferCanvases[this.TEXTURE_BUFFER], this.textureMult = 2, o.width = l * this.textureMult, o.height = h * this.textureMult), this.canvasWidth = l, this.canvasHeight = h, this.pixelRatio = a;
	}
}, Ya.renderTo = function(e, t, r, i) {
	this.render({
		forcedContext: e,
		forcedZoom: t,
		forcedPan: r,
		drawAllLayers: !0,
		forcedPxRatio: i
	});
}, Ya.clearCanvas = function() {
	var e = this, t = e.data;
	function r(t) {
		t.clearRect(0, 0, e.canvasWidth, e.canvasHeight);
	}
	h(r, "clear"), r(t.contexts[e.NODE]), r(t.contexts[e.DRAG]);
}, Ya.render = function(e) {
	var t = this;
	e = e || $s();
	var r = t.cy, i = e.forcedContext, n = e.drawAllLayers, a = e.drawOnlyNodeLayer, s = e.forcedZoom, o = e.forcedPan, l = void 0 === e.forcedPxRatio ? this.getPixelRatio() : e.forcedPxRatio, u = t.data, d = u.canvasNeedsRedraw, p = t.textureOnViewport && !i && (t.pinching || t.hoverData.dragging || t.swipePanning || t.data.wheelZooming), f = void 0 !== e.motionBlur ? e.motionBlur : t.motionBlur, g = t.motionBlurPxRatio, m = r.hasCompoundNodes(), y = t.hoverData.draggingEles, v = !!(t.hoverData.selecting || t.touchData.selecting), x = f = f && !i && t.motionBlurEnabled && !v;
	i || (t.prevPxRatio !== l && (t.invalidateContainerClientCoordsCache(), t.matchCanvasSize(t.container), t.redrawHint("eles", !0), t.redrawHint("drag", !0)), t.prevPxRatio = l), !i && t.motionBlurTimeout && clearTimeout(t.motionBlurTimeout), f && (t.mbFrames ??= 0, t.mbFrames++, t.mbFrames < 3 && (x = !1), t.mbFrames > t.minMbLowQualFrames && (t.motionBlurPxRatio = t.mbPxRBlurry)), t.clearingMotionBlur && (t.motionBlurPxRatio = 1), t.textureDrawLastFrame && !p && (d[t.NODE] = !0, d[t.SELECT_BOX] = !0);
	var b = r.style(), w = r.zoom(), k = void 0 !== s ? s : w, T = r.pan(), _ = {
		x: T.x,
		y: T.y
	}, E = {
		zoom: w,
		pan: {
			x: T.x,
			y: T.y
		}
	}, C = t.prevViewport;
	void 0 === C || E.zoom !== C.zoom || E.pan.x !== C.pan.x || E.pan.y !== C.pan.y || y && !m || (t.motionBlurPxRatio = 1), o && (_ = o), k *= l, _.x *= l, _.y *= l;
	var S = t.getCachedZSortedEles();
	function A(e, r, i, n, a) {
		var s = e.globalCompositeOperation;
		e.globalCompositeOperation = "destination-out", t.colorFillStyle(e, 255, 255, 255, t.motionBlurTransparency), e.fillRect(r, i, n, a), e.globalCompositeOperation = s;
	}
	function L(e, r) {
		var a, l, h, d;
		t.clearingMotionBlur || e !== u.bufferContexts[t.MOTIONBLUR_BUFFER_NODE] && e !== u.bufferContexts[t.MOTIONBLUR_BUFFER_DRAG] ? (a = _, l = k, h = t.canvasWidth, d = t.canvasHeight) : (a = {
			x: T.x * g,
			y: T.y * g
		}, l = w * g, h = t.canvasWidth * g, d = t.canvasHeight * g), e.setTransform(1, 0, 0, 1, 0, 0), "motionBlur" === r ? A(e, 0, 0, h, d) : !i && (void 0 === r || r) && e.clearRect(0, 0, h, d), n || (e.translate(a.x, a.y), e.scale(l, l)), o && e.translate(o.x, o.y), s && e.scale(s, s);
	}
	if (h(A, "mbclear"), h(L, "setContextTransform"), p || (t.textureDrawLastFrame = !1), p) {
		if (t.textureDrawLastFrame = !0, !t.textureCache) {
			t.textureCache = {}, t.textureCache.bb = r.mutableElements().boundingBox(), t.textureCache.texture = t.data.bufferCanvases[t.TEXTURE_BUFFER];
			var R = t.data.bufferContexts[t.TEXTURE_BUFFER];
			R.setTransform(1, 0, 0, 1, 0, 0), R.clearRect(0, 0, t.canvasWidth * t.textureMult, t.canvasHeight * t.textureMult), t.render({
				forcedContext: R,
				drawOnlyNodeLayer: !0,
				forcedPxRatio: l * t.textureMult
			});
			var E = t.textureCache.viewport = {
				zoom: r.zoom(),
				pan: r.pan(),
				width: t.canvasWidth,
				height: t.canvasHeight
			};
			E.mpan = {
				x: (0 - E.pan.x) / E.zoom,
				y: (0 - E.pan.y) / E.zoom
			};
		}
		d[t.DRAG] = !1, d[t.NODE] = !1;
		var N = u.contexts[t.NODE], I = t.textureCache.texture, E = t.textureCache.viewport;
		N.setTransform(1, 0, 0, 1, 0, 0), f ? A(N, 0, 0, E.width, E.height) : N.clearRect(0, 0, E.width, E.height);
		var M = b.core("outside-texture-bg-color").value, D = b.core("outside-texture-bg-opacity").value;
		t.colorFillStyle(N, M[0], M[1], M[2], D), N.fillRect(0, 0, E.width, E.height);
		var w = r.zoom();
		L(N, !1), N.clearRect(E.mpan.x, E.mpan.y, E.width / E.zoom / l, E.height / E.zoom / l), N.drawImage(I, E.mpan.x, E.mpan.y, E.width / E.zoom / l, E.height / E.zoom / l);
	} else t.textureOnViewport && !i && (t.textureCache = null);
	var O = r.extent(), $ = t.pinching || t.hoverData.dragging || t.swipePanning || t.data.wheelZooming || t.hoverData.draggingEles || t.cy.animated(), P = t.hideEdgesOnViewport && $, B = [];
	if (B[t.NODE] = !d[t.NODE] && f && !t.clearedForMotionBlur[t.NODE] || t.clearingMotionBlur, B[t.NODE] && (t.clearedForMotionBlur[t.NODE] = !0), B[t.DRAG] = !d[t.DRAG] && f && !t.clearedForMotionBlur[t.DRAG] || t.clearingMotionBlur, B[t.DRAG] && (t.clearedForMotionBlur[t.DRAG] = !0), d[t.NODE] || n || a || B[t.NODE]) {
		var F = f && !B[t.NODE] && 1 !== g, N = i || (F ? t.data.bufferContexts[t.MOTIONBLUR_BUFFER_NODE] : u.contexts[t.NODE]);
		L(N, f && !F ? "motionBlur" : void 0), P ? t.drawCachedNodes(N, S.nondrag, l, O) : t.drawLayeredElements(N, S.nondrag, l, O), t.debug && t.drawDebugPoints(N, S.nondrag), n || f || (d[t.NODE] = !1);
	}
	if (!a && (d[t.DRAG] || n || B[t.DRAG])) {
		var F = f && !B[t.DRAG] && 1 !== g, N = i || (F ? t.data.bufferContexts[t.MOTIONBLUR_BUFFER_DRAG] : u.contexts[t.DRAG]);
		L(N, f && !F ? "motionBlur" : void 0), P ? t.drawCachedNodes(N, S.drag, l, O) : t.drawCachedElements(N, S.drag, l, O), t.debug && t.drawDebugPoints(N, S.drag), n || f || (d[t.DRAG] = !1);
	}
	if (this.drawSelectionRectangle(e, L), f && 1 !== g) {
		var z = u.contexts[t.NODE], U = t.data.bufferCanvases[t.MOTIONBLUR_BUFFER_NODE], G = u.contexts[t.DRAG], q = t.data.bufferCanvases[t.MOTIONBLUR_BUFFER_DRAG], j = h(function(e, r, i) {
			e.setTransform(1, 0, 0, 1, 0, 0), i || !x ? e.clearRect(0, 0, t.canvasWidth, t.canvasHeight) : A(e, 0, 0, t.canvasWidth, t.canvasHeight), e.drawImage(r, 0, 0, t.canvasWidth * g, t.canvasHeight * g, 0, 0, t.canvasWidth, t.canvasHeight);
		}, "drawMotionBlur");
		(d[t.NODE] || B[t.NODE]) && (j(z, U, B[t.NODE]), d[t.NODE] = !1), (d[t.DRAG] || B[t.DRAG]) && (j(G, q, B[t.DRAG]), d[t.DRAG] = !1);
	}
	t.prevViewport = E, t.clearingMotionBlur && (t.clearingMotionBlur = !1, t.motionBlurCleared = !0, t.motionBlur = !0), f && (t.motionBlurTimeout = setTimeout(function() {
		t.motionBlurTimeout = null, t.clearedForMotionBlur[t.NODE] = !1, t.clearedForMotionBlur[t.DRAG] = !1, t.motionBlur = !1, t.clearingMotionBlur = !p, t.mbFrames = 0, d[t.NODE] = !0, d[t.DRAG] = !0, t.redraw();
	}, 100)), i || r.emit("render");
}, Ya.drawSelectionRectangle = function(e, t) {
	var r = this.cy, i = this.data, n = r.style(), a = e.drawOnlyNodeLayer, s = e.drawAllLayers, o = i.canvasNeedsRedraw, l = e.forcedContext;
	if (this.showFps || !a && o[this.SELECT_BOX] && !s) {
		var h = l || i.contexts[this.SELECT_BOX];
		if (t(h), 1 == this.selection[4] && (this.hoverData.selecting || this.touchData.selecting)) {
			var u = this.cy.zoom(), d = n.core("selection-box-border-width").value / u;
			h.lineWidth = d, h.fillStyle = "rgba(" + n.core("selection-box-color").value[0] + "," + n.core("selection-box-color").value[1] + "," + n.core("selection-box-color").value[2] + "," + n.core("selection-box-opacity").value + ")", h.fillRect(this.selection[0], this.selection[1], this.selection[2] - this.selection[0], this.selection[3] - this.selection[1]), d > 0 && (h.strokeStyle = "rgba(" + n.core("selection-box-border-color").value[0] + "," + n.core("selection-box-border-color").value[1] + "," + n.core("selection-box-border-color").value[2] + "," + n.core("selection-box-opacity").value + ")", h.strokeRect(this.selection[0], this.selection[1], this.selection[2] - this.selection[0], this.selection[3] - this.selection[1]));
		}
		if (i.bgActivePosistion && !this.hoverData.selecting) {
			var u = this.cy.zoom(), p = i.bgActivePosistion;
			h.fillStyle = "rgba(" + n.core("active-bg-color").value[0] + "," + n.core("active-bg-color").value[1] + "," + n.core("active-bg-color").value[2] + "," + n.core("active-bg-opacity").value + ")", h.beginPath(), h.arc(p.x, p.y, n.core("active-bg-size").pfValue / u, 0, 2 * Math.PI), h.fill();
		}
		var f = this.lastRedrawTime;
		if (this.showFps && f) {
			var g = Math.round(1e3 / (f = Math.round(f))), m = "1 frame = " + f + " ms = " + g + " fps";
			h.setTransform(1, 0, 0, 1, 0, 0), h.fillStyle = "rgba(255, 0, 0, 0.75)", h.strokeStyle = "rgba(255, 0, 0, 0.75)", h.font = "30px Arial", VX || (VX = h.measureText(m).actualBoundingBoxAscent), h.fillText(m, 0, VX), h.strokeRect(0, VX + 10, 250, 20), h.fillRect(0, VX + 10, 250 * Math.min(g / 60, 1), 20);
		}
		s || (o[this.SELECT_BOX] = !1);
	}
}, h(Ys, "compileShader"), h(Yo, "createProgram"), h(Yl, "createTextureCanvas"), h(Yc, "getEffectivePanZoom"), h(Yh, "getEffectiveZoom"), h(Yu, "modelToRenderedPosition"), h(Yd, "isSimpleShape"), h(Yp, "arrayEqual"), h(Yf, "toWebGLColor"), h(Yg, "indexToVec4"), h(Ym, "vec4ToIndex"), h(Yy, "createTexture"), h(Yv, "getTypeInfo"), h(Yx, "createTypedArray"), h(Yb, "createTypedArrayView"), h(Yw, "createBufferStaticDraw"), h(Yk, "createBufferDynamicDraw"), h(YT, "create3x3MatrixBufferDynamicDraw"), h(Y_, "createPickingFrameBuffer");
var YE = "u" > typeof Float32Array ? Float32Array : Array;
function YC() {
	var e = new YE(9);
	return YE != Float32Array && (e[1] = 0, e[2] = 0, e[3] = 0, e[5] = 0, e[6] = 0, e[7] = 0), e[0] = 1, e[4] = 1, e[8] = 1, e;
}
function YS(e) {
	return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1, e;
}
function YA(e, t, r) {
	var i = t[0], n = t[1], a = t[2], s = t[3], o = t[4], l = t[5], h = t[6], u = t[7], d = t[8], p = r[0], f = r[1], g = r[2], m = r[3], y = r[4], v = r[5], x = r[6], b = r[7], w = r[8];
	return e[0] = p * i + f * s + g * h, e[1] = p * n + f * o + g * u, e[2] = p * a + f * l + g * d, e[3] = m * i + y * s + v * h, e[4] = m * n + y * o + v * u, e[5] = m * a + y * l + v * d, e[6] = x * i + b * s + w * h, e[7] = x * n + b * o + w * u, e[8] = x * a + b * l + w * d, e;
}
function YL(e, t, r) {
	var i = t[0], n = t[1], a = t[2], s = t[3], o = t[4], l = t[5], h = t[6], u = t[7], d = t[8], p = r[0], f = r[1];
	return e[0] = i, e[1] = n, e[2] = a, e[3] = s, e[4] = o, e[5] = l, e[6] = p * i + f * s + h, e[7] = p * n + f * o + u, e[8] = p * a + f * l + d, e;
}
function YR(e, t, r) {
	var i = t[0], n = t[1], a = t[2], s = t[3], o = t[4], l = t[5], h = t[6], u = t[7], d = t[8], p = Math.sin(r), f = Math.cos(r);
	return e[0] = f * i + p * s, e[1] = f * n + p * o, e[2] = f * a + p * l, e[3] = f * s - p * i, e[4] = f * o - p * n, e[5] = f * l - p * a, e[6] = h, e[7] = u, e[8] = d, e;
}
function YN(e, t, r) {
	var i = r[0], n = r[1];
	return e[0] = i * t[0], e[1] = i * t[1], e[2] = i * t[2], e[3] = n * t[3], e[4] = n * t[4], e[5] = n * t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e;
}
function YI(e, t, r) {
	return e[0] = 2 / t, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = -2 / r, e[5] = 0, e[6] = -1, e[7] = 1, e[8] = 1, e;
}
Math.hypot || (Math.hypot = function() {
	for (var e = 0, t = arguments.length; t--;) e += arguments[t] * arguments[t];
	return Math.sqrt(e);
}), h(YC, "create"), h(YS, "identity"), h(YA, "multiply"), h(YL, "translate"), h(YR, "rotate"), h(YN, "scale"), h(YI, "projection");
var YM = function() {
	function e(t, r, i, n) {
		Dw(this, e), this.debugID = Math.floor(1e4 * Math.random()), this.r = t, this.texSize = r, this.texRows = i, this.texHeight = Math.floor(r / i), this.enableWrapping = !0, this.locked = !1, this.texture = null, this.needsBuffer = !0, this.freePointer = {
			x: 0,
			row: 0
		}, this.keyToLocation = /* @__PURE__ */ new Map(), this.canvas = n(t, r, r), this.scratch = n(t, r, this.texHeight, "scratch");
	}
	return h(e, "Atlas"), DT(e, [
		{
			key: "lock",
			value: h(function() {
				this.locked = !0;
			}, "lock")
		},
		{
			key: "getKeys",
			value: h(function() {
				return new Set(this.keyToLocation.keys());
			}, "getKeys")
		},
		{
			key: "getScale",
			value: h(function(e) {
				var t = e.w, r = e.h, i = this.texHeight, n = this.texSize, a = i / r, s = t * a, o = r * a;
				return s > n && (a = n / t, s = t * a, o = r * a), {
					scale: a,
					texW: s,
					texH: o
				};
			}, "getScale")
		},
		{
			key: "draw",
			value: h(function(e, t, r) {
				var i = this;
				if (this.locked) throw Error("can't draw, atlas is locked");
				var n = this.texSize, a = this.texRows, s = this.texHeight, o = this.getScale(t), l = o.scale, u = o.texW, d = o.texH, p = h(function(e, i) {
					if (r && i) {
						var n = i.context, a = e.x, o = s * e.row;
						n.save(), n.translate(a, o), n.scale(l, l), r(n, t), n.restore();
					}
				}, "drawAt"), f = [null, null], g = h(function() {
					p(i.freePointer, i.canvas), f[0] = {
						x: i.freePointer.x,
						y: i.freePointer.row * s,
						w: u,
						h: d
					}, f[1] = {
						x: i.freePointer.x + u,
						y: i.freePointer.row * s,
						w: 0,
						h: d
					}, i.freePointer.x += u, i.freePointer.x == n && (i.freePointer.x = 0, i.freePointer.row++);
				}, "drawNormal"), m = h(function() {
					var e = i.scratch, t = i.canvas;
					e.clear(), p({
						x: 0,
						row: 0
					}, e);
					var r = n - i.freePointer.x, a = u - r, o = i.freePointer.x, l = i.freePointer.row * s;
					t.context.drawImage(e, 0, 0, r, s, o, l, r, s), f[0] = {
						x: o,
						y: l,
						w: r,
						h: d
					};
					var h = (i.freePointer.row + 1) * s;
					t && t.context.drawImage(e, r, 0, a, s, 0, h, a, s), f[1] = {
						x: 0,
						y: h,
						w: a,
						h: d
					}, i.freePointer.x = a, i.freePointer.row++;
				}, "drawWrapped"), y = h(function() {
					i.freePointer.x = 0, i.freePointer.row++;
				}, "moveToStartOfNextRow");
				if (this.freePointer.x + u <= n) g();
				else {
					if (this.freePointer.row >= a - 1) return !1;
					this.freePointer.x === n ? (y(), g()) : this.enableWrapping ? m() : (y(), g());
				}
				return this.keyToLocation.set(e, f), this.needsBuffer = !0, f;
			}, "draw")
		},
		{
			key: "getOffsets",
			value: h(function(e) {
				return this.keyToLocation.get(e);
			}, "getOffsets")
		},
		{
			key: "isEmpty",
			value: h(function() {
				return 0 === this.freePointer.x && 0 === this.freePointer.row;
			}, "isEmpty")
		},
		{
			key: "canFit",
			value: h(function(e) {
				if (this.locked) return !1;
				var t = this.texSize, r = this.texRows, i = this.getScale(e).texW;
				return !(this.freePointer.x + i > t) || this.freePointer.row < r - 1;
			}, "canFit")
		},
		{
			key: "bufferIfNeeded",
			value: h(function(e) {
				this.texture || (this.texture = Yy(e, this.debugID)), this.needsBuffer && (this.texture.buffer(this.canvas), this.needsBuffer = !1, this.locked && (this.canvas = null, this.scratch = null));
			}, "bufferIfNeeded")
		},
		{
			key: "dispose",
			value: h(function() {
				this.texture && (this.texture.deleteTexture(), this.texture = null), this.canvas = null, this.scratch = null, this.locked = !0;
			}, "dispose")
		}
	]);
}(), YD = function() {
	function e(t, r, i, n) {
		Dw(this, e), this.r = t, this.texSize = r, this.texRows = i, this.createTextureCanvas = n, this.atlases = [], this.styleKeyToAtlas = /* @__PURE__ */ new Map(), this.markedKeys = /* @__PURE__ */ new Set();
	}
	return h(e, "AtlasCollection"), DT(e, [
		{
			key: "getKeys",
			value: h(function() {
				return new Set(this.styleKeyToAtlas.keys());
			}, "getKeys")
		},
		{
			key: "_createAtlas",
			value: h(function() {
				return new YM(this.r, this.texSize, this.texRows, this.createTextureCanvas);
			}, "_createAtlas")
		},
		{
			key: "_getScratchCanvas",
			value: h(function() {
				if (!this.scratch) {
					var e = this.r, t = this.texSize, r = this.texRows, i = this.createTextureCanvas;
					this.scratch = i(e, t, Math.floor(t / r), "scratch");
				}
				return this.scratch;
			}, "_getScratchCanvas")
		},
		{
			key: "draw",
			value: h(function(e, t, r) {
				var i = this.styleKeyToAtlas.get(e);
				return i || ((i = this.atlases[this.atlases.length - 1]) && i.canFit(t) || (i && i.lock(), i = this._createAtlas(), this.atlases.push(i)), i.draw(e, t, r), this.styleKeyToAtlas.set(e, i)), i;
			}, "draw")
		},
		{
			key: "getAtlas",
			value: h(function(e) {
				return this.styleKeyToAtlas.get(e);
			}, "getAtlas")
		},
		{
			key: "hasAtlas",
			value: h(function(e) {
				return this.styleKeyToAtlas.has(e);
			}, "hasAtlas")
		},
		{
			key: "markKeyForGC",
			value: h(function(e) {
				this.markedKeys.add(e);
			}, "markKeyForGC")
		},
		{
			key: "gc",
			value: h(function() {
				var e = this, t = this.markedKeys;
				if (0 === t.size) return void console.log("nothing to garbage collect");
				var r, i = [], n = /* @__PURE__ */ new Map(), a = null, s = D_(this.atlases);
				try {
					var o = h(function() {
						var s = r.value, o = s.getKeys(), l = YO(t, o);
						if (0 === l.size) return i.push(s), o.forEach(function(e) {
							return n.set(e, s);
						}), 1;
						a || (a = e._createAtlas(), i.push(a));
						var h, u = D_(o);
						try {
							for (u.s(); !(h = u.n()).done;) {
								var d = h.value;
								if (!l.has(d)) {
									var p = DR(s.getOffsets(d), 2), f = p[0], g = p[1];
									a.canFit({
										w: f.w + g.w,
										h: f.h
									}) || (a.lock(), a = e._createAtlas(), i.push(a)), s.canvas && (e._copyTextureToNewAtlas(d, s, a), n.set(d, a));
								}
							}
						} catch (e) {
							u.e(e);
						} finally {
							u.f();
						}
						s.dispose();
					}, "_loop");
					for (s.s(); !(r = s.n()).done;) o();
				} catch (e) {
					s.e(e);
				} finally {
					s.f();
				}
				this.atlases = i, this.styleKeyToAtlas = n, this.markedKeys = /* @__PURE__ */ new Set();
			}, "gc")
		},
		{
			key: "_copyTextureToNewAtlas",
			value: h(function(e, t, r) {
				var i = DR(t.getOffsets(e), 2), n = i[0], a = i[1];
				if (0 === a.w) r.draw(e, n, function(e) {
					e.drawImage(t.canvas, n.x, n.y, n.w, n.h, 0, 0, n.w, n.h);
				});
				else {
					var s = this._getScratchCanvas();
					s.clear(), s.context.drawImage(t.canvas, n.x, n.y, n.w, n.h, 0, 0, n.w, n.h), s.context.drawImage(t.canvas, a.x, a.y, a.w, a.h, n.w, 0, a.w, a.h);
					var o = n.w + a.w, l = n.h;
					r.draw(e, {
						w: o,
						h: l
					}, function(e) {
						e.drawImage(s, 0, 0, o, l, 0, 0, o, l);
					});
				}
			}, "_copyTextureToNewAtlas")
		},
		{
			key: "getCounts",
			value: h(function() {
				return {
					keyCount: this.styleKeyToAtlas.size,
					atlasCount: new Set(this.styleKeyToAtlas.values()).size
				};
			}, "getCounts")
		}
	]);
}();
function YO(e, t) {
	return e.intersection ? e.intersection(t) : new Set(DN(e).filter(function(e) {
		return t.has(e);
	}));
}
h(YO, "intersection");
var Y$ = function() {
	function e(t, r) {
		Dw(this, e), this.r = t, this.globalOptions = r, this.atlasSize = r.webglTexSize, this.maxAtlasesPerBatch = r.webglTexPerBatch, this.renderTypes = /* @__PURE__ */ new Map(), this.collections = /* @__PURE__ */ new Map(), this.typeAndIdToKey = /* @__PURE__ */ new Map();
	}
	return h(e, "AtlasManager"), DT(e, [
		{
			key: "getAtlasSize",
			value: h(function() {
				return this.atlasSize;
			}, "getAtlasSize")
		},
		{
			key: "addAtlasCollection",
			value: h(function(e, t) {
				var r = this.globalOptions, i = r.webglTexSize, n = r.createTextureCanvas, a = t.texRows, s = this._cacheScratchCanvas(n), o = new YD(this.r, i, a, s);
				this.collections.set(e, o);
			}, "addAtlasCollection")
		},
		{
			key: "addRenderType",
			value: h(function(e, t) {
				var r = t.collection;
				if (!this.collections.has(r)) throw Error("invalid atlas collection name '".concat(r, "'"));
				var i = Ou({
					type: e,
					atlasCollection: this.collections.get(r)
				}, t);
				this.renderTypes.set(e, i);
			}, "addRenderType")
		},
		{
			key: "getRenderTypeOpts",
			value: h(function(e) {
				return this.renderTypes.get(e);
			}, "getRenderTypeOpts")
		},
		{
			key: "getAtlasCollection",
			value: h(function(e) {
				return this.collections.get(e);
			}, "getAtlasCollection")
		},
		{
			key: "_cacheScratchCanvas",
			value: h(function(e) {
				var t = -1, r = -1, i = null;
				return function(n, a, s, o) {
					return o ? (i && a == t && s == r || (t = a, r = s, i = e(n, a, s)), i) : e(n, a, s);
				};
			}, "_cacheScratchCanvas")
		},
		{
			key: "_key",
			value: h(function(e, t) {
				return "".concat(e, "-").concat(t);
			}, "_key")
		},
		{
			key: "invalidate",
			value: h(function(e) {
				var t, r = this, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = i.forceRedraw, a = void 0 !== n && n, s = i.filterEle, o = void 0 === s ? function() {
					return !0;
				} : s, l = i.filterType, u = void 0 === l ? function() {
					return !0;
				} : l, d = !1, p = !1, f = D_(e);
				try {
					for (f.s(); !(t = f.n()).done;) {
						var g = t.value;
						if (o(g)) {
							var m, y = D_(this.renderTypes.values());
							try {
								var v = h(function() {
									var e = m.value, t = e.type;
									if (u(t)) {
										var i = r.collections.get(e.collection), n = e.getKey(g), s = Array.isArray(n) ? n : [n];
										if (a) s.forEach(function(e) {
											return i.markKeyForGC(e);
										}), p = !0;
										else {
											var o = e.getID ? e.getID(g) : g.id(), l = r._key(t, o), h = r.typeAndIdToKey.get(l);
											void 0 === h || Yp(s, h) || (d = !0, r.typeAndIdToKey.delete(l), h.forEach(function(e) {
												return i.markKeyForGC(e);
											}));
										}
									}
								}, "_loop2");
								for (y.s(); !(m = y.n()).done;) v();
							} catch (e) {
								y.e(e);
							} finally {
								y.f();
							}
						}
					}
				} catch (e) {
					f.e(e);
				} finally {
					f.f();
				}
				return p && (this.gc(), d = !1), d;
			}, "invalidate")
		},
		{
			key: "gc",
			value: h(function() {
				var e, t = D_(this.collections.values());
				try {
					for (t.s(); !(e = t.n()).done;) e.value.gc();
				} catch (e) {
					t.e(e);
				} finally {
					t.f();
				}
			}, "gc")
		},
		{
			key: "getOrCreateAtlas",
			value: h(function(e, t, r, i) {
				var n = this.renderTypes.get(t), a = this.collections.get(n.collection), s = !1, o = a.draw(i, r, function(t) {
					n.drawClipped ? (t.save(), t.beginPath(), t.rect(0, 0, r.w, r.h), t.clip(), n.drawElement(t, e, r, !0, !0), t.restore()) : n.drawElement(t, e, r, !0, !0), s = !0;
				});
				if (s) {
					var l = n.getID ? n.getID(e) : e.id(), h = this._key(t, l);
					this.typeAndIdToKey.has(h) ? this.typeAndIdToKey.get(h).push(i) : this.typeAndIdToKey.set(h, [i]);
				}
				return o;
			}, "getOrCreateAtlas")
		},
		{
			key: "getAtlasInfo",
			value: h(function(e, t) {
				var r = this, i = this.renderTypes.get(t), n = i.getKey(e);
				return (Array.isArray(n) ? n : [n]).map(function(n) {
					var a = i.getBoundingBox(e, n), s = r.getOrCreateAtlas(e, t, a, n), o = DR(s.getOffsets(n), 2), l = o[0];
					return {
						atlas: s,
						tex: l,
						tex1: l,
						tex2: o[1],
						bb: a
					};
				});
			}, "getAtlasInfo")
		},
		{
			key: "getDebugInfo",
			value: h(function() {
				var e, t = [], r = D_(this.collections);
				try {
					for (r.s(); !(e = r.n()).done;) {
						var i = DR(e.value, 2), n = i[0], a = i[1].getCounts(), s = a.keyCount, o = a.atlasCount;
						t.push({
							type: n,
							keyCount: s,
							atlasCount: o
						});
					}
				} catch (e) {
					r.e(e);
				} finally {
					r.f();
				}
				return t;
			}, "getDebugInfo")
		}
	]);
}(), YP = function() {
	function e(t) {
		Dw(this, e), this.globalOptions = t, this.atlasSize = t.webglTexSize, this.maxAtlasesPerBatch = t.webglTexPerBatch, this.batchAtlases = [];
	}
	return h(e, "AtlasBatchManager"), DT(e, [
		{
			key: "getMaxAtlasesPerBatch",
			value: h(function() {
				return this.maxAtlasesPerBatch;
			}, "getMaxAtlasesPerBatch")
		},
		{
			key: "getAtlasSize",
			value: h(function() {
				return this.atlasSize;
			}, "getAtlasSize")
		},
		{
			key: "getIndexArray",
			value: h(function() {
				return Array.from({ length: this.maxAtlasesPerBatch }, function(e, t) {
					return t;
				});
			}, "getIndexArray")
		},
		{
			key: "startBatch",
			value: h(function() {
				this.batchAtlases = [];
			}, "startBatch")
		},
		{
			key: "getAtlasCount",
			value: h(function() {
				return this.batchAtlases.length;
			}, "getAtlasCount")
		},
		{
			key: "getAtlases",
			value: h(function() {
				return this.batchAtlases;
			}, "getAtlases")
		},
		{
			key: "canAddToCurrentBatch",
			value: h(function(e) {
				return this.batchAtlases.length !== this.maxAtlasesPerBatch || this.batchAtlases.includes(e);
			}, "canAddToCurrentBatch")
		},
		{
			key: "getAtlasIndexForBatch",
			value: h(function(e) {
				var t = this.batchAtlases.indexOf(e);
				if (t < 0) {
					if (this.batchAtlases.length === this.maxAtlasesPerBatch) throw Error("cannot add more atlases to batch");
					this.batchAtlases.push(e), t = this.batchAtlases.length - 1;
				}
				return t;
			}, "getAtlasIndexForBatch")
		}
	]);
}(), YB = `
  float circleSD(vec2 p, float r) {
    return distance(vec2(0), p) - r; // signed distance
  }
`, YF = `
  float rectangleSD(vec2 p, vec2 b) {
    vec2 d = abs(p)-b;
    return distance(vec2(0),max(d,0.0)) + min(max(d.x,d.y),0.0);
  }
`, Yz = `
  float roundRectangleSD(vec2 p, vec2 b, vec4 cr) {
    cr.xy = (p.x > 0.0) ? cr.xy : cr.zw;
    cr.x  = (p.y > 0.0) ? cr.x  : cr.y;
    vec2 q = abs(p) - b + cr.x;
    return min(max(q.x, q.y), 0.0) + distance(vec2(0), max(q, 0.0)) - cr.x;
  }
`, YU = `
  float ellipseSD(vec2 p, vec2 ab) {
    p = abs( p ); // symmetry

    // find root with Newton solver
    vec2 q = ab*(p-ab);
    float w = (q.x<q.y)? 1.570796327 : 0.0;
    for( int i=0; i<5; i++ ) {
      vec2 cs = vec2(cos(w),sin(w));
      vec2 u = ab*vec2( cs.x,cs.y);
      vec2 v = ab*vec2(-cs.y,cs.x);
      w = w + dot(p-u,v)/(dot(p-u,u)+dot(v,v));
    }
    
    // compute final point and distance
    float d = length(p-ab*vec2(cos(w),sin(w)));
    
    // return signed distance
    return (dot(p/ab,p/ab)>1.0) ? d : -d;
  }
`, YG = {
	name: "screen",
	screen: !0
}, Yq = {
	name: "picking",
	picking: !0
}, Yj = function() {
	function e(t, r, i) {
		Dw(this, e), this.r = t, this.gl = r, this.maxInstances = i.webglBatchSize, this.atlasSize = i.webglTexSize, this.bgColor = i.bgColor, this.debug = i.webglDebug, this.batchDebugInfo = [], i.enableWrapping = !0, i.createTextureCanvas = Yl, this.atlasManager = new Y$(t, i), this.batchManager = new YP(i), this.simpleShapeOptions = /* @__PURE__ */ new Map(), this.program = this._createShaderProgram(YG), this.pickingProgram = this._createShaderProgram(Yq), this.vao = this._createVAO();
	}
	return h(e, "ElementDrawingWebGL"), DT(e, [
		{
			key: "addAtlasCollection",
			value: h(function(e, t) {
				this.atlasManager.addAtlasCollection(e, t);
			}, "addAtlasCollection")
		},
		{
			key: "addTextureAtlasRenderType",
			value: h(function(e, t) {
				this.atlasManager.addRenderType(e, t);
			}, "addTextureAtlasRenderType")
		},
		{
			key: "addSimpleShapeRenderType",
			value: h(function(e, t) {
				this.simpleShapeOptions.set(e, t);
			}, "addSimpleShapeRenderType")
		},
		{
			key: "invalidate",
			value: h(function(e) {
				var t = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).type, r = this.atlasManager;
				return t ? r.invalidate(e, {
					filterType: h(function(e) {
						return e === t;
					}, "filterType"),
					forceRedraw: !0
				}) : r.invalidate(e);
			}, "invalidate")
		},
		{
			key: "gc",
			value: h(function() {
				this.atlasManager.gc();
			}, "gc")
		},
		{
			key: "_createShaderProgram",
			value: h(function(e) {
				var t = this.gl, r = `#version 300 es
      precision highp float;

      uniform mat3 uPanZoomMatrix;
      uniform int  uAtlasSize;
      
      // instanced
      in vec2 aPosition; // a vertex from the unit square
      
      in mat3 aTransform; // used to transform verticies, eg into a bounding box
      in int aVertType; // the type of thing we are rendering

      // the z-index that is output when using picking mode
      in vec4 aIndex;
      
      // For textures
      in int aAtlasId; // which shader unit/atlas to use
      in vec4 aTex; // x/y/w/h of texture in atlas

      // for edges
      in vec4 aPointAPointB;
      in vec4 aPointCPointD;
      in vec2 aLineWidth; // also used for node border width

      // simple shapes
      in vec4 aCornerRadius; // for round-rectangle [top-right, bottom-right, top-left, bottom-left]
      in vec4 aColor; // also used for edges
      in vec4 aBorderColor; // aLineWidth is used for border width

      // output values passed to the fragment shader
      out vec2 vTexCoord;
      out vec4 vColor;
      out vec2 vPosition;
      // flat values are not interpolated
      flat out int vAtlasId; 
      flat out int vVertType;
      flat out vec2 vTopRight;
      flat out vec2 vBotLeft;
      flat out vec4 vCornerRadius;
      flat out vec4 vBorderColor;
      flat out vec2 vBorderWidth;
      flat out vec4 vIndex;
      
      void main(void) {
        int vid = gl_VertexID;
        vec2 position = aPosition; // TODO make this a vec3, simplifies some code below

        if(aVertType == `.concat(0, `) {
          float texX = aTex.x; // texture coordinates
          float texY = aTex.y;
          float texW = aTex.z;
          float texH = aTex.w;

          if(vid == 1 || vid == 2 || vid == 4) {
            texX += texW;
          }
          if(vid == 2 || vid == 4 || vid == 5) {
            texY += texH;
          }

          float d = float(uAtlasSize);
          vTexCoord = vec2(texX / d, texY / d); // tex coords must be between 0 and 1

          gl_Position = vec4(uPanZoomMatrix * aTransform * vec3(position, 1.0), 1.0);
        }
        else if(aVertType == `).concat(4, " || aVertType == ").concat(7, ` 
             || aVertType == `).concat(5, " || aVertType == ").concat(6, `) { // simple shapes

          // the bounding box is needed by the fragment shader
          vBotLeft  = (aTransform * vec3(0, 0, 1)).xy; // flat
          vTopRight = (aTransform * vec3(1, 1, 1)).xy; // flat
          vPosition = (aTransform * vec3(position, 1)).xy; // will be interpolated

          // calculations are done in the fragment shader, just pass these along
          vColor = aColor;
          vCornerRadius = aCornerRadius;
          vBorderColor = aBorderColor;
          vBorderWidth = aLineWidth;

          gl_Position = vec4(uPanZoomMatrix * aTransform * vec3(position, 1.0), 1.0);
        }
        else if(aVertType == `).concat(1, `) {
          vec2 source = aPointAPointB.xy;
          vec2 target = aPointAPointB.zw;

          // adjust the geometry so that the line is centered on the edge
          position.y = position.y - 0.5;

          // stretch the unit square into a long skinny rectangle
          vec2 xBasis = target - source;
          vec2 yBasis = normalize(vec2(-xBasis.y, xBasis.x));
          vec2 point = source + xBasis * position.x + yBasis * aLineWidth[0] * position.y;

          gl_Position = vec4(uPanZoomMatrix * vec3(point, 1.0), 1.0);
          vColor = aColor;
        } 
        else if(aVertType == `).concat(2, `) {
          vec2 pointA = aPointAPointB.xy;
          vec2 pointB = aPointAPointB.zw;
          vec2 pointC = aPointCPointD.xy;
          vec2 pointD = aPointCPointD.zw;

          // adjust the geometry so that the line is centered on the edge
          position.y = position.y - 0.5;

          vec2 p0, p1, p2, pos;
          if(position.x == 0.0) { // The left side of the unit square
            p0 = pointA;
            p1 = pointB;
            p2 = pointC;
            pos = position;
          } else { // The right side of the unit square, use same approach but flip the geometry upside down
            p0 = pointD;
            p1 = pointC;
            p2 = pointB;
            pos = vec2(0.0, -position.y);
          }

          vec2 p01 = p1 - p0;
          vec2 p12 = p2 - p1;
          vec2 p21 = p1 - p2;

          // Find the normal vector.
          vec2 tangent = normalize(normalize(p12) + normalize(p01));
          vec2 normal = vec2(-tangent.y, tangent.x);

          // Find the vector perpendicular to p0 -> p1.
          vec2 p01Norm = normalize(vec2(-p01.y, p01.x));

          // Determine the bend direction.
          float sigma = sign(dot(p01 + p21, normal));
          float width = aLineWidth[0];

          if(sign(pos.y) == -sigma) {
            // This is an intersecting vertex. Adjust the position so that there's no overlap.
            vec2 point = 0.5 * width * normal * -sigma / dot(normal, p01Norm);
            gl_Position = vec4(uPanZoomMatrix * vec3(p1 + point, 1.0), 1.0);
          } else {
            // This is a non-intersecting vertex. Treat it like a mitre join.
            vec2 point = 0.5 * width * normal * sigma * dot(normal, p01Norm);
            gl_Position = vec4(uPanZoomMatrix * vec3(p1 + point, 1.0), 1.0);
          }

          vColor = aColor;
        } 
        else if(aVertType == `).concat(3, ` && vid < 3) {
          // massage the first triangle into an edge arrow
          if(vid == 0)
            position = vec2(-0.15, -0.3);
          if(vid == 1)
            position = vec2(  0.0,  0.0);
          if(vid == 2)
            position = vec2( 0.15, -0.3);

          gl_Position = vec4(uPanZoomMatrix * aTransform * vec3(position, 1.0), 1.0);
          vColor = aColor;
        }
        else {
          gl_Position = vec4(2.0, 0.0, 0.0, 1.0); // discard vertex by putting it outside webgl clip space
        }

        vAtlasId = aAtlasId;
        vVertType = aVertType;
        vIndex = aIndex;
      }
    `), i = this.batchManager.getIndexArray(), n = Yo(t, r, `#version 300 es
      precision highp float;

      // declare texture unit for each texture atlas in the batch
      `.concat(i.map(function(e) {
					return "uniform sampler2D uTexture".concat(e, ";");
				}).join(`
	`), `

      uniform vec4 uBGColor;
      uniform float uZoom;

      in vec2 vTexCoord;
      in vec4 vColor;
      in vec2 vPosition; // model coordinates

      flat in int vAtlasId;
      flat in vec4 vIndex;
      flat in int vVertType;
      flat in vec2 vTopRight;
      flat in vec2 vBotLeft;
      flat in vec4 vCornerRadius;
      flat in vec4 vBorderColor;
      flat in vec2 vBorderWidth;

      out vec4 outColor;

      `).concat(YB, `
      `).concat(YF, `
      `).concat(Yz, `
      `).concat(YU, `

      vec4 blend(vec4 top, vec4 bot) { // blend colors with premultiplied alpha
        return vec4( 
          top.rgb + (bot.rgb * (1.0 - top.a)),
          top.a   + (bot.a   * (1.0 - top.a)) 
        );
      }

      vec4 distInterp(vec4 cA, vec4 cB, float d) { // interpolate color using Signed Distance
        // scale to the zoom level so that borders don't look blurry when zoomed in
        // note 1.5 is an aribitrary value chosen because it looks good
        return mix(cA, cB, 1.0 - smoothstep(0.0, 1.5 / uZoom, abs(d))); 
      }

      void main(void) {
        if(vVertType == `).concat(0, `) {
          // look up the texel from the texture unit
          `).concat(i.map(function(e) {
					return "if(vAtlasId == ".concat(e, ") outColor = texture(uTexture").concat(e, ", vTexCoord);");
				}).join(`
	else `), `
        } 
        else if(vVertType == `).concat(3, `) {
          // mimics how canvas renderer uses context.globalCompositeOperation = 'destination-out';
          outColor = blend(vColor, uBGColor);
          outColor.a = 1.0; // make opaque, masks out line under arrow
        }
        else if(vVertType == `).concat(4, ` && vBorderWidth == vec2(0.0)) { // simple rectangle with no border
          outColor = vColor; // unit square is already transformed to the rectangle, nothing else needs to be done
        }
        else if(vVertType == `).concat(4, " || vVertType == ").concat(7, ` 
          || vVertType == `).concat(5, " || vVertType == ").concat(6, `) { // use SDF

          float outerBorder = vBorderWidth[0];
          float innerBorder = vBorderWidth[1];
          float borderPadding = outerBorder * 2.0;
          float w = vTopRight.x - vBotLeft.x - borderPadding;
          float h = vTopRight.y - vBotLeft.y - borderPadding;
          vec2 b = vec2(w/2.0, h/2.0); // half width, half height
          vec2 p = vPosition - vec2(vTopRight.x - b[0] - outerBorder, vTopRight.y - b[1] - outerBorder); // translate to center

          float d; // signed distance
          if(vVertType == `).concat(4, `) {
            d = rectangleSD(p, b);
          } else if(vVertType == `).concat(7, ` && w == h) {
            d = circleSD(p, b.x); // faster than ellipse
          } else if(vVertType == `).concat(7, `) {
            d = ellipseSD(p, b);
          } else {
            d = roundRectangleSD(p, b, vCornerRadius.wzyx);
          }

          // use the distance to interpolate a color to smooth the edges of the shape, doesn't need multisampling
          // we must smooth colors inwards, because we can't change pixels outside the shape's bounding box
          if(d > 0.0) {
            if(d > outerBorder) {
              discard;
            } else {
              outColor = distInterp(vBorderColor, vec4(0), d - outerBorder);
            }
          } else {
            if(d > innerBorder) {
              vec4 outerColor = outerBorder == 0.0 ? vec4(0) : vBorderColor;
              vec4 innerBorderColor = blend(vBorderColor, vColor);
              outColor = distInterp(innerBorderColor, outerColor, d);
            } 
            else {
              vec4 outerColor;
              if(innerBorder == 0.0 && outerBorder == 0.0) {
                outerColor = vec4(0);
              } else if(innerBorder == 0.0) {
                outerColor = vBorderColor;
              } else {
                outerColor = blend(vBorderColor, vColor);
              }
              outColor = distInterp(vColor, outerColor, d - innerBorder);
            }
          }
        }
        else {
          outColor = vColor;
        }

        `).concat(e.picking ? `if(outColor.a == 0.0) discard;
             else outColor = vIndex;` : "", `
      }
    `));
				n.aPosition = t.getAttribLocation(n, "aPosition"), n.aIndex = t.getAttribLocation(n, "aIndex"), n.aVertType = t.getAttribLocation(n, "aVertType"), n.aTransform = t.getAttribLocation(n, "aTransform"), n.aAtlasId = t.getAttribLocation(n, "aAtlasId"), n.aTex = t.getAttribLocation(n, "aTex"), n.aPointAPointB = t.getAttribLocation(n, "aPointAPointB"), n.aPointCPointD = t.getAttribLocation(n, "aPointCPointD"), n.aLineWidth = t.getAttribLocation(n, "aLineWidth"), n.aColor = t.getAttribLocation(n, "aColor"), n.aCornerRadius = t.getAttribLocation(n, "aCornerRadius"), n.aBorderColor = t.getAttribLocation(n, "aBorderColor"), n.uPanZoomMatrix = t.getUniformLocation(n, "uPanZoomMatrix"), n.uAtlasSize = t.getUniformLocation(n, "uAtlasSize"), n.uBGColor = t.getUniformLocation(n, "uBGColor"), n.uZoom = t.getUniformLocation(n, "uZoom"), n.uTextures = [];
				for (var a = 0; a < this.batchManager.getMaxAtlasesPerBatch(); a++) n.uTextures.push(t.getUniformLocation(n, "uTexture".concat(a)));
				return n;
			}, "_createShaderProgram")
		},
		{
			key: "_createVAO",
			value: h(function() {
				var e = [
					0,
					0,
					1,
					0,
					1,
					1,
					0,
					0,
					1,
					1,
					0,
					1
				];
				this.vertexCount = e.length / 2;
				var t = this.maxInstances, r = this.gl, i = this.program, n = r.createVertexArray();
				return r.bindVertexArray(n), Yw(r, "vec2", i.aPosition, e), this.transformBuffer = YT(r, t, i.aTransform), this.indexBuffer = Yk(r, t, "vec4", i.aIndex), this.vertTypeBuffer = Yk(r, t, "int", i.aVertType), this.atlasIdBuffer = Yk(r, t, "int", i.aAtlasId), this.texBuffer = Yk(r, t, "vec4", i.aTex), this.pointAPointBBuffer = Yk(r, t, "vec4", i.aPointAPointB), this.pointCPointDBuffer = Yk(r, t, "vec4", i.aPointCPointD), this.lineWidthBuffer = Yk(r, t, "vec2", i.aLineWidth), this.colorBuffer = Yk(r, t, "vec4", i.aColor), this.cornerRadiusBuffer = Yk(r, t, "vec4", i.aCornerRadius), this.borderColorBuffer = Yk(r, t, "vec4", i.aBorderColor), r.bindVertexArray(null), n;
			}, "_createVAO")
		},
		{
			key: "buffers",
			get: h(function() {
				var e = this;
				return this._buffers || (this._buffers = Object.keys(this).filter(function(e) {
					return Oi(e, "Buffer");
				}).map(function(t) {
					return e[t];
				})), this._buffers;
			}, "get")
		},
		{
			key: "startFrame",
			value: h(function(e) {
				var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : YG;
				this.panZoomMatrix = e, this.renderTarget = t, this.batchDebugInfo = [], this.wrappedCount = 0, this.simpleCount = 0, this.startBatch();
			}, "startFrame")
		},
		{
			key: "startBatch",
			value: h(function() {
				this.instanceCount = 0, this.batchManager.startBatch();
			}, "startBatch")
		},
		{
			key: "endFrame",
			value: h(function() {
				this.endBatch();
			}, "endFrame")
		},
		{
			key: "_isVisible",
			value: h(function(e, t) {
				return !!e.visible() && (!t || !t.isVisible || t.isVisible(e));
			}, "_isVisible")
		},
		{
			key: "drawTexture",
			value: h(function(e, t, r) {
				var i = this.atlasManager, n = this.batchManager, a = i.getRenderTypeOpts(r);
				if (this._isVisible(e, a) && !(e.isEdge() && !this._isValidEdge(e))) {
					if (this.renderTarget.picking && a.getTexPickingMode) {
						var s = a.getTexPickingMode(e);
						if (1 === s) return;
						if (2 == s) return void this.drawPickingRectangle(e, t, r);
					}
					var o, l = D_(i.getAtlasInfo(e, r));
					try {
						for (l.s(); !(o = l.n()).done;) {
							var h = o.value, u = h.atlas, d = h.tex1, p = h.tex2;
							n.canAddToCurrentBatch(u) || this.endBatch();
							for (var f = n.getAtlasIndexForBatch(u), g = 0, m = [[d, !0], [p, !1]]; g < m.length; g++) {
								var y = DR(m[g], 2), v = y[0], x = y[1];
								if (0 != v.w) {
									var b = this.instanceCount;
									this.vertTypeBuffer.getView(b)[0] = 0, Yg(t, this.indexBuffer.getView(b)), this.atlasIdBuffer.getView(b)[0] = f;
									var w = this.texBuffer.getView(b);
									w[0] = v.x, w[1] = v.y, w[2] = v.w, w[3] = v.h;
									var k = this.transformBuffer.getMatrixView(b);
									this.setTransformMatrix(e, k, a, h, x), this.instanceCount++, x || this.wrappedCount++, this.instanceCount >= this.maxInstances && this.endBatch();
								}
							}
						}
					} catch (e) {
						l.e(e);
					} finally {
						l.f();
					}
				}
			}, "drawTexture")
		},
		{
			key: "setTransformMatrix",
			value: h(function(e, t, r, i) {
				var n = !(arguments.length > 4) || void 0 === arguments[4] || arguments[4], a = 0;
				if (r.shapeProps && r.shapeProps.padding && (a = e.pstyle(r.shapeProps.padding).pfValue), i) {
					var s = i.bb, o = i.tex1, l = i.tex2, h = o.w / (o.w + l.w);
					n || (h = 1 - h);
					var u = this._getAdjustedBB(s, a, n, h);
					this._applyTransformMatrix(t, u, r, e);
				} else {
					var d = r.getBoundingBox(e), p = this._getAdjustedBB(d, a, !0, 1);
					this._applyTransformMatrix(t, p, r, e);
				}
			}, "setTransformMatrix")
		},
		{
			key: "_applyTransformMatrix",
			value: h(function(e, t, r, i) {
				YS(e);
				var n, a, s = r.getRotation ? r.getRotation(i) : 0;
				if (0 !== s) {
					var o = r.getRotationPoint(i);
					YL(e, e, [o.x, o.y]), YR(e, e, s);
					var l = r.getRotationOffset(i);
					n = l.x + (t.xOffset || 0), a = l.y + (t.yOffset || 0);
				} else n = t.x1, a = t.y1;
				YL(e, e, [n, a]), YN(e, e, [t.w, t.h]);
			}, "_applyTransformMatrix")
		},
		{
			key: "_getAdjustedBB",
			value: h(function(e, t, r, i) {
				var n = e.x1, a = e.y1, s = e.w, o = e.h, l = e.yOffset;
				t && (n -= t, a -= t, s += 2 * t, o += 2 * t);
				var h = 0, u = s * i;
				return r && i < 1 ? s = u : !r && i < 1 && (n += h = s - u, s = u), {
					x1: n,
					y1: a,
					w: s,
					h: o,
					xOffset: h,
					yOffset: l
				};
			}, "_getAdjustedBB")
		},
		{
			key: "drawPickingRectangle",
			value: h(function(e, t, r) {
				var i = this.atlasManager.getRenderTypeOpts(r), n = this.instanceCount;
				this.vertTypeBuffer.getView(n)[0] = 4, Yg(t, this.indexBuffer.getView(n)), Yf([
					0,
					0,
					0
				], 1, this.colorBuffer.getView(n));
				var a = this.transformBuffer.getMatrixView(n);
				this.setTransformMatrix(e, a, i), this.simpleCount++, this.instanceCount++, this.instanceCount >= this.maxInstances && this.endBatch();
			}, "drawPickingRectangle")
		},
		{
			key: "drawNode",
			value: h(function(e, t, r) {
				var i = this.simpleShapeOptions.get(r);
				if (this._isVisible(e, i)) {
					var n = i.shapeProps, a = this._getVertTypeForShape(e, n.shape);
					if (void 0 === a || i.isSimple && !i.isSimple(e)) return void this.drawTexture(e, t, r);
					var s = this.instanceCount;
					if (this.vertTypeBuffer.getView(s)[0] = a, 5 === a || 6 === a) {
						var o = i.getBoundingBox(e), l = this._getCornerRadius(e, n.radius, o), h = this.cornerRadiusBuffer.getView(s);
						h[0] = l, h[1] = l, h[2] = l, h[3] = l, 6 === a && (h[0] = 0, h[2] = 0);
					}
					Yg(t, this.indexBuffer.getView(s)), Yf(e.pstyle(n.color).value, e.pstyle(n.opacity).value, this.colorBuffer.getView(s));
					var u = this.lineWidthBuffer.getView(s);
					if (u[0] = 0, u[1] = 0, n.border) {
						var d = e.pstyle("border-width").value;
						if (d > 0) {
							Yf(e.pstyle("border-color").value, e.pstyle("border-opacity").value, this.borderColorBuffer.getView(s));
							var p = e.pstyle("border-position").value;
							if ("inside" === p) u[0] = 0, u[1] = -d;
							else if ("outside" === p) u[0] = d, u[1] = 0;
							else {
								var f = d / 2;
								u[0] = f, u[1] = -f;
							}
						}
					}
					var g = this.transformBuffer.getMatrixView(s);
					this.setTransformMatrix(e, g, i), this.simpleCount++, this.instanceCount++, this.instanceCount >= this.maxInstances && this.endBatch();
				}
			}, "drawNode")
		},
		{
			key: "_getVertTypeForShape",
			value: h(function(e, t) {
				switch (e.pstyle(t).value) {
					case "rectangle": return 4;
					case "ellipse": return 7;
					case "roundrectangle":
					case "round-rectangle": return 5;
					case "bottom-round-rectangle": return 6;
					default: return;
				}
			}, "_getVertTypeForShape")
		},
		{
			key: "_getCornerRadius",
			value: h(function(e, t, r) {
				var i = r.w, n = r.h;
				return "auto" === e.pstyle(t).value ? Be(i, n) : Math.min(e.pstyle(t).pfValue, n / 2, i / 2);
			}, "_getCornerRadius")
		},
		{
			key: "drawEdgeArrow",
			value: h(function(e, t, r) {
				if (e.visible()) {
					var i, n, a, s = e._private.rscratch;
					if ("source" === r ? (i = s.arrowStartX, n = s.arrowStartY, a = s.srcArrowAngle) : (i = s.arrowEndX, n = s.arrowEndY, a = s.tgtArrowAngle), !(isNaN(i) || null == i || isNaN(n) || null == n || isNaN(a) || null == a) && "none" !== e.pstyle(r + "-arrow-shape").value) {
						var o = e.pstyle(r + "-arrow-color").value, l = e.pstyle("opacity").value * e.pstyle("line-opacity").value, h = e.pstyle("width").pfValue, u = e.pstyle("arrow-scale").value, d = this.r.getArrowWidth(h, u), p = this.instanceCount, f = this.transformBuffer.getMatrixView(p);
						YS(f), YL(f, f, [i, n]), YN(f, f, [d, d]), YR(f, f, a), this.vertTypeBuffer.getView(p)[0] = 3, Yg(t, this.indexBuffer.getView(p)), Yf(o, l, this.colorBuffer.getView(p)), this.instanceCount++, this.instanceCount >= this.maxInstances && this.endBatch();
					}
				}
			}, "drawEdgeArrow")
		},
		{
			key: "drawEdgeLine",
			value: h(function(e, t) {
				if (e.visible()) {
					var r = this._getEdgePoints(e);
					if (r) {
						var i = e.pstyle("opacity").value, n = e.pstyle("line-opacity").value, a = e.pstyle("width").pfValue, s = e.pstyle("line-color").value, o = i * n;
						if (r.length / 2 + this.instanceCount > this.maxInstances && this.endBatch(), 4 == r.length) {
							var l = this.instanceCount;
							this.vertTypeBuffer.getView(l)[0] = 1, Yg(t, this.indexBuffer.getView(l)), Yf(s, o, this.colorBuffer.getView(l)), this.lineWidthBuffer.getView(l)[0] = a;
							var h = this.pointAPointBBuffer.getView(l);
							h[0] = r[0], h[1] = r[1], h[2] = r[2], h[3] = r[3], this.instanceCount++, this.instanceCount >= this.maxInstances && this.endBatch();
						} else for (var u = 0; u < r.length - 2; u += 2) {
							var d = this.instanceCount;
							this.vertTypeBuffer.getView(d)[0] = 2, Yg(t, this.indexBuffer.getView(d)), Yf(s, o, this.colorBuffer.getView(d)), this.lineWidthBuffer.getView(d)[0] = a;
							var p = r[u - 2], f = r[u - 1], g = r[u], m = r[u + 1], y = r[u + 2], v = r[u + 3], x = r[u + 4], b = r[u + 5];
							0 == u && (p = 2 * g - y + .001, f = 2 * m - v + .001), u == r.length - 4 && (x = 2 * y - g + .001, b = 2 * v - m + .001);
							var w = this.pointAPointBBuffer.getView(d);
							w[0] = p, w[1] = f, w[2] = g, w[3] = m;
							var k = this.pointCPointDBuffer.getView(d);
							k[0] = y, k[1] = v, k[2] = x, k[3] = b, this.instanceCount++, this.instanceCount >= this.maxInstances && this.endBatch();
						}
					}
				}
			}, "drawEdgeLine")
		},
		{
			key: "_isValidEdge",
			value: h(function(e) {
				var t = e._private.rscratch;
				return !(t.badLine || null == t.allpts || isNaN(t.allpts[0]));
			}, "_isValidEdge")
		},
		{
			key: "_getEdgePoints",
			value: h(function(e) {
				var t = e._private.rscratch;
				if (this._isValidEdge(e)) {
					var r = t.allpts;
					if (4 == r.length) return r;
					var i = this._getNumSegments(e);
					return this._getCurveSegmentPoints(r, i);
				}
			}, "_getEdgePoints")
		},
		{
			key: "_getNumSegments",
			value: h(function(e) {
				return Math.min(15, this.maxInstances);
			}, "_getNumSegments")
		},
		{
			key: "_getCurveSegmentPoints",
			value: h(function(e, t) {
				if (4 == e.length) return e;
				for (var r = Array((t + 1) * 2), i = 0; i <= t; i++) if (0 == i) r[0] = e[0], r[1] = e[1];
				else if (i == t) r[2 * i] = e[e.length - 2], r[2 * i + 1] = e[e.length - 1];
				else {
					var n = i / t;
					this._setCurvePoint(e, n, r, 2 * i);
				}
				return r;
			}, "_getCurveSegmentPoints")
		},
		{
			key: "_setCurvePoint",
			value: h(function(e, t, r, i) {
				if (e.length <= 2) r[i] = e[0], r[i + 1] = e[1];
				else {
					for (var n = Array(e.length - 2), a = 0; a < n.length; a += 2) {
						var s = (1 - t) * e[a] + t * e[a + 2], o = (1 - t) * e[a + 1] + t * e[a + 3];
						n[a] = s, n[a + 1] = o;
					}
					return this._setCurvePoint(n, t, r, i);
				}
			}, "_setCurvePoint")
		},
		{
			key: "endBatch",
			value: h(function() {
				var e = this.gl, t = this.vao, r = this.vertexCount, i = this.instanceCount;
				if (0 !== i) {
					var n = this.renderTarget.picking ? this.pickingProgram : this.program;
					e.useProgram(n), e.bindVertexArray(t);
					var a, s = D_(this.buffers);
					try {
						for (s.s(); !(a = s.n()).done;) a.value.bufferSubData(i);
					} catch (e) {
						s.e(e);
					} finally {
						s.f();
					}
					for (var o = this.batchManager.getAtlases(), l = 0; l < o.length; l++) o[l].bufferIfNeeded(e);
					for (var h = 0; h < o.length; h++) e.activeTexture(e.TEXTURE0 + h), e.bindTexture(e.TEXTURE_2D, o[h].texture), e.uniform1i(n.uTextures[h], h);
					e.uniform1f(n.uZoom, Yh(this.r)), e.uniformMatrix3fv(n.uPanZoomMatrix, !1, this.panZoomMatrix), e.uniform1i(n.uAtlasSize, this.batchManager.getAtlasSize());
					var u = Yf(this.bgColor, 1);
					e.uniform4fv(n.uBGColor, u), e.drawArraysInstanced(e.TRIANGLES, 0, r, i), e.bindVertexArray(null), e.bindTexture(e.TEXTURE_2D, null), this.debug && this.batchDebugInfo.push({
						count: i,
						atlasCount: o.length
					}), this.startBatch();
				}
			}, "endBatch")
		},
		{
			key: "getDebugInfo",
			value: h(function() {
				var e = this.atlasManager.getDebugInfo(), t = e.reduce(function(e, t) {
					return e + t.atlasCount;
				}, 0), r = this.batchDebugInfo, i = r.reduce(function(e, t) {
					return e + t.count;
				}, 0);
				return {
					atlasInfo: e,
					totalAtlases: t,
					wrappedCount: this.wrappedCount,
					simpleCount: this.simpleCount,
					batchCount: r.length,
					batchInfo: r,
					totalInstances: i
				};
			}, "getDebugInfo")
		}
	]);
}(), YW = {};
function YY(e) {
	var t = e.cy.container();
	return Om(t && t.style && t.style.backgroundColor || "white");
}
function YV(e, t) {
	return $u(e._private.rscratch, "labelWrapCachedLines", t) || [];
}
YW.initWebgl = function(e, t) {
	var r = this, i = r.data.contexts[r.WEBGL];
	e.bgColor = YY(r), e.webglTexSize = Math.min(e.webglTexSize, i.getParameter(i.MAX_TEXTURE_SIZE)), e.webglTexRows = Math.min(e.webglTexRows, 54), e.webglTexRowsNodes = Math.min(e.webglTexRowsNodes, 54), e.webglBatchSize = Math.min(e.webglBatchSize, 16384), e.webglTexPerBatch = Math.min(e.webglTexPerBatch, i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS)), r.webglDebug = e.webglDebug, r.webglDebugShowAtlases = e.webglDebugShowAtlases, r.pickingFrameBuffer = Y_(i), r.pickingFrameBuffer.needsDraw = !0, r.drawing = new Yj(r, i, e);
	var n = h(function(e) {
		return function(t) {
			return r.getTextAngle(t, e);
		};
	}, "getLabelRotation"), a = h(function(e) {
		return function(t) {
			var r = t.pstyle(e);
			return r && r.value;
		};
	}, "isLabelVisible"), s = h(function(e) {
		return function(t) {
			return t.pstyle("".concat(e, "-opacity")).value > 0;
		};
	}, "isLayerVisible"), o = h(function(e) {
		return "yes" === e.pstyle("text-events").strValue ? 2 : 1;
	}, "getTexPickingMode"), l = h(function(e) {
		var t = e.position(), r = t.x, i = t.y, n = e.outerWidth(), a = e.outerHeight();
		return {
			w: n,
			h: a,
			x1: r - n / 2,
			y1: i - a / 2
		};
	}, "getBBForSimpleShape");
	r.drawing.addAtlasCollection("node", { texRows: e.webglTexRowsNodes }), r.drawing.addAtlasCollection("label", { texRows: e.webglTexRows }), r.drawing.addTextureAtlasRenderType("node-body", {
		collection: "node",
		getKey: t.getStyleKey,
		getBoundingBox: t.getElementBox,
		drawElement: t.drawElement
	}), r.drawing.addSimpleShapeRenderType("node-body", {
		getBoundingBox: l,
		isSimple: Yd,
		shapeProps: {
			shape: "shape",
			color: "background-color",
			opacity: "background-opacity",
			radius: "corner-radius",
			border: !0
		}
	}), r.drawing.addSimpleShapeRenderType("node-overlay", {
		getBoundingBox: l,
		isVisible: s("overlay"),
		shapeProps: {
			shape: "overlay-shape",
			color: "overlay-color",
			opacity: "overlay-opacity",
			padding: "overlay-padding",
			radius: "overlay-corner-radius"
		}
	}), r.drawing.addSimpleShapeRenderType("node-underlay", {
		getBoundingBox: l,
		isVisible: s("underlay"),
		shapeProps: {
			shape: "underlay-shape",
			color: "underlay-color",
			opacity: "underlay-opacity",
			padding: "underlay-padding",
			radius: "underlay-corner-radius"
		}
	}), r.drawing.addTextureAtlasRenderType("label", {
		collection: "label",
		getTexPickingMode: o,
		getKey: YH(t.getLabelKey, null),
		getBoundingBox: YX(t.getLabelBox, null),
		drawClipped: !0,
		drawElement: t.drawLabel,
		getRotation: n(null),
		getRotationPoint: t.getLabelRotationPoint,
		getRotationOffset: t.getLabelRotationOffset,
		isVisible: a("label")
	}), r.drawing.addTextureAtlasRenderType("edge-source-label", {
		collection: "label",
		getTexPickingMode: o,
		getKey: YH(t.getSourceLabelKey, "source"),
		getBoundingBox: YX(t.getSourceLabelBox, "source"),
		drawClipped: !0,
		drawElement: t.drawSourceLabel,
		getRotation: n("source"),
		getRotationPoint: t.getSourceLabelRotationPoint,
		getRotationOffset: t.getSourceLabelRotationOffset,
		isVisible: a("source-label")
	}), r.drawing.addTextureAtlasRenderType("edge-target-label", {
		collection: "label",
		getTexPickingMode: o,
		getKey: YH(t.getTargetLabelKey, "target"),
		getBoundingBox: YX(t.getTargetLabelBox, "target"),
		drawClipped: !0,
		drawElement: t.drawTargetLabel,
		getRotation: n("target"),
		getRotationPoint: t.getTargetLabelRotationPoint,
		getRotationOffset: t.getTargetLabelRotationOffset,
		isVisible: a("target-label")
	});
	var u = O$(function() {
		console.log("garbage collect flag set"), r.data.gc = !0;
	}, 1e4);
	r.onUpdateEleCalcs(function(e, t) {
		var i = !1;
		t && t.length > 0 && (i |= r.drawing.invalidate(t)), i && u();
	}), YK(r);
}, h(YY, "getBGColor"), h(YV, "getLabelLines");
var YH = h(function(e, t) {
	return function(r) {
		var i = e(r), n = YV(r, t);
		return n.length > 1 ? n.map(function(e, t) {
			return "".concat(i, "_").concat(t);
		}) : i;
	};
}, "getStyleKeysForLabel"), YX = h(function(e, t) {
	return function(r, i) {
		var n = e(r);
		if ("string" == typeof i) {
			var a = i.indexOf("_");
			if (a > 0) {
				var s = Number(i.substring(a + 1)), o = YV(r, t), l = n.h / o.length, h = l * s, u = n.y1 + h;
				return {
					x1: n.x1,
					w: n.w,
					y1: u,
					h: l,
					yOffset: h
				};
			}
		}
		return n;
	};
}, "getBoundingBoxForLabel");
function YK(e) {
	var t = e.render;
	e.render = function(r) {
		r = r || {};
		var i = e.cy;
		e.webgl && (i.zoom() > 7.99 ? (YZ(e), t.call(e, r)) : (YQ(e), Y7(e, r, YG)));
	};
	var r = e.matchCanvasSize;
	e.matchCanvasSize = function(t) {
		r.call(e, t), e.pickingFrameBuffer.setFramebufferAttachmentSizes(e.canvasWidth, e.canvasHeight), e.pickingFrameBuffer.needsDraw = !0;
	}, e.findNearestElements = function(t, r, i, n) {
		return Y3(e, t, r);
	};
	var i = e.invalidateCachedZSortedEles;
	e.invalidateCachedZSortedEles = function() {
		i.call(e), e.pickingFrameBuffer.needsDraw = !0;
	};
	var n = e.notify;
	e.notify = function(t, r) {
		n.call(e, t, r), "viewport" === t || "bounds" === t ? e.pickingFrameBuffer.needsDraw = !0 : "background" === t && e.drawing.invalidate(r, { type: "node-body" });
	};
}
function YZ(e) {
	var t = e.data.contexts[e.WEBGL];
	t.clear(t.COLOR_BUFFER_BIT | t.DEPTH_BUFFER_BIT);
}
function YQ(e) {
	var t = h(function(t) {
		t.save(), t.setTransform(1, 0, 0, 1, 0, 0), t.clearRect(0, 0, e.canvasWidth, e.canvasHeight), t.restore();
	}, "clear");
	t(e.data.contexts[e.NODE]), t(e.data.contexts[e.DRAG]);
}
function YJ(e) {
	var t = e.canvasWidth, r = e.canvasHeight, i = Yc(e), n = i.pan, a = i.zoom, s = YC();
	YL(s, s, [n.x, n.y]), YN(s, s, [a, a]);
	var o = YC();
	YI(o, t, r);
	var l = YC();
	return YA(l, o, s), l;
}
function Y0(e, t) {
	var r = e.canvasWidth, i = e.canvasHeight, n = Yc(e), a = n.pan, s = n.zoom;
	t.setTransform(1, 0, 0, 1, 0, 0), t.clearRect(0, 0, r, i), t.translate(a.x, a.y), t.scale(s, s);
}
function Y1(e, t) {
	e.drawSelectionRectangle(t, function(t) {
		return Y0(e, t);
	});
}
function Y2(e) {
	var t = e.data.contexts[e.NODE];
	t.save(), Y0(e, t), t.strokeStyle = "rgba(0, 0, 0, 0.3)", t.beginPath(), t.moveTo(-1e3, 0), t.lineTo(1e3, 0), t.stroke(), t.beginPath(), t.moveTo(0, -1e3), t.lineTo(0, 1e3), t.stroke(), t.restore();
}
function Y4(e) {
	var t = h(function(t, r, i) {
		for (var n = t.atlasManager.getAtlasCollection(r), a = e.data.contexts[e.NODE], s = n.atlases, o = 0; o < s.length; o++) {
			var l = s[o].canvas;
			if (l) {
				var h = l.width, u = l.height, d = h * o, p = l.height * i;
				a.save(), a.scale(.4, .4), a.drawImage(l, d, p), a.strokeStyle = "black", a.rect(d, p, h, u), a.stroke(), a.restore();
			}
		}
	}, "draw"), r = 0;
	t(e.drawing, "node", r++), t(e.drawing, "label", r++);
}
function Y5(e, t, r, i, n) {
	var a = Yc(e), s = DR(Yu(e, a.pan, a.zoom, t, r), 2), o = s[0], l = s[1], h = e.data.contexts[e.WEBGL];
	h.bindFramebuffer(h.FRAMEBUFFER, e.pickingFrameBuffer), e.pickingFrameBuffer.needsDraw && (h.viewport(0, 0, h.canvas.width, h.canvas.height), Y7(e, null, Yq), e.pickingFrameBuffer.needsDraw = !1);
	var u = new Uint8Array(144);
	h.readPixels(o - 3, l - 3, 6, 6, h.RGBA, h.UNSIGNED_BYTE, u), h.bindFramebuffer(h.FRAMEBUFFER, null);
	for (var d = /* @__PURE__ */ new Set(), p = 0; p < 36; p++) {
		var f = Ym(u.slice(4 * p, 4 * p + 4)) - 1;
		f >= 0 && d.add(f);
	}
	return d;
}
function Y3(e, t, r) {
	var i, n, a, s = Y5(e, t, r), o = e.getCachedZSortedEles(), l = D_(s);
	try {
		for (l.s(); !(a = l.n()).done;) {
			var h = o[a.value];
			if (!i && h.isNode() && (i = h), !n && h.isEdge() && (n = h), i && n) break;
		}
	} catch (e) {
		l.e(e);
	} finally {
		l.f();
	}
	return [i, n].filter(Boolean);
}
function Y6(e, t, r) {
	var i = e.drawing;
	t += 1, r.isNode() ? (i.drawNode(r, t, "node-underlay"), i.drawNode(r, t, "node-body"), i.drawTexture(r, t, "label"), i.drawNode(r, t, "node-overlay")) : (i.drawEdgeLine(r, t), i.drawEdgeArrow(r, t, "source"), i.drawEdgeArrow(r, t, "target"), i.drawTexture(r, t, "label"), i.drawTexture(r, t, "edge-source-label"), i.drawTexture(r, t, "edge-target-label"));
}
function Y7(e, t, r) {
	e.webglDebug && (g = performance.now());
	var i = e.drawing, n = 0;
	if (r.screen && e.data.canvasNeedsRedraw[e.SELECT_BOX] && Y1(e, t), e.data.canvasNeedsRedraw[e.NODE] || r.picking) {
		var a = e.data.contexts[e.WEBGL];
		r.screen ? (a.clearColor(0, 0, 0, 0), a.enable(a.BLEND), a.blendFunc(a.ONE, a.ONE_MINUS_SRC_ALPHA)) : a.disable(a.BLEND), a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT), a.viewport(0, 0, a.canvas.width, a.canvas.height);
		var s = YJ(e), o = e.getCachedZSortedEles();
		if (n = o.length, i.startFrame(s, r), r.screen) {
			for (var l = 0; l < o.nondrag.length; l++) Y6(e, l, o.nondrag[l]);
			for (var h = 0; h < o.drag.length; h++) Y6(e, h, o.drag[h]);
		} else if (r.picking) for (var u = 0; u < o.length; u++) Y6(e, u, o[u]);
		i.endFrame(), r.screen && e.webglDebugShowAtlases && (Y2(e), Y4(e)), e.data.canvasNeedsRedraw[e.NODE] = !1, e.data.canvasNeedsRedraw[e.DRAG] = !1;
	}
	if (e.webglDebug) {
		var d = Math.ceil(performance.now() - g), p = i.getDebugInfo(), f = [
			"".concat(n, " elements"),
			"".concat(p.totalInstances, " instances"),
			"".concat(p.batchCount, " batches"),
			"".concat(p.totalAtlases, " atlases"),
			"".concat(p.wrappedCount, " wrapped textures"),
			"".concat(p.simpleCount, " simple shapes")
		].join(", ");
		console.log("WebGL (".concat(r.name, ") - frame time ").concat(d, "ms")), console.log("Totals:"), console.log("  ".concat(f)), console.log("Texture Atlases Used:");
		var g, m, y = D_(p.atlasInfo);
		try {
			for (y.s(); !(m = y.n()).done;) {
				var v = m.value;
				console.log("  ".concat(v.type, ": ").concat(v.keyCount, " keys, ").concat(v.atlasCount, " atlases"));
			}
		} catch (e) {
			y.e(e);
		} finally {
			y.f();
		}
		console.log("");
	}
	e.data.gc && (console.log("Garbage Collect!"), e.data.gc = !1, i.gc());
}
h(YK, "overrideCanvasRendererFunctions"), h(YZ, "clearWebgl"), h(YQ, "clearCanvas"), h(YJ, "createPanZoomMatrix"), h(Y0, "setContextTransform"), h(Y1, "drawSelectionRectangle"), h(Y2, "drawAxes"), h(Y4, "drawAtlases"), h(Y5, "getPickingIndexes"), h(Y3, "findNearestElementsWebgl"), h(Y6, "drawEle"), h(Y7, "renderWebgl");
var Y8 = {};
Y8.drawPolygonPath = function(e, t, r, i, n, a) {
	var s = i / 2, o = n / 2;
	e.beginPath && e.beginPath(), e.moveTo(t + s * a[0], r + o * a[1]);
	for (var l = 1; l < a.length / 2; l++) e.lineTo(t + s * a[2 * l], r + o * a[2 * l + 1]);
	e.closePath();
}, Y8.drawRoundPolygonPath = function(e, t, r, i, n, a, s) {
	s.forEach(function(t) {
		return Wd(e, t);
	}), e.closePath();
}, Y8.drawRoundRectanglePath = function(e, t, r, i, n, a) {
	var s = i / 2, o = n / 2, l = "auto" === a ? Be(i, n) : Math.min(a, o, s);
	e.beginPath && e.beginPath(), e.moveTo(t, r - o), e.arcTo(t + s, r - o, t + s, r, l), e.arcTo(t + s, r + o, t, r + o, l), e.arcTo(t - s, r + o, t - s, r, l), e.arcTo(t - s, r - o, t, r - o, l), e.lineTo(t, r - o), e.closePath();
}, Y8.drawBottomRoundRectanglePath = function(e, t, r, i, n, a) {
	var s = i / 2, o = n / 2, l = "auto" === a ? Be(i, n) : a;
	e.beginPath && e.beginPath(), e.moveTo(t, r - o), e.lineTo(t + s, r - o), e.lineTo(t + s, r), e.arcTo(t + s, r + o, t, r + o, l), e.arcTo(t - s, r + o, t - s, r, l), e.lineTo(t - s, r - o), e.lineTo(t, r - o), e.closePath();
}, Y8.drawCutRectanglePath = function(e, t, r, i, n, a, s) {
	var o = i / 2, l = n / 2, h = "auto" === s ? Br() : s;
	e.beginPath && e.beginPath(), e.moveTo(t - o + h, r - l), e.lineTo(t + o - h, r - l), e.lineTo(t + o, r - l + h), e.lineTo(t + o, r + l - h), e.lineTo(t + o - h, r + l), e.lineTo(t - o + h, r + l), e.lineTo(t - o, r + l - h), e.lineTo(t - o, r - l + h), e.closePath();
}, Y8.drawBarrelPath = function(e, t, r, i, n) {
	var a = i / 2, s = n / 2, o = t - a, l = t + a, h = r - s, u = r + s, d = Bn(i, n), p = d.widthOffset, f = d.heightOffset, g = d.ctrlPtOffsetPct * p;
	e.beginPath && e.beginPath(), e.moveTo(o, h + f), e.lineTo(o, u - f), e.quadraticCurveTo(o + g, u, o + p, u), e.lineTo(l - p, u), e.quadraticCurveTo(l - g, u, l, u - f), e.lineTo(l, h + f), e.quadraticCurveTo(l - g, h, l - p, h), e.lineTo(o + p, h), e.quadraticCurveTo(o + g, h, o, h + f), e.closePath();
};
var Y9 = {}, Ve = {}, Vt = Math.PI / 40;
for (VK = 0 * Math.PI; VK < 2 * Math.PI; VK += Vt) Y9[VK] = Math.sin(VK), Ve[VK] = Math.cos(VK);
Y8.drawEllipsePath = function(e, t, r, i, n) {
	if (e.beginPath && e.beginPath(), e.ellipse) e.ellipse(t, r, i / 2, n / 2, 0, 0, 2 * Math.PI);
	else for (var a, s, o = i / 2, l = n / 2, h = 0 * Math.PI; h < 2 * Math.PI; h += Vt) a = t - o * Y9[h] * 0 + o * Ve[h] * 1, s = r + l * Ve[h] * 0 + l * Y9[h] * 1, 0 === h ? e.moveTo(a, s) : e.lineTo(a, s);
	e.closePath();
};
var Vr = {};
function Vi(e, t) {
	for (var r = atob(e), i = new ArrayBuffer(r.length), n = new Uint8Array(i), a = 0; a < r.length; a++) n[a] = r.charCodeAt(a);
	return new Blob([i], { type: t });
}
function Vn(e) {
	var t = e.indexOf(",");
	return e.substr(t + 1);
}
function Va(e, t, r) {
	var i = h(function() {
		return t.toDataURL(r, e.quality);
	}, "getB64Uri");
	switch (e.output) {
		case "blob-promise": return new Fm(function(i, n) {
			try {
				t.toBlob(function(e) {
					null != e ? i(e) : n(Error("`canvas.toBlob()` sent a null value in its callback"));
				}, r, e.quality);
			} catch (e) {
				n(e);
			}
		});
		case "blob": return Vi(Vn(i()), r);
		case "base64": return Vn(i());
		default: return i();
	}
}
Vr.createBuffer = function(e, t) {
	var r = document.createElement("canvas");
	return r.width = e, r.height = t, [r, r.getContext("2d")];
}, Vr.bufferCanvasImage = function(e) {
	var t = this.cy, r = t.mutableElements().boundingBox(), i = this.findContainerClientCoords(), n = e.full ? Math.ceil(r.w) : i[2], a = e.full ? Math.ceil(r.h) : i[3], s = DH(e.maxWidth) || DH(e.maxHeight), o = this.getPixelRatio(), l = 1;
	if (void 0 !== e.scale) n *= e.scale, a *= e.scale, l = e.scale;
	else if (s) {
		var h = Infinity, u = Infinity;
		DH(e.maxWidth) && (h = l * e.maxWidth / n), DH(e.maxHeight) && (u = l * e.maxHeight / a), n *= l = Math.min(h, u), a *= l;
	}
	s || (n *= o, a *= o, l *= o);
	var d = document.createElement("canvas");
	d.width = n, d.height = a, d.style.width = n + "px", d.style.height = a + "px";
	var p = d.getContext("2d");
	if (n > 0 && a > 0) {
		p.clearRect(0, 0, n, a), p.globalCompositeOperation = "source-over";
		var f = this.getCachedZSortedEles();
		if (e.full) p.translate(-r.x1 * l, -r.y1 * l), p.scale(l, l), this.drawElements(p, f), p.scale(1 / l, 1 / l), p.translate(r.x1 * l, r.y1 * l);
		else {
			var g = t.pan(), m = {
				x: g.x * l,
				y: g.y * l
			};
			l *= t.zoom(), p.translate(m.x, m.y), p.scale(l, l), this.drawElements(p, f), p.scale(1 / l, 1 / l), p.translate(-m.x, -m.y);
		}
		e.bg && (p.globalCompositeOperation = "destination-over", p.fillStyle = e.bg, p.rect(0, 0, n, a), p.fill());
	}
	return d;
}, h(Vi, "b64ToBlob"), h(Vn, "b64UriToB64"), h(Va, "output"), Vr.png = function(e) {
	return Va(e, this.bufferCanvasImage(e), "image/png");
}, Vr.jpg = function(e) {
	return Va(e, this.bufferCanvasImage(e), "image/jpeg");
};
var Vs = {};
Vs.nodeShapeImpl = function(e, t, r, i, n, a, s, o) {
	switch (e) {
		case "ellipse": return this.drawEllipsePath(t, r, i, n, a);
		case "polygon": return this.drawPolygonPath(t, r, i, n, a, s);
		case "round-polygon": return this.drawRoundPolygonPath(t, r, i, n, a, s, o);
		case "roundrectangle":
		case "round-rectangle": return this.drawRoundRectanglePath(t, r, i, n, a, o);
		case "cutrectangle":
		case "cut-rectangle": return this.drawCutRectanglePath(t, r, i, n, a, s, o);
		case "bottomroundrectangle":
		case "bottom-round-rectangle": return this.drawBottomRoundRectanglePath(t, r, i, n, a, o);
		case "barrel": return this.drawBarrelPath(t, r, i, n, a);
	}
};
var Vo = Vl.prototype;
function Vl(e) {
	var t = this, r = t.cy.window().document;
	e.webgl && (Vo.CANVAS_LAYERS = t.CANVAS_LAYERS = 4, console.log("webgl rendering enabled")), t.data = {
		canvases: Array(Vo.CANVAS_LAYERS),
		contexts: Array(Vo.CANVAS_LAYERS),
		canvasNeedsRedraw: Array(Vo.CANVAS_LAYERS),
		bufferCanvases: Array(Vo.BUFFER_COUNT),
		bufferContexts: Array(Vo.CANVAS_LAYERS)
	};
	var i = "-webkit-tap-highlight-color", n = "rgba(0,0,0,0)";
	t.data.canvasContainer = r.createElement("div");
	var a = t.data.canvasContainer.style;
	t.data.canvasContainer.style[i] = n, a.position = "relative", a.zIndex = "0", a.overflow = "hidden";
	var s = e.cy.container();
	s.appendChild(t.data.canvasContainer), s.style[i] = n;
	var o = {
		"-webkit-user-select": "none",
		"-moz-user-select": "-moz-none",
		"user-select": "none",
		"-webkit-tap-highlight-color": "rgba(0,0,0,0)",
		"outline-style": "none"
	};
	D7() && (o["-ms-touch-action"] = "none", o["touch-action"] = "none");
	for (var l = 0; l < Vo.CANVAS_LAYERS; l++) {
		var u = t.data.canvases[l] = r.createElement("canvas"), d = Vo.CANVAS_TYPES[l];
		t.data.contexts[l] = u.getContext(d), t.data.contexts[l] || O8("Could not create canvas of type " + d), Object.keys(o).forEach(function(e) {
			u.style[e] = o[e];
		}), u.style.position = "absolute", u.setAttribute("data-id", "layer" + l), u.style.zIndex = String(Vo.CANVAS_LAYERS - l), t.data.canvasContainer.appendChild(u), t.data.canvasNeedsRedraw[l] = !1;
	}
	t.data.topCanvas = t.data.canvases[0], t.data.canvases[Vo.NODE].setAttribute("data-id", "layer" + Vo.NODE + "-node"), t.data.canvases[Vo.SELECT_BOX].setAttribute("data-id", "layer" + Vo.SELECT_BOX + "-selectbox"), t.data.canvases[Vo.DRAG].setAttribute("data-id", "layer" + Vo.DRAG + "-drag"), t.data.canvases[Vo.WEBGL] && t.data.canvases[Vo.WEBGL].setAttribute("data-id", "layer" + Vo.WEBGL + "-webgl");
	for (var l = 0; l < Vo.BUFFER_COUNT; l++) t.data.bufferCanvases[l] = r.createElement("canvas"), t.data.bufferContexts[l] = t.data.bufferCanvases[l].getContext("2d"), t.data.bufferCanvases[l].style.position = "absolute", t.data.bufferCanvases[l].setAttribute("data-id", "buffer" + l), t.data.bufferCanvases[l].style.zIndex = String(-l - 1), t.data.bufferCanvases[l].style.visibility = "hidden";
	t.pathsEnabled = !0;
	var p = PE(), f = h(function(e) {
		return {
			x: (e.x1 + e.x2) / 2,
			y: (e.y1 + e.y2) / 2
		};
	}, "getBoxCenter"), g = h(function(e) {
		return {
			x: -e.w / 2,
			y: -e.h / 2
		};
	}, "getCenterOffset"), m = h(function(e) {
		var t = e[0]._private;
		return t.oldBackgroundTimestamp !== t.backgroundTimestamp;
	}, "backgroundTimestampHasChanged"), y = h(function(e) {
		return e[0]._private.nodeKey;
	}, "getStyleKey"), v = h(function(e) {
		return e[0]._private.labelStyleKey;
	}, "getLabelKey"), x = h(function(e) {
		return e[0]._private.sourceLabelStyleKey;
	}, "getSourceLabelKey"), b = h(function(e) {
		return e[0]._private.targetLabelStyleKey;
	}, "getTargetLabelKey"), w = h(function(e, r, i, n, a) {
		return t.drawElement(e, r, i, !1, !1, a);
	}, "drawElement"), k = h(function(e, r, i, n, a) {
		return t.drawElementText(e, r, i, n, "main", a);
	}, "drawLabel"), T = h(function(e, r, i, n, a) {
		return t.drawElementText(e, r, i, n, "source", a);
	}, "drawSourceLabel"), _ = h(function(e, r, i, n, a) {
		return t.drawElementText(e, r, i, n, "target", a);
	}, "drawTargetLabel"), E = h(function(e) {
		return e.boundingBox(), e[0]._private.bodyBounds;
	}, "getElementBox"), C = h(function(e) {
		return e.boundingBox(), e[0]._private.labelBounds.main || p;
	}, "getLabelBox"), S = h(function(e) {
		return e.boundingBox(), e[0]._private.labelBounds.source || p;
	}, "getSourceLabelBox"), A = h(function(e) {
		return e.boundingBox(), e[0]._private.labelBounds.target || p;
	}, "getTargetLabelBox"), L = h(function(e, t) {
		return t;
	}, "isLabelVisibleAtScale"), R = h(function(e) {
		return f(E(e));
	}, "getElementRotationPoint"), N = h(function(e, t, r) {
		var i = e ? e + "-" : "";
		return {
			x: t.x + r.pstyle(i + "text-margin-x").pfValue,
			y: t.y + r.pstyle(i + "text-margin-y").pfValue
		};
	}, "addTextMargin"), I = h(function(e, t, r) {
		var i = e[0]._private.rscratch;
		return {
			x: i[t],
			y: i[r]
		};
	}, "getRsPt"), M = h(function(e) {
		return N("", I(e, "labelX", "labelY"), e);
	}, "getLabelRotationPoint"), D = h(function(e) {
		return N("source", I(e, "sourceLabelX", "sourceLabelY"), e);
	}, "getSourceLabelRotationPoint"), O = h(function(e) {
		return N("target", I(e, "targetLabelX", "targetLabelY"), e);
	}, "getTargetLabelRotationPoint"), $ = h(function(e) {
		return g(E(e));
	}, "getElementRotationOffset"), P = h(function(e) {
		return g(S(e));
	}, "getSourceLabelRotationOffset"), B = h(function(e) {
		return g(A(e));
	}, "getTargetLabelRotationOffset"), F = h(function(e) {
		var t = C(e), r = g(C(e));
		if (e.isNode()) {
			switch (e.pstyle("text-halign").value) {
				case "left":
					r.x = -t.w - (t.leftPad || 0);
					break;
				case "right": r.x = -(t.rightPad || 0);
			}
			switch (e.pstyle("text-valign").value) {
				case "top":
					r.y = -t.h - (t.topPad || 0);
					break;
				case "bottom": r.y = -(t.botPad || 0);
			}
		}
		return r;
	}, "getLabelRotationOffset"), z = t.data.eleTxrCache = new WU(t, {
		getKey: y,
		doesEleInvalidateKey: m,
		drawElement: w,
		getBoundingBox: E,
		getRotationPoint: R,
		getRotationOffset: $,
		allowEdgeTxrCaching: !1,
		allowParentTxrCaching: !1
	}), U = t.data.lblTxrCache = new WU(t, {
		getKey: v,
		drawElement: k,
		getBoundingBox: C,
		getRotationPoint: M,
		getRotationOffset: F,
		isVisible: L
	}), G = t.data.slbTxrCache = new WU(t, {
		getKey: x,
		drawElement: T,
		getBoundingBox: S,
		getRotationPoint: D,
		getRotationOffset: P,
		isVisible: L
	}), q = t.data.tlbTxrCache = new WU(t, {
		getKey: b,
		drawElement: _,
		getBoundingBox: A,
		getRotationPoint: O,
		getRotationOffset: B,
		isVisible: L
	}), j = t.data.lyrTxrCache = new Wj(t);
	t.onUpdateEleCalcs(h(function(e, t) {
		z.invalidateElements(t), U.invalidateElements(t), G.invalidateElements(t), q.invalidateElements(t), j.invalidateElements(t);
		for (var r = 0; r < t.length; r++) {
			var i = t[r]._private;
			i.oldBackgroundTimestamp = i.backgroundTimestamp;
		}
	}, "invalidateTextureCaches"));
	var W = h(function(e) {
		for (var t = 0; t < e.length; t++) j.enqueueElementRefinement(e[t].ele);
	}, "refineInLayers");
	z.onDequeue(W), U.onDequeue(W), G.onDequeue(W), q.onDequeue(W), e.webgl && t.initWebgl(e, {
		getStyleKey: y,
		getLabelKey: v,
		getSourceLabelKey: x,
		getTargetLabelKey: b,
		drawElement: w,
		drawLabel: k,
		drawSourceLabel: T,
		drawTargetLabel: _,
		getElementBox: E,
		getLabelBox: C,
		getSourceLabelBox: S,
		getTargetLabelBox: A,
		getElementRotationPoint: R,
		getElementRotationOffset: $,
		getLabelRotationPoint: M,
		getSourceLabelRotationPoint: D,
		getTargetLabelRotationPoint: O,
		getLabelRotationOffset: F,
		getSourceLabelRotationOffset: P,
		getTargetLabelRotationOffset: B
	});
}
Vo.CANVAS_LAYERS = 3, Vo.SELECT_BOX = 0, Vo.DRAG = 1, Vo.NODE = 2, Vo.WEBGL = 3, Vo.CANVAS_TYPES = [
	"2d",
	"2d",
	"2d",
	"webgl2"
], Vo.BUFFER_COUNT = 3, Vo.TEXTURE_BUFFER = 0, Vo.MOTIONBLUR_BUFFER_NODE = 1, Vo.MOTIONBLUR_BUFFER_DRAG = 2, h(Vl, "CanvasRenderer"), Vo.redrawHint = function(e, t) {
	switch (e) {
		case "eles":
			this.data.canvasNeedsRedraw[Vo.NODE] = t;
			break;
		case "drag":
			this.data.canvasNeedsRedraw[Vo.DRAG] = t;
			break;
		case "select":
			this.data.canvasNeedsRedraw[Vo.SELECT_BOX] = t;
			break;
		case "gc": this.data.gc = !0;
	}
};
var Vc = "u" > typeof Path2D;
Vo.path2dEnabled = function(e) {
	if (void 0 === e) return this.pathsEnabled;
	this.pathsEnabled = !!e;
}, Vo.usePaths = function() {
	return Vc && this.pathsEnabled;
}, Vo.setImgSmoothing = function(e, t) {
	null != e.imageSmoothingEnabled ? e.imageSmoothingEnabled = t : (e.webkitImageSmoothingEnabled = t, e.mozImageSmoothingEnabled = t, e.msImageSmoothingEnabled = t);
}, Vo.getImgSmoothing = function(e) {
	return null != e.imageSmoothingEnabled ? e.imageSmoothingEnabled : e.webkitImageSmoothingEnabled || e.mozImageSmoothingEnabled || e.msImageSmoothingEnabled;
}, Vo.makeOffscreenCanvas = function(e, t) {
	var r;
	return (typeof OffscreenCanvas > "u" ? "undefined" : DD(OffscreenCanvas)) !== "undefined" ? r = new OffscreenCanvas(e, t) : ((r = this.cy.window().document.createElement("canvas")).width = e, r.height = t), r;
}, [
	WH,
	W0,
	W7,
	W9,
	Ye,
	Yi,
	Ya,
	YW,
	Y8,
	Vr,
	Vs
].forEach(function(e) {
	Ou(Vo, e);
});
var Vh = [{
	type: "layout",
	extensions: jV
}, {
	type: "renderer",
	extensions: [
		{
			name: "null",
			impl: jH
		},
		{
			name: "base",
			impl: WD
		},
		{
			name: "canvas",
			impl: Vl
		}
	]
}], Vu = {}, Vd = {};
function Vp(e, t, r) {
	var i = r, n = h(function(r) {
		$e("Can not register `" + t + "` for `" + e + "` since `" + r + "` already exists in the prototype and can not be overridden");
	}, "overrideErr");
	if ("core" === e) {
		if (ja.prototype[t]) return n(t);
		ja.prototype[t] = r;
	} else if ("collection" === e) {
		if (qI.prototype[t]) return n(t);
		qI.prototype[t] = r;
	} else if ("layout" === e) {
		for (var a = h(function(e) {
			this.options = e, r.call(this, e), DY(this._private) || (this._private = {}), this._private.cy = e.cy, this._private.listeners = [], this.createEmitter();
		}, "Layout"), s = a.prototype = Object.create(r.prototype), o = [], l = 0; l < o.length; l++) {
			var u = o[l];
			s[u] = s[u] || function() {
				return this;
			};
		}
		s.start && !s.run ? s.run = function() {
			return this.start(), this;
		} : !s.start && s.run && (s.start = function() {
			return this.run(), this;
		});
		var d = r.prototype.stop;
		s.stop = function() {
			var e = this.options;
			if (e && e.animate) {
				var t = this.animations;
				if (t) for (var r = 0; r < t.length; r++) t[r].stop();
			}
			return d ? d.call(this) : this.emit("layoutstop"), this;
		}, s.destroy || (s.destroy = function() {
			return this;
		}), s.cy = function() {
			return this._private.cy;
		};
		var p = h(function(e) {
			return e._private.cy;
		}, "getCy"), f = {
			addEventFields: h(function(e, t) {
				t.layout = e, t.cy = p(e), t.target = e;
			}, "addEventFields"),
			bubble: h(function() {
				return !0;
			}, "bubble"),
			parent: h(function(e) {
				return p(e);
			}, "parent")
		};
		Ou(s, {
			createEmitter: h(function() {
				return this._private.emitter = new qt(f, this), this;
			}, "createEmitter"),
			emitter: h(function() {
				return this._private.emitter;
			}, "emitter"),
			on: h(function(e, t) {
				return this.emitter().on(e, t), this;
			}, "on"),
			one: h(function(e, t) {
				return this.emitter().one(e, t), this;
			}, "one"),
			once: h(function(e, t) {
				return this.emitter().one(e, t), this;
			}, "once"),
			removeListener: h(function(e, t) {
				return this.emitter().removeListener(e, t), this;
			}, "removeListener"),
			removeAllListeners: h(function() {
				return this.emitter().removeAllListeners(), this;
			}, "removeAllListeners"),
			emit: h(function(e, t) {
				return this.emitter().emit(e, t), this;
			}, "emit")
		}), UH.eventAliasesOn(s), i = a;
	} else if ("renderer" === e && "null" !== t && "base" !== t) {
		var g = Vf("renderer", "base"), m = g.prototype, y = r.prototype, v = h(function() {
			g.apply(this, arguments), r.apply(this, arguments);
		}, "Renderer"), x = v.prototype;
		for (var b in m) {
			var w = m[b];
			if (null != y[b]) return n(b);
			x[b] = w;
		}
		for (var k in y) x[k] = y[k];
		m.clientFunctions.forEach(function(e) {
			x[e] = x[e] || function() {
				O8("Renderer does not implement `renderer." + e + "()` on its prototype");
			};
		}), i = v;
	} else if ("__proto__" === e || "constructor" === e || "prototype" === e) return O8(e + " is an illegal type to be registered, possibly lead to prototype pollutions");
	return Ov({
		map: Vu,
		keys: [e, t],
		value: i
	});
}
function Vf(e, t) {
	return Ox({
		map: Vu,
		keys: [e, t]
	});
}
function Vg(e, t, r, i, n) {
	return Ov({
		map: Vd,
		keys: [
			e,
			t,
			r,
			i
		],
		value: n
	});
}
function Vm(e, t, r, i) {
	return Ox({
		map: Vd,
		keys: [
			e,
			t,
			r,
			i
		]
	});
}
h(Vp, "setExtension"), h(Vf, "getExtension"), h(Vg, "setModule"), h(Vm, "getModule");
var Vy = h(function() {
	return 2 == arguments.length ? Vf.apply(null, arguments) : 3 == arguments.length ? Vp.apply(null, arguments) : 4 == arguments.length ? Vm.apply(null, arguments) : 5 == arguments.length ? Vg.apply(null, arguments) : void O8("Invalid extension access syntax");
}, "extension");
ja.prototype.extension = Vy, Vh.forEach(function(e) {
	e.extensions.forEach(function(t) {
		Vp(e.type, t.name, t.impl);
	});
});
var Vv = h(function() {
	if (!(this instanceof Vv)) return new Vv();
	this.length = 0;
}, "Stylesheet"), Vx = Vv.prototype;
Vx.instanceString = function() {
	return "stylesheet";
}, Vx.selector = function(e) {
	return this[this.length++] = {
		selector: e,
		properties: []
	}, this;
}, Vx.css = function(e, t) {
	var r = this.length - 1;
	if (Dq(e)) this[r].properties.push({
		name: e,
		value: t
	});
	else if (DY(e)) for (var i = Object.keys(e), n = 0; n < i.length; n++) {
		var a = i[n], s = e[a];
		if (null != s) {
			var o = je.properties[a] || je.properties[Oe(a)];
			if (null != o) {
				var l = o.name;
				this[r].properties.push({
					name: l,
					value: s
				});
			}
		}
	}
	return this;
}, Vx.style = Vx.css, Vx.generateStyle = function(e) {
	var t = new je(e);
	return this.appendToStyle(t);
}, Vx.appendToStyle = function(e) {
	for (var t = 0; t < this.length; t++) {
		var r = this[t], i = r.selector, n = r.properties;
		e.selector(i);
		for (var a = 0; a < n.length; a++) {
			var s = n[a];
			e.css(s.name, s.value);
		}
	}
	return e;
};
var Vb = h(function(e) {
	return (void 0 === e && (e = {}), DY(e)) ? new ja(e) : Dq(e) ? Vy.apply(Vy, arguments) : void 0;
}, "cytoscape");
Vb.use = function(e) {
	var t = Array.prototype.slice.call(arguments, 1);
	return t.unshift(Vb), e.apply(null, t), this;
}, Vb.warnings = function(e) {
	return O9(e);
}, Vb.version = "3.33.1", Vb.stylesheet = Vb.Stylesheet = Vv;
var Vw = u((e) => {
	Object.defineProperty(e, "__esModule", { value: !0 }), e.BLANK_URL = e.relativeFirstCharacters = e.whitespaceEscapeCharsRegex = e.urlSchemeRegex = e.ctrlCharactersRegex = e.htmlCtrlEntityRegex = e.htmlEntitiesRegex = e.invalidProtocolRegex = void 0, e.invalidProtocolRegex = /^([^\w]*)(javascript|data|vbscript)/im, e.htmlEntitiesRegex = /&#(\w+)(^\w|;)?/g, e.htmlCtrlEntityRegex = /&(newline|tab);/gi, e.ctrlCharactersRegex = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim, e.urlSchemeRegex = /^.+(:|&colon;)/gim, e.whitespaceEscapeCharsRegex = /(\\|%5[cC])((%(6[eE]|72|74))|[nrt])/g, e.relativeFirstCharacters = [".", "/"], e.BLANK_URL = "about:blank";
}), Vk = u((e) => {
	Object.defineProperty(e, "__esModule", { value: !0 }), e.sanitizeUrl = void 0;
	var t = Vw();
	function r(e) {
		return t.relativeFirstCharacters.indexOf(e[0]) > -1;
	}
	function i(e) {
		return e.replace(t.ctrlCharactersRegex, "").replace(t.htmlEntitiesRegex, function(e, t) {
			return String.fromCharCode(t);
		});
	}
	function n(e) {
		return URL.canParse(e);
	}
	function a(e) {
		try {
			return decodeURIComponent(e);
		} catch {
			return e;
		}
	}
	function s(e) {
		if (!e) return t.BLANK_URL;
		var s, o = a(e.trim());
		do
			s = (o = a(o = i(o).replace(t.htmlCtrlEntityRegex, "").replace(t.ctrlCharactersRegex, "").replace(t.whitespaceEscapeCharsRegex, "").trim())).match(t.ctrlCharactersRegex) || o.match(t.htmlEntitiesRegex) || o.match(t.htmlCtrlEntityRegex) || o.match(t.whitespaceEscapeCharsRegex);
		while (s && s.length > 0);
		var l = o;
		if (!l) return t.BLANK_URL;
		if (r(l)) return l;
		var h = l.trimStart(), u = h.match(t.urlSchemeRegex);
		if (!u) return l;
		var d = u[0].toLowerCase().trim();
		if (t.invalidProtocolRegex.test(d)) return t.BLANK_URL;
		var p = h.replace(/\\/g, "/");
		if ("mailto:" === d || d.includes("://")) return p;
		if ("http:" === d || "https:" === d) {
			if (!n(p)) return t.BLANK_URL;
			var f = new URL(p);
			return f.protocol = f.protocol.toLowerCase(), f.hostname = f.hostname.toLowerCase(), f.toString();
		}
		return p;
	}
	h(r, "isRelativeUrlWithoutProtocol"), h(i, "decodeHtmlCharacters"), h(n, "isValidUrl"), h(a, "decodeURI"), h(s, "sanitizeUrl"), e.sanitizeUrl = s;
}), VT = g(Vk(), 1), V_ = {
	curveBasis: Li,
	curveBasisClosed: Ls,
	curveBasisOpen: Ll,
	curveBumpX: A9,
	curveBumpY: Le,
	curveBundle: Lh,
	curveCardinalClosed: Lg,
	curveCardinalOpen: Ly,
	curveCardinal: Lp,
	curveCatmullRomClosed: Lk,
	curveCatmullRomOpen: L_,
	curveCatmullRom: Lb,
	curveLinear: A0,
	curveLinearClosed: LC,
	curveMonotoneX: LD,
	curveMonotoneY: LO,
	curveNatural: LB,
	curveStep: Lz,
	curveStepAfter: LG,
	curveStepBefore: LU
}, VE = /\s*(?:(\w+)(?=:):|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi, VC = h(function(e, t) {
	let r = VS(e, /(?:init\b)|(?:initialize\b)/), i = {};
	if (Array.isArray(r)) {
		let e = r.map((e) => e.args);
		Im(e), i = NF(i, [...e]);
	} else i = r.args;
	if (!i) return;
	let n = NO(e, t), a = "config";
	return void 0 !== i[a] && ("flowchart-v2" === n && (n = "flowchart"), i[n] = i[a], delete i[a]), i;
}, "detectInit"), VS = h(function(e, t = null) {
	try {
		let r = RegExp(`[%]{2}(?![{]${VE.source})(?=[}][%]{2}).*
`, "ig");
		e = e.trim().replace(r, "").replace(/'/gm, "\""), wQ.debug(`Detecting diagram directive${null !== t ? " type:" + t : ""} based on the text:${e}`);
		let i, n = [];
		for (; null !== (i = NN.exec(e));) if (i.index === NN.lastIndex && NN.lastIndex++, i && !t || t && i[1]?.match(t) || t && i[2]?.match(t)) {
			let e = i[1] ? i[1] : i[2], t = i[3] ? i[3].trim() : i[4] ? JSON.parse(i[4].trim()) : null;
			n.push({
				type: e,
				args: t
			});
		}
		return 0 === n.length ? {
			type: e,
			args: null
		} : 1 === n.length ? n[0] : n;
	} catch (r) {
		return wQ.error(`ERROR: ${r.message} - Unable to parse directive type: '${t}' based on the text: '${e}'`), {
			type: void 0,
			args: null
		};
	}
}, "detectDirective"), VA = h(function(e) {
	return e.replace(NN, "");
}, "removeDirectives");
function VL(e, t) {
	return e ? V_[`curve${e.charAt(0).toUpperCase() + e.slice(1)}`] ?? t : t;
}
function VR(e, t) {
	let r = e.trim();
	if (r) return "loose" !== t.securityLevel ? (0, VT.sanitizeUrl)(r) : r;
}
h(VL, "interpolateToCurve"), h(VR, "formatUrl");
var VN = h((e, ...t) => {
	let r = e.split("."), i = r.length - 1, n = r[i], a = window;
	for (let t = 0; t < i; t++) if (!(a = a[r[t]])) return void wQ.error(`Function name: ${e} not found in window`);
	a[n](...t);
}, "runFunc");
function VI(e, t) {
	return e && t ? Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2)) : 0;
}
function VM(e) {
	let t, r = 0;
	return e.forEach((e) => {
		r += VI(e, t), t = e;
	}), V$(e, r / 2);
}
function VD(e) {
	return 1 === e.length ? e[0] : VM(e);
}
h(VI, "distance"), h(VM, "traverseEdge"), h(VD, "calcLabelPosition");
var VO = h((e, t = 2) => {
	let r = Math.pow(10, t);
	return Math.round(e * r) / r;
}, "roundNumber"), V$ = h((e, t) => {
	let r, i = t;
	for (let t of e) {
		if (r) {
			let e = VI(t, r);
			if (0 === e) return r;
			if (e < i) i -= e;
			else {
				let n = i / e;
				if (n <= 0) return r;
				if (n >= 1) return {
					x: t.x,
					y: t.y
				};
				if (n > 0 && n < 1) return {
					x: VO((1 - n) * r.x + n * t.x, 5),
					y: VO((1 - n) * r.y + n * t.y, 5)
				};
			}
		}
		r = t;
	}
	throw Error("Could not find a suitable point for the given distance");
}, "calculatePoint");
function VP(e, t, r) {
	let i = structuredClone(r);
	wQ.info("our points", i), "start_left" !== t && "start_right" !== t && i.reverse();
	let n = V$(i, 25 + e), a = 10 + .5 * e, s = Math.atan2(i[0].y - n.y, i[0].x - n.x), o = {
		x: 0,
		y: 0
	};
	return "start_left" === t ? (o.x = Math.sin(s + Math.PI) * a + (i[0].x + n.x) / 2, o.y = -Math.cos(s + Math.PI) * a + (i[0].y + n.y) / 2) : "end_right" === t ? (o.x = Math.sin(s - Math.PI) * a + (i[0].x + n.x) / 2 - 5, o.y = -Math.cos(s - Math.PI) * a + (i[0].y + n.y) / 2 - 5) : "end_left" === t ? (o.x = Math.sin(s) * a + (i[0].x + n.x) / 2 - 5, o.y = -Math.cos(s) * a + (i[0].y + n.y) / 2 - 5) : (o.x = Math.sin(s) * a + (i[0].x + n.x) / 2, o.y = -Math.cos(s) * a + (i[0].y + n.y) / 2), o;
}
function VB(e) {
	let t = "", r = "";
	for (let i of e) void 0 !== i && (i.startsWith("color:") || i.startsWith("text-align:") ? r = r + i + ";" : t = t + i + ";");
	return {
		style: t,
		labelStyle: r
	};
}
h(VP, "calcTerminalLabelPosition"), h(VB, "getStylesFromArray");
var VF = 0, Vz = h(() => (VF++, "id-" + Math.random().toString(36).substr(2, 12) + "-" + VF), "generateId");
function VU(e) {
	let t = "";
	for (let r = 0; r < e; r++) t += "0123456789abcdef".charAt(Math.floor(16 * Math.random()));
	return t;
}
h(VU, "makeRandomHex");
var VG = h((e) => VU(e.length), "random"), Vq = h(function() {
	return {
		x: 0,
		y: 0,
		fill: void 0,
		anchor: "start",
		style: "#666",
		width: 100,
		height: 100,
		textMargin: 0,
		rx: 0,
		ry: 0,
		valign: void 0,
		text: ""
	};
}, "getTextObj"), Vj = h(function(e, t) {
	let r = t.text.replace(M1.lineBreakRegex, " "), [, i] = V4(t.fontSize), n = e.append("text");
	n.attr("x", t.x), n.attr("y", t.y), n.style("text-anchor", t.anchor), n.style("font-family", t.fontFamily), n.style("font-size", i), n.style("font-weight", t.fontWeight), n.attr("fill", t.fill), void 0 !== t.class && n.attr("class", t.class);
	let a = n.append("tspan");
	return a.attr("x", t.x + 2 * t.textMargin), a.attr("fill", t.fill), a.text(r), n;
}, "drawSimpleText"), VW = ey((e, t, r) => {
	if (!e || (r = Object.assign({
		fontSize: 12,
		fontWeight: 400,
		fontFamily: "Arial",
		joinWith: "<br/>"
	}, r), M1.lineBreakRegex.test(e))) return e;
	let i = e.split(" ").filter(Boolean), n = [], a = "";
	return i.forEach((e, s) => {
		let o = VH(`${e} `, r), l = VH(a, r);
		if (o > t) {
			let { hyphenatedStrings: i, remainingWord: s } = VY(e, t, "-", r);
			n.push(a, ...i), a = s;
		} else l + o >= t ? (n.push(a), a = e) : a = [a, e].filter(Boolean).join(" ");
		s + 1 === i.length && n.push(a);
	}), n.filter((e) => "" !== e).join(r.joinWith);
}, (e, t, r) => `${e}${t}${r.fontSize}${r.fontWeight}${r.fontFamily}${r.joinWith}`), VY = ey((e, t, r = "-", i) => {
	i = Object.assign({
		fontSize: 12,
		fontWeight: 400,
		fontFamily: "Arial",
		margin: 0
	}, i);
	let n = [...e], a = [], s = "";
	return n.forEach((e, o) => {
		let l = `${s}${e}`;
		if (VH(l, i) >= t) {
			let e = n.length === o + 1, t = `${l}${r}`;
			a.push(e ? l : t), s = "";
		} else s = l;
	}), {
		hyphenatedStrings: a,
		remainingWord: s
	};
}, (e, t, r = "-", i) => `${e}${t}${r}${i.fontSize}${i.fontWeight}${i.fontFamily}`);
function VV(e, t) {
	return VQ(e, t).height;
}
function VH(e, t) {
	return VQ(e, t).width;
}
h(VV, "calculateTextHeight"), h(VH, "calculateTextWidth");
var VX, VK, VZ, VQ = ey((e, t) => {
	let { fontSize: r = 12, fontFamily: i = "Arial", fontWeight: n = 400 } = t;
	if (!e) return {
		width: 0,
		height: 0
	};
	let [, a] = V4(r), s = e.split(M1.lineBreakRegex), o = [], l = _t("body");
	if (!l.remove) return {
		width: 0,
		height: 0,
		lineHeight: 0
	};
	let h = l.append("svg");
	for (let e of ["sans-serif", i]) {
		let t = 0, r = {
			width: 0,
			height: 0,
			lineHeight: 0
		};
		for (let i of s) {
			let s = Vq();
			s.text = i || "";
			let o = Vj(h, s).style("font-size", a).style("font-weight", n).style("font-family", e), l = (o._groups || o)[0][0].getBBox();
			if (0 === l.width && 0 === l.height) throw Error("svg element not in render tree");
			r.width = Math.round(Math.max(r.width, l.width)), t = Math.round(l.height), r.height += t, r.lineHeight = Math.round(Math.max(r.lineHeight, t));
		}
		o.push(r);
	}
	return h.remove(), o[isNaN(o[1].height) || isNaN(o[1].width) || isNaN(o[1].lineHeight) || o[0].height > o[1].height && o[0].width > o[1].width && o[0].lineHeight > o[1].lineHeight ? 0 : 1];
}, (e, t) => `${e}${t.fontSize}${t.fontWeight}${t.fontFamily}`), VJ = class {
	constructor(e = !1, t) {
		this.count = 0, this.count = t ? t.length : 0, this.next = e ? () => this.count++ : () => Date.now();
	}
	static {
		h(this, "InitIDGenerator");
	}
}, V0 = h(function(e) {
	return VZ = VZ || document.createElement("div"), e = escape(e).replace(/%26/g, "&").replace(/%23/g, "#").replace(/%3B/g, ";"), VZ.innerHTML = e, unescape(VZ.textContent);
}, "entityDecode");
function V1(e) {
	return "str" in e;
}
h(V1, "isDetailedError");
var V2 = h((e, t, r, i) => {
	if (!i) return;
	let n = e.node()?.getBBox();
	n && e.append("text").text(i).attr("text-anchor", "middle").attr("x", n.x + n.width / 2).attr("y", -r).attr("class", t);
}, "insertTitle"), V4 = h((e) => {
	if ("number" == typeof e) return [e, e + "px"];
	let t = parseInt(e ?? "", 10);
	return Number.isNaN(t) ? [void 0, void 0] : e === String(t) ? [t, e + "px"] : [t, e];
}, "parseFontSize");
function V5(e, t) {
	return tB({}, e, t);
}
h(V5, "cleanAndMerge");
var V3 = h(function(e) {
	let t = e;
	return (t = (t = t.replace(/style.*:\S*#.*;/g, function(e) {
		return e.substring(0, e.length - 1);
	})).replace(/classDef.*:\S*#.*;/g, function(e) {
		return e.substring(0, e.length - 1);
	})).replace(/#\w+;/g, function(e) {
		let t = e.substring(1, e.length - 1);
		return /^\+?\d+$/.test(t) ? "" + t + "" : "" + t + "";
	});
}, "encodeEntities"), V6 = h(function(e) {
	return e.replace(//g, "&#").replace(//g, "&").replace(//g, ";");
}, "decodeEntities"), V7 = h((e, t, { counter: r = 0, prefix: i, suffix: n }, a) => a || `${i ? `${i}_` : ""}${e}_${t}_${r}${n ? `_${n}` : ""}`, "getEdgeId");
function V8(e) {
	return e ?? null;
}
function V9(e, t) {
	let r = Math.round(e.x), i = Math.round(e.y), n = t.replace(/(\d+\.\d+)/g, (e) => Math.round(parseFloat(e)).toString());
	return n.includes(r.toString()) || n.includes(i.toString());
}
h(V8, "handleUndefinedAttr"), h(V9, "isLabelCoordinateInPath");
var He = Object.freeze({
	left: 0,
	top: 0,
	width: 16,
	height: 16
}), Ht = Object.freeze({
	rotate: 0,
	vFlip: !1,
	hFlip: !1
}), Hr = Object.freeze({
	...He,
	...Ht
}), Hi = Object.freeze({
	...Hr,
	body: "",
	hidden: !1
}), Hn = Object.freeze({
	...Object.freeze({
		width: null,
		height: null
	}),
	...Ht
}), Ha = h((e, t, r, i = "") => {
	let n = e.split(":");
	if ("@" === e.slice(0, 1)) {
		if (n.length < 2 || n.length > 3) return null;
		i = n.shift().slice(1);
	}
	if (n.length > 3 || !n.length) return null;
	if (n.length > 1) {
		let e = n.pop(), r = n.pop(), a = {
			provider: n.length > 0 ? n[0] : i,
			prefix: r,
			name: e
		};
		return t && !Hs(a) ? null : a;
	}
	let a = n[0], s = a.split("-");
	if (s.length > 1) {
		let e = {
			provider: i,
			prefix: s.shift(),
			name: s.join("-")
		};
		return t && !Hs(e) ? null : e;
	}
	if (r && "" === i) {
		let e = {
			provider: i,
			prefix: "",
			name: a
		};
		return t && !Hs(e, r) ? null : e;
	}
	return null;
}, "stringToIcon"), Hs = h((e, t) => !!e && !!((t && "" === e.prefix || e.prefix) && e.name), "validateIconName");
function Ho(e, t) {
	let r = {};
	!e.hFlip != !t.hFlip && (r.hFlip = !0), !e.vFlip != !t.vFlip && (r.vFlip = !0);
	let i = ((e.rotate || 0) + (t.rotate || 0)) % 4;
	return i && (r.rotate = i), r;
}
function Hl(e, t) {
	let r = Ho(e, t);
	for (let i in Hi) i in Ht ? i in e && !(i in r) && (r[i] = Ht[i]) : i in t ? r[i] = t[i] : i in e && (r[i] = e[i]);
	return r;
}
function Hc(e, t) {
	let r = e.icons, i = e.aliases || Object.create(null), n = Object.create(null);
	function a(e) {
		if (r[e]) return n[e] = [];
		if (!(e in n)) {
			n[e] = null;
			let t = i[e] && i[e].parent, r = t && a(t);
			r && (n[e] = [t].concat(r));
		}
		return n[e];
	}
	return h(a, "resolve"), (t || Object.keys(r).concat(Object.keys(i))).forEach(a), n;
}
function Hh(e, t, r) {
	let i = e.icons, n = e.aliases || Object.create(null), a = {};
	function s(e) {
		a = Hl(i[e] || n[e], a);
	}
	return h(s, "parse"), s(t), r.forEach(s), Hl(e, a);
}
function Hu(e, t) {
	if (e.icons[t]) return Hh(e, t, []);
	let r = Hc(e, [t])[t];
	return r ? Hh(e, t, r) : null;
}
h(Ho, "mergeIconTransformations"), h(Hl, "mergeIconData"), h(Hc, "getIconsTree"), h(Hh, "internalGetIconData"), h(Hu, "getIconData");
var Hd = /(-?[0-9.]*[0-9]+[0-9.]*)/g, Hp = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function Hf(e, t, r) {
	if (1 === t) return e;
	if (r = r || 100, "number" == typeof e) return Math.ceil(e * t * r) / r;
	if ("string" != typeof e) return e;
	let i = e.split(Hd);
	if (null === i || !i.length) return e;
	let n = [], a = i.shift(), s = Hp.test(a);
	for (;;) {
		if (s) {
			let e = parseFloat(a);
			isNaN(e) ? n.push(a) : n.push(Math.ceil(e * t * r) / r);
		} else n.push(a);
		if (void 0 === (a = i.shift())) return n.join("");
		s = !s;
	}
}
function Hg(e, t = "defs") {
	let r = "", i = e.indexOf("<" + t);
	for (; i >= 0;) {
		let n = e.indexOf(">", i), a = e.indexOf("</" + t);
		if (-1 === n || -1 === a) break;
		let s = e.indexOf(">", a);
		if (-1 === s) break;
		r += e.slice(n + 1, a).trim(), e = e.slice(0, i).trim() + e.slice(s + 1);
	}
	return {
		defs: r,
		content: e
	};
}
function Hm(e, t) {
	return e ? "<defs>" + e + "</defs>" + t : t;
}
function Hy(e, t, r) {
	let i = Hg(e);
	return Hm(i.defs, t + i.content + r);
}
h(Hf, "calculateSize"), h(Hg, "splitSVGDefs"), h(Hm, "mergeDefsAndContent"), h(Hy, "wrapSVGContent");
var Hv = h((e) => "unset" === e || "undefined" === e || "none" === e, "isUnsetKeyword");
function Hx(e, t) {
	let r = {
		...Hr,
		...e
	}, i = {
		...Hn,
		...t
	}, n = {
		left: r.left,
		top: r.top,
		width: r.width,
		height: r.height
	}, a = r.body;
	[r, i].forEach((e) => {
		let t, r = [], i = e.hFlip, s = e.vFlip, o = e.rotate;
		switch (i ? s ? o += 2 : (r.push("translate(" + (n.width + n.left).toString() + " " + (0 - n.top).toString() + ")"), r.push("scale(-1 1)"), n.top = n.left = 0) : s && (r.push("translate(" + (0 - n.left).toString() + " " + (n.height + n.top).toString() + ")"), r.push("scale(1 -1)"), n.top = n.left = 0), o < 0 && (o -= 4 * Math.floor(o / 4)), o %= 4) {
			case 1:
				r.unshift("rotate(90 " + (t = n.height / 2 + n.top).toString() + " " + t.toString() + ")");
				break;
			case 2:
				r.unshift("rotate(180 " + (n.width / 2 + n.left).toString() + " " + (n.height / 2 + n.top).toString() + ")");
				break;
			case 3: r.unshift("rotate(-90 " + (t = n.width / 2 + n.left).toString() + " " + t.toString() + ")");
		}
		o % 2 == 1 && (n.left !== n.top && (t = n.left, n.left = n.top, n.top = t), n.width !== n.height && (t = n.width, n.width = n.height, n.height = t)), r.length && (a = Hy(a, "<g transform=\"" + r.join(" ") + "\">", "</g>"));
	});
	let s = i.width, o = i.height, l = n.width, u = n.height, d, p;
	null === s ? d = Hf(p = null === o ? "1em" : "auto" === o ? u : o, l / u) : (d = "auto" === s ? l : s, p = null === o ? Hf(d, u / l) : "auto" === o ? u : o);
	let f = {}, g = h((e, t) => {
		Hv(t) || (f[e] = t.toString());
	}, "setAttr");
	g("width", d), g("height", p);
	let m = [
		n.left,
		n.top,
		l,
		u
	];
	return f.viewBox = m.join(" "), {
		attributes: f,
		viewBox: m,
		body: a
	};
}
h(Hx, "iconToSVG");
var Hb = /\sid="(\S+)"/g, Hw = "IconifyId" + Date.now().toString(16) + (16777216 * Math.random() | 0).toString(16), Hk = 0;
function HT(e, t = Hw) {
	let r = [], i;
	for (; i = Hb.exec(e);) r.push(i[1]);
	if (!r.length) return e;
	let n = "suffix" + (16777216 * Math.random() | Date.now()).toString(16);
	return r.forEach((r) => {
		let i = "function" == typeof t ? t(r) : t + (Hk++).toString(), a = r.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
		e = e.replace(RegExp("([#;\"])(" + a + ")([\")]|\\.[a-z])", "g"), "$1" + i + n + "$3");
	}), e = e.replace(RegExp(n, "g"), "");
}
function H_(e, t) {
	let r = -1 === e.indexOf("xlink:") ? "" : " xmlns:xlink=\"http://www.w3.org/1999/xlink\"";
	for (let e in t) r += " " + e + "=\"" + t[e] + "\"";
	return "<svg xmlns=\"http://www.w3.org/2000/svg\"" + r + ">" + e + "</svg>";
}
h(HT, "replaceIDs"), h(H_, "iconToHTML");
var HE = {
	body: "<g><rect width=\"80\" height=\"80\" style=\"fill: #087ebf; stroke-width: 0px;\"/><text transform=\"translate(21.16 64.67)\" style=\"fill: #fff; font-family: ArialMT, Arial; font-size: 67.75px;\"><tspan x=\"0\" y=\"0\">?</tspan></text></g>",
	height: 80,
	width: 80
}, HC = /* @__PURE__ */ new Map(), HS = /* @__PURE__ */ new Map(), HA = h((e) => {
	for (let t of e) {
		if (!t.name) throw Error("Invalid icon loader. Must have a \"name\" property with non-empty string value.");
		if (wQ.debug("Registering icon pack:", t.name), "loader" in t) HS.set(t.name, t.loader);
		else if ("icons" in t) HC.set(t.name, t.icons);
		else throw wQ.error("Invalid icon loader:", t), Error("Invalid icon loader. Must have either \"icons\" or \"loader\" property.");
	}
}, "registerIconPacks"), HL = h(async (e, t) => {
	let r = Ha(e, !0, void 0 !== t);
	if (!r) throw Error(`Invalid icon name: ${e}`);
	let i = r.prefix || t;
	if (!i) throw Error(`Icon name must contain a prefix: ${e}`);
	let n = HC.get(i);
	if (!n) {
		let e = HS.get(i);
		if (!e) throw Error(`Icon set not found: ${r.prefix}`);
		try {
			n = {
				...await e(),
				prefix: i
			}, HC.set(i, n);
		} catch (e) {
			throw wQ.error(e), Error(`Failed to load icon set: ${r.prefix}`);
		}
	}
	let a = Hu(n, r.name);
	if (!a) throw Error(`Icon not found: ${e}`);
	return a;
}, "getRegisteredIconData"), HR = h(async (e) => {
	try {
		return await HL(e), !0;
	} catch {
		return !1;
	}
}, "isIconAvailable"), HN = h(async (e, t, r) => {
	let i;
	try {
		i = await HL(e, t?.fallbackPrefix);
	} catch (e) {
		wQ.error(e), i = HE;
	}
	let n = Hx(i, t);
	return MO(H_(HT(n.body), {
		...n.attributes,
		...r
	}), IA());
}, "getIconSVG");
function HI(e) {
	for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
	var i = Array.from("string" == typeof e ? [e] : e);
	i[i.length - 1] = i[i.length - 1].replace(/\r?\n([\t ]*)$/, "");
	var n = i.reduce(function(e, t) {
		var r = t.match(/\n([\t ]+|(?!\s).)/g);
		return r ? e.concat(r.map(function(e) {
			var t, r;
			return null != (r = null == (t = e.match(/[\t ]/g)) ? void 0 : t.length) ? r : 0;
		})) : e;
	}, []);
	if (n.length) {
		var a = RegExp(`
[	 ]{` + Math.min.apply(Math, n) + "}", "g");
		i = i.map(function(e) {
			return e.replace(a, `
`);
		});
	}
	i[0] = i[0].replace(/^\r?\n/, "");
	var s = i[0];
	return t.forEach(function(e, t) {
		var r = s.match(/(?:^|\n)( *)$/), n = r ? r[1] : "", a = e;
		"string" == typeof e && e.includes(`
`) && (a = String(e).split(`
`).map(function(e, t) {
			return 0 === t ? e : "" + n + e;
		}).join(`
`)), s += a + i[t + 1];
	}), s;
}
function HM() {
	return {
		async: !1,
		breaks: !1,
		extensions: null,
		gfm: !0,
		hooks: null,
		pedantic: !1,
		renderer: null,
		silent: !1,
		tokenizer: null,
		walkTokens: null
	};
}
h(HI, "dedent"), h(HM, "L");
var HD = HM();
function HO(e) {
	HD = e;
}
h(HO, "G");
var H$ = { exec: h(() => null, "exec") };
function HP(e, t = "") {
	let r = "string" == typeof e ? e : e.source, i = {
		replace: h((e, t) => {
			let n = "string" == typeof t ? t : t.source;
			return n = n.replace(HB.caret, "$1"), r = r.replace(e, n), i;
		}, "replace"),
		getRegex: h(() => new RegExp(r, t), "getRegex")
	};
	return i;
}
h(HP, "h");
var HB = {
	codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm,
	outputLinkReplace: /\\([\[\]])/g,
	indentCodeCompensation: /^(\s+)(?:```)/,
	beginningSpace: /^\s+/,
	endingHash: /#$/,
	startingSpaceChar: /^ /,
	endingSpaceChar: / $/,
	nonSpaceChar: /[^ ]/,
	newLineCharGlobal: /\n/g,
	tabCharGlobal: /\t/g,
	multipleSpaceGlobal: /\s+/g,
	blankLine: /^[ \t]*$/,
	doubleBlankLine: /\n[ \t]*\n[ \t]*$/,
	blockquoteStart: /^ {0,3}>/,
	blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
	blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm,
	listReplaceTabs: /^\t+/,
	listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,
	listIsTask: /^\[[ xX]\] /,
	listReplaceTask: /^\[[ xX]\] +/,
	anyLine: /\n.*\n/,
	hrefBrackets: /^<(.*)>$/,
	tableDelimiter: /[:|]/,
	tableAlignChars: /^\||\| *$/g,
	tableRowBlankLine: /\n[ \t]*$/,
	tableAlignRight: /^ *-+: *$/,
	tableAlignCenter: /^ *:-+: *$/,
	tableAlignLeft: /^ *:-+ *$/,
	startATag: /^<a /i,
	endATag: /^<\/a>/i,
	startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i,
	endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i,
	startAngleBracket: /^</,
	endAngleBracket: />$/,
	pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/,
	unicodeAlphaNumeric: /[\p{L}\p{N}]/u,
	escapeTest: /[&<>"']/,
	escapeReplace: /[&<>"']/g,
	escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
	escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,
	unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi,
	caret: /(^|[^\[])\^/g,
	percentDecode: /%25/g,
	findPipe: /\|/g,
	splitPipe: / \|/,
	slashPipe: /\\\|/g,
	carriageReturn: /\r\n|\r/g,
	spaceLine: /^ +$/gm,
	notSpaceStart: /^\S*/,
	endingNewline: /\n$/,
	listItemRegex: h((e) => RegExp(`^( {0,3}${e})((?:[	 ][^\\n]*)?(?:\\n|$))`), "listItemRegex"),
	nextBulletRegex: h((e) => RegExp(`^ {0,${Math.min(3, e - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), "nextBulletRegex"),
	hrRegex: h((e) => RegExp(`^ {0,${Math.min(3, e - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), "hrRegex"),
	fencesBeginRegex: h((e) => RegExp(`^ {0,${Math.min(3, e - 1)}}(?:\`\`\`|~~~)`), "fencesBeginRegex"),
	headingBeginRegex: h((e) => RegExp(`^ {0,${Math.min(3, e - 1)}}#`), "headingBeginRegex"),
	htmlBeginRegex: h((e) => RegExp(`^ {0,${Math.min(3, e - 1)}}<(?:[a-z].*>|!--)`, "i"), "htmlBeginRegex")
}, HF = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, Hz = /(?:[*+-]|\d{1,9}[.)])/, HU = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/, HG = HP(HU).replace(/bull/g, Hz).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex(), Hq = HP(HU).replace(/bull/g, Hz).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex(), Hj = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, HW = /(?!\s*\])(?:\\[\s\S]|[^\[\]\\])+/, HY = HP(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", HW).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), HV = HP(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, Hz).getRegex(), HH = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", HX = /<!--(?:-?>|[\s\S]*?(?:-->|$))/, HK = HP("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", HX).replace("tag", HH).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), HZ = HP(Hj).replace("hr", HF).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", HH).getRegex(), HQ = {
	blockquote: HP(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", HZ).getRegex(),
	code: /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/,
	def: HY,
	fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
	heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
	hr: HF,
	html: HK,
	lheading: HG,
	list: HV,
	newline: /^(?:[ \t]*(?:\n|$))+/,
	paragraph: HZ,
	table: H$,
	text: /^[^\n]+/
}, HJ = HP("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", HF).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", HH).getRegex(), H0 = {
	...HQ,
	lheading: Hq,
	table: HJ,
	paragraph: HP(Hj).replace("hr", HF).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", HJ).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", HH).getRegex()
}, H1 = {
	...HQ,
	html: HP(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", HX).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
	def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
	heading: /^(#{1,6})(.*)(?:\n+|$)/,
	fences: H$,
	lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
	paragraph: HP(Hj).replace("hr", HF).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", HG).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
}, H2 = /^( {2,}|\\)\n(?!\s*$)/, H4 = /[\p{P}\p{S}]/u, H5 = /[\s\p{P}\p{S}]/u, H3 = /[^\s\p{P}\p{S}]/u, H6 = HP(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, H5).getRegex(), H7 = /(?!~)[\p{P}\p{S}]/u, H8 = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/, H9 = HP(H8, "u").replace(/punct/g, H4).getRegex(), Xe = HP(H8, "u").replace(/punct/g, H7).getRegex(), Xt = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)", Xr = HP(Xt, "gu").replace(/notPunctSpace/g, H3).replace(/punctSpace/g, H5).replace(/punct/g, H4).getRegex(), Xi = HP(Xt, "gu").replace(/notPunctSpace/g, /(?:[^\s\p{P}\p{S}]|~)/u).replace(/punctSpace/g, /(?!~)[\s\p{P}\p{S}]/u).replace(/punct/g, H7).getRegex(), Xn = HP("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, H3).replace(/punctSpace/g, H5).replace(/punct/g, H4).getRegex(), Xa = HP(/\\(punct)/, "gu").replace(/punct/g, H4).getRegex(), Xs = HP(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), Xo = HP(HX).replace("(?:-->|$)", "-->").getRegex(), Xl = HP("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", Xo).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), Xc = /(?:\[(?:\\[\s\S]|[^\[\]\\])*\]|\\[\s\S]|`[^`]*`|[^\[\]\\`])*?/, Xh = HP(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", Xc).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), Xu = HP(/^!?\[(label)\]\[(ref)\]/).replace("label", Xc).replace("ref", HW).getRegex(), Xd = HP(/^!?\[(ref)\](?:\[\])?/).replace("ref", HW).getRegex(), Xp = {
	_backpedal: H$,
	anyPunctuation: Xa,
	autolink: Xs,
	blockSkip: /\[[^\[\]]*?\]\((?:\\[\s\S]|[^\\\(\)]|\((?:\\[\s\S]|[^\\\(\)])*\))*\)|`[^`]*?`|<(?! )[^<>]*?>/g,
	br: H2,
	code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
	del: H$,
	emStrongLDelim: H9,
	emStrongRDelimAst: Xr,
	emStrongRDelimUnd: Xn,
	escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
	link: Xh,
	nolink: Xd,
	punctuation: H6,
	reflink: Xu,
	reflinkSearch: HP("reflink|nolink(?!\\()", "g").replace("reflink", Xu).replace("nolink", Xd).getRegex(),
	tag: Xl,
	text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
	url: H$
}, Xf = {
	...Xp,
	link: HP(/^!?\[(label)\]\((.*?)\)/).replace("label", Xc).getRegex(),
	reflink: HP(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", Xc).getRegex()
}, Xg = {
	...Xp,
	emStrongRDelimAst: Xi,
	emStrongLDelim: Xe,
	url: HP(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
	_backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
	del: /^(~~?)(?=[^\s~])((?:\\[\s\S]|[^\\])*?(?:\\[\s\S]|[^\s~\\]))\1(?=[^~]|$)/,
	text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
}, Xm = {
	...Xg,
	br: HP(H2).replace("{2,}", "*").getRegex(),
	text: HP(Xg.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
}, Xy = {
	normal: HQ,
	gfm: H0,
	pedantic: H1
}, Xv = {
	normal: Xp,
	gfm: Xg,
	breaks: Xm,
	pedantic: Xf
}, Xx = {
	"&": "&amp;",
	"<": "&lt;",
	">": "&gt;",
	"\"": "&quot;",
	"'": "&#39;"
}, Xb = h((e) => Xx[e], "ke");
function Xw(e, t) {
	if (t) {
		if (HB.escapeTest.test(e)) return e.replace(HB.escapeReplace, Xb);
	} else if (HB.escapeTestNoEncode.test(e)) return e.replace(HB.escapeReplaceNoEncode, Xb);
	return e;
}
function Xk(e) {
	try {
		e = encodeURI(e).replace(HB.percentDecode, "%");
	} catch {
		return null;
	}
	return e;
}
function XT(e, t) {
	let r = e.replace(HB.findPipe, (e, t, r) => {
		let i = !1, n = t;
		for (; --n >= 0 && "\\" === r[n];) i = !i;
		return i ? "|" : " |";
	}).split(HB.splitPipe), i = 0;
	if (r[0].trim() || r.shift(), r.length > 0 && !r.at(-1)?.trim() && r.pop(), t) if (r.length > t) r.splice(t);
	else for (; r.length < t;) r.push("");
	for (; i < r.length; i++) r[i] = r[i].trim().replace(HB.slashPipe, "|");
	return r;
}
function X_(e, t, r) {
	let i = e.length;
	if (0 === i) return "";
	let n = 0;
	for (; n < i;) {
		let a = e.charAt(i - n - 1);
		if (a !== t || r) if (a !== t && r) n++;
		else break;
		else n++;
	}
	return e.slice(0, i - n);
}
function XE(e, t) {
	if (-1 === e.indexOf(t[1])) return -1;
	let r = 0;
	for (let i = 0; i < e.length; i++) if ("\\" === e[i]) i++;
	else if (e[i] === t[0]) r++;
	else if (e[i] === t[1] && --r < 0) return i;
	return r > 0 ? -2 : -1;
}
function XC(e, t, r, i, n) {
	let a = t.href, s = t.title || null, o = e[1].replace(n.other.outputLinkReplace, "$1");
	i.state.inLink = !0;
	let l = {
		type: "!" === e[0].charAt(0) ? "image" : "link",
		raw: r,
		href: a,
		title: s,
		text: o,
		tokens: i.inlineTokens(o)
	};
	return i.state.inLink = !1, l;
}
function XS(e, t, r) {
	let i = e.match(r.other.indentCodeCompensation);
	if (null === i) return t;
	let n = i[1];
	return t.split(`
`).map((e) => {
		let t = e.match(r.other.beginningSpace);
		if (null === t) return e;
		let [i] = t;
		return i.length >= n.length ? e.slice(n.length) : e;
	}).join(`
`);
}
h(Xw, "w"), h(Xk, "J"), h(XT, "V"), h(X_, "z"), h(XE, "ge"), h(XC, "fe"), h(XS, "Je");
var XA = class {
	static {
		h(this, "y");
	}
	options;
	rules;
	lexer;
	constructor(e) {
		this.options = e || HD;
	}
	space(e) {
		let t = this.rules.block.newline.exec(e);
		if (t && t[0].length > 0) return {
			type: "space",
			raw: t[0]
		};
	}
	code(e) {
		let t = this.rules.block.code.exec(e);
		if (t) {
			let e = t[0].replace(this.rules.other.codeRemoveIndent, "");
			return {
				type: "code",
				raw: t[0],
				codeBlockStyle: "indented",
				text: this.options.pedantic ? e : X_(e, `
`)
			};
		}
	}
	fences(e) {
		let t = this.rules.block.fences.exec(e);
		if (t) {
			let e = t[0], r = XS(e, t[3] || "", this.rules);
			return {
				type: "code",
				raw: e,
				lang: t[2] ? t[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : t[2],
				text: r
			};
		}
	}
	heading(e) {
		let t = this.rules.block.heading.exec(e);
		if (t) {
			let e = t[2].trim();
			if (this.rules.other.endingHash.test(e)) {
				let t = X_(e, "#");
				(this.options.pedantic || !t || this.rules.other.endingSpaceChar.test(t)) && (e = t.trim());
			}
			return {
				type: "heading",
				raw: t[0],
				depth: t[1].length,
				text: e,
				tokens: this.lexer.inline(e)
			};
		}
	}
	hr(e) {
		let t = this.rules.block.hr.exec(e);
		if (t) return {
			type: "hr",
			raw: X_(t[0], `
`)
		};
	}
	blockquote(e) {
		let t = this.rules.block.blockquote.exec(e);
		if (t) {
			let e = X_(t[0], `
`).split(`
`), r = "", i = "", n = [];
			for (; e.length > 0;) {
				let t = !1, a = [], s;
				for (s = 0; s < e.length; s++) if (this.rules.other.blockquoteStart.test(e[s])) a.push(e[s]), t = !0;
				else if (t) break;
				else a.push(e[s]);
				e = e.slice(s);
				let o = a.join(`
`), l = o.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, "");
				r = r ? `${r}
${o}` : o, i = i ? `${i}
${l}` : l;
				let h = this.lexer.state.top;
				if (this.lexer.state.top = !0, this.lexer.blockTokens(l, n, !0), this.lexer.state.top = h, 0 === e.length) break;
				let u = n.at(-1);
				if (u?.type === "code") break;
				if (u?.type === "blockquote") {
					let t = u.raw + `
` + e.join(`
`), a = this.blockquote(t);
					n[n.length - 1] = a, r = r.substring(0, r.length - u.raw.length) + a.raw, i = i.substring(0, i.length - u.text.length) + a.text;
					break;
				}
				if (u?.type === "list") {
					let t = u.raw + `
` + e.join(`
`), a = this.list(t);
					n[n.length - 1] = a, r = r.substring(0, r.length - u.raw.length) + a.raw, i = i.substring(0, i.length - u.raw.length) + a.raw, e = t.substring(n.at(-1).raw.length).split(`
`);
					continue;
				}
			}
			return {
				type: "blockquote",
				raw: r,
				tokens: n,
				text: i
			};
		}
	}
	list(e) {
		let t = this.rules.block.list.exec(e);
		if (t) {
			let r = t[1].trim(), i = r.length > 1, n = {
				type: "list",
				raw: "",
				ordered: i,
				start: i ? +r.slice(0, -1) : "",
				loose: !1,
				items: []
			};
			r = i ? `\\d{1,9}\\${r.slice(-1)}` : `\\${r}`, this.options.pedantic && (r = i ? r : "[*+-]");
			let a = this.rules.other.listItemRegex(r), s = !1;
			for (; e;) {
				let r = !1, i = "", o = "";
				if (!(t = a.exec(e)) || this.rules.block.hr.test(e)) break;
				i = t[0], e = e.substring(i.length);
				let l = t[2].split(`
`, 1)[0].replace(this.rules.other.listReplaceTabs, (e) => " ".repeat(3 * e.length)), h = e.split(`
`, 1)[0], u = !l.trim(), d = 0;
				if (this.options.pedantic ? (d = 2, o = l.trimStart()) : u ? d = t[1].length + 1 : (d = (d = t[2].search(this.rules.other.nonSpaceChar)) > 4 ? 1 : d, o = l.slice(d), d += t[1].length), u && this.rules.other.blankLine.test(h) && (i += h + `
`, e = e.substring(h.length + 1), r = !0), !r) {
					let t = this.rules.other.nextBulletRegex(d), r = this.rules.other.hrRegex(d), n = this.rules.other.fencesBeginRegex(d), a = this.rules.other.headingBeginRegex(d), s = this.rules.other.htmlBeginRegex(d);
					for (; e;) {
						let p = e.split(`
`, 1)[0], f;
						if (h = p, f = this.options.pedantic ? h = h.replace(this.rules.other.listReplaceNesting, "  ") : h.replace(this.rules.other.tabCharGlobal, "    "), n.test(h) || a.test(h) || s.test(h) || t.test(h) || r.test(h)) break;
						if (f.search(this.rules.other.nonSpaceChar) >= d || !h.trim()) o += `
` + f.slice(d);
						else {
							if (u || l.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4 || n.test(l) || a.test(l) || r.test(l)) break;
							o += `
` + h;
						}
						u || h.trim() || (u = !0), i += p + `
`, e = e.substring(p.length + 1), l = f.slice(d);
					}
				}
				n.loose || (s ? n.loose = !0 : this.rules.other.doubleBlankLine.test(i) && (s = !0));
				let p = null, f;
				this.options.gfm && (p = this.rules.other.listIsTask.exec(o)) && (f = "[ ] " !== p[0], o = o.replace(this.rules.other.listReplaceTask, "")), n.items.push({
					type: "list_item",
					raw: i,
					task: !!p,
					checked: f,
					loose: !1,
					text: o,
					tokens: []
				}), n.raw += i;
			}
			let o = n.items.at(-1);
			if (!o) return;
			o.raw = o.raw.trimEnd(), o.text = o.text.trimEnd(), n.raw = n.raw.trimEnd();
			for (let e = 0; e < n.items.length; e++) if (this.lexer.state.top = !1, n.items[e].tokens = this.lexer.blockTokens(n.items[e].text, []), !n.loose) {
				let t = n.items[e].tokens.filter((e) => "space" === e.type);
				n.loose = t.length > 0 && t.some((e) => this.rules.other.anyLine.test(e.raw));
			}
			if (n.loose) for (let e = 0; e < n.items.length; e++) n.items[e].loose = !0;
			return n;
		}
	}
	html(e) {
		let t = this.rules.block.html.exec(e);
		if (t) return {
			type: "html",
			block: !0,
			raw: t[0],
			pre: "pre" === t[1] || "script" === t[1] || "style" === t[1],
			text: t[0]
		};
	}
	def(e) {
		let t = this.rules.block.def.exec(e);
		if (t) {
			let e = t[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "), r = t[2] ? t[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", i = t[3] ? t[3].substring(1, t[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : t[3];
			return {
				type: "def",
				tag: e,
				raw: t[0],
				href: r,
				title: i
			};
		}
	}
	table(e) {
		let t = this.rules.block.table.exec(e);
		if (!t || !this.rules.other.tableDelimiter.test(t[2])) return;
		let r = XT(t[1]), i = t[2].replace(this.rules.other.tableAlignChars, "").split("|"), n = t[3]?.trim() ? t[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : [], a = {
			type: "table",
			raw: t[0],
			header: [],
			align: [],
			rows: []
		};
		if (r.length === i.length) {
			for (let e of i) this.rules.other.tableAlignRight.test(e) ? a.align.push("right") : this.rules.other.tableAlignCenter.test(e) ? a.align.push("center") : this.rules.other.tableAlignLeft.test(e) ? a.align.push("left") : a.align.push(null);
			for (let e = 0; e < r.length; e++) a.header.push({
				text: r[e],
				tokens: this.lexer.inline(r[e]),
				header: !0,
				align: a.align[e]
			});
			for (let e of n) a.rows.push(XT(e, a.header.length).map((e, t) => ({
				text: e,
				tokens: this.lexer.inline(e),
				header: !1,
				align: a.align[t]
			})));
			return a;
		}
	}
	lheading(e) {
		let t = this.rules.block.lheading.exec(e);
		if (t) return {
			type: "heading",
			raw: t[0],
			depth: "=" === t[2].charAt(0) ? 1 : 2,
			text: t[1],
			tokens: this.lexer.inline(t[1])
		};
	}
	paragraph(e) {
		let t = this.rules.block.paragraph.exec(e);
		if (t) {
			let e = t[1].charAt(t[1].length - 1) === `
` ? t[1].slice(0, -1) : t[1];
			return {
				type: "paragraph",
				raw: t[0],
				text: e,
				tokens: this.lexer.inline(e)
			};
		}
	}
	text(e) {
		let t = this.rules.block.text.exec(e);
		if (t) return {
			type: "text",
			raw: t[0],
			text: t[0],
			tokens: this.lexer.inline(t[0])
		};
	}
	escape(e) {
		let t = this.rules.inline.escape.exec(e);
		if (t) return {
			type: "escape",
			raw: t[0],
			text: t[1]
		};
	}
	tag(e) {
		let t = this.rules.inline.tag.exec(e);
		if (t) return !this.lexer.state.inLink && this.rules.other.startATag.test(t[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && this.rules.other.endATag.test(t[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(t[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(t[0]) && (this.lexer.state.inRawBlock = !1), {
			type: "html",
			raw: t[0],
			inLink: this.lexer.state.inLink,
			inRawBlock: this.lexer.state.inRawBlock,
			block: !1,
			text: t[0]
		};
	}
	link(e) {
		let t = this.rules.inline.link.exec(e);
		if (t) {
			let e = t[2].trim();
			if (!this.options.pedantic && this.rules.other.startAngleBracket.test(e)) {
				if (!this.rules.other.endAngleBracket.test(e)) return;
				let t = X_(e.slice(0, -1), "\\");
				if ((e.length - t.length) % 2 == 0) return;
			} else {
				let e = XE(t[2], "()");
				if (-2 === e) return;
				if (e > -1) {
					let r = (0 === t[0].indexOf("!") ? 5 : 4) + t[1].length + e;
					t[2] = t[2].substring(0, e), t[0] = t[0].substring(0, r).trim(), t[3] = "";
				}
			}
			let r = t[2], i = "";
			if (this.options.pedantic) {
				let e = this.rules.other.pedanticHrefTitle.exec(r);
				e && (r = e[1], i = e[3]);
			} else i = t[3] ? t[3].slice(1, -1) : "";
			return r = r.trim(), this.rules.other.startAngleBracket.test(r) && (r = this.options.pedantic && !this.rules.other.endAngleBracket.test(e) ? r.slice(1) : r.slice(1, -1)), XC(t, {
				href: r && r.replace(this.rules.inline.anyPunctuation, "$1"),
				title: i && i.replace(this.rules.inline.anyPunctuation, "$1")
			}, t[0], this.lexer, this.rules);
		}
	}
	reflink(e, t) {
		let r;
		if ((r = this.rules.inline.reflink.exec(e)) || (r = this.rules.inline.nolink.exec(e))) {
			let e = t[(r[2] || r[1]).replace(this.rules.other.multipleSpaceGlobal, " ").toLowerCase()];
			if (!e) {
				let e = r[0].charAt(0);
				return {
					type: "text",
					raw: e,
					text: e
				};
			}
			return XC(r, e, r[0], this.lexer, this.rules);
		}
	}
	emStrong(e, t, r = "") {
		let i = this.rules.inline.emStrongLDelim.exec(e);
		if (!(!i || i[3] && r.match(this.rules.other.unicodeAlphaNumeric)) && (!(i[1] || i[2]) || !r || this.rules.inline.punctuation.exec(r))) {
			let r = [...i[0]].length - 1, n, a, s = r, o = 0, l = "*" === i[0][0] ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
			for (l.lastIndex = 0, t = t.slice(-1 * e.length + r); null != (i = l.exec(t));) {
				if (!(n = i[1] || i[2] || i[3] || i[4] || i[5] || i[6])) continue;
				if (a = [...n].length, i[3] || i[4]) {
					s += a;
					continue;
				}
				if ((i[5] || i[6]) && r % 3 && !((r + a) % 3)) {
					o += a;
					continue;
				}
				if ((s -= a) > 0) continue;
				a = Math.min(a, a + s + o);
				let t = [...i[0]][0].length, l = e.slice(0, r + i.index + t + a);
				if (Math.min(r, a) % 2) {
					let e = l.slice(1, -1);
					return {
						type: "em",
						raw: l,
						text: e,
						tokens: this.lexer.inlineTokens(e)
					};
				}
				let h = l.slice(2, -2);
				return {
					type: "strong",
					raw: l,
					text: h,
					tokens: this.lexer.inlineTokens(h)
				};
			}
		}
	}
	codespan(e) {
		let t = this.rules.inline.code.exec(e);
		if (t) {
			let e = t[2].replace(this.rules.other.newLineCharGlobal, " "), r = this.rules.other.nonSpaceChar.test(e), i = this.rules.other.startingSpaceChar.test(e) && this.rules.other.endingSpaceChar.test(e);
			return r && i && (e = e.substring(1, e.length - 1)), {
				type: "codespan",
				raw: t[0],
				text: e
			};
		}
	}
	br(e) {
		let t = this.rules.inline.br.exec(e);
		if (t) return {
			type: "br",
			raw: t[0]
		};
	}
	del(e) {
		let t = this.rules.inline.del.exec(e);
		if (t) return {
			type: "del",
			raw: t[0],
			text: t[2],
			tokens: this.lexer.inlineTokens(t[2])
		};
	}
	autolink(e) {
		let t = this.rules.inline.autolink.exec(e);
		if (t) {
			let e, r;
			return r = "@" === t[2] ? "mailto:" + (e = t[1]) : e = t[1], {
				type: "link",
				raw: t[0],
				text: e,
				href: r,
				tokens: [{
					type: "text",
					raw: e,
					text: e
				}]
			};
		}
	}
	url(e) {
		let t;
		if (t = this.rules.inline.url.exec(e)) {
			let e, r;
			if ("@" === t[2]) r = "mailto:" + (e = t[0]);
			else {
				let i;
				do
					i = t[0], t[0] = this.rules.inline._backpedal.exec(t[0])?.[0] ?? "";
				while (i !== t[0]);
				e = t[0], r = "www." === t[1] ? "http://" + t[0] : t[0];
			}
			return {
				type: "link",
				raw: t[0],
				text: e,
				href: r,
				tokens: [{
					type: "text",
					raw: e,
					text: e
				}]
			};
		}
	}
	inlineText(e) {
		let t = this.rules.inline.text.exec(e);
		if (t) {
			let e = this.lexer.state.inRawBlock;
			return {
				type: "text",
				raw: t[0],
				text: t[0],
				escaped: e
			};
		}
	}
}, XL = class e {
	static {
		h(this, "l");
	}
	tokens;
	options;
	state;
	tokenizer;
	inlineQueue;
	constructor(e) {
		this.tokens = [], this.tokens.links = Object.create(null), this.options = e || HD, this.options.tokenizer = this.options.tokenizer || new XA(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = {
			inLink: !1,
			inRawBlock: !1,
			top: !0
		};
		let t = {
			other: HB,
			block: Xy.normal,
			inline: Xv.normal
		};
		this.options.pedantic ? (t.block = Xy.pedantic, t.inline = Xv.pedantic) : this.options.gfm && (t.block = Xy.gfm, this.options.breaks ? t.inline = Xv.breaks : t.inline = Xv.gfm), this.tokenizer.rules = t;
	}
	static get rules() {
		return {
			block: Xy,
			inline: Xv
		};
	}
	static lex(t, r) {
		return new e(r).lex(t);
	}
	static lexInline(t, r) {
		return new e(r).inlineTokens(t);
	}
	lex(e) {
		e = e.replace(HB.carriageReturn, `
`), this.blockTokens(e, this.tokens);
		for (let e = 0; e < this.inlineQueue.length; e++) {
			let t = this.inlineQueue[e];
			this.inlineTokens(t.src, t.tokens);
		}
		return this.inlineQueue = [], this.tokens;
	}
	blockTokens(e, t = [], r = !1) {
		for (this.options.pedantic && (e = e.replace(HB.tabCharGlobal, "    ").replace(HB.spaceLine, "")); e;) {
			let i;
			if (this.options.extensions?.block?.some((r) => !!(i = r.call({ lexer: this }, e, t)) && (e = e.substring(i.raw.length), t.push(i), !0))) continue;
			if (i = this.tokenizer.space(e)) {
				e = e.substring(i.raw.length);
				let r = t.at(-1);
				1 === i.raw.length && void 0 !== r ? r.raw += `
` : t.push(i);
				continue;
			}
			if (i = this.tokenizer.code(e)) {
				e = e.substring(i.raw.length);
				let r = t.at(-1);
				r?.type === "paragraph" || r?.type === "text" ? (r.raw += (r.raw.endsWith(`
`) ? "" : `
`) + i.raw, r.text += `
` + i.text, this.inlineQueue.at(-1).src = r.text) : t.push(i);
				continue;
			}
			if ((i = this.tokenizer.fences(e)) || (i = this.tokenizer.heading(e)) || (i = this.tokenizer.hr(e)) || (i = this.tokenizer.blockquote(e)) || (i = this.tokenizer.list(e)) || (i = this.tokenizer.html(e))) {
				e = e.substring(i.raw.length), t.push(i);
				continue;
			}
			if (i = this.tokenizer.def(e)) {
				e = e.substring(i.raw.length);
				let r = t.at(-1);
				r?.type === "paragraph" || r?.type === "text" ? (r.raw += (r.raw.endsWith(`
`) ? "" : `
`) + i.raw, r.text += `
` + i.raw, this.inlineQueue.at(-1).src = r.text) : this.tokens.links[i.tag] || (this.tokens.links[i.tag] = {
					href: i.href,
					title: i.title
				}, t.push(i));
				continue;
			}
			if ((i = this.tokenizer.table(e)) || (i = this.tokenizer.lheading(e))) {
				e = e.substring(i.raw.length), t.push(i);
				continue;
			}
			let n = e;
			if (this.options.extensions?.startBlock) {
				let t = Infinity, r = e.slice(1), i;
				this.options.extensions.startBlock.forEach((e) => {
					"number" == typeof (i = e.call({ lexer: this }, r)) && i >= 0 && (t = Math.min(t, i));
				}), t < Infinity && t >= 0 && (n = e.substring(0, t + 1));
			}
			if (this.state.top && (i = this.tokenizer.paragraph(n))) {
				let a = t.at(-1);
				r && a?.type === "paragraph" ? (a.raw += (a.raw.endsWith(`
`) ? "" : `
`) + i.raw, a.text += `
` + i.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = a.text) : t.push(i), r = n.length !== e.length, e = e.substring(i.raw.length);
				continue;
			}
			if (i = this.tokenizer.text(e)) {
				e = e.substring(i.raw.length);
				let r = t.at(-1);
				r?.type === "text" ? (r.raw += (r.raw.endsWith(`
`) ? "" : `
`) + i.raw, r.text += `
` + i.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = r.text) : t.push(i);
				continue;
			}
			if (e) {
				let t = "Infinite loop on byte: " + e.charCodeAt(0);
				if (this.options.silent) {
					console.error(t);
					break;
				}
				throw Error(t);
			}
		}
		return this.state.top = !0, t;
	}
	inline(e, t = []) {
		return this.inlineQueue.push({
			src: e,
			tokens: t
		}), t;
	}
	inlineTokens(e, t = []) {
		let r = e, i = null;
		if (this.tokens.links) {
			let e = Object.keys(this.tokens.links);
			if (e.length > 0) for (; null != (i = this.tokenizer.rules.inline.reflinkSearch.exec(r));) e.includes(i[0].slice(i[0].lastIndexOf("[") + 1, -1)) && (r = r.slice(0, i.index) + "[" + "a".repeat(i[0].length - 2) + "]" + r.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
		}
		for (; null != (i = this.tokenizer.rules.inline.anyPunctuation.exec(r));) r = r.slice(0, i.index) + "++" + r.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
		for (; null != (i = this.tokenizer.rules.inline.blockSkip.exec(r));) r = r.slice(0, i.index) + "[" + "a".repeat(i[0].length - 2) + "]" + r.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
		r = this.options.hooks?.emStrongMask?.call({ lexer: this }, r) ?? r;
		let n = !1, a = "";
		for (; e;) {
			let i;
			if (n || (a = ""), n = !1, this.options.extensions?.inline?.some((r) => !!(i = r.call({ lexer: this }, e, t)) && (e = e.substring(i.raw.length), t.push(i), !0))) continue;
			if ((i = this.tokenizer.escape(e)) || (i = this.tokenizer.tag(e)) || (i = this.tokenizer.link(e))) {
				e = e.substring(i.raw.length), t.push(i);
				continue;
			}
			if (i = this.tokenizer.reflink(e, this.tokens.links)) {
				e = e.substring(i.raw.length);
				let r = t.at(-1);
				"text" === i.type && r?.type === "text" ? (r.raw += i.raw, r.text += i.text) : t.push(i);
				continue;
			}
			if ((i = this.tokenizer.emStrong(e, r, a)) || (i = this.tokenizer.codespan(e)) || (i = this.tokenizer.br(e)) || (i = this.tokenizer.del(e)) || (i = this.tokenizer.autolink(e)) || !this.state.inLink && (i = this.tokenizer.url(e))) {
				e = e.substring(i.raw.length), t.push(i);
				continue;
			}
			let s = e;
			if (this.options.extensions?.startInline) {
				let t = Infinity, r = e.slice(1), i;
				this.options.extensions.startInline.forEach((e) => {
					"number" == typeof (i = e.call({ lexer: this }, r)) && i >= 0 && (t = Math.min(t, i));
				}), t < Infinity && t >= 0 && (s = e.substring(0, t + 1));
			}
			if (i = this.tokenizer.inlineText(s)) {
				e = e.substring(i.raw.length), "_" !== i.raw.slice(-1) && (a = i.raw.slice(-1)), n = !0;
				let r = t.at(-1);
				r?.type === "text" ? (r.raw += i.raw, r.text += i.text) : t.push(i);
				continue;
			}
			if (e) {
				let t = "Infinite loop on byte: " + e.charCodeAt(0);
				if (this.options.silent) {
					console.error(t);
					break;
				}
				throw Error(t);
			}
		}
		return t;
	}
}, XR = class {
	static {
		h(this, "P");
	}
	options;
	parser;
	constructor(e) {
		this.options = e || HD;
	}
	space(e) {
		return "";
	}
	code({ text: e, lang: t, escaped: r }) {
		let i = (t || "").match(HB.notSpaceStart)?.[0], n = e.replace(HB.endingNewline, "") + `
`;
		return i ? "<pre><code class=\"language-" + Xw(i) + "\">" + (r ? n : Xw(n, !0)) + `</code></pre>
` : "<pre><code>" + (r ? n : Xw(n, !0)) + `</code></pre>
`;
	}
	blockquote({ tokens: e }) {
		return `<blockquote>
${this.parser.parse(e)}</blockquote>
`;
	}
	html({ text: e }) {
		return e;
	}
	def(e) {
		return "";
	}
	heading({ tokens: e, depth: t }) {
		return `<h${t}>${this.parser.parseInline(e)}</h${t}>
`;
	}
	hr(e) {
		return `<hr>
`;
	}
	list(e) {
		let t = e.ordered, r = e.start, i = "";
		for (let t = 0; t < e.items.length; t++) {
			let r = e.items[t];
			i += this.listitem(r);
		}
		let n = t ? "ol" : "ul";
		return "<" + n + (t && 1 !== r ? " start=\"" + r + "\"" : "") + `>
` + i + "</" + n + `>
`;
	}
	listitem(e) {
		let t = "";
		if (e.task) {
			let r = this.checkbox({ checked: !!e.checked });
			e.loose ? e.tokens[0]?.type === "paragraph" ? (e.tokens[0].text = r + " " + e.tokens[0].text, e.tokens[0].tokens && e.tokens[0].tokens.length > 0 && "text" === e.tokens[0].tokens[0].type && (e.tokens[0].tokens[0].text = r + " " + Xw(e.tokens[0].tokens[0].text), e.tokens[0].tokens[0].escaped = !0)) : e.tokens.unshift({
				type: "text",
				raw: r + " ",
				text: r + " ",
				escaped: !0
			}) : t += r + " ";
		}
		return t += this.parser.parse(e.tokens, !!e.loose), `<li>${t}</li>
`;
	}
	checkbox({ checked: e }) {
		return "<input " + (e ? "checked=\"\" " : "") + "disabled=\"\" type=\"checkbox\">";
	}
	paragraph({ tokens: e }) {
		return `<p>${this.parser.parseInline(e)}</p>
`;
	}
	table(e) {
		let t = "", r = "";
		for (let t = 0; t < e.header.length; t++) r += this.tablecell(e.header[t]);
		t += this.tablerow({ text: r });
		let i = "";
		for (let t = 0; t < e.rows.length; t++) {
			let n = e.rows[t];
			r = "";
			for (let e = 0; e < n.length; e++) r += this.tablecell(n[e]);
			i += this.tablerow({ text: r });
		}
		return i && (i = `<tbody>${i}</tbody>`), `<table>
<thead>
` + t + `</thead>
` + i + `</table>
`;
	}
	tablerow({ text: e }) {
		return `<tr>
${e}</tr>
`;
	}
	tablecell(e) {
		let t = this.parser.parseInline(e.tokens), r = e.header ? "th" : "td";
		return (e.align ? `<${r} align="${e.align}">` : `<${r}>`) + t + `</${r}>
`;
	}
	strong({ tokens: e }) {
		return `<strong>${this.parser.parseInline(e)}</strong>`;
	}
	em({ tokens: e }) {
		return `<em>${this.parser.parseInline(e)}</em>`;
	}
	codespan({ text: e }) {
		return `<code>${Xw(e, !0)}</code>`;
	}
	br(e) {
		return "<br>";
	}
	del({ tokens: e }) {
		return `<del>${this.parser.parseInline(e)}</del>`;
	}
	link({ href: e, title: t, tokens: r }) {
		let i = this.parser.parseInline(r), n = Xk(e);
		if (null === n) return i;
		let a = "<a href=\"" + (e = n) + "\"";
		return t && (a += " title=\"" + Xw(t) + "\""), a += ">" + i + "</a>";
	}
	image({ href: e, title: t, text: r, tokens: i }) {
		i && (r = this.parser.parseInline(i, this.parser.textRenderer));
		let n = Xk(e);
		if (null === n) return Xw(r);
		e = n;
		let a = `<img src="${e}" alt="${r}"`;
		return t && (a += ` title="${Xw(t)}"`), a += ">";
	}
	text(e) {
		return "tokens" in e && e.tokens ? this.parser.parseInline(e.tokens) : "escaped" in e && e.escaped ? e.text : Xw(e.text);
	}
}, XN = class {
	static {
		h(this, "$");
	}
	strong({ text: e }) {
		return e;
	}
	em({ text: e }) {
		return e;
	}
	codespan({ text: e }) {
		return e;
	}
	del({ text: e }) {
		return e;
	}
	html({ text: e }) {
		return e;
	}
	text({ text: e }) {
		return e;
	}
	link({ text: e }) {
		return "" + e;
	}
	image({ text: e }) {
		return "" + e;
	}
	br() {
		return "";
	}
}, XI = class e {
	static {
		h(this, "l");
	}
	options;
	renderer;
	textRenderer;
	constructor(e) {
		this.options = e || HD, this.options.renderer = this.options.renderer || new XR(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new XN();
	}
	static parse(t, r) {
		return new e(r).parse(t);
	}
	static parseInline(t, r) {
		return new e(r).parseInline(t);
	}
	parse(e, t = !0) {
		let r = "";
		for (let i = 0; i < e.length; i++) {
			let n = e[i];
			if (this.options.extensions?.renderers?.[n.type]) {
				let e = this.options.extensions.renderers[n.type].call({ parser: this }, n);
				if (!1 !== e || ![
					"space",
					"hr",
					"heading",
					"code",
					"table",
					"blockquote",
					"list",
					"html",
					"def",
					"paragraph",
					"text"
				].includes(n.type)) {
					r += e || "";
					continue;
				}
			}
			switch (n.type) {
				case "space":
					r += this.renderer.space(n);
					continue;
				case "hr":
					r += this.renderer.hr(n);
					continue;
				case "heading":
					r += this.renderer.heading(n);
					continue;
				case "code":
					r += this.renderer.code(n);
					continue;
				case "table":
					r += this.renderer.table(n);
					continue;
				case "blockquote":
					r += this.renderer.blockquote(n);
					continue;
				case "list":
					r += this.renderer.list(n);
					continue;
				case "html":
					r += this.renderer.html(n);
					continue;
				case "def":
					r += this.renderer.def(n);
					continue;
				case "paragraph":
					r += this.renderer.paragraph(n);
					continue;
				case "text": {
					let a = n, s = this.renderer.text(a);
					for (; i + 1 < e.length && "text" === e[i + 1].type;) a = e[++i], s += `
` + this.renderer.text(a);
					t ? r += this.renderer.paragraph({
						type: "paragraph",
						raw: s,
						text: s,
						tokens: [{
							type: "text",
							raw: s,
							text: s,
							escaped: !0
						}]
					}) : r += s;
					continue;
				}
				default: {
					let e = "Token with \"" + n.type + "\" type was not found.";
					if (this.options.silent) return console.error(e), "";
					throw Error(e);
				}
			}
		}
		return r;
	}
	parseInline(e, t = this.renderer) {
		let r = "";
		for (let i = 0; i < e.length; i++) {
			let n = e[i];
			if (this.options.extensions?.renderers?.[n.type]) {
				let e = this.options.extensions.renderers[n.type].call({ parser: this }, n);
				if (!1 !== e || ![
					"escape",
					"html",
					"link",
					"image",
					"strong",
					"em",
					"codespan",
					"br",
					"del",
					"text"
				].includes(n.type)) {
					r += e || "";
					continue;
				}
			}
			switch (n.type) {
				case "escape":
				case "text":
					r += t.text(n);
					break;
				case "html":
					r += t.html(n);
					break;
				case "link":
					r += t.link(n);
					break;
				case "image":
					r += t.image(n);
					break;
				case "strong":
					r += t.strong(n);
					break;
				case "em":
					r += t.em(n);
					break;
				case "codespan":
					r += t.codespan(n);
					break;
				case "br":
					r += t.br(n);
					break;
				case "del":
					r += t.del(n);
					break;
				default: {
					let e = "Token with \"" + n.type + "\" type was not found.";
					if (this.options.silent) return console.error(e), "";
					throw Error(e);
				}
			}
		}
		return r;
	}
}, XM = class {
	static {
		h(this, "S");
	}
	options;
	block;
	constructor(e) {
		this.options = e || HD;
	}
	static passThroughHooks = new Set([
		"preprocess",
		"postprocess",
		"processAllTokens",
		"emStrongMask"
	]);
	static passThroughHooksRespectAsync = new Set([
		"preprocess",
		"postprocess",
		"processAllTokens"
	]);
	preprocess(e) {
		return e;
	}
	postprocess(e) {
		return e;
	}
	processAllTokens(e) {
		return e;
	}
	emStrongMask(e) {
		return e;
	}
	provideLexer() {
		return this.block ? XL.lex : XL.lexInline;
	}
	provideParser() {
		return this.block ? XI.parse : XI.parseInline;
	}
}, XD = new class {
	static {
		h(this, "B");
	}
	defaults = HM();
	options = this.setOptions;
	parse = this.parseMarkdown(!0);
	parseInline = this.parseMarkdown(!1);
	Parser = XI;
	Renderer = XR;
	TextRenderer = XN;
	Lexer = XL;
	Tokenizer = XA;
	Hooks = XM;
	constructor(...e) {
		this.use(...e);
	}
	walkTokens(e, t) {
		let r = [];
		for (let i of e) switch (r = r.concat(t.call(this, i)), i.type) {
			case "table":
				for (let e of i.header) r = r.concat(this.walkTokens(e.tokens, t));
				for (let e of i.rows) for (let i of e) r = r.concat(this.walkTokens(i.tokens, t));
				break;
			case "list":
				r = r.concat(this.walkTokens(i.items, t));
				break;
			default: {
				let e = i;
				this.defaults.extensions?.childTokens?.[e.type] ? this.defaults.extensions.childTokens[e.type].forEach((i) => {
					let n = e[i].flat(Infinity);
					r = r.concat(this.walkTokens(n, t));
				}) : e.tokens && (r = r.concat(this.walkTokens(e.tokens, t)));
			}
		}
		return r;
	}
	use(...e) {
		let t = this.defaults.extensions || {
			renderers: {},
			childTokens: {}
		};
		return e.forEach((e) => {
			let r = { ...e };
			if (r.async = this.defaults.async || r.async || !1, e.extensions && (e.extensions.forEach((e) => {
				if (!e.name) throw Error("extension name required");
				if ("renderer" in e) {
					let r = t.renderers[e.name];
					r ? t.renderers[e.name] = function(...t) {
						let i = e.renderer.apply(this, t);
						return !1 === i && (i = r.apply(this, t)), i;
					} : t.renderers[e.name] = e.renderer;
				}
				if ("tokenizer" in e) {
					if (!e.level || "block" !== e.level && "inline" !== e.level) throw Error("extension level must be 'block' or 'inline'");
					let r = t[e.level];
					r ? r.unshift(e.tokenizer) : t[e.level] = [e.tokenizer], e.start && ("block" === e.level ? t.startBlock ? t.startBlock.push(e.start) : t.startBlock = [e.start] : "inline" === e.level && (t.startInline ? t.startInline.push(e.start) : t.startInline = [e.start]));
				}
				"childTokens" in e && e.childTokens && (t.childTokens[e.name] = e.childTokens);
			}), r.extensions = t), e.renderer) {
				let t = this.defaults.renderer || new XR(this.defaults);
				for (let r in e.renderer) {
					if (!(r in t)) throw Error(`renderer '${r}' does not exist`);
					if (["options", "parser"].includes(r)) continue;
					let i = e.renderer[r], n = t[r];
					t[r] = (...e) => {
						let r = i.apply(t, e);
						return !1 === r && (r = n.apply(t, e)), r || "";
					};
				}
				r.renderer = t;
			}
			if (e.tokenizer) {
				let t = this.defaults.tokenizer || new XA(this.defaults);
				for (let r in e.tokenizer) {
					if (!(r in t)) throw Error(`tokenizer '${r}' does not exist`);
					if ([
						"options",
						"rules",
						"lexer"
					].includes(r)) continue;
					let i = e.tokenizer[r], n = t[r];
					t[r] = (...e) => {
						let r = i.apply(t, e);
						return !1 === r && (r = n.apply(t, e)), r;
					};
				}
				r.tokenizer = t;
			}
			if (e.hooks) {
				let t = this.defaults.hooks || new XM();
				for (let r in e.hooks) {
					if (!(r in t)) throw Error(`hook '${r}' does not exist`);
					if (["options", "block"].includes(r)) continue;
					let i = e.hooks[r], n = t[r];
					XM.passThroughHooks.has(r) ? t[r] = (e) => {
						if (this.defaults.async && XM.passThroughHooksRespectAsync.has(r)) return Promise.resolve(i.call(t, e)).then((e) => n.call(t, e));
						let a = i.call(t, e);
						return n.call(t, a);
					} : t[r] = (...e) => {
						let r = i.apply(t, e);
						return !1 === r && (r = n.apply(t, e)), r;
					};
				}
				r.hooks = t;
			}
			if (e.walkTokens) {
				let t = this.defaults.walkTokens, i = e.walkTokens;
				r.walkTokens = function(e) {
					let r = [];
					return r.push(i.call(this, e)), t && (r = r.concat(t.call(this, e))), r;
				};
			}
			this.defaults = {
				...this.defaults,
				...r
			};
		}), this;
	}
	setOptions(e) {
		return this.defaults = {
			...this.defaults,
			...e
		}, this;
	}
	lexer(e, t) {
		return XL.lex(e, t ?? this.defaults);
	}
	parser(e, t) {
		return XI.parse(e, t ?? this.defaults);
	}
	parseMarkdown(e) {
		return (t, r) => {
			let i = { ...r }, n = {
				...this.defaults,
				...i
			}, a = this.onError(!!n.silent, !!n.async);
			if (!0 === this.defaults.async && !1 === i.async) return a(Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
			if (typeof t > "u" || null === t) return a(Error("marked(): input parameter is undefined or null"));
			if ("string" != typeof t) return a(Error("marked(): input parameter is of type " + Object.prototype.toString.call(t) + ", string expected"));
			n.hooks && (n.hooks.options = n, n.hooks.block = e);
			let s = n.hooks ? n.hooks.provideLexer() : e ? XL.lex : XL.lexInline, o = n.hooks ? n.hooks.provideParser() : e ? XI.parse : XI.parseInline;
			if (n.async) return Promise.resolve(n.hooks ? n.hooks.preprocess(t) : t).then((e) => s(e, n)).then((e) => n.hooks ? n.hooks.processAllTokens(e) : e).then((e) => n.walkTokens ? Promise.all(this.walkTokens(e, n.walkTokens)).then(() => e) : e).then((e) => o(e, n)).then((e) => n.hooks ? n.hooks.postprocess(e) : e).catch(a);
			try {
				n.hooks && (t = n.hooks.preprocess(t));
				let e = s(t, n);
				n.hooks && (e = n.hooks.processAllTokens(e)), n.walkTokens && this.walkTokens(e, n.walkTokens);
				let r = o(e, n);
				return n.hooks && (r = n.hooks.postprocess(r)), r;
			} catch (e) {
				return a(e);
			}
		};
	}
	onError(e, t) {
		return (r) => {
			if (r.message += `
Please report this to https://github.com/markedjs/marked.`, e) {
				let e = "<p>An error occurred:</p><pre>" + Xw(r.message + "", !0) + "</pre>";
				return t ? Promise.resolve(e) : e;
			}
			if (t) return Promise.reject(r);
			throw r;
		};
	}
}();
function XO(e, t) {
	return XD.parse(e, t);
}
function X$(e, { markdownAutoWrap: t }) {
	let r = HI(e.replace(/<br\/>/g, `
`).replace(/\n{2,}/g, `
`));
	return !1 === t ? r.replace(/ /g, "&nbsp;") : r;
}
function XP(e, t = {}) {
	let r = X$(e, t), i = XO.lexer(r), n = [[]], a = 0;
	function s(e, t = "normal") {
		"text" === e.type ? e.text.split(`
`).forEach((e, r) => {
			0 !== r && (a++, n.push([])), e.split(" ").forEach((e) => {
				(e = e.replace(/&#39;/g, "'")) && n[a].push({
					content: e,
					type: t
				});
			});
		}) : "strong" === e.type || "em" === e.type ? e.tokens.forEach((t) => {
			s(t, e.type);
		}) : "html" === e.type && n[a].push({
			content: e.text,
			type: "normal"
		});
	}
	return h(s, "processNode"), i.forEach((e) => {
		"paragraph" === e.type ? e.tokens?.forEach((e) => {
			s(e);
		}) : "html" === e.type ? n[a].push({
			content: e.text,
			type: "normal"
		}) : n[a].push({
			content: e.raw,
			type: "normal"
		});
	}), n;
}
function XB(e, { markdownAutoWrap: t } = {}) {
	let r = XO.lexer(e);
	function i(e) {
		return "text" === e.type ? !1 === t ? e.text.replace(/\n */g, "<br/>").replace(/ /g, "&nbsp;") : e.text.replace(/\n */g, "<br/>") : "strong" === e.type ? `<strong>${e.tokens?.map(i).join("")}</strong>` : "em" === e.type ? `<em>${e.tokens?.map(i).join("")}</em>` : "paragraph" === e.type ? `<p>${e.tokens?.map(i).join("")}</p>` : "space" === e.type ? "" : "html" === e.type ? `${e.text}` : "escape" === e.type ? e.text : (wQ.warn(`Unsupported markdown: ${e.type}`), e.raw);
	}
	return h(i, "output"), r.map(i).join("");
}
function XF(e) {
	return Intl.Segmenter ? [...new Intl.Segmenter().segment(e)].map((e) => e.segment) : [...e];
}
function Xz(e, t) {
	return XU(e, [], XF(t.content), t.type);
}
function XU(e, t, r, i) {
	if (0 === r.length) return [{
		content: t.join(""),
		type: i
	}, {
		content: "",
		type: i
	}];
	let [n, ...a] = r, s = [...t, n];
	return e([{
		content: s.join(""),
		type: i
	}]) ? XU(e, s, a, i) : (0 === t.length && n && (t.push(n), r.shift()), [{
		content: t.join(""),
		type: i
	}, {
		content: r.join(""),
		type: i
	}]);
}
function XG(e, t) {
	if (e.some(({ content: e }) => e.includes(`
`))) throw Error("splitLineToFitWidth does not support newlines in the line");
	return Xq(e, t);
}
function Xq(e, t, r = [], i = []) {
	if (0 === e.length) return i.length > 0 && r.push(i), r.length > 0 ? r : [];
	let n = "";
	" " === e[0].content && (n = " ", e.shift());
	let a = e.shift() ?? {
		content: " ",
		type: "normal"
	}, s = [...i];
	if ("" !== n && s.push({
		content: n,
		type: "normal"
	}), s.push(a), t(s)) return Xq(e, t, r, s);
	if (i.length > 0) r.push(i), e.unshift(a);
	else if (a.content) {
		let [i, n] = Xz(t, a);
		r.push([i]), n.content && e.unshift(n);
	}
	return Xq(e, t, r);
}
function Xj(e, t) {
	t && e.attr("style", t);
}
async function XW(e, t, r, i, n = !1, a = IA()) {
	let s = e.append("foreignObject");
	s.attr("width", `${10 * r}px`), s.attr("height", `${10 * r}px`);
	let o = s.append("xhtml:div"), l = MZ(t.label) ? await M0(t.label.replace(M1.lineBreakRegex, `
`), a) : MO(t.label, a), h = t.isNode ? "nodeLabel" : "edgeLabel", u = o.append("span");
	u.html(l), Xj(u, t.labelStyle), u.attr("class", `${h} ${i}`), Xj(o, t.labelStyle), o.style("display", "table-cell"), o.style("white-space", "nowrap"), o.style("line-height", "1.5"), o.style("max-width", r + "px"), o.style("text-align", "center"), o.attr("xmlns", "http://www.w3.org/1999/xhtml"), n && o.attr("class", "labelBkg");
	let d = o.node().getBoundingClientRect();
	return d.width === r && (o.style("display", "table"), o.style("white-space", "break-spaces"), o.style("width", r + "px"), d = o.node().getBoundingClientRect()), s.node();
}
function XY(e, t, r) {
	return e.append("tspan").attr("class", "text-outer-tspan").attr("x", 0).attr("y", t * r - .1 + "em").attr("dy", r + "em");
}
function XV(e, t, r) {
	let i = e.append("text"), n = XY(i, 1, t);
	XK(n, r);
	let a = n.node().getComputedTextLength();
	return i.remove(), a;
}
function XH(e, t, r) {
	let i = e.append("text"), n = XY(i, 1, t);
	XK(n, [{
		content: r,
		type: "normal"
	}]);
	let a = n.node()?.getBoundingClientRect();
	return a && i.remove(), a;
}
function XX(e, t, r, i = !1) {
	let n = t.append("g"), a = n.insert("rect").attr("class", "background").attr("style", "stroke: none"), s = n.append("text").attr("y", "-10.1"), o = 0;
	for (let t of r) {
		let r = h((t) => XV(n, 1.1, t) <= e, "checkWidth");
		for (let e of r(t) ? [t] : XG(t, r)) XK(XY(s, o, 1.1), e), o++;
	}
	if (!i) return s.node();
	{
		let e = s.node().getBBox();
		return a.attr("x", e.x - 2).attr("y", e.y - 2).attr("width", e.width + 4).attr("height", e.height + 4), n.node();
	}
}
function XK(e, t) {
	e.text(""), t.forEach((t, r) => {
		let i = e.append("tspan").attr("font-style", "em" === t.type ? "italic" : "normal").attr("class", "text-inner-tspan").attr("font-weight", "strong" === t.type ? "bold" : "normal");
		0 === r ? i.text(t.content) : i.text(" " + t.content);
	});
}
async function XZ(e, t = {}) {
	let r = [];
	e.replace(/(fa[bklrs]?):fa-([\w-]+)/g, (e, i, n) => (r.push((async () => {
		let r = `${i}:${n}`;
		return await HR(r) ? await HN(r, void 0, { class: "label-icon" }) : `<i class='${MO(e, t).replace(":", " ")}'></i>`;
	})()), e));
	let i = await Promise.all(r);
	return e.replace(/(fa[bklrs]?):fa-([\w-]+)/g, () => i.shift() ?? "");
}
h(XO, "d"), XO.options = XO.setOptions = function(e) {
	return XD.setOptions(e), XO.defaults = XD.defaults, HO(XO.defaults), XO;
}, XO.getDefaults = HM, XO.defaults = HD, XO.use = function(...e) {
	return XD.use(...e), XO.defaults = XD.defaults, HO(XO.defaults), XO;
}, XO.walkTokens = function(e, t) {
	return XD.walkTokens(e, t);
}, XO.parseInline = XD.parseInline, XO.Parser = XI, XO.parser = XI.parse, XO.Renderer = XR, XO.TextRenderer = XN, XO.Lexer = XL, XO.lexer = XL.lex, XO.Tokenizer = XA, XO.Hooks = XM, XO.parse = XO, XO.options, XO.setOptions, XO.use, XO.walkTokens, XO.parseInline, XI.parse, XL.lex, h(X$, "preprocessMarkdown"), h(XP, "markdownToLines"), h(XB, "markdownToHTML"), h(XF, "splitTextToChars"), h(Xz, "splitWordToFitWidth"), h(XU, "splitWordToFitWidthRecursion"), h(XG, "splitLineToFitWidth"), h(Xq, "splitLineToFitWidthRecursion"), h(Xj, "applyStyle"), h(XW, "addHtmlSpan"), h(XY, "createTspan"), h(XV, "computeWidthOfText"), h(XH, "computeDimensionOfText"), h(XX, "createFormattedText"), h(XK, "updateTextContentAndStyles"), h(XZ, "replaceIconSubstring");
var XQ = h(async (e, t = "", { style: r = "", isTitle: i = !1, classes: n = "", useHtmlLabels: a = !0, isNode: s = !0, width: o = 200, addSvgBackground: l = !1 } = {}, h) => {
	if (wQ.debug("XYZ createText", t, r, i, n, a, s, "addSvgBackground: ", l), a) {
		let i = await XZ(V6(XB(t, h)), h), a = t.replace(/\\\\/g, "\\");
		return await XW(e, {
			isNode: s,
			label: MZ(t) ? a : i,
			labelStyle: r.replace("fill:", "color:")
		}, o, n, l, h);
	}
	{
		let i = XX(o, e, XP(t.replace(/<br\s*\/?>/g, "<br/>").replace("<br>", "<br/>"), h), !!t && l);
		if (s) {
			/stroke:/.exec(r) && (r = r.replace("stroke:", "lineColor:"));
			let e = r.replace(/stroke:[^;]+;?/g, "").replace(/stroke-width:[^;]+;?/g, "").replace(/fill:[^;]+;?/g, "").replace(/color:/g, "fill:");
			_t(i).attr("style", e);
		} else {
			let e = r.replace(/stroke:[^;]+;?/g, "").replace(/stroke-width:[^;]+;?/g, "").replace(/fill:[^;]+;?/g, "").replace(/background:/g, "fill:");
			_t(i).select("rect").attr("style", e.replace(/background:/g, "fill:"));
			let t = r.replace(/stroke:[^;]+;?/g, "").replace(/stroke-width:[^;]+;?/g, "").replace(/fill:[^;]+;?/g, "").replace(/color:/g, "fill:");
			_t(i).select("text").attr("style", t);
		}
		return i;
	}
}, "createText"), XJ = class extends wx {
	static {
		h(this, "InfoTokenBuilder");
	}
	static {
		bl(this, "InfoTokenBuilder");
	}
	constructor() {
		super(["info", "showInfo"]);
	}
}, X0 = { parser: {
	TokenBuilder: bl(() => new XJ(), "TokenBuilder"),
	ValueConverter: bl(() => new wv(), "ValueConverter")
} };
function X1(e = br) {
	let t = xW(xj(e), wl), r = xW(xq({ shared: t }), wc, X0);
	return t.ServiceRegistry.register(r), {
		shared: t,
		Info: r
	};
}
h(X1, "createInfoServices"), bl(X1, "createInfoServices");
var X2 = u((e, t) => {
	h(function(r, i) {
		"object" == typeof e && "object" == typeof t ? t.exports = i() : "function" == typeof define && define.amd ? define([], i) : "object" == typeof e ? e.layoutBase = i() : r.layoutBase = i();
	}, "webpackUniversalModuleDefinition")(e, function() {
		var e = [
			function(e, t, r) {
				function i() {}
				h(i, "LayoutConstants"), i.QUALITY = 1, i.DEFAULT_CREATE_BENDS_AS_NEEDED = !1, i.DEFAULT_INCREMENTAL = !1, i.DEFAULT_ANIMATION_ON_LAYOUT = !0, i.DEFAULT_ANIMATION_DURING_LAYOUT = !1, i.DEFAULT_ANIMATION_PERIOD = 50, i.DEFAULT_UNIFORM_LEAF_NODE_SIZES = !1, i.DEFAULT_GRAPH_MARGIN = 15, i.NODE_DIMENSIONS_INCLUDE_LABELS = !1, i.SIMPLE_NODE_SIZE = 40, i.SIMPLE_NODE_HALF_SIZE = i.SIMPLE_NODE_SIZE / 2, i.EMPTY_COMPOUND_NODE_SIZE = 40, i.MIN_EDGE_LENGTH = 1, i.WORLD_BOUNDARY = 1e6, i.INITIAL_WORLD_BOUNDARY = i.WORLD_BOUNDARY / 1e3, i.WORLD_CENTER_X = 1200, i.WORLD_CENTER_Y = 900, e.exports = i;
			},
			function(e, t, r) {
				var i = r(2), n = r(8), a = r(9);
				function s(e, t, r) {
					i.call(this, r), this.isOverlapingSourceAndTarget = !1, this.vGraphObject = r, this.bendpoints = [], this.source = e, this.target = t;
				}
				for (var o in h(s, "LEdge"), s.prototype = Object.create(i.prototype), i) s[o] = i[o];
				s.prototype.getSource = function() {
					return this.source;
				}, s.prototype.getTarget = function() {
					return this.target;
				}, s.prototype.isInterGraph = function() {
					return this.isInterGraph;
				}, s.prototype.getLength = function() {
					return this.length;
				}, s.prototype.isOverlapingSourceAndTarget = function() {
					return this.isOverlapingSourceAndTarget;
				}, s.prototype.getBendpoints = function() {
					return this.bendpoints;
				}, s.prototype.getLca = function() {
					return this.lca;
				}, s.prototype.getSourceInLca = function() {
					return this.sourceInLca;
				}, s.prototype.getTargetInLca = function() {
					return this.targetInLca;
				}, s.prototype.getOtherEnd = function(e) {
					if (this.source === e) return this.target;
					if (this.target === e) return this.source;
					throw "Node is not incident with this edge";
				}, s.prototype.getOtherEndInGraph = function(e, t) {
					for (var r = this.getOtherEnd(e), i = t.getGraphManager().getRoot();;) {
						if (r.getOwner() == t) return r;
						if (r.getOwner() == i) break;
						r = r.getOwner().getParent();
					}
					return null;
				}, s.prototype.updateLength = function() {
					var e = [
						,
						,
						,
						,
					];
					this.isOverlapingSourceAndTarget = n.getIntersection(this.target.getRect(), this.source.getRect(), e), this.isOverlapingSourceAndTarget || (this.lengthX = e[0] - e[2], this.lengthY = e[1] - e[3], 1 > Math.abs(this.lengthX) && (this.lengthX = a.sign(this.lengthX)), 1 > Math.abs(this.lengthY) && (this.lengthY = a.sign(this.lengthY)), this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY));
				}, s.prototype.updateLengthSimple = function() {
					this.lengthX = this.target.getCenterX() - this.source.getCenterX(), this.lengthY = this.target.getCenterY() - this.source.getCenterY(), 1 > Math.abs(this.lengthX) && (this.lengthX = a.sign(this.lengthX)), 1 > Math.abs(this.lengthY) && (this.lengthY = a.sign(this.lengthY)), this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);
				}, e.exports = s;
			},
			function(e, t, r) {
				function i(e) {
					this.vGraphObject = e;
				}
				h(i, "LGraphObject"), e.exports = i;
			},
			function(e, t, r) {
				var i = r(2), n = r(10), a = r(13), s = r(0), o = r(16), l = r(5);
				function u(e, t, r, s) {
					null == r && null == s && (s = t), i.call(this, s), null != e.graphManager && (e = e.graphManager), this.estimatedSize = n.MIN_VALUE, this.inclusionTreeDepth = n.MAX_VALUE, this.vGraphObject = s, this.edges = [], this.graphManager = e, null != r && null != t ? this.rect = new a(t.x, t.y, r.width, r.height) : this.rect = new a();
				}
				for (var d in h(u, "LNode"), u.prototype = Object.create(i.prototype), i) u[d] = i[d];
				u.prototype.getEdges = function() {
					return this.edges;
				}, u.prototype.getChild = function() {
					return this.child;
				}, u.prototype.getOwner = function() {
					return this.owner;
				}, u.prototype.getWidth = function() {
					return this.rect.width;
				}, u.prototype.setWidth = function(e) {
					this.rect.width = e;
				}, u.prototype.getHeight = function() {
					return this.rect.height;
				}, u.prototype.setHeight = function(e) {
					this.rect.height = e;
				}, u.prototype.getCenterX = function() {
					return this.rect.x + this.rect.width / 2;
				}, u.prototype.getCenterY = function() {
					return this.rect.y + this.rect.height / 2;
				}, u.prototype.getCenter = function() {
					return new l(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);
				}, u.prototype.getLocation = function() {
					return new l(this.rect.x, this.rect.y);
				}, u.prototype.getRect = function() {
					return this.rect;
				}, u.prototype.getDiagonal = function() {
					return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);
				}, u.prototype.getHalfTheDiagonal = function() {
					return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;
				}, u.prototype.setRect = function(e, t) {
					this.rect.x = e.x, this.rect.y = e.y, this.rect.width = t.width, this.rect.height = t.height;
				}, u.prototype.setCenter = function(e, t) {
					this.rect.x = e - this.rect.width / 2, this.rect.y = t - this.rect.height / 2;
				}, u.prototype.setLocation = function(e, t) {
					this.rect.x = e, this.rect.y = t;
				}, u.prototype.moveBy = function(e, t) {
					this.rect.x += e, this.rect.y += t;
				}, u.prototype.getEdgeListToNode = function(e) {
					var t = [], r = this;
					return r.edges.forEach(function(i) {
						if (i.target == e) {
							if (i.source != r) throw "Incorrect edge source!";
							t.push(i);
						}
					}), t;
				}, u.prototype.getEdgesBetween = function(e) {
					var t = [], r = this;
					return r.edges.forEach(function(i) {
						if (i.source != r && i.target != r) throw "Incorrect edge source and/or target";
						(i.target == e || i.source == e) && t.push(i);
					}), t;
				}, u.prototype.getNeighborsList = function() {
					var e = /* @__PURE__ */ new Set(), t = this;
					return t.edges.forEach(function(r) {
						if (r.source == t) e.add(r.target);
						else {
							if (r.target != t) throw "Incorrect incidency!";
							e.add(r.source);
						}
					}), e;
				}, u.prototype.withChildren = function() {
					var e = /* @__PURE__ */ new Set();
					if (e.add(this), null != this.child) for (var t = this.child.getNodes(), r = 0; r < t.length; r++) t[r].withChildren().forEach(function(t) {
						e.add(t);
					});
					return e;
				}, u.prototype.getNoOfChildren = function() {
					var e = 0;
					if (null == this.child) e = 1;
					else for (var t = this.child.getNodes(), r = 0; r < t.length; r++) e += t[r].getNoOfChildren();
					return 0 == e && (e = 1), e;
				}, u.prototype.getEstimatedSize = function() {
					if (this.estimatedSize == n.MIN_VALUE) throw "assert failed";
					return this.estimatedSize;
				}, u.prototype.calcEstimatedSize = function() {
					return null == this.child ? this.estimatedSize = (this.rect.width + this.rect.height) / 2 : (this.estimatedSize = this.child.calcEstimatedSize(), this.rect.width = this.estimatedSize, this.rect.height = this.estimatedSize, this.estimatedSize);
				}, u.prototype.scatter = function() {
					var e, t, r = -s.INITIAL_WORLD_BOUNDARY, i = s.INITIAL_WORLD_BOUNDARY;
					e = s.WORLD_CENTER_X + o.nextDouble() * (i - r) + r;
					var n = -s.INITIAL_WORLD_BOUNDARY, a = s.INITIAL_WORLD_BOUNDARY;
					t = s.WORLD_CENTER_Y + o.nextDouble() * (a - n) + n, this.rect.x = e, this.rect.y = t;
				}, u.prototype.updateBounds = function() {
					if (null == this.getChild()) throw "assert failed";
					if (0 != this.getChild().getNodes().length) {
						var e = this.getChild();
						if (e.updateBounds(!0), this.rect.x = e.getLeft(), this.rect.y = e.getTop(), this.setWidth(e.getRight() - e.getLeft()), this.setHeight(e.getBottom() - e.getTop()), s.NODE_DIMENSIONS_INCLUDE_LABELS) {
							var t = e.getRight() - e.getLeft(), r = e.getBottom() - e.getTop();
							this.labelWidth && ("left" == this.labelPosHorizontal ? (this.rect.x -= this.labelWidth, this.setWidth(t + this.labelWidth)) : "center" == this.labelPosHorizontal && this.labelWidth > t ? (this.rect.x -= (this.labelWidth - t) / 2, this.setWidth(this.labelWidth)) : "right" == this.labelPosHorizontal && this.setWidth(t + this.labelWidth)), this.labelHeight && ("top" == this.labelPosVertical ? (this.rect.y -= this.labelHeight, this.setHeight(r + this.labelHeight)) : "center" == this.labelPosVertical && this.labelHeight > r ? (this.rect.y -= (this.labelHeight - r) / 2, this.setHeight(this.labelHeight)) : "bottom" == this.labelPosVertical && this.setHeight(r + this.labelHeight));
						}
					}
				}, u.prototype.getInclusionTreeDepth = function() {
					if (this.inclusionTreeDepth == n.MAX_VALUE) throw "assert failed";
					return this.inclusionTreeDepth;
				}, u.prototype.transform = function(e) {
					var t = this.rect.x;
					t > s.WORLD_BOUNDARY ? t = s.WORLD_BOUNDARY : t < -s.WORLD_BOUNDARY && (t = -s.WORLD_BOUNDARY);
					var r = this.rect.y;
					r > s.WORLD_BOUNDARY ? r = s.WORLD_BOUNDARY : r < -s.WORLD_BOUNDARY && (r = -s.WORLD_BOUNDARY);
					var i = new l(t, r), n = e.inverseTransformPoint(i);
					this.setLocation(n.x, n.y);
				}, u.prototype.getLeft = function() {
					return this.rect.x;
				}, u.prototype.getRight = function() {
					return this.rect.x + this.rect.width;
				}, u.prototype.getTop = function() {
					return this.rect.y;
				}, u.prototype.getBottom = function() {
					return this.rect.y + this.rect.height;
				}, u.prototype.getParent = function() {
					return null == this.owner ? null : this.owner.getParent();
				}, e.exports = u;
			},
			function(e, t, r) {
				var i = r(0);
				function n() {}
				for (var a in h(n, "FDLayoutConstants"), i) n[a] = i[a];
				n.MAX_ITERATIONS = 2500, n.DEFAULT_EDGE_LENGTH = 50, n.DEFAULT_SPRING_STRENGTH = .45, n.DEFAULT_REPULSION_STRENGTH = 4500, n.DEFAULT_GRAVITY_STRENGTH = .4, n.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1, n.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8, n.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5, n.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = !0, n.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = !0, n.DEFAULT_COOLING_FACTOR_INCREMENTAL = .3, n.COOLING_ADAPTATION_FACTOR = .33, n.ADAPTATION_LOWER_NODE_LIMIT = 1e3, n.ADAPTATION_UPPER_NODE_LIMIT = 5e3, n.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100, n.MAX_NODE_DISPLACEMENT = 3 * n.MAX_NODE_DISPLACEMENT_INCREMENTAL, n.MIN_REPULSION_DIST = n.DEFAULT_EDGE_LENGTH / 10, n.CONVERGENCE_CHECK_PERIOD = 100, n.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = .1, n.MIN_EDGE_LENGTH = 1, n.GRID_CALCULATION_CHECK_PERIOD = 10, e.exports = n;
			},
			function(e, t, r) {
				function i(e, t) {
					null == e && null == t ? (this.x = 0, this.y = 0) : (this.x = e, this.y = t);
				}
				h(i, "PointD"), i.prototype.getX = function() {
					return this.x;
				}, i.prototype.getY = function() {
					return this.y;
				}, i.prototype.setX = function(e) {
					this.x = e;
				}, i.prototype.setY = function(e) {
					this.y = e;
				}, i.prototype.getDifference = function(e) {
					return new DimensionD(this.x - e.x, this.y - e.y);
				}, i.prototype.getCopy = function() {
					return new i(this.x, this.y);
				}, i.prototype.translate = function(e) {
					return this.x += e.width, this.y += e.height, this;
				}, e.exports = i;
			},
			function(e, t, r) {
				var i = r(2), n = r(10), a = r(0), s = r(7), o = r(3), l = r(1), u = r(13), d = r(12), p = r(11);
				function f(e, t, r) {
					i.call(this, r), this.estimatedSize = n.MIN_VALUE, this.margin = a.DEFAULT_GRAPH_MARGIN, this.edges = [], this.nodes = [], this.isConnected = !1, this.parent = e, null != t && t instanceof s ? this.graphManager = t : null != t && t instanceof Layout && (this.graphManager = t.graphManager);
				}
				for (var g in h(f, "LGraph"), f.prototype = Object.create(i.prototype), i) f[g] = i[g];
				f.prototype.getNodes = function() {
					return this.nodes;
				}, f.prototype.getEdges = function() {
					return this.edges;
				}, f.prototype.getGraphManager = function() {
					return this.graphManager;
				}, f.prototype.getParent = function() {
					return this.parent;
				}, f.prototype.getLeft = function() {
					return this.left;
				}, f.prototype.getRight = function() {
					return this.right;
				}, f.prototype.getTop = function() {
					return this.top;
				}, f.prototype.getBottom = function() {
					return this.bottom;
				}, f.prototype.isConnected = function() {
					return this.isConnected;
				}, f.prototype.add = function(e, t, r) {
					if (null == t && null == r) {
						if (null == this.graphManager) throw "Graph has no graph mgr!";
						if (this.getNodes().indexOf(e) > -1) throw "Node already in graph!";
						return e.owner = this, this.getNodes().push(e), e;
					}
					if (!(this.getNodes().indexOf(t) > -1 && this.getNodes().indexOf(r) > -1)) throw "Source or target not in graph!";
					if (t.owner != r.owner || t.owner != this) throw "Both owners must be this graph!";
					return t.owner != r.owner ? null : (e.source = t, e.target = r, e.isInterGraph = !1, this.getEdges().push(e), t.edges.push(e), r != t && r.edges.push(e), e);
				}, f.prototype.remove = function(e) {
					if (e instanceof o) {
						if (null == e) throw "Node is null!";
						if (null == e.owner || e.owner != this) throw "Owner graph is invalid!";
						if (null == this.graphManager) throw "Owner graph manager is invalid!";
						for (var t, r = e.edges.slice(), i = r.length, n = 0; n < i; n++) (t = r[n]).isInterGraph ? this.graphManager.remove(t) : t.source.owner.remove(t);
						var a = this.nodes.indexOf(e);
						if (-1 == a) throw "Node not in owner node list!";
						this.nodes.splice(a, 1);
					} else if (e instanceof l) {
						var t = e;
						if (null == t) throw "Edge is null!";
						if (null == t.source || null == t.target) throw "Source and/or target is null!";
						if (null == t.source.owner || null == t.target.owner || t.source.owner != this || t.target.owner != this) throw "Source and/or target owner is invalid!";
						var s = t.source.edges.indexOf(t), h = t.target.edges.indexOf(t);
						if (!(s > -1 && h > -1)) throw "Source and/or target doesn't know this edge!";
						t.source.edges.splice(s, 1), t.target != t.source && t.target.edges.splice(h, 1);
						var a = t.source.owner.getEdges().indexOf(t);
						if (-1 == a) throw "Not in owner's edge list!";
						t.source.owner.getEdges().splice(a, 1);
					}
				}, f.prototype.updateLeftTop = function() {
					for (var e, t, r, i = n.MAX_VALUE, a = n.MAX_VALUE, s = this.getNodes(), o = s.length, l = 0; l < o; l++) {
						var h = s[l];
						e = h.getTop(), t = h.getLeft(), i > e && (i = e), a > t && (a = t);
					}
					return i == n.MAX_VALUE ? null : (r = null != s[0].getParent().paddingLeft ? s[0].getParent().paddingLeft : this.margin, this.left = a - r, this.top = i - r, new d(this.left, this.top));
				}, f.prototype.updateBounds = function(e) {
					for (var t, r, i, a, s, o = n.MAX_VALUE, l = -n.MAX_VALUE, h = n.MAX_VALUE, d = -n.MAX_VALUE, p = this.nodes, f = p.length, g = 0; g < f; g++) {
						var m = p[g];
						e && null != m.child && m.updateBounds(), t = m.getLeft(), r = m.getRight(), i = m.getTop(), a = m.getBottom(), o > t && (o = t), l < r && (l = r), h > i && (h = i), d < a && (d = a);
					}
					var y = new u(o, h, l - o, d - h);
					o == n.MAX_VALUE && (this.left = this.parent.getLeft(), this.right = this.parent.getRight(), this.top = this.parent.getTop(), this.bottom = this.parent.getBottom()), s = null != p[0].getParent().paddingLeft ? p[0].getParent().paddingLeft : this.margin, this.left = y.x - s, this.right = y.x + y.width + s, this.top = y.y - s, this.bottom = y.y + y.height + s;
				}, f.calculateBounds = function(e) {
					for (var t, r, i, a, s = n.MAX_VALUE, o = -n.MAX_VALUE, l = n.MAX_VALUE, h = -n.MAX_VALUE, d = e.length, p = 0; p < d; p++) {
						var f = e[p];
						t = f.getLeft(), r = f.getRight(), i = f.getTop(), a = f.getBottom(), s > t && (s = t), o < r && (o = r), l > i && (l = i), h < a && (h = a);
					}
					return new u(s, l, o - s, h - l);
				}, f.prototype.getInclusionTreeDepth = function() {
					return this == this.graphManager.getRoot() ? 1 : this.parent.getInclusionTreeDepth();
				}, f.prototype.getEstimatedSize = function() {
					if (this.estimatedSize == n.MIN_VALUE) throw "assert failed";
					return this.estimatedSize;
				}, f.prototype.calcEstimatedSize = function() {
					for (var e = 0, t = this.nodes, r = t.length, i = 0; i < r; i++) e += t[i].calcEstimatedSize();
					return 0 == e ? this.estimatedSize = a.EMPTY_COMPOUND_NODE_SIZE : this.estimatedSize = e / Math.sqrt(this.nodes.length), this.estimatedSize;
				}, f.prototype.updateConnected = function() {
					var e = this;
					if (0 == this.nodes.length) {
						this.isConnected = !0;
						return;
					}
					var t, r, i = new p(), n = /* @__PURE__ */ new Set(), a = this.nodes[0];
					for (a.withChildren().forEach(function(e) {
						i.push(e), n.add(e);
					}); 0 !== i.length;) {
						t = (a = i.shift()).getEdges();
						for (var s = t.length, o = 0; o < s; o++) null == (r = t[o].getOtherEndInGraph(a, this)) || n.has(r) || r.withChildren().forEach(function(e) {
							i.push(e), n.add(e);
						});
					}
					if (this.isConnected = !1, n.size >= this.nodes.length) {
						var l = 0;
						n.forEach(function(t) {
							t.owner == e && l++;
						}), l == this.nodes.length && (this.isConnected = !0);
					}
				}, e.exports = f;
			},
			function(e, t, r) {
				var i, n = r(1);
				function a(e) {
					i = r(6), this.layout = e, this.graphs = [], this.edges = [];
				}
				h(a, "LGraphManager"), a.prototype.addRoot = function() {
					var e = this.layout.newGraph(), t = this.layout.newNode(null), r = this.add(e, t);
					return this.setRootGraph(r), this.rootGraph;
				}, a.prototype.add = function(e, t, r, i, n) {
					if (null == r && null == i && null == n) {
						if (null == e) throw "Graph is null!";
						if (null == t) throw "Parent node is null!";
						if (this.graphs.indexOf(e) > -1) throw "Graph already in this graph mgr!";
						if (this.graphs.push(e), null != e.parent) throw "Already has a parent!";
						if (null != t.child) throw "Already has a child!";
						return e.parent = t, t.child = e, e;
					}
					n = r, i = t, r = e;
					var a = i.getOwner(), s = n.getOwner();
					if (null == a || a.getGraphManager() != this) throw "Source not in this graph mgr!";
					if (null == s || s.getGraphManager() != this) throw "Target not in this graph mgr!";
					if (a == s) return r.isInterGraph = !1, a.add(r, i, n);
					if (r.isInterGraph = !0, r.source = i, r.target = n, this.edges.indexOf(r) > -1) throw "Edge already in inter-graph edge list!";
					if (this.edges.push(r), null == r.source || null == r.target) throw "Edge source and/or target is null!";
					if (-1 != r.source.edges.indexOf(r) || -1 != r.target.edges.indexOf(r)) throw "Edge already in source and/or target incidency list!";
					return r.source.edges.push(r), r.target.edges.push(r), r;
				}, a.prototype.remove = function(e) {
					if (e instanceof i) {
						if (e.getGraphManager() != this) throw "Graph not in this graph mgr";
						if (e != this.rootGraph && (null == e.parent || e.parent.graphManager != this)) throw "Invalid parent node!";
						var t = [];
						t = t.concat(e.getEdges());
						for (var r, a, s = t.length, o = 0; o < s; o++) a = t[o], e.remove(a);
						var l = [];
						s = (l = l.concat(e.getNodes())).length;
						for (var o = 0; o < s; o++) r = l[o], e.remove(r);
						e == this.rootGraph && this.setRootGraph(null);
						var h = this.graphs.indexOf(e);
						this.graphs.splice(h, 1), e.parent = null;
					} else if (e instanceof n) {
						if (null == (a = e)) throw "Edge is null!";
						if (!a.isInterGraph) throw "Not an inter-graph edge!";
						if (null == a.source || null == a.target) throw "Source and/or target is null!";
						if (-1 == a.source.edges.indexOf(a) || -1 == a.target.edges.indexOf(a)) throw "Source and/or target doesn't know this edge!";
						var h = a.source.edges.indexOf(a);
						if (a.source.edges.splice(h, 1), h = a.target.edges.indexOf(a), a.target.edges.splice(h, 1), null == a.source.owner || null == a.source.owner.getGraphManager()) throw "Edge owner graph or owner graph manager is null!";
						if (-1 == a.source.owner.getGraphManager().edges.indexOf(a)) throw "Not in owner graph manager's edge list!";
						var h = a.source.owner.getGraphManager().edges.indexOf(a);
						a.source.owner.getGraphManager().edges.splice(h, 1);
					}
				}, a.prototype.updateBounds = function() {
					this.rootGraph.updateBounds(!0);
				}, a.prototype.getGraphs = function() {
					return this.graphs;
				}, a.prototype.getAllNodes = function() {
					if (null == this.allNodes) {
						for (var e = [], t = this.getGraphs(), r = t.length, i = 0; i < r; i++) e = e.concat(t[i].getNodes());
						this.allNodes = e;
					}
					return this.allNodes;
				}, a.prototype.resetAllNodes = function() {
					this.allNodes = null;
				}, a.prototype.resetAllEdges = function() {
					this.allEdges = null;
				}, a.prototype.resetAllNodesToApplyGravitation = function() {
					this.allNodesToApplyGravitation = null;
				}, a.prototype.getAllEdges = function() {
					if (null == this.allEdges) {
						for (var e = [], t = this.getGraphs(), r = (t.length, 0); r < t.length; r++) e = e.concat(t[r].getEdges());
						e = e.concat(this.edges), this.allEdges = e;
					}
					return this.allEdges;
				}, a.prototype.getAllNodesToApplyGravitation = function() {
					return this.allNodesToApplyGravitation;
				}, a.prototype.setAllNodesToApplyGravitation = function(e) {
					if (null != this.allNodesToApplyGravitation) throw "assert failed";
					this.allNodesToApplyGravitation = e;
				}, a.prototype.getRoot = function() {
					return this.rootGraph;
				}, a.prototype.setRootGraph = function(e) {
					if (e.getGraphManager() != this) throw "Root not in this graph mgr!";
					this.rootGraph = e, e.parent ??= this.layout.newNode("Root node");
				}, a.prototype.getLayout = function() {
					return this.layout;
				}, a.prototype.isOneAncestorOfOther = function(e, t) {
					if (null == e || null == t) throw "assert failed";
					if (e == t) return !0;
					for (var r, i = e.getOwner(); null != (r = i.getParent());) {
						if (r == t) return !0;
						if (null == (i = r.getOwner())) break;
					}
					for (i = t.getOwner(); null != (r = i.getParent());) {
						if (r == e) return !0;
						if (null == (i = r.getOwner())) break;
					}
					return !1;
				}, a.prototype.calcLowestCommonAncestors = function() {
					for (var e, t, r, i, n, a = this.getAllEdges(), s = a.length, o = 0; o < s; o++) {
						if (t = (e = a[o]).source, r = e.target, e.lca = null, e.sourceInLca = t, e.targetInLca = r, t == r) {
							e.lca = t.getOwner();
							continue;
						}
						for (i = t.getOwner(); null == e.lca;) {
							for (e.targetInLca = r, n = r.getOwner(); null == e.lca;) {
								if (n == i) {
									e.lca = n;
									break;
								}
								if (n == this.rootGraph) break;
								if (null != e.lca) throw "assert failed";
								e.targetInLca = n.getParent(), n = e.targetInLca.getOwner();
							}
							if (i == this.rootGraph) break;
							e.lca ?? (e.sourceInLca = i.getParent(), i = e.sourceInLca.getOwner());
						}
						if (null == e.lca) throw "assert failed";
					}
				}, a.prototype.calcLowestCommonAncestor = function(e, t) {
					if (e == t) return e.getOwner();
					for (var r = e.getOwner(); null != r;) {
						for (var i = t.getOwner(); null != i;) {
							if (i == r) return i;
							i = i.getParent().getOwner();
						}
						r = r.getParent().getOwner();
					}
					return r;
				}, a.prototype.calcInclusionTreeDepths = function(e, t) {
					null == e && null == t && (e = this.rootGraph, t = 1);
					for (var r, i = e.getNodes(), n = i.length, a = 0; a < n; a++) (r = i[a]).inclusionTreeDepth = t, null != r.child && this.calcInclusionTreeDepths(r.child, t + 1);
				}, a.prototype.includesInvalidEdge = function() {
					for (var e, t = [], r = this.edges.length, i = 0; i < r; i++) e = this.edges[i], this.isOneAncestorOfOther(e.source, e.target) && t.push(e);
					for (var i = 0; i < t.length; i++) this.remove(t[i]);
					return !1;
				}, e.exports = a;
			},
			function(e, t, r) {
				var i = r(12);
				function n() {}
				h(n, "IGeometry"), n.calcSeparationAmount = function(e, t, r, i) {
					if (!e.intersects(t)) throw "assert failed";
					var n = [, ,];
					this.decideDirectionsForOverlappingNodes(e, t, n), r[0] = Math.min(e.getRight(), t.getRight()) - Math.max(e.x, t.x), r[1] = Math.min(e.getBottom(), t.getBottom()) - Math.max(e.y, t.y), e.getX() <= t.getX() && e.getRight() >= t.getRight() ? r[0] += Math.min(t.getX() - e.getX(), e.getRight() - t.getRight()) : t.getX() <= e.getX() && t.getRight() >= e.getRight() && (r[0] += Math.min(e.getX() - t.getX(), t.getRight() - e.getRight())), e.getY() <= t.getY() && e.getBottom() >= t.getBottom() ? r[1] += Math.min(t.getY() - e.getY(), e.getBottom() - t.getBottom()) : t.getY() <= e.getY() && t.getBottom() >= e.getBottom() && (r[1] += Math.min(e.getY() - t.getY(), t.getBottom() - e.getBottom()));
					var a = Math.abs((t.getCenterY() - e.getCenterY()) / (t.getCenterX() - e.getCenterX()));
					t.getCenterY() === e.getCenterY() && t.getCenterX() === e.getCenterX() && (a = 1);
					var s = a * r[0], o = r[1] / a;
					r[0] < o ? o = r[0] : s = r[1], r[0] = -1 * n[0] * (o / 2 + i), r[1] = -1 * n[1] * (s / 2 + i);
				}, n.decideDirectionsForOverlappingNodes = function(e, t, r) {
					e.getCenterX() < t.getCenterX() ? r[0] = -1 : r[0] = 1, e.getCenterY() < t.getCenterY() ? r[1] = -1 : r[1] = 1;
				}, n.getIntersection2 = function(e, t, r) {
					var i = e.getCenterX(), n = e.getCenterY(), a = t.getCenterX(), s = t.getCenterY();
					if (e.intersects(t)) return r[0] = i, r[1] = n, r[2] = a, r[3] = s, !0;
					var o = e.getX(), l = e.getY(), h = e.getRight(), u = e.getX(), d = e.getBottom(), p = e.getRight(), f = e.getWidthHalf(), g = e.getHeightHalf(), m = t.getX(), y = t.getY(), v = t.getRight(), x = t.getX(), b = t.getBottom(), w = t.getRight(), k = t.getWidthHalf(), T = t.getHeightHalf(), _ = !1, E = !1;
					if (i === a) {
						if (n > s) return r[0] = i, r[1] = l, r[2] = a, r[3] = b, !1;
						if (n < s) return r[0] = i, r[1] = d, r[2] = a, r[3] = y, !1;
					} else if (n === s) {
						if (i > a) return r[0] = o, r[1] = n, r[2] = v, r[3] = s, !1;
						if (i < a) return r[0] = h, r[1] = n, r[2] = m, r[3] = s, !1;
					} else {
						var C = e.height / e.width, S = t.height / t.width, A = (s - n) / (a - i), L = void 0, R = void 0, N = void 0, I = void 0, M = void 0, D = void 0;
						if (-C === A ? (i > a ? (r[0] = u, r[1] = d) : (r[0] = h, r[1] = l), _ = !0) : C === A && (i > a ? (r[0] = o, r[1] = l) : (r[0] = p, r[1] = d), _ = !0), -S === A ? (a > i ? (r[2] = x, r[3] = b) : (r[2] = v, r[3] = y), E = !0) : S === A && (a > i ? (r[2] = m, r[3] = y) : (r[2] = w, r[3] = b), E = !0), _ && E) return !1;
						if (i > a ? n > s ? (L = this.getCardinalDirection(C, A, 4), R = this.getCardinalDirection(S, A, 2)) : (L = this.getCardinalDirection(-C, A, 3), R = this.getCardinalDirection(-S, A, 1)) : n > s ? (L = this.getCardinalDirection(-C, A, 1), R = this.getCardinalDirection(-S, A, 3)) : (L = this.getCardinalDirection(C, A, 2), R = this.getCardinalDirection(S, A, 4)), !_) switch (L) {
							case 1:
								I = l, N = i + -g / A, r[0] = N, r[1] = I;
								break;
							case 2:
								N = p, I = n + f * A, r[0] = N, r[1] = I;
								break;
							case 3:
								I = d, N = i + g / A, r[0] = N, r[1] = I;
								break;
							case 4: N = u, I = n + -f * A, r[0] = N, r[1] = I;
						}
						if (!E) switch (R) {
							case 1:
								D = y, M = a + -T / A, r[2] = M, r[3] = D;
								break;
							case 2:
								M = w, D = s + k * A, r[2] = M, r[3] = D;
								break;
							case 3:
								D = b, M = a + T / A, r[2] = M, r[3] = D;
								break;
							case 4: M = x, D = s + -k * A, r[2] = M, r[3] = D;
						}
					}
					return !1;
				}, n.getCardinalDirection = function(e, t, r) {
					return e > t ? r : 1 + r % 4;
				}, n.getIntersection = function(e, t, r, n) {
					if (null == n) return this.getIntersection2(e, t, r);
					var a = e.x, s = e.y, o = t.x, l = t.y, h = r.x, u = r.y, d = n.x, p = n.y, f = void 0, g = void 0, m = void 0, y = void 0, v = void 0, x = void 0, b = void 0;
					return f = l - s, m = a - o, v = o * s - a * l, g = p - u, y = h - d, x = d * u - h * p, 0 == (b = f * y - g * m) ? null : new i((m * x - y * v) / b, (g * v - f * x) / b);
				}, n.angleOfVector = function(e, t, r, i) {
					var n = void 0;
					return e !== r ? (n = Math.atan((i - t) / (r - e)), r < e ? n += Math.PI : i < t && (n += this.TWO_PI)) : n = i < t ? this.ONE_AND_HALF_PI : this.HALF_PI, n;
				}, n.doIntersect = function(e, t, r, i) {
					var n = e.x, a = e.y, s = t.x, o = t.y, l = r.x, h = r.y, u = i.x, d = i.y, p = (s - n) * (d - h) - (u - l) * (o - a);
					if (0 === p) return !1;
					var f = ((d - h) * (u - n) + (l - u) * (d - a)) / p, g = ((a - o) * (u - n) + (s - n) * (d - a)) / p;
					return 0 < f && f < 1 && 0 < g && g < 1;
				}, n.findCircleLineIntersections = function(e, t, r, i, n, a, s) {
					var o = (r - e) * (r - e) + (i - t) * (i - t), l = 2 * ((e - n) * (r - e) + (t - a) * (i - t)), h = (e - n) * (e - n) + (t - a) * (t - a) - s * s;
					if (!(l * l - 4 * o * h >= 0)) return null;
					var u = (-l + Math.sqrt(l * l - 4 * o * h)) / (2 * o), d = (-l - Math.sqrt(l * l - 4 * o * h)) / (2 * o);
					return u >= 0 && u <= 1 ? [u] : d >= 0 && d <= 1 ? [d] : null;
				}, n.HALF_PI = .5 * Math.PI, n.ONE_AND_HALF_PI = 1.5 * Math.PI, n.TWO_PI = 2 * Math.PI, n.THREE_PI = 3 * Math.PI, e.exports = n;
			},
			function(e, t, r) {
				function i() {}
				h(i, "IMath"), i.sign = function(e) {
					return e > 0 ? 1 : e < 0 ? -1 : 0;
				}, i.floor = function(e) {
					return e < 0 ? Math.ceil(e) : Math.floor(e);
				}, i.ceil = function(e) {
					return e < 0 ? Math.floor(e) : Math.ceil(e);
				}, e.exports = i;
			},
			function(e, t, r) {
				function i() {}
				h(i, "Integer"), i.MAX_VALUE = 2147483647, i.MIN_VALUE = -2147483648, e.exports = i;
			},
			function(e, t, r) {
				var i = function() {
					function e(e, t) {
						for (var r = 0; r < t.length; r++) {
							var i = t[r];
							i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
						}
					}
					return h(e, "defineProperties"), function(t, r, i) {
						return r && e(t.prototype, r), i && e(t, i), t;
					};
				}();
				function n(e, t) {
					if (!(e instanceof t)) throw TypeError("Cannot call a class as a function");
				}
				h(n, "_classCallCheck");
				var a = h(function(e) {
					return {
						value: e,
						next: null,
						prev: null
					};
				}, "nodeFrom"), s = h(function(e, t, r, i) {
					return null !== e ? e.next = t : i.head = t, null !== r ? r.prev = t : i.tail = t, t.prev = e, t.next = r, i.length++, t;
				}, "add"), o = h(function(e, t) {
					var r = e.prev, i = e.next;
					return null !== r ? r.next = i : t.head = i, null !== i ? i.prev = r : t.tail = r, e.prev = e.next = null, t.length--, e;
				}, "_remove");
				e.exports = function() {
					function e(t) {
						var r = this;
						n(this, e), this.length = 0, this.head = null, this.tail = null, t?.forEach(function(e) {
							return r.push(e);
						});
					}
					return h(e, "LinkedList"), i(e, [
						{
							key: "size",
							value: h(function() {
								return this.length;
							}, "size")
						},
						{
							key: "insertBefore",
							value: h(function(e, t) {
								return s(t.prev, a(e), t, this);
							}, "insertBefore")
						},
						{
							key: "insertAfter",
							value: h(function(e, t) {
								return s(t, a(e), t.next, this);
							}, "insertAfter")
						},
						{
							key: "insertNodeBefore",
							value: h(function(e, t) {
								return s(t.prev, e, t, this);
							}, "insertNodeBefore")
						},
						{
							key: "insertNodeAfter",
							value: h(function(e, t) {
								return s(t, e, t.next, this);
							}, "insertNodeAfter")
						},
						{
							key: "push",
							value: h(function(e) {
								return s(this.tail, a(e), null, this);
							}, "push")
						},
						{
							key: "unshift",
							value: h(function(e) {
								return s(null, a(e), this.head, this);
							}, "unshift")
						},
						{
							key: "remove",
							value: h(function(e) {
								return o(e, this);
							}, "remove")
						},
						{
							key: "pop",
							value: h(function() {
								return o(this.tail, this).value;
							}, "pop")
						},
						{
							key: "popNode",
							value: h(function() {
								return o(this.tail, this);
							}, "popNode")
						},
						{
							key: "shift",
							value: h(function() {
								return o(this.head, this).value;
							}, "shift")
						},
						{
							key: "shiftNode",
							value: h(function() {
								return o(this.head, this);
							}, "shiftNode")
						},
						{
							key: "get_object_at",
							value: h(function(e) {
								if (e <= this.length()) {
									for (var t = 1, r = this.head; t < e;) r = r.next, t++;
									return r.value;
								}
							}, "get_object_at")
						},
						{
							key: "set_object_at",
							value: h(function(e, t) {
								if (e <= this.length()) {
									for (var r = 1, i = this.head; r < e;) i = i.next, r++;
									i.value = t;
								}
							}, "set_object_at")
						}
					]), e;
				}();
			},
			function(e, t, r) {
				function i(e, t, r) {
					this.x = null, this.y = null, null == e && null == t && null == r ? (this.x = 0, this.y = 0) : "number" == typeof e && "number" == typeof t && null == r ? (this.x = e, this.y = t) : "Point" == e.constructor.name && null == t && null == r && (r = e, this.x = r.x, this.y = r.y);
				}
				h(i, "Point"), i.prototype.getX = function() {
					return this.x;
				}, i.prototype.getY = function() {
					return this.y;
				}, i.prototype.getLocation = function() {
					return new i(this.x, this.y);
				}, i.prototype.setLocation = function(e, t, r) {
					"Point" == e.constructor.name && null == t && null == r ? (r = e, this.setLocation(r.x, r.y)) : "number" == typeof e && "number" == typeof t && null == r && (parseInt(e) == e && parseInt(t) == t ? this.move(e, t) : (this.x = Math.floor(e + .5), this.y = Math.floor(t + .5)));
				}, i.prototype.move = function(e, t) {
					this.x = e, this.y = t;
				}, i.prototype.translate = function(e, t) {
					this.x += e, this.y += t;
				}, i.prototype.equals = function(e) {
					return "Point" == e.constructor.name ? this.x == e.x && this.y == e.y : this == e;
				}, i.prototype.toString = function() {
					return new i().constructor.name + "[x=" + this.x + ",y=" + this.y + "]";
				}, e.exports = i;
			},
			function(e, t, r) {
				function i(e, t, r, i) {
					this.x = 0, this.y = 0, this.width = 0, this.height = 0, null != e && null != t && null != r && null != i && (this.x = e, this.y = t, this.width = r, this.height = i);
				}
				h(i, "RectangleD"), i.prototype.getX = function() {
					return this.x;
				}, i.prototype.setX = function(e) {
					this.x = e;
				}, i.prototype.getY = function() {
					return this.y;
				}, i.prototype.setY = function(e) {
					this.y = e;
				}, i.prototype.getWidth = function() {
					return this.width;
				}, i.prototype.setWidth = function(e) {
					this.width = e;
				}, i.prototype.getHeight = function() {
					return this.height;
				}, i.prototype.setHeight = function(e) {
					this.height = e;
				}, i.prototype.getRight = function() {
					return this.x + this.width;
				}, i.prototype.getBottom = function() {
					return this.y + this.height;
				}, i.prototype.intersects = function(e) {
					return !(this.getRight() < e.x || this.getBottom() < e.y || e.getRight() < this.x || e.getBottom() < this.y);
				}, i.prototype.getCenterX = function() {
					return this.x + this.width / 2;
				}, i.prototype.getMinX = function() {
					return this.getX();
				}, i.prototype.getMaxX = function() {
					return this.getX() + this.width;
				}, i.prototype.getCenterY = function() {
					return this.y + this.height / 2;
				}, i.prototype.getMinY = function() {
					return this.getY();
				}, i.prototype.getMaxY = function() {
					return this.getY() + this.height;
				}, i.prototype.getWidthHalf = function() {
					return this.width / 2;
				}, i.prototype.getHeightHalf = function() {
					return this.height / 2;
				}, e.exports = i;
			},
			function(e, t, r) {
				var i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
					return typeof e;
				} : function(e) {
					return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
				};
				function n() {}
				h(n, "UniqueIDGeneretor"), n.lastID = 0, n.createID = function(e) {
					return n.isPrimitive(e) ? e : (e.uniqueID ?? (e.uniqueID = n.getString(), n.lastID++), e.uniqueID);
				}, n.getString = function(e) {
					return "Object#" + (e ??= n.lastID);
				}, n.isPrimitive = function(e) {
					var t = typeof e > "u" ? "undefined" : i(e);
					return null == e || "object" != t && "function" != t;
				}, e.exports = n;
			},
			function(e, t, r) {
				function i(e) {
					if (!Array.isArray(e)) return Array.from(e);
					for (var t = 0, r = Array(e.length); t < e.length; t++) r[t] = e[t];
					return r;
				}
				h(i, "_toConsumableArray");
				var n = r(0), a = r(7), s = r(3), o = r(1), l = r(6), u = r(5), d = r(17), p = r(29);
				function f(e) {
					p.call(this), this.layoutQuality = n.QUALITY, this.createBendsAsNeeded = n.DEFAULT_CREATE_BENDS_AS_NEEDED, this.incremental = n.DEFAULT_INCREMENTAL, this.animationOnLayout = n.DEFAULT_ANIMATION_ON_LAYOUT, this.animationDuringLayout = n.DEFAULT_ANIMATION_DURING_LAYOUT, this.animationPeriod = n.DEFAULT_ANIMATION_PERIOD, this.uniformLeafNodeSizes = n.DEFAULT_UNIFORM_LEAF_NODE_SIZES, this.edgeToDummyNodes = /* @__PURE__ */ new Map(), this.graphManager = new a(this), this.isLayoutFinished = !1, this.isSubLayout = !1, this.isRemoteUse = !1, null != e && (this.isRemoteUse = e);
				}
				h(f, "Layout"), f.RANDOM_SEED = 1, f.prototype = Object.create(p.prototype), f.prototype.getGraphManager = function() {
					return this.graphManager;
				}, f.prototype.getAllNodes = function() {
					return this.graphManager.getAllNodes();
				}, f.prototype.getAllEdges = function() {
					return this.graphManager.getAllEdges();
				}, f.prototype.getAllNodesToApplyGravitation = function() {
					return this.graphManager.getAllNodesToApplyGravitation();
				}, f.prototype.newGraphManager = function() {
					var e = new a(this);
					return this.graphManager = e, e;
				}, f.prototype.newGraph = function(e) {
					return new l(null, this.graphManager, e);
				}, f.prototype.newNode = function(e) {
					return new s(this.graphManager, e);
				}, f.prototype.newEdge = function(e) {
					return new o(null, null, e);
				}, f.prototype.checkLayoutSuccess = function() {
					return null == this.graphManager.getRoot() || 0 == this.graphManager.getRoot().getNodes().length || this.graphManager.includesInvalidEdge();
				}, f.prototype.runLayout = function() {
					var e;
					return this.isLayoutFinished = !1, this.tilingPreLayout && this.tilingPreLayout(), this.initParameters(), e = !this.checkLayoutSuccess() && this.layout(), "during" !== n.ANIMATE && (e && (this.isSubLayout || this.doPostLayout()), this.tilingPostLayout && this.tilingPostLayout(), this.isLayoutFinished = !0, e);
				}, f.prototype.doPostLayout = function() {
					this.incremental || this.transform(), this.update();
				}, f.prototype.update2 = function() {
					if (this.createBendsAsNeeded && (this.createBendpointsFromDummyNodes(), this.graphManager.resetAllEdges()), !this.isRemoteUse) {
						for (var e = this.graphManager.getAllEdges(), t = 0; t < e.length; t++) e[t];
						for (var r = this.graphManager.getRoot().getNodes(), t = 0; t < r.length; t++) r[t];
						this.update(this.graphManager.getRoot());
					}
				}, f.prototype.update = function(e) {
					if (null == e) this.update2();
					else if (e instanceof s) {
						if (null != e.getChild()) for (var t = e.getChild().getNodes(), r = 0; r < t.length; r++) update(t[r]);
						null != e.vGraphObject && e.vGraphObject.update(e);
					} else e instanceof o ? null != e.vGraphObject && e.vGraphObject.update(e) : e instanceof l && null != e.vGraphObject && e.vGraphObject.update(e);
				}, f.prototype.initParameters = function() {
					this.isSubLayout || (this.layoutQuality = n.QUALITY, this.animationDuringLayout = n.DEFAULT_ANIMATION_DURING_LAYOUT, this.animationPeriod = n.DEFAULT_ANIMATION_PERIOD, this.animationOnLayout = n.DEFAULT_ANIMATION_ON_LAYOUT, this.incremental = n.DEFAULT_INCREMENTAL, this.createBendsAsNeeded = n.DEFAULT_CREATE_BENDS_AS_NEEDED, this.uniformLeafNodeSizes = n.DEFAULT_UNIFORM_LEAF_NODE_SIZES), this.animationDuringLayout && (this.animationOnLayout = !1);
				}, f.prototype.transform = function(e) {
					if (null == e) this.transform(new u(0, 0));
					else {
						var t = new d(), r = this.graphManager.getRoot().updateLeftTop();
						if (null != r) {
							t.setWorldOrgX(e.x), t.setWorldOrgY(e.y), t.setDeviceOrgX(r.x), t.setDeviceOrgY(r.y);
							for (var i = this.getAllNodes(), n = 0; n < i.length; n++) i[n].transform(t);
						}
					}
				}, f.prototype.positionNodesRandomly = function(e) {
					if (null == e) this.positionNodesRandomly(this.getGraphManager().getRoot()), this.getGraphManager().getRoot().updateBounds(!0);
					else for (var t, r, i = e.getNodes(), n = 0; n < i.length; n++) null == (r = (t = i[n]).getChild()) || 0 == r.getNodes().length ? t.scatter() : (this.positionNodesRandomly(r), t.updateBounds());
				}, f.prototype.getFlatForest = function() {
					for (var e = [], t = !0, r = this.graphManager.getRoot().getNodes(), n = !0, a = 0; a < r.length; a++) null != r[a].getChild() && (n = !1);
					if (!n) return e;
					var s = /* @__PURE__ */ new Set(), o = [], l = /* @__PURE__ */ new Map(), h = [];
					for (h = h.concat(r); h.length > 0 && t;) {
						for (o.push(h[0]); o.length > 0 && t;) {
							var u = o[0];
							o.splice(0, 1), s.add(u);
							for (var d = u.getEdges(), a = 0; a < d.length; a++) {
								var p = d[a].getOtherEnd(u);
								if (l.get(u) != p) if (s.has(p)) {
									t = !1;
									break;
								} else o.push(p), l.set(p, u);
							}
						}
						if (t) {
							var f = [].concat(i(s));
							e.push(f);
							for (var a = 0; a < f.length; a++) {
								var g = f[a], m = h.indexOf(g);
								m > -1 && h.splice(m, 1);
							}
							s = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Map();
						} else e = [];
					}
					return e;
				}, f.prototype.createDummyNodesForBendpoints = function(e) {
					for (var t = [], r = e.source, i = this.graphManager.calcLowestCommonAncestor(e.source, e.target), n = 0; n < e.bendpoints.length; n++) {
						var a = this.newNode(null);
						a.setRect(new Point(0, 0), new Dimension(1, 1)), i.add(a);
						var s = this.newEdge(null);
						this.graphManager.add(s, r, a), t.add(a), r = a;
					}
					var s = this.newEdge(null);
					return this.graphManager.add(s, r, e.target), this.edgeToDummyNodes.set(e, t), e.isInterGraph() ? this.graphManager.remove(e) : i.remove(e), t;
				}, f.prototype.createBendpointsFromDummyNodes = function() {
					var e = [];
					e = e.concat(this.graphManager.getAllEdges()), e = [].concat(i(this.edgeToDummyNodes.keys())).concat(e);
					for (var t = 0; t < e.length; t++) {
						var r = e[t];
						if (r.bendpoints.length > 0) {
							for (var n = this.edgeToDummyNodes.get(r), a = 0; a < n.length; a++) {
								var s = n[a], o = new u(s.getCenterX(), s.getCenterY()), l = r.bendpoints.get(a);
								l.x = o.x, l.y = o.y, s.getOwner().remove(s);
							}
							this.graphManager.add(r, r.source, r.target);
						}
					}
				}, f.transform = function(e, t, r, i) {
					if (null == r || null == i) return e <= 50 ? (n = 9 * t / 500, a = t / 10) : (n = 9 * t / 50, a = -8 * t), n * e + a;
					var n, a, s = t;
					return e <= 50 ? s -= (t - t / r) / 50 * (50 - e) : s += (t * i - t) / 50 * (e - 50), s;
				}, f.findCenterOfTree = function(e) {
					var t = [];
					t = t.concat(e);
					var r = [], i = /* @__PURE__ */ new Map(), n = !1, a = null;
					(1 == t.length || 2 == t.length) && (n = !0, a = t[0]);
					for (var s = 0; s < t.length; s++) {
						var o = t[s], l = o.getNeighborsList().size;
						i.set(o, o.getNeighborsList().size), 1 == l && r.push(o);
					}
					var h = [];
					for (h = h.concat(r); !n;) {
						var u = [];
						u = u.concat(h), h = [];
						for (var s = 0; s < t.length; s++) {
							var o = t[s], d = t.indexOf(o);
							d >= 0 && t.splice(d, 1), o.getNeighborsList().forEach(function(e) {
								if (0 > r.indexOf(e)) {
									var t = i.get(e) - 1;
									1 == t && h.push(e), i.set(e, t);
								}
							});
						}
						r = r.concat(h), (1 == t.length || 2 == t.length) && (n = !0, a = t[0]);
					}
					return a;
				}, f.prototype.setGraphManager = function(e) {
					this.graphManager = e;
				}, e.exports = f;
			},
			function(e, t, r) {
				function i() {}
				h(i, "RandomSeed"), i.seed = 1, i.x = 0, i.nextDouble = function() {
					return i.x = 1e4 * Math.sin(i.seed++), i.x - Math.floor(i.x);
				}, e.exports = i;
			},
			function(e, t, r) {
				var i = r(5);
				function n(e, t) {
					this.lworldOrgX = 0, this.lworldOrgY = 0, this.ldeviceOrgX = 0, this.ldeviceOrgY = 0, this.lworldExtX = 1, this.lworldExtY = 1, this.ldeviceExtX = 1, this.ldeviceExtY = 1;
				}
				h(n, "Transform"), n.prototype.getWorldOrgX = function() {
					return this.lworldOrgX;
				}, n.prototype.setWorldOrgX = function(e) {
					this.lworldOrgX = e;
				}, n.prototype.getWorldOrgY = function() {
					return this.lworldOrgY;
				}, n.prototype.setWorldOrgY = function(e) {
					this.lworldOrgY = e;
				}, n.prototype.getWorldExtX = function() {
					return this.lworldExtX;
				}, n.prototype.setWorldExtX = function(e) {
					this.lworldExtX = e;
				}, n.prototype.getWorldExtY = function() {
					return this.lworldExtY;
				}, n.prototype.setWorldExtY = function(e) {
					this.lworldExtY = e;
				}, n.prototype.getDeviceOrgX = function() {
					return this.ldeviceOrgX;
				}, n.prototype.setDeviceOrgX = function(e) {
					this.ldeviceOrgX = e;
				}, n.prototype.getDeviceOrgY = function() {
					return this.ldeviceOrgY;
				}, n.prototype.setDeviceOrgY = function(e) {
					this.ldeviceOrgY = e;
				}, n.prototype.getDeviceExtX = function() {
					return this.ldeviceExtX;
				}, n.prototype.setDeviceExtX = function(e) {
					this.ldeviceExtX = e;
				}, n.prototype.getDeviceExtY = function() {
					return this.ldeviceExtY;
				}, n.prototype.setDeviceExtY = function(e) {
					this.ldeviceExtY = e;
				}, n.prototype.transformX = function(e) {
					var t = 0, r = this.lworldExtX;
					return 0 != r && (t = this.ldeviceOrgX + (e - this.lworldOrgX) * this.ldeviceExtX / r), t;
				}, n.prototype.transformY = function(e) {
					var t = 0, r = this.lworldExtY;
					return 0 != r && (t = this.ldeviceOrgY + (e - this.lworldOrgY) * this.ldeviceExtY / r), t;
				}, n.prototype.inverseTransformX = function(e) {
					var t = 0, r = this.ldeviceExtX;
					return 0 != r && (t = this.lworldOrgX + (e - this.ldeviceOrgX) * this.lworldExtX / r), t;
				}, n.prototype.inverseTransformY = function(e) {
					var t = 0, r = this.ldeviceExtY;
					return 0 != r && (t = this.lworldOrgY + (e - this.ldeviceOrgY) * this.lworldExtY / r), t;
				}, n.prototype.inverseTransformPoint = function(e) {
					return new i(this.inverseTransformX(e.x), this.inverseTransformY(e.y));
				}, e.exports = n;
			},
			function(e, t, r) {
				function i(e) {
					if (!Array.isArray(e)) return Array.from(e);
					for (var t = 0, r = Array(e.length); t < e.length; t++) r[t] = e[t];
					return r;
				}
				h(i, "_toConsumableArray");
				var n = r(15), a = r(4), s = r(0), o = r(8), l = r(9);
				function u() {
					n.call(this), this.useSmartIdealEdgeLengthCalculation = a.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION, this.gravityConstant = a.DEFAULT_GRAVITY_STRENGTH, this.compoundGravityConstant = a.DEFAULT_COMPOUND_GRAVITY_STRENGTH, this.gravityRangeFactor = a.DEFAULT_GRAVITY_RANGE_FACTOR, this.compoundGravityRangeFactor = a.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR, this.displacementThresholdPerNode = 3 * a.DEFAULT_EDGE_LENGTH / 100, this.coolingFactor = a.DEFAULT_COOLING_FACTOR_INCREMENTAL, this.initialCoolingFactor = a.DEFAULT_COOLING_FACTOR_INCREMENTAL, this.totalDisplacement = 0, this.oldTotalDisplacement = 0, this.maxIterations = a.MAX_ITERATIONS;
				}
				for (var d in h(u, "FDLayout"), u.prototype = Object.create(n.prototype), n) u[d] = n[d];
				u.prototype.initParameters = function() {
					n.prototype.initParameters.call(this, arguments), this.totalIterations = 0, this.notAnimatedIterations = 0, this.useFRGridVariant = a.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION, this.grid = [];
				}, u.prototype.calcIdealEdgeLengths = function() {
					for (var e, t, r, i, n, o, l, h = this.getGraphManager().getAllEdges(), u = 0; u < h.length; u++) t = (e = h[u]).idealLength, e.isInterGraph && (i = e.getSource(), n = e.getTarget(), o = e.getSourceInLca().getEstimatedSize(), l = e.getTargetInLca().getEstimatedSize(), this.useSmartIdealEdgeLengthCalculation && (e.idealLength += o + l - 2 * s.SIMPLE_NODE_SIZE), r = e.getLca().getInclusionTreeDepth(), e.idealLength += t * a.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (i.getInclusionTreeDepth() + n.getInclusionTreeDepth() - 2 * r));
				}, u.prototype.initSpringEmbedder = function() {
					var e = this.getAllNodes().length;
					this.incremental ? (e > a.ADAPTATION_LOWER_NODE_LIMIT && (this.coolingFactor = Math.max(this.coolingFactor * a.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (e - a.ADAPTATION_LOWER_NODE_LIMIT) / (a.ADAPTATION_UPPER_NODE_LIMIT - a.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - a.COOLING_ADAPTATION_FACTOR))), this.maxNodeDisplacement = a.MAX_NODE_DISPLACEMENT_INCREMENTAL) : (e > a.ADAPTATION_LOWER_NODE_LIMIT ? this.coolingFactor = Math.max(a.COOLING_ADAPTATION_FACTOR, 1 - (e - a.ADAPTATION_LOWER_NODE_LIMIT) / (a.ADAPTATION_UPPER_NODE_LIMIT - a.ADAPTATION_LOWER_NODE_LIMIT) * (1 - a.COOLING_ADAPTATION_FACTOR)) : this.coolingFactor = 1, this.initialCoolingFactor = this.coolingFactor, this.maxNodeDisplacement = a.MAX_NODE_DISPLACEMENT), this.maxIterations = Math.max(5 * this.getAllNodes().length, this.maxIterations), this.displacementThresholdPerNode = 3 * a.DEFAULT_EDGE_LENGTH / 100, this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length, this.repulsionRange = this.calcRepulsionRange();
				}, u.prototype.calcSpringForces = function() {
					for (var e, t = this.getAllEdges(), r = 0; r < t.length; r++) e = t[r], this.calcSpringForce(e, e.idealLength);
				}, u.prototype.calcRepulsionForces = function() {
					var e, t, r, i, n, s = !(arguments.length > 0) || void 0 === arguments[0] || arguments[0], o = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], l = this.getAllNodes();
					if (this.useFRGridVariant) for (this.totalIterations % a.GRID_CALCULATION_CHECK_PERIOD == 1 && s && this.updateGrid(), n = /* @__PURE__ */ new Set(), e = 0; e < l.length; e++) r = l[e], this.calculateRepulsionForceOfANode(r, n, s, o), n.add(r);
					else for (e = 0; e < l.length; e++) for (r = l[e], t = e + 1; t < l.length; t++) i = l[t], r.getOwner() == i.getOwner() && this.calcRepulsionForce(r, i);
				}, u.prototype.calcGravitationalForces = function() {
					for (var e, t = this.getAllNodesToApplyGravitation(), r = 0; r < t.length; r++) e = t[r], this.calcGravitationalForce(e);
				}, u.prototype.moveNodes = function() {
					for (var e = this.getAllNodes(), t = 0; t < e.length; t++) e[t].move();
				}, u.prototype.calcSpringForce = function(e, t) {
					var r, i, n, a, s = e.getSource(), o = e.getTarget();
					if (this.uniformLeafNodeSizes && null == s.getChild() && null == o.getChild()) e.updateLengthSimple();
					else if (e.updateLength(), e.isOverlapingSourceAndTarget) return;
					0 != (r = e.getLength()) && (n = (i = e.edgeElasticity * (r - t)) * (e.lengthX / r), a = i * (e.lengthY / r), s.springForceX += n, s.springForceY += a, o.springForceX -= n, o.springForceY -= a);
				}, u.prototype.calcRepulsionForce = function(e, t) {
					var r, i, n, s, h, u, d, p = e.getRect(), f = t.getRect(), g = [, ,], m = [
						,
						,
						,
						,
					];
					if (p.intersects(f)) {
						o.calcSeparationAmount(p, f, g, a.DEFAULT_EDGE_LENGTH / 2), u = 2 * g[0], d = 2 * g[1];
						var y = e.noOfChildren * t.noOfChildren / (e.noOfChildren + t.noOfChildren);
						e.repulsionForceX -= y * u, e.repulsionForceY -= y * d, t.repulsionForceX += y * u, t.repulsionForceY += y * d;
					} else this.uniformLeafNodeSizes && null == e.getChild() && null == t.getChild() ? (r = f.getCenterX() - p.getCenterX(), i = f.getCenterY() - p.getCenterY()) : (o.getIntersection(p, f, m), r = m[2] - m[0], i = m[3] - m[1]), Math.abs(r) < a.MIN_REPULSION_DIST && (r = l.sign(r) * a.MIN_REPULSION_DIST), Math.abs(i) < a.MIN_REPULSION_DIST && (i = l.sign(i) * a.MIN_REPULSION_DIST), s = Math.sqrt(n = r * r + i * i), u = (h = (e.nodeRepulsion / 2 + t.nodeRepulsion / 2) * e.noOfChildren * t.noOfChildren / n) * r / s, d = h * i / s, e.repulsionForceX -= u, e.repulsionForceY -= d, t.repulsionForceX += u, t.repulsionForceY += d;
				}, u.prototype.calcGravitationalForce = function(e) {
					var t, r = e.getOwner(), i = (r.getRight() + r.getLeft()) / 2, n = (r.getTop() + r.getBottom()) / 2, a = e.getCenterX() - i, s = e.getCenterY() - n, o = Math.abs(a) + e.getWidth() / 2, l = Math.abs(s) + e.getHeight() / 2;
					e.getOwner() == this.graphManager.getRoot() ? (o > (t = r.getEstimatedSize() * this.gravityRangeFactor) || l > t) && (e.gravitationForceX = -this.gravityConstant * a, e.gravitationForceY = -this.gravityConstant * s) : (o > (t = r.getEstimatedSize() * this.compoundGravityRangeFactor) || l > t) && (e.gravitationForceX = -this.gravityConstant * a * this.compoundGravityConstant, e.gravitationForceY = -this.gravityConstant * s * this.compoundGravityConstant);
				}, u.prototype.isConverged = function() {
					var e, t = !1;
					return this.totalIterations > this.maxIterations / 3 && (t = 2 > Math.abs(this.totalDisplacement - this.oldTotalDisplacement)), e = this.totalDisplacement < this.totalDisplacementThreshold, this.oldTotalDisplacement = this.totalDisplacement, e || t;
				}, u.prototype.animate = function() {
					this.animationDuringLayout && !this.isSubLayout && (this.notAnimatedIterations == this.animationPeriod ? (this.update(), this.notAnimatedIterations = 0) : this.notAnimatedIterations++);
				}, u.prototype.calcNoOfChildrenForAllNodes = function() {
					for (var e, t = this.graphManager.getAllNodes(), r = 0; r < t.length; r++) (e = t[r]).noOfChildren = e.getNoOfChildren();
				}, u.prototype.calcGrid = function(e) {
					var t = 0, r = 0;
					t = parseInt(Math.ceil((e.getRight() - e.getLeft()) / this.repulsionRange)), r = parseInt(Math.ceil((e.getBottom() - e.getTop()) / this.repulsionRange));
					for (var i = Array(t), n = 0; n < t; n++) i[n] = Array(r);
					for (var n = 0; n < t; n++) for (var a = 0; a < r; a++) i[n][a] = [];
					return i;
				}, u.prototype.addNodeToGrid = function(e, t, r) {
					var i = 0, n = 0, a = 0, s = 0;
					i = parseInt(Math.floor((e.getRect().x - t) / this.repulsionRange)), n = parseInt(Math.floor((e.getRect().width + e.getRect().x - t) / this.repulsionRange)), a = parseInt(Math.floor((e.getRect().y - r) / this.repulsionRange)), s = parseInt(Math.floor((e.getRect().height + e.getRect().y - r) / this.repulsionRange));
					for (var o = i; o <= n; o++) for (var l = a; l <= s; l++) this.grid[o][l].push(e), e.setGridCoordinates(i, n, a, s);
				}, u.prototype.updateGrid = function() {
					var e, t, r = this.getAllNodes();
					for (this.grid = this.calcGrid(this.graphManager.getRoot()), e = 0; e < r.length; e++) t = r[e], this.addNodeToGrid(t, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());
				}, u.prototype.calculateRepulsionForceOfANode = function(e, t, r, n) {
					if (this.totalIterations % a.GRID_CALCULATION_CHECK_PERIOD == 1 && r || n) {
						var s = /* @__PURE__ */ new Set();
						e.surrounding = [];
						for (var o, l = this.grid, h = e.startX - 1; h < e.finishX + 2; h++) for (var u = e.startY - 1; u < e.finishY + 2; u++) if (!(h < 0 || u < 0 || h >= l.length || u >= l[0].length)) {
							for (var d = 0; d < l[h][u].length; d++) if (o = l[h][u][d], e.getOwner() == o.getOwner() && e != o && !t.has(o) && !s.has(o)) {
								var p = Math.abs(e.getCenterX() - o.getCenterX()) - (e.getWidth() / 2 + o.getWidth() / 2), f = Math.abs(e.getCenterY() - o.getCenterY()) - (e.getHeight() / 2 + o.getHeight() / 2);
								p <= this.repulsionRange && f <= this.repulsionRange && s.add(o);
							}
						}
						e.surrounding = [].concat(i(s));
					}
					for (h = 0; h < e.surrounding.length; h++) this.calcRepulsionForce(e, e.surrounding[h]);
				}, u.prototype.calcRepulsionRange = function() {
					return 0;
				}, e.exports = u;
			},
			function(e, t, r) {
				var i = r(1), n = r(4);
				function a(e, t, r) {
					i.call(this, e, t, r), this.idealLength = n.DEFAULT_EDGE_LENGTH, this.edgeElasticity = n.DEFAULT_SPRING_STRENGTH;
				}
				for (var s in h(a, "FDLayoutEdge"), a.prototype = Object.create(i.prototype), i) a[s] = i[s];
				e.exports = a;
			},
			function(e, t, r) {
				var i = r(3), n = r(4);
				function a(e, t, r, a) {
					i.call(this, e, t, r, a), this.nodeRepulsion = n.DEFAULT_REPULSION_STRENGTH, this.springForceX = 0, this.springForceY = 0, this.repulsionForceX = 0, this.repulsionForceY = 0, this.gravitationForceX = 0, this.gravitationForceY = 0, this.displacementX = 0, this.displacementY = 0, this.startX = 0, this.finishX = 0, this.startY = 0, this.finishY = 0, this.surrounding = [];
				}
				for (var s in h(a, "FDLayoutNode"), a.prototype = Object.create(i.prototype), i) a[s] = i[s];
				a.prototype.setGridCoordinates = function(e, t, r, i) {
					this.startX = e, this.finishX = t, this.startY = r, this.finishY = i;
				}, e.exports = a;
			},
			function(e, t, r) {
				function i(e, t) {
					this.width = 0, this.height = 0, null !== e && null !== t && (this.height = t, this.width = e);
				}
				h(i, "DimensionD"), i.prototype.getWidth = function() {
					return this.width;
				}, i.prototype.setWidth = function(e) {
					this.width = e;
				}, i.prototype.getHeight = function() {
					return this.height;
				}, i.prototype.setHeight = function(e) {
					this.height = e;
				}, e.exports = i;
			},
			function(e, t, r) {
				var i = r(14);
				function n() {
					this.map = {}, this.keys = [];
				}
				h(n, "HashMap"), n.prototype.put = function(e, t) {
					var r = i.createID(e);
					this.contains(r) || (this.map[r] = t, this.keys.push(e));
				}, n.prototype.contains = function(e) {
					return i.createID(e), null != this.map[e];
				}, n.prototype.get = function(e) {
					var t = i.createID(e);
					return this.map[t];
				}, n.prototype.keySet = function() {
					return this.keys;
				}, e.exports = n;
			},
			function(e, t, r) {
				var i = r(14);
				function n() {
					this.set = {};
				}
				h(n, "HashSet"), n.prototype.add = function(e) {
					var t = i.createID(e);
					this.contains(t) || (this.set[t] = e);
				}, n.prototype.remove = function(e) {
					delete this.set[i.createID(e)];
				}, n.prototype.clear = function() {
					this.set = {};
				}, n.prototype.contains = function(e) {
					return this.set[i.createID(e)] == e;
				}, n.prototype.isEmpty = function() {
					return 0 === this.size();
				}, n.prototype.size = function() {
					return Object.keys(this.set).length;
				}, n.prototype.addAllTo = function(e) {
					for (var t = Object.keys(this.set), r = t.length, i = 0; i < r; i++) e.push(this.set[t[i]]);
				}, n.prototype.size = function() {
					return Object.keys(this.set).length;
				}, n.prototype.addAll = function(e) {
					for (var t = e.length, r = 0; r < t; r++) {
						var i = e[r];
						this.add(i);
					}
				}, e.exports = n;
			},
			function(e, t, r) {
				function i() {}
				h(i, "Matrix"), i.multMat = function(e, t) {
					for (var r = [], i = 0; i < e.length; i++) {
						r[i] = [];
						for (var n = 0; n < t[0].length; n++) {
							r[i][n] = 0;
							for (var a = 0; a < e[0].length; a++) r[i][n] += e[i][a] * t[a][n];
						}
					}
					return r;
				}, i.transpose = function(e) {
					for (var t = [], r = 0; r < e[0].length; r++) {
						t[r] = [];
						for (var i = 0; i < e.length; i++) t[r][i] = e[i][r];
					}
					return t;
				}, i.multCons = function(e, t) {
					for (var r = [], i = 0; i < e.length; i++) r[i] = e[i] * t;
					return r;
				}, i.minusOp = function(e, t) {
					for (var r = [], i = 0; i < e.length; i++) r[i] = e[i] - t[i];
					return r;
				}, i.dotProduct = function(e, t) {
					for (var r = 0, i = 0; i < e.length; i++) r += e[i] * t[i];
					return r;
				}, i.mag = function(e) {
					return Math.sqrt(this.dotProduct(e, e));
				}, i.normalize = function(e) {
					for (var t = [], r = this.mag(e), i = 0; i < e.length; i++) t[i] = e[i] / r;
					return t;
				}, i.multGamma = function(e) {
					for (var t = [], r = 0, i = 0; i < e.length; i++) r += e[i];
					r *= -1 / e.length;
					for (var n = 0; n < e.length; n++) t[n] = r + e[n];
					return t;
				}, i.multL = function(e, t, r) {
					for (var i = [], n = [], a = [], s = 0; s < t[0].length; s++) {
						for (var o = 0, l = 0; l < t.length; l++) o += -.5 * t[l][s] * e[l];
						n[s] = o;
					}
					for (var h = 0; h < r.length; h++) {
						for (var u = 0, d = 0; d < r.length; d++) u += r[h][d] * n[d];
						a[h] = u;
					}
					for (var p = 0; p < t.length; p++) {
						for (var f = 0, g = 0; g < t[0].length; g++) f += t[p][g] * a[g];
						i[p] = f;
					}
					return i;
				}, e.exports = i;
			},
			function(e, t, r) {
				var i = function() {
					function e(e, t) {
						for (var r = 0; r < t.length; r++) {
							var i = t[r];
							i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
						}
					}
					return h(e, "defineProperties"), function(t, r, i) {
						return r && e(t.prototype, r), i && e(t, i), t;
					};
				}();
				function n(e, t) {
					if (!(e instanceof t)) throw TypeError("Cannot call a class as a function");
				}
				h(n, "_classCallCheck");
				var a = r(11);
				e.exports = function() {
					function e(t, r) {
						n(this, e), (null !== r || void 0 !== r) && (this.compareFunction = this._defaultCompareFunction);
						var i = void 0;
						i = t instanceof a ? t.size() : t.length, this._quicksort(t, 0, i - 1);
					}
					return h(e, "Quicksort"), i(e, [
						{
							key: "_quicksort",
							value: h(function(e, t, r) {
								if (t < r) {
									var i = this._partition(e, t, r);
									this._quicksort(e, t, i), this._quicksort(e, i + 1, r);
								}
							}, "_quicksort")
						},
						{
							key: "_partition",
							value: h(function(e, t, r) {
								for (var i = this._get(e, t), n = t, a = r;;) {
									for (; this.compareFunction(i, this._get(e, a));) a--;
									for (; this.compareFunction(this._get(e, n), i);) n++;
									if (!(n < a)) return a;
									this._swap(e, n, a), n++, a--;
								}
							}, "_partition")
						},
						{
							key: "_get",
							value: h(function(e, t) {
								return e instanceof a ? e.get_object_at(t) : e[t];
							}, "_get")
						},
						{
							key: "_set",
							value: h(function(e, t, r) {
								e instanceof a ? e.set_object_at(t, r) : e[t] = r;
							}, "_set")
						},
						{
							key: "_swap",
							value: h(function(e, t, r) {
								var i = this._get(e, t);
								this._set(e, t, this._get(e, r)), this._set(e, r, i);
							}, "_swap")
						},
						{
							key: "_defaultCompareFunction",
							value: h(function(e, t) {
								return t > e;
							}, "_defaultCompareFunction")
						}
					]), e;
				}();
			},
			function(e, t, r) {
				function i() {}
				h(i, "SVD"), i.svd = function(e) {
					this.U = null, this.V = null, this.s = null, this.m = 0, this.n = 0, this.m = e.length, this.n = e[0].length;
					var t = Math.min(this.m, this.n);
					this.s = function(e) {
						for (var t = []; e-- > 0;) t.push(0);
						return t;
					}(Math.min(this.m + 1, this.n)), this.U = (y = [this.m, t], h(function e(t) {
						if (0 == t.length) return 0;
						for (var r = [], i = 0; i < t[0]; i++) r.push(e(t.slice(1)));
						return r;
					}, "allocate")(y)), this.V = (v = [this.n, this.n], h(function e(t) {
						if (0 == t.length) return 0;
						for (var r = [], i = 0; i < t[0]; i++) r.push(e(t.slice(1)));
						return r;
					}, "allocate")(v));
					for (var r = function(e) {
						for (var t = []; e-- > 0;) t.push(0);
						return t;
					}(this.n), n = function(e) {
						for (var t = []; e-- > 0;) t.push(0);
						return t;
					}(this.m), a = Math.min(this.m - 1, this.n), s = Math.max(0, Math.min(this.n - 2, this.m)), o = 0; o < Math.max(a, s); o++) {
						if (o < a) {
							this.s[o] = 0;
							for (var l = o; l < this.m; l++) this.s[o] = i.hypot(this.s[o], e[l][o]);
							if (0 !== this.s[o]) {
								e[o][o] < 0 && (this.s[o] = -this.s[o]);
								for (var u = o; u < this.m; u++) e[u][o] /= this.s[o];
								e[o][o] += 1;
							}
							this.s[o] = -this.s[o];
						}
						for (var d = o + 1; d < this.n; d++) {
							if (x = o < a, b = 0 !== this.s[o], x && b) {
								for (var p = 0, f = o; f < this.m; f++) p += e[f][o] * e[f][d];
								p = -p / e[o][o];
								for (var g = o; g < this.m; g++) e[g][d] += p * e[g][o];
							}
							r[d] = e[o][d];
						}
						if (w = o < a) for (var m = o; m < this.m; m++) this.U[m][o] = e[m][o];
						if (o < s) {
							r[o] = 0;
							for (var y, v, x, b, w, k, T, _ = o + 1; _ < this.n; _++) r[o] = i.hypot(r[o], r[_]);
							if (0 !== r[o]) {
								r[o + 1] < 0 && (r[o] = -r[o]);
								for (var E = o + 1; E < this.n; E++) r[E] /= r[o];
								r[o + 1] += 1;
							}
							if (r[o] = -r[o], k = o + 1 < this.m, T = 0 !== r[o], k && T) {
								for (var C = o + 1; C < this.m; C++) n[C] = 0;
								for (var S = o + 1; S < this.n; S++) for (var A = o + 1; A < this.m; A++) n[A] += r[S] * e[A][S];
								for (var L = o + 1; L < this.n; L++) for (var R = -r[L] / r[o + 1], N = o + 1; N < this.m; N++) e[N][L] += R * n[N];
							}
							for (var I = o + 1; I < this.n; I++) this.V[I][o] = r[I];
						}
					}
					var M = Math.min(this.n, this.m + 1);
					a < this.n && (this.s[a] = e[a][a]), this.m < M && (this.s[M - 1] = 0), s + 1 < M && (r[s] = e[s][M - 1]), r[M - 1] = 0;
					for (var D = a; D < t; D++) {
						for (var O = 0; O < this.m; O++) this.U[O][D] = 0;
						this.U[D][D] = 1;
					}
					for (var $ = a - 1; $ >= 0; $--) if (0 !== this.s[$]) {
						for (var P = $ + 1; P < t; P++) {
							for (var B = 0, F = $; F < this.m; F++) B += this.U[F][$] * this.U[F][P];
							B = -B / this.U[$][$];
							for (var z = $; z < this.m; z++) this.U[z][P] += B * this.U[z][$];
						}
						for (var U = $; U < this.m; U++) this.U[U][$] = -this.U[U][$];
						this.U[$][$] = 1 + this.U[$][$];
						for (var G = 0; G < $ - 1; G++) this.U[G][$] = 0;
					} else {
						for (var q = 0; q < this.m; q++) this.U[q][$] = 0;
						this.U[$][$] = 1;
					}
					for (var j = this.n - 1; j >= 0; j--) {
						if (ef = j < s, eg = 0 !== r[j], ef && eg) for (var W = j + 1; W < t; W++) {
							for (var Y = 0, V = j + 1; V < this.n; V++) Y += this.V[V][j] * this.V[V][W];
							Y = -Y / this.V[j + 1][j];
							for (var H = j + 1; H < this.n; H++) this.V[H][W] += Y * this.V[H][j];
						}
						for (var X = 0; X < this.n; X++) this.V[X][j] = 0;
						this.V[j][j] = 1;
					}
					for (var K = M - 1; M > 0;) {
						var Q = void 0, J = void 0;
						for (Q = M - 2; Q >= -1 && -1 !== Q; Q--) if (Math.abs(r[Q]) <= 16033346880071782e-307 + 2220446049250313e-31 * (Math.abs(this.s[Q]) + Math.abs(this.s[Q + 1]))) {
							r[Q] = 0;
							break;
						}
						if (Q === M - 2) J = 4;
						else {
							var ee = void 0;
							for (ee = M - 1; ee >= Q && ee !== Q; ee--) {
								var et = (ee !== M ? Math.abs(r[ee]) : 0) + (ee !== Q + 1 ? Math.abs(r[ee - 1]) : 0);
								if (Math.abs(this.s[ee]) <= 16033346880071782e-307 + 2220446049250313e-31 * et) {
									this.s[ee] = 0;
									break;
								}
							}
							ee === Q ? J = 3 : ee === M - 1 ? J = 1 : (J = 2, Q = ee);
						}
						switch (Q++, J) {
							case 1:
								var er = r[M - 2];
								r[M - 2] = 0;
								for (var ei = M - 2; ei >= Q; ei--) {
									var en = i.hypot(this.s[ei], er), ea = this.s[ei] / en, es = er / en;
									this.s[ei] = en, ei !== Q && (er = -es * r[ei - 1], r[ei - 1] = ea * r[ei - 1]);
									for (var eo = 0; eo < this.n; eo++) en = ea * this.V[eo][ei] + es * this.V[eo][M - 1], this.V[eo][M - 1] = -es * this.V[eo][ei] + ea * this.V[eo][M - 1], this.V[eo][ei] = en;
								}
								break;
							case 2:
								var el = r[Q - 1];
								r[Q - 1] = 0;
								for (var ec = Q; ec < M; ec++) {
									var eh = i.hypot(this.s[ec], el), eu = this.s[ec] / eh, ed = el / eh;
									this.s[ec] = eh, el = -ed * r[ec], r[ec] = eu * r[ec];
									for (var ep = 0; ep < this.m; ep++) eh = eu * this.U[ep][ec] + ed * this.U[ep][Q - 1], this.U[ep][Q - 1] = -ed * this.U[ep][ec] + eu * this.U[ep][Q - 1], this.U[ep][ec] = eh;
								}
								break;
							case 3:
								var ef, eg, em, ey, ev = Math.max(Math.max(Math.max(Math.max(Math.abs(this.s[M - 1]), Math.abs(this.s[M - 2])), Math.abs(r[M - 2])), Math.abs(this.s[Q])), Math.abs(r[Q])), ex = this.s[M - 1] / ev, eb = this.s[M - 2] / ev, ew = r[M - 2] / ev, ek = this.s[Q] / ev, eT = r[Q] / ev, e_ = ((eb + ex) * (eb - ex) + ew * ew) / 2, eE = ex * ew * (ex * ew), eC = 0;
								em = 0 !== e_, ey = 0 !== eE, (em || ey) && (eC = Math.sqrt(e_ * e_ + eE), e_ < 0 && (eC = -eC), eC = eE / (e_ + eC));
								for (var eS = (ek + ex) * (ek - ex) + eC, eA = ek * eT, eL = Q; eL < M - 1; eL++) {
									var eR = i.hypot(eS, eA), eN = eS / eR, eI = eA / eR;
									eL !== Q && (r[eL - 1] = eR), eS = eN * this.s[eL] + eI * r[eL], r[eL] = eN * r[eL] - eI * this.s[eL], eA = eI * this.s[eL + 1], this.s[eL + 1] = eN * this.s[eL + 1];
									for (var eM = 0; eM < this.n; eM++) eR = eN * this.V[eM][eL] + eI * this.V[eM][eL + 1], this.V[eM][eL + 1] = -eI * this.V[eM][eL] + eN * this.V[eM][eL + 1], this.V[eM][eL] = eR;
									if (eR = i.hypot(eS, eA), eN = eS / eR, eI = eA / eR, this.s[eL] = eR, eS = eN * r[eL] + eI * this.s[eL + 1], this.s[eL + 1] = -eI * r[eL] + eN * this.s[eL + 1], eA = eI * r[eL + 1], r[eL + 1] = eN * r[eL + 1], eL < this.m - 1) for (var eD = 0; eD < this.m; eD++) eR = eN * this.U[eD][eL] + eI * this.U[eD][eL + 1], this.U[eD][eL + 1] = -eI * this.U[eD][eL] + eN * this.U[eD][eL + 1], this.U[eD][eL] = eR;
								}
								r[M - 2] = eS;
								break;
							case 4:
								if (this.s[Q] <= 0 && (this.s[Q] = this.s[Q] < 0 ? -this.s[Q] : 0, 1)) for (var eO = 0; eO <= K; eO++) this.V[eO][Q] = -this.V[eO][Q];
								for (; Q < K && !(this.s[Q] >= this.s[Q + 1]);) {
									var e$ = this.s[Q];
									if (this.s[Q] = this.s[Q + 1], this.s[Q + 1] = e$, Q < this.n - 1) for (var eP = 0; eP < this.n; eP++) e$ = this.V[eP][Q + 1], this.V[eP][Q + 1] = this.V[eP][Q], this.V[eP][Q] = e$;
									if (Q < this.m - 1) for (var eB = 0; eB < this.m; eB++) e$ = this.U[eB][Q + 1], this.U[eB][Q + 1] = this.U[eB][Q], this.U[eB][Q] = e$;
									Q++;
								}
								M--;
						}
					}
					return {
						U: this.U,
						V: this.V,
						S: this.s
					};
				}, i.hypot = function(e, t) {
					var r = void 0;
					return Math.abs(e) > Math.abs(t) ? (r = t / e, r = Math.abs(e) * Math.sqrt(1 + r * r)) : 0 != t ? (r = e / t, r = Math.abs(t) * Math.sqrt(1 + r * r)) : r = 0, r;
				}, e.exports = i;
			},
			function(e, t, r) {
				var i = function() {
					function e(e, t) {
						for (var r = 0; r < t.length; r++) {
							var i = t[r];
							i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
						}
					}
					return h(e, "defineProperties"), function(t, r, i) {
						return r && e(t.prototype, r), i && e(t, i), t;
					};
				}();
				function n(e, t) {
					if (!(e instanceof t)) throw TypeError("Cannot call a class as a function");
				}
				h(n, "_classCallCheck"), e.exports = function() {
					function e(t, r) {
						var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : -1, s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : -1;
						n(this, e), this.sequence1 = t, this.sequence2 = r, this.match_score = i, this.mismatch_penalty = a, this.gap_penalty = s, this.iMax = t.length + 1, this.jMax = r.length + 1, this.grid = Array(this.iMax);
						for (var o = 0; o < this.iMax; o++) {
							this.grid[o] = Array(this.jMax);
							for (var l = 0; l < this.jMax; l++) this.grid[o][l] = 0;
						}
						this.tracebackGrid = Array(this.iMax);
						for (var h = 0; h < this.iMax; h++) {
							this.tracebackGrid[h] = Array(this.jMax);
							for (var u = 0; u < this.jMax; u++) this.tracebackGrid[h][u] = [
								null,
								null,
								null
							];
						}
						this.alignments = [], this.score = -1, this.computeGrids();
					}
					return h(e, "NeedlemanWunsch"), i(e, [
						{
							key: "getScore",
							value: h(function() {
								return this.score;
							}, "getScore")
						},
						{
							key: "getAlignments",
							value: h(function() {
								return this.alignments;
							}, "getAlignments")
						},
						{
							key: "computeGrids",
							value: h(function() {
								for (var e = 1; e < this.jMax; e++) this.grid[0][e] = this.grid[0][e - 1] + this.gap_penalty, this.tracebackGrid[0][e] = [
									!1,
									!1,
									!0
								];
								for (var t = 1; t < this.iMax; t++) this.grid[t][0] = this.grid[t - 1][0] + this.gap_penalty, this.tracebackGrid[t][0] = [
									!1,
									!0,
									!1
								];
								for (var r = 1; r < this.iMax; r++) for (var i = 1; i < this.jMax; i++) {
									var n = [
										this.sequence1[r - 1] === this.sequence2[i - 1] ? this.grid[r - 1][i - 1] + this.match_score : this.grid[r - 1][i - 1] + this.mismatch_penalty,
										this.grid[r - 1][i] + this.gap_penalty,
										this.grid[r][i - 1] + this.gap_penalty
									], a = this.arrayAllMaxIndexes(n);
									this.grid[r][i] = n[a[0]], this.tracebackGrid[r][i] = [
										a.includes(0),
										a.includes(1),
										a.includes(2)
									];
								}
								this.score = this.grid[this.iMax - 1][this.jMax - 1];
							}, "computeGrids")
						},
						{
							key: "alignmentTraceback",
							value: h(function() {
								var e = [];
								for (e.push({
									pos: [this.sequence1.length, this.sequence2.length],
									seq1: "",
									seq2: ""
								}); e[0];) {
									var t = e[0], r = this.tracebackGrid[t.pos[0]][t.pos[1]];
									r[0] && e.push({
										pos: [t.pos[0] - 1, t.pos[1] - 1],
										seq1: this.sequence1[t.pos[0] - 1] + t.seq1,
										seq2: this.sequence2[t.pos[1] - 1] + t.seq2
									}), r[1] && e.push({
										pos: [t.pos[0] - 1, t.pos[1]],
										seq1: this.sequence1[t.pos[0] - 1] + t.seq1,
										seq2: "-" + t.seq2
									}), r[2] && e.push({
										pos: [t.pos[0], t.pos[1] - 1],
										seq1: "-" + t.seq1,
										seq2: this.sequence2[t.pos[1] - 1] + t.seq2
									}), 0 === t.pos[0] && 0 === t.pos[1] && this.alignments.push({
										sequence1: t.seq1,
										sequence2: t.seq2
									}), e.shift();
								}
								return this.alignments;
							}, "alignmentTraceback")
						},
						{
							key: "getAllIndexes",
							value: h(function(e, t) {
								for (var r = [], i = -1; -1 !== (i = e.indexOf(t, i + 1));) r.push(i);
								return r;
							}, "getAllIndexes")
						},
						{
							key: "arrayAllMaxIndexes",
							value: h(function(e) {
								return this.getAllIndexes(e, Math.max.apply(null, e));
							}, "arrayAllMaxIndexes")
						}
					]), e;
				}();
			},
			function(e, t, r) {
				var i = h(function() {}, "layoutBase");
				i.FDLayout = r(18), i.FDLayoutConstants = r(4), i.FDLayoutEdge = r(19), i.FDLayoutNode = r(20), i.DimensionD = r(21), i.HashMap = r(22), i.HashSet = r(23), i.IGeometry = r(8), i.IMath = r(9), i.Integer = r(10), i.Point = r(12), i.PointD = r(5), i.RandomSeed = r(16), i.RectangleD = r(13), i.Transform = r(17), i.UniqueIDGeneretor = r(14), i.Quicksort = r(25), i.LinkedList = r(11), i.LGraphObject = r(2), i.LGraph = r(6), i.LEdge = r(1), i.LGraphManager = r(7), i.LNode = r(3), i.Layout = r(15), i.LayoutConstants = r(0), i.NeedlemanWunsch = r(27), i.Matrix = r(24), i.SVD = r(26), e.exports = i;
			},
			function(e, t, r) {
				function i() {
					this.listeners = [];
				}
				h(i, "Emitter");
				var n = i.prototype;
				n.addListener = function(e, t) {
					this.listeners.push({
						event: e,
						callback: t
					});
				}, n.removeListener = function(e, t) {
					for (var r = this.listeners.length; r >= 0; r--) {
						var i = this.listeners[r];
						i.event === e && i.callback === t && this.listeners.splice(r, 1);
					}
				}, n.emit = function(e, t) {
					for (var r = 0; r < this.listeners.length; r++) {
						var i = this.listeners[r];
						e === i.event && i.callback(t);
					}
				}, e.exports = i;
			}
		], t = {};
		function r(i) {
			if (t[i]) return t[i].exports;
			var n = t[i] = {
				i,
				l: !1,
				exports: {}
			};
			return e[i].call(n.exports, n, n.exports, r), n.l = !0, n.exports;
		}
		return h(r, "__webpack_require__"), r.m = e, r.c = t, r.i = function(e) {
			return e;
		}, r.d = function(e, t, i) {
			r.o(e, t) || Object.defineProperty(e, t, {
				configurable: !1,
				enumerable: !0,
				get: i
			});
		}, r.n = function(e) {
			var t = e && e.__esModule ? h(function() {
				return e.default;
			}, "getDefault") : h(function() {
				return e;
			}, "getModuleExports");
			return r.d(t, "a", t), t;
		}, r.o = function(e, t) {
			return Object.prototype.hasOwnProperty.call(e, t);
		}, r.p = "", r(r.s = 28);
	});
}), X4 = u((e, t) => {
	h(function(r, i) {
		"object" == typeof e && "object" == typeof t ? t.exports = i(X2()) : "function" == typeof define && define.amd ? define(["layout-base"], i) : "object" == typeof e ? e.coseBase = i(X2()) : r.coseBase = i(r.layoutBase);
	}, "webpackUniversalModuleDefinition")(e, function(e) {
		var t = {
			45: (e, t, r) => {
				var i = {};
				i.layoutBase = r(551), i.CoSEConstants = r(806), i.CoSEEdge = r(767), i.CoSEGraph = r(880), i.CoSEGraphManager = r(578), i.CoSELayout = r(765), i.CoSENode = r(991), i.ConstraintHandler = r(902), e.exports = i;
			},
			806: (e, t, r) => {
				var i = r(551).FDLayoutConstants;
				function n() {}
				for (var a in h(n, "CoSEConstants"), i) n[a] = i[a];
				n.DEFAULT_USE_MULTI_LEVEL_SCALING = !1, n.DEFAULT_RADIAL_SEPARATION = i.DEFAULT_EDGE_LENGTH, n.DEFAULT_COMPONENT_SEPERATION = 60, n.TILE = !0, n.TILING_PADDING_VERTICAL = 10, n.TILING_PADDING_HORIZONTAL = 10, n.TRANSFORM_ON_CONSTRAINT_HANDLING = !0, n.ENFORCE_CONSTRAINTS = !0, n.APPLY_LAYOUT = !0, n.RELAX_MOVEMENT_ON_CONSTRAINTS = !0, n.TREE_REDUCTION_ON_INCREMENTAL = !0, n.PURE_INCREMENTAL = n.DEFAULT_INCREMENTAL, e.exports = n;
			},
			767: (e, t, r) => {
				var i = r(551).FDLayoutEdge;
				function n(e, t, r) {
					i.call(this, e, t, r);
				}
				for (var a in h(n, "CoSEEdge"), n.prototype = Object.create(i.prototype), i) n[a] = i[a];
				e.exports = n;
			},
			880: (e, t, r) => {
				var i = r(551).LGraph;
				function n(e, t, r) {
					i.call(this, e, t, r);
				}
				for (var a in h(n, "CoSEGraph"), n.prototype = Object.create(i.prototype), i) n[a] = i[a];
				e.exports = n;
			},
			578: (e, t, r) => {
				var i = r(551).LGraphManager;
				function n(e) {
					i.call(this, e);
				}
				for (var a in h(n, "CoSEGraphManager"), n.prototype = Object.create(i.prototype), i) n[a] = i[a];
				e.exports = n;
			},
			765: (e, t, r) => {
				var i = r(551).FDLayout, n = r(578), a = r(880), s = r(991), o = r(767), l = r(806), u = r(902), d = r(551).FDLayoutConstants, p = r(551).LayoutConstants, f = r(551).Point, g = r(551).PointD, m = r(551).DimensionD, y = r(551).Layout, v = r(551).Integer, x = r(551).IGeometry, b = r(551).LGraph, w = r(551).Transform, k = r(551).LinkedList;
				function T() {
					i.call(this), this.toBeTiled = {}, this.constraints = {};
				}
				for (var _ in h(T, "CoSELayout"), T.prototype = Object.create(i.prototype), i) T[_] = i[_];
				T.prototype.newGraphManager = function() {
					var e = new n(this);
					return this.graphManager = e, e;
				}, T.prototype.newGraph = function(e) {
					return new a(null, this.graphManager, e);
				}, T.prototype.newNode = function(e) {
					return new s(this.graphManager, e);
				}, T.prototype.newEdge = function(e) {
					return new o(null, null, e);
				}, T.prototype.initParameters = function() {
					i.prototype.initParameters.call(this, arguments), this.isSubLayout || (l.DEFAULT_EDGE_LENGTH < 10 ? this.idealEdgeLength = 10 : this.idealEdgeLength = l.DEFAULT_EDGE_LENGTH, this.useSmartIdealEdgeLengthCalculation = l.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION, this.gravityConstant = d.DEFAULT_GRAVITY_STRENGTH, this.compoundGravityConstant = d.DEFAULT_COMPOUND_GRAVITY_STRENGTH, this.gravityRangeFactor = d.DEFAULT_GRAVITY_RANGE_FACTOR, this.compoundGravityRangeFactor = d.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR, this.prunedNodesAll = [], this.growTreeIterations = 0, this.afterGrowthIterations = 0, this.isTreeGrowing = !1, this.isGrowthFinished = !1);
				}, T.prototype.initSpringEmbedder = function() {
					i.prototype.initSpringEmbedder.call(this), this.coolingCycle = 0, this.maxCoolingCycle = this.maxIterations / d.CONVERGENCE_CHECK_PERIOD, this.finalTemperature = .04, this.coolingAdjuster = 1;
				}, T.prototype.layout = function() {
					return p.DEFAULT_CREATE_BENDS_AS_NEEDED && (this.createBendpoints(), this.graphManager.resetAllEdges()), this.level = 0, this.classicLayout();
				}, T.prototype.classicLayout = function() {
					if (this.nodesWithGravity = this.calculateNodesToApplyGravitationTo(), this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity), this.calcNoOfChildrenForAllNodes(), this.graphManager.calcLowestCommonAncestors(), this.graphManager.calcInclusionTreeDepths(), this.graphManager.getRoot().calcEstimatedSize(), this.calcIdealEdgeLengths(), this.incremental) {
						if (l.TREE_REDUCTION_ON_INCREMENTAL) {
							this.reduceTrees(), this.graphManager.resetAllNodesToApplyGravitation();
							var e = new Set(this.getAllNodes()), t = this.nodesWithGravity.filter(function(t) {
								return e.has(t);
							});
							this.graphManager.setAllNodesToApplyGravitation(t);
						}
					} else {
						var r = this.getFlatForest();
						if (r.length > 0) this.positionNodesRadially(r);
						else {
							this.reduceTrees(), this.graphManager.resetAllNodesToApplyGravitation();
							var e = new Set(this.getAllNodes()), t = this.nodesWithGravity.filter(function(t) {
								return e.has(t);
							});
							this.graphManager.setAllNodesToApplyGravitation(t), this.positionNodesRandomly();
						}
					}
					return Object.keys(this.constraints).length > 0 && (u.handleConstraints(this), this.initConstraintVariables()), this.initSpringEmbedder(), l.APPLY_LAYOUT && this.runSpringEmbedder(), !0;
				}, T.prototype.tick = function() {
					if (this.totalIterations++, this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) if (!(this.prunedNodesAll.length > 0)) return !0;
					else this.isTreeGrowing = !0;
					if (this.totalIterations % d.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {
						if (this.isConverged()) if (!(this.prunedNodesAll.length > 0)) return !0;
						else this.isTreeGrowing = !0;
						this.coolingCycle++, 0 == this.layoutQuality ? this.coolingAdjuster = this.coolingCycle : 1 == this.layoutQuality && (this.coolingAdjuster = this.coolingCycle / 3), this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature), this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));
					}
					if (this.isTreeGrowing) {
						if (this.growTreeIterations % 10 == 0) if (this.prunedNodesAll.length > 0) {
							this.graphManager.updateBounds(), this.updateGrid(), this.growTree(this.prunedNodesAll), this.graphManager.resetAllNodesToApplyGravitation();
							var e = new Set(this.getAllNodes()), t = this.nodesWithGravity.filter(function(t) {
								return e.has(t);
							});
							this.graphManager.setAllNodesToApplyGravitation(t), this.graphManager.updateBounds(), this.updateGrid(), l.PURE_INCREMENTAL ? this.coolingFactor = d.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2 : this.coolingFactor = d.DEFAULT_COOLING_FACTOR_INCREMENTAL;
						} else this.isTreeGrowing = !1, this.isGrowthFinished = !0;
						this.growTreeIterations++;
					}
					if (this.isGrowthFinished) {
						if (this.isConverged()) return !0;
						this.afterGrowthIterations % 10 == 0 && (this.graphManager.updateBounds(), this.updateGrid()), l.PURE_INCREMENTAL ? this.coolingFactor = d.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2 * ((100 - this.afterGrowthIterations) / 100) : this.coolingFactor = d.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100), this.afterGrowthIterations++;
					}
					var r = !this.isTreeGrowing && !this.isGrowthFinished, i = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;
					return this.totalDisplacement = 0, this.graphManager.updateBounds(), this.calcSpringForces(), this.calcRepulsionForces(r, i), this.calcGravitationalForces(), this.moveNodes(), this.animate(), !1;
				}, T.prototype.getPositionsData = function() {
					for (var e = this.graphManager.getAllNodes(), t = {}, r = 0; r < e.length; r++) {
						var i = e[r].rect, n = e[r].id;
						t[n] = {
							id: n,
							x: i.getCenterX(),
							y: i.getCenterY(),
							w: i.width,
							h: i.height
						};
					}
					return t;
				}, T.prototype.runSpringEmbedder = function() {
					this.initialAnimationPeriod = 25, this.animationPeriod = this.initialAnimationPeriod;
					var e = !1;
					if ("during" === d.ANIMATE) this.emit("layoutstarted");
					else {
						for (; !e;) e = this.tick();
						this.graphManager.updateBounds();
					}
				}, T.prototype.moveNodes = function() {
					for (var t = this.getAllNodes(), r = 0; r < t.length; r++) t[r].calculateDisplacement();
					Object.keys(this.constraints).length > 0 && this.updateDisplacements();
					for (var r = 0; r < t.length; r++) t[r].move();
				}, T.prototype.initConstraintVariables = function() {
					var e = this;
					this.idToNodeMap = /* @__PURE__ */ new Map(), this.fixedNodeSet = /* @__PURE__ */ new Set();
					for (var t = this.graphManager.getAllNodes(), r = 0; r < t.length; r++) {
						var i = t[r];
						this.idToNodeMap.set(i.id, i);
					}
					var n = h(function t(r) {
						for (var i, n = r.getChild().getNodes(), a = 0, s = 0; s < n.length; s++) null == (i = n[s]).getChild() ? e.fixedNodeSet.has(i.id) && (a += 100) : a += t(i);
						return a;
					}, "calculateCompoundWeight");
					if (this.constraints.fixedNodeConstraint) {
						this.constraints.fixedNodeConstraint.forEach(function(t) {
							e.fixedNodeSet.add(t.nodeId);
						});
						for (var i, t = this.graphManager.getAllNodes(), r = 0; r < t.length; r++) if (null != (i = t[r]).getChild()) {
							var a = n(i);
							a > 0 && (i.fixedNodeWeight = a);
						}
					}
					if (this.constraints.relativePlacementConstraint) {
						var s = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
						if (this.dummyToNodeForVerticalAlignment = /* @__PURE__ */ new Map(), this.dummyToNodeForHorizontalAlignment = /* @__PURE__ */ new Map(), this.fixedNodesOnHorizontal = /* @__PURE__ */ new Set(), this.fixedNodesOnVertical = /* @__PURE__ */ new Set(), this.fixedNodeSet.forEach(function(t) {
							e.fixedNodesOnHorizontal.add(t), e.fixedNodesOnVertical.add(t);
						}), this.constraints.alignmentConstraint) {
							if (this.constraints.alignmentConstraint.vertical) for (var u = this.constraints.alignmentConstraint.vertical, r = 0; r < u.length; r++) this.dummyToNodeForVerticalAlignment.set("dummy" + r, []), u[r].forEach(function(t) {
								s.set(t, "dummy" + r), e.dummyToNodeForVerticalAlignment.get("dummy" + r).push(t), e.fixedNodeSet.has(t) && e.fixedNodesOnHorizontal.add("dummy" + r);
							});
							if (this.constraints.alignmentConstraint.horizontal) for (var d = this.constraints.alignmentConstraint.horizontal, r = 0; r < d.length; r++) this.dummyToNodeForHorizontalAlignment.set("dummy" + r, []), d[r].forEach(function(t) {
								o.set(t, "dummy" + r), e.dummyToNodeForHorizontalAlignment.get("dummy" + r).push(t), e.fixedNodeSet.has(t) && e.fixedNodesOnVertical.add("dummy" + r);
							});
						}
						if (l.RELAX_MOVEMENT_ON_CONSTRAINTS) this.shuffle = function(e) {
							var t, r, i;
							for (i = e.length - 1; i >= 2 * e.length / 3; i--) t = Math.floor(Math.random() * (i + 1)), r = e[i], e[i] = e[t], e[t] = r;
							return e;
						}, this.nodesInRelativeHorizontal = [], this.nodesInRelativeVertical = [], this.nodeToRelativeConstraintMapHorizontal = /* @__PURE__ */ new Map(), this.nodeToRelativeConstraintMapVertical = /* @__PURE__ */ new Map(), this.nodeToTempPositionMapHorizontal = /* @__PURE__ */ new Map(), this.nodeToTempPositionMapVertical = /* @__PURE__ */ new Map(), this.constraints.relativePlacementConstraint.forEach(function(t) {
							if (t.left) {
								var r = s.has(t.left) ? s.get(t.left) : t.left, i = s.has(t.right) ? s.get(t.right) : t.right;
								e.nodesInRelativeHorizontal.includes(r) || (e.nodesInRelativeHorizontal.push(r), e.nodeToRelativeConstraintMapHorizontal.set(r, []), e.dummyToNodeForVerticalAlignment.has(r) ? e.nodeToTempPositionMapHorizontal.set(r, e.idToNodeMap.get(e.dummyToNodeForVerticalAlignment.get(r)[0]).getCenterX()) : e.nodeToTempPositionMapHorizontal.set(r, e.idToNodeMap.get(r).getCenterX())), e.nodesInRelativeHorizontal.includes(i) || (e.nodesInRelativeHorizontal.push(i), e.nodeToRelativeConstraintMapHorizontal.set(i, []), e.dummyToNodeForVerticalAlignment.has(i) ? e.nodeToTempPositionMapHorizontal.set(i, e.idToNodeMap.get(e.dummyToNodeForVerticalAlignment.get(i)[0]).getCenterX()) : e.nodeToTempPositionMapHorizontal.set(i, e.idToNodeMap.get(i).getCenterX())), e.nodeToRelativeConstraintMapHorizontal.get(r).push({
									right: i,
									gap: t.gap
								}), e.nodeToRelativeConstraintMapHorizontal.get(i).push({
									left: r,
									gap: t.gap
								});
							} else {
								var n = o.has(t.top) ? o.get(t.top) : t.top, a = o.has(t.bottom) ? o.get(t.bottom) : t.bottom;
								e.nodesInRelativeVertical.includes(n) || (e.nodesInRelativeVertical.push(n), e.nodeToRelativeConstraintMapVertical.set(n, []), e.dummyToNodeForHorizontalAlignment.has(n) ? e.nodeToTempPositionMapVertical.set(n, e.idToNodeMap.get(e.dummyToNodeForHorizontalAlignment.get(n)[0]).getCenterY()) : e.nodeToTempPositionMapVertical.set(n, e.idToNodeMap.get(n).getCenterY())), e.nodesInRelativeVertical.includes(a) || (e.nodesInRelativeVertical.push(a), e.nodeToRelativeConstraintMapVertical.set(a, []), e.dummyToNodeForHorizontalAlignment.has(a) ? e.nodeToTempPositionMapVertical.set(a, e.idToNodeMap.get(e.dummyToNodeForHorizontalAlignment.get(a)[0]).getCenterY()) : e.nodeToTempPositionMapVertical.set(a, e.idToNodeMap.get(a).getCenterY())), e.nodeToRelativeConstraintMapVertical.get(n).push({
									bottom: a,
									gap: t.gap
								}), e.nodeToRelativeConstraintMapVertical.get(a).push({
									top: n,
									gap: t.gap
								});
							}
						});
						else {
							var p = /* @__PURE__ */ new Map(), f = /* @__PURE__ */ new Map();
							this.constraints.relativePlacementConstraint.forEach(function(e) {
								if (e.left) {
									var t = s.has(e.left) ? s.get(e.left) : e.left, r = s.has(e.right) ? s.get(e.right) : e.right;
									p.has(t) ? p.get(t).push(r) : p.set(t, [r]), p.has(r) ? p.get(r).push(t) : p.set(r, [t]);
								} else {
									var i = o.has(e.top) ? o.get(e.top) : e.top, n = o.has(e.bottom) ? o.get(e.bottom) : e.bottom;
									f.has(i) ? f.get(i).push(n) : f.set(i, [n]), f.has(n) ? f.get(n).push(i) : f.set(n, [i]);
								}
							});
							var g = h(function(e, t) {
								var r = [], i = [], n = new k(), a = /* @__PURE__ */ new Set(), s = 0;
								return e.forEach(function(o, l) {
									if (!a.has(l)) {
										r[s] = [], i[s] = !1;
										var h = l;
										for (n.push(h), a.add(h), r[s].push(h); 0 != n.length;) h = n.shift(), t.has(h) && (i[s] = !0), e.get(h).forEach(function(e) {
											a.has(e) || (n.push(e), a.add(e), r[s].push(e));
										});
										s++;
									}
								}), {
									components: r,
									isFixed: i
								};
							}, "constructComponents"), m = g(p, e.fixedNodesOnHorizontal);
							this.componentsOnHorizontal = m.components, this.fixedComponentsOnHorizontal = m.isFixed;
							var y = g(f, e.fixedNodesOnVertical);
							this.componentsOnVertical = y.components, this.fixedComponentsOnVertical = y.isFixed;
						}
					}
				}, T.prototype.updateDisplacements = function() {
					var e = this;
					if (this.constraints.fixedNodeConstraint && this.constraints.fixedNodeConstraint.forEach(function(t) {
						var r = e.idToNodeMap.get(t.nodeId);
						r.displacementX = 0, r.displacementY = 0;
					}), this.constraints.alignmentConstraint) {
						if (this.constraints.alignmentConstraint.vertical) for (var t = this.constraints.alignmentConstraint.vertical, r = 0; r < t.length; r++) {
							for (var i = 0, n = 0; n < t[r].length; n++) {
								if (this.fixedNodeSet.has(t[r][n])) {
									i = 0;
									break;
								}
								i += this.idToNodeMap.get(t[r][n]).displacementX;
							}
							for (var a = i / t[r].length, n = 0; n < t[r].length; n++) this.idToNodeMap.get(t[r][n]).displacementX = a;
						}
						if (this.constraints.alignmentConstraint.horizontal) for (var s = this.constraints.alignmentConstraint.horizontal, r = 0; r < s.length; r++) {
							for (var o = 0, n = 0; n < s[r].length; n++) {
								if (this.fixedNodeSet.has(s[r][n])) {
									o = 0;
									break;
								}
								o += this.idToNodeMap.get(s[r][n]).displacementY;
							}
							for (var h = o / s[r].length, n = 0; n < s[r].length; n++) this.idToNodeMap.get(s[r][n]).displacementY = h;
						}
					}
					if (this.constraints.relativePlacementConstraint) if (l.RELAX_MOVEMENT_ON_CONSTRAINTS) this.totalIterations % 10 == 0 && (this.shuffle(this.nodesInRelativeHorizontal), this.shuffle(this.nodesInRelativeVertical)), this.nodesInRelativeHorizontal.forEach(function(t) {
						if (!e.fixedNodesOnHorizontal.has(t)) {
							var r = 0;
							r = e.dummyToNodeForVerticalAlignment.has(t) ? e.idToNodeMap.get(e.dummyToNodeForVerticalAlignment.get(t)[0]).displacementX : e.idToNodeMap.get(t).displacementX, e.nodeToRelativeConstraintMapHorizontal.get(t).forEach(function(i) {
								if (i.right) {
									var n = e.nodeToTempPositionMapHorizontal.get(i.right) - e.nodeToTempPositionMapHorizontal.get(t) - r;
									n < i.gap && (r -= i.gap - n);
								} else {
									var n = e.nodeToTempPositionMapHorizontal.get(t) - e.nodeToTempPositionMapHorizontal.get(i.left) + r;
									n < i.gap && (r += i.gap - n);
								}
							}), e.nodeToTempPositionMapHorizontal.set(t, e.nodeToTempPositionMapHorizontal.get(t) + r), e.dummyToNodeForVerticalAlignment.has(t) ? e.dummyToNodeForVerticalAlignment.get(t).forEach(function(t) {
								e.idToNodeMap.get(t).displacementX = r;
							}) : e.idToNodeMap.get(t).displacementX = r;
						}
					}), this.nodesInRelativeVertical.forEach(function(t) {
						if (!e.fixedNodesOnHorizontal.has(t)) {
							var r = 0;
							r = e.dummyToNodeForHorizontalAlignment.has(t) ? e.idToNodeMap.get(e.dummyToNodeForHorizontalAlignment.get(t)[0]).displacementY : e.idToNodeMap.get(t).displacementY, e.nodeToRelativeConstraintMapVertical.get(t).forEach(function(i) {
								if (i.bottom) {
									var n = e.nodeToTempPositionMapVertical.get(i.bottom) - e.nodeToTempPositionMapVertical.get(t) - r;
									n < i.gap && (r -= i.gap - n);
								} else {
									var n = e.nodeToTempPositionMapVertical.get(t) - e.nodeToTempPositionMapVertical.get(i.top) + r;
									n < i.gap && (r += i.gap - n);
								}
							}), e.nodeToTempPositionMapVertical.set(t, e.nodeToTempPositionMapVertical.get(t) + r), e.dummyToNodeForHorizontalAlignment.has(t) ? e.dummyToNodeForHorizontalAlignment.get(t).forEach(function(t) {
								e.idToNodeMap.get(t).displacementY = r;
							}) : e.idToNodeMap.get(t).displacementY = r;
						}
					});
					else {
						for (var r = 0; r < this.componentsOnHorizontal.length; r++) {
							var u = this.componentsOnHorizontal[r];
							if (this.fixedComponentsOnHorizontal[r]) for (var n = 0; n < u.length; n++) this.dummyToNodeForVerticalAlignment.has(u[n]) ? this.dummyToNodeForVerticalAlignment.get(u[n]).forEach(function(t) {
								e.idToNodeMap.get(t).displacementX = 0;
							}) : this.idToNodeMap.get(u[n]).displacementX = 0;
							else {
								for (var d = 0, p = 0, n = 0; n < u.length; n++) if (this.dummyToNodeForVerticalAlignment.has(u[n])) {
									var f = this.dummyToNodeForVerticalAlignment.get(u[n]);
									d += f.length * this.idToNodeMap.get(f[0]).displacementX, p += f.length;
								} else d += this.idToNodeMap.get(u[n]).displacementX, p++;
								for (var g = d / p, n = 0; n < u.length; n++) this.dummyToNodeForVerticalAlignment.has(u[n]) ? this.dummyToNodeForVerticalAlignment.get(u[n]).forEach(function(t) {
									e.idToNodeMap.get(t).displacementX = g;
								}) : this.idToNodeMap.get(u[n]).displacementX = g;
							}
						}
						for (var r = 0; r < this.componentsOnVertical.length; r++) {
							var u = this.componentsOnVertical[r];
							if (this.fixedComponentsOnVertical[r]) for (var n = 0; n < u.length; n++) this.dummyToNodeForHorizontalAlignment.has(u[n]) ? this.dummyToNodeForHorizontalAlignment.get(u[n]).forEach(function(t) {
								e.idToNodeMap.get(t).displacementY = 0;
							}) : this.idToNodeMap.get(u[n]).displacementY = 0;
							else {
								for (var d = 0, p = 0, n = 0; n < u.length; n++) if (this.dummyToNodeForHorizontalAlignment.has(u[n])) {
									var f = this.dummyToNodeForHorizontalAlignment.get(u[n]);
									d += f.length * this.idToNodeMap.get(f[0]).displacementY, p += f.length;
								} else d += this.idToNodeMap.get(u[n]).displacementY, p++;
								for (var g = d / p, n = 0; n < u.length; n++) this.dummyToNodeForHorizontalAlignment.has(u[n]) ? this.dummyToNodeForHorizontalAlignment.get(u[n]).forEach(function(t) {
									e.idToNodeMap.get(t).displacementY = g;
								}) : this.idToNodeMap.get(u[n]).displacementY = g;
							}
						}
					}
				}, T.prototype.calculateNodesToApplyGravitationTo = function() {
					var e, t, r = [], i = this.graphManager.getGraphs(), n = i.length;
					for (t = 0; t < n; t++) (e = i[t]).updateConnected(), e.isConnected || (r = r.concat(e.getNodes()));
					return r;
				}, T.prototype.createBendpoints = function() {
					var e = [];
					e = e.concat(this.graphManager.getAllEdges());
					var t, r = /* @__PURE__ */ new Set();
					for (t = 0; t < e.length; t++) {
						var i = e[t];
						if (!r.has(i)) {
							var n = i.getSource(), a = i.getTarget();
							if (n == a) i.getBendpoints().push(new g()), i.getBendpoints().push(new g()), this.createDummyNodesForBendpoints(i), r.add(i);
							else {
								var s, o = [];
								if (o = (o = o.concat(n.getEdgeListToNode(a))).concat(a.getEdgeListToNode(n)), !r.has(o[0])) {
									if (o.length > 1) for (s = 0; s < o.length; s++) {
										var l = o[s];
										l.getBendpoints().push(new g()), this.createDummyNodesForBendpoints(l);
									}
									o.forEach(function(e) {
										r.add(e);
									});
								}
							}
						}
						if (r.size == e.length) break;
					}
				}, T.prototype.positionNodesRadially = function(e) {
					for (var t = new f(0, 0), r = Math.ceil(Math.sqrt(e.length)), i = 0, n = 0, a = 0, s = new g(0, 0), o = 0; o < e.length; o++) {
						o % r == 0 && (a = 0, n = i, 0 != o && (n += l.DEFAULT_COMPONENT_SEPERATION), i = 0);
						var h = e[o], u = y.findCenterOfTree(h);
						t.x = a, t.y = n, (s = T.radialLayout(h, u, t)).y > i && (i = Math.floor(s.y)), a = Math.floor(s.x + l.DEFAULT_COMPONENT_SEPERATION);
					}
					this.transform(new g(p.WORLD_CENTER_X - s.x / 2, p.WORLD_CENTER_Y - s.y / 2));
				}, T.radialLayout = function(e, t, r) {
					var i = Math.max(this.maxDiagonalInTree(e), l.DEFAULT_RADIAL_SEPARATION);
					T.branchRadialLayout(t, null, 0, 359, 0, i);
					var n = b.calculateBounds(e), a = new w();
					a.setDeviceOrgX(n.getMinX()), a.setDeviceOrgY(n.getMinY()), a.setWorldOrgX(r.x), a.setWorldOrgY(r.y);
					for (var s = 0; s < e.length; s++) e[s].transform(a);
					var o = new g(n.getMaxX(), n.getMaxY());
					return a.inverseTransformPoint(o);
				}, T.branchRadialLayout = function(e, t, r, i, n, a) {
					var s = (i - r + 1) / 2;
					s < 0 && (s += 180);
					var o = (s + r) % 360 * x.TWO_PI / 360, l = n * Math.cos(o), h = n * Math.sin(o);
					e.setCenter(l, h);
					var u = [], d = (u = u.concat(e.getEdges())).length;
					null != t && d--;
					for (var p, f = 0, g = u.length, m = e.getEdgesBetween(t); m.length > 1;) {
						var y = m[0];
						m.splice(0, 1);
						var v = u.indexOf(y);
						v >= 0 && u.splice(v, 1), g--, d--;
					}
					p = null != t ? (u.indexOf(m[0]) + 1) % g : 0;
					for (var b = Math.abs(i - r) / d, w = p; f != d; w = ++w % g) {
						var k = u[w].getOtherEnd(e);
						if (k != t) {
							var _ = (r + f * b) % 360, E = (_ + b) % 360;
							T.branchRadialLayout(k, e, _, E, n + a, a), f++;
						}
					}
				}, T.maxDiagonalInTree = function(e) {
					for (var t = v.MIN_VALUE, r = 0; r < e.length; r++) {
						var i = e[r].getDiagonal();
						i > t && (t = i);
					}
					return t;
				}, T.prototype.calcRepulsionRange = function() {
					return 2 * (this.level + 1) * this.idealEdgeLength;
				}, T.prototype.groupZeroDegreeMembers = function() {
					var e = this, t = {};
					this.memberGroups = {}, this.idToDummyNode = {};
					for (var r = [], i = this.graphManager.getAllNodes(), n = 0; n < i.length; n++) {
						var a = i[n], o = a.getParent();
						0 !== this.getNodeDegreeWithChildren(a) || null != o.id && this.getToBeTiled(o) || r.push(a);
					}
					for (var n = 0; n < r.length; n++) {
						var a = r[n], l = a.getParent().id;
						typeof t[l] > "u" && (t[l] = []), t[l] = t[l].concat(a);
					}
					Object.keys(t).forEach(function(r) {
						if (t[r].length > 1) {
							var i = "DummyCompound_" + r;
							e.memberGroups[i] = t[r];
							var n = t[r][0].getParent(), a = new s(e.graphManager);
							a.id = i, a.paddingLeft = n.paddingLeft || 0, a.paddingRight = n.paddingRight || 0, a.paddingBottom = n.paddingBottom || 0, a.paddingTop = n.paddingTop || 0, e.idToDummyNode[i] = a;
							var o = e.getGraphManager().add(e.newGraph(), a), l = n.getChild();
							l.add(a);
							for (var h = 0; h < t[r].length; h++) {
								var u = t[r][h];
								l.remove(u), o.add(u);
							}
						}
					});
				}, T.prototype.clearCompounds = function() {
					var e = {}, t = {};
					this.performDFSOnCompounds();
					for (var r = 0; r < this.compoundOrder.length; r++) t[this.compoundOrder[r].id] = this.compoundOrder[r], e[this.compoundOrder[r].id] = [].concat(this.compoundOrder[r].getChild().getNodes()), this.graphManager.remove(this.compoundOrder[r].getChild()), this.compoundOrder[r].child = null;
					this.graphManager.resetAllNodes(), this.tileCompoundMembers(e, t);
				}, T.prototype.clearZeroDegreeMembers = function() {
					var e = this, t = this.tiledZeroDegreePack = [];
					Object.keys(this.memberGroups).forEach(function(r) {
						var i = e.idToDummyNode[r];
						if (t[r] = e.tileNodes(e.memberGroups[r], i.paddingLeft + i.paddingRight), i.rect.width = t[r].width, i.rect.height = t[r].height, i.setCenter(t[r].centerX, t[r].centerY), i.labelMarginLeft = 0, i.labelMarginTop = 0, l.NODE_DIMENSIONS_INCLUDE_LABELS) {
							var n = i.rect.width, a = i.rect.height;
							i.labelWidth && ("left" == i.labelPosHorizontal ? (i.rect.x -= i.labelWidth, i.setWidth(n + i.labelWidth), i.labelMarginLeft = i.labelWidth) : "center" == i.labelPosHorizontal && i.labelWidth > n ? (i.rect.x -= (i.labelWidth - n) / 2, i.setWidth(i.labelWidth), i.labelMarginLeft = (i.labelWidth - n) / 2) : "right" == i.labelPosHorizontal && i.setWidth(n + i.labelWidth)), i.labelHeight && ("top" == i.labelPosVertical ? (i.rect.y -= i.labelHeight, i.setHeight(a + i.labelHeight), i.labelMarginTop = i.labelHeight) : "center" == i.labelPosVertical && i.labelHeight > a ? (i.rect.y -= (i.labelHeight - a) / 2, i.setHeight(i.labelHeight), i.labelMarginTop = (i.labelHeight - a) / 2) : "bottom" == i.labelPosVertical && i.setHeight(a + i.labelHeight));
						}
					});
				}, T.prototype.repopulateCompounds = function() {
					for (var e = this.compoundOrder.length - 1; e >= 0; e--) {
						var t = this.compoundOrder[e], r = t.id, i = t.paddingLeft, n = t.paddingTop, a = t.labelMarginLeft, s = t.labelMarginTop;
						this.adjustLocations(this.tiledMemberPack[r], t.rect.x, t.rect.y, i, n, a, s);
					}
				}, T.prototype.repopulateZeroDegreeMembers = function() {
					var e = this, t = this.tiledZeroDegreePack;
					Object.keys(t).forEach(function(r) {
						var i = e.idToDummyNode[r], n = i.paddingLeft, a = i.paddingTop, s = i.labelMarginLeft, o = i.labelMarginTop;
						e.adjustLocations(t[r], i.rect.x, i.rect.y, n, a, s, o);
					});
				}, T.prototype.getToBeTiled = function(e) {
					var t = e.id;
					if (null != this.toBeTiled[t]) return this.toBeTiled[t];
					var r = e.getChild();
					if (null == r) return this.toBeTiled[t] = !1, !1;
					for (var i = r.getNodes(), n = 0; n < i.length; n++) {
						var a = i[n];
						if (this.getNodeDegree(a) > 0) return this.toBeTiled[t] = !1, !1;
						if (null == a.getChild()) {
							this.toBeTiled[a.id] = !1;
							continue;
						}
						if (!this.getToBeTiled(a)) return this.toBeTiled[t] = !1, !1;
					}
					return this.toBeTiled[t] = !0, !0;
				}, T.prototype.getNodeDegree = function(e) {
					e.id;
					for (var t = e.getEdges(), r = 0, i = 0; i < t.length; i++) {
						var n = t[i];
						n.getSource().id !== n.getTarget().id && (r += 1);
					}
					return r;
				}, T.prototype.getNodeDegreeWithChildren = function(e) {
					var t = this.getNodeDegree(e);
					if (null == e.getChild()) return t;
					for (var r = e.getChild().getNodes(), i = 0; i < r.length; i++) {
						var n = r[i];
						t += this.getNodeDegreeWithChildren(n);
					}
					return t;
				}, T.prototype.performDFSOnCompounds = function() {
					this.compoundOrder = [], this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());
				}, T.prototype.fillCompexOrderByDFS = function(e) {
					for (var t = 0; t < e.length; t++) {
						var r = e[t];
						null != r.getChild() && this.fillCompexOrderByDFS(r.getChild().getNodes()), this.getToBeTiled(r) && this.compoundOrder.push(r);
					}
				}, T.prototype.adjustLocations = function(e, t, r, i, n, a, s) {
					t += i + a, r += n + s;
					for (var o = t, l = 0; l < e.rows.length; l++) {
						var h = e.rows[l];
						t = o;
						for (var u = 0, d = 0; d < h.length; d++) {
							var p = h[d];
							p.rect.x = t, p.rect.y = r, t += p.rect.width + e.horizontalPadding, p.rect.height > u && (u = p.rect.height);
						}
						r += u + e.verticalPadding;
					}
				}, T.prototype.tileCompoundMembers = function(e, t) {
					var r = this;
					this.tiledMemberPack = [], Object.keys(e).forEach(function(i) {
						var n = t[i];
						if (r.tiledMemberPack[i] = r.tileNodes(e[i], n.paddingLeft + n.paddingRight), n.rect.width = r.tiledMemberPack[i].width, n.rect.height = r.tiledMemberPack[i].height, n.setCenter(r.tiledMemberPack[i].centerX, r.tiledMemberPack[i].centerY), n.labelMarginLeft = 0, n.labelMarginTop = 0, l.NODE_DIMENSIONS_INCLUDE_LABELS) {
							var a = n.rect.width, s = n.rect.height;
							n.labelWidth && ("left" == n.labelPosHorizontal ? (n.rect.x -= n.labelWidth, n.setWidth(a + n.labelWidth), n.labelMarginLeft = n.labelWidth) : "center" == n.labelPosHorizontal && n.labelWidth > a ? (n.rect.x -= (n.labelWidth - a) / 2, n.setWidth(n.labelWidth), n.labelMarginLeft = (n.labelWidth - a) / 2) : "right" == n.labelPosHorizontal && n.setWidth(a + n.labelWidth)), n.labelHeight && ("top" == n.labelPosVertical ? (n.rect.y -= n.labelHeight, n.setHeight(s + n.labelHeight), n.labelMarginTop = n.labelHeight) : "center" == n.labelPosVertical && n.labelHeight > s ? (n.rect.y -= (n.labelHeight - s) / 2, n.setHeight(n.labelHeight), n.labelMarginTop = (n.labelHeight - s) / 2) : "bottom" == n.labelPosVertical && n.setHeight(s + n.labelHeight));
						}
					});
				}, T.prototype.tileNodes = function(e, t) {
					var r = this.tileNodesByFavoringDim(e, t, !0), i = this.tileNodesByFavoringDim(e, t, !1), n = this.getOrgRatio(r);
					return this.getOrgRatio(i) < n ? i : r;
				}, T.prototype.getOrgRatio = function(e) {
					var t = e.width / e.height;
					return t < 1 && (t = 1 / t), t;
				}, T.prototype.calcIdealRowWidth = function(e, t) {
					var r = l.TILING_PADDING_VERTICAL, i = l.TILING_PADDING_HORIZONTAL, n = e.length, a = 0, s = 0, o = 0;
					e.forEach(function(e) {
						a += e.getWidth(), s += e.getHeight(), e.getWidth() > o && (o = e.getWidth());
					});
					var h, u = a / n, d = Math.pow(r - i, 2) + 4 * (u + i) * (s / n + r) * n, p = (i - r + Math.sqrt(d)) / (2 * (u + i));
					t ? (h = Math.ceil(p)) == p && h++ : h = Math.floor(p);
					var f = h * (u + i) - i;
					return o > f && (f = o), f += 2 * i;
				}, T.prototype.tileNodesByFavoringDim = function(e, t, r) {
					var i = l.TILING_PADDING_VERTICAL, n = l.TILING_PADDING_HORIZONTAL, a = l.TILING_COMPARE_BY, s = {
						rows: [],
						rowWidth: [],
						rowHeight: [],
						width: 0,
						height: t,
						verticalPadding: i,
						horizontalPadding: n,
						centerX: 0,
						centerY: 0
					};
					a && (s.idealRowWidth = this.calcIdealRowWidth(e, r));
					var o = h(function(e) {
						return e.rect.width * e.rect.height;
					}, "getNodeArea"), u = h(function(e, t) {
						return o(t) - o(e);
					}, "areaCompareFcn");
					e.sort(function(e, t) {
						var r = u;
						return s.idealRowWidth ? (r = a)(e.id, t.id) : r(e, t);
					});
					for (var d = 0, p = 0, f = 0; f < e.length; f++) {
						var g = e[f];
						d += g.getCenterX(), p += g.getCenterY();
					}
					s.centerX = d / e.length, s.centerY = p / e.length;
					for (var f = 0; f < e.length; f++) {
						var g = e[f];
						if (0 == s.rows.length) this.insertNodeToRow(s, g, 0, t);
						else if (this.canAddHorizontal(s, g.rect.width, g.rect.height)) {
							var m = s.rows.length - 1;
							s.idealRowWidth || (m = this.getShortestRowIndex(s)), this.insertNodeToRow(s, g, m, t);
						} else this.insertNodeToRow(s, g, s.rows.length, t);
						this.shiftToLastRow(s);
					}
					return s;
				}, T.prototype.insertNodeToRow = function(e, t, r, i) {
					r == e.rows.length && (e.rows.push([]), e.rowWidth.push(i), e.rowHeight.push(0));
					var n = e.rowWidth[r] + t.rect.width;
					e.rows[r].length > 0 && (n += e.horizontalPadding), e.rowWidth[r] = n, e.width < n && (e.width = n);
					var a = t.rect.height;
					r > 0 && (a += e.verticalPadding);
					var s = 0;
					a > e.rowHeight[r] && (s = e.rowHeight[r], e.rowHeight[r] = a, s = e.rowHeight[r] - s), e.height += s, e.rows[r].push(t);
				}, T.prototype.getShortestRowIndex = function(e) {
					for (var t = -1, r = Number.MAX_VALUE, i = 0; i < e.rows.length; i++) e.rowWidth[i] < r && (t = i, r = e.rowWidth[i]);
					return t;
				}, T.prototype.getLongestRowIndex = function(e) {
					for (var t = -1, r = 5e-324, i = 0; i < e.rows.length; i++) e.rowWidth[i] > r && (t = i, r = e.rowWidth[i]);
					return t;
				}, T.prototype.canAddHorizontal = function(e, t, r) {
					if (e.idealRowWidth) {
						var i, n, a = e.rows.length - 1;
						return e.rowWidth[a] + t + e.horizontalPadding <= e.idealRowWidth;
					}
					var s = this.getShortestRowIndex(e);
					if (s < 0) return !0;
					var o = e.rowWidth[s];
					if (o + e.horizontalPadding + t <= e.width) return !0;
					var l = 0;
					return e.rowHeight[s] < r && s > 0 && (l = r + e.verticalPadding - e.rowHeight[s]), i = e.width - o >= t + e.horizontalPadding ? (e.height + l) / (o + t + e.horizontalPadding) : (e.height + l) / e.width, l = r + e.verticalPadding, (n = e.width < t ? (e.height + l) / t : (e.height + l) / e.width) < 1 && (n = 1 / n), i < 1 && (i = 1 / i), i < n;
				}, T.prototype.shiftToLastRow = function(e) {
					var t = this.getLongestRowIndex(e), r = e.rowWidth.length - 1, i = e.rows[t], n = i[i.length - 1], a = n.width + e.horizontalPadding;
					if (e.width - e.rowWidth[r] > a && t != r) {
						i.splice(-1, 1), e.rows[r].push(n), e.rowWidth[t] = e.rowWidth[t] - a, e.rowWidth[r] = e.rowWidth[r] + a, e.width = e.rowWidth[instance.getLongestRowIndex(e)];
						for (var s = 5e-324, o = 0; o < i.length; o++) i[o].height > s && (s = i[o].height);
						t > 0 && (s += e.verticalPadding);
						var l = e.rowHeight[t] + e.rowHeight[r];
						e.rowHeight[t] = s, e.rowHeight[r] < n.height + e.verticalPadding && (e.rowHeight[r] = n.height + e.verticalPadding);
						var h = e.rowHeight[t] + e.rowHeight[r];
						e.height += h - l, this.shiftToLastRow(e);
					}
				}, T.prototype.tilingPreLayout = function() {
					l.TILE && (this.groupZeroDegreeMembers(), this.clearCompounds(), this.clearZeroDegreeMembers());
				}, T.prototype.tilingPostLayout = function() {
					l.TILE && (this.repopulateZeroDegreeMembers(), this.repopulateCompounds());
				}, T.prototype.reduceTrees = function() {
					for (var e, t = [], r = !0; r;) {
						var i = this.graphManager.getAllNodes(), n = [];
						r = !1;
						for (var a = 0; a < i.length; a++) if (1 == (e = i[a]).getEdges().length && !e.getEdges()[0].isInterGraph && null == e.getChild()) {
							if (l.PURE_INCREMENTAL) {
								var s = e.getEdges()[0].getOtherEnd(e), o = new m(e.getCenterX() - s.getCenterX(), e.getCenterY() - s.getCenterY());
								n.push([
									e,
									e.getEdges()[0],
									e.getOwner(),
									o
								]);
							} else n.push([
								e,
								e.getEdges()[0],
								e.getOwner()
							]);
							r = !0;
						}
						if (!0 == r) {
							for (var h = [], u = 0; u < n.length; u++) 1 == n[u][0].getEdges().length && (h.push(n[u]), n[u][0].getOwner().remove(n[u][0]));
							t.push(h), this.graphManager.resetAllNodes(), this.graphManager.resetAllEdges();
						}
					}
					this.prunedNodesAll = t;
				}, T.prototype.growTree = function(e) {
					for (var t, r = e[e.length - 1], i = 0; i < r.length; i++) t = r[i], this.findPlaceforPrunedNode(t), t[2].add(t[0]), t[2].add(t[1], t[1].source, t[1].target);
					e.splice(e.length - 1, 1), this.graphManager.resetAllNodes(), this.graphManager.resetAllEdges();
				}, T.prototype.findPlaceforPrunedNode = function(e) {
					var t, r, i = e[0];
					if (r = i == e[1].source ? e[1].target : e[1].source, l.PURE_INCREMENTAL) i.setCenter(r.getCenterX() + e[3].getWidth(), r.getCenterY() + e[3].getHeight());
					else {
						var n = r.startX, a = r.finishX, s = r.startY, o = r.finishY, h = [
							0,
							0,
							0,
							0
						];
						if (s > 0) for (var u = n; u <= a; u++) h[0] += this.grid[u][s - 1].length + this.grid[u][s].length - 1;
						if (a < this.grid.length - 1) for (var u = s; u <= o; u++) h[1] += this.grid[a + 1][u].length + this.grid[a][u].length - 1;
						if (o < this.grid[0].length - 1) for (var u = n; u <= a; u++) h[2] += this.grid[u][o + 1].length + this.grid[u][o].length - 1;
						if (n > 0) for (var u = s; u <= o; u++) h[3] += this.grid[n - 1][u].length + this.grid[n][u].length - 1;
						for (var p, f, g = v.MAX_VALUE, m = 0; m < h.length; m++) h[m] < g ? (g = h[m], p = 1, f = m) : h[m] == g && p++;
						if (3 == p && 0 == g) 0 == h[0] && 0 == h[1] && 0 == h[2] ? t = 1 : 0 == h[0] && 0 == h[1] && 0 == h[3] ? t = 0 : 0 == h[0] && 0 == h[2] && 0 == h[3] ? t = 3 : 0 == h[1] && 0 == h[2] && 0 == h[3] && (t = 2);
						else if (2 == p && 0 == g) {
							var y = Math.floor(2 * Math.random());
							t = 0 == h[0] && 0 == h[1] ? +(0 != y) : 0 == h[0] && 0 == h[2] ? 2 * (0 != y) : 0 == h[0] && 0 == h[3] ? 3 * (0 != y) : 0 == h[1] && 0 == h[2] ? 0 == y ? 1 : 2 : 0 == h[1] && 0 == h[3] ? 0 == y ? 1 : 3 : 0 == y ? 2 : 3;
						} else if (4 == p && 0 == g) {
							var y = Math.floor(4 * Math.random());
							t = y;
						} else t = f;
						0 == t ? i.setCenter(r.getCenterX(), r.getCenterY() - r.getHeight() / 2 - d.DEFAULT_EDGE_LENGTH - i.getHeight() / 2) : 1 == t ? i.setCenter(r.getCenterX() + r.getWidth() / 2 + d.DEFAULT_EDGE_LENGTH + i.getWidth() / 2, r.getCenterY()) : 2 == t ? i.setCenter(r.getCenterX(), r.getCenterY() + r.getHeight() / 2 + d.DEFAULT_EDGE_LENGTH + i.getHeight() / 2) : i.setCenter(r.getCenterX() - r.getWidth() / 2 - d.DEFAULT_EDGE_LENGTH - i.getWidth() / 2, r.getCenterY());
					}
				}, e.exports = T;
			},
			991: (e, t, r) => {
				var i = r(551).FDLayoutNode, n = r(551).IMath;
				function a(e, t, r, n) {
					i.call(this, e, t, r, n);
				}
				for (var s in h(a, "CoSENode"), a.prototype = Object.create(i.prototype), i) a[s] = i[s];
				a.prototype.calculateDisplacement = function() {
					var e = this.graphManager.getLayout();
					null != this.getChild() && this.fixedNodeWeight ? (this.displacementX += e.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.fixedNodeWeight, this.displacementY += e.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.fixedNodeWeight) : (this.displacementX += e.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren, this.displacementY += e.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren), Math.abs(this.displacementX) > e.coolingFactor * e.maxNodeDisplacement && (this.displacementX = e.coolingFactor * e.maxNodeDisplacement * n.sign(this.displacementX)), Math.abs(this.displacementY) > e.coolingFactor * e.maxNodeDisplacement && (this.displacementY = e.coolingFactor * e.maxNodeDisplacement * n.sign(this.displacementY)), this.child && this.child.getNodes().length > 0 && this.propogateDisplacementToChildren(this.displacementX, this.displacementY);
				}, a.prototype.propogateDisplacementToChildren = function(e, t) {
					for (var r, i = this.getChild().getNodes(), n = 0; n < i.length; n++) null == (r = i[n]).getChild() ? (r.displacementX += e, r.displacementY += t) : r.propogateDisplacementToChildren(e, t);
				}, a.prototype.move = function() {
					var e = this.graphManager.getLayout();
					(null == this.child || 0 == this.child.getNodes().length) && (this.moveBy(this.displacementX, this.displacementY), e.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY)), this.springForceX = 0, this.springForceY = 0, this.repulsionForceX = 0, this.repulsionForceY = 0, this.gravitationForceX = 0, this.gravitationForceY = 0, this.displacementX = 0, this.displacementY = 0;
				}, a.prototype.setPred1 = function(e) {
					this.pred1 = e;
				}, a.prototype.getPred1 = function() {
					return pred1;
				}, a.prototype.getPred2 = function() {
					return pred2;
				}, a.prototype.setNext = function(e) {
					this.next = e;
				}, a.prototype.getNext = function() {
					return next;
				}, a.prototype.setProcessed = function(e) {
					this.processed = e;
				}, a.prototype.isProcessed = function() {
					return processed;
				}, e.exports = a;
			},
			902: (e, t, r) => {
				function i(e) {
					if (!Array.isArray(e)) return Array.from(e);
					for (var t = 0, r = Array(e.length); t < e.length; t++) r[t] = e[t];
					return r;
				}
				h(i, "_toConsumableArray");
				var n = r(806), a = r(551).LinkedList, s = r(551).Matrix, o = r(551).SVD;
				function l() {}
				h(l, "ConstraintHandler"), l.handleConstraints = function(e) {
					var t = {};
					t.fixedNodeConstraint = e.constraints.fixedNodeConstraint, t.alignmentConstraint = e.constraints.alignmentConstraint, t.relativePlacementConstraint = e.constraints.relativePlacementConstraint;
					for (var r = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map(), u = [], d = [], p = e.getAllNodes(), f = 0, g = 0; g < p.length; g++) {
						var m = p[g];
						m.getChild() ?? (l.set(m.id, f++), u.push(m.getCenterX()), d.push(m.getCenterY()), r.set(m.id, m));
					}
					t.relativePlacementConstraint && t.relativePlacementConstraint.forEach(function(e) {
						e.gap || 0 == e.gap || (e.left ? e.gap = n.DEFAULT_EDGE_LENGTH + r.get(e.left).getWidth() / 2 + r.get(e.right).getWidth() / 2 : e.gap = n.DEFAULT_EDGE_LENGTH + r.get(e.top).getHeight() / 2 + r.get(e.bottom).getHeight() / 2);
					});
					var y = h(function(e, t) {
						return {
							x: e.x - t.x,
							y: e.y - t.y
						};
					}, "calculatePositionDiff"), v = h(function(e) {
						var t = 0, r = 0;
						return e.forEach(function(e) {
							t += u[l.get(e)], r += d[l.get(e)];
						}), {
							x: t / e.size,
							y: r / e.size
						};
					}, "calculateAvgPosition"), x = h(function(e, t, r, n, s) {
						function o(e, t) {
							var r = new Set(e), i = !0, n = !1, a = void 0;
							try {
								for (var s, o = t[Symbol.iterator](); !(i = (s = o.next()).done); i = !0) {
									var l = s.value;
									r.add(l);
								}
							} catch (e) {
								n = !0, a = e;
							} finally {
								try {
									!i && o.return && o.return();
								} finally {
									if (n) throw a;
								}
							}
							return r;
						}
						h(o, "setUnion");
						var p = /* @__PURE__ */ new Map();
						e.forEach(function(e, t) {
							p.set(t, 0);
						}), e.forEach(function(e, t) {
							e.forEach(function(e) {
								p.set(e.id, p.get(e.id) + 1);
							});
						});
						var f = /* @__PURE__ */ new Map(), g = /* @__PURE__ */ new Map(), m = new a();
						p.forEach(function(e, i) {
							0 == e ? (m.push(i), r || ("horizontal" == t ? f.set(i, l.has(i) ? u[l.get(i)] : n.get(i)) : f.set(i, l.has(i) ? d[l.get(i)] : n.get(i)))) : f.set(i, -Infinity), r && g.set(i, new Set([i]));
						}), r && s.forEach(function(e) {
							var i = [];
							if (e.forEach(function(e) {
								r.has(e) && i.push(e);
							}), i.length > 0) {
								var a = 0;
								i.forEach(function(e) {
									"horizontal" == t ? f.set(e, l.has(e) ? u[l.get(e)] : n.get(e)) : f.set(e, l.has(e) ? d[l.get(e)] : n.get(e)), a += f.get(e);
								}), a /= i.length, e.forEach(function(e) {
									r.has(e) || f.set(e, a);
								});
							} else {
								var s = 0;
								e.forEach(function(e) {
									"horizontal" == t ? s += l.has(e) ? u[l.get(e)] : n.get(e) : s += l.has(e) ? d[l.get(e)] : n.get(e);
								}), s /= e.length, e.forEach(function(e) {
									f.set(e, s);
								});
							}
						});
						for (var y = h(function() {
							var i = m.shift();
							e.get(i).forEach(function(e) {
								if (f.get(e.id) < f.get(i) + e.gap) if (r && r.has(e.id)) {
									var a = void 0;
									if (a = "horizontal" == t ? l.has(e.id) ? u[l.get(e.id)] : n.get(e.id) : l.has(e.id) ? d[l.get(e.id)] : n.get(e.id), f.set(e.id, a), a < f.get(i) + e.gap) {
										var s = f.get(i) + e.gap - a;
										g.get(i).forEach(function(e) {
											f.set(e, f.get(e) - s);
										});
									}
								} else f.set(e.id, f.get(i) + e.gap);
								p.set(e.id, p.get(e.id) - 1), 0 == p.get(e.id) && m.push(e.id), r && g.set(e.id, o(g.get(i), g.get(e.id)));
							});
						}, "_loop"); 0 != m.length;) y();
						if (r) {
							var v = /* @__PURE__ */ new Set();
							e.forEach(function(e, t) {
								0 == e.length && v.add(t);
							});
							var x = [];
							g.forEach(function(e, t) {
								if (v.has(t)) {
									var n = !1, a = !0, s = !1, o = void 0;
									try {
										for (var l, h = e[Symbol.iterator](); !(a = (l = h.next()).done); a = !0) {
											var u = l.value;
											r.has(u) && (n = !0);
										}
									} catch (e) {
										s = !0, o = e;
									} finally {
										try {
											!a && h.return && h.return();
										} finally {
											if (s) throw o;
										}
									}
									if (!n) {
										var d = !1, p = void 0;
										x.forEach(function(t, r) {
											t.has([].concat(i(e))[0]) && (d = !0, p = r);
										}), d ? e.forEach(function(e) {
											x[p].add(e);
										}) : x.push(new Set(e));
									}
								}
							}), x.forEach(function(e, r) {
								var i = Infinity, a = Infinity, s = -Infinity, o = -Infinity, h = !0, p = !1, g = void 0;
								try {
									for (var m, y = e[Symbol.iterator](); !(h = (m = y.next()).done); h = !0) {
										var v = m.value, x = void 0;
										x = "horizontal" == t ? l.has(v) ? u[l.get(v)] : n.get(v) : l.has(v) ? d[l.get(v)] : n.get(v);
										var b = f.get(v);
										x < i && (i = x), x > s && (s = x), b < a && (a = b), b > o && (o = b);
									}
								} catch (e) {
									p = !0, g = e;
								} finally {
									try {
										!h && y.return && y.return();
									} finally {
										if (p) throw g;
									}
								}
								var w = (i + s) / 2 - (a + o) / 2, k = !0, T = !1, _ = void 0;
								try {
									for (var E, C = e[Symbol.iterator](); !(k = (E = C.next()).done); k = !0) {
										var S = E.value;
										f.set(S, f.get(S) + w);
									}
								} catch (e) {
									T = !0, _ = e;
								} finally {
									try {
										!k && C.return && C.return();
									} finally {
										if (T) throw _;
									}
								}
							});
						}
						return f;
					}, "findAppropriatePositionForRelativePlacement"), b = h(function(e) {
						var t = 0, r = 0, i = 0, n = 0;
						if (e.forEach(function(e) {
							e.left ? u[l.get(e.left)] - u[l.get(e.right)] >= 0 ? t++ : r++ : d[l.get(e.top)] - d[l.get(e.bottom)] >= 0 ? i++ : n++;
						}), t > r && i > n) for (var a = 0; a < l.size; a++) u[a] = -1 * u[a], d[a] = -1 * d[a];
						else if (t > r) for (var s = 0; s < l.size; s++) u[s] = -1 * u[s];
						else if (i > n) for (var o = 0; o < l.size; o++) d[o] = -1 * d[o];
					}, "applyReflectionForRelativePlacement"), w = h(function(e) {
						var t = [], r = new a(), i = /* @__PURE__ */ new Set(), n = 0;
						return e.forEach(function(a, s) {
							if (!i.has(s)) {
								t[n] = [];
								var o = s;
								for (r.push(o), i.add(o), t[n].push(o); 0 != r.length;) o = r.shift(), e.get(o).forEach(function(e) {
									i.has(e.id) || (r.push(e.id), i.add(e.id), t[n].push(e.id));
								});
								n++;
							}
						}), t;
					}, "findComponents"), k = h(function(e) {
						var t = /* @__PURE__ */ new Map();
						return e.forEach(function(e, r) {
							t.set(r, []);
						}), e.forEach(function(e, r) {
							e.forEach(function(e) {
								t.get(r).push(e), t.get(e.id).push({
									id: r,
									gap: e.gap,
									direction: e.direction
								});
							});
						}), t;
					}, "dagToUndirected"), T = h(function(e) {
						var t = /* @__PURE__ */ new Map();
						return e.forEach(function(e, r) {
							t.set(r, []);
						}), e.forEach(function(e, r) {
							e.forEach(function(e) {
								t.get(e.id).push({
									id: r,
									gap: e.gap,
									direction: e.direction
								});
							});
						}), t;
					}, "dagToReversed"), _ = [], E = [], C = !1, S = !1, A = /* @__PURE__ */ new Set(), L = /* @__PURE__ */ new Map(), R = /* @__PURE__ */ new Map(), N = [];
					if (t.fixedNodeConstraint && t.fixedNodeConstraint.forEach(function(e) {
						A.add(e.nodeId);
					}), t.relativePlacementConstraint && (t.relativePlacementConstraint.forEach(function(e) {
						e.left ? (L.has(e.left) ? L.get(e.left).push({
							id: e.right,
							gap: e.gap,
							direction: "horizontal"
						}) : L.set(e.left, [{
							id: e.right,
							gap: e.gap,
							direction: "horizontal"
						}]), L.has(e.right) || L.set(e.right, [])) : (L.has(e.top) ? L.get(e.top).push({
							id: e.bottom,
							gap: e.gap,
							direction: "vertical"
						}) : L.set(e.top, [{
							id: e.bottom,
							gap: e.gap,
							direction: "vertical"
						}]), L.has(e.bottom) || L.set(e.bottom, []));
					}), N = w(R = k(L))), n.TRANSFORM_ON_CONSTRAINT_HANDLING) {
						if (t.fixedNodeConstraint && t.fixedNodeConstraint.length > 1) t.fixedNodeConstraint.forEach(function(e, t) {
							_[t] = [e.position.x, e.position.y], E[t] = [u[l.get(e.nodeId)], d[l.get(e.nodeId)]];
						}), C = !0;
						else if (t.alignmentConstraint) (function() {
							var e = 0;
							if (t.alignmentConstraint.vertical) {
								for (var r = t.alignmentConstraint.vertical, n = h(function(t) {
									var n = /* @__PURE__ */ new Set();
									r[t].forEach(function(e) {
										n.add(e);
									});
									var a = new Set([].concat(i(n)).filter(function(e) {
										return A.has(e);
									})), s = void 0;
									s = a.size > 0 ? u[l.get(a.values().next().value)] : v(n).x, r[t].forEach(function(t) {
										_[e] = [s, d[l.get(t)]], E[e] = [u[l.get(t)], d[l.get(t)]], e++;
									});
								}, "_loop2"), a = 0; a < r.length; a++) n(a);
								C = !0;
							}
							if (t.alignmentConstraint.horizontal) {
								for (var s = t.alignmentConstraint.horizontal, o = h(function(t) {
									var r = /* @__PURE__ */ new Set();
									s[t].forEach(function(e) {
										r.add(e);
									});
									var n = new Set([].concat(i(r)).filter(function(e) {
										return A.has(e);
									})), a = void 0;
									a = n.size > 0 ? u[l.get(n.values().next().value)] : v(r).y, s[t].forEach(function(t) {
										_[e] = [u[l.get(t)], a], E[e] = [u[l.get(t)], d[l.get(t)]], e++;
									});
								}, "_loop3"), p = 0; p < s.length; p++) o(p);
								C = !0;
							}
							t.relativePlacementConstraint && (S = !0);
						})();
						else if (t.relativePlacementConstraint) {
							for (var I = 0, M = 0, D = 0; D < N.length; D++) N[D].length > I && (I = N[D].length, M = D);
							if (I < R.size / 2) b(t.relativePlacementConstraint), C = !1, S = !1;
							else {
								var O = /* @__PURE__ */ new Map(), $ = /* @__PURE__ */ new Map(), P = [];
								N[M].forEach(function(e) {
									L.get(e).forEach(function(t) {
										"horizontal" == t.direction ? (O.has(e) ? O.get(e).push(t) : O.set(e, [t]), O.has(t.id) || O.set(t.id, []), P.push({
											left: e,
											right: t.id
										})) : ($.has(e) ? $.get(e).push(t) : $.set(e, [t]), $.has(t.id) || $.set(t.id, []), P.push({
											top: e,
											bottom: t.id
										}));
									});
								}), b(P), S = !1;
								var B = x(O, "horizontal"), F = x($, "vertical");
								N[M].forEach(function(e, t) {
									E[t] = [u[l.get(e)], d[l.get(e)]], _[t] = [], B.has(e) ? _[t][0] = B.get(e) : _[t][0] = u[l.get(e)], F.has(e) ? _[t][1] = F.get(e) : _[t][1] = d[l.get(e)];
								}), C = !0;
							}
						}
						if (C) {
							for (var z = void 0, U = s.transpose(_), G = s.transpose(E), q = 0; q < U.length; q++) U[q] = s.multGamma(U[q]), G[q] = s.multGamma(G[q]);
							var j = s.multMat(U, s.transpose(G)), W = o.svd(j);
							z = s.multMat(W.V, s.transpose(W.U));
							for (var Y = 0; Y < l.size; Y++) {
								var V = [u[Y], d[Y]], H = [z[0][0], z[1][0]], X = [z[0][1], z[1][1]];
								u[Y] = s.dotProduct(V, H), d[Y] = s.dotProduct(V, X);
							}
							S && b(t.relativePlacementConstraint);
						}
					}
					if (n.ENFORCE_CONSTRAINTS) {
						if (t.fixedNodeConstraint && t.fixedNodeConstraint.length > 0) {
							var K = {
								x: 0,
								y: 0
							};
							t.fixedNodeConstraint.forEach(function(e, t) {
								var r = {
									x: u[l.get(e.nodeId)],
									y: d[l.get(e.nodeId)]
								}, i = y(e.position, r);
								K.x += i.x, K.y += i.y;
							}), K.x /= t.fixedNodeConstraint.length, K.y /= t.fixedNodeConstraint.length, u.forEach(function(e, t) {
								u[t] += K.x;
							}), d.forEach(function(e, t) {
								d[t] += K.y;
							}), t.fixedNodeConstraint.forEach(function(e) {
								u[l.get(e.nodeId)] = e.position.x, d[l.get(e.nodeId)] = e.position.y;
							});
						}
						if (t.alignmentConstraint) {
							if (t.alignmentConstraint.vertical) for (var Z = t.alignmentConstraint.vertical, Q = h(function(e) {
								var t = /* @__PURE__ */ new Set();
								Z[e].forEach(function(e) {
									t.add(e);
								});
								var r = new Set([].concat(i(t)).filter(function(e) {
									return A.has(e);
								})), n = void 0;
								n = r.size > 0 ? u[l.get(r.values().next().value)] : v(t).x, t.forEach(function(e) {
									A.has(e) || (u[l.get(e)] = n);
								});
							}, "_loop4"), J = 0; J < Z.length; J++) Q(J);
							if (t.alignmentConstraint.horizontal) for (var ee = t.alignmentConstraint.horizontal, et = h(function(e) {
								var t = /* @__PURE__ */ new Set();
								ee[e].forEach(function(e) {
									t.add(e);
								});
								var r = new Set([].concat(i(t)).filter(function(e) {
									return A.has(e);
								})), n = void 0;
								n = r.size > 0 ? d[l.get(r.values().next().value)] : v(t).y, t.forEach(function(e) {
									A.has(e) || (d[l.get(e)] = n);
								});
							}, "_loop5"), er = 0; er < ee.length; er++) et(er);
						}
						t.relativePlacementConstraint && function() {
							var e = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Set(), p = /* @__PURE__ */ new Set();
							if (A.forEach(function(e) {
								o.add(e), p.add(e);
							}), t.alignmentConstraint) {
								if (t.alignmentConstraint.vertical) for (var f = t.alignmentConstraint.vertical, g = h(function(t) {
									i.set("dummy" + t, []), f[t].forEach(function(r) {
										e.set(r, "dummy" + t), i.get("dummy" + t).push(r), A.has(r) && o.add("dummy" + t);
									}), a.set("dummy" + t, u[l.get(f[t][0])]);
								}, "_loop6"), m = 0; m < f.length; m++) g(m);
								if (t.alignmentConstraint.horizontal) for (var y = t.alignmentConstraint.horizontal, v = h(function(e) {
									n.set("dummy" + e, []), y[e].forEach(function(t) {
										r.set(t, "dummy" + e), n.get("dummy" + e).push(t), A.has(t) && p.add("dummy" + e);
									}), s.set("dummy" + e, d[l.get(y[e][0])]);
								}, "_loop7"), b = 0; b < y.length; b++) v(b);
							}
							var _ = /* @__PURE__ */ new Map(), E = /* @__PURE__ */ new Map(), C = h(function(t) {
								L.get(t).forEach(function(i) {
									var n = void 0, a = void 0;
									"horizontal" == i.direction ? (n = e.get(t) ? e.get(t) : t, a = e.get(i.id) ? {
										id: e.get(i.id),
										gap: i.gap,
										direction: i.direction
									} : i, _.has(n) ? _.get(n).push(a) : _.set(n, [a]), _.has(a.id) || _.set(a.id, [])) : (n = r.get(t) ? r.get(t) : t, a = r.get(i.id) ? {
										id: r.get(i.id),
										gap: i.gap,
										direction: i.direction
									} : i, E.has(n) ? E.get(n).push(a) : E.set(n, [a]), E.has(a.id) || E.set(a.id, []));
								});
							}, "_loop8"), S = !0, R = !1, N = void 0;
							try {
								for (var I, M = L.keys()[Symbol.iterator](); !(S = (I = M.next()).done); S = !0) {
									var D = I.value;
									C(D);
								}
							} catch (e) {
								R = !0, N = e;
							} finally {
								try {
									!S && M.return && M.return();
								} finally {
									if (R) throw N;
								}
							}
							var O = k(_), $ = k(E), P = w(O), B = w($), F = T(_), z = T(E), U = [], G = [];
							P.forEach(function(e, t) {
								U[t] = [], e.forEach(function(e) {
									0 == F.get(e).length && U[t].push(e);
								});
							}), B.forEach(function(e, t) {
								G[t] = [], e.forEach(function(e) {
									0 == z.get(e).length && G[t].push(e);
								});
							});
							var q = x(_, "horizontal", o, a, U), j = x(E, "vertical", p, s, G), W = h(function(e) {
								i.get(e) ? i.get(e).forEach(function(t) {
									u[l.get(t)] = q.get(e);
								}) : u[l.get(e)] = q.get(e);
							}, "_loop9"), Y = !0, V = !1, H = void 0;
							try {
								for (var X, K = q.keys()[Symbol.iterator](); !(Y = (X = K.next()).done); Y = !0) {
									var Z = X.value;
									W(Z);
								}
							} catch (e) {
								V = !0, H = e;
							} finally {
								try {
									!Y && K.return && K.return();
								} finally {
									if (V) throw H;
								}
							}
							var Q = h(function(e) {
								n.get(e) ? n.get(e).forEach(function(t) {
									d[l.get(t)] = j.get(e);
								}) : d[l.get(e)] = j.get(e);
							}, "_loop10"), J = !0, ee = !1, et = void 0;
							try {
								for (var er, ei = j.keys()[Symbol.iterator](); !(J = (er = ei.next()).done); J = !0) {
									var Z = er.value;
									Q(Z);
								}
							} catch (e) {
								ee = !0, et = e;
							} finally {
								try {
									!J && ei.return && ei.return();
								} finally {
									if (ee) throw et;
								}
							}
						}();
					}
					for (var ei = 0; ei < p.length; ei++) {
						var en = p[ei];
						en.getChild() ?? en.setCenter(u[l.get(en.id)], d[l.get(en.id)]);
					}
				}, e.exports = l;
			},
			551: (t) => {
				t.exports = e;
			}
		}, r = {};
		function i(e) {
			var n = r[e];
			if (void 0 !== n) return n.exports;
			var a = r[e] = { exports: {} };
			return t[e](a, a.exports, i), a.exports;
		}
		return h(i, "__webpack_require__"), i(45);
	});
}), X5 = u((e, t) => {
	h(function(r, i) {
		"object" == typeof e && "object" == typeof t ? t.exports = i(X4()) : "function" == typeof define && define.amd ? define(["cose-base"], i) : "object" == typeof e ? e.cytoscapeFcose = i(X4()) : r.cytoscapeFcose = i(r.coseBase);
	}, "webpackUniversalModuleDefinition")(e, function(e) {
		var t = {
			658: (e) => {
				e.exports = null != Object.assign ? Object.assign.bind(Object) : function(e) {
					for (var t = arguments.length, r = Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++) r[i - 1] = arguments[i];
					return r.forEach(function(t) {
						Object.keys(t).forEach(function(r) {
							return e[r] = t[r];
						});
					}), e;
				};
			},
			548: (e, t, r) => {
				var i = function() {
					function e(e, t) {
						var r = [], i = !0, n = !1, a = void 0;
						try {
							for (var s, o = e[Symbol.iterator](); !(i = (s = o.next()).done) && (r.push(s.value), !(t && r.length === t)); i = !0);
						} catch (e) {
							n = !0, a = e;
						} finally {
							try {
								!i && o.return && o.return();
							} finally {
								if (n) throw a;
							}
						}
						return r;
					}
					return h(e, "sliceIterator"), function(t, r) {
						if (Array.isArray(t)) return t;
						if (Symbol.iterator in Object(t)) return e(t, r);
						throw TypeError("Invalid attempt to destructure non-iterable instance");
					};
				}(), n = r(140).layoutBase.LinkedList, a = {};
				a.getTopMostNodes = function(e) {
					for (var t = {}, r = 0; r < e.length; r++) t[e[r].id()] = !0;
					return e.filter(function(e, r) {
						"number" == typeof e && (e = r);
						for (var i = e.parent()[0]; null != i;) {
							if (t[i.id()]) return !1;
							i = i.parent()[0];
						}
						return !0;
					});
				}, a.connectComponents = function(e, t, r, i) {
					var a = new n(), s = /* @__PURE__ */ new Set(), o = [], l = void 0, u = void 0, d = void 0, p = !1, f = 1, g = [], m = [], y = h(function() {
						var i = e.collection();
						m.push(i);
						var n = r[0], y = e.collection();
						y.merge(n).merge(n.descendants().intersection(t)), o.push(n), y.forEach(function(e) {
							a.push(e), s.add(e), i.merge(e);
						});
						for (var v = h(function() {
							n = a.shift();
							var h = e.collection();
							n.neighborhood().nodes().forEach(function(e) {
								t.intersection(n.edgesWith(e)).length > 0 && h.merge(e);
							});
							for (var u = 0; u < h.length; u++) {
								var d = h[u];
								null == (l = r.intersection(d.union(d.ancestors()))) || s.has(l[0]) || l.union(l.descendants()).forEach(function(e) {
									a.push(e), s.add(e), i.merge(e), r.has(e) && o.push(e);
								});
							}
						}, "_loop2"); 0 != a.length;) v();
						if (i.forEach(function(e) {
							t.intersection(e.connectedEdges()).forEach(function(e) {
								i.has(e.source()) && i.has(e.target()) && i.merge(e);
							});
						}), o.length == r.length && (p = !0), !p || p && f > 1) {
							d = (u = o[0]).connectedEdges().length, o.forEach(function(e) {
								e.connectedEdges().length < d && (d = e.connectedEdges().length, u = e);
							}), g.push(u.id());
							var x = e.collection();
							x.merge(o[0]), o.forEach(function(e) {
								x.merge(e);
							}), o = [], r = r.difference(x), f++;
						}
					}, "_loop");
					do
						y();
					while (!p);
					return i && g.length > 0 && i.set("dummy" + (i.size + 1), g), m;
				}, a.relocateComponent = function(e, t, r) {
					if (!r.fixedNodeConstraint) {
						var n = Infinity, a = -Infinity, s = Infinity, o = -Infinity;
						if ("draft" == r.quality) {
							var l = !0, h = !1, u = void 0;
							try {
								for (var d, p = t.nodeIndexes[Symbol.iterator](); !(l = (d = p.next()).done); l = !0) {
									var f = d.value, g = i(f, 2), m = g[0], y = g[1], v = r.cy.getElementById(m);
									if (v) {
										var x = v.boundingBox(), b = t.xCoords[y] - x.w / 2, w = t.xCoords[y] + x.w / 2, k = t.yCoords[y] - x.h / 2, T = t.yCoords[y] + x.h / 2;
										b < n && (n = b), w > a && (a = w), k < s && (s = k), T > o && (o = T);
									}
								}
							} catch (e) {
								h = !0, u = e;
							} finally {
								try {
									!l && p.return && p.return();
								} finally {
									if (h) throw u;
								}
							}
							var _ = e.x - (a + n) / 2, E = e.y - (o + s) / 2;
							t.xCoords = t.xCoords.map(function(e) {
								return e + _;
							}), t.yCoords = t.yCoords.map(function(e) {
								return e + E;
							});
						} else {
							Object.keys(t).forEach(function(e) {
								var r = t[e], i = r.getRect().x, l = r.getRect().x + r.getRect().width, h = r.getRect().y, u = r.getRect().y + r.getRect().height;
								i < n && (n = i), l > a && (a = l), h < s && (s = h), u > o && (o = u);
							});
							var C = e.x - (a + n) / 2, S = e.y - (o + s) / 2;
							Object.keys(t).forEach(function(e) {
								var r = t[e];
								r.setCenter(r.getCenterX() + C, r.getCenterY() + S);
							});
						}
					}
				}, a.calcBoundingBox = function(e, t, r, i) {
					for (var n = Number.MAX_SAFE_INTEGER, a = Number.MIN_SAFE_INTEGER, s = Number.MAX_SAFE_INTEGER, o = Number.MIN_SAFE_INTEGER, l = void 0, h = void 0, u = void 0, d = void 0, p = e.descendants().not(":parent"), f = p.length, g = 0; g < f; g++) {
						var m = p[g];
						l = t[i.get(m.id())] - m.width() / 2, h = t[i.get(m.id())] + m.width() / 2, u = r[i.get(m.id())] - m.height() / 2, d = r[i.get(m.id())] + m.height() / 2, n > l && (n = l), a < h && (a = h), s > u && (s = u), o < d && (o = d);
					}
					var y = {};
					return y.topLeftX = n, y.topLeftY = s, y.width = a - n, y.height = o - s, y;
				}, a.calcParentsWithoutChildren = function(e, t) {
					var r = e.collection();
					return t.nodes(":parent").forEach(function(e) {
						var t = !1;
						e.children().forEach(function(e) {
							"none" != e.css("display") && (t = !0);
						}), t || r.merge(e);
					}), r;
				}, e.exports = a;
			},
			816: (e, t, r) => {
				var i = r(548), n = r(140).CoSELayout, a = r(140).CoSENode, s = r(140).layoutBase.PointD, o = r(140).layoutBase.DimensionD, l = r(140).layoutBase.LayoutConstants, u = r(140).layoutBase.FDLayoutConstants, d = r(140).CoSEConstants;
				e.exports = { coseLayout: h(function(e, t) {
					var r = e.cy, p = e.eles, f = p.nodes(), g = p.edges(), m = void 0, y = void 0, v = void 0, x = {};
					e.randomize && (m = t.nodeIndexes, y = t.xCoords, v = t.yCoords);
					var b = h(function(e) {
						return "function" == typeof e;
					}, "isFn"), w = h(function(e, t) {
						return b(e) ? e(t) : e;
					}, "optFn"), k = i.calcParentsWithoutChildren(r, p), T = h(function e(t, r, n, l) {
						for (var h = r.length, u = 0; u < h; u++) {
							var d = r[u], p = null;
							0 == d.intersection(k).length && (p = d.children());
							var f = void 0, g = d.layoutDimensions({ nodeDimensionsIncludeLabels: l.nodeDimensionsIncludeLabels });
							if (null != d.outerWidth() && null != d.outerHeight()) if (l.randomize) if (d.isParent()) {
								var b = i.calcBoundingBox(d, y, v, m);
								f = 0 == d.intersection(k).length ? t.add(new a(n.graphManager, new s(b.topLeftX, b.topLeftY), new o(b.width, b.height))) : t.add(new a(n.graphManager, new s(b.topLeftX, b.topLeftY), new o(parseFloat(g.w), parseFloat(g.h))));
							} else f = t.add(new a(n.graphManager, new s(y[m.get(d.id())] - g.w / 2, v[m.get(d.id())] - g.h / 2), new o(parseFloat(g.w), parseFloat(g.h))));
							else f = t.add(new a(n.graphManager, new s(d.position("x") - g.w / 2, d.position("y") - g.h / 2), new o(parseFloat(g.w), parseFloat(g.h))));
							else f = t.add(new a(this.graphManager));
							(f.id = d.data("id"), f.nodeRepulsion = w(l.nodeRepulsion, d), f.paddingLeft = parseInt(d.css("padding")), f.paddingTop = parseInt(d.css("padding")), f.paddingRight = parseInt(d.css("padding")), f.paddingBottom = parseInt(d.css("padding")), l.nodeDimensionsIncludeLabels && (f.labelWidth = d.boundingBox({
								includeLabels: !0,
								includeNodes: !1,
								includeOverlays: !1
							}).w, f.labelHeight = d.boundingBox({
								includeLabels: !0,
								includeNodes: !1,
								includeOverlays: !1
							}).h, f.labelPosVertical = d.css("text-valign"), f.labelPosHorizontal = d.css("text-halign")), x[d.data("id")] = f, isNaN(f.rect.x) && (f.rect.x = 0), isNaN(f.rect.y) && (f.rect.y = 0), null != p && p.length > 0) && e(n.getGraphManager().add(n.newGraph(), f), p, n, l);
						}
					}, "processChildrenList"), _ = h(function(t, r, i) {
						for (var n = 0, a = 0, s = 0; s < i.length; s++) {
							var o = i[s], l = x[o.data("source")], h = x[o.data("target")];
							if (l && h && l !== h && 0 == l.getEdgesBetween(h).length) {
								var p = r.add(t.newEdge(), l, h);
								p.id = o.id(), p.idealLength = w(e.idealEdgeLength, o), p.edgeElasticity = w(e.edgeElasticity, o), n += p.idealLength, a++;
							}
						}
						null != e.idealEdgeLength && (a > 0 ? d.DEFAULT_EDGE_LENGTH = u.DEFAULT_EDGE_LENGTH = n / a : b(e.idealEdgeLength) ? d.DEFAULT_EDGE_LENGTH = u.DEFAULT_EDGE_LENGTH = 50 : d.DEFAULT_EDGE_LENGTH = u.DEFAULT_EDGE_LENGTH = e.idealEdgeLength, d.MIN_REPULSION_DIST = u.MIN_REPULSION_DIST = u.DEFAULT_EDGE_LENGTH / 10, d.DEFAULT_RADIAL_SEPARATION = u.DEFAULT_EDGE_LENGTH);
					}, "processEdges"), E = h(function(e, t) {
						t.fixedNodeConstraint && (e.constraints.fixedNodeConstraint = t.fixedNodeConstraint), t.alignmentConstraint && (e.constraints.alignmentConstraint = t.alignmentConstraint), t.relativePlacementConstraint && (e.constraints.relativePlacementConstraint = t.relativePlacementConstraint);
					}, "processConstraints");
					null != e.nestingFactor && (d.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = u.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = e.nestingFactor), null != e.gravity && (d.DEFAULT_GRAVITY_STRENGTH = u.DEFAULT_GRAVITY_STRENGTH = e.gravity), null != e.numIter && (d.MAX_ITERATIONS = u.MAX_ITERATIONS = e.numIter), null != e.gravityRange && (d.DEFAULT_GRAVITY_RANGE_FACTOR = u.DEFAULT_GRAVITY_RANGE_FACTOR = e.gravityRange), null != e.gravityCompound && (d.DEFAULT_COMPOUND_GRAVITY_STRENGTH = u.DEFAULT_COMPOUND_GRAVITY_STRENGTH = e.gravityCompound), null != e.gravityRangeCompound && (d.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = u.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = e.gravityRangeCompound), null != e.initialEnergyOnIncremental && (d.DEFAULT_COOLING_FACTOR_INCREMENTAL = u.DEFAULT_COOLING_FACTOR_INCREMENTAL = e.initialEnergyOnIncremental), null != e.tilingCompareBy && (d.TILING_COMPARE_BY = e.tilingCompareBy), "proof" == e.quality ? l.QUALITY = 2 : l.QUALITY = 0, d.NODE_DIMENSIONS_INCLUDE_LABELS = u.NODE_DIMENSIONS_INCLUDE_LABELS = l.NODE_DIMENSIONS_INCLUDE_LABELS = e.nodeDimensionsIncludeLabels, d.DEFAULT_INCREMENTAL = u.DEFAULT_INCREMENTAL = l.DEFAULT_INCREMENTAL = !e.randomize, d.ANIMATE = u.ANIMATE = l.ANIMATE = e.animate, d.TILE = e.tile, d.TILING_PADDING_VERTICAL = "function" == typeof e.tilingPaddingVertical ? e.tilingPaddingVertical.call() : e.tilingPaddingVertical, d.TILING_PADDING_HORIZONTAL = "function" == typeof e.tilingPaddingHorizontal ? e.tilingPaddingHorizontal.call() : e.tilingPaddingHorizontal, d.DEFAULT_INCREMENTAL = u.DEFAULT_INCREMENTAL = l.DEFAULT_INCREMENTAL = !0, d.PURE_INCREMENTAL = !e.randomize, l.DEFAULT_UNIFORM_LEAF_NODE_SIZES = e.uniformNodeDimensions, "transformed" == e.step && (d.TRANSFORM_ON_CONSTRAINT_HANDLING = !0, d.ENFORCE_CONSTRAINTS = !1, d.APPLY_LAYOUT = !1), "enforced" == e.step && (d.TRANSFORM_ON_CONSTRAINT_HANDLING = !1, d.ENFORCE_CONSTRAINTS = !0, d.APPLY_LAYOUT = !1), "cose" == e.step && (d.TRANSFORM_ON_CONSTRAINT_HANDLING = !1, d.ENFORCE_CONSTRAINTS = !1, d.APPLY_LAYOUT = !0), "all" == e.step && (e.randomize ? d.TRANSFORM_ON_CONSTRAINT_HANDLING = !0 : d.TRANSFORM_ON_CONSTRAINT_HANDLING = !1, d.ENFORCE_CONSTRAINTS = !0, d.APPLY_LAYOUT = !0), e.fixedNodeConstraint || e.alignmentConstraint || e.relativePlacementConstraint ? d.TREE_REDUCTION_ON_INCREMENTAL = !1 : d.TREE_REDUCTION_ON_INCREMENTAL = !0;
					var C = new n(), S = C.newGraphManager();
					return T(S.addRoot(), i.getTopMostNodes(f), C, e), _(C, S, g), E(C, e), C.runLayout(), x;
				}, "coseLayout") };
			},
			212: (e, t, r) => {
				var i = function() {
					function e(e, t) {
						for (var r = 0; r < t.length; r++) {
							var i = t[r];
							i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
						}
					}
					return h(e, "defineProperties"), function(t, r, i) {
						return r && e(t.prototype, r), i && e(t, i), t;
					};
				}();
				function n(e, t) {
					if (!(e instanceof t)) throw TypeError("Cannot call a class as a function");
				}
				h(n, "_classCallCheck");
				var a = r(658), s = r(548), o = r(657).spectralLayout, l = r(816).coseLayout, u = Object.freeze({
					quality: "default",
					randomize: !0,
					animate: !0,
					animationDuration: 1e3,
					animationEasing: void 0,
					fit: !0,
					padding: 30,
					nodeDimensionsIncludeLabels: !1,
					uniformNodeDimensions: !1,
					packComponents: !0,
					step: "all",
					samplingType: !0,
					sampleSize: 25,
					nodeSeparation: 75,
					piTol: 1e-7,
					nodeRepulsion: h(function(e) {
						return 4500;
					}, "nodeRepulsion"),
					idealEdgeLength: h(function(e) {
						return 50;
					}, "idealEdgeLength"),
					edgeElasticity: h(function(e) {
						return .45;
					}, "edgeElasticity"),
					nestingFactor: .1,
					gravity: .25,
					numIter: 2500,
					tile: !0,
					tilingCompareBy: void 0,
					tilingPaddingVertical: 10,
					tilingPaddingHorizontal: 10,
					gravityRangeCompound: 1.5,
					gravityCompound: 1,
					gravityRange: 3.8,
					initialEnergyOnIncremental: .3,
					fixedNodeConstraint: void 0,
					alignmentConstraint: void 0,
					relativePlacementConstraint: void 0,
					ready: h(function() {}, "ready"),
					stop: h(function() {}, "stop")
				});
				e.exports = function() {
					function e(t) {
						n(this, e), this.options = a({}, u, t);
					}
					return h(e, "Layout"), i(e, [{
						key: "run",
						value: h(function() {
							var e = this.options, t = e.cy, r = e.eles, i = [], n = [], a = void 0, u = [];
							e.fixedNodeConstraint && (!Array.isArray(e.fixedNodeConstraint) || 0 == e.fixedNodeConstraint.length) && (e.fixedNodeConstraint = void 0), e.alignmentConstraint && (e.alignmentConstraint.vertical && (!Array.isArray(e.alignmentConstraint.vertical) || 0 == e.alignmentConstraint.vertical.length) && (e.alignmentConstraint.vertical = void 0), e.alignmentConstraint.horizontal && (!Array.isArray(e.alignmentConstraint.horizontal) || 0 == e.alignmentConstraint.horizontal.length) && (e.alignmentConstraint.horizontal = void 0)), e.relativePlacementConstraint && (!Array.isArray(e.relativePlacementConstraint) || 0 == e.relativePlacementConstraint.length) && (e.relativePlacementConstraint = void 0), (e.fixedNodeConstraint || e.alignmentConstraint || e.relativePlacementConstraint) && (e.tile = !1, e.packComponents = !1);
							var d = void 0, p = !1;
							if (t.layoutUtilities && e.packComponents && ((d = t.layoutUtilities("get")) || (d = t.layoutUtilities()), p = !0), r.nodes().length > 0) if (p) {
								var f = s.getTopMostNodes(e.eles.nodes());
								if ((a = s.connectComponents(t, e.eles, f)).forEach(function(e) {
									var t = e.boundingBox();
									u.push({
										x: t.x1 + t.w / 2,
										y: t.y1 + t.h / 2
									});
								}), e.randomize && a.forEach(function(t) {
									e.eles = t, i.push(o(e));
								}), "default" == e.quality || "proof" == e.quality) {
									var g = t.collection();
									if (e.tile) {
										var m = /* @__PURE__ */ new Map(), y = 0, v = {
											nodeIndexes: m,
											xCoords: [],
											yCoords: []
										}, x = [];
										if (a.forEach(function(e, t) {
											0 == e.edges().length && (e.nodes().forEach(function(t, r) {
												g.merge(e.nodes()[r]), t.isParent() || (v.nodeIndexes.set(e.nodes()[r].id(), y++), v.xCoords.push(e.nodes()[0].position().x), v.yCoords.push(e.nodes()[0].position().y));
											}), x.push(t));
										}), g.length > 1) {
											var b = g.boundingBox();
											u.push({
												x: b.x1 + b.w / 2,
												y: b.y1 + b.h / 2
											}), a.push(g), i.push(v);
											for (var w = x.length - 1; w >= 0; w--) a.splice(x[w], 1), i.splice(x[w], 1), u.splice(x[w], 1);
										}
									}
									a.forEach(function(t, r) {
										e.eles = t, n.push(l(e, i[r])), s.relocateComponent(u[r], n[r], e);
									});
								} else a.forEach(function(t, r) {
									s.relocateComponent(u[r], i[r], e);
								});
								var k = /* @__PURE__ */ new Set();
								if (a.length > 1) {
									var T = [], _ = r.filter(function(e) {
										return "none" == e.css("display");
									});
									a.forEach(function(t, r) {
										var a = void 0;
										if ("draft" == e.quality && (a = i[r].nodeIndexes), t.nodes().not(_).length > 0) {
											var o = {};
											o.edges = [], o.nodes = [];
											var l = void 0;
											t.nodes().not(_).forEach(function(t) {
												if ("draft" == e.quality) if (t.isParent()) {
													var h = s.calcBoundingBox(t, i[r].xCoords, i[r].yCoords, a);
													o.nodes.push({
														x: h.topLeftX,
														y: h.topLeftY,
														width: h.width,
														height: h.height
													});
												} else l = a.get(t.id()), o.nodes.push({
													x: i[r].xCoords[l] - t.boundingbox().w / 2,
													y: i[r].yCoords[l] - t.boundingbox().h / 2,
													width: t.boundingbox().w,
													height: t.boundingbox().h
												});
												else n[r][t.id()] && o.nodes.push({
													x: n[r][t.id()].getLeft(),
													y: n[r][t.id()].getTop(),
													width: n[r][t.id()].getWidth(),
													height: n[r][t.id()].getHeight()
												});
											}), t.edges().forEach(function(t) {
												var l = t.source(), h = t.target();
												if ("none" != l.css("display") && "none" != h.css("display")) if ("draft" == e.quality) {
													var u = a.get(l.id()), d = a.get(h.id()), p = [], f = [];
													if (l.isParent()) {
														var g = s.calcBoundingBox(l, i[r].xCoords, i[r].yCoords, a);
														p.push(g.topLeftX + g.width / 2), p.push(g.topLeftY + g.height / 2);
													} else p.push(i[r].xCoords[u]), p.push(i[r].yCoords[u]);
													if (h.isParent()) {
														var m = s.calcBoundingBox(h, i[r].xCoords, i[r].yCoords, a);
														f.push(m.topLeftX + m.width / 2), f.push(m.topLeftY + m.height / 2);
													} else f.push(i[r].xCoords[d]), f.push(i[r].yCoords[d]);
													o.edges.push({
														startX: p[0],
														startY: p[1],
														endX: f[0],
														endY: f[1]
													});
												} else n[r][l.id()] && n[r][h.id()] && o.edges.push({
													startX: n[r][l.id()].getCenterX(),
													startY: n[r][l.id()].getCenterY(),
													endX: n[r][h.id()].getCenterX(),
													endY: n[r][h.id()].getCenterY()
												});
											}), o.nodes.length > 0 && (T.push(o), k.add(r));
										}
									});
									var E = d.packComponents(T, e.randomize).shifts;
									if ("draft" == e.quality) i.forEach(function(e, t) {
										var r = e.xCoords.map(function(e) {
											return e + E[t].dx;
										}), i = e.yCoords.map(function(e) {
											return e + E[t].dy;
										});
										e.xCoords = r, e.yCoords = i;
									});
									else {
										var C = 0;
										k.forEach(function(e) {
											Object.keys(n[e]).forEach(function(t) {
												var r = n[e][t];
												r.setCenter(r.getCenterX() + E[C].dx, r.getCenterY() + E[C].dy);
											}), C++;
										});
									}
								}
							} else {
								var S = e.eles.boundingBox();
								if (u.push({
									x: S.x1 + S.w / 2,
									y: S.y1 + S.h / 2
								}), e.randomize) {
									var A = o(e);
									i.push(A);
								}
								"default" == e.quality || "proof" == e.quality ? (n.push(l(e, i[0])), s.relocateComponent(u[0], n[0], e)) : s.relocateComponent(u[0], i[0], e);
							}
							var L = h(function(t, r) {
								if ("default" == e.quality || "proof" == e.quality) {
									"number" == typeof t && (t = r);
									var a = void 0, s = void 0, o = t.data("id");
									return n.forEach(function(e) {
										o in e && (a = {
											x: e[o].getRect().getCenterX(),
											y: e[o].getRect().getCenterY()
										}, s = e[o]);
									}), e.nodeDimensionsIncludeLabels && (s.labelWidth && ("left" == s.labelPosHorizontal ? a.x += s.labelWidth / 2 : "right" == s.labelPosHorizontal && (a.x -= s.labelWidth / 2)), s.labelHeight && ("top" == s.labelPosVertical ? a.y += s.labelHeight / 2 : "bottom" == s.labelPosVertical && (a.y -= s.labelHeight / 2))), {
										x: (a ??= {
											x: t.position("x"),
											y: t.position("y")
										}).x,
										y: a.y
									};
								}
								var l = void 0;
								return i.forEach(function(e) {
									var r = e.nodeIndexes.get(t.id());
									null != r && (l = {
										x: e.xCoords[r],
										y: e.yCoords[r]
									});
								}), {
									x: (l ??= {
										x: t.position("x"),
										y: t.position("y")
									}).x,
									y: l.y
								};
							}, "getPositions");
							if ("default" == e.quality || "proof" == e.quality || e.randomize) {
								var R = s.calcParentsWithoutChildren(t, r), N = r.filter(function(e) {
									return "none" == e.css("display");
								});
								e.eles = r.not(N), r.nodes().not(":parent").not(N).layoutPositions(this, e, L), R.length > 0 && R.forEach(function(e) {
									e.position(L(e));
								});
							} else console.log("If randomize option is set to false, then quality option must be 'default' or 'proof'.");
						}, "run")
					}]), e;
				}();
			},
			657: (e, t, r) => {
				var i = r(548), n = r(140).layoutBase.Matrix, a = r(140).layoutBase.SVD;
				e.exports = { spectralLayout: h(function(e) {
					var t = e.cy, r = e.eles, s = r.nodes(), o = r.nodes(":parent"), l = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new Map(), d = /* @__PURE__ */ new Map(), p = [], f = [], g = [], m = [], y = [], v = [], x = [], b = [], w = void 0, k = e.piTol, T = e.samplingType, _ = e.nodeSeparation, E = void 0, C = h(function() {
						for (var e = 0, t = 0, r = !1; t < E;) {
							e = Math.floor(Math.random() * w), r = !1;
							for (var i = 0; i < t; i++) if (m[i] == e) {
								r = !0;
								break;
							}
							!r && (m[t] = e, t++);
						}
					}, "randomSampleCR"), S = h(function(e, t, r) {
						for (var i = [], n = 0, a = 0, s = 0, o = void 0, l = [], h = 0, d = 1, f = 0; f < w; f++) l[f] = 1e8;
						for (i[a] = e, l[e] = 0; a >= n;) {
							s = i[n++];
							for (var g = p[s], m = 0; m < g.length; m++) 1e8 == l[o = u.get(g[m])] && (l[o] = l[s] + 1, i[++a] = o);
							v[s][t] = l[s] * _;
						}
						if (r) {
							for (var x = 0; x < w; x++) v[x][t] < y[x] && (y[x] = v[x][t]);
							for (var b = 0; b < w; b++) y[b] > h && (h = y[b], d = b);
						}
						return d;
					}, "BFS"), A = h(function(e) {
						var t = void 0;
						if (e) {
							t = Math.floor(Math.random() * w);
							for (var r = 0; r < w; r++) y[r] = 1e8;
							for (var i = 0; i < E; i++) m[i] = t, t = S(t, i, e);
						} else {
							C();
							for (var n = 0; n < E; n++) S(m[n], n, e, !1);
						}
						for (var a = 0; a < w; a++) for (var s = 0; s < E; s++) v[a][s] *= v[a][s];
						for (var o = 0; o < E; o++) x[o] = [];
						for (var l = 0; l < E; l++) for (var h = 0; h < E; h++) x[l][h] = v[m[h]][l];
					}, "allBFS"), L = h(function() {
						for (var e = a.svd(x), t = e.S, r = e.U, i = e.V, s = t[0] * t[0] * t[0], o = [], l = 0; l < E; l++) {
							o[l] = [];
							for (var h = 0; h < E; h++) o[l][h] = 0, l == h && (o[l][h] = t[l] / (t[l] * t[l] + s / (t[l] * t[l])));
						}
						b = n.multMat(n.multMat(i, o), n.transpose(r));
					}, "sample"), R = h(function() {
						for (var e = void 0, t = void 0, r = [], i = [], a = [], s = [], o = 0; o < w; o++) r[o] = Math.random(), i[o] = Math.random();
						r = n.normalize(r), i = n.normalize(i);
						for (var l = 0, h = 1e-9, u = 1e-9, d = void 0;;) {
							l++;
							for (var p = 0; p < w; p++) a[p] = r[p];
							if (r = n.multGamma(n.multL(n.multGamma(a), v, b)), e = n.dotProduct(a, r), r = n.normalize(r), (d = Math.abs((h = n.dotProduct(a, r)) / u)) <= 1 + k && d >= 1) break;
							u = h;
						}
						for (var m = 0; m < w; m++) a[m] = r[m];
						for (l = 0, u = 1e-9;;) {
							l++;
							for (var y = 0; y < w; y++) s[y] = i[y];
							if (s = n.minusOp(s, n.multCons(a, n.dotProduct(a, s))), i = n.multGamma(n.multL(n.multGamma(s), v, b)), t = n.dotProduct(s, i), i = n.normalize(i), (d = Math.abs((h = n.dotProduct(s, i)) / u)) <= 1 + k && d >= 1) break;
							u = h;
						}
						for (var x = 0; x < w; x++) s[x] = i[x];
						f = n.multCons(a, Math.sqrt(Math.abs(e))), g = n.multCons(s, Math.sqrt(Math.abs(t)));
					}, "powerIteration");
					i.connectComponents(t, r, i.getTopMostNodes(s), l), o.forEach(function(e) {
						i.connectComponents(t, r, i.getTopMostNodes(e.descendants().intersection(r)), l);
					});
					for (var N = 0, I = 0; I < s.length; I++) s[I].isParent() || u.set(s[I].id(), N++);
					var M = !0, D = !1, O = void 0;
					try {
						for (var $, P = l.keys()[Symbol.iterator](); !(M = ($ = P.next()).done); M = !0) {
							var B = $.value;
							u.set(B, N++);
						}
					} catch (e) {
						D = !0, O = e;
					} finally {
						try {
							!M && P.return && P.return();
						} finally {
							if (D) throw O;
						}
					}
					for (var F = 0; F < u.size; F++) p[F] = [];
					o.forEach(function(e) {
						for (var t = e.children().intersection(r); 0 == t.nodes(":childless").length;) t = t.nodes()[0].children().intersection(r);
						var i = 0, n = t.nodes(":childless")[0].connectedEdges().length;
						t.nodes(":childless").forEach(function(e, t) {
							e.connectedEdges().length < n && (n = e.connectedEdges().length, i = t);
						}), d.set(e.id(), t.nodes(":childless")[i].id());
					}), s.forEach(function(e) {
						var t = void 0;
						t = e.isParent() ? u.get(d.get(e.id())) : u.get(e.id()), e.neighborhood().nodes().forEach(function(i) {
							r.intersection(e.edgesWith(i)).length > 0 && (i.isParent() ? p[t].push(d.get(i.id())) : p[t].push(i.id()));
						});
					});
					var z = h(function(e) {
						var r = u.get(e), i = void 0;
						l.get(e).forEach(function(n) {
							i = t.getElementById(n).isParent() ? d.get(n) : n, p[r].push(i), p[u.get(i)].push(e);
						});
					}, "_loop"), U = !0, G = !1, q = void 0;
					try {
						for (var j, W = l.keys()[Symbol.iterator](); !(U = (j = W.next()).done); U = !0) {
							var Y = j.value;
							z(Y);
						}
					} catch (e) {
						G = !0, q = e;
					} finally {
						try {
							!U && W.return && W.return();
						} finally {
							if (G) throw q;
						}
					}
					w = u.size;
					if (w > 2) {
						E = w < e.sampleSize ? w : e.sampleSize;
						for (var V = 0; V < w; V++) v[V] = [];
						for (var H = 0; H < E; H++) b[H] = [];
						return "draft" == e.quality || "all" == e.step ? (A(T), L(), R()) : u.forEach(function(e, r) {
							f.push(t.getElementById(r).position("x")), g.push(t.getElementById(r).position("y"));
						}), {
							nodeIndexes: u,
							xCoords: f,
							yCoords: g
						};
					}
					var X = u.keys(), K = t.getElementById(X.next().value), Z = K.position(), Q = K.outerWidth();
					if (f.push(Z.x), g.push(Z.y), 2 == w) {
						var J = t.getElementById(X.next().value).outerWidth();
						f.push(Z.x + Q / 2 + J / 2 + e.idealEdgeLength), g.push(Z.y);
					}
					return {
						nodeIndexes: u,
						xCoords: f,
						yCoords: g
					};
				}, "spectralLayout") };
			},
			579: (e, t, r) => {
				var i = r(212), n = h(function(e) {
					e && e("layout", "fcose", i);
				}, "register");
				"u" > typeof cytoscape && n(cytoscape), e.exports = n;
			},
			140: (t) => {
				t.exports = e;
			}
		}, r = {};
		function i(e) {
			var n = r[e];
			if (void 0 !== n) return n.exports;
			var a = r[e] = { exports: {} };
			return t[e](a, a.exports, i), a.exports;
		}
		return h(i, "__webpack_require__"), i(579);
	});
}), X3 = {
	L: "left",
	R: "right",
	T: "top",
	B: "bottom"
}, X6 = {
	L: h((e) => `${e},${e / 2} 0,${e} 0,0`, "L"),
	R: h((e) => `0,${e / 2} ${e},0 ${e},${e}`, "R"),
	T: h((e) => `0,0 ${e},0 ${e / 2},${e}`, "T"),
	B: h((e) => `${e / 2},0 ${e},${e} 0,${e}`, "B")
}, X7 = {
	L: h((e, t) => e - t + 2, "L"),
	R: h((e, t) => e - 2, "R"),
	T: h((e, t) => e - t + 2, "T"),
	B: h((e, t) => e - 2, "B")
}, X8 = h(function(e) {
	return Ke(e) ? "L" === e ? "R" : "L" : "T" === e ? "B" : "T";
}, "getOppositeArchitectureDirection"), X9 = h(function(e) {
	return "L" === e || "R" === e || "T" === e || "B" === e;
}, "isArchitectureDirection"), Ke = h(function(e) {
	return "L" === e || "R" === e;
}, "isArchitectureDirectionX"), Kt = h(function(e) {
	return "T" === e || "B" === e;
}, "isArchitectureDirectionY"), Kr = h(function(e, t) {
	let r = Ke(e) && Kt(t), i = Kt(e) && Ke(t);
	return r || i;
}, "isArchitectureDirectionXY"), Ki = h(function(e) {
	let t = e[0], r = e[1], i = Ke(t) && Kt(r), n = Kt(t) && Ke(r);
	return i || n;
}, "isArchitecturePairXY"), Kn = h(function(e) {
	return "LL" !== e && "RR" !== e && "TT" !== e && "BB" !== e;
}, "isValidArchitectureDirectionPair"), Ka = h(function(e, t) {
	let r = `${e}${t}`;
	return Kn(r) ? r : void 0;
}, "getArchitectureDirectionPair"), Ks = h(function([e, t], r) {
	let i = r[0], n = r[1];
	return Ke(i) ? Kt(n) ? [e + ("L" === i ? -1 : 1), t + ("T" === n ? 1 : -1)] : [e + ("L" === i ? -1 : 1), t] : Ke(n) ? [e + ("L" === n ? 1 : -1), t + ("T" === i ? 1 : -1)] : [e, t + ("T" === i ? 1 : -1)];
}, "shiftPositionByArchitectureDirectionPair"), Ko = h(function(e) {
	return "LT" === e || "TL" === e ? [1, 1] : "BL" === e || "LB" === e ? [1, -1] : "BR" === e || "RB" === e ? [-1, -1] : [-1, 1];
}, "getArchitectureDirectionXYFactors"), Kl = h(function(e, t) {
	return Kr(e, t) ? "bend" : Ke(e) ? "horizontal" : "vertical";
}, "getArchitectureDirectionAlignment"), Kc = h(function(e) {
	return "service" === e.type;
}, "isArchitectureService"), Kh = h(function(e) {
	return "junction" === e.type;
}, "isArchitectureJunction"), Ku = h((e) => e.data(), "edgeData"), Kd = h((e) => e.data(), "nodeData"), Kp = Ip.architecture, Kf = class {
	constructor() {
		this.nodes = {}, this.groups = {}, this.edges = [], this.registeredIds = {}, this.elements = {}, this.setAccTitle = Da, this.getAccTitle = Ds, this.setDiagramTitle = Dc, this.getDiagramTitle = Dh, this.getAccDescription = Dl, this.setAccDescription = Do, this.clear();
	}
	static {
		h(this, "ArchitectureDB");
	}
	clear() {
		this.nodes = {}, this.groups = {}, this.edges = [], this.registeredIds = {}, this.dataStructures = void 0, this.elements = {}, Dn();
	}
	addService({ id: e, icon: t, in: r, title: i, iconText: n }) {
		if (void 0 !== this.registeredIds[e]) throw Error(`The service id [${e}] is already in use by another ${this.registeredIds[e]}`);
		if (void 0 !== r) {
			if (e === r) throw Error(`The service [${e}] cannot be placed within itself`);
			if (void 0 === this.registeredIds[r]) throw Error(`The service [${e}]'s parent does not exist. Please make sure the parent is created before this service`);
			if ("node" === this.registeredIds[r]) throw Error(`The service [${e}]'s parent is not a group`);
		}
		this.registeredIds[e] = "node", this.nodes[e] = {
			id: e,
			type: "service",
			icon: t,
			iconText: n,
			title: i,
			edges: [],
			in: r
		};
	}
	getServices() {
		return Object.values(this.nodes).filter(Kc);
	}
	addJunction({ id: e, in: t }) {
		this.registeredIds[e] = "node", this.nodes[e] = {
			id: e,
			type: "junction",
			edges: [],
			in: t
		};
	}
	getJunctions() {
		return Object.values(this.nodes).filter(Kh);
	}
	getNodes() {
		return Object.values(this.nodes);
	}
	getNode(e) {
		return this.nodes[e] ?? null;
	}
	addGroup({ id: e, icon: t, in: r, title: i }) {
		if (this.registeredIds?.[e] !== void 0) throw Error(`The group id [${e}] is already in use by another ${this.registeredIds[e]}`);
		if (void 0 !== r) {
			if (e === r) throw Error(`The group [${e}] cannot be placed within itself`);
			if (this.registeredIds?.[r] === void 0) throw Error(`The group [${e}]'s parent does not exist. Please make sure the parent is created before this group`);
			if (this.registeredIds?.[r] === "node") throw Error(`The group [${e}]'s parent is not a group`);
		}
		this.registeredIds[e] = "group", this.groups[e] = {
			id: e,
			icon: t,
			title: i,
			in: r
		};
	}
	getGroups() {
		return Object.values(this.groups);
	}
	addEdge({ lhsId: e, rhsId: t, lhsDir: r, rhsDir: i, lhsInto: n, rhsInto: a, lhsGroup: s, rhsGroup: o, title: l }) {
		if (!X9(r)) throw Error(`Invalid direction given for left hand side of edge ${e}--${t}. Expected (L,R,T,B) got ${String(r)}`);
		if (!X9(i)) throw Error(`Invalid direction given for right hand side of edge ${e}--${t}. Expected (L,R,T,B) got ${String(i)}`);
		if (void 0 === this.nodes[e] && void 0 === this.groups[e]) throw Error(`The left-hand id [${e}] does not yet exist. Please create the service/group before declaring an edge to it.`);
		if (void 0 === this.nodes[t] && void 0 === this.groups[t]) throw Error(`The right-hand id [${t}] does not yet exist. Please create the service/group before declaring an edge to it.`);
		let h = this.nodes[e].in, u = this.nodes[t].in;
		if (s && h && u && h == u) throw Error(`The left-hand id [${e}] is modified to traverse the group boundary, but the edge does not pass through two groups.`);
		if (o && h && u && h == u) throw Error(`The right-hand id [${t}] is modified to traverse the group boundary, but the edge does not pass through two groups.`);
		this.edges.push({
			lhsId: e,
			lhsDir: r,
			lhsInto: n,
			lhsGroup: s,
			rhsId: t,
			rhsDir: i,
			rhsInto: a,
			rhsGroup: o,
			title: l
		}), this.nodes[e] && this.nodes[t] && (this.nodes[e].edges.push(this.edges[this.edges.length - 1]), this.nodes[t].edges.push(this.edges[this.edges.length - 1]));
	}
	getEdges() {
		return this.edges;
	}
	getDataStructures() {
		if (void 0 === this.dataStructures) {
			let e = {}, t = Object.entries(this.nodes).reduce((t, [r, i]) => (t[r] = i.edges.reduce((t, i) => {
				let n = this.getNode(i.lhsId)?.in, a = this.getNode(i.rhsId)?.in;
				if (n && a && n !== a) {
					let t = Kl(i.lhsDir, i.rhsDir);
					"bend" !== t && (e[n] ??= {}, e[n][a] = t, e[a] ??= {}, e[a][n] = t);
				}
				if (i.lhsId === r) {
					let e = Ka(i.lhsDir, i.rhsDir);
					e && (t[e] = i.rhsId);
				} else {
					let e = Ka(i.rhsDir, i.lhsDir);
					e && (t[e] = i.lhsId);
				}
				return t;
			}, {}), t), {}), r = Object.keys(t)[0], i = { [r]: 1 }, n = Object.keys(t).reduce((e, t) => t === r ? e : {
				...e,
				[t]: 1
			}, {}), a = h((e) => {
				let r = { [e]: [0, 0] }, a = [e];
				for (; a.length > 0;) {
					let e = a.shift();
					if (e) {
						i[e] = 1, delete n[e];
						let s = t[e], [o, l] = r[e];
						Object.entries(s).forEach(([e, t]) => {
							i[t] || (r[t] = Ks([o, l], e), a.push(t));
						});
					}
				}
				return r;
			}, "BFS"), s = [a(r)];
			for (; Object.keys(n).length > 0;) s.push(a(Object.keys(n)[0]));
			this.dataStructures = {
				adjList: t,
				spatialMaps: s,
				groupAlignments: e
			};
		}
		return this.dataStructures;
	}
	setElementForId(e, t) {
		this.elements[e] = t;
	}
	getElementById(e) {
		return this.elements[e];
	}
	getConfig() {
		return V5({
			...Kp,
			...IA().architecture
		});
	}
	getConfigField(e) {
		return this.getConfig()[e];
	}
}, Kg = h((e, t) => {
	w_(e, t), e.groups.map((e) => t.addGroup(e)), e.services.map((e) => t.addService({
		...e,
		type: "service"
	})), e.junctions.map((e) => t.addJunction({
		...e,
		type: "junction"
	})), e.edges.map((e) => t.addEdge(e));
}, "populateDb"), Km = {
	parser: { yy: void 0 },
	parse: h(async (e) => {
		let t = await wS("architecture", e);
		wQ.debug(t);
		let r = Km.parser?.yy;
		if (!(r instanceof Kf)) throw Error("parser.parser?.yy was not a ArchitectureDB. This is due to a bug within Mermaid, please report this issue at https://github.com/mermaid-js/mermaid/issues.");
		Kg(t, r);
	}, "parse")
}, Ky = h((e) => `
  .edge {
    stroke-width: ${e.archEdgeWidth};
    stroke: ${e.archEdgeColor};
    fill: none;
  }

  .arrow {
    fill: ${e.archEdgeArrowColor};
  }

  .node-bkg {
    fill: none;
    stroke: ${e.archGroupBorderColor};
    stroke-width: ${e.archGroupBorderWidth};
    stroke-dasharray: 8;
  }
  .node-icon-text {
    display: flex; 
    align-items: center;
  }
  
  .node-icon-text > div {
    color: #fff;
    margin: 1px;
    height: fit-content;
    text-align: center;
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
  }
`, "getStyles"), Kv = g(X5(), 1), Kx = h((e) => `<g><rect width="80" height="80" style="fill: #087ebf; stroke-width: 0px;"/>${e}</g>`, "wrapIcon"), Kb = {
	prefix: "mermaid-architecture",
	height: 80,
	width: 80,
	icons: {
		database: { body: Kx("<path id=\"b\" data-name=\"4\" d=\"m20,57.86c0,3.94,8.95,7.14,20,7.14s20-3.2,20-7.14\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><path id=\"c\" data-name=\"3\" d=\"m20,45.95c0,3.94,8.95,7.14,20,7.14s20-3.2,20-7.14\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><path id=\"d\" data-name=\"2\" d=\"m20,34.05c0,3.94,8.95,7.14,20,7.14s20-3.2,20-7.14\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><ellipse id=\"e\" data-name=\"1\" cx=\"40\" cy=\"22.14\" rx=\"20\" ry=\"7.14\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"20\" y1=\"57.86\" x2=\"20\" y2=\"22.14\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"60\" y1=\"57.86\" x2=\"60\" y2=\"22.14\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/>") },
		server: { body: Kx("<rect x=\"17.5\" y=\"17.5\" width=\"45\" height=\"45\" rx=\"2\" ry=\"2\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"17.5\" y1=\"32.5\" x2=\"62.5\" y2=\"32.5\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"17.5\" y1=\"47.5\" x2=\"62.5\" y2=\"47.5\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><g><path d=\"m56.25,25c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z\" style=\"fill: #fff; stroke-width: 0px;\"/><path d=\"m56.25,25c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10;\"/></g><g><path d=\"m56.25,40c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z\" style=\"fill: #fff; stroke-width: 0px;\"/><path d=\"m56.25,40c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10;\"/></g><g><path d=\"m56.25,55c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z\" style=\"fill: #fff; stroke-width: 0px;\"/><path d=\"m56.25,55c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10;\"/></g><g><circle cx=\"32.5\" cy=\"25\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/><circle cx=\"27.5\" cy=\"25\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/><circle cx=\"22.5\" cy=\"25\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/></g><g><circle cx=\"32.5\" cy=\"40\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/><circle cx=\"27.5\" cy=\"40\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/><circle cx=\"22.5\" cy=\"40\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/></g><g><circle cx=\"32.5\" cy=\"55\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/><circle cx=\"27.5\" cy=\"55\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/><circle cx=\"22.5\" cy=\"55\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/></g>") },
		disk: { body: Kx("<rect x=\"20\" y=\"15\" width=\"40\" height=\"50\" rx=\"1\" ry=\"1\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><ellipse cx=\"24\" cy=\"19.17\" rx=\".8\" ry=\".83\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><ellipse cx=\"56\" cy=\"19.17\" rx=\".8\" ry=\".83\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><ellipse cx=\"24\" cy=\"60.83\" rx=\".8\" ry=\".83\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><ellipse cx=\"56\" cy=\"60.83\" rx=\".8\" ry=\".83\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><ellipse cx=\"40\" cy=\"33.75\" rx=\"14\" ry=\"14.58\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><ellipse cx=\"40\" cy=\"33.75\" rx=\"4\" ry=\"4.17\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><path d=\"m37.51,42.52l-4.83,13.22c-.26.71-1.1,1.02-1.76.64l-4.18-2.42c-.66-.38-.81-1.26-.33-1.84l9.01-10.8c.88-1.05,2.56-.08,2.09,1.2Z\" style=\"fill: #fff; stroke-width: 0px;\"/>") },
		internet: { body: Kx("<circle cx=\"40\" cy=\"40\" r=\"22.5\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"40\" y1=\"17.5\" x2=\"40\" y2=\"62.5\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"17.5\" y1=\"40\" x2=\"62.5\" y2=\"40\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><path d=\"m39.99,17.51c-15.28,11.1-15.28,33.88,0,44.98\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><path d=\"m40.01,17.51c15.28,11.1,15.28,33.88,0,44.98\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"19.75\" y1=\"30.1\" x2=\"60.25\" y2=\"30.1\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"19.75\" y1=\"49.9\" x2=\"60.25\" y2=\"49.9\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/>") },
		cloud: { body: Kx("<path d=\"m65,47.5c0,2.76-2.24,5-5,5H20c-2.76,0-5-2.24-5-5,0-1.87,1.03-3.51,2.56-4.36-.04-.21-.06-.42-.06-.64,0-2.6,2.48-4.74,5.65-4.97,1.65-4.51,6.34-7.76,11.85-7.76.86,0,1.69.08,2.5.23,2.09-1.57,4.69-2.5,7.5-2.5,6.1,0,11.19,4.38,12.28,10.17,2.14.56,3.72,2.51,3.72,4.83,0,.03,0,.07-.01.1,2.29.46,4.01,2.48,4.01,4.9Z\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/>") },
		unknown: HE,
		blank: { body: Kx("") }
	}
}, Kw = h(async function(e, t, r) {
	let i = r.getConfigField("padding"), n = r.getConfigField("iconSize"), a = n / 2, s = n / 6, o = s / 2;
	await Promise.all(t.edges().map(async (t) => {
		let { source: n, sourceDir: l, sourceArrow: h, sourceGroup: u, target: d, targetDir: p, targetArrow: f, targetGroup: g, label: m } = Ku(t), { x: y, y: v } = t[0].sourceEndpoint(), { x, y: b } = t[0].midpoint(), { x: w, y: k } = t[0].targetEndpoint(), T = i + 4;
		if (u && (Ke(l) ? y += "L" === l ? -T : T : v += "T" === l ? -T : T + 18), g && (Ke(p) ? w += "L" === p ? -T : T : k += "T" === p ? -T : T + 18), u || r.getNode(n)?.type !== "junction" || (Ke(l) ? y += "L" === l ? a : -a : v += "T" === l ? a : -a), g || r.getNode(d)?.type !== "junction" || (Ke(p) ? w += "L" === p ? a : -a : k += "T" === p ? a : -a), t[0]._private.rscratch) {
			let t = e.insert("g");
			if (t.insert("path").attr("d", `M ${y},${v} L ${x},${b} L${w},${k} `).attr("class", "edge").attr("id", V7(n, d, { prefix: "L" })), h) {
				let e = Ke(l) ? X7[l](y, s) : y - o, r = Kt(l) ? X7[l](v, s) : v - o;
				t.insert("polygon").attr("points", X6[l](s)).attr("transform", `translate(${e},${r})`).attr("class", "arrow");
			}
			if (f) {
				let e = Ke(p) ? X7[p](w, s) : w - o, r = Kt(p) ? X7[p](k, s) : k - o;
				t.insert("polygon").attr("points", X6[p](s)).attr("transform", `translate(${e},${r})`).attr("class", "arrow");
			}
			if (m) {
				let e = Kr(l, p) ? "XY" : Ke(l) ? "X" : "Y", r = 0;
				r = "X" === e ? Math.abs(y - w) : "Y" === e ? Math.abs(v - k) / 1.5 : Math.abs(y - w) / 2;
				let i = t.append("g");
				if (await XQ(i, m, {
					useHtmlLabels: !1,
					width: r,
					classes: "architecture-service-label"
				}, IA()), i.attr("dy", "1em").attr("alignment-baseline", "middle").attr("dominant-baseline", "middle").attr("text-anchor", "middle"), "X" === e) i.attr("transform", "translate(" + x + ", " + b + ")");
				else if ("Y" === e) i.attr("transform", "translate(" + x + ", " + b + ") rotate(-90)");
				else if ("XY" === e) {
					let e = Ka(l, p);
					if (e && Ki(e)) {
						let t = i.node().getBoundingClientRect(), [r, n] = Ko(e);
						i.attr("dominant-baseline", "auto").attr("transform", `rotate(${-1 * r * n * 45})`);
						let a = i.node().getBoundingClientRect();
						i.attr("transform", `
                translate(${x}, ${b - t.height / 2})
                translate(${r * a.width / 2}, ${n * a.height / 2})
                rotate(${-1 * r * n * 45}, 0, ${t.height / 2})
              `);
					}
				}
			}
		}
	}));
}, "drawEdges"), Kk = h(async function(e, t, r) {
	let i = .75 * r.getConfigField("padding"), n = r.getConfigField("fontSize"), a = r.getConfigField("iconSize") / 2;
	await Promise.all(t.nodes().map(async (t) => {
		let s = Kd(t);
		if ("group" === s.type) {
			let { h: o, w: l, x1: h, y1: u } = t.boundingBox(), d = e.append("rect");
			d.attr("id", `group-${s.id}`).attr("x", h + a).attr("y", u + a).attr("width", l).attr("height", o).attr("class", "node-bkg");
			let p = e.append("g"), f = h, g = u;
			if (s.icon) {
				let e = p.append("g");
				e.html(`<g>${await HN(s.icon, {
					height: i,
					width: i,
					fallbackPrefix: Kb.prefix
				})}</g>`), e.attr("transform", "translate(" + (f + a + 1) + ", " + (g + a + 1) + ")"), f += i, g += n / 2 - 1 - 2;
			}
			if (s.label) {
				let e = p.append("g");
				await XQ(e, s.label, {
					useHtmlLabels: !1,
					width: l,
					classes: "architecture-service-label"
				}, IA()), e.attr("dy", "1em").attr("alignment-baseline", "middle").attr("dominant-baseline", "start").attr("text-anchor", "start"), e.attr("transform", "translate(" + (f + a + 4) + ", " + (g + a + 2) + ")");
			}
			r.setElementForId(s.id, d);
		}
	}));
}, "drawGroups"), KT = h(async function(e, t, r) {
	let i = IA();
	for (let n of r) {
		let r = t.append("g"), a = e.getConfigField("iconSize");
		if (n.title) {
			let e = r.append("g");
			await XQ(e, n.title, {
				useHtmlLabels: !1,
				width: 1.5 * a,
				classes: "architecture-service-label"
			}, i), e.attr("dy", "1em").attr("alignment-baseline", "middle").attr("dominant-baseline", "middle").attr("text-anchor", "middle"), e.attr("transform", "translate(" + a / 2 + ", " + a + ")");
		}
		let s = r.append("g");
		if (n.icon) s.html(`<g>${await HN(n.icon, {
			height: a,
			width: a,
			fallbackPrefix: Kb.prefix
		})}</g>`);
		else if (n.iconText) {
			s.html(`<g>${await HN("blank", {
				height: a,
				width: a,
				fallbackPrefix: Kb.prefix
			})}</g>`);
			let e = s.append("g").append("foreignObject").attr("width", a).attr("height", a).append("div").attr("class", "node-icon-text").attr("style", `height: ${a}px;`).append("div").html(MO(n.iconText, i)), t = parseInt(window.getComputedStyle(e.node(), null).getPropertyValue("font-size").replace(/\D/g, "")) ?? 16;
			e.attr("style", `-webkit-line-clamp: ${Math.floor((a - 2) / t)};`);
		} else s.append("path").attr("class", "node-bkg").attr("id", "node-" + n.id).attr("d", `M0 ${a} v${-a} q0,-5 5,-5 h${a} q5,0 5,5 v${a} H0 Z`);
		r.attr("id", `service-${n.id}`).attr("class", "architecture-service");
		let { width: o, height: l } = r.node().getBBox();
		n.width = o, n.height = l, e.setElementForId(n.id, r);
	}
	return 0;
}, "drawServices"), K_ = h(function(e, t, r) {
	r.forEach((r) => {
		let i = t.append("g"), n = e.getConfigField("iconSize");
		i.append("g").append("rect").attr("id", "node-" + r.id).attr("fill-opacity", "0").attr("width", n).attr("height", n), i.attr("class", "architecture-junction");
		let { width: a, height: s } = i._groups[0][0].getBBox();
		i.width = a, i.height = s, e.setElementForId(r.id, i);
	});
}, "drawJunctions");
function KE(e, t, r) {
	e.forEach((e) => {
		t.add({
			group: "nodes",
			data: {
				type: "service",
				id: e.id,
				icon: e.icon,
				label: e.title,
				parent: e.in,
				width: r.getConfigField("iconSize"),
				height: r.getConfigField("iconSize")
			},
			classes: "node-service"
		});
	});
}
function KC(e, t, r) {
	e.forEach((e) => {
		t.add({
			group: "nodes",
			data: {
				type: "junction",
				id: e.id,
				parent: e.in,
				width: r.getConfigField("iconSize"),
				height: r.getConfigField("iconSize")
			},
			classes: "node-junction"
		});
	});
}
function KS(e, t) {
	t.nodes().map((t) => {
		let r = Kd(t);
		"group" !== r.type && (r.x = t.position().x, r.y = t.position().y, e.getElementById(r.id).attr("transform", "translate(" + (r.x || 0) + "," + (r.y || 0) + ")"));
	});
}
function KA(e, t) {
	e.forEach((e) => {
		t.add({
			group: "nodes",
			data: {
				type: "group",
				id: e.id,
				icon: e.icon,
				label: e.title,
				parent: e.in
			},
			classes: "node-group"
		});
	});
}
function KL(e, t) {
	e.forEach((e) => {
		let { lhsId: r, rhsId: i, lhsInto: n, lhsGroup: a, rhsInto: s, lhsDir: o, rhsDir: l, rhsGroup: h, title: u } = e, d = Kr(e.lhsDir, e.rhsDir) ? "segments" : "straight", p = {
			id: `${r}-${i}`,
			label: u,
			source: r,
			sourceDir: o,
			sourceArrow: n,
			sourceGroup: a,
			sourceEndpoint: "L" === o ? "0 50%" : "R" === o ? "100% 50%" : "T" === o ? "50% 0" : "50% 100%",
			target: i,
			targetDir: l,
			targetArrow: s,
			targetGroup: h,
			targetEndpoint: "L" === l ? "0 50%" : "R" === l ? "100% 50%" : "T" === l ? "50% 0" : "50% 100%"
		};
		t.add({
			group: "edges",
			data: p,
			classes: d
		});
	});
}
function KR(e, t, r) {
	let i = h((e, t) => Object.entries(e).reduce((e, [i, n]) => {
		let a = 0, s = Object.entries(n);
		if (1 === s.length) return e[i] = s[0][1], e;
		for (let n = 0; n < s.length - 1; n++) for (let o = n + 1; o < s.length; o++) {
			let [l, h] = s[n], [u, d] = s[o];
			r[l]?.[u] === t || "default" === l || "default" === u ? (e[i] ??= [], e[i] = [
				...e[i],
				...h,
				...d
			]) : (e[`${i}-${a++}`] = h, e[`${i}-${a++}`] = d);
		}
		return e;
	}, {}), "flattenAlignments"), [n, a] = t.map((t) => {
		let r = {}, n = {};
		return Object.entries(t).forEach(([t, [i, a]]) => {
			let s = e.getNode(t)?.in ?? "default";
			r[a] ??= {}, r[a][s] ??= [], r[a][s].push(t), n[i] ??= {}, n[i][s] ??= [], n[i][s].push(t);
		}), {
			horiz: Object.values(i(r, "horizontal")).filter((e) => e.length > 1),
			vert: Object.values(i(n, "vertical")).filter((e) => e.length > 1)
		};
	}).reduce(([e, t], { horiz: r, vert: i }) => [[...e, ...r], [...t, ...i]], [[], []]);
	return {
		horizontal: n,
		vertical: a
	};
}
function KN(e, t) {
	let r = [], i = h((e) => `${e[0]},${e[1]}`, "posToStr"), n = h((e) => e.split(",").map((e) => parseInt(e)), "strToPos");
	return e.forEach((e) => {
		let a = Object.fromEntries(Object.entries(e).map(([e, t]) => [i(t), e])), s = [i([0, 0])], o = {}, l = {
			L: [-1, 0],
			R: [1, 0],
			T: [0, 1],
			B: [0, -1]
		};
		for (; s.length > 0;) {
			let e = s.shift();
			if (e) {
				o[e] = 1;
				let h = a[e];
				if (h) {
					let u = n(e);
					Object.entries(l).forEach(([e, n]) => {
						let l = i([u[0] + n[0], u[1] + n[1]]), d = a[l];
						d && !o[l] && (s.push(l), r.push({
							[X3[e]]: d,
							[X3[X8(e)]]: h,
							gap: 1.5 * t.getConfigField("iconSize")
						}));
					});
				}
			}
		}
	}), r;
}
function KI(e, t, r, i, n, { spatialMaps: a, groupAlignments: s }) {
	return new Promise((o) => {
		let l = _t("body").append("div").attr("id", "cy").attr("style", "display:none"), u = Vb({
			container: document.getElementById("cy"),
			style: [
				{
					selector: "edge",
					style: {
						"curve-style": "straight",
						label: "data(label)",
						"source-endpoint": "data(sourceEndpoint)",
						"target-endpoint": "data(targetEndpoint)"
					}
				},
				{
					selector: "edge.segments",
					style: {
						"curve-style": "segments",
						"segment-weights": "0",
						"segment-distances": [.5],
						"edge-distances": "endpoints",
						"source-endpoint": "data(sourceEndpoint)",
						"target-endpoint": "data(targetEndpoint)"
					}
				},
				{
					selector: "node",
					style: { "compound-sizing-wrt-labels": "include" }
				},
				{
					selector: "node[label]",
					style: {
						"text-valign": "bottom",
						"text-halign": "center",
						"font-size": `${n.getConfigField("fontSize")}px`
					}
				},
				{
					selector: ".node-service",
					style: {
						label: "data(label)",
						width: "data(width)",
						height: "data(height)"
					}
				},
				{
					selector: ".node-junction",
					style: {
						width: "data(width)",
						height: "data(height)"
					}
				},
				{
					selector: ".node-group",
					style: { padding: `${n.getConfigField("padding")}px` }
				}
			],
			layout: {
				name: "grid",
				boundingBox: {
					x1: 0,
					x2: 100,
					y1: 0,
					y2: 100
				}
			}
		});
		l.remove(), KA(r, u), KE(e, u, n), KC(t, u, n), KL(i, u);
		let d = KR(n, a, s), p = KN(a, n), f = u.layout({
			name: "fcose",
			quality: "proof",
			styleEnabled: !1,
			animate: !1,
			nodeDimensionsIncludeLabels: !1,
			idealEdgeLength(e) {
				let [t, r] = e.connectedNodes(), { parent: i } = Kd(t), { parent: a } = Kd(r);
				return i === a ? 1.5 * n.getConfigField("iconSize") : .5 * n.getConfigField("iconSize");
			},
			edgeElasticity(e) {
				let [t, r] = e.connectedNodes(), { parent: i } = Kd(t), { parent: n } = Kd(r);
				return i === n ? .45 : .001;
			},
			alignmentConstraint: d,
			relativePlacementConstraint: p
		});
		f.one("layoutstop", () => {
			function e(e, t, r, i) {
				let n, a, { x: s, y: o } = e, { x: l, y: h } = t;
				a = (i - o + (s - r) * (o - h) / (s - l)) / Math.sqrt(1 + Math.pow((o - h) / (s - l), 2)), n = Math.sqrt(Math.pow(i - o, 2) + Math.pow(r - s, 2) - Math.pow(a, 2)) / Math.sqrt(Math.pow(l - s, 2) + Math.pow(h - o, 2));
				let u = (l - s) * (i - o) - (h - o) * (r - s);
				switch (!0) {
					case u >= 0:
						u = 1;
						break;
					case u < 0: u = -1;
				}
				let d = (l - s) * (r - s) + (h - o) * (i - o);
				switch (!0) {
					case d >= 0:
						d = 1;
						break;
					case d < 0: d = -1;
				}
				return {
					distances: a = Math.abs(a) * u,
					weights: n *= d
				};
			}
			for (let t of (h(e, "getSegmentWeights"), u.startBatch(), Object.values(u.edges()))) if (t.data?.()) {
				let { x: r, y: i } = t.source().position(), { x: n, y: a } = t.target().position();
				if (r !== n && i !== a) {
					let r = t.sourceEndpoint(), i = t.targetEndpoint(), { sourceDir: n } = Ku(t), [a, s] = Kt(n) ? [r.x, i.y] : [i.x, r.y], { weights: o, distances: l } = e(r, i, a, s);
					t.style("segment-distances", l), t.style("segment-weights", o);
				}
			}
			u.endBatch(), f.run();
		}), f.run(), u.ready((e) => {
			wQ.info("Ready", e), o(u);
		});
	});
}
HA([{
	name: Kb.prefix,
	icons: Kb
}]), Vb.use(Kv.default), h(KE, "addServices"), h(KC, "addJunctions"), h(KS, "positionNodes"), h(KA, "addGroups"), h(KL, "addEdges"), h(KR, "getAlignments"), h(KN, "getRelativeConstraints"), h(KI, "layoutArchitecture");
var KM = {
	parser: Km,
	get db() {
		return new Kf();
	},
	renderer: { draw: h(async (e, t, r, i) => {
		let n = i.db, a = n.getServices(), s = n.getJunctions(), o = n.getGroups(), l = n.getEdges(), h = n.getDataStructures(), u = Dy(t), d = u.append("g");
		d.attr("class", "architecture-edges");
		let p = u.append("g");
		p.attr("class", "architecture-services");
		let f = u.append("g");
		f.attr("class", "architecture-groups"), await KT(n, p, a), K_(n, p, s);
		let g = await KI(a, s, o, l, n, h);
		await Kw(d, g, n), await Kk(f, g, n), KS(n, g), M3(void 0, u, n.getConfigField("padding"), n.getConfigField("useMaxWidth"));
	}, "draw") },
	styles: Ky
}, KD = class {
	static {
		h(this, "Graph");
	}
	constructor(e = {}) {
		this._isDirected = !Object.prototype.hasOwnProperty.call(e, "directed") || e.directed, this._isMultigraph = !!Object.prototype.hasOwnProperty.call(e, "multigraph") && e.multigraph, this._isCompound = !!Object.prototype.hasOwnProperty.call(e, "compound") && e.compound, this._label = void 0, this._defaultNodeLabelFn = ev(void 0), this._defaultEdgeLabelFn = ev(void 0), this._nodes = {}, this._isCompound && (this._parent = {}, this._children = {}, this._children["\0"] = {}), this._in = {}, this._preds = {}, this._out = {}, this._sucs = {}, this._edgeObjs = {}, this._edgeLabels = {};
	}
	isDirected() {
		return this._isDirected;
	}
	isMultigraph() {
		return this._isMultigraph;
	}
	isCompound() {
		return this._isCompound;
	}
	setGraph(e) {
		return this._label = e, this;
	}
	graph() {
		return this._label;
	}
	setDefaultNodeLabel(e) {
		return R(e) || (e = ev(e)), this._defaultNodeLabelFn = e, this;
	}
	nodeCount() {
		return this._nodeCount;
	}
	nodes() {
		return t6(this._nodes);
	}
	sources() {
		var e = this;
		return iI(this.nodes(), function(t) {
			return t3(e._in[t]);
		});
	}
	sinks() {
		var e = this;
		return iI(this.nodes(), function(t) {
			return t3(e._out[t]);
		});
	}
	setNodes(e, t) {
		var r = arguments, i = this;
		return rU(e, function(e) {
			r.length > 1 ? i.setNode(e, t) : i.setNode(e);
		}), this;
	}
	setNode(e, t) {
		return Object.prototype.hasOwnProperty.call(this._nodes, e) ? arguments.length > 1 && (this._nodes[e] = t) : (this._nodes[e] = arguments.length > 1 ? t : this._defaultNodeLabelFn(e), this._isCompound && (this._parent[e] = "\0", this._children[e] = {}, this._children["\0"][e] = !0), this._in[e] = {}, this._preds[e] = {}, this._out[e] = {}, this._sucs[e] = {}, ++this._nodeCount), this;
	}
	node(e) {
		return this._nodes[e];
	}
	hasNode(e) {
		return Object.prototype.hasOwnProperty.call(this._nodes, e);
	}
	removeNode(e) {
		if (Object.prototype.hasOwnProperty.call(this._nodes, e)) {
			var t = h((e) => this.removeEdge(this._edgeObjs[e]), "removeEdge");
			delete this._nodes[e], this._isCompound && (this._removeFromParentsChildList(e), delete this._parent[e], rU(this.children(e), (e) => {
				this.setParent(e);
			}), delete this._children[e]), rU(t6(this._in[e]), t), delete this._in[e], delete this._preds[e], rU(t6(this._out[e]), t), delete this._out[e], delete this._sucs[e], --this._nodeCount;
		}
		return this;
	}
	setParent(e, t) {
		if (!this._isCompound) throw Error("Cannot set parent in a non-compound graph");
		if (iP(t)) t = "\0";
		else {
			t += "";
			for (var r = t; !iP(r); r = this.parent(r)) if (r === e) throw Error("Setting " + t + " as parent of " + e + " would create a cycle");
			this.setNode(t);
		}
		return this.setNode(e), this._removeFromParentsChildList(e), this._parent[e] = t, this._children[t][e] = !0, this;
	}
	_removeFromParentsChildList(e) {
		delete this._children[this._parent[e]][e];
	}
	parent(e) {
		if (this._isCompound) {
			var t = this._parent[e];
			if ("\0" !== t) return t;
		}
	}
	children(e) {
		if (iP(e) && (e = "\0"), this._isCompound) {
			var t = this._children[e];
			if (t) return t6(t);
		} else {
			if ("\0" === e) return this.nodes();
			if (this.hasNode(e)) return [];
		}
	}
	predecessors(e) {
		var t = this._preds[e];
		if (t) return t6(t);
	}
	successors(e) {
		var t = this._sucs[e];
		if (t) return t6(t);
	}
	neighbors(e) {
		var t = this.predecessors(e);
		if (t) return i9(t, this.successors(e));
	}
	isLeaf(e) {
		return 0 === (this.isDirected() ? this.successors(e) : this.neighbors(e)).length;
	}
	filterNodes(e) {
		var t = new this.constructor({
			directed: this._isDirected,
			multigraph: this._isMultigraph,
			compound: this._isCompound
		});
		t.setGraph(this.graph());
		var r = this;
		rU(this._nodes, function(r, i) {
			e(i) && t.setNode(i, r);
		}), rU(this._edgeObjs, function(e) {
			t.hasNode(e.v) && t.hasNode(e.w) && t.setEdge(e, r.edge(e));
		});
		var i = {};
		function n(e) {
			var a = r.parent(e);
			return void 0 === a || t.hasNode(a) ? (i[e] = a, a) : a in i ? i[a] : n(a);
		}
		return h(n, "findParent"), this._isCompound && rU(t.nodes(), function(e) {
			t.setParent(e, n(e));
		}), t;
	}
	setDefaultEdgeLabel(e) {
		return R(e) || (e = ev(e)), this._defaultEdgeLabelFn = e, this;
	}
	edgeCount() {
		return this._edgeCount;
	}
	edges() {
		return i$(this._edgeObjs);
	}
	setPath(e, t) {
		var r = this, i = arguments;
		return iJ(e, function(e, n) {
			return i.length > 1 ? r.setEdge(e, n, t) : r.setEdge(e, n), n;
		}), this;
	}
	setEdge() {
		var e, t, r, i, n = !1, a = arguments[0];
		"object" == typeof a && null !== a && "v" in a ? (e = a.v, t = a.w, r = a.name, 2 == arguments.length && (i = arguments[1], n = !0)) : (e = a, t = arguments[1], r = arguments[3], arguments.length > 2 && (i = arguments[2], n = !0)), e = "" + e, t = "" + t, iP(r) || (r = "" + r);
		var s = KP(this._isDirected, e, t, r);
		if (Object.prototype.hasOwnProperty.call(this._edgeLabels, s)) return n && (this._edgeLabels[s] = i), this;
		if (!iP(r) && !this._isMultigraph) throw Error("Cannot set a named edge when isMultigraph = false");
		this.setNode(e), this.setNode(t), this._edgeLabels[s] = n ? i : this._defaultEdgeLabelFn(e, t, r);
		var o = KB(this._isDirected, e, t, r);
		return e = o.v, t = o.w, Object.freeze(o), this._edgeObjs[s] = o, KO(this._preds[t], e), KO(this._sucs[e], t), this._in[t][s] = o, this._out[e][s] = o, this._edgeCount++, this;
	}
	edge(e, t, r) {
		var i = 1 == arguments.length ? KF(this._isDirected, arguments[0]) : KP(this._isDirected, e, t, r);
		return this._edgeLabels[i];
	}
	hasEdge(e, t, r) {
		var i = 1 == arguments.length ? KF(this._isDirected, arguments[0]) : KP(this._isDirected, e, t, r);
		return Object.prototype.hasOwnProperty.call(this._edgeLabels, i);
	}
	removeEdge(e, t, r) {
		var i = 1 == arguments.length ? KF(this._isDirected, arguments[0]) : KP(this._isDirected, e, t, r), n = this._edgeObjs[i];
		return n && (e = n.v, t = n.w, delete this._edgeLabels[i], delete this._edgeObjs[i], K$(this._preds[t], e), K$(this._sucs[e], t), delete this._in[t][i], delete this._out[e][i], this._edgeCount--), this;
	}
	inEdges(e, t) {
		var r = this._in[e];
		if (r) {
			var i = i$(r);
			return t ? iI(i, function(e) {
				return e.v === t;
			}) : i;
		}
	}
	outEdges(e, t) {
		var r = this._out[e];
		if (r) {
			var i = i$(r);
			return t ? iI(i, function(e) {
				return e.w === t;
			}) : i;
		}
	}
	nodeEdges(e, t) {
		var r = this.inEdges(e, t);
		if (r) return r.concat(this.outEdges(e, t));
	}
};
function KO(e, t) {
	e[t] ? e[t]++ : e[t] = 1;
}
function K$(e, t) {
	--e[t] || delete e[t];
}
function KP(e, t, r, i) {
	var n = "" + t, a = "" + r;
	if (!e && n > a) {
		var s = n;
		n = a, a = s;
	}
	return n + "" + a + "" + (iP(i) ? "\0" : i);
}
function KB(e, t, r, i) {
	var n = "" + t, a = "" + r;
	if (!e && n > a) {
		var s = n;
		n = a, a = s;
	}
	var o = {
		v: n,
		w: a
	};
	return i && (o.name = i), o;
}
function KF(e, t) {
	return KP(e, t.v, t.w, t.name);
}
KD.prototype._nodeCount = 0, KD.prototype._edgeCount = 0, h(KO, "incrementOrInitEntry"), h(K$, "decrementOrRemoveEntry"), h(KP, "edgeArgsToId"), h(KB, "edgeArgsToObj"), h(KF, "edgeObjToId");
var Kz = h(() => `
  /* Font Awesome icon styling - consolidated */
  .label-icon {
    display: inline-block;
    height: 1em;
    overflow: visible;
    vertical-align: -0.125em;
  }
  
  .node .label-icon path {
    fill: currentColor;
    stroke: revert;
    stroke-width: revert;
  }
`, "getIconStyles"), KU = {
	aggregation: 17.25,
	extension: 17.25,
	composition: 17.25,
	dependency: 6,
	lollipop: 13.5,
	arrow_point: 4
}, KG = {
	arrow_point: 9,
	arrow_cross: 12.5,
	arrow_circle: 12.5
};
function Kq(e, t) {
	if (void 0 === e || void 0 === t) return {
		angle: 0,
		deltaX: 0,
		deltaY: 0
	};
	e = Kj(e), t = Kj(t);
	let [r, i] = [e.x, e.y], [n, a] = [t.x, t.y], s = n - r, o = a - i;
	return {
		angle: Math.atan(o / s),
		deltaX: s,
		deltaY: o
	};
}
h(Kq, "calculateDeltaAndAngle");
var Kj = h((e) => Array.isArray(e) ? {
	x: e[0],
	y: e[1]
} : e, "pointTransformer"), KW = h((e) => ({
	x: h(function(t, r, i) {
		let n = 0, a = Kj(i[0]).x < Kj(i[i.length - 1]).x ? "left" : "right";
		if (0 === r && Object.hasOwn(KU, e.arrowTypeStart)) {
			let { angle: t, deltaX: r } = Kq(i[0], i[1]);
			n = KU[e.arrowTypeStart] * Math.cos(t) * (r >= 0 ? 1 : -1);
		} else if (r === i.length - 1 && Object.hasOwn(KU, e.arrowTypeEnd)) {
			let { angle: t, deltaX: r } = Kq(i[i.length - 1], i[i.length - 2]);
			n = KU[e.arrowTypeEnd] * Math.cos(t) * (r >= 0 ? 1 : -1);
		}
		let s = Math.abs(Kj(t).x - Kj(i[i.length - 1]).x), o = Math.abs(Kj(t).y - Kj(i[i.length - 1]).y), l = Math.abs(Kj(t).x - Kj(i[0]).x), h = Math.abs(Kj(t).y - Kj(i[0]).y), u = KU[e.arrowTypeStart], d = KU[e.arrowTypeEnd];
		if (s < d && s > 0 && o < d) {
			let e = d + 1 - s;
			e *= "right" === a ? -1 : 1, n -= e;
		}
		if (l < u && l > 0 && h < u) {
			let e = u + 1 - l;
			e *= "right" === a ? -1 : 1, n += e;
		}
		return Kj(t).x + n;
	}, "x"),
	y: h(function(t, r, i) {
		let n = 0, a = Kj(i[0]).y < Kj(i[i.length - 1]).y ? "down" : "up";
		if (0 === r && Object.hasOwn(KU, e.arrowTypeStart)) {
			let { angle: t, deltaY: r } = Kq(i[0], i[1]);
			n = KU[e.arrowTypeStart] * Math.abs(Math.sin(t)) * (r >= 0 ? 1 : -1);
		} else if (r === i.length - 1 && Object.hasOwn(KU, e.arrowTypeEnd)) {
			let { angle: t, deltaY: r } = Kq(i[i.length - 1], i[i.length - 2]);
			n = KU[e.arrowTypeEnd] * Math.abs(Math.sin(t)) * (r >= 0 ? 1 : -1);
		}
		let s = Math.abs(Kj(t).y - Kj(i[i.length - 1]).y), o = Math.abs(Kj(t).x - Kj(i[i.length - 1]).x), l = Math.abs(Kj(t).y - Kj(i[0]).y), h = Math.abs(Kj(t).x - Kj(i[0]).x), u = KU[e.arrowTypeStart], d = KU[e.arrowTypeEnd];
		if (s < d && s > 0 && o < d) {
			let e = d + 1 - s;
			e *= "up" === a ? -1 : 1, n -= e;
		}
		if (l < u && l > 0 && h < u) {
			let e = u + 1 - l;
			e *= "up" === a ? -1 : 1, n += e;
		}
		return Kj(t).y + n;
	}, "y")
}), "getLineFunctionsWithOffset"), KY = h(({ flowchart: e }) => {
	let t = e?.subGraphTitleMargin?.top ?? 0, r = e?.subGraphTitleMargin?.bottom ?? 0;
	return {
		subGraphTitleTopMargin: t,
		subGraphTitleBottomMargin: r,
		subGraphTitleTotalMargin: t + r
	};
}, "getSubGraphTitleMargins"), KV = function() {
	var e = h(function(e, t, r, i) {
		for (r = r || {}, i = e.length; i--; r[e[i]] = t);
		return r;
	}, "o"), t = [1, 15], r = [1, 7], i = [1, 13], n = [1, 14], a = [1, 19], s = [1, 16], o = [1, 17], l = [1, 18], u = [8, 30], d = [
		8,
		10,
		21,
		28,
		29,
		30,
		31,
		39,
		43,
		46
	], p = [1, 23], f = [1, 24], g = [
		8,
		10,
		15,
		16,
		21,
		28,
		29,
		30,
		31,
		39,
		43,
		46
	], m = [
		8,
		10,
		15,
		16,
		21,
		27,
		28,
		29,
		30,
		31,
		39,
		43,
		46
	], y = [1, 49], v = {
		trace: h(function() {}, "trace"),
		yy: {},
		symbols_: {
			error: 2,
			spaceLines: 3,
			SPACELINE: 4,
			NL: 5,
			separator: 6,
			SPACE: 7,
			EOF: 8,
			start: 9,
			BLOCK_DIAGRAM_KEY: 10,
			document: 11,
			stop: 12,
			statement: 13,
			link: 14,
			LINK: 15,
			START_LINK: 16,
			LINK_LABEL: 17,
			STR: 18,
			nodeStatement: 19,
			columnsStatement: 20,
			SPACE_BLOCK: 21,
			blockStatement: 22,
			classDefStatement: 23,
			cssClassStatement: 24,
			styleStatement: 25,
			node: 26,
			SIZE: 27,
			COLUMNS: 28,
			"id-block": 29,
			end: 30,
			NODE_ID: 31,
			nodeShapeNLabel: 32,
			dirList: 33,
			DIR: 34,
			NODE_DSTART: 35,
			NODE_DEND: 36,
			BLOCK_ARROW_START: 37,
			BLOCK_ARROW_END: 38,
			classDef: 39,
			CLASSDEF_ID: 40,
			CLASSDEF_STYLEOPTS: 41,
			DEFAULT: 42,
			class: 43,
			CLASSENTITY_IDS: 44,
			STYLECLASS: 45,
			style: 46,
			STYLE_ENTITY_IDS: 47,
			STYLE_DEFINITION_DATA: 48,
			$accept: 0,
			$end: 1
		},
		terminals_: {
			2: "error",
			4: "SPACELINE",
			5: "NL",
			7: "SPACE",
			8: "EOF",
			10: "BLOCK_DIAGRAM_KEY",
			15: "LINK",
			16: "START_LINK",
			17: "LINK_LABEL",
			18: "STR",
			21: "SPACE_BLOCK",
			27: "SIZE",
			28: "COLUMNS",
			29: "id-block",
			30: "end",
			31: "NODE_ID",
			34: "DIR",
			35: "NODE_DSTART",
			36: "NODE_DEND",
			37: "BLOCK_ARROW_START",
			38: "BLOCK_ARROW_END",
			39: "classDef",
			40: "CLASSDEF_ID",
			41: "CLASSDEF_STYLEOPTS",
			42: "DEFAULT",
			43: "class",
			44: "CLASSENTITY_IDS",
			45: "STYLECLASS",
			46: "style",
			47: "STYLE_ENTITY_IDS",
			48: "STYLE_DEFINITION_DATA"
		},
		productions_: [
			0,
			[3, 1],
			[3, 2],
			[3, 2],
			[6, 1],
			[6, 1],
			[6, 1],
			[9, 3],
			[12, 1],
			[12, 1],
			[12, 2],
			[12, 2],
			[11, 1],
			[11, 2],
			[14, 1],
			[14, 4],
			[13, 1],
			[13, 1],
			[13, 1],
			[13, 1],
			[13, 1],
			[13, 1],
			[13, 1],
			[19, 3],
			[19, 2],
			[19, 1],
			[20, 1],
			[22, 4],
			[22, 3],
			[26, 1],
			[26, 2],
			[33, 1],
			[33, 2],
			[32, 3],
			[32, 4],
			[23, 3],
			[23, 3],
			[24, 3],
			[25, 3]
		],
		performAction: h(function(e, t, r, i, n, a, s) {
			var o = a.length - 1;
			switch (n) {
				case 4:
					i.getLogger().debug("Rule: separator (NL) ");
					break;
				case 5:
					i.getLogger().debug("Rule: separator (Space) ");
					break;
				case 6:
					i.getLogger().debug("Rule: separator (EOF) ");
					break;
				case 7:
					i.getLogger().debug("Rule: hierarchy: ", a[o - 1]), i.setHierarchy(a[o - 1]);
					break;
				case 8:
					i.getLogger().debug("Stop NL ");
					break;
				case 9:
					i.getLogger().debug("Stop EOF ");
					break;
				case 10:
					i.getLogger().debug("Stop NL2 ");
					break;
				case 11:
					i.getLogger().debug("Stop EOF2 ");
					break;
				case 12:
					i.getLogger().debug("Rule: statement: ", a[o]), "number" == typeof a[o].length ? this.$ = a[o] : this.$ = [a[o]];
					break;
				case 13:
					i.getLogger().debug("Rule: statement #2: ", a[o - 1]), this.$ = [a[o - 1]].concat(a[o]);
					break;
				case 14:
					i.getLogger().debug("Rule: link: ", a[o], e), this.$ = {
						edgeTypeStr: a[o],
						label: ""
					};
					break;
				case 15:
					i.getLogger().debug("Rule: LABEL link: ", a[o - 3], a[o - 1], a[o]), this.$ = {
						edgeTypeStr: a[o],
						label: a[o - 1]
					};
					break;
				case 18:
					let l = parseInt(a[o]);
					this.$ = {
						id: i.generateId(),
						type: "space",
						label: "",
						width: l,
						children: []
					};
					break;
				case 23:
					i.getLogger().debug("Rule: (nodeStatement link node) ", a[o - 2], a[o - 1], a[o], " typestr: ", a[o - 1].edgeTypeStr);
					let h = i.edgeStrToEdgeData(a[o - 1].edgeTypeStr);
					this.$ = [
						{
							id: a[o - 2].id,
							label: a[o - 2].label,
							type: a[o - 2].type,
							directions: a[o - 2].directions
						},
						{
							id: a[o - 2].id + "-" + a[o].id,
							start: a[o - 2].id,
							end: a[o].id,
							label: a[o - 1].label,
							type: "edge",
							directions: a[o].directions,
							arrowTypeEnd: h,
							arrowTypeStart: "arrow_open"
						},
						{
							id: a[o].id,
							label: a[o].label,
							type: i.typeStr2Type(a[o].typeStr),
							directions: a[o].directions
						}
					];
					break;
				case 24:
					i.getLogger().debug("Rule: nodeStatement (abc88 node size) ", a[o - 1], a[o]), this.$ = {
						id: a[o - 1].id,
						label: a[o - 1].label,
						type: i.typeStr2Type(a[o - 1].typeStr),
						directions: a[o - 1].directions,
						widthInColumns: parseInt(a[o], 10)
					};
					break;
				case 25:
					i.getLogger().debug("Rule: nodeStatement (node) ", a[o]), this.$ = {
						id: a[o].id,
						label: a[o].label,
						type: i.typeStr2Type(a[o].typeStr),
						directions: a[o].directions,
						widthInColumns: 1
					};
					break;
				case 26:
					i.getLogger().debug("APA123", this ? this : "na"), i.getLogger().debug("COLUMNS: ", a[o]), this.$ = {
						type: "column-setting",
						columns: "auto" === a[o] ? -1 : parseInt(a[o])
					};
					break;
				case 27:
					i.getLogger().debug("Rule: id-block statement : ", a[o - 2], a[o - 1]), i.generateId(), this.$ = {
						...a[o - 2],
						type: "composite",
						children: a[o - 1]
					};
					break;
				case 28:
					i.getLogger().debug("Rule: blockStatement : ", a[o - 2], a[o - 1], a[o]), this.$ = {
						id: i.generateId(),
						type: "composite",
						label: "",
						children: a[o - 1]
					};
					break;
				case 29:
					i.getLogger().debug("Rule: node (NODE_ID separator): ", a[o]), this.$ = { id: a[o] };
					break;
				case 30:
					i.getLogger().debug("Rule: node (NODE_ID nodeShapeNLabel separator): ", a[o - 1], a[o]), this.$ = {
						id: a[o - 1],
						label: a[o].label,
						typeStr: a[o].typeStr,
						directions: a[o].directions
					};
					break;
				case 31:
					i.getLogger().debug("Rule: dirList: ", a[o]), this.$ = [a[o]];
					break;
				case 32:
					i.getLogger().debug("Rule: dirList: ", a[o - 1], a[o]), this.$ = [a[o - 1]].concat(a[o]);
					break;
				case 33:
					i.getLogger().debug("Rule: nodeShapeNLabel: ", a[o - 2], a[o - 1], a[o]), this.$ = {
						typeStr: a[o - 2] + a[o],
						label: a[o - 1]
					};
					break;
				case 34:
					i.getLogger().debug("Rule: BLOCK_ARROW nodeShapeNLabel: ", a[o - 3], a[o - 2], " #3:", a[o - 1], a[o]), this.$ = {
						typeStr: a[o - 3] + a[o],
						label: a[o - 2],
						directions: a[o - 1]
					};
					break;
				case 35:
				case 36:
					this.$ = {
						type: "classDef",
						id: a[o - 1].trim(),
						css: a[o].trim()
					};
					break;
				case 37:
					this.$ = {
						type: "applyClass",
						id: a[o - 1].trim(),
						styleClass: a[o].trim()
					};
					break;
				case 38: this.$ = {
					type: "applyStyles",
					id: a[o - 1].trim(),
					stylesStr: a[o].trim()
				};
			}
		}, "anonymous"),
		table: [
			{
				9: 1,
				10: [1, 2]
			},
			{ 1: [3] },
			{
				10: t,
				11: 3,
				13: 4,
				19: 5,
				20: 6,
				21: r,
				22: 8,
				23: 9,
				24: 10,
				25: 11,
				26: 12,
				28: i,
				29: n,
				31: a,
				39: s,
				43: o,
				46: l
			},
			{ 8: [1, 20] },
			e(u, [2, 12], {
				13: 4,
				19: 5,
				20: 6,
				22: 8,
				23: 9,
				24: 10,
				25: 11,
				26: 12,
				11: 21,
				10: t,
				21: r,
				28: i,
				29: n,
				31: a,
				39: s,
				43: o,
				46: l
			}),
			e(d, [2, 16], {
				14: 22,
				15: p,
				16: f
			}),
			e(d, [2, 17]),
			e(d, [2, 18]),
			e(d, [2, 19]),
			e(d, [2, 20]),
			e(d, [2, 21]),
			e(d, [2, 22]),
			e(g, [2, 25], { 27: [1, 25] }),
			e(d, [2, 26]),
			{
				19: 26,
				26: 12,
				31: a
			},
			{
				10: t,
				11: 27,
				13: 4,
				19: 5,
				20: 6,
				21: r,
				22: 8,
				23: 9,
				24: 10,
				25: 11,
				26: 12,
				28: i,
				29: n,
				31: a,
				39: s,
				43: o,
				46: l
			},
			{
				40: [1, 28],
				42: [1, 29]
			},
			{ 44: [1, 30] },
			{ 47: [1, 31] },
			e(m, [2, 29], {
				32: 32,
				35: [1, 33],
				37: [1, 34]
			}),
			{ 1: [2, 7] },
			e(u, [2, 13]),
			{
				26: 35,
				31: a
			},
			{ 31: [2, 14] },
			{ 17: [1, 36] },
			e(g, [2, 24]),
			{
				10: t,
				11: 37,
				13: 4,
				14: 22,
				15: p,
				16: f,
				19: 5,
				20: 6,
				21: r,
				22: 8,
				23: 9,
				24: 10,
				25: 11,
				26: 12,
				28: i,
				29: n,
				31: a,
				39: s,
				43: o,
				46: l
			},
			{ 30: [1, 38] },
			{ 41: [1, 39] },
			{ 41: [1, 40] },
			{ 45: [1, 41] },
			{ 48: [1, 42] },
			e(m, [2, 30]),
			{ 18: [1, 43] },
			{ 18: [1, 44] },
			e(g, [2, 23]),
			{ 18: [1, 45] },
			{ 30: [1, 46] },
			e(d, [2, 28]),
			e(d, [2, 35]),
			e(d, [2, 36]),
			e(d, [2, 37]),
			e(d, [2, 38]),
			{ 36: [1, 47] },
			{
				33: 48,
				34: y
			},
			{ 15: [1, 50] },
			e(d, [2, 27]),
			e(m, [2, 33]),
			{ 38: [1, 51] },
			{
				33: 52,
				34: y,
				38: [2, 31]
			},
			{ 31: [2, 15] },
			e(m, [2, 34]),
			{ 38: [2, 32] }
		],
		defaultActions: {
			20: [2, 7],
			23: [2, 14],
			50: [2, 15],
			52: [2, 32]
		},
		parseError: h(function(e, t) {
			if (t.recoverable) this.trace(e);
			else {
				var r = Error(e);
				throw r.hash = t, r;
			}
		}, "parseError"),
		parse: h(function(e) {
			var t = this, r = [0], i = [], n = [null], a = [], s = this.table, o = "", l = 0, u = 0, d = 0, p = a.slice.call(arguments, 1), f = Object.create(this.lexer), g = {};
			for (var m in this.yy) Object.prototype.hasOwnProperty.call(this.yy, m) && (g[m] = this.yy[m]);
			f.setInput(e, g), g.lexer = f, g.parser = this, typeof f.yylloc > "u" && (f.yylloc = {});
			var y = f.yylloc;
			a.push(y);
			var v = f.options && f.options.ranges;
			function x() {
				var e;
				return "number" != typeof (e = i.pop() || f.lex() || 1) && (e instanceof Array && (e = (i = e).pop()), e = t.symbols_[e] || e), e;
			}
			"function" == typeof g.parseError ? this.parseError = g.parseError : this.parseError = Object.getPrototypeOf(this).parseError, h(function(e) {
				r.length = r.length - 2 * e, n.length = n.length - e, a.length = a.length - e;
			}, "popStack"), h(x, "lex");
			for (var b, w, k, T, _, E, C, S, A, L = {};;) {
				if (k = r[r.length - 1], this.defaultActions[k] ? T = this.defaultActions[k] : ((null === b || typeof b > "u") && (b = x()), T = s[k] && s[k][b]), typeof T > "u" || !T.length || !T[0]) {
					var R = "";
					for (E in A = [], s[k]) this.terminals_[E] && E > 2 && A.push("'" + this.terminals_[E] + "'");
					R = f.showPosition ? "Parse error on line " + (l + 1) + `:
` + f.showPosition() + `
Expecting ` + A.join(", ") + ", got '" + (this.terminals_[b] || b) + "'" : "Parse error on line " + (l + 1) + ": Unexpected " + (1 == b ? "end of input" : "'" + (this.terminals_[b] || b) + "'"), this.parseError(R, {
						text: f.match,
						token: this.terminals_[b] || b,
						line: f.yylineno,
						loc: y,
						expected: A
					});
				}
				if (T[0] instanceof Array && T.length > 1) throw Error("Parse Error: multiple actions possible at state: " + k + ", token: " + b);
				switch (T[0]) {
					case 1:
						r.push(b), n.push(f.yytext), a.push(f.yylloc), r.push(T[1]), b = null, w ? (b = w, w = null) : (u = f.yyleng, o = f.yytext, l = f.yylineno, y = f.yylloc, d > 0 && d--);
						break;
					case 2:
						if (C = this.productions_[T[1]][1], L.$ = n[n.length - C], L._$ = {
							first_line: a[a.length - (C || 1)].first_line,
							last_line: a[a.length - 1].last_line,
							first_column: a[a.length - (C || 1)].first_column,
							last_column: a[a.length - 1].last_column
						}, v && (L._$.range = [a[a.length - (C || 1)].range[0], a[a.length - 1].range[1]]), "u" > typeof (_ = this.performAction.apply(L, [
							o,
							u,
							l,
							g,
							T[1],
							n,
							a
						].concat(p)))) return _;
						C && (r = r.slice(0, -1 * C * 2), n = n.slice(0, -1 * C), a = a.slice(0, -1 * C)), r.push(this.productions_[T[1]][0]), n.push(L.$), a.push(L._$), S = s[r[r.length - 2]][r[r.length - 1]], r.push(S);
						break;
					case 3: return !0;
				}
			}
			return !0;
		}, "parse")
	};
	function x() {
		this.yy = {};
	}
	return v.lexer = {
		EOF: 1,
		parseError: h(function(e, t) {
			if (this.yy.parser) this.yy.parser.parseError(e, t);
			else throw Error(e);
		}, "parseError"),
		setInput: h(function(e, t) {
			return this.yy = t || this.yy || {}, this._input = e, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
				first_line: 1,
				first_column: 0,
				last_line: 1,
				last_column: 0
			}, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
		}, "setInput"),
		input: h(function() {
			var e = this._input[0];
			return this.yytext += e, this.yyleng++, this.offset++, this.match += e, this.matched += e, e.match(/(?:\r\n?|\n).*/g) ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), e;
		}, "input"),
		unput: h(function(e) {
			var t = e.length, r = e.split(/(?:\r\n?|\n)/g);
			this._input = e + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - t), this.offset -= t;
			var i = this.match.split(/(?:\r\n?|\n)/g);
			this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), r.length - 1 && (this.yylineno -= r.length - 1);
			var n = this.yylloc.range;
			return this.yylloc = {
				first_line: this.yylloc.first_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.first_column,
				last_column: r ? (r.length === i.length ? this.yylloc.first_column : 0) + i[i.length - r.length].length - r[0].length : this.yylloc.first_column - t
			}, this.options.ranges && (this.yylloc.range = [n[0], n[0] + this.yyleng - t]), this.yyleng = this.yytext.length, this;
		}, "unput"),
		more: h(function() {
			return this._more = !0, this;
		}, "more"),
		reject: h(function() {
			return this.options.backtrack_lexer ? (this._backtrack = !0, this) : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "reject"),
		less: h(function(e) {
			this.unput(this.match.slice(e));
		}, "less"),
		pastInput: h(function() {
			var e = this.matched.substr(0, this.matched.length - this.match.length);
			return (e.length > 20 ? "..." : "") + e.substr(-20).replace(/\n/g, "");
		}, "pastInput"),
		upcomingInput: h(function() {
			var e = this.match;
			return e.length < 20 && (e += this._input.substr(0, 20 - e.length)), (e.substr(0, 20) + (e.length > 20 ? "..." : "")).replace(/\n/g, "");
		}, "upcomingInput"),
		showPosition: h(function() {
			var e = this.pastInput(), t = Array(e.length + 1).join("-");
			return e + this.upcomingInput() + `
` + t + "^";
		}, "showPosition"),
		test_match: h(function(e, t) {
			var r, i, n;
			if (this.options.backtrack_lexer && (n = {
				yylineno: this.yylineno,
				yylloc: {
					first_line: this.yylloc.first_line,
					last_line: this.last_line,
					first_column: this.yylloc.first_column,
					last_column: this.yylloc.last_column
				},
				yytext: this.yytext,
				match: this.match,
				matches: this.matches,
				matched: this.matched,
				yyleng: this.yyleng,
				offset: this.offset,
				_more: this._more,
				_input: this._input,
				yy: this.yy,
				conditionStack: this.conditionStack.slice(0),
				done: this.done
			}, this.options.ranges && (n.yylloc.range = this.yylloc.range.slice(0))), (i = e[0].match(/(?:\r\n?|\n).*/g)) && (this.yylineno += i.length), this.yylloc = {
				first_line: this.yylloc.last_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.last_column,
				last_column: i ? i[i.length - 1].length - i[i.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + e[0].length
			}, this.yytext += e[0], this.match += e[0], this.matches = e, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(e[0].length), this.matched += e[0], r = this.performAction.call(this, this.yy, this, t, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), r) return r;
			if (this._backtrack) for (var a in n) this[a] = n[a];
			return !1;
		}, "test_match"),
		next: h(function() {
			if (this.done) return this.EOF;
			this._input || (this.done = !0), this._more || (this.yytext = "", this.match = "");
			for (var e, t, r, i, n = this._currentRules(), a = 0; a < n.length; a++) if ((r = this._input.match(this.rules[n[a]])) && (!t || r[0].length > t[0].length)) {
				if (t = r, i = a, this.options.backtrack_lexer) {
					if (!1 !== (e = this.test_match(r, n[a]))) return e;
					if (!this._backtrack) return !1;
					t = !1;
					continue;
				} else if (!this.options.flex) break;
			}
			return t ? !1 !== (e = this.test_match(t, n[i])) && e : "" === this._input ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "next"),
		lex: h(function() {
			return this.next() || this.lex();
		}, "lex"),
		begin: h(function(e) {
			this.conditionStack.push(e);
		}, "begin"),
		popState: h(function() {
			return this.conditionStack.length - 1 > 0 ? this.conditionStack.pop() : this.conditionStack[0];
		}, "popState"),
		_currentRules: h(function() {
			return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
		}, "_currentRules"),
		topState: h(function(e) {
			return (e = this.conditionStack.length - 1 - Math.abs(e || 0)) >= 0 ? this.conditionStack[e] : "INITIAL";
		}, "topState"),
		pushState: h(function(e) {
			this.begin(e);
		}, "pushState"),
		stateStackSize: h(function() {
			return this.conditionStack.length;
		}, "stateStackSize"),
		options: {},
		performAction: h(function(e, t, r, i) {
			switch (r) {
				case 0: return e.getLogger().debug("Found block-beta"), 10;
				case 1: return e.getLogger().debug("Found id-block"), 29;
				case 2: return e.getLogger().debug("Found block"), 10;
				case 3:
					e.getLogger().debug(".", t.yytext);
					break;
				case 4:
					e.getLogger().debug("_", t.yytext);
					break;
				case 5: return 5;
				case 6: return t.yytext = -1, 28;
				case 7: return t.yytext = t.yytext.replace(/columns\s+/, ""), e.getLogger().debug("COLUMNS (LEX)", t.yytext), 28;
				case 8:
				case 76:
				case 77:
				case 99:
					this.pushState("md_string");
					break;
				case 9: return "MD_STR";
				case 10:
				case 34:
				case 79:
					this.popState();
					break;
				case 11:
					this.pushState("string");
					break;
				case 12:
					e.getLogger().debug("LEX: POPPING STR:", t.yytext), this.popState();
					break;
				case 13: return e.getLogger().debug("LEX: STR end:", t.yytext), "STR";
				case 14: return t.yytext = t.yytext.replace(/space\:/, ""), e.getLogger().debug("SPACE NUM (LEX)", t.yytext), 21;
				case 15: return t.yytext = "1", e.getLogger().debug("COLUMNS (LEX)", t.yytext), 21;
				case 16: return 42;
				case 17: return "LINKSTYLE";
				case 18: return "INTERPOLATE";
				case 19: return this.pushState("CLASSDEF"), 39;
				case 20: return this.popState(), this.pushState("CLASSDEFID"), "DEFAULT_CLASSDEF_ID";
				case 21: return this.popState(), this.pushState("CLASSDEFID"), 40;
				case 22: return this.popState(), 41;
				case 23: return this.pushState("CLASS"), 43;
				case 24: return this.popState(), this.pushState("CLASS_STYLE"), 44;
				case 25: return this.popState(), 45;
				case 26: return this.pushState("STYLE_STMNT"), 46;
				case 27: return this.popState(), this.pushState("STYLE_DEFINITION"), 47;
				case 28: return this.popState(), 48;
				case 29: return this.pushState("acc_title"), "acc_title";
				case 30: return this.popState(), "acc_title_value";
				case 31: return this.pushState("acc_descr"), "acc_descr";
				case 32: return this.popState(), "acc_descr_value";
				case 33:
					this.pushState("acc_descr_multiline");
					break;
				case 35: return "acc_descr_multiline_value";
				case 36: return 30;
				case 37:
				case 38:
				case 40:
				case 41:
				case 44: return this.popState(), e.getLogger().debug("Lex: (("), "NODE_DEND";
				case 39: return this.popState(), e.getLogger().debug("Lex: ))"), "NODE_DEND";
				case 42: return this.popState(), e.getLogger().debug("Lex: (-"), "NODE_DEND";
				case 43: return this.popState(), e.getLogger().debug("Lex: -)"), "NODE_DEND";
				case 45: return this.popState(), e.getLogger().debug("Lex: ]]"), "NODE_DEND";
				case 46: return this.popState(), e.getLogger().debug("Lex: ("), "NODE_DEND";
				case 47: return this.popState(), e.getLogger().debug("Lex: ])"), "NODE_DEND";
				case 48:
				case 49: return this.popState(), e.getLogger().debug("Lex: /]"), "NODE_DEND";
				case 50: return this.popState(), e.getLogger().debug("Lex: )]"), "NODE_DEND";
				case 51: return this.popState(), e.getLogger().debug("Lex: )"), "NODE_DEND";
				case 52: return this.popState(), e.getLogger().debug("Lex: ]>"), "NODE_DEND";
				case 53: return this.popState(), e.getLogger().debug("Lex: ]"), "NODE_DEND";
				case 54: return e.getLogger().debug("Lexa: -)"), this.pushState("NODE"), 35;
				case 55: return e.getLogger().debug("Lexa: (-"), this.pushState("NODE"), 35;
				case 56: return e.getLogger().debug("Lexa: ))"), this.pushState("NODE"), 35;
				case 57:
				case 59:
				case 60:
				case 61:
				case 64: return e.getLogger().debug("Lexa: )"), this.pushState("NODE"), 35;
				case 58: return e.getLogger().debug("Lex: ((("), this.pushState("NODE"), 35;
				case 62: return e.getLogger().debug("Lexc: >"), this.pushState("NODE"), 35;
				case 63: return e.getLogger().debug("Lexa: (["), this.pushState("NODE"), 35;
				case 65:
				case 66:
				case 67:
				case 68:
				case 69:
				case 70:
				case 71: return this.pushState("NODE"), 35;
				case 72: return e.getLogger().debug("Lexa: ["), this.pushState("NODE"), 35;
				case 73: return this.pushState("BLOCK_ARROW"), e.getLogger().debug("LEX ARR START"), 37;
				case 74: return e.getLogger().debug("Lex: NODE_ID", t.yytext), 31;
				case 75: return e.getLogger().debug("Lex: EOF", t.yytext), 8;
				case 78: return "NODE_DESCR";
				case 80:
					e.getLogger().debug("Lex: Starting string"), this.pushState("string");
					break;
				case 81:
					e.getLogger().debug("LEX ARR: Starting string"), this.pushState("string");
					break;
				case 82: return e.getLogger().debug("LEX: NODE_DESCR:", t.yytext), "NODE_DESCR";
				case 83:
					e.getLogger().debug("LEX POPPING"), this.popState();
					break;
				case 84:
					e.getLogger().debug("Lex: =>BAE"), this.pushState("ARROW_DIR");
					break;
				case 85: return t.yytext = t.yytext.replace(/^,\s*/, ""), e.getLogger().debug("Lex (right): dir:", t.yytext), "DIR";
				case 86: return t.yytext = t.yytext.replace(/^,\s*/, ""), e.getLogger().debug("Lex (left):", t.yytext), "DIR";
				case 87: return t.yytext = t.yytext.replace(/^,\s*/, ""), e.getLogger().debug("Lex (x):", t.yytext), "DIR";
				case 88: return t.yytext = t.yytext.replace(/^,\s*/, ""), e.getLogger().debug("Lex (y):", t.yytext), "DIR";
				case 89: return t.yytext = t.yytext.replace(/^,\s*/, ""), e.getLogger().debug("Lex (up):", t.yytext), "DIR";
				case 90: return t.yytext = t.yytext.replace(/^,\s*/, ""), e.getLogger().debug("Lex (down):", t.yytext), "DIR";
				case 91: return t.yytext = "]>", e.getLogger().debug("Lex (ARROW_DIR end):", t.yytext), this.popState(), this.popState(), "BLOCK_ARROW_END";
				case 92: return e.getLogger().debug("Lex: LINK", "#" + t.yytext + "#"), 15;
				case 93:
				case 94:
				case 95: return e.getLogger().debug("Lex: LINK", t.yytext), 15;
				case 96:
				case 97:
				case 98: return e.getLogger().debug("Lex: START_LINK", t.yytext), this.pushState("LLABEL"), 16;
				case 100: return e.getLogger().debug("Lex: Starting string"), this.pushState("string"), "LINK_LABEL";
				case 101: return this.popState(), e.getLogger().debug("Lex: LINK", "#" + t.yytext + "#"), 15;
				case 102:
				case 103: return this.popState(), e.getLogger().debug("Lex: LINK", t.yytext), 15;
				case 104: return e.getLogger().debug("Lex: COLON", t.yytext), t.yytext = t.yytext.slice(1), 27;
			}
		}, "anonymous"),
		rules: [
			/^(?:block-beta\b)/,
			/^(?:block:)/,
			/^(?:block\b)/,
			/^(?:[\s]+)/,
			/^(?:[\n]+)/,
			/^(?:((\u000D\u000A)|(\u000A)))/,
			/^(?:columns\s+auto\b)/,
			/^(?:columns\s+[\d]+)/,
			/^(?:["][`])/,
			/^(?:[^`"]+)/,
			/^(?:[`]["])/,
			/^(?:["])/,
			/^(?:["])/,
			/^(?:[^"]*)/,
			/^(?:space[:]\d+)/,
			/^(?:space\b)/,
			/^(?:default\b)/,
			/^(?:linkStyle\b)/,
			/^(?:interpolate\b)/,
			/^(?:classDef\s+)/,
			/^(?:DEFAULT\s+)/,
			/^(?:\w+\s+)/,
			/^(?:[^\n]*)/,
			/^(?:class\s+)/,
			/^(?:(\w+)+((,\s*\w+)*))/,
			/^(?:[^\n]*)/,
			/^(?:style\s+)/,
			/^(?:(\w+)+((,\s*\w+)*))/,
			/^(?:[^\n]*)/,
			/^(?:accTitle\s*:\s*)/,
			/^(?:(?!\n||)*[^\n]*)/,
			/^(?:accDescr\s*:\s*)/,
			/^(?:(?!\n||)*[^\n]*)/,
			/^(?:accDescr\s*\{\s*)/,
			/^(?:[\}])/,
			/^(?:[^\}]*)/,
			/^(?:end\b\s*)/,
			/^(?:\(\(\()/,
			/^(?:\)\)\))/,
			/^(?:[\)]\))/,
			/^(?:\}\})/,
			/^(?:\})/,
			/^(?:\(-)/,
			/^(?:-\))/,
			/^(?:\(\()/,
			/^(?:\]\])/,
			/^(?:\()/,
			/^(?:\]\))/,
			/^(?:\\\])/,
			/^(?:\/\])/,
			/^(?:\)\])/,
			/^(?:[\)])/,
			/^(?:\]>)/,
			/^(?:[\]])/,
			/^(?:-\))/,
			/^(?:\(-)/,
			/^(?:\)\))/,
			/^(?:\))/,
			/^(?:\(\(\()/,
			/^(?:\(\()/,
			/^(?:\{\{)/,
			/^(?:\{)/,
			/^(?:>)/,
			/^(?:\(\[)/,
			/^(?:\()/,
			/^(?:\[\[)/,
			/^(?:\[\|)/,
			/^(?:\[\()/,
			/^(?:\)\)\))/,
			/^(?:\[\\)/,
			/^(?:\[\/)/,
			/^(?:\[\\)/,
			/^(?:\[)/,
			/^(?:<\[)/,
			/^(?:[^\(\[\n\-\)\{\}\s\<\>:]+)/,
			/^(?:$)/,
			/^(?:["][`])/,
			/^(?:["][`])/,
			/^(?:[^`"]+)/,
			/^(?:[`]["])/,
			/^(?:["])/,
			/^(?:["])/,
			/^(?:[^"]+)/,
			/^(?:["])/,
			/^(?:\]>\s*\()/,
			/^(?:,?\s*right\s*)/,
			/^(?:,?\s*left\s*)/,
			/^(?:,?\s*x\s*)/,
			/^(?:,?\s*y\s*)/,
			/^(?:,?\s*up\s*)/,
			/^(?:,?\s*down\s*)/,
			/^(?:\)\s*)/,
			/^(?:\s*[xo<]?--+[-xo>]\s*)/,
			/^(?:\s*[xo<]?==+[=xo>]\s*)/,
			/^(?:\s*[xo<]?-?\.+-[xo>]?\s*)/,
			/^(?:\s*~~[\~]+\s*)/,
			/^(?:\s*[xo<]?--\s*)/,
			/^(?:\s*[xo<]?==\s*)/,
			/^(?:\s*[xo<]?-\.\s*)/,
			/^(?:["][`])/,
			/^(?:["])/,
			/^(?:\s*[xo<]?--+[-xo>]\s*)/,
			/^(?:\s*[xo<]?==+[=xo>]\s*)/,
			/^(?:\s*[xo<]?-?\.+-[xo>]?\s*)/,
			/^(?::\d+)/
		],
		conditions: {
			STYLE_DEFINITION: {
				rules: [28],
				inclusive: !1
			},
			STYLE_STMNT: {
				rules: [27],
				inclusive: !1
			},
			CLASSDEFID: {
				rules: [22],
				inclusive: !1
			},
			CLASSDEF: {
				rules: [20, 21],
				inclusive: !1
			},
			CLASS_STYLE: {
				rules: [25],
				inclusive: !1
			},
			CLASS: {
				rules: [24],
				inclusive: !1
			},
			LLABEL: {
				rules: [
					99,
					100,
					101,
					102,
					103
				],
				inclusive: !1
			},
			ARROW_DIR: {
				rules: [
					85,
					86,
					87,
					88,
					89,
					90,
					91
				],
				inclusive: !1
			},
			BLOCK_ARROW: {
				rules: [
					76,
					81,
					84
				],
				inclusive: !1
			},
			NODE: {
				rules: [
					37,
					38,
					39,
					40,
					41,
					42,
					43,
					44,
					45,
					46,
					47,
					48,
					49,
					50,
					51,
					52,
					53,
					77,
					80
				],
				inclusive: !1
			},
			md_string: {
				rules: [
					9,
					10,
					78,
					79
				],
				inclusive: !1
			},
			space: {
				rules: [],
				inclusive: !1
			},
			string: {
				rules: [
					12,
					13,
					82,
					83
				],
				inclusive: !1
			},
			acc_descr_multiline: {
				rules: [34, 35],
				inclusive: !1
			},
			acc_descr: {
				rules: [32],
				inclusive: !1
			},
			acc_title: {
				rules: [30],
				inclusive: !1
			},
			INITIAL: {
				rules: [
					0,
					1,
					2,
					3,
					4,
					5,
					6,
					7,
					8,
					11,
					14,
					15,
					16,
					17,
					18,
					19,
					23,
					26,
					29,
					31,
					33,
					36,
					54,
					55,
					56,
					57,
					58,
					59,
					60,
					61,
					62,
					63,
					64,
					65,
					66,
					67,
					68,
					69,
					70,
					71,
					72,
					73,
					74,
					75,
					92,
					93,
					94,
					95,
					96,
					97,
					98,
					104
				],
				inclusive: !0
			}
		}
	}, h(x, "Parser"), x.prototype = v, v.Parser = x, new x();
}();
KV.parser = KV;
var KH = /* @__PURE__ */ new Map(), KX = [], KK = /* @__PURE__ */ new Map(), KZ = "color", KQ = "fill", KJ = IA(), K0 = /* @__PURE__ */ new Map(), K1 = h((e) => M1.sanitizeText(e, KJ), "sanitizeText"), K2 = h(function(e, t = "") {
	let r = K0.get(e);
	r || (r = {
		id: e,
		styles: [],
		textStyles: []
	}, K0.set(e, r)), t?.split(",").forEach((e) => {
		let t = e.replace(/([^;]*);/, "$1").trim();
		if (RegExp(KZ).exec(e)) {
			let e = t.replace(KQ, "bgFill").replace(KZ, KQ);
			r.textStyles.push(e);
		}
		r.styles.push(t);
	});
}, "addStyleClass"), K4 = h(function(e, t = "") {
	let r = KH.get(e);
	null != t && (r.styles = t.split(","));
}, "addStyle2Node"), K5 = h(function(e, t) {
	e.split(",").forEach(function(e) {
		let r = KH.get(e);
		if (void 0 === r) {
			let t = e.trim();
			r = {
				id: t,
				type: "na",
				children: []
			}, KH.set(t, r);
		}
		r.classes || (r.classes = []), r.classes.push(t);
	});
}, "setCssClass"), K3 = h((e, t) => {
	let r = e.flat(), i = [], n = r.find((e) => e?.type === "column-setting")?.columns ?? -1;
	for (let e of r) {
		if ("number" == typeof n && n > 0 && "column-setting" !== e.type && "number" == typeof e.widthInColumns && e.widthInColumns > n && wQ.warn(`Block ${e.id} width ${e.widthInColumns} exceeds configured column width ${n}`), e.label && (e.label = K1(e.label)), "classDef" === e.type) {
			K2(e.id, e.css);
			continue;
		}
		if ("applyClass" === e.type) {
			K5(e.id, e?.styleClass ?? "");
			continue;
		}
		if ("applyStyles" === e.type) {
			e?.stylesStr && K4(e.id, e?.stylesStr);
			continue;
		}
		if ("column-setting" === e.type) t.columns = e.columns ?? -1;
		else if ("edge" === e.type) {
			let t = (KK.get(e.id) ?? 0) + 1;
			KK.set(e.id, t), e.id = t + "-" + e.id, KX.push(e);
		} else {
			e.label || ("composite" === e.type ? e.label = "" : e.label = e.id);
			let t = KH.get(e.id);
			if (void 0 === t ? KH.set(e.id, e) : ("na" !== e.type && (t.type = e.type), e.label !== e.id && (t.label = e.label)), e.children && K3(e.children, e), "space" === e.type) {
				let t = e.width ?? 1;
				for (let r = 0; r < t; r++) {
					let t = rI(e);
					t.id = t.id + "-" + r, KH.set(t.id, t), i.push(t);
				}
			} else void 0 === t && i.push(e);
		}
	}
	t.children = i;
}, "populateBlockDatabase"), K6 = [], K7 = {
	id: "root",
	type: "composite",
	children: [],
	columns: -1
}, K8 = h(() => {
	wQ.debug("Clear called"), Dn(), KH = new Map([["root", K7 = {
		id: "root",
		type: "composite",
		children: [],
		columns: -1
	}]]), K6 = [], K0 = /* @__PURE__ */ new Map(), KX = [], KK = /* @__PURE__ */ new Map();
}, "clear");
function K9(e) {
	switch (wQ.debug("typeStr2Type", e), e) {
		case "[]": return "square";
		case "()": return wQ.debug("we have a round"), "round";
		case "(())": return "circle";
		case ">]": return "rect_left_inv_arrow";
		case "{}": return "diamond";
		case "{{}}": return "hexagon";
		case "([])": return "stadium";
		case "[[]]": return "subroutine";
		case "[()]": return "cylinder";
		case "((()))": return "doublecircle";
		case "[//]": return "lean_right";
		case "[\\\\]": return "lean_left";
		case "[/\\]": return "trapezoid";
		case "[\\/]": return "inv_trapezoid";
		case "<[]>": return "block_arrow";
		default: return "na";
	}
}
function Ze(e) {
	return (wQ.debug("typeStr2Type", e), "==" === e) ? "thick" : "normal";
}
function Zt(e) {
	switch (e.replace(/^[\s-]+|[\s-]+$/g, "")) {
		case "x": return "arrow_cross";
		case "o": return "arrow_circle";
		case ">": return "arrow_point";
		default: return "";
	}
}
h(K9, "typeStr2Type"), h(Ze, "edgeTypeStr2Type"), h(Zt, "edgeStrToEdgeData");
var Zr = 0, Zi = h(() => (Zr++, "id-" + Math.random().toString(36).substr(2, 12) + "-" + Zr), "generateId"), Zn = h((e) => {
	K7.children = e, K3(e, K7), K6 = K7.children;
}, "setHierarchy"), Za = h((e) => {
	let t = KH.get(e);
	return t ? t.columns ? t.columns : t.children ? t.children.length : -1 : -1;
}, "getColumns"), Zs = h(() => [...KH.values()], "getBlocksFlat"), Zo = h(() => K6 || [], "getBlocks"), Zl = h(() => KX, "getEdges"), Zc = h((e) => KH.get(e), "getBlock"), Zh = h((e) => {
	KH.set(e.id, e);
}, "setBlock"), Zu = h(() => wQ, "getLogger"), Zd = h(function() {
	return K0;
}, "getClasses"), Zp = {
	getConfig: h(() => IA().block, "getConfig"),
	typeStr2Type: K9,
	edgeTypeStr2Type: Ze,
	edgeStrToEdgeData: Zt,
	getLogger: Zu,
	getBlocksFlat: Zs,
	getBlocks: Zo,
	getEdges: Zl,
	setHierarchy: Zn,
	getBlock: Zc,
	setBlock: Zh,
	getColumns: Za,
	getClasses: Zd,
	clear: K8,
	generateId: Zi
}, Zf = h((e, t) => NQ(NJ(e, "r"), NJ(e, "g"), NJ(e, "b"), t), "fade"), Zg = h((e) => `.label {
    font-family: ${e.fontFamily};
    color: ${e.nodeTextColor || e.textColor};
  }
  .cluster-label text {
    fill: ${e.titleColor};
  }
  .cluster-label span,p {
    color: ${e.titleColor};
  }



  .label text,span,p {
    fill: ${e.nodeTextColor || e.textColor};
    color: ${e.nodeTextColor || e.textColor};
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${e.mainBkg};
    stroke: ${e.nodeBorder};
    stroke-width: 1px;
  }
  .flowchart-label text {
    text-anchor: middle;
  }
  // .flowchart-label .text-outer-tspan {
  //   text-anchor: middle;
  // }
  // .flowchart-label .text-inner-tspan {
  //   text-anchor: start;
  // }

  .node .label {
    text-align: center;
  }
  .node.clickable {
    cursor: pointer;
  }

  .arrowheadPath {
    fill: ${e.arrowheadColor};
  }

  .edgePath .path {
    stroke: ${e.lineColor};
    stroke-width: 2.0px;
  }

  .flowchart-link {
    stroke: ${e.lineColor};
    fill: none;
  }

  .edgeLabel {
    background-color: ${e.edgeLabelBackground};
    rect {
      opacity: 0.5;
      background-color: ${e.edgeLabelBackground};
      fill: ${e.edgeLabelBackground};
    }
    text-align: center;
  }

  /* For html labels only */
  .labelBkg {
    background-color: ${Zf(e.edgeLabelBackground, .5)};
    // background-color:
  }

  .node .cluster {
    // fill: ${Zf(e.mainBkg, .5)};
    fill: ${Zf(e.clusterBkg, .5)};
    stroke: ${Zf(e.clusterBorder, .2)};
    box-shadow: rgba(50, 50, 93, 0.25) 0px 13px 27px -5px, rgba(0, 0, 0, 0.3) 0px 8px 16px -8px;
    stroke-width: 1px;
  }

  .cluster text {
    fill: ${e.titleColor};
  }

  .cluster span,p {
    color: ${e.titleColor};
  }
  /* .cluster div {
    color: ${e.titleColor};
  } */

  div.mermaidTooltip {
    position: absolute;
    text-align: center;
    max-width: 200px;
    padding: 2px;
    font-family: ${e.fontFamily};
    font-size: 12px;
    background: ${e.tertiaryColor};
    border: 1px solid ${e.border2};
    border-radius: 2px;
    pointer-events: none;
    z-index: 100;
  }

  .flowchartTitleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${e.textColor};
  }
  ${Kz()}
`, "getStyles"), Zm = h((e, t, r, i) => {
	t.forEach((t) => {
		Zy[t](e, r, i);
	});
}, "insertMarkers"), Zy = {
	extension: h((e, t, r) => {
		wQ.trace("Making markers for ", r), e.append("defs").append("marker").attr("id", r + "_" + t + "-extensionStart").attr("class", "marker extension " + t).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 1,7 L18,13 V 1 Z"), e.append("defs").append("marker").attr("id", r + "_" + t + "-extensionEnd").attr("class", "marker extension " + t).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 1,1 V 13 L18,7 Z");
	}, "extension"),
	composition: h((e, t, r) => {
		e.append("defs").append("marker").attr("id", r + "_" + t + "-compositionStart").attr("class", "marker composition " + t).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), e.append("defs").append("marker").attr("id", r + "_" + t + "-compositionEnd").attr("class", "marker composition " + t).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
	}, "composition"),
	aggregation: h((e, t, r) => {
		e.append("defs").append("marker").attr("id", r + "_" + t + "-aggregationStart").attr("class", "marker aggregation " + t).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), e.append("defs").append("marker").attr("id", r + "_" + t + "-aggregationEnd").attr("class", "marker aggregation " + t).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
	}, "aggregation"),
	dependency: h((e, t, r) => {
		e.append("defs").append("marker").attr("id", r + "_" + t + "-dependencyStart").attr("class", "marker dependency " + t).attr("refX", 6).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 5,7 L9,13 L1,7 L9,1 Z"), e.append("defs").append("marker").attr("id", r + "_" + t + "-dependencyEnd").attr("class", "marker dependency " + t).attr("refX", 13).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
	}, "dependency"),
	lollipop: h((e, t, r) => {
		e.append("defs").append("marker").attr("id", r + "_" + t + "-lollipopStart").attr("class", "marker lollipop " + t).attr("refX", 13).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6), e.append("defs").append("marker").attr("id", r + "_" + t + "-lollipopEnd").attr("class", "marker lollipop " + t).attr("refX", 1).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6);
	}, "lollipop"),
	point: h((e, t, r) => {
		e.append("marker").attr("id", r + "_" + t + "-pointEnd").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", 6).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), e.append("marker").attr("id", r + "_" + t + "-pointStart").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", 4.5).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 5 L 10 10 L 10 0 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
	}, "point"),
	circle: h((e, t, r) => {
		e.append("marker").attr("id", r + "_" + t + "-circleEnd").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", 11).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), e.append("marker").attr("id", r + "_" + t + "-circleStart").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", -1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
	}, "circle"),
	cross: h((e, t, r) => {
		e.append("marker").attr("id", r + "_" + t + "-crossEnd").attr("class", "marker cross " + t).attr("viewBox", "0 0 11 11").attr("refX", 12).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0"), e.append("marker").attr("id", r + "_" + t + "-crossStart").attr("class", "marker cross " + t).attr("viewBox", "0 0 11 11").attr("refX", -1).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0");
	}, "cross"),
	barb: h((e, t, r) => {
		e.append("defs").append("marker").attr("id", r + "_" + t + "-barbEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 14).attr("markerUnits", "strokeWidth").attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
	}, "barb")
}, Zv = IA()?.block?.padding ?? 8;
function Zx(e, t) {
	if (0 === e || !Number.isInteger(e)) throw Error("Columns must be an integer !== 0.");
	if (t < 0 || !Number.isInteger(t)) throw Error("Position must be a non-negative integer." + t);
	return e < 0 ? {
		px: t,
		py: 0
	} : 1 === e ? {
		px: 0,
		py: t
	} : {
		px: t % e,
		py: Math.floor(t / e)
	};
}
h(Zx, "calculateBlockPosition");
var Zb = h((e) => {
	let t = 0, r = 0;
	for (let i of e.children) {
		let { width: n, height: a, x: s, y: o } = i.size ?? {
			width: 0,
			height: 0,
			x: 0,
			y: 0
		};
		wQ.debug("getMaxChildSize abc95 child:", i.id, "width:", n, "height:", a, "x:", s, "y:", o, i.type), "space" !== i.type && (n > t && (t = n / (e.widthInColumns ?? 1)), a > r && (r = a));
	}
	return {
		width: t,
		height: r
	};
}, "getMaxChildSize");
function Zw(e, t, r = 0, i = 0) {
	wQ.debug("setBlockSizes abc95 (start)", e.id, e?.size?.x, "block width =", e?.size, "siblingWidth", r), e?.size?.width || (e.size = {
		width: r,
		height: i,
		x: 0,
		y: 0
	});
	let n = 0, a = 0;
	if (e.children?.length > 0) {
		for (let r of e.children) Zw(r, t);
		let s = Zb(e);
		for (let t of (n = s.width, a = s.height, wQ.debug("setBlockSizes abc95 maxWidth of", e.id, ":s children is ", n, a), e.children)) t.size && (wQ.debug(`abc95 Setting size of children of ${e.id} id=${t.id} ${n} ${a} ${JSON.stringify(t.size)}`), t.size.width = n * (t.widthInColumns ?? 1) + Zv * ((t.widthInColumns ?? 1) - 1), t.size.height = a, t.size.x = 0, t.size.y = 0, wQ.debug(`abc95 updating size of ${e.id} children child:${t.id} maxWidth:${n} maxHeight:${a}`));
		for (let r of e.children) Zw(r, t, n, a);
		let o = e.columns ?? -1, l = 0;
		for (let t of e.children) l += t.widthInColumns ?? 1;
		let h = e.children.length;
		o > 0 && o < l && (h = o);
		let u = Math.ceil(l / h), d = h * (n + Zv) + Zv, p = u * (a + Zv) + Zv;
		if (d < r) {
			wQ.debug(`Detected to small sibling: abc95 ${e.id} siblingWidth ${r} siblingHeight ${i} width ${d}`), d = r, p = i;
			let t = (r - h * Zv - Zv) / h, s = (i - u * Zv - Zv) / u;
			for (let r of (wQ.debug("Size indata abc88", e.id, "childWidth", t, "maxWidth", n), wQ.debug("Size indata abc88", e.id, "childHeight", s, "maxHeight", a), wQ.debug("Size indata abc88 xSize", h, "padding", Zv), e.children)) r.size && (r.size.width = t, r.size.height = s, r.size.x = 0, r.size.y = 0);
		}
		if (wQ.debug(`abc95 (finale calc) ${e.id} xSize ${h} ySize ${u} columns ${o}${e.children.length} width=${Math.max(d, e.size?.width || 0)}`), d < (e?.size?.width || 0)) {
			d = e?.size?.width || 0;
			let t = o > 0 ? Math.min(e.children.length, o) : e.children.length;
			if (t > 0) {
				let r = (d - t * Zv - Zv) / t;
				for (let t of (wQ.debug("abc95 (growing to fit) width", e.id, d, e.size?.width, r), e.children)) t.size && (t.size.width = r);
			}
		}
		e.size = {
			width: d,
			height: p,
			x: 0,
			y: 0
		};
	}
	wQ.debug("setBlockSizes abc94 (done)", e.id, e?.size?.x, e?.size?.width, e?.size?.y, e?.size?.height);
}
function Zk(e, t) {
	wQ.debug(`abc85 layout blocks (=>layoutBlocks) ${e.id} x: ${e?.size?.x} y: ${e?.size?.y} width: ${e?.size?.width}`);
	let r = e.columns ?? -1;
	if (wQ.debug("layoutBlocks columns abc95", e.id, "=>", r, e), e.children && e.children.length > 0) {
		let i = e?.children[0]?.size?.width ?? 0, n = e.children.length * i + (e.children.length - 1) * Zv;
		wQ.debug("widthOfChildren 88", n, "posX");
		let a = 0;
		wQ.debug("abc91 block?.size?.x", e.id, e?.size?.x);
		let s = e?.size?.x ? e?.size?.x + (-e?.size?.width / 2 || 0) : -Zv, o = 0;
		for (let i of e.children) {
			if (!i.size) continue;
			let { width: n, height: l } = i.size, { px: h, py: u } = Zx(r, a);
			if (u != o && (o = u, s = e?.size?.x ? e?.size?.x + (-e?.size?.width / 2 || 0) : -Zv, wQ.debug("New row in layout for block", e.id, " and child ", i.id, o)), wQ.debug(`abc89 layout blocks (child) id: ${i.id} Pos: ${a} (px, py) ${h},${u} (${e?.size?.x},${e?.size?.y}) parent: ${e.id} width: ${n}${Zv}`), e.size) {
				let t = n / 2;
				i.size.x = s + Zv + t, wQ.debug(`abc91 layout blocks (calc) px, pyid:${i.id} startingPos=X${s} new startingPosX${i.size.x} ${t} padding=${Zv} width=${n} halfWidth=${t} => x:${i.size.x} y:${i.size.y} ${i.widthInColumns} (width * (child?.w || 1)) / 2 ${n * (i?.widthInColumns ?? 1) / 2}`), s = i.size.x + t, i.size.y = e.size.y - e.size.height / 2 + u * (l + Zv) + l / 2 + Zv, wQ.debug(`abc88 layout blocks (calc) px, pyid:${i.id}startingPosX${s}${Zv}${t}=>x:${i.size.x}y:${i.size.y}${i.widthInColumns}(width * (child?.w || 1)) / 2${n * (i?.widthInColumns ?? 1) / 2}`);
			}
			i.children && Zk(i, t);
			let d = i?.widthInColumns ?? 1;
			r > 0 && (d = Math.min(d, r - a % r)), a += d, wQ.debug("abc88 columnsPos", i, a);
		}
	}
	wQ.debug(`layout blocks (<==layoutBlocks) ${e.id} x: ${e?.size?.x} y: ${e?.size?.y} width: ${e?.size?.width}`);
}
function ZT(e, { minX: t, minY: r, maxX: i, maxY: n } = {
	minX: 0,
	minY: 0,
	maxX: 0,
	maxY: 0
}) {
	if (e.size && "root" !== e.id) {
		let { x: a, y: s, width: o, height: l } = e.size;
		a - o / 2 < t && (t = a - o / 2), s - l / 2 < r && (r = s - l / 2), a + o / 2 > i && (i = a + o / 2), s + l / 2 > n && (n = s + l / 2);
	}
	if (e.children) for (let a of e.children) ({minX: t, minY: r, maxX: i, maxY: n} = ZT(a, {
		minX: t,
		minY: r,
		maxX: i,
		maxY: n
	}));
	return {
		minX: t,
		minY: r,
		maxX: i,
		maxY: n
	};
}
function Z_(e) {
	let t = e.getBlock("root");
	if (!t) return;
	Zw(t, e, 0, 0), Zk(t, e), wQ.debug("getBlocks", JSON.stringify(t, null, 2));
	let { minX: r, minY: i, maxX: n, maxY: a } = ZT(t);
	return {
		x: r,
		y: i,
		width: n - r,
		height: a - i
	};
}
function ZE(e, t) {
	t && e.attr("style", t);
}
function ZC(e, t) {
	let r = _t(document.createElementNS("http://www.w3.org/2000/svg", "foreignObject")), i = r.append("xhtml:div"), n = e.label, a = e.isNode ? "nodeLabel" : "edgeLabel", s = i.append("span");
	return s.html(MO(n, t)), ZE(s, e.labelStyle), s.attr("class", a), ZE(i, e.labelStyle), i.style("display", "inline-block"), i.style("white-space", "nowrap"), i.attr("xmlns", "http://www.w3.org/1999/xhtml"), r.node();
}
h(Zw, "setBlockSizes"), h(Zk, "layoutBlocks"), h(ZT, "findBounds"), h(Z_, "layout"), h(ZE, "applyStyle"), h(ZC, "addHtmlLabel");
var ZS = h(async (e, t, r, i) => {
	let n = e || "";
	"object" == typeof n && (n = n[0]);
	let a = IA();
	if (MG(a.flowchart.htmlLabels)) return n = n.replace(/\\n|\n/g, "<br />"), wQ.debug("vertexText" + n), ZC({
		isNode: i,
		label: await XZ(V6(n)),
		labelStyle: t.replace("fill:", "color:")
	}, a);
	{
		let e = document.createElementNS("http://www.w3.org/2000/svg", "text");
		e.setAttribute("style", t.replace("color:", "fill:"));
		for (let t of "string" == typeof n ? n.split(/\\n|\n|<br\s*\/?>/gi) : Array.isArray(n) ? n : []) {
			let i = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
			i.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), i.setAttribute("dy", "1em"), i.setAttribute("x", "0"), r ? i.setAttribute("class", "title-row") : i.setAttribute("class", "row"), i.textContent = t.trim(), e.appendChild(i);
		}
		return e;
	}
}, "createLabel"), ZA = h((e, t, r, i, n) => {
	t.arrowTypeStart && ZR(e, "start", t.arrowTypeStart, r, i, n), t.arrowTypeEnd && ZR(e, "end", t.arrowTypeEnd, r, i, n);
}, "addEdgeMarkers"), ZL = {
	arrow_cross: "cross",
	arrow_point: "point",
	arrow_barb: "barb",
	arrow_circle: "circle",
	aggregation: "aggregation",
	extension: "extension",
	composition: "composition",
	dependency: "dependency",
	lollipop: "lollipop"
}, ZR = h((e, t, r, i, n, a) => {
	let s = ZL[r];
	s ? e.attr(`marker-${t}`, `url(${i}#${n}_${a}-${s}${"start" === t ? "Start" : "End"})`) : wQ.warn(`Unknown arrow type: ${r}`);
}, "addEdgeMarker"), ZN = {}, ZI = {}, ZM = h(async (e, t) => {
	let r, i = IA(), n = MG(i.flowchart.htmlLabels), a = "markdown" === t.labelType ? XQ(e, t.label, {
		style: t.labelStyle,
		useHtmlLabels: n,
		addSvgBackground: !0
	}, i) : await ZS(t.label, t.labelStyle), s = e.insert("g").attr("class", "edgeLabel"), o = s.insert("g").attr("class", "label");
	o.node().appendChild(a);
	let l = a.getBBox();
	if (n) {
		let e = a.children[0], t = _t(a);
		l = e.getBoundingClientRect(), t.attr("width", l.width), t.attr("height", l.height);
	}
	if (o.attr("transform", "translate(" + -l.width / 2 + ", " + -l.height / 2 + ")"), ZN[t.id] = s, t.width = l.width, t.height = l.height, t.startLabelLeft) {
		let i = await ZS(t.startLabelLeft, t.labelStyle), n = e.insert("g").attr("class", "edgeTerminals"), a = n.insert("g").attr("class", "inner");
		r = a.node().appendChild(i);
		let s = i.getBBox();
		a.attr("transform", "translate(" + -s.width / 2 + ", " + -s.height / 2 + ")"), ZI[t.id] || (ZI[t.id] = {}), ZI[t.id].startLeft = n, ZD(r, t.startLabelLeft);
	}
	if (t.startLabelRight) {
		let i = await ZS(t.startLabelRight, t.labelStyle), n = e.insert("g").attr("class", "edgeTerminals"), a = n.insert("g").attr("class", "inner");
		r = n.node().appendChild(i), a.node().appendChild(i);
		let s = i.getBBox();
		a.attr("transform", "translate(" + -s.width / 2 + ", " + -s.height / 2 + ")"), ZI[t.id] || (ZI[t.id] = {}), ZI[t.id].startRight = n, ZD(r, t.startLabelRight);
	}
	if (t.endLabelLeft) {
		let i = await ZS(t.endLabelLeft, t.labelStyle), n = e.insert("g").attr("class", "edgeTerminals"), a = n.insert("g").attr("class", "inner");
		r = a.node().appendChild(i);
		let s = i.getBBox();
		a.attr("transform", "translate(" + -s.width / 2 + ", " + -s.height / 2 + ")"), n.node().appendChild(i), ZI[t.id] || (ZI[t.id] = {}), ZI[t.id].endLeft = n, ZD(r, t.endLabelLeft);
	}
	if (t.endLabelRight) {
		let i = await ZS(t.endLabelRight, t.labelStyle), n = e.insert("g").attr("class", "edgeTerminals"), a = n.insert("g").attr("class", "inner");
		r = a.node().appendChild(i);
		let s = i.getBBox();
		a.attr("transform", "translate(" + -s.width / 2 + ", " + -s.height / 2 + ")"), n.node().appendChild(i), ZI[t.id] || (ZI[t.id] = {}), ZI[t.id].endRight = n, ZD(r, t.endLabelRight);
	}
	return a;
}, "insertEdgeLabel");
function ZD(e, t) {
	IA().flowchart.htmlLabels && e && (e.style.width = 9 * t.length + "px", e.style.height = "12px");
}
h(ZD, "setTerminalWidth");
var ZO = h((e, t) => {
	wQ.debug("Moving label abc88 ", e.id, e.label, ZN[e.id], t);
	let r = t.updatedPath ? t.updatedPath : t.originalPath, { subGraphTitleTotalMargin: i } = KY(IA());
	if (e.label) {
		let n = ZN[e.id], a = e.x, s = e.y;
		if (r) {
			let i = VD(r);
			wQ.debug("Moving label " + e.label + " from (", a, ",", s, ") to (", i.x, ",", i.y, ") abc88"), t.updatedPath && (a = i.x, s = i.y);
		}
		n.attr("transform", `translate(${a}, ${s + i / 2})`);
	}
	if (e.startLabelLeft) {
		let t = ZI[e.id].startLeft, i = e.x, n = e.y;
		if (r) {
			let t = VP(10 * !!e.arrowTypeStart, "start_left", r);
			i = t.x, n = t.y;
		}
		t.attr("transform", `translate(${i}, ${n})`);
	}
	if (e.startLabelRight) {
		let t = ZI[e.id].startRight, i = e.x, n = e.y;
		if (r) {
			let t = VP(10 * !!e.arrowTypeStart, "start_right", r);
			i = t.x, n = t.y;
		}
		t.attr("transform", `translate(${i}, ${n})`);
	}
	if (e.endLabelLeft) {
		let t = ZI[e.id].endLeft, i = e.x, n = e.y;
		if (r) {
			let t = VP(10 * !!e.arrowTypeEnd, "end_left", r);
			i = t.x, n = t.y;
		}
		t.attr("transform", `translate(${i}, ${n})`);
	}
	if (e.endLabelRight) {
		let t = ZI[e.id].endRight, i = e.x, n = e.y;
		if (r) {
			let t = VP(10 * !!e.arrowTypeEnd, "end_right", r);
			i = t.x, n = t.y;
		}
		t.attr("transform", `translate(${i}, ${n})`);
	}
}, "positionEdgeLabel"), Z$ = h((e, t) => {
	let r = e.x, i = e.y, n = Math.abs(t.x - r), a = Math.abs(t.y - i), s = e.width / 2, o = e.height / 2;
	return n >= s || a >= o;
}, "outsideNode"), ZP = h((e, t, r) => {
	wQ.debug(`intersection calc abc89:
  outsidePoint: ${JSON.stringify(t)}
  insidePoint : ${JSON.stringify(r)}
  node        : x:${e.x} y:${e.y} w:${e.width} h:${e.height}`);
	let i = e.x, n = e.y, a = Math.abs(i - r.x), s = e.width / 2, o = r.x < t.x ? s - a : s + a, l = e.height / 2, h = Math.abs(t.y - r.y), u = Math.abs(t.x - r.x);
	if (Math.abs(n - t.y) * s > Math.abs(i - t.x) * l) {
		let e = r.y < t.y ? t.y - l - n : n - l - t.y;
		o = u * e / h;
		let i = {
			x: r.x < t.x ? r.x + o : r.x - u + o,
			y: r.y < t.y ? r.y + h - e : r.y - h + e
		};
		return 0 === o && (i.x = t.x, i.y = t.y), 0 === u && (i.x = t.x), 0 === h && (i.y = t.y), wQ.debug(`abc89 topp/bott calc, Q ${h}, q ${e}, R ${u}, r ${o}`, i), i;
	}
	{
		let e = h * (o = r.x < t.x ? t.x - s - i : i - s - t.x) / u, n = r.x < t.x ? r.x + u - o : r.x - u + o, a = r.y < t.y ? r.y + e : r.y - e;
		return wQ.debug(`sides calc abc89, Q ${h}, q ${e}, R ${u}, r ${o}`, {
			_x: n,
			_y: a
		}), 0 === o && (n = t.x, a = t.y), 0 === u && (n = t.x), 0 === h && (a = t.y), {
			x: n,
			y: a
		};
	}
}, "intersection"), ZB = h((e, t) => {
	wQ.debug("abc88 cutPathAtIntersect", e, t);
	let r = [], i = e[0], n = !1;
	return e.forEach((e) => {
		if (Z$(t, e) || n) i = e, n || r.push(e);
		else {
			let a = ZP(t, i, e), s = !1;
			r.forEach((e) => {
				s = s || e.x === a.x && e.y === a.y;
			}), r.some((e) => e.x === a.x && e.y === a.y) || r.push(a), n = !0;
		}
	}), r;
}, "cutPathAtIntersect"), ZF = h(function(e, t, r, i, n, a, s) {
	let o = r.points;
	wQ.debug("abc88 InsertEdge: edge=", r, "e=", t);
	let l = !1, h = a.node(t.v);
	var u = a.node(t.w);
	u?.intersect && h?.intersect && ((o = o.slice(1, r.points.length - 1)).unshift(h.intersect(o[0])), o.push(u.intersect(o[o.length - 1]))), r.toCluster && (wQ.debug("to cluster abc88", i[r.toCluster]), o = ZB(r.points, i[r.toCluster].node), l = !0), r.fromCluster && (wQ.debug("from cluster abc88", i[r.fromCluster]), o = ZB(o.reverse(), i[r.fromCluster].node).reverse(), l = !0);
	let d = o.filter((e) => !Number.isNaN(e.y)), p = Li;
	r.curve && ("graph" === n || "flowchart" === n) && (p = r.curve);
	let { x: f, y: g } = KW(r), m = A5().x(f).y(g).curve(p), y;
	switch (r.thickness) {
		case "normal":
			y = "edge-thickness-normal";
			break;
		case "thick":
		case "invisible":
			y = "edge-thickness-thick";
			break;
		default: y = "";
	}
	switch (r.pattern) {
		case "solid":
			y += " edge-pattern-solid";
			break;
		case "dotted":
			y += " edge-pattern-dotted";
			break;
		case "dashed": y += " edge-pattern-dashed";
	}
	let v = e.append("path").attr("d", m(d)).attr("id", r.id).attr("class", " " + y + (r.classes ? " " + r.classes : "")).attr("style", r.style), x = "";
	(IA().flowchart.arrowMarkerAbsolute || IA().state.arrowMarkerAbsolute) && (x = MU(!0)), ZA(v, r, x, s, n);
	let b = {};
	return l && (b.updatedPath = o), b.originalPath = r.points, b;
}, "insertEdge"), Zz = h((e) => {
	let t = /* @__PURE__ */ new Set();
	for (let r of e) switch (r) {
		case "x":
			t.add("right"), t.add("left");
			break;
		case "y":
			t.add("up"), t.add("down");
			break;
		default: t.add(r);
	}
	return t;
}, "expandAndDeduplicateDirections"), ZU = h((e, t, r) => {
	let i = Zz(e), n = t.height + 2 * r.padding, a = n / 2, s = t.width + 2 * a + r.padding, o = r.padding / 2;
	return i.has("right") && i.has("left") && i.has("up") && i.has("down") ? [
		{
			x: 0,
			y: 0
		},
		{
			x: a,
			y: 0
		},
		{
			x: s / 2,
			y: 2 * o
		},
		{
			x: s - a,
			y: 0
		},
		{
			x: s,
			y: 0
		},
		{
			x: s,
			y: -n / 3
		},
		{
			x: s + 2 * o,
			y: -n / 2
		},
		{
			x: s,
			y: -2 * n / 3
		},
		{
			x: s,
			y: -n
		},
		{
			x: s - a,
			y: -n
		},
		{
			x: s / 2,
			y: -n - 2 * o
		},
		{
			x: a,
			y: -n
		},
		{
			x: 0,
			y: -n
		},
		{
			x: 0,
			y: -2 * n / 3
		},
		{
			x: -2 * o,
			y: -n / 2
		},
		{
			x: 0,
			y: -n / 3
		}
	] : i.has("right") && i.has("left") && i.has("up") ? [
		{
			x: a,
			y: 0
		},
		{
			x: s - a,
			y: 0
		},
		{
			x: s,
			y: -n / 2
		},
		{
			x: s - a,
			y: -n
		},
		{
			x: a,
			y: -n
		},
		{
			x: 0,
			y: -n / 2
		}
	] : i.has("right") && i.has("left") && i.has("down") ? [
		{
			x: 0,
			y: 0
		},
		{
			x: a,
			y: -n
		},
		{
			x: s - a,
			y: -n
		},
		{
			x: s,
			y: 0
		}
	] : i.has("right") && i.has("up") && i.has("down") ? [
		{
			x: 0,
			y: 0
		},
		{
			x: s,
			y: -a
		},
		{
			x: s,
			y: -n + a
		},
		{
			x: 0,
			y: -n
		}
	] : i.has("left") && i.has("up") && i.has("down") ? [
		{
			x: s,
			y: 0
		},
		{
			x: 0,
			y: -a
		},
		{
			x: 0,
			y: -n + a
		},
		{
			x: s,
			y: -n
		}
	] : i.has("right") && i.has("left") ? [
		{
			x: a,
			y: 0
		},
		{
			x: a,
			y: -o
		},
		{
			x: s - a,
			y: -o
		},
		{
			x: s - a,
			y: 0
		},
		{
			x: s,
			y: -n / 2
		},
		{
			x: s - a,
			y: -n
		},
		{
			x: s - a,
			y: -n + o
		},
		{
			x: a,
			y: -n + o
		},
		{
			x: a,
			y: -n
		},
		{
			x: 0,
			y: -n / 2
		}
	] : i.has("up") && i.has("down") ? [
		{
			x: s / 2,
			y: 0
		},
		{
			x: 0,
			y: -o
		},
		{
			x: a,
			y: -o
		},
		{
			x: a,
			y: -n + o
		},
		{
			x: 0,
			y: -n + o
		},
		{
			x: s / 2,
			y: -n
		},
		{
			x: s,
			y: -n + o
		},
		{
			x: s - a,
			y: -n + o
		},
		{
			x: s - a,
			y: -o
		},
		{
			x: s,
			y: -o
		}
	] : i.has("right") && i.has("up") ? [
		{
			x: 0,
			y: 0
		},
		{
			x: s,
			y: -a
		},
		{
			x: 0,
			y: -n
		}
	] : i.has("right") && i.has("down") ? [
		{
			x: 0,
			y: 0
		},
		{
			x: s,
			y: 0
		},
		{
			x: 0,
			y: -n
		}
	] : i.has("left") && i.has("up") ? [
		{
			x: s,
			y: 0
		},
		{
			x: 0,
			y: -a
		},
		{
			x: s,
			y: -n
		}
	] : i.has("left") && i.has("down") ? [
		{
			x: s,
			y: 0
		},
		{
			x: 0,
			y: 0
		},
		{
			x: s,
			y: -n
		}
	] : i.has("right") ? [
		{
			x: a,
			y: -o
		},
		{
			x: a,
			y: -o
		},
		{
			x: s - a,
			y: -o
		},
		{
			x: s - a,
			y: 0
		},
		{
			x: s,
			y: -n / 2
		},
		{
			x: s - a,
			y: -n
		},
		{
			x: s - a,
			y: -n + o
		},
		{
			x: a,
			y: -n + o
		},
		{
			x: a,
			y: -n + o
		}
	] : i.has("left") ? [
		{
			x: a,
			y: 0
		},
		{
			x: a,
			y: -o
		},
		{
			x: s - a,
			y: -o
		},
		{
			x: s - a,
			y: -n + o
		},
		{
			x: a,
			y: -n + o
		},
		{
			x: a,
			y: -n
		},
		{
			x: 0,
			y: -n / 2
		}
	] : i.has("up") ? [
		{
			x: a,
			y: -o
		},
		{
			x: a,
			y: -n + o
		},
		{
			x: 0,
			y: -n + o
		},
		{
			x: s / 2,
			y: -n
		},
		{
			x: s,
			y: -n + o
		},
		{
			x: s - a,
			y: -n + o
		},
		{
			x: s - a,
			y: -o
		}
	] : i.has("down") ? [
		{
			x: s / 2,
			y: 0
		},
		{
			x: 0,
			y: -o
		},
		{
			x: a,
			y: -o
		},
		{
			x: a,
			y: -n + o
		},
		{
			x: s - a,
			y: -n + o
		},
		{
			x: s - a,
			y: -o
		},
		{
			x: s,
			y: -o
		}
	] : [{
		x: 0,
		y: 0
	}];
}, "getArrowPoints");
function ZG(e, t) {
	return e.intersect(t);
}
function Zq(e, t, r, i) {
	var n = e.x, a = e.y, s = n - i.x, o = a - i.y, l = Math.sqrt(t * t * o * o + r * r * s * s), h = Math.abs(t * r * s / l);
	i.x < n && (h = -h);
	var u = Math.abs(t * r * o / l);
	return i.y < a && (u = -u), {
		x: n + h,
		y: a + u
	};
}
function Zj(e, t, r) {
	return Zq(e, t, t, r);
}
function ZW(e, t, r, i) {
	var n, a, s, o, l, h, u, d, p, f, g, m, y;
	if (n = t.y - e.y, s = e.x - t.x, l = t.x * e.y - e.x * t.y, p = n * r.x + s * r.y + l, f = n * i.x + s * i.y + l, !(0 !== p && 0 !== f && ZY(p, f)) && (a = i.y - r.y, o = r.x - i.x, h = i.x * r.y - r.x * i.y, u = a * e.x + o * e.y + h, d = a * t.x + o * t.y + h, !(0 !== u && 0 !== d && ZY(u, d)) && 0 != (g = n * o - a * s))) return m = Math.abs(g / 2), {
		x: (y = s * h - o * l) < 0 ? (y - m) / g : (y + m) / g,
		y: (y = a * l - n * h) < 0 ? (y - m) / g : (y + m) / g
	};
}
function ZY(e, t) {
	return e * t > 0;
}
function ZV(e, t, r) {
	var i = e.x, n = e.y, a = [], s = Infinity, o = Infinity;
	"function" == typeof t.forEach ? t.forEach(function(e) {
		s = Math.min(s, e.x), o = Math.min(o, e.y);
	}) : (s = Math.min(s, t.x), o = Math.min(o, t.y));
	for (var l = i - e.width / 2 - s, h = n - e.height / 2 - o, u = 0; u < t.length; u++) {
		var d = t[u], p = t[u < t.length - 1 ? u + 1 : 0], f = ZW(e, r, {
			x: l + d.x,
			y: h + d.y
		}, {
			x: l + p.x,
			y: h + p.y
		});
		f && a.push(f);
	}
	return a.length ? (a.length > 1 && a.sort(function(e, t) {
		var i = e.x - r.x, n = e.y - r.y, a = Math.sqrt(i * i + n * n), s = t.x - r.x, o = t.y - r.y, l = Math.sqrt(s * s + o * o);
		return a < l ? -1 : +(a !== l);
	}), a[0]) : e;
}
h(ZG, "intersectNode"), h(Zq, "intersectEllipse"), h(Zj, "intersectCircle"), h(ZW, "intersectLine"), h(ZY, "sameSign"), h(ZV, "intersectPolygon");
var ZH = {
	node: ZG,
	circle: Zj,
	ellipse: Zq,
	polygon: ZV,
	rect: h((e, t) => {
		var r, i, n = e.x, a = e.y, s = t.x - n, o = t.y - a, l = e.width / 2, h = e.height / 2;
		return Math.abs(o) * l > Math.abs(s) * h ? (o < 0 && (h = -h), r = 0 === o ? 0 : h * s / o, i = h) : (s < 0 && (l = -l), r = l, i = 0 === s ? 0 : l * o / s), {
			x: n + r,
			y: a + i
		};
	}, "intersectRect")
}, ZX = h(async (e, t, r, i) => {
	let n = IA(), a = t.useHtmlLabels || MG(n.flowchart.htmlLabels), s = e.insert("g").attr("class", r || "node default").attr("id", t.domId || t.id), o = s.insert("g").attr("class", "label").attr("style", t.labelStyle), l;
	l = void 0 === t.labelText ? "" : "string" == typeof t.labelText ? t.labelText : t.labelText[0];
	let u = o.node(), d, p = (d = "markdown" === t.labelType ? XQ(o, MO(V6(l), n), {
		useHtmlLabels: a,
		width: t.width || n.flowchart.wrappingWidth,
		classes: "markdown-node-label"
	}, n) : u.appendChild(await ZS(MO(V6(l), n), t.labelStyle, !1, i))).getBBox(), f = t.padding / 2;
	if (MG(n.flowchart.htmlLabels)) {
		let e = d.children[0], t = _t(d), r = e.getElementsByTagName("img");
		if (r) {
			let e = "" === l.replace(/<img[^>]*>/g, "").trim();
			await Promise.all([...r].map((t) => new Promise((r) => {
				function i() {
					if (t.style.display = "flex", t.style.flexDirection = "column", e) {
						let e = 5 * parseInt(n.fontSize ? n.fontSize : window.getComputedStyle(document.body).fontSize, 10) + "px";
						t.style.minWidth = e, t.style.maxWidth = e;
					} else t.style.width = "100%";
					r(t);
				}
				h(i, "setupImage"), setTimeout(() => {
					t.complete && i();
				}), t.addEventListener("error", i), t.addEventListener("load", i);
			})));
		}
		p = e.getBoundingClientRect(), t.attr("width", p.width), t.attr("height", p.height);
	}
	return a ? o.attr("transform", "translate(" + -p.width / 2 + ", " + -p.height / 2 + ")") : o.attr("transform", "translate(0, " + -p.height / 2 + ")"), t.centerLabel && o.attr("transform", "translate(" + -p.width / 2 + ", " + -p.height / 2 + ")"), o.insert("rect", ":first-child"), {
		shapeSvg: s,
		bbox: p,
		halfPadding: f,
		label: o
	};
}, "labelHelper"), ZK = h((e, t) => {
	let r = t.node().getBBox();
	e.width = r.width, e.height = r.height;
}, "updateNodeBounds");
function ZZ(e, t, r, i) {
	return e.insert("polygon", ":first-child").attr("points", i.map(function(e) {
		return e.x + "," + e.y;
	}).join(" ")).attr("class", "label-container").attr("transform", "translate(" + -t / 2 + "," + r / 2 + ")");
}
h(ZZ, "insertPolygonShape");
var ZQ = h(async (e, t) => {
	t.useHtmlLabels || IA().flowchart.htmlLabels || (t.centerLabel = !0);
	let { shapeSvg: r, bbox: i, halfPadding: n } = await ZX(e, t, "node " + t.classes, !0);
	wQ.info("Classes = ", t.classes);
	let a = r.insert("rect", ":first-child");
	return a.attr("rx", t.rx).attr("ry", t.ry).attr("x", -i.width / 2 - n).attr("y", -i.height / 2 - n).attr("width", i.width + t.padding).attr("height", i.height + t.padding), ZK(t, a), t.intersect = function(e) {
		return ZH.rect(t, e);
	}, r;
}, "note"), ZJ = h((e) => e ? " " + e : "", "formatClass"), Z0 = h((e, t) => `${t || "node default"}${ZJ(e.classes)} ${ZJ(e.class)}`, "getClassesFromNode"), Z1 = h(async (e, t) => {
	let { shapeSvg: r, bbox: i } = await ZX(e, t, Z0(t, void 0), !0), n = i.width + t.padding + (i.height + t.padding), a = [
		{
			x: n / 2,
			y: 0
		},
		{
			x: n,
			y: -n / 2
		},
		{
			x: n / 2,
			y: -n
		},
		{
			x: 0,
			y: -n / 2
		}
	];
	wQ.info("Question main (Circle)");
	let s = ZZ(r, n, n, a);
	return s.attr("style", t.style), ZK(t, s), t.intersect = function(e) {
		return wQ.warn("Intersect called"), ZH.polygon(t, a, e);
	}, r;
}, "question"), Z2 = h((e, t) => {
	let r = e.insert("g").attr("class", "node default").attr("id", t.domId || t.id);
	return r.insert("polygon", ":first-child").attr("points", [
		{
			x: 0,
			y: 14
		},
		{
			x: 14,
			y: 0
		},
		{
			x: 0,
			y: -14
		},
		{
			x: -14,
			y: 0
		}
	].map(function(e) {
		return e.x + "," + e.y;
	}).join(" ")).attr("class", "state-start").attr("r", 7).attr("width", 28).attr("height", 28), t.width = 28, t.height = 28, t.intersect = function(e) {
		return ZH.circle(t, 14, e);
	}, r;
}, "choice"), Z4 = h(async (e, t) => {
	let { shapeSvg: r, bbox: i } = await ZX(e, t, Z0(t, void 0), !0), n = i.height + t.padding, a = n / 4, s = i.width + 2 * a + t.padding, o = [
		{
			x: a,
			y: 0
		},
		{
			x: s - a,
			y: 0
		},
		{
			x: s,
			y: -n / 2
		},
		{
			x: s - a,
			y: -n
		},
		{
			x: a,
			y: -n
		},
		{
			x: 0,
			y: -n / 2
		}
	], l = ZZ(r, s, n, o);
	return l.attr("style", t.style), ZK(t, l), t.intersect = function(e) {
		return ZH.polygon(t, o, e);
	}, r;
}, "hexagon"), Z5 = h(async (e, t) => {
	let { shapeSvg: r, bbox: i } = await ZX(e, t, void 0, !0), n = i.height + 2 * t.padding, a = n / 2, s = i.width + 2 * a + t.padding, o = ZU(t.directions, i, t), l = ZZ(r, s, n, o);
	return l.attr("style", t.style), ZK(t, l), t.intersect = function(e) {
		return ZH.polygon(t, o, e);
	}, r;
}, "block_arrow"), Z3 = h(async (e, t) => {
	let { shapeSvg: r, bbox: i } = await ZX(e, t, Z0(t, void 0), !0), n = i.width + t.padding, a = i.height + t.padding, s = [
		{
			x: -a / 2,
			y: 0
		},
		{
			x: n,
			y: 0
		},
		{
			x: n,
			y: -a
		},
		{
			x: -a / 2,
			y: -a
		},
		{
			x: 0,
			y: -a / 2
		}
	];
	return ZZ(r, n, a, s).attr("style", t.style), t.width = n + a, t.height = a, t.intersect = function(e) {
		return ZH.polygon(t, s, e);
	}, r;
}, "rect_left_inv_arrow"), Z6 = h(async (e, t) => {
	let { shapeSvg: r, bbox: i } = await ZX(e, t, Z0(t), !0), n = i.width + t.padding, a = i.height + t.padding, s = [
		{
			x: -2 * a / 6,
			y: 0
		},
		{
			x: n - a / 6,
			y: 0
		},
		{
			x: n + 2 * a / 6,
			y: -a
		},
		{
			x: a / 6,
			y: -a
		}
	], o = ZZ(r, n, a, s);
	return o.attr("style", t.style), ZK(t, o), t.intersect = function(e) {
		return ZH.polygon(t, s, e);
	}, r;
}, "lean_right"), Z7 = h(async (e, t) => {
	let { shapeSvg: r, bbox: i } = await ZX(e, t, Z0(t, void 0), !0), n = i.width + t.padding, a = i.height + t.padding, s = [
		{
			x: 2 * a / 6,
			y: 0
		},
		{
			x: n + a / 6,
			y: 0
		},
		{
			x: n - 2 * a / 6,
			y: -a
		},
		{
			x: -a / 6,
			y: -a
		}
	], o = ZZ(r, n, a, s);
	return o.attr("style", t.style), ZK(t, o), t.intersect = function(e) {
		return ZH.polygon(t, s, e);
	}, r;
}, "lean_left"), Z8 = h(async (e, t) => {
	let { shapeSvg: r, bbox: i } = await ZX(e, t, Z0(t, void 0), !0), n = i.width + t.padding, a = i.height + t.padding, s = [
		{
			x: -2 * a / 6,
			y: 0
		},
		{
			x: n + 2 * a / 6,
			y: 0
		},
		{
			x: n - a / 6,
			y: -a
		},
		{
			x: a / 6,
			y: -a
		}
	], o = ZZ(r, n, a, s);
	return o.attr("style", t.style), ZK(t, o), t.intersect = function(e) {
		return ZH.polygon(t, s, e);
	}, r;
}, "trapezoid"), Z9 = h(async (e, t) => {
	let { shapeSvg: r, bbox: i } = await ZX(e, t, Z0(t, void 0), !0), n = i.width + t.padding, a = i.height + t.padding, s = [
		{
			x: a / 6,
			y: 0
		},
		{
			x: n - a / 6,
			y: 0
		},
		{
			x: n + 2 * a / 6,
			y: -a
		},
		{
			x: -2 * a / 6,
			y: -a
		}
	], o = ZZ(r, n, a, s);
	return o.attr("style", t.style), ZK(t, o), t.intersect = function(e) {
		return ZH.polygon(t, s, e);
	}, r;
}, "inv_trapezoid"), Qe = h(async (e, t) => {
	let { shapeSvg: r, bbox: i } = await ZX(e, t, Z0(t, void 0), !0), n = i.width + t.padding, a = i.height + t.padding, s = [
		{
			x: 0,
			y: 0
		},
		{
			x: n + a / 2,
			y: 0
		},
		{
			x: n,
			y: -a / 2
		},
		{
			x: n + a / 2,
			y: -a
		},
		{
			x: 0,
			y: -a
		}
	], o = ZZ(r, n, a, s);
	return o.attr("style", t.style), ZK(t, o), t.intersect = function(e) {
		return ZH.polygon(t, s, e);
	}, r;
}, "rect_right_inv_arrow"), Qt = h(async (e, t) => {
	let { shapeSvg: r, bbox: i } = await ZX(e, t, Z0(t, void 0), !0), n = i.width + t.padding, a = n / 2, s = a / (2.5 + n / 50), o = i.height + s + t.padding, l = "M 0," + s + " a " + a + "," + s + " 0,0,0 " + n + " 0 a " + a + "," + s + " 0,0,0 " + -n + " 0 l 0," + o + " a " + a + "," + s + " 0,0,0 " + n + " 0 l 0," + -o;
	return ZK(t, r.attr("label-offset-y", s).insert("path", ":first-child").attr("style", t.style).attr("d", l).attr("transform", "translate(" + -n / 2 + "," + -(o / 2 + s) + ")")), t.intersect = function(e) {
		let r = ZH.rect(t, e), i = r.x - t.x;
		if (0 != a && (Math.abs(i) < t.width / 2 || Math.abs(i) == t.width / 2 && Math.abs(r.y - t.y) > t.height / 2 - s)) {
			let n = s * s * (1 - i * i / (a * a));
			0 != n && (n = Math.sqrt(n)), n = s - n, e.y - t.y > 0 && (n = -n), r.y += n;
		}
		return r;
	}, r;
}, "cylinder"), Qr = h(async (e, t) => {
	let { shapeSvg: r, bbox: i, halfPadding: n } = await ZX(e, t, "node " + t.classes + " " + t.class, !0), a = r.insert("rect", ":first-child"), s = t.positioned ? t.width : i.width + t.padding, o = t.positioned ? t.height : i.height + t.padding, l = t.positioned ? -s / 2 : -i.width / 2 - n, h = t.positioned ? -o / 2 : -i.height / 2 - n;
	if (a.attr("class", "basic label-container").attr("style", t.style).attr("rx", t.rx).attr("ry", t.ry).attr("x", l).attr("y", h).attr("width", s).attr("height", o), t.props) {
		let e = new Set(Object.keys(t.props));
		t.props.borders && (Qa(a, t.props.borders, s, o), e.delete("borders")), e.forEach((e) => {
			wQ.warn(`Unknown node property ${e}`);
		});
	}
	return ZK(t, a), t.intersect = function(e) {
		return ZH.rect(t, e);
	}, r;
}, "rect"), Qi = h(async (e, t) => {
	let { shapeSvg: r, bbox: i, halfPadding: n } = await ZX(e, t, "node " + t.classes, !0), a = r.insert("rect", ":first-child"), s = t.positioned ? t.width : i.width + t.padding, o = t.positioned ? t.height : i.height + t.padding, l = t.positioned ? -s / 2 : -i.width / 2 - n, h = t.positioned ? -o / 2 : -i.height / 2 - n;
	if (a.attr("class", "basic cluster composite label-container").attr("style", t.style).attr("rx", t.rx).attr("ry", t.ry).attr("x", l).attr("y", h).attr("width", s).attr("height", o), t.props) {
		let e = new Set(Object.keys(t.props));
		t.props.borders && (Qa(a, t.props.borders, s, o), e.delete("borders")), e.forEach((e) => {
			wQ.warn(`Unknown node property ${e}`);
		});
	}
	return ZK(t, a), t.intersect = function(e) {
		return ZH.rect(t, e);
	}, r;
}, "composite"), Qn = h(async (e, t) => {
	let { shapeSvg: r } = await ZX(e, t, "label", !0);
	wQ.trace("Classes = ", t.class);
	let i = r.insert("rect", ":first-child");
	if (i.attr("width", 0).attr("height", 0), r.attr("class", "label edgeLabel"), t.props) {
		let e = new Set(Object.keys(t.props));
		t.props.borders && (Qa(i, t.props.borders, 0, 0), e.delete("borders")), e.forEach((e) => {
			wQ.warn(`Unknown node property ${e}`);
		});
	}
	return ZK(t, i), t.intersect = function(e) {
		return ZH.rect(t, e);
	}, r;
}, "labelRect");
function Qa(e, t, r, i) {
	let n = [], a = h((e) => {
		n.push(e, 0);
	}, "addBorder"), s = h((e) => {
		n.push(0, e);
	}, "skipBorder");
	t.includes("t") ? (wQ.debug("add top border"), a(r)) : s(r), t.includes("r") ? (wQ.debug("add right border"), a(i)) : s(i), t.includes("b") ? (wQ.debug("add bottom border"), a(r)) : s(r), t.includes("l") ? (wQ.debug("add left border"), a(i)) : s(i), e.attr("stroke-dasharray", n.join(" "));
}
h(Qa, "applyNodePropertyBorders");
var Qs = h(async (e, t) => {
	let r;
	r = t.classes ? "node " + t.classes : "node default";
	let i = e.insert("g").attr("class", r).attr("id", t.domId || t.id), n = i.insert("rect", ":first-child"), a = i.insert("line"), s = i.insert("g").attr("class", "label"), o = t.labelText.flat ? t.labelText.flat() : t.labelText, l = "";
	l = "object" == typeof o ? o[0] : o, wQ.info("Label text abc79", l, o, "object" == typeof o);
	let h = s.node().appendChild(await ZS(l, t.labelStyle, !0, !0)), u = {
		width: 0,
		height: 0
	};
	if (MG(IA().flowchart.htmlLabels)) {
		let e = h.children[0], t = _t(h);
		u = e.getBoundingClientRect(), t.attr("width", u.width), t.attr("height", u.height);
	}
	wQ.info("Text 2", o);
	let d = o.slice(1, o.length), p = h.getBBox(), f = s.node().appendChild(await ZS(d.join ? d.join("<br/>") : d, t.labelStyle, !0, !0));
	if (MG(IA().flowchart.htmlLabels)) {
		let e = f.children[0], t = _t(f);
		u = e.getBoundingClientRect(), t.attr("width", u.width), t.attr("height", u.height);
	}
	let g = t.padding / 2;
	return _t(f).attr("transform", "translate( " + (u.width > p.width ? 0 : (p.width - u.width) / 2) + ", " + (p.height + g + 5) + ")"), _t(h).attr("transform", "translate( " + (u.width < p.width ? 0 : -(p.width - u.width) / 2) + ", 0)"), u = s.node().getBBox(), s.attr("transform", "translate(" + -u.width / 2 + ", " + (-u.height / 2 - g + 3) + ")"), n.attr("class", "outer title-state").attr("x", -u.width / 2 - g).attr("y", -u.height / 2 - g).attr("width", u.width + t.padding).attr("height", u.height + t.padding), a.attr("class", "divider").attr("x1", -u.width / 2 - g).attr("x2", u.width / 2 + g).attr("y1", -u.height / 2 - g + p.height + g).attr("y2", -u.height / 2 - g + p.height + g), ZK(t, n), t.intersect = function(e) {
		return ZH.rect(t, e);
	}, i;
}, "rectWithTitle"), Qo = h(async (e, t) => {
	let { shapeSvg: r, bbox: i } = await ZX(e, t, Z0(t, void 0), !0), n = i.height + t.padding, a = i.width + n / 4 + t.padding;
	return ZK(t, r.insert("rect", ":first-child").attr("style", t.style).attr("rx", n / 2).attr("ry", n / 2).attr("x", -a / 2).attr("y", -n / 2).attr("width", a).attr("height", n)), t.intersect = function(e) {
		return ZH.rect(t, e);
	}, r;
}, "stadium"), Ql = h(async (e, t) => {
	let { shapeSvg: r, bbox: i, halfPadding: n } = await ZX(e, t, Z0(t, void 0), !0), a = r.insert("circle", ":first-child");
	return a.attr("style", t.style).attr("rx", t.rx).attr("ry", t.ry).attr("r", i.width / 2 + n).attr("width", i.width + t.padding).attr("height", i.height + t.padding), wQ.info("Circle main"), ZK(t, a), t.intersect = function(e) {
		return wQ.info("Circle intersect", t, i.width / 2 + n, e), ZH.circle(t, i.width / 2 + n, e);
	}, r;
}, "circle"), Qc = h(async (e, t) => {
	let { shapeSvg: r, bbox: i, halfPadding: n } = await ZX(e, t, Z0(t, void 0), !0), a = r.insert("g", ":first-child"), s = a.insert("circle"), o = a.insert("circle");
	return a.attr("class", t.class), s.attr("style", t.style).attr("rx", t.rx).attr("ry", t.ry).attr("r", i.width / 2 + n + 5).attr("width", i.width + t.padding + 10).attr("height", i.height + t.padding + 10), o.attr("style", t.style).attr("rx", t.rx).attr("ry", t.ry).attr("r", i.width / 2 + n).attr("width", i.width + t.padding).attr("height", i.height + t.padding), wQ.info("DoubleCircle main"), ZK(t, s), t.intersect = function(e) {
		return wQ.info("DoubleCircle intersect", t, i.width / 2 + n + 5, e), ZH.circle(t, i.width / 2 + n + 5, e);
	}, r;
}, "doublecircle"), Qh = h(async (e, t) => {
	let { shapeSvg: r, bbox: i } = await ZX(e, t, Z0(t, void 0), !0), n = i.width + t.padding, a = i.height + t.padding, s = [
		{
			x: 0,
			y: 0
		},
		{
			x: n,
			y: 0
		},
		{
			x: n,
			y: -a
		},
		{
			x: 0,
			y: -a
		},
		{
			x: 0,
			y: 0
		},
		{
			x: -8,
			y: 0
		},
		{
			x: n + 8,
			y: 0
		},
		{
			x: n + 8,
			y: -a
		},
		{
			x: -8,
			y: -a
		},
		{
			x: -8,
			y: 0
		}
	], o = ZZ(r, n, a, s);
	return o.attr("style", t.style), ZK(t, o), t.intersect = function(e) {
		return ZH.polygon(t, s, e);
	}, r;
}, "subroutine"), Qu = h((e, t) => {
	let r = e.insert("g").attr("class", "node default").attr("id", t.domId || t.id), i = r.insert("circle", ":first-child");
	return i.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14), ZK(t, i), t.intersect = function(e) {
		return ZH.circle(t, 7, e);
	}, r;
}, "start"), Qd = h((e, t, r) => {
	let i = e.insert("g").attr("class", "node default").attr("id", t.domId || t.id), n = 70, a = 10;
	return "LR" === r && (n = 10, a = 70), ZK(t, i.append("rect").attr("x", -1 * n / 2).attr("y", -1 * a / 2).attr("width", n).attr("height", a).attr("class", "fork-join")), t.height = t.height + t.padding / 2, t.width = t.width + t.padding / 2, t.intersect = function(e) {
		return ZH.rect(t, e);
	}, i;
}, "forkJoin"), Qp = {
	rhombus: Z1,
	composite: Qi,
	question: Z1,
	rect: Qr,
	labelRect: Qn,
	rectWithTitle: Qs,
	choice: Z2,
	circle: Ql,
	doublecircle: Qc,
	stadium: Qo,
	hexagon: Z4,
	block_arrow: Z5,
	rect_left_inv_arrow: Z3,
	lean_right: Z6,
	lean_left: Z7,
	trapezoid: Z8,
	inv_trapezoid: Z9,
	rect_right_inv_arrow: Qe,
	cylinder: Qt,
	start: Qu,
	end: h((e, t) => {
		let r = e.insert("g").attr("class", "node default").attr("id", t.domId || t.id), i = r.insert("circle", ":first-child"), n = r.insert("circle", ":first-child");
		return n.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14), i.attr("class", "state-end").attr("r", 5).attr("width", 10).attr("height", 10), ZK(t, n), t.intersect = function(e) {
			return ZH.circle(t, 7, e);
		}, r;
	}, "end"),
	note: ZQ,
	subroutine: Qh,
	fork: Qd,
	join: Qd,
	class_box: h(async (e, t) => {
		let r = t.padding / 2, i;
		i = t.classes ? "node " + t.classes : "node default";
		let n = e.insert("g").attr("class", i).attr("id", t.domId || t.id), a = n.insert("rect", ":first-child"), s = n.insert("line"), o = n.insert("line"), l = 0, h = 4, u = n.insert("g").attr("class", "label"), d = 0, p = t.classData.annotations?.[0], f = t.classData.annotations[0] ? "" + t.classData.annotations[0] + "" : "", g = u.node().appendChild(await ZS(f, t.labelStyle, !0, !0)), m = g.getBBox();
		if (MG(IA().flowchart.htmlLabels)) {
			let e = g.children[0], t = _t(g);
			m = e.getBoundingClientRect(), t.attr("width", m.width), t.attr("height", m.height);
		}
		t.classData.annotations[0] && (h += m.height + 4, l += m.width);
		let y = t.classData.label;
		void 0 !== t.classData.type && "" !== t.classData.type && (IA().flowchart.htmlLabels ? y += "&lt;" + t.classData.type + "&gt;" : y += "<" + t.classData.type + ">");
		let v = u.node().appendChild(await ZS(y, t.labelStyle, !0, !0));
		_t(v).attr("class", "classTitle");
		let x = v.getBBox();
		if (MG(IA().flowchart.htmlLabels)) {
			let e = v.children[0], t = _t(v);
			x = e.getBoundingClientRect(), t.attr("width", x.width), t.attr("height", x.height);
		}
		h += x.height + 4, x.width > l && (l = x.width);
		let b = [];
		t.classData.members.forEach(async (e) => {
			let r = e.getDisplayDetails(), i = r.displayText;
			IA().flowchart.htmlLabels && (i = i.replace(/</g, "&lt;").replace(/>/g, "&gt;"));
			let n = u.node().appendChild(await ZS(i, r.cssStyle ? r.cssStyle : t.labelStyle, !0, !0)), a = n.getBBox();
			if (MG(IA().flowchart.htmlLabels)) {
				let e = n.children[0], t = _t(n);
				a = e.getBoundingClientRect(), t.attr("width", a.width), t.attr("height", a.height);
			}
			a.width > l && (l = a.width), h += a.height + 4, b.push(n);
		}), h += 8;
		let w = [];
		if (t.classData.methods.forEach(async (e) => {
			let r = e.getDisplayDetails(), i = r.displayText;
			IA().flowchart.htmlLabels && (i = i.replace(/</g, "&lt;").replace(/>/g, "&gt;"));
			let n = u.node().appendChild(await ZS(i, r.cssStyle ? r.cssStyle : t.labelStyle, !0, !0)), a = n.getBBox();
			if (MG(IA().flowchart.htmlLabels)) {
				let e = n.children[0], t = _t(n);
				a = e.getBoundingClientRect(), t.attr("width", a.width), t.attr("height", a.height);
			}
			a.width > l && (l = a.width), h += a.height + 4, w.push(n);
		}), h += 8, p) {
			let e = (l - m.width) / 2;
			_t(g).attr("transform", "translate( " + (-1 * l / 2 + e) + ", " + -1 * h / 2 + ")"), d = m.height + 4;
		}
		let k = (l - x.width) / 2;
		return _t(v).attr("transform", "translate( " + (-1 * l / 2 + k) + ", " + (-1 * h / 2 + d) + ")"), d += x.height + 4, s.attr("class", "divider").attr("x1", -l / 2 - r).attr("x2", l / 2 + r).attr("y1", -h / 2 - r + 8 + d).attr("y2", -h / 2 - r + 8 + d), d += 8, b.forEach((e) => {
			_t(e).attr("transform", "translate( " + -l / 2 + ", " + (-1 * h / 2 + d + 4) + ")");
			let t = e?.getBBox();
			d += (t?.height ?? 0) + 4;
		}), d += 8, o.attr("class", "divider").attr("x1", -l / 2 - r).attr("x2", l / 2 + r).attr("y1", -h / 2 - r + 8 + d).attr("y2", -h / 2 - r + 8 + d), d += 8, w.forEach((e) => {
			_t(e).attr("transform", "translate( " + -l / 2 + ", " + (-1 * h / 2 + d) + ")");
			let t = e?.getBBox();
			d += (t?.height ?? 0) + 4;
		}), a.attr("style", t.style).attr("class", "outer title-state").attr("x", -l / 2 - r).attr("y", -(h / 2) - r).attr("width", l + t.padding).attr("height", h + t.padding), ZK(t, a), t.intersect = function(e) {
			return ZH.rect(t, e);
		}, n;
	}, "class_box")
}, Qf = {}, Qg = h(async (e, t, r) => {
	let i, n;
	if (t.link) {
		let a;
		"sandbox" === IA().securityLevel ? a = "_top" : t.linkTarget && (a = t.linkTarget || "_blank"), i = e.insert("svg:a").attr("xlink:href", t.link).attr("target", a), n = await Qp[t.shape](i, t, r);
	} else i = n = await Qp[t.shape](e, t, r);
	return t.tooltip && n.attr("title", t.tooltip), t.class && n.attr("class", "node default " + t.class), Qf[t.id] = i, t.haveCallback && Qf[t.id].attr("class", Qf[t.id].attr("class") + " clickable"), i;
}, "insertNode"), Qm = h((e) => {
	let t = Qf[e.id];
	wQ.trace("Transforming node", e.diff, e, "translate(" + (e.x - e.width / 2 - 5) + ", " + e.width / 2 + ")");
	let r = e.diff || 0;
	return e.clusterNode ? t.attr("transform", "translate(" + (e.x + r - e.width / 2) + ", " + (e.y - e.height / 2 - 8) + ")") : t.attr("transform", "translate(" + e.x + ", " + e.y + ")"), r;
}, "positionNode");
function Qy(e, t, r = !1) {
	let i = "default";
	(e?.classes?.length || 0) > 0 && (i = (e?.classes ?? []).join(" ")), i += " flowchart-label";
	let n = 0, a = "", s;
	switch (e.type) {
		case "round":
			n = 5, a = "rect";
			break;
		case "composite":
			n = 0, a = "composite", s = 0;
			break;
		case "square":
		case "group":
		default:
			a = "rect";
			break;
		case "diamond":
			a = "question";
			break;
		case "hexagon":
			a = "hexagon";
			break;
		case "block_arrow":
			a = "block_arrow";
			break;
		case "odd":
		case "rect_left_inv_arrow":
			a = "rect_left_inv_arrow";
			break;
		case "lean_right":
			a = "lean_right";
			break;
		case "lean_left":
			a = "lean_left";
			break;
		case "trapezoid":
			a = "trapezoid";
			break;
		case "inv_trapezoid":
			a = "inv_trapezoid";
			break;
		case "circle":
			a = "circle";
			break;
		case "ellipse":
			a = "ellipse";
			break;
		case "stadium":
			a = "stadium";
			break;
		case "subroutine":
			a = "subroutine";
			break;
		case "cylinder":
			a = "cylinder";
			break;
		case "doublecircle": a = "doublecircle";
	}
	let o = VB(e?.styles ?? []), l = e.label, h = e.size ?? {
		width: 0,
		height: 0,
		x: 0,
		y: 0
	};
	return {
		labelStyle: o.labelStyle,
		shape: a,
		labelText: l,
		rx: n,
		ry: n,
		class: i,
		style: o.style,
		id: e.id,
		directions: e.directions,
		width: h.width,
		height: h.height,
		x: h.x,
		y: h.y,
		positioned: r,
		intersect: void 0,
		type: e.type,
		padding: s ?? IA()?.block?.padding ?? 0
	};
}
async function Qv(e, t, r) {
	let i = Qy(t, r, !1);
	if ("group" === i.type) return;
	let n = await Qg(e, i, { config: IA() }), a = n.node().getBBox(), s = r.getBlock(i.id);
	s.size = {
		width: a.width,
		height: a.height,
		x: 0,
		y: 0,
		node: n
	}, r.setBlock(s), n.remove();
}
async function Qx(e, t, r) {
	let i = Qy(t, r, !0);
	"space" !== r.getBlock(i.id).type && (await Qg(e, i, { config: IA() }), t.intersect = i?.intersect, Qm(i));
}
async function Qb(e, t, r, i) {
	for (let n of t) await i(e, n, r), n.children && await Qb(e, n.children, r, i);
}
async function Qw(e, t, r) {
	await Qb(e, t, r, Qv);
}
async function Qk(e, t, r) {
	await Qb(e, t, r, Qx);
}
async function QT(e, t, r, i, n) {
	let a = new KD({
		multigraph: !0,
		compound: !0
	});
	for (let e of (a.setGraph({
		rankdir: "TB",
		nodesep: 10,
		ranksep: 10,
		marginx: 8,
		marginy: 8
	}), r)) e.size && a.setNode(e.id, {
		width: e.size.width,
		height: e.size.height,
		intersect: e.intersect
	});
	for (let r of t) if (r.start && r.end) {
		let t = i.getBlock(r.start), s = i.getBlock(r.end);
		if (t?.size && s?.size) {
			let i = t.size, o = s.size, l = [
				{
					x: i.x,
					y: i.y
				},
				{
					x: i.x + (o.x - i.x) / 2,
					y: i.y + (o.y - i.y) / 2
				},
				{
					x: o.x,
					y: o.y
				}
			];
			ZF(e, {
				v: r.start,
				w: r.end,
				name: r.id
			}, {
				...r,
				arrowTypeEnd: r.arrowTypeEnd,
				arrowTypeStart: r.arrowTypeStart,
				points: l,
				classes: "edge-thickness-normal edge-pattern-solid flowchart-link LS-a1 LE-b1"
			}, void 0, "block", a, n), r.label && (await ZM(e, {
				...r,
				label: r.label,
				labelStyle: "stroke: #333; stroke-width: 1.5px;fill:none;",
				arrowTypeEnd: r.arrowTypeEnd,
				arrowTypeStart: r.arrowTypeStart,
				points: l,
				classes: "edge-thickness-normal edge-pattern-solid flowchart-link LS-a1 LE-b1"
			}), ZO({
				...r,
				x: l[1].x,
				y: l[1].y
			}, { originalPath: l }));
		}
	}
}
h(Qy, "getNodeFromBlock"), h(Qv, "calculateBlockSize"), h(Qx, "insertBlockPositioned"), h(Qb, "performOperations"), h(Qw, "calculateBlockSizes"), h(Qk, "insertBlocks"), h(QT, "insertEdges");
var Q_ = h(function(e, t) {
	return t.db.getClasses();
}, "getClasses"), QE = {
	parser: KV,
	db: Zp,
	renderer: {
		draw: h(async function(e, t, r, i) {
			let { securityLevel: n, block: a } = IA(), s = i.db, o;
			"sandbox" === n && (o = _t("#i" + t));
			let l = "sandbox" === n ? _t(o.nodes()[0].contentDocument.body) : _t("body"), h = "sandbox" === n ? l.select(`[id="${t}"]`) : _t(`[id="${t}"]`);
			Zm(h, [
				"point",
				"circle",
				"cross"
			], i.type, t);
			let u = s.getBlocks(), d = s.getBlocksFlat(), p = s.getEdges(), f = h.insert("g").attr("class", "block");
			await Qw(f, u, s);
			let g = Z_(s);
			if (await Qk(f, u, s), await QT(f, p, d, s, t), g) {
				let e = Math.max(1, Math.round(.125 * (g.width / g.height))), t = g.height + e + 10, r = g.width + 10, { useMaxWidth: i } = a;
				M5(h, t, r, !!i), wQ.debug("Here Bounds", g, g), h.attr("viewBox", `${g.x - 5} ${g.y - 5} ${g.width + 10} ${g.height + 10}`);
			}
		}, "draw"),
		getClasses: Q_
	},
	styles: Zg
}, QC = g(Vk(), 1), QS = h((e, t) => {
	let r = e.append("rect");
	if (r.attr("x", t.x), r.attr("y", t.y), r.attr("fill", t.fill), r.attr("stroke", t.stroke), r.attr("width", t.width), r.attr("height", t.height), t.name && r.attr("name", t.name), t.rx && r.attr("rx", t.rx), t.ry && r.attr("ry", t.ry), void 0 !== t.attrs) for (let e in t.attrs) r.attr(e, t.attrs[e]);
	return t.class && r.attr("class", t.class), r;
}, "drawRect"), QA = h((e, t) => {
	QS(e, {
		x: t.startx,
		y: t.starty,
		width: t.stopx - t.startx,
		height: t.stopy - t.starty,
		fill: t.fill,
		stroke: t.stroke,
		class: "rect"
	}).lower();
}, "drawBackgroundRect"), QL = h((e, t) => {
	let r = t.text.replace(ML, " "), i = e.append("text");
	i.attr("x", t.x), i.attr("y", t.y), i.attr("class", "legend"), i.style("text-anchor", t.anchor), t.class && i.attr("class", t.class);
	let n = i.append("tspan");
	return n.attr("x", t.x + 2 * t.textMargin), n.text(r), i;
}, "drawText"), QR = h((e, t, r, i) => {
	let n = e.append("image");
	n.attr("x", t), n.attr("y", r);
	let a = (0, QC.sanitizeUrl)(i);
	n.attr("xlink:href", a);
}, "drawImage"), QN = h((e, t, r, i) => {
	let n = e.append("use");
	n.attr("x", t), n.attr("y", r);
	let a = (0, QC.sanitizeUrl)(i);
	n.attr("xlink:href", `#${a}`);
}, "drawEmbeddedImage"), QI = h(() => ({
	x: 0,
	y: 0,
	width: 100,
	height: 100,
	fill: "#EDF2AE",
	stroke: "#666",
	anchor: "start",
	rx: 0,
	ry: 0
}), "getNoteRect"), QM = h(() => ({
	x: 0,
	y: 0,
	width: 100,
	height: 100,
	"text-anchor": "start",
	style: "#666",
	textMargin: 0,
	rx: 0,
	ry: 0,
	tspan: !0
}), "getTextObj"), QD = function() {
	var e = h(function(e, t, r, i) {
		for (r = r || {}, i = e.length; i--; r[e[i]] = t);
		return r;
	}, "o"), t = [1, 24], r = [1, 25], i = [1, 26], n = [1, 27], a = [1, 28], s = [1, 63], o = [1, 64], l = [1, 65], u = [1, 66], d = [1, 67], p = [1, 68], f = [1, 69], g = [1, 29], m = [1, 30], y = [1, 31], v = [1, 32], x = [1, 33], b = [1, 34], w = [1, 35], k = [1, 36], T = [1, 37], _ = [1, 38], E = [1, 39], C = [1, 40], S = [1, 41], A = [1, 42], L = [1, 43], R = [1, 44], N = [1, 45], I = [1, 46], M = [1, 47], D = [1, 48], O = [1, 50], $ = [1, 51], P = [1, 52], B = [1, 53], F = [1, 54], z = [1, 55], U = [1, 56], G = [1, 57], q = [1, 58], j = [1, 59], W = [1, 60], Y = [14, 42], V = [
		14,
		34,
		36,
		37,
		38,
		39,
		40,
		41,
		42,
		44,
		45,
		46,
		47,
		48,
		49,
		50,
		51,
		52,
		53,
		54,
		55,
		56,
		57,
		58,
		59,
		60,
		61,
		62,
		63,
		64,
		65,
		66,
		67,
		68,
		69,
		70,
		71,
		72,
		73,
		74
	], H = [
		12,
		14,
		34,
		36,
		37,
		38,
		39,
		40,
		41,
		42,
		44,
		45,
		46,
		47,
		48,
		49,
		50,
		51,
		52,
		53,
		54,
		55,
		56,
		57,
		58,
		59,
		60,
		61,
		62,
		63,
		64,
		65,
		66,
		67,
		68,
		69,
		70,
		71,
		72,
		73,
		74
	], X = [1, 82], K = [1, 83], Z = [1, 84], Q = [1, 85], J = [
		12,
		14,
		42
	], ee = [
		12,
		14,
		33,
		42
	], et = [
		12,
		14,
		33,
		42,
		76,
		77,
		79,
		80
	], er = [12, 33], ei = [
		34,
		36,
		37,
		38,
		39,
		40,
		41,
		44,
		45,
		46,
		47,
		48,
		49,
		50,
		51,
		52,
		53,
		54,
		55,
		56,
		57,
		58,
		59,
		60,
		61,
		62,
		63,
		64,
		65,
		66,
		67,
		68,
		69,
		70,
		71,
		72,
		73,
		74
	], en = {
		trace: h(function() {}, "trace"),
		yy: {},
		symbols_: {
			error: 2,
			start: 3,
			mermaidDoc: 4,
			direction: 5,
			direction_tb: 6,
			direction_bt: 7,
			direction_rl: 8,
			direction_lr: 9,
			graphConfig: 10,
			C4_CONTEXT: 11,
			NEWLINE: 12,
			statements: 13,
			EOF: 14,
			C4_CONTAINER: 15,
			C4_COMPONENT: 16,
			C4_DYNAMIC: 17,
			C4_DEPLOYMENT: 18,
			otherStatements: 19,
			diagramStatements: 20,
			otherStatement: 21,
			title: 22,
			accDescription: 23,
			acc_title: 24,
			acc_title_value: 25,
			acc_descr: 26,
			acc_descr_value: 27,
			acc_descr_multiline_value: 28,
			boundaryStatement: 29,
			boundaryStartStatement: 30,
			boundaryStopStatement: 31,
			boundaryStart: 32,
			LBRACE: 33,
			ENTERPRISE_BOUNDARY: 34,
			attributes: 35,
			SYSTEM_BOUNDARY: 36,
			BOUNDARY: 37,
			CONTAINER_BOUNDARY: 38,
			NODE: 39,
			NODE_L: 40,
			NODE_R: 41,
			RBRACE: 42,
			diagramStatement: 43,
			PERSON: 44,
			PERSON_EXT: 45,
			SYSTEM: 46,
			SYSTEM_DB: 47,
			SYSTEM_QUEUE: 48,
			SYSTEM_EXT: 49,
			SYSTEM_EXT_DB: 50,
			SYSTEM_EXT_QUEUE: 51,
			CONTAINER: 52,
			CONTAINER_DB: 53,
			CONTAINER_QUEUE: 54,
			CONTAINER_EXT: 55,
			CONTAINER_EXT_DB: 56,
			CONTAINER_EXT_QUEUE: 57,
			COMPONENT: 58,
			COMPONENT_DB: 59,
			COMPONENT_QUEUE: 60,
			COMPONENT_EXT: 61,
			COMPONENT_EXT_DB: 62,
			COMPONENT_EXT_QUEUE: 63,
			REL: 64,
			BIREL: 65,
			REL_U: 66,
			REL_D: 67,
			REL_L: 68,
			REL_R: 69,
			REL_B: 70,
			REL_INDEX: 71,
			UPDATE_EL_STYLE: 72,
			UPDATE_REL_STYLE: 73,
			UPDATE_LAYOUT_CONFIG: 74,
			attribute: 75,
			STR: 76,
			STR_KEY: 77,
			STR_VALUE: 78,
			ATTRIBUTE: 79,
			ATTRIBUTE_EMPTY: 80,
			$accept: 0,
			$end: 1
		},
		terminals_: {
			2: "error",
			6: "direction_tb",
			7: "direction_bt",
			8: "direction_rl",
			9: "direction_lr",
			11: "C4_CONTEXT",
			12: "NEWLINE",
			14: "EOF",
			15: "C4_CONTAINER",
			16: "C4_COMPONENT",
			17: "C4_DYNAMIC",
			18: "C4_DEPLOYMENT",
			22: "title",
			23: "accDescription",
			24: "acc_title",
			25: "acc_title_value",
			26: "acc_descr",
			27: "acc_descr_value",
			28: "acc_descr_multiline_value",
			33: "LBRACE",
			34: "ENTERPRISE_BOUNDARY",
			36: "SYSTEM_BOUNDARY",
			37: "BOUNDARY",
			38: "CONTAINER_BOUNDARY",
			39: "NODE",
			40: "NODE_L",
			41: "NODE_R",
			42: "RBRACE",
			44: "PERSON",
			45: "PERSON_EXT",
			46: "SYSTEM",
			47: "SYSTEM_DB",
			48: "SYSTEM_QUEUE",
			49: "SYSTEM_EXT",
			50: "SYSTEM_EXT_DB",
			51: "SYSTEM_EXT_QUEUE",
			52: "CONTAINER",
			53: "CONTAINER_DB",
			54: "CONTAINER_QUEUE",
			55: "CONTAINER_EXT",
			56: "CONTAINER_EXT_DB",
			57: "CONTAINER_EXT_QUEUE",
			58: "COMPONENT",
			59: "COMPONENT_DB",
			60: "COMPONENT_QUEUE",
			61: "COMPONENT_EXT",
			62: "COMPONENT_EXT_DB",
			63: "COMPONENT_EXT_QUEUE",
			64: "REL",
			65: "BIREL",
			66: "REL_U",
			67: "REL_D",
			68: "REL_L",
			69: "REL_R",
			70: "REL_B",
			71: "REL_INDEX",
			72: "UPDATE_EL_STYLE",
			73: "UPDATE_REL_STYLE",
			74: "UPDATE_LAYOUT_CONFIG",
			76: "STR",
			77: "STR_KEY",
			78: "STR_VALUE",
			79: "ATTRIBUTE",
			80: "ATTRIBUTE_EMPTY"
		},
		productions_: [
			0,
			[3, 1],
			[3, 1],
			[5, 1],
			[5, 1],
			[5, 1],
			[5, 1],
			[4, 1],
			[10, 4],
			[10, 4],
			[10, 4],
			[10, 4],
			[10, 4],
			[13, 1],
			[13, 1],
			[13, 2],
			[19, 1],
			[19, 2],
			[19, 3],
			[21, 1],
			[21, 1],
			[21, 2],
			[21, 2],
			[21, 1],
			[29, 3],
			[30, 3],
			[30, 3],
			[30, 4],
			[32, 2],
			[32, 2],
			[32, 2],
			[32, 2],
			[32, 2],
			[32, 2],
			[32, 2],
			[31, 1],
			[20, 1],
			[20, 2],
			[20, 3],
			[43, 2],
			[43, 2],
			[43, 2],
			[43, 2],
			[43, 2],
			[43, 2],
			[43, 2],
			[43, 2],
			[43, 2],
			[43, 2],
			[43, 2],
			[43, 2],
			[43, 2],
			[43, 2],
			[43, 2],
			[43, 2],
			[43, 2],
			[43, 2],
			[43, 2],
			[43, 2],
			[43, 1],
			[43, 2],
			[43, 2],
			[43, 2],
			[43, 2],
			[43, 2],
			[43, 2],
			[43, 2],
			[43, 2],
			[43, 2],
			[43, 2],
			[43, 2],
			[35, 1],
			[35, 2],
			[75, 1],
			[75, 2],
			[75, 1],
			[75, 1]
		],
		performAction: h(function(e, t, r, i, n, a, s) {
			var o = a.length - 1;
			switch (n) {
				case 3:
					i.setDirection("TB");
					break;
				case 4:
					i.setDirection("BT");
					break;
				case 5:
					i.setDirection("RL");
					break;
				case 6:
					i.setDirection("LR");
					break;
				case 8:
				case 9:
				case 10:
				case 11:
				case 12:
					i.setC4Type(a[o - 3]);
					break;
				case 19:
					i.setTitle(a[o].substring(6)), this.$ = a[o].substring(6);
					break;
				case 20:
					i.setAccDescription(a[o].substring(15)), this.$ = a[o].substring(15);
					break;
				case 21:
					this.$ = a[o].trim(), i.setTitle(this.$);
					break;
				case 22:
				case 23:
					this.$ = a[o].trim(), i.setAccDescription(this.$);
					break;
				case 28:
					a[o].splice(2, 0, "ENTERPRISE"), i.addPersonOrSystemBoundary(...a[o]), this.$ = a[o];
					break;
				case 29:
					a[o].splice(2, 0, "SYSTEM"), i.addPersonOrSystemBoundary(...a[o]), this.$ = a[o];
					break;
				case 30:
					i.addPersonOrSystemBoundary(...a[o]), this.$ = a[o];
					break;
				case 31:
					a[o].splice(2, 0, "CONTAINER"), i.addContainerBoundary(...a[o]), this.$ = a[o];
					break;
				case 32:
					i.addDeploymentNode("node", ...a[o]), this.$ = a[o];
					break;
				case 33:
					i.addDeploymentNode("nodeL", ...a[o]), this.$ = a[o];
					break;
				case 34:
					i.addDeploymentNode("nodeR", ...a[o]), this.$ = a[o];
					break;
				case 35:
					i.popBoundaryParseStack();
					break;
				case 39:
					i.addPersonOrSystem("person", ...a[o]), this.$ = a[o];
					break;
				case 40:
					i.addPersonOrSystem("external_person", ...a[o]), this.$ = a[o];
					break;
				case 41:
					i.addPersonOrSystem("system", ...a[o]), this.$ = a[o];
					break;
				case 42:
					i.addPersonOrSystem("system_db", ...a[o]), this.$ = a[o];
					break;
				case 43:
					i.addPersonOrSystem("system_queue", ...a[o]), this.$ = a[o];
					break;
				case 44:
					i.addPersonOrSystem("external_system", ...a[o]), this.$ = a[o];
					break;
				case 45:
					i.addPersonOrSystem("external_system_db", ...a[o]), this.$ = a[o];
					break;
				case 46:
					i.addPersonOrSystem("external_system_queue", ...a[o]), this.$ = a[o];
					break;
				case 47:
					i.addContainer("container", ...a[o]), this.$ = a[o];
					break;
				case 48:
					i.addContainer("container_db", ...a[o]), this.$ = a[o];
					break;
				case 49:
					i.addContainer("container_queue", ...a[o]), this.$ = a[o];
					break;
				case 50:
					i.addContainer("external_container", ...a[o]), this.$ = a[o];
					break;
				case 51:
					i.addContainer("external_container_db", ...a[o]), this.$ = a[o];
					break;
				case 52:
					i.addContainer("external_container_queue", ...a[o]), this.$ = a[o];
					break;
				case 53:
					i.addComponent("component", ...a[o]), this.$ = a[o];
					break;
				case 54:
					i.addComponent("component_db", ...a[o]), this.$ = a[o];
					break;
				case 55:
					i.addComponent("component_queue", ...a[o]), this.$ = a[o];
					break;
				case 56:
					i.addComponent("external_component", ...a[o]), this.$ = a[o];
					break;
				case 57:
					i.addComponent("external_component_db", ...a[o]), this.$ = a[o];
					break;
				case 58:
					i.addComponent("external_component_queue", ...a[o]), this.$ = a[o];
					break;
				case 60:
					i.addRel("rel", ...a[o]), this.$ = a[o];
					break;
				case 61:
					i.addRel("birel", ...a[o]), this.$ = a[o];
					break;
				case 62:
					i.addRel("rel_u", ...a[o]), this.$ = a[o];
					break;
				case 63:
					i.addRel("rel_d", ...a[o]), this.$ = a[o];
					break;
				case 64:
					i.addRel("rel_l", ...a[o]), this.$ = a[o];
					break;
				case 65:
					i.addRel("rel_r", ...a[o]), this.$ = a[o];
					break;
				case 66:
					i.addRel("rel_b", ...a[o]), this.$ = a[o];
					break;
				case 67:
					a[o].splice(0, 1), i.addRel("rel", ...a[o]), this.$ = a[o];
					break;
				case 68:
					i.updateElStyle("update_el_style", ...a[o]), this.$ = a[o];
					break;
				case 69:
					i.updateRelStyle("update_rel_style", ...a[o]), this.$ = a[o];
					break;
				case 70:
					i.updateLayoutConfig("update_layout_config", ...a[o]), this.$ = a[o];
					break;
				case 71:
					this.$ = [a[o]];
					break;
				case 72:
					a[o].unshift(a[o - 1]), this.$ = a[o];
					break;
				case 73:
				case 75:
					this.$ = a[o].trim();
					break;
				case 74:
					let l = {};
					l[a[o - 1].trim()] = a[o].trim(), this.$ = l;
					break;
				case 76: this.$ = "";
			}
		}, "anonymous"),
		table: [
			{
				3: 1,
				4: 2,
				5: 3,
				6: [1, 5],
				7: [1, 6],
				8: [1, 7],
				9: [1, 8],
				10: 4,
				11: [1, 9],
				15: [1, 10],
				16: [1, 11],
				17: [1, 12],
				18: [1, 13]
			},
			{ 1: [3] },
			{ 1: [2, 1] },
			{ 1: [2, 2] },
			{ 1: [2, 7] },
			{ 1: [2, 3] },
			{ 1: [2, 4] },
			{ 1: [2, 5] },
			{ 1: [2, 6] },
			{ 12: [1, 14] },
			{ 12: [1, 15] },
			{ 12: [1, 16] },
			{ 12: [1, 17] },
			{ 12: [1, 18] },
			{
				13: 19,
				19: 20,
				20: 21,
				21: 22,
				22: t,
				23: r,
				24: i,
				26: n,
				28: a,
				29: 49,
				30: 61,
				32: 62,
				34: s,
				36: o,
				37: l,
				38: u,
				39: d,
				40: p,
				41: f,
				43: 23,
				44: g,
				45: m,
				46: y,
				47: v,
				48: x,
				49: b,
				50: w,
				51: k,
				52: T,
				53: _,
				54: E,
				55: C,
				56: S,
				57: A,
				58: L,
				59: R,
				60: N,
				61: I,
				62: M,
				63: D,
				64: O,
				65: $,
				66: P,
				67: B,
				68: F,
				69: z,
				70: U,
				71: G,
				72: q,
				73: j,
				74: W
			},
			{
				13: 70,
				19: 20,
				20: 21,
				21: 22,
				22: t,
				23: r,
				24: i,
				26: n,
				28: a,
				29: 49,
				30: 61,
				32: 62,
				34: s,
				36: o,
				37: l,
				38: u,
				39: d,
				40: p,
				41: f,
				43: 23,
				44: g,
				45: m,
				46: y,
				47: v,
				48: x,
				49: b,
				50: w,
				51: k,
				52: T,
				53: _,
				54: E,
				55: C,
				56: S,
				57: A,
				58: L,
				59: R,
				60: N,
				61: I,
				62: M,
				63: D,
				64: O,
				65: $,
				66: P,
				67: B,
				68: F,
				69: z,
				70: U,
				71: G,
				72: q,
				73: j,
				74: W
			},
			{
				13: 71,
				19: 20,
				20: 21,
				21: 22,
				22: t,
				23: r,
				24: i,
				26: n,
				28: a,
				29: 49,
				30: 61,
				32: 62,
				34: s,
				36: o,
				37: l,
				38: u,
				39: d,
				40: p,
				41: f,
				43: 23,
				44: g,
				45: m,
				46: y,
				47: v,
				48: x,
				49: b,
				50: w,
				51: k,
				52: T,
				53: _,
				54: E,
				55: C,
				56: S,
				57: A,
				58: L,
				59: R,
				60: N,
				61: I,
				62: M,
				63: D,
				64: O,
				65: $,
				66: P,
				67: B,
				68: F,
				69: z,
				70: U,
				71: G,
				72: q,
				73: j,
				74: W
			},
			{
				13: 72,
				19: 20,
				20: 21,
				21: 22,
				22: t,
				23: r,
				24: i,
				26: n,
				28: a,
				29: 49,
				30: 61,
				32: 62,
				34: s,
				36: o,
				37: l,
				38: u,
				39: d,
				40: p,
				41: f,
				43: 23,
				44: g,
				45: m,
				46: y,
				47: v,
				48: x,
				49: b,
				50: w,
				51: k,
				52: T,
				53: _,
				54: E,
				55: C,
				56: S,
				57: A,
				58: L,
				59: R,
				60: N,
				61: I,
				62: M,
				63: D,
				64: O,
				65: $,
				66: P,
				67: B,
				68: F,
				69: z,
				70: U,
				71: G,
				72: q,
				73: j,
				74: W
			},
			{
				13: 73,
				19: 20,
				20: 21,
				21: 22,
				22: t,
				23: r,
				24: i,
				26: n,
				28: a,
				29: 49,
				30: 61,
				32: 62,
				34: s,
				36: o,
				37: l,
				38: u,
				39: d,
				40: p,
				41: f,
				43: 23,
				44: g,
				45: m,
				46: y,
				47: v,
				48: x,
				49: b,
				50: w,
				51: k,
				52: T,
				53: _,
				54: E,
				55: C,
				56: S,
				57: A,
				58: L,
				59: R,
				60: N,
				61: I,
				62: M,
				63: D,
				64: O,
				65: $,
				66: P,
				67: B,
				68: F,
				69: z,
				70: U,
				71: G,
				72: q,
				73: j,
				74: W
			},
			{ 14: [1, 74] },
			e(Y, [2, 13], {
				43: 23,
				29: 49,
				30: 61,
				32: 62,
				20: 75,
				34: s,
				36: o,
				37: l,
				38: u,
				39: d,
				40: p,
				41: f,
				44: g,
				45: m,
				46: y,
				47: v,
				48: x,
				49: b,
				50: w,
				51: k,
				52: T,
				53: _,
				54: E,
				55: C,
				56: S,
				57: A,
				58: L,
				59: R,
				60: N,
				61: I,
				62: M,
				63: D,
				64: O,
				65: $,
				66: P,
				67: B,
				68: F,
				69: z,
				70: U,
				71: G,
				72: q,
				73: j,
				74: W
			}),
			e(Y, [2, 14]),
			e(V, [2, 16], { 12: [1, 76] }),
			e(Y, [2, 36], { 12: [1, 77] }),
			e(H, [2, 19]),
			e(H, [2, 20]),
			{ 25: [1, 78] },
			{ 27: [1, 79] },
			e(H, [2, 23]),
			{
				35: 80,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 86,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 87,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 88,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 89,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 90,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 91,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 92,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 93,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 94,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 95,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 96,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 97,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 98,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 99,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 100,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 101,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 102,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 103,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 104,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			e(J, [2, 59]),
			{
				35: 105,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 106,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 107,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 108,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 109,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 110,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 111,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 112,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 113,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 114,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 115,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				20: 116,
				29: 49,
				30: 61,
				32: 62,
				34: s,
				36: o,
				37: l,
				38: u,
				39: d,
				40: p,
				41: f,
				43: 23,
				44: g,
				45: m,
				46: y,
				47: v,
				48: x,
				49: b,
				50: w,
				51: k,
				52: T,
				53: _,
				54: E,
				55: C,
				56: S,
				57: A,
				58: L,
				59: R,
				60: N,
				61: I,
				62: M,
				63: D,
				64: O,
				65: $,
				66: P,
				67: B,
				68: F,
				69: z,
				70: U,
				71: G,
				72: q,
				73: j,
				74: W
			},
			{
				12: [1, 118],
				33: [1, 117]
			},
			{
				35: 119,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 120,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 121,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 122,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 123,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 124,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{
				35: 125,
				75: 81,
				76: X,
				77: K,
				79: Z,
				80: Q
			},
			{ 14: [1, 126] },
			{ 14: [1, 127] },
			{ 14: [1, 128] },
			{ 14: [1, 129] },
			{ 1: [2, 8] },
			e(Y, [2, 15]),
			e(V, [2, 17], {
				21: 22,
				19: 130,
				22: t,
				23: r,
				24: i,
				26: n,
				28: a
			}),
			e(Y, [2, 37], {
				19: 20,
				20: 21,
				21: 22,
				43: 23,
				29: 49,
				30: 61,
				32: 62,
				13: 131,
				22: t,
				23: r,
				24: i,
				26: n,
				28: a,
				34: s,
				36: o,
				37: l,
				38: u,
				39: d,
				40: p,
				41: f,
				44: g,
				45: m,
				46: y,
				47: v,
				48: x,
				49: b,
				50: w,
				51: k,
				52: T,
				53: _,
				54: E,
				55: C,
				56: S,
				57: A,
				58: L,
				59: R,
				60: N,
				61: I,
				62: M,
				63: D,
				64: O,
				65: $,
				66: P,
				67: B,
				68: F,
				69: z,
				70: U,
				71: G,
				72: q,
				73: j,
				74: W
			}),
			e(H, [2, 21]),
			e(H, [2, 22]),
			e(J, [2, 39]),
			e(ee, [2, 71], {
				75: 81,
				35: 132,
				76: X,
				77: K,
				79: Z,
				80: Q
			}),
			e(et, [2, 73]),
			{ 78: [1, 133] },
			e(et, [2, 75]),
			e(et, [2, 76]),
			e(J, [2, 40]),
			e(J, [2, 41]),
			e(J, [2, 42]),
			e(J, [2, 43]),
			e(J, [2, 44]),
			e(J, [2, 45]),
			e(J, [2, 46]),
			e(J, [2, 47]),
			e(J, [2, 48]),
			e(J, [2, 49]),
			e(J, [2, 50]),
			e(J, [2, 51]),
			e(J, [2, 52]),
			e(J, [2, 53]),
			e(J, [2, 54]),
			e(J, [2, 55]),
			e(J, [2, 56]),
			e(J, [2, 57]),
			e(J, [2, 58]),
			e(J, [2, 60]),
			e(J, [2, 61]),
			e(J, [2, 62]),
			e(J, [2, 63]),
			e(J, [2, 64]),
			e(J, [2, 65]),
			e(J, [2, 66]),
			e(J, [2, 67]),
			e(J, [2, 68]),
			e(J, [2, 69]),
			e(J, [2, 70]),
			{
				31: 134,
				42: [1, 135]
			},
			{ 12: [1, 136] },
			{ 33: [1, 137] },
			e(er, [2, 28]),
			e(er, [2, 29]),
			e(er, [2, 30]),
			e(er, [2, 31]),
			e(er, [2, 32]),
			e(er, [2, 33]),
			e(er, [2, 34]),
			{ 1: [2, 9] },
			{ 1: [2, 10] },
			{ 1: [2, 11] },
			{ 1: [2, 12] },
			e(V, [2, 18]),
			e(Y, [2, 38]),
			e(ee, [2, 72]),
			e(et, [2, 74]),
			e(J, [2, 24]),
			e(J, [2, 35]),
			e(ei, [2, 25]),
			e(ei, [2, 26], { 12: [1, 138] }),
			e(ei, [2, 27])
		],
		defaultActions: {
			2: [2, 1],
			3: [2, 2],
			4: [2, 7],
			5: [2, 3],
			6: [2, 4],
			7: [2, 5],
			8: [2, 6],
			74: [2, 8],
			126: [2, 9],
			127: [2, 10],
			128: [2, 11],
			129: [2, 12]
		},
		parseError: h(function(e, t) {
			if (t.recoverable) this.trace(e);
			else {
				var r = Error(e);
				throw r.hash = t, r;
			}
		}, "parseError"),
		parse: h(function(e) {
			var t = this, r = [0], i = [], n = [null], a = [], s = this.table, o = "", l = 0, u = 0, d = 0, p = a.slice.call(arguments, 1), f = Object.create(this.lexer), g = {};
			for (var m in this.yy) Object.prototype.hasOwnProperty.call(this.yy, m) && (g[m] = this.yy[m]);
			f.setInput(e, g), g.lexer = f, g.parser = this, typeof f.yylloc > "u" && (f.yylloc = {});
			var y = f.yylloc;
			a.push(y);
			var v = f.options && f.options.ranges;
			function x() {
				var e;
				return "number" != typeof (e = i.pop() || f.lex() || 1) && (e instanceof Array && (e = (i = e).pop()), e = t.symbols_[e] || e), e;
			}
			"function" == typeof g.parseError ? this.parseError = g.parseError : this.parseError = Object.getPrototypeOf(this).parseError, h(function(e) {
				r.length = r.length - 2 * e, n.length = n.length - e, a.length = a.length - e;
			}, "popStack"), h(x, "lex");
			for (var b, w, k, T, _, E, C, S, A, L = {};;) {
				if (k = r[r.length - 1], this.defaultActions[k] ? T = this.defaultActions[k] : ((null === b || typeof b > "u") && (b = x()), T = s[k] && s[k][b]), typeof T > "u" || !T.length || !T[0]) {
					var R = "";
					for (E in A = [], s[k]) this.terminals_[E] && E > 2 && A.push("'" + this.terminals_[E] + "'");
					R = f.showPosition ? "Parse error on line " + (l + 1) + `:
` + f.showPosition() + `
Expecting ` + A.join(", ") + ", got '" + (this.terminals_[b] || b) + "'" : "Parse error on line " + (l + 1) + ": Unexpected " + (1 == b ? "end of input" : "'" + (this.terminals_[b] || b) + "'"), this.parseError(R, {
						text: f.match,
						token: this.terminals_[b] || b,
						line: f.yylineno,
						loc: y,
						expected: A
					});
				}
				if (T[0] instanceof Array && T.length > 1) throw Error("Parse Error: multiple actions possible at state: " + k + ", token: " + b);
				switch (T[0]) {
					case 1:
						r.push(b), n.push(f.yytext), a.push(f.yylloc), r.push(T[1]), b = null, w ? (b = w, w = null) : (u = f.yyleng, o = f.yytext, l = f.yylineno, y = f.yylloc, d > 0 && d--);
						break;
					case 2:
						if (C = this.productions_[T[1]][1], L.$ = n[n.length - C], L._$ = {
							first_line: a[a.length - (C || 1)].first_line,
							last_line: a[a.length - 1].last_line,
							first_column: a[a.length - (C || 1)].first_column,
							last_column: a[a.length - 1].last_column
						}, v && (L._$.range = [a[a.length - (C || 1)].range[0], a[a.length - 1].range[1]]), "u" > typeof (_ = this.performAction.apply(L, [
							o,
							u,
							l,
							g,
							T[1],
							n,
							a
						].concat(p)))) return _;
						C && (r = r.slice(0, -1 * C * 2), n = n.slice(0, -1 * C), a = a.slice(0, -1 * C)), r.push(this.productions_[T[1]][0]), n.push(L.$), a.push(L._$), S = s[r[r.length - 2]][r[r.length - 1]], r.push(S);
						break;
					case 3: return !0;
				}
			}
			return !0;
		}, "parse")
	};
	function ea() {
		this.yy = {};
	}
	return en.lexer = {
		EOF: 1,
		parseError: h(function(e, t) {
			if (this.yy.parser) this.yy.parser.parseError(e, t);
			else throw Error(e);
		}, "parseError"),
		setInput: h(function(e, t) {
			return this.yy = t || this.yy || {}, this._input = e, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
				first_line: 1,
				first_column: 0,
				last_line: 1,
				last_column: 0
			}, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
		}, "setInput"),
		input: h(function() {
			var e = this._input[0];
			return this.yytext += e, this.yyleng++, this.offset++, this.match += e, this.matched += e, e.match(/(?:\r\n?|\n).*/g) ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), e;
		}, "input"),
		unput: h(function(e) {
			var t = e.length, r = e.split(/(?:\r\n?|\n)/g);
			this._input = e + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - t), this.offset -= t;
			var i = this.match.split(/(?:\r\n?|\n)/g);
			this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), r.length - 1 && (this.yylineno -= r.length - 1);
			var n = this.yylloc.range;
			return this.yylloc = {
				first_line: this.yylloc.first_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.first_column,
				last_column: r ? (r.length === i.length ? this.yylloc.first_column : 0) + i[i.length - r.length].length - r[0].length : this.yylloc.first_column - t
			}, this.options.ranges && (this.yylloc.range = [n[0], n[0] + this.yyleng - t]), this.yyleng = this.yytext.length, this;
		}, "unput"),
		more: h(function() {
			return this._more = !0, this;
		}, "more"),
		reject: h(function() {
			return this.options.backtrack_lexer ? (this._backtrack = !0, this) : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "reject"),
		less: h(function(e) {
			this.unput(this.match.slice(e));
		}, "less"),
		pastInput: h(function() {
			var e = this.matched.substr(0, this.matched.length - this.match.length);
			return (e.length > 20 ? "..." : "") + e.substr(-20).replace(/\n/g, "");
		}, "pastInput"),
		upcomingInput: h(function() {
			var e = this.match;
			return e.length < 20 && (e += this._input.substr(0, 20 - e.length)), (e.substr(0, 20) + (e.length > 20 ? "..." : "")).replace(/\n/g, "");
		}, "upcomingInput"),
		showPosition: h(function() {
			var e = this.pastInput(), t = Array(e.length + 1).join("-");
			return e + this.upcomingInput() + `
` + t + "^";
		}, "showPosition"),
		test_match: h(function(e, t) {
			var r, i, n;
			if (this.options.backtrack_lexer && (n = {
				yylineno: this.yylineno,
				yylloc: {
					first_line: this.yylloc.first_line,
					last_line: this.last_line,
					first_column: this.yylloc.first_column,
					last_column: this.yylloc.last_column
				},
				yytext: this.yytext,
				match: this.match,
				matches: this.matches,
				matched: this.matched,
				yyleng: this.yyleng,
				offset: this.offset,
				_more: this._more,
				_input: this._input,
				yy: this.yy,
				conditionStack: this.conditionStack.slice(0),
				done: this.done
			}, this.options.ranges && (n.yylloc.range = this.yylloc.range.slice(0))), (i = e[0].match(/(?:\r\n?|\n).*/g)) && (this.yylineno += i.length), this.yylloc = {
				first_line: this.yylloc.last_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.last_column,
				last_column: i ? i[i.length - 1].length - i[i.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + e[0].length
			}, this.yytext += e[0], this.match += e[0], this.matches = e, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(e[0].length), this.matched += e[0], r = this.performAction.call(this, this.yy, this, t, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), r) return r;
			if (this._backtrack) for (var a in n) this[a] = n[a];
			return !1;
		}, "test_match"),
		next: h(function() {
			if (this.done) return this.EOF;
			this._input || (this.done = !0), this._more || (this.yytext = "", this.match = "");
			for (var e, t, r, i, n = this._currentRules(), a = 0; a < n.length; a++) if ((r = this._input.match(this.rules[n[a]])) && (!t || r[0].length > t[0].length)) {
				if (t = r, i = a, this.options.backtrack_lexer) {
					if (!1 !== (e = this.test_match(r, n[a]))) return e;
					if (!this._backtrack) return !1;
					t = !1;
					continue;
				} else if (!this.options.flex) break;
			}
			return t ? !1 !== (e = this.test_match(t, n[i])) && e : "" === this._input ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "next"),
		lex: h(function() {
			return this.next() || this.lex();
		}, "lex"),
		begin: h(function(e) {
			this.conditionStack.push(e);
		}, "begin"),
		popState: h(function() {
			return this.conditionStack.length - 1 > 0 ? this.conditionStack.pop() : this.conditionStack[0];
		}, "popState"),
		_currentRules: h(function() {
			return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
		}, "_currentRules"),
		topState: h(function(e) {
			return (e = this.conditionStack.length - 1 - Math.abs(e || 0)) >= 0 ? this.conditionStack[e] : "INITIAL";
		}, "topState"),
		pushState: h(function(e) {
			this.begin(e);
		}, "pushState"),
		stateStackSize: h(function() {
			return this.conditionStack.length;
		}, "stateStackSize"),
		options: {},
		performAction: h(function(e, t, r, i) {
			switch (r) {
				case 0: return 6;
				case 1: return 7;
				case 2: return 8;
				case 3: return 9;
				case 4: return 22;
				case 5: return 23;
				case 6: return this.begin("acc_title"), 24;
				case 7: return this.popState(), "acc_title_value";
				case 8: return this.begin("acc_descr"), 26;
				case 9: return this.popState(), "acc_descr_value";
				case 10:
					this.begin("acc_descr_multiline");
					break;
				case 11:
				case 73:
					this.popState();
					break;
				case 12: return "acc_descr_multiline_value";
				case 13:
				case 16:
				case 70: break;
				case 14:
					c;
					break;
				case 15: return 12;
				case 17: return 11;
				case 18: return 15;
				case 19: return 16;
				case 20: return 17;
				case 21: return 18;
				case 22: return this.begin("person_ext"), 45;
				case 23: return this.begin("person"), 44;
				case 24: return this.begin("system_ext_queue"), 51;
				case 25: return this.begin("system_ext_db"), 50;
				case 26: return this.begin("system_ext"), 49;
				case 27: return this.begin("system_queue"), 48;
				case 28: return this.begin("system_db"), 47;
				case 29: return this.begin("system"), 46;
				case 30: return this.begin("boundary"), 37;
				case 31: return this.begin("enterprise_boundary"), 34;
				case 32: return this.begin("system_boundary"), 36;
				case 33: return this.begin("container_ext_queue"), 57;
				case 34: return this.begin("container_ext_db"), 56;
				case 35: return this.begin("container_ext"), 55;
				case 36: return this.begin("container_queue"), 54;
				case 37: return this.begin("container_db"), 53;
				case 38: return this.begin("container"), 52;
				case 39: return this.begin("container_boundary"), 38;
				case 40: return this.begin("component_ext_queue"), 63;
				case 41: return this.begin("component_ext_db"), 62;
				case 42: return this.begin("component_ext"), 61;
				case 43: return this.begin("component_queue"), 60;
				case 44: return this.begin("component_db"), 59;
				case 45: return this.begin("component"), 58;
				case 46:
				case 47: return this.begin("node"), 39;
				case 48: return this.begin("node_l"), 40;
				case 49: return this.begin("node_r"), 41;
				case 50: return this.begin("rel"), 64;
				case 51: return this.begin("birel"), 65;
				case 52:
				case 53: return this.begin("rel_u"), 66;
				case 54:
				case 55: return this.begin("rel_d"), 67;
				case 56:
				case 57: return this.begin("rel_l"), 68;
				case 58:
				case 59: return this.begin("rel_r"), 69;
				case 60: return this.begin("rel_b"), 70;
				case 61: return this.begin("rel_index"), 71;
				case 62: return this.begin("update_el_style"), 72;
				case 63: return this.begin("update_rel_style"), 73;
				case 64: return this.begin("update_layout_config"), 74;
				case 65: return "EOF_IN_STRUCT";
				case 66: return this.begin("attribute"), "ATTRIBUTE_EMPTY";
				case 67:
					this.begin("attribute");
					break;
				case 68:
				case 79:
					this.popState(), this.popState();
					break;
				case 69:
				case 71: return 80;
				case 72:
					this.begin("string");
					break;
				case 74:
				case 80: return "STR";
				case 75:
					this.begin("string_kv");
					break;
				case 76: return this.begin("string_kv_key"), "STR_KEY";
				case 77:
					this.popState(), this.begin("string_kv_value");
					break;
				case 78: return "STR_VALUE";
				case 81: return "LBRACE";
				case 82: return "RBRACE";
				case 83: return "SPACE";
				case 84: return "EOL";
				case 85: return 14;
			}
		}, "anonymous"),
		rules: [
			/^(?:.*direction\s+TB[^\n]*)/,
			/^(?:.*direction\s+BT[^\n]*)/,
			/^(?:.*direction\s+RL[^\n]*)/,
			/^(?:.*direction\s+LR[^\n]*)/,
			/^(?:title\s[^#\n;]+)/,
			/^(?:accDescription\s[^#\n;]+)/,
			/^(?:accTitle\s*:\s*)/,
			/^(?:(?!\n||)*[^\n]*)/,
			/^(?:accDescr\s*:\s*)/,
			/^(?:(?!\n||)*[^\n]*)/,
			/^(?:accDescr\s*\{\s*)/,
			/^(?:[\}])/,
			/^(?:[^\}]*)/,
			/^(?:%%(?!\{)*[^\n]*(\r?\n?)+)/,
			/^(?:%%[^\n]*(\r?\n)*)/,
			/^(?:\s*(\r?\n)+)/,
			/^(?:\s+)/,
			/^(?:C4Context\b)/,
			/^(?:C4Container\b)/,
			/^(?:C4Component\b)/,
			/^(?:C4Dynamic\b)/,
			/^(?:C4Deployment\b)/,
			/^(?:Person_Ext\b)/,
			/^(?:Person\b)/,
			/^(?:SystemQueue_Ext\b)/,
			/^(?:SystemDb_Ext\b)/,
			/^(?:System_Ext\b)/,
			/^(?:SystemQueue\b)/,
			/^(?:SystemDb\b)/,
			/^(?:System\b)/,
			/^(?:Boundary\b)/,
			/^(?:Enterprise_Boundary\b)/,
			/^(?:System_Boundary\b)/,
			/^(?:ContainerQueue_Ext\b)/,
			/^(?:ContainerDb_Ext\b)/,
			/^(?:Container_Ext\b)/,
			/^(?:ContainerQueue\b)/,
			/^(?:ContainerDb\b)/,
			/^(?:Container\b)/,
			/^(?:Container_Boundary\b)/,
			/^(?:ComponentQueue_Ext\b)/,
			/^(?:ComponentDb_Ext\b)/,
			/^(?:Component_Ext\b)/,
			/^(?:ComponentQueue\b)/,
			/^(?:ComponentDb\b)/,
			/^(?:Component\b)/,
			/^(?:Deployment_Node\b)/,
			/^(?:Node\b)/,
			/^(?:Node_L\b)/,
			/^(?:Node_R\b)/,
			/^(?:Rel\b)/,
			/^(?:BiRel\b)/,
			/^(?:Rel_Up\b)/,
			/^(?:Rel_U\b)/,
			/^(?:Rel_Down\b)/,
			/^(?:Rel_D\b)/,
			/^(?:Rel_Left\b)/,
			/^(?:Rel_L\b)/,
			/^(?:Rel_Right\b)/,
			/^(?:Rel_R\b)/,
			/^(?:Rel_Back\b)/,
			/^(?:RelIndex\b)/,
			/^(?:UpdateElementStyle\b)/,
			/^(?:UpdateRelStyle\b)/,
			/^(?:UpdateLayoutConfig\b)/,
			/^(?:$)/,
			/^(?:[(][ ]*[,])/,
			/^(?:[(])/,
			/^(?:[)])/,
			/^(?:,,)/,
			/^(?:,)/,
			/^(?:[ ]*["]["])/,
			/^(?:[ ]*["])/,
			/^(?:["])/,
			/^(?:[^"]*)/,
			/^(?:[ ]*[\$])/,
			/^(?:[^=]*)/,
			/^(?:[=][ ]*["])/,
			/^(?:[^"]+)/,
			/^(?:["])/,
			/^(?:[^,]+)/,
			/^(?:\{)/,
			/^(?:\})/,
			/^(?:[\s]+)/,
			/^(?:[\n\r]+)/,
			/^(?:$)/
		],
		conditions: {
			acc_descr_multiline: {
				rules: [11, 12],
				inclusive: !1
			},
			acc_descr: {
				rules: [9],
				inclusive: !1
			},
			acc_title: {
				rules: [7],
				inclusive: !1
			},
			string_kv_value: {
				rules: [78, 79],
				inclusive: !1
			},
			string_kv_key: {
				rules: [77],
				inclusive: !1
			},
			string_kv: {
				rules: [76],
				inclusive: !1
			},
			string: {
				rules: [73, 74],
				inclusive: !1
			},
			attribute: {
				rules: [
					68,
					69,
					70,
					71,
					72,
					75,
					80
				],
				inclusive: !1
			},
			update_layout_config: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			update_rel_style: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			update_el_style: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			rel_b: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			rel_r: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			rel_l: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			rel_d: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			rel_u: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			rel_bi: {
				rules: [],
				inclusive: !1
			},
			rel: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			node_r: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			node_l: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			node: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			index: {
				rules: [],
				inclusive: !1
			},
			rel_index: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			component_ext_queue: {
				rules: [],
				inclusive: !1
			},
			component_ext_db: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			component_ext: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			component_queue: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			component_db: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			component: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			container_boundary: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			container_ext_queue: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			container_ext_db: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			container_ext: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			container_queue: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			container_db: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			container: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			birel: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			system_boundary: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			enterprise_boundary: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			boundary: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			system_ext_queue: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			system_ext_db: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			system_ext: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			system_queue: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			system_db: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			system: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			person_ext: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			person: {
				rules: [
					65,
					66,
					67,
					68
				],
				inclusive: !1
			},
			INITIAL: {
				rules: [
					0,
					1,
					2,
					3,
					4,
					5,
					6,
					8,
					10,
					13,
					14,
					15,
					16,
					17,
					18,
					19,
					20,
					21,
					22,
					23,
					24,
					25,
					26,
					27,
					28,
					29,
					30,
					31,
					32,
					33,
					34,
					35,
					36,
					37,
					38,
					39,
					40,
					41,
					42,
					43,
					44,
					45,
					46,
					47,
					48,
					49,
					50,
					51,
					52,
					53,
					54,
					55,
					56,
					57,
					58,
					59,
					60,
					61,
					62,
					63,
					64,
					81,
					82,
					83,
					84,
					85
				],
				inclusive: !0
			}
		}
	}, h(ea, "Parser"), ea.prototype = en, en.Parser = ea, new ea();
}();
QD.parser = QD;
var QO, Q$ = [], QP = [""], QB = "global", QF = "", Qz = [{
	alias: "global",
	label: { text: "global" },
	type: { text: "global" },
	tags: null,
	link: null,
	parentBoundary: ""
}], QU = [], QG = "", Qq = !1, Qj = 4, QW = 2, QY = h(function() {
	return QO;
}, "getC4Type"), QV = h(function(e) {
	QO = MO(e, IA());
}, "setC4Type"), QH = h(function(e, t, r, i, n, a, s, o, l) {
	if (null == e || null == t || null == r || null == i) return;
	let h = {}, u = QU.find((e) => e.from === t && e.to === r);
	if (u ? h = u : QU.push(h), h.type = e, h.from = t, h.to = r, h.label = { text: i }, null == n) h.techn = { text: "" };
	else if ("object" == typeof n) {
		let [e, t] = Object.entries(n)[0];
		h[e] = { text: t };
	} else h.techn = { text: n };
	if (null == a) h.descr = { text: "" };
	else if ("object" == typeof a) {
		let [e, t] = Object.entries(a)[0];
		h[e] = { text: t };
	} else h.descr = { text: a };
	if ("object" == typeof s) {
		let [e, t] = Object.entries(s)[0];
		h[e] = t;
	} else h.sprite = s;
	if ("object" == typeof o) {
		let [e, t] = Object.entries(o)[0];
		h[e] = t;
	} else h.tags = o;
	if ("object" == typeof l) {
		let [e, t] = Object.entries(l)[0];
		h[e] = t;
	} else h.link = l;
	h.wrap = Js();
}, "addRel"), QX = h(function(e, t, r, i, n, a, s) {
	if (null === t || null === r) return;
	let o = {}, l = Q$.find((e) => e.alias === t);
	if (l && t === l.alias ? o = l : (o.alias = t, Q$.push(o)), null == r ? o.label = { text: "" } : o.label = { text: r }, null == i) o.descr = { text: "" };
	else if ("object" == typeof i) {
		let [e, t] = Object.entries(i)[0];
		o[e] = { text: t };
	} else o.descr = { text: i };
	if ("object" == typeof n) {
		let [e, t] = Object.entries(n)[0];
		o[e] = t;
	} else o.sprite = n;
	if ("object" == typeof a) {
		let [e, t] = Object.entries(a)[0];
		o[e] = t;
	} else o.tags = a;
	if ("object" == typeof s) {
		let [e, t] = Object.entries(s)[0];
		o[e] = t;
	} else o.link = s;
	o.typeC4Shape = { text: e }, o.parentBoundary = QB, o.wrap = Js();
}, "addPersonOrSystem"), QK = h(function(e, t, r, i, n, a, s, o) {
	if (null === t || null === r) return;
	let l = {}, h = Q$.find((e) => e.alias === t);
	if (h && t === h.alias ? l = h : (l.alias = t, Q$.push(l)), null == r ? l.label = { text: "" } : l.label = { text: r }, null == i) l.techn = { text: "" };
	else if ("object" == typeof i) {
		let [e, t] = Object.entries(i)[0];
		l[e] = { text: t };
	} else l.techn = { text: i };
	if (null == n) l.descr = { text: "" };
	else if ("object" == typeof n) {
		let [e, t] = Object.entries(n)[0];
		l[e] = { text: t };
	} else l.descr = { text: n };
	if ("object" == typeof a) {
		let [e, t] = Object.entries(a)[0];
		l[e] = t;
	} else l.sprite = a;
	if ("object" == typeof s) {
		let [e, t] = Object.entries(s)[0];
		l[e] = t;
	} else l.tags = s;
	if ("object" == typeof o) {
		let [e, t] = Object.entries(o)[0];
		l[e] = t;
	} else l.link = o;
	l.wrap = Js(), l.typeC4Shape = { text: e }, l.parentBoundary = QB;
}, "addContainer"), QZ = h(function(e, t, r, i, n, a, s, o) {
	if (null === t || null === r) return;
	let l = {}, h = Q$.find((e) => e.alias === t);
	if (h && t === h.alias ? l = h : (l.alias = t, Q$.push(l)), null == r ? l.label = { text: "" } : l.label = { text: r }, null == i) l.techn = { text: "" };
	else if ("object" == typeof i) {
		let [e, t] = Object.entries(i)[0];
		l[e] = { text: t };
	} else l.techn = { text: i };
	if (null == n) l.descr = { text: "" };
	else if ("object" == typeof n) {
		let [e, t] = Object.entries(n)[0];
		l[e] = { text: t };
	} else l.descr = { text: n };
	if ("object" == typeof a) {
		let [e, t] = Object.entries(a)[0];
		l[e] = t;
	} else l.sprite = a;
	if ("object" == typeof s) {
		let [e, t] = Object.entries(s)[0];
		l[e] = t;
	} else l.tags = s;
	if ("object" == typeof o) {
		let [e, t] = Object.entries(o)[0];
		l[e] = t;
	} else l.link = o;
	l.wrap = Js(), l.typeC4Shape = { text: e }, l.parentBoundary = QB;
}, "addComponent"), QQ = h(function(e, t, r, i, n) {
	if (null === e || null === t) return;
	let a = {}, s = Qz.find((t) => t.alias === e);
	if (s && e === s.alias ? a = s : (a.alias = e, Qz.push(a)), null == t ? a.label = { text: "" } : a.label = { text: t }, null == r) a.type = { text: "system" };
	else if ("object" == typeof r) {
		let [e, t] = Object.entries(r)[0];
		a[e] = { text: t };
	} else a.type = { text: r };
	if ("object" == typeof i) {
		let [e, t] = Object.entries(i)[0];
		a[e] = t;
	} else a.tags = i;
	if ("object" == typeof n) {
		let [e, t] = Object.entries(n)[0];
		a[e] = t;
	} else a.link = n;
	a.parentBoundary = QB, a.wrap = Js(), QF = QB, QB = e, QP.push(QF);
}, "addPersonOrSystemBoundary"), QJ = h(function(e, t, r, i, n) {
	if (null === e || null === t) return;
	let a = {}, s = Qz.find((t) => t.alias === e);
	if (s && e === s.alias ? a = s : (a.alias = e, Qz.push(a)), null == t ? a.label = { text: "" } : a.label = { text: t }, null == r) a.type = { text: "container" };
	else if ("object" == typeof r) {
		let [e, t] = Object.entries(r)[0];
		a[e] = { text: t };
	} else a.type = { text: r };
	if ("object" == typeof i) {
		let [e, t] = Object.entries(i)[0];
		a[e] = t;
	} else a.tags = i;
	if ("object" == typeof n) {
		let [e, t] = Object.entries(n)[0];
		a[e] = t;
	} else a.link = n;
	a.parentBoundary = QB, a.wrap = Js(), QF = QB, QB = e, QP.push(QF);
}, "addContainerBoundary"), Q0 = h(function(e, t, r, i, n, a, s, o) {
	if (null === t || null === r) return;
	let l = {}, h = Qz.find((e) => e.alias === t);
	if (h && t === h.alias ? l = h : (l.alias = t, Qz.push(l)), null == r ? l.label = { text: "" } : l.label = { text: r }, null == i) l.type = { text: "node" };
	else if ("object" == typeof i) {
		let [e, t] = Object.entries(i)[0];
		l[e] = { text: t };
	} else l.type = { text: i };
	if (null == n) l.descr = { text: "" };
	else if ("object" == typeof n) {
		let [e, t] = Object.entries(n)[0];
		l[e] = { text: t };
	} else l.descr = { text: n };
	if ("object" == typeof s) {
		let [e, t] = Object.entries(s)[0];
		l[e] = t;
	} else l.tags = s;
	if ("object" == typeof o) {
		let [e, t] = Object.entries(o)[0];
		l[e] = t;
	} else l.link = o;
	l.nodeType = e, l.parentBoundary = QB, l.wrap = Js(), QF = QB, QB = t, QP.push(QF);
}, "addDeploymentNode"), Q1 = h(function() {
	QB = QF, QP.pop(), QF = QP.pop(), QP.push(QF);
}, "popBoundaryParseStack"), Q2 = h(function(e, t, r, i, n, a, s, o, l, h, u) {
	let d = Q$.find((e) => e.alias === t);
	if (void 0 !== d || void 0 !== (d = Qz.find((e) => e.alias === t))) {
		if (null != r) if ("object" == typeof r) {
			let [e, t] = Object.entries(r)[0];
			d[e] = t;
		} else d.bgColor = r;
		if (null != i) if ("object" == typeof i) {
			let [e, t] = Object.entries(i)[0];
			d[e] = t;
		} else d.fontColor = i;
		if (null != n) if ("object" == typeof n) {
			let [e, t] = Object.entries(n)[0];
			d[e] = t;
		} else d.borderColor = n;
		if (null != a) if ("object" == typeof a) {
			let [e, t] = Object.entries(a)[0];
			d[e] = t;
		} else d.shadowing = a;
		if (null != s) if ("object" == typeof s) {
			let [e, t] = Object.entries(s)[0];
			d[e] = t;
		} else d.shape = s;
		if (null != o) if ("object" == typeof o) {
			let [e, t] = Object.entries(o)[0];
			d[e] = t;
		} else d.sprite = o;
		if (null != l) if ("object" == typeof l) {
			let [e, t] = Object.entries(l)[0];
			d[e] = t;
		} else d.techn = l;
		if (null != h) if ("object" == typeof h) {
			let [e, t] = Object.entries(h)[0];
			d[e] = t;
		} else d.legendText = h;
		if (null != u) if ("object" == typeof u) {
			let [e, t] = Object.entries(u)[0];
			d[e] = t;
		} else d.legendSprite = u;
	}
}, "updateElStyle"), Q4 = h(function(e, t, r, i, n, a, s) {
	let o = QU.find((e) => e.from === t && e.to === r);
	if (void 0 !== o) {
		if (null != i) if ("object" == typeof i) {
			let [e, t] = Object.entries(i)[0];
			o[e] = t;
		} else o.textColor = i;
		if (null != n) if ("object" == typeof n) {
			let [e, t] = Object.entries(n)[0];
			o[e] = t;
		} else o.lineColor = n;
		if (null != a) if ("object" == typeof a) {
			let [e, t] = Object.entries(a)[0];
			o[e] = parseInt(t);
		} else o.offsetX = parseInt(a);
		if (null != s) if ("object" == typeof s) {
			let [e, t] = Object.entries(s)[0];
			o[e] = parseInt(t);
		} else o.offsetY = parseInt(s);
	}
}, "updateRelStyle"), Q5 = h(function(e, t, r) {
	let i = Qj, n = QW;
	i = "object" == typeof t ? parseInt(Object.values(t)[0]) : parseInt(t), n = "object" == typeof r ? parseInt(Object.values(r)[0]) : parseInt(r), i >= 1 && (Qj = i), n >= 1 && (QW = n);
}, "updateLayoutConfig"), Q3 = h(function() {
	return Qj;
}, "getC4ShapeInRow"), Q6 = h(function() {
	return QW;
}, "getC4BoundaryInRow"), Q7 = h(function() {
	return QB;
}, "getCurrentBoundaryParse"), Q8 = h(function() {
	return QF;
}, "getParentBoundaryParse"), Q9 = h(function(e) {
	return null == e ? Q$ : Q$.filter((t) => t.parentBoundary === e);
}, "getC4ShapeArray"), Je = h(function(e) {
	return Q$.find((t) => t.alias === e);
}, "getC4Shape"), Jt = h(function(e) {
	return Object.keys(Q9(e));
}, "getC4ShapeKeys"), Jr = h(function(e) {
	return null == e ? Qz : Qz.filter((t) => t.parentBoundary === e);
}, "getBoundaries"), Ji = h(function() {
	return QU;
}, "getRels"), Jn = h(function() {
	return QG;
}, "getTitle"), Ja = h(function(e) {
	Qq = e;
}, "setWrap"), Js = h(function() {
	return Qq;
}, "autoWrap"), Jo = h(function() {
	Q$ = [], Qz = [{
		alias: "global",
		label: { text: "global" },
		type: { text: "global" },
		tags: null,
		link: null,
		parentBoundary: ""
	}], QF = "", QB = "global", QP = [""], QU = [], QP = [""], QG = "", Qq = !1, Qj = 4, QW = 2;
}, "clear"), Jl = h(function(e) {
	QG = MO(e, IA());
}, "setTitle"), Jc = {
	addPersonOrSystem: QX,
	addPersonOrSystemBoundary: QQ,
	addContainer: QK,
	addContainerBoundary: QJ,
	addComponent: QZ,
	addDeploymentNode: Q0,
	popBoundaryParseStack: Q1,
	addRel: QH,
	updateElStyle: Q2,
	updateRelStyle: Q4,
	updateLayoutConfig: Q5,
	autoWrap: Js,
	setWrap: Ja,
	getC4ShapeArray: Q9,
	getC4Shape: Je,
	getC4ShapeKeys: Jt,
	getBoundaries: Jr,
	getBoundarys: Jr,
	getCurrentBoundaryParse: Q7,
	getParentBoundaryParse: Q8,
	getRels: Ji,
	getTitle: Jn,
	getC4Type: QY,
	getC4ShapeInRow: Q3,
	getC4BoundaryInRow: Q6,
	setAccTitle: Da,
	getAccTitle: Ds,
	getAccDescription: Dl,
	setAccDescription: Do,
	getConfig: h(() => IA().c4, "getConfig"),
	clear: Jo,
	LINETYPE: {
		SOLID: 0,
		DOTTED: 1,
		NOTE: 2,
		SOLID_CROSS: 3,
		DOTTED_CROSS: 4,
		SOLID_OPEN: 5,
		DOTTED_OPEN: 6,
		LOOP_START: 10,
		LOOP_END: 11,
		ALT_START: 12,
		ALT_ELSE: 13,
		ALT_END: 14,
		OPT_START: 15,
		OPT_END: 16,
		ACTIVE_START: 17,
		ACTIVE_END: 18,
		PAR_START: 19,
		PAR_AND: 20,
		PAR_END: 21,
		RECT_START: 22,
		RECT_END: 23,
		SOLID_POINT: 24,
		DOTTED_POINT: 25
	},
	ARROWTYPE: {
		FILLED: 0,
		OPEN: 1
	},
	PLACEMENT: {
		LEFTOF: 0,
		RIGHTOF: 1,
		OVER: 2
	},
	setTitle: Jl,
	setC4Type: QV
}, Jh = g(Vk(), 1), Ju = h(function(e, t) {
	return QS(e, t);
}, "drawRect"), Jd = h(function(e, t, r, i, n, a) {
	let s = e.append("image");
	s.attr("width", t), s.attr("height", r), s.attr("x", i), s.attr("y", n);
	let o = a.startsWith("data:image/png;base64") ? a : (0, Jh.sanitizeUrl)(a);
	s.attr("xlink:href", o);
}, "drawImage"), Jp = h((e, t, r) => {
	let i = e.append("g"), n = 0;
	for (let e of t) {
		let t = e.textColor ? e.textColor : "#444444", a = e.lineColor ? e.lineColor : "#444444", s = e.offsetX ? parseInt(e.offsetX) : 0, o = e.offsetY ? parseInt(e.offsetY) : 0;
		if (0 === n) {
			let t = i.append("line");
			t.attr("x1", e.startPoint.x), t.attr("y1", e.startPoint.y), t.attr("x2", e.endPoint.x), t.attr("y2", e.endPoint.y), t.attr("stroke-width", "1"), t.attr("stroke", a), t.style("fill", "none"), "rel_b" !== e.type && t.attr("marker-end", "url(#arrowhead)"), ("birel" === e.type || "rel_b" === e.type) && t.attr("marker-start", "url(#arrowend)"), n = -1;
		} else {
			let t = i.append("path");
			t.attr("fill", "none").attr("stroke-width", "1").attr("stroke", a).attr("d", "Mstartx,starty Qcontrolx,controly stopx,stopy ".replaceAll("startx", e.startPoint.x).replaceAll("starty", e.startPoint.y).replaceAll("controlx", e.startPoint.x + (e.endPoint.x - e.startPoint.x) / 2 - (e.endPoint.x - e.startPoint.x) / 4).replaceAll("controly", e.startPoint.y + (e.endPoint.y - e.startPoint.y) / 2).replaceAll("stopx", e.endPoint.x).replaceAll("stopy", e.endPoint.y)), "rel_b" !== e.type && t.attr("marker-end", "url(#arrowhead)"), ("birel" === e.type || "rel_b" === e.type) && t.attr("marker-start", "url(#arrowend)");
		}
		let l = r.messageFont();
		J_(r)(e.label.text, i, Math.min(e.startPoint.x, e.endPoint.x) + Math.abs(e.endPoint.x - e.startPoint.x) / 2 + s, Math.min(e.startPoint.y, e.endPoint.y) + Math.abs(e.endPoint.y - e.startPoint.y) / 2 + o, e.label.width, e.label.height, { fill: t }, l), e.techn && "" !== e.techn.text && (l = r.messageFont(), J_(r)("[" + e.techn.text + "]", i, Math.min(e.startPoint.x, e.endPoint.x) + Math.abs(e.endPoint.x - e.startPoint.x) / 2 + s, Math.min(e.startPoint.y, e.endPoint.y) + Math.abs(e.endPoint.y - e.startPoint.y) / 2 + r.messageFontSize + 5 + o, Math.max(e.label.width, e.techn.width), e.techn.height, {
			fill: t,
			"font-style": "italic"
		}, l));
	}
}, "drawRels"), Jf = h(function(e, t, r) {
	let i = e.append("g"), n = t.bgColor ? t.bgColor : "none", a = t.borderColor ? t.borderColor : "#444444", s = t.fontColor ? t.fontColor : "black", o = {
		"stroke-width": 1,
		"stroke-dasharray": "7.0,7.0"
	};
	t.nodeType && (o = { "stroke-width": 1 }), Ju(i, {
		x: t.x,
		y: t.y,
		fill: n,
		stroke: a,
		width: t.width,
		height: t.height,
		rx: 2.5,
		ry: 2.5,
		attrs: o
	});
	let l = r.boundaryFont();
	l.fontWeight = "bold", l.fontSize = l.fontSize + 2, l.fontColor = s, J_(r)(t.label.text, i, t.x, t.y + t.label.Y, t.width, t.height, { fill: "#444444" }, l), t.type && "" !== t.type.text && ((l = r.boundaryFont()).fontColor = s, J_(r)(t.type.text, i, t.x, t.y + t.type.Y, t.width, t.height, { fill: "#444444" }, l)), t.descr && "" !== t.descr.text && ((l = r.boundaryFont()).fontSize = l.fontSize - 2, l.fontColor = s, J_(r)(t.descr.text, i, t.x, t.y + t.descr.Y, t.width, t.height, { fill: "#444444" }, l));
}, "drawBoundary"), Jg = h(function(e, t, r) {
	let i = t.bgColor ? t.bgColor : r[t.typeC4Shape.text + "_bg_color"], n = t.borderColor ? t.borderColor : r[t.typeC4Shape.text + "_border_color"], a = t.fontColor ? t.fontColor : "#FFFFFF", s = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAACD0lEQVR4Xu2YoU4EMRCGT+4j8Ai8AhaH4QHgAUjQuFMECUgMIUgwJAgMhgQsAYUiJCiQIBBY+EITsjfTdme6V24v4c8vyGbb+ZjOtN0bNcvjQXmkH83WvYBWto6PLm6v7p7uH1/w2fXD+PBycX1Pv2l3IdDm/vn7x+dXQiAubRzoURa7gRZWd0iGRIiJbOnhnfYBQZNJjNbuyY2eJG8fkDE3bbG4ep6MHUAsgYxmE3nVs6VsBWJSGccsOlFPmLIViMzLOB7pCVO2AtHJMohH7Fh6zqitQK7m0rJvAVYgGcEpe//PLdDz65sM4pF9N7ICcXDKIB5Nv6j7tD0NoSdM2QrU9Gg0ewE1LqBhHR3BBdvj2vapnidjHxD/q6vd7Pvhr31AwcY8eXMTXAKECZZJFXuEq27aLgQK5uLMohCenGGuGewOxSjBvYBqeG6B+Nqiblggdjnc+ZXDy+FNFpFzw76O3UBAROuXh6FoiAcf5g9eTvUgzy0nWg6I8cXHRUpg5bOVBCo+KDpFajOf23GgPme7RSQ+lacIENUgJ6gg1k6HjgOlqnLqip4tEuhv0hNEMXUD0clyXE3p6pZA0S2nnvTlXwLJEZWlb7cTQH1+USgTN4VhAenm/wea1OCAOmqo6fE1WCb9WSKBah+rbUWPWAmE2Rvk0ApiB45eOyNAzU8xcTvj8KvkKEoOaIYeHNA3ZuygAvFMUO0AAAAASUVORK5CYII=";
	switch (t.typeC4Shape.text) {
		case "person":
			s = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAACD0lEQVR4Xu2YoU4EMRCGT+4j8Ai8AhaH4QHgAUjQuFMECUgMIUgwJAgMhgQsAYUiJCiQIBBY+EITsjfTdme6V24v4c8vyGbb+ZjOtN0bNcvjQXmkH83WvYBWto6PLm6v7p7uH1/w2fXD+PBycX1Pv2l3IdDm/vn7x+dXQiAubRzoURa7gRZWd0iGRIiJbOnhnfYBQZNJjNbuyY2eJG8fkDE3bbG4ep6MHUAsgYxmE3nVs6VsBWJSGccsOlFPmLIViMzLOB7pCVO2AtHJMohH7Fh6zqitQK7m0rJvAVYgGcEpe//PLdDz65sM4pF9N7ICcXDKIB5Nv6j7tD0NoSdM2QrU9Gg0ewE1LqBhHR3BBdvj2vapnidjHxD/q6vd7Pvhr31AwcY8eXMTXAKECZZJFXuEq27aLgQK5uLMohCenGGuGewOxSjBvYBqeG6B+Nqiblggdjnc+ZXDy+FNFpFzw76O3UBAROuXh6FoiAcf5g9eTvUgzy0nWg6I8cXHRUpg5bOVBCo+KDpFajOf23GgPme7RSQ+lacIENUgJ6gg1k6HjgOlqnLqip4tEuhv0hNEMXUD0clyXE3p6pZA0S2nnvTlXwLJEZWlb7cTQH1+USgTN4VhAenm/wea1OCAOmqo6fE1WCb9WSKBah+rbUWPWAmE2Rvk0ApiB45eOyNAzU8xcTvj8KvkKEoOaIYeHNA3ZuygAvFMUO0AAAAASUVORK5CYII=";
			break;
		case "external_person": s = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAAB6ElEQVR4Xu2YLY+EMBCG9+dWr0aj0Wg0Go1Go0+j8Xdv2uTCvv1gpt0ebHKPuhDaeW4605Z9mJvx4AdXUyTUdd08z+u6flmWZRnHsWkafk9DptAwDPu+f0eAYtu2PEaGWuj5fCIZrBAC2eLBAnRCsEkkxmeaJp7iDJ2QMDdHsLg8SxKFEJaAo8lAXnmuOFIhTMpxxKATebo4UiFknuNo4OniSIXQyRxEA3YsnjGCVEjVXD7yLUAqxBGUyPv/Y4W2beMgGuS7kVQIBycH0fD+oi5pezQETxdHKmQKGk1eQEYldK+jw5GxPfZ9z7Mk0Qnhf1W1m3w//EUn5BDmSZsbR44QQLBEqrBHqOrmSKaQAxdnLArCrxZcM7A7ZKs4ioRq8LFC+NpC3WCBJsvpVw5edm9iEXFuyNfxXAgSwfrFQ1c0iNda8AdejvUgnktOtJQQxmcfFzGglc5WVCj7oDgFqU18boeFSs52CUh8LE8BIVQDT1ABrB0HtgSEYlX5doJnCwv9TXocKCaKbnwhdDKPq4lf3SwU3HLq4V/+WYhHVMa/3b4IlfyikAduCkcBc7mQ3/z/Qq/cTuikhkzB12Ae/mcJC9U+Vo8Ej1gWAtgbeGgFsAMHr50BIWOLCbezvhpBFUdY6EJuJ/QDW0XoMX60zZ0AAAAASUVORK5CYII=";
	}
	let o = e.append("g");
	o.attr("class", "person-man");
	let l = QI();
	switch (t.typeC4Shape.text) {
		case "person":
		case "external_person":
		case "system":
		case "external_system":
		case "container":
		case "external_container":
		case "component":
		case "external_component":
			l.x = t.x, l.y = t.y, l.fill = i, l.width = t.width, l.height = t.height, l.stroke = n, l.rx = 2.5, l.ry = 2.5, l.attrs = { "stroke-width": .5 }, Ju(o, l);
			break;
		case "system_db":
		case "external_system_db":
		case "container_db":
		case "external_container_db":
		case "component_db":
		case "external_component_db":
			o.append("path").attr("fill", i).attr("stroke-width", "0.5").attr("stroke", n).attr("d", "Mstartx,startyc0,-10 half,-10 half,-10c0,0 half,0 half,10l0,heightc0,10 -half,10 -half,10c0,0 -half,0 -half,-10l0,-height".replaceAll("startx", t.x).replaceAll("starty", t.y).replaceAll("half", t.width / 2).replaceAll("height", t.height)), o.append("path").attr("fill", "none").attr("stroke-width", "0.5").attr("stroke", n).attr("d", "Mstartx,startyc0,10 half,10 half,10c0,0 half,0 half,-10".replaceAll("startx", t.x).replaceAll("starty", t.y).replaceAll("half", t.width / 2));
			break;
		case "system_queue":
		case "external_system_queue":
		case "container_queue":
		case "external_container_queue":
		case "component_queue":
		case "external_component_queue": o.append("path").attr("fill", i).attr("stroke-width", "0.5").attr("stroke", n).attr("d", "Mstartx,startylwidth,0c5,0 5,half 5,halfc0,0 0,half -5,halfl-width,0c-5,0 -5,-half -5,-halfc0,0 0,-half 5,-half".replaceAll("startx", t.x).replaceAll("starty", t.y).replaceAll("width", t.width).replaceAll("half", t.height / 2)), o.append("path").attr("fill", "none").attr("stroke-width", "0.5").attr("stroke", n).attr("d", "Mstartx,startyc-5,0 -5,half -5,halfc0,half 5,half 5,half".replaceAll("startx", t.x + t.width).replaceAll("starty", t.y).replaceAll("half", t.height / 2));
	}
	let h = JT(r, t.typeC4Shape.text);
	switch (o.append("text").attr("fill", a).attr("font-family", h.fontFamily).attr("font-size", h.fontSize - 2).attr("font-style", "italic").attr("lengthAdjust", "spacing").attr("textLength", t.typeC4Shape.width).attr("x", t.x + t.width / 2 - t.typeC4Shape.width / 2).attr("y", t.y + t.typeC4Shape.Y).text("<<" + t.typeC4Shape.text + ">>"), t.typeC4Shape.text) {
		case "person":
		case "external_person": Jd(o, 48, 48, t.x + t.width / 2 - 24, t.y + t.image.Y, s);
	}
	let u = r[t.typeC4Shape.text + "Font"]();
	return u.fontWeight = "bold", u.fontSize = u.fontSize + 2, u.fontColor = a, J_(r)(t.label.text, o, t.x, t.y + t.label.Y, t.width, t.height, { fill: a }, u), (u = r[t.typeC4Shape.text + "Font"]()).fontColor = a, t.techn && t.techn?.text !== "" ? J_(r)(t.techn.text, o, t.x, t.y + t.techn.Y, t.width, t.height, {
		fill: a,
		"font-style": "italic"
	}, u) : t.type && "" !== t.type.text && J_(r)(t.type.text, o, t.x, t.y + t.type.Y, t.width, t.height, {
		fill: a,
		"font-style": "italic"
	}, u), t.descr && "" !== t.descr.text && ((u = r.personFont()).fontColor = a, J_(r)(t.descr.text, o, t.x, t.y + t.descr.Y, t.width, t.height, { fill: a }, u)), t.height;
}, "drawC4Shape"), Jm = h(function(e) {
	e.append("defs").append("symbol").attr("id", "database").attr("fill-rule", "evenodd").attr("clip-rule", "evenodd").append("path").attr("transform", "scale(.5)").attr("d", "M12.258.001l.256.004.255.005.253.008.251.01.249.012.247.015.246.016.242.019.241.02.239.023.236.024.233.027.231.028.229.031.225.032.223.034.22.036.217.038.214.04.211.041.208.043.205.045.201.046.198.048.194.05.191.051.187.053.183.054.18.056.175.057.172.059.168.06.163.061.16.063.155.064.15.066.074.033.073.033.071.034.07.034.069.035.068.035.067.035.066.035.064.036.064.036.062.036.06.036.06.037.058.037.058.037.055.038.055.038.053.038.052.038.051.039.05.039.048.039.047.039.045.04.044.04.043.04.041.04.04.041.039.041.037.041.036.041.034.041.033.042.032.042.03.042.029.042.027.042.026.043.024.043.023.043.021.043.02.043.018.044.017.043.015.044.013.044.012.044.011.045.009.044.007.045.006.045.004.045.002.045.001.045v17l-.001.045-.002.045-.004.045-.006.045-.007.045-.009.044-.011.045-.012.044-.013.044-.015.044-.017.043-.018.044-.02.043-.021.043-.023.043-.024.043-.026.043-.027.042-.029.042-.03.042-.032.042-.033.042-.034.041-.036.041-.037.041-.039.041-.04.041-.041.04-.043.04-.044.04-.045.04-.047.039-.048.039-.05.039-.051.039-.052.038-.053.038-.055.038-.055.038-.058.037-.058.037-.06.037-.06.036-.062.036-.064.036-.064.036-.066.035-.067.035-.068.035-.069.035-.07.034-.071.034-.073.033-.074.033-.15.066-.155.064-.16.063-.163.061-.168.06-.172.059-.175.057-.18.056-.183.054-.187.053-.191.051-.194.05-.198.048-.201.046-.205.045-.208.043-.211.041-.214.04-.217.038-.22.036-.223.034-.225.032-.229.031-.231.028-.233.027-.236.024-.239.023-.241.02-.242.019-.246.016-.247.015-.249.012-.251.01-.253.008-.255.005-.256.004-.258.001-.258-.001-.256-.004-.255-.005-.253-.008-.251-.01-.249-.012-.247-.015-.245-.016-.243-.019-.241-.02-.238-.023-.236-.024-.234-.027-.231-.028-.228-.031-.226-.032-.223-.034-.22-.036-.217-.038-.214-.04-.211-.041-.208-.043-.204-.045-.201-.046-.198-.048-.195-.05-.19-.051-.187-.053-.184-.054-.179-.056-.176-.057-.172-.059-.167-.06-.164-.061-.159-.063-.155-.064-.151-.066-.074-.033-.072-.033-.072-.034-.07-.034-.069-.035-.068-.035-.067-.035-.066-.035-.064-.036-.063-.036-.062-.036-.061-.036-.06-.037-.058-.037-.057-.037-.056-.038-.055-.038-.053-.038-.052-.038-.051-.039-.049-.039-.049-.039-.046-.039-.046-.04-.044-.04-.043-.04-.041-.04-.04-.041-.039-.041-.037-.041-.036-.041-.034-.041-.033-.042-.032-.042-.03-.042-.029-.042-.027-.042-.026-.043-.024-.043-.023-.043-.021-.043-.02-.043-.018-.044-.017-.043-.015-.044-.013-.044-.012-.044-.011-.045-.009-.044-.007-.045-.006-.045-.004-.045-.002-.045-.001-.045v-17l.001-.045.002-.045.004-.045.006-.045.007-.045.009-.044.011-.045.012-.044.013-.044.015-.044.017-.043.018-.044.02-.043.021-.043.023-.043.024-.043.026-.043.027-.042.029-.042.03-.042.032-.042.033-.042.034-.041.036-.041.037-.041.039-.041.04-.041.041-.04.043-.04.044-.04.046-.04.046-.039.049-.039.049-.039.051-.039.052-.038.053-.038.055-.038.056-.038.057-.037.058-.037.06-.037.061-.036.062-.036.063-.036.064-.036.066-.035.067-.035.068-.035.069-.035.07-.034.072-.034.072-.033.074-.033.151-.066.155-.064.159-.063.164-.061.167-.06.172-.059.176-.057.179-.056.184-.054.187-.053.19-.051.195-.05.198-.048.201-.046.204-.045.208-.043.211-.041.214-.04.217-.038.22-.036.223-.034.226-.032.228-.031.231-.028.234-.027.236-.024.238-.023.241-.02.243-.019.245-.016.247-.015.249-.012.251-.01.253-.008.255-.005.256-.004.258-.001.258.001zm-9.258 20.499v.01l.001.021.003.021.004.022.005.021.006.022.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.023.018.024.019.024.021.024.022.025.023.024.024.025.052.049.056.05.061.051.066.051.07.051.075.051.079.052.084.052.088.052.092.052.097.052.102.051.105.052.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.048.144.049.147.047.152.047.155.047.16.045.163.045.167.043.171.043.176.041.178.041.183.039.187.039.19.037.194.035.197.035.202.033.204.031.209.03.212.029.216.027.219.025.222.024.226.021.23.02.233.018.236.016.24.015.243.012.246.01.249.008.253.005.256.004.259.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.021.224-.024.22-.026.216-.027.212-.028.21-.031.205-.031.202-.034.198-.034.194-.036.191-.037.187-.039.183-.04.179-.04.175-.042.172-.043.168-.044.163-.045.16-.046.155-.046.152-.047.148-.048.143-.049.139-.049.136-.05.131-.05.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.053.083-.051.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.05.023-.024.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.023.01-.022.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.127l-.077.055-.08.053-.083.054-.085.053-.087.052-.09.052-.093.051-.095.05-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.045-.118.044-.12.043-.122.042-.124.042-.126.041-.128.04-.13.04-.132.038-.134.038-.135.037-.138.037-.139.035-.142.035-.143.034-.144.033-.147.032-.148.031-.15.03-.151.03-.153.029-.154.027-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.01-.179.008-.179.008-.181.006-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.006-.179-.008-.179-.008-.178-.01-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.027-.153-.029-.151-.03-.15-.03-.148-.031-.146-.032-.145-.033-.143-.034-.141-.035-.14-.035-.137-.037-.136-.037-.134-.038-.132-.038-.13-.04-.128-.04-.126-.041-.124-.042-.122-.042-.12-.044-.117-.043-.116-.045-.113-.045-.112-.046-.109-.047-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.05-.093-.052-.09-.051-.087-.052-.085-.053-.083-.054-.08-.054-.077-.054v4.127zm0-5.654v.011l.001.021.003.021.004.021.005.022.006.022.007.022.009.022.01.022.011.023.012.023.013.023.015.024.016.023.017.024.018.024.019.024.021.024.022.024.023.025.024.024.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.052.11.051.114.051.119.052.123.05.127.051.131.05.135.049.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.044.171.042.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.022.23.02.233.018.236.016.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.012.241-.015.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.048.139-.05.136-.049.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.051.051-.049.023-.025.023-.024.021-.025.02-.024.019-.024.018-.024.017-.024.015-.023.014-.023.013-.024.012-.022.01-.023.01-.023.008-.022.006-.022.006-.022.004-.021.004-.022.001-.021.001-.021v-4.139l-.077.054-.08.054-.083.054-.085.052-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.044-.118.044-.12.044-.122.042-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.035-.143.033-.144.033-.147.033-.148.031-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.009-.179.009-.179.007-.181.007-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.007-.179-.007-.179-.009-.178-.009-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.031-.146-.033-.145-.033-.143-.033-.141-.035-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.04-.126-.041-.124-.042-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.051-.093-.051-.09-.051-.087-.053-.085-.052-.083-.054-.08-.054-.077-.054v4.139zm0-5.666v.011l.001.02.003.022.004.021.005.022.006.021.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.024.018.023.019.024.021.025.022.024.023.024.024.025.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.051.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.043.171.043.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.021.23.02.233.018.236.017.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.013.241-.014.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.049.139-.049.136-.049.131-.051.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.049.023-.025.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.022.01-.023.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.153l-.077.054-.08.054-.083.053-.085.053-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.048-.105.048-.106.048-.109.046-.111.046-.114.046-.115.044-.118.044-.12.043-.122.043-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.034-.143.034-.144.033-.147.032-.148.032-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.024-.161.024-.162.023-.163.023-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.01-.178.01-.179.009-.179.007-.181.006-.182.006-.182.004-.184.003-.184.001-.185.001-.185-.001-.184-.001-.184-.003-.182-.004-.182-.006-.181-.006-.179-.007-.179-.009-.178-.01-.176-.01-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.023-.162-.023-.161-.024-.159-.024-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.032-.146-.032-.145-.033-.143-.034-.141-.034-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.041-.126-.041-.124-.041-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.048-.105-.048-.102-.048-.1-.05-.097-.049-.095-.051-.093-.051-.09-.052-.087-.052-.085-.053-.083-.053-.08-.054-.077-.054v4.153zm8.74-8.179l-.257.004-.254.005-.25.008-.247.011-.244.012-.241.014-.237.016-.233.018-.231.021-.226.022-.224.023-.22.026-.216.027-.212.028-.21.031-.205.032-.202.033-.198.034-.194.036-.191.038-.187.038-.183.04-.179.041-.175.042-.172.043-.168.043-.163.045-.16.046-.155.046-.152.048-.148.048-.143.048-.139.049-.136.05-.131.05-.126.051-.123.051-.118.051-.114.052-.11.052-.106.052-.101.052-.096.052-.092.052-.088.052-.083.052-.079.052-.074.051-.07.052-.065.051-.06.05-.056.05-.051.05-.023.025-.023.024-.021.024-.02.025-.019.024-.018.024-.017.023-.015.024-.014.023-.013.023-.012.023-.01.023-.01.022-.008.022-.006.023-.006.021-.004.022-.004.021-.001.021-.001.021.001.021.001.021.004.021.004.022.006.021.006.023.008.022.01.022.01.023.012.023.013.023.014.023.015.024.017.023.018.024.019.024.02.025.021.024.023.024.023.025.051.05.056.05.06.05.065.051.07.052.074.051.079.052.083.052.088.052.092.052.096.052.101.052.106.052.11.052.114.052.118.051.123.051.126.051.131.05.136.05.139.049.143.048.148.048.152.048.155.046.16.046.163.045.168.043.172.043.175.042.179.041.183.04.187.038.191.038.194.036.198.034.202.033.205.032.21.031.212.028.216.027.22.026.224.023.226.022.231.021.233.018.237.016.241.014.244.012.247.011.25.008.254.005.257.004.26.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.022.224-.023.22-.026.216-.027.212-.028.21-.031.205-.032.202-.033.198-.034.194-.036.191-.038.187-.038.183-.04.179-.041.175-.042.172-.043.168-.043.163-.045.16-.046.155-.046.152-.048.148-.048.143-.048.139-.049.136-.05.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.05.051-.05.023-.025.023-.024.021-.024.02-.025.019-.024.018-.024.017-.023.015-.024.014-.023.013-.023.012-.023.01-.023.01-.022.008-.022.006-.023.006-.021.004-.022.004-.021.001-.021.001-.021-.001-.021-.001-.021-.004-.021-.004-.022-.006-.021-.006-.023-.008-.022-.01-.022-.01-.023-.012-.023-.013-.023-.014-.023-.015-.024-.017-.023-.018-.024-.019-.024-.02-.025-.021-.024-.023-.024-.023-.025-.051-.05-.056-.05-.06-.05-.065-.051-.07-.052-.074-.051-.079-.052-.083-.052-.088-.052-.092-.052-.096-.052-.101-.052-.106-.052-.11-.052-.114-.052-.118-.051-.123-.051-.126-.051-.131-.05-.136-.05-.139-.049-.143-.048-.148-.048-.152-.048-.155-.046-.16-.046-.163-.045-.168-.043-.172-.043-.175-.042-.179-.041-.183-.04-.187-.038-.191-.038-.194-.036-.198-.034-.202-.033-.205-.032-.21-.031-.212-.028-.216-.027-.22-.026-.224-.023-.226-.022-.231-.021-.233-.018-.237-.016-.241-.014-.244-.012-.247-.011-.25-.008-.254-.005-.257-.004-.26-.001-.26.001z");
}, "insertDatabaseIcon"), Jy = h(function(e) {
	e.append("defs").append("symbol").attr("id", "computer").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr("d", "M2 2v13h20v-13h-20zm18 11h-16v-9h16v9zm-10.228 6l.466-1h3.524l.467 1h-4.457zm14.228 3h-24l2-6h2.104l-1.33 4h18.45l-1.297-4h2.073l2 6zm-5-10h-14v-7h14v7z");
}, "insertComputerIcon"), Jv = h(function(e) {
	e.append("defs").append("symbol").attr("id", "clock").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr("d", "M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm5.848 12.459c.202.038.202.333.001.372-1.907.361-6.045 1.111-6.547 1.111-.719 0-1.301-.582-1.301-1.301 0-.512.77-5.447 1.125-7.445.034-.192.312-.181.343.014l.985 6.238 5.394 1.011z");
}, "insertClockIcon"), Jx = h(function(e) {
	e.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 9).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z");
}, "insertArrowHead"), Jb = h(function(e) {
	e.append("defs").append("marker").attr("id", "arrowend").attr("refX", 1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 10 0 L 0 5 L 10 10 z");
}, "insertArrowEnd"), Jw = h(function(e) {
	e.append("defs").append("marker").attr("id", "filled-head").attr("refX", 18).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
}, "insertArrowFilledHead"), Jk = h(function(e) {
	let t = e.append("defs").append("marker").attr("id", "crosshead").attr("markerWidth", 15).attr("markerHeight", 8).attr("orient", "auto").attr("refX", 16).attr("refY", 4);
	t.append("path").attr("fill", "black").attr("stroke", "#000000").style("stroke-dasharray", "0, 0").attr("stroke-width", "1px").attr("d", "M 9,2 V 6 L16,4 Z"), t.append("path").attr("fill", "none").attr("stroke", "#000000").style("stroke-dasharray", "0, 0").attr("stroke-width", "1px").attr("d", "M 0,1 L 6,7 M 6,1 L 0,7");
}, "insertArrowCrossHead"), JT = h((e, t) => ({
	fontFamily: e[t + "FontFamily"],
	fontSize: e[t + "FontSize"],
	fontWeight: e[t + "FontWeight"]
}), "getC4ShapeFont"), J_ = function() {
	function e(e, t, r, n, a, s, o) {
		i(t.append("text").attr("x", r + a / 2).attr("y", n + s / 2 + 5).style("text-anchor", "middle").text(e), o);
	}
	function t(e, t, r, n, a, s, o, l) {
		let { fontSize: h, fontFamily: u, fontWeight: d } = l, p = e.split(M1.lineBreakRegex);
		for (let e = 0; e < p.length; e++) {
			let s = e * h - h * (p.length - 1) / 2, l = t.append("text").attr("x", r + a / 2).attr("y", n).style("text-anchor", "middle").attr("dominant-baseline", "middle").style("font-size", h).style("font-weight", d).style("font-family", u);
			l.append("tspan").attr("dy", s).text(p[e]).attr("alignment-baseline", "mathematical"), i(l, o);
		}
	}
	function r(e, r, n, a, s, o, l, h) {
		let u = r.append("switch"), d = u.append("foreignObject").attr("x", n).attr("y", a).attr("width", s).attr("height", o).append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
		d.append("div").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(e), t(e, u, n, a, s, o, l, h), i(d, l);
	}
	function i(e, t) {
		for (let r in t) t.hasOwnProperty(r) && e.attr(r, t[r]);
	}
	return h(e, "byText"), h(t, "byTspan"), h(r, "byFo"), h(i, "_setTextAttrs"), function(i) {
		return "fo" === i.textPlacement ? r : "old" === i.textPlacement ? e : t;
	};
}(), JE = 0, JC = 0, JS = 4, JA = 2;
QD.yy = Jc;
var JL = {}, JR = class {
	static {
		h(this, "Bounds");
	}
	constructor(e) {
		this.name = "", this.data = {}, this.data.startx = void 0, this.data.stopx = void 0, this.data.starty = void 0, this.data.stopy = void 0, this.data.widthLimit = void 0, this.nextData = {}, this.nextData.startx = void 0, this.nextData.stopx = void 0, this.nextData.starty = void 0, this.nextData.stopy = void 0, this.nextData.cnt = 0, JN(e.db.getConfig());
	}
	setData(e, t, r, i) {
		this.nextData.startx = this.data.startx = e, this.nextData.stopx = this.data.stopx = t, this.nextData.starty = this.data.starty = r, this.nextData.stopy = this.data.stopy = i;
	}
	updateVal(e, t, r, i) {
		void 0 === e[t] ? e[t] = r : e[t] = i(r, e[t]);
	}
	insert(e) {
		this.nextData.cnt = this.nextData.cnt + 1;
		let t = this.nextData.startx === this.nextData.stopx ? this.nextData.stopx + e.margin : this.nextData.stopx + 2 * e.margin, r = t + e.width, i = this.nextData.starty + 2 * e.margin, n = i + e.height;
		(t >= this.data.widthLimit || r >= this.data.widthLimit || this.nextData.cnt > JS) && (t = this.nextData.startx + e.margin + JL.nextLinePaddingX, i = this.nextData.stopy + 2 * e.margin, this.nextData.stopx = r = t + e.width, this.nextData.starty = this.nextData.stopy, this.nextData.stopy = n = i + e.height, this.nextData.cnt = 1), e.x = t, e.y = i, this.updateVal(this.data, "startx", t, Math.min), this.updateVal(this.data, "starty", i, Math.min), this.updateVal(this.data, "stopx", r, Math.max), this.updateVal(this.data, "stopy", n, Math.max), this.updateVal(this.nextData, "startx", t, Math.min), this.updateVal(this.nextData, "starty", i, Math.min), this.updateVal(this.nextData, "stopx", r, Math.max), this.updateVal(this.nextData, "stopy", n, Math.max);
	}
	init(e) {
		this.name = "", this.data = {
			startx: void 0,
			stopx: void 0,
			starty: void 0,
			stopy: void 0,
			widthLimit: void 0
		}, this.nextData = {
			startx: void 0,
			stopx: void 0,
			starty: void 0,
			stopy: void 0,
			cnt: 0
		}, JN(e.db.getConfig());
	}
	bumpLastMargin(e) {
		this.data.stopx += e, this.data.stopy += e;
	}
}, JN = h(function(e) {
	NF(JL, e), e.fontFamily && (JL.personFontFamily = JL.systemFontFamily = JL.messageFontFamily = e.fontFamily), e.fontSize && (JL.personFontSize = JL.systemFontSize = JL.messageFontSize = e.fontSize), e.fontWeight && (JL.personFontWeight = JL.systemFontWeight = JL.messageFontWeight = e.fontWeight);
}, "setConf"), JI = h((e, t) => ({
	fontFamily: e[t + "FontFamily"],
	fontSize: e[t + "FontSize"],
	fontWeight: e[t + "FontWeight"]
}), "c4ShapeFont"), JM = h((e) => ({
	fontFamily: e.boundaryFontFamily,
	fontSize: e.boundaryFontSize,
	fontWeight: e.boundaryFontWeight
}), "boundaryFont"), JD = h((e) => ({
	fontFamily: e.messageFontFamily,
	fontSize: e.messageFontSize,
	fontWeight: e.messageFontWeight
}), "messageFont");
function JO(e, t, r, i, n) {
	if (!t[e].width) if (r) t[e].text = VW(t[e].text, n, i), t[e].textLines = t[e].text.split(M1.lineBreakRegex).length, t[e].width = n, t[e].height = VV(t[e].text, i);
	else {
		let r = t[e].text.split(M1.lineBreakRegex);
		t[e].textLines = r.length;
		let n = 0;
		for (let a of (t[e].height = 0, t[e].width = 0, r)) t[e].width = Math.max(VH(a, i), t[e].width), n = VV(a, i), t[e].height = t[e].height + n;
	}
}
h(JO, "calcC4ShapeTextWH");
var J$ = h(function(e, t, r) {
	t.x = r.data.startx, t.y = r.data.starty, t.width = r.data.stopx - r.data.startx, t.height = r.data.stopy - r.data.starty, t.label.y = JL.c4ShapeMargin - 35;
	let i = t.wrap && JL.wrap, n = JM(JL);
	n.fontSize = n.fontSize + 2, n.fontWeight = "bold", JO("label", t, i, n, VH(t.label.text, n)), Jf(e, t, JL);
}, "drawBoundary"), JP = h(function(e, t, r, i) {
	let n = 0;
	for (let a of i) {
		n = 0;
		let i = r[a], s = JI(JL, i.typeC4Shape.text);
		switch (s.fontSize = s.fontSize - 2, i.typeC4Shape.width = VH("" + i.typeC4Shape.text + "", s), i.typeC4Shape.height = s.fontSize + 2, i.typeC4Shape.Y = JL.c4ShapePadding, n = i.typeC4Shape.Y + i.typeC4Shape.height - 4, i.image = {
			width: 0,
			height: 0,
			Y: 0
		}, i.typeC4Shape.text) {
			case "person":
			case "external_person": i.image.width = 48, i.image.height = 48, i.image.Y = n, n = i.image.Y + i.image.height;
		}
		i.sprite && (i.image.width = 48, i.image.height = 48, i.image.Y = n, n = i.image.Y + i.image.height);
		let o = i.wrap && JL.wrap, l = JL.width - 2 * JL.c4ShapePadding, h = JI(JL, i.typeC4Shape.text);
		(h.fontSize = h.fontSize + 2, h.fontWeight = "bold", JO("label", i, o, h, l), i.label.Y = n + 8, n = i.label.Y + i.label.height, i.type && "" !== i.type.text) ? (i.type.text = "[" + i.type.text + "]", JO("type", i, o, JI(JL, i.typeC4Shape.text), l), i.type.Y = n + 5, n = i.type.Y + i.type.height) : i.techn && "" !== i.techn.text && (i.techn.text = "[" + i.techn.text + "]", JO("techn", i, o, JI(JL, i.techn.text), l), i.techn.Y = n + 5, n = i.techn.Y + i.techn.height);
		let u = n, d = i.label.width;
		i.descr && "" !== i.descr.text && (JO("descr", i, o, JI(JL, i.typeC4Shape.text), l), i.descr.Y = n + 20, n = i.descr.Y + i.descr.height, d = Math.max(i.label.width, i.descr.width), u = n - 5 * i.descr.textLines), d += JL.c4ShapePadding, i.width = Math.max(i.width || JL.width, d, JL.width), i.height = Math.max(i.height || JL.height, u, JL.height), i.margin = i.margin || JL.c4ShapeMargin, e.insert(i), Jg(t, i, JL);
	}
	e.bumpLastMargin(JL.c4ShapeMargin);
}, "drawC4ShapeArray"), JB = class {
	static {
		h(this, "Point");
	}
	constructor(e, t) {
		this.x = e, this.y = t;
	}
}, JF = h(function(e, t) {
	let r = e.x, i = e.y, n = t.x, a = t.y, s = r + e.width / 2, o = i + e.height / 2, l = Math.abs(r - n), h = Math.abs(i - a), u = h / l, d = e.height / e.width, p = null;
	return i == a && r < n ? p = new JB(r + e.width, o) : i == a && r > n ? p = new JB(r, o) : r == n && i < a ? p = new JB(s, i + e.height) : r == n && i > a && (p = new JB(s, i)), r > n && i < a ? p = d >= u ? new JB(r, o + u * e.width / 2) : new JB(s - l / h * e.height / 2, i + e.height) : r < n && i < a ? p = d >= u ? new JB(r + e.width, o + u * e.width / 2) : new JB(s + l / h * e.height / 2, i + e.height) : r < n && i > a ? p = d >= u ? new JB(r + e.width, o - u * e.width / 2) : new JB(s + e.height / 2 * l / h, i) : r > n && i > a && (p = d >= u ? new JB(r, o - e.width / 2 * u) : new JB(s - e.height / 2 * l / h, i)), p;
}, "getIntersectPoint"), Jz = h(function(e, t) {
	let r = {
		x: 0,
		y: 0
	};
	r.x = t.x + t.width / 2, r.y = t.y + t.height / 2;
	let i = JF(e, r);
	return r.x = e.x + e.width / 2, r.y = e.y + e.height / 2, {
		startPoint: i,
		endPoint: JF(t, r)
	};
}, "getIntersectPoints"), JU = h(function(e, t, r, i) {
	let n = 0;
	for (let e of t) {
		n += 1;
		let t = e.wrap && JL.wrap, a = JD(JL);
		"C4Dynamic" === i.db.getC4Type() && (e.label.text = n + ": " + e.label.text);
		let s = VH(e.label.text, a);
		JO("label", e, t, a, s), e.techn && "" !== e.techn.text && (s = VH(e.techn.text, a), JO("techn", e, t, a, s)), e.descr && "" !== e.descr.text && (s = VH(e.descr.text, a), JO("descr", e, t, a, s));
		let o = Jz(r(e.from), r(e.to));
		e.startPoint = o.startPoint, e.endPoint = o.endPoint;
	}
	Jp(e, t, JL);
}, "drawRels");
function JG(e, t, r, i, n) {
	let a = new JR(n);
	for (let [s, o] of (a.data.widthLimit = r.data.widthLimit / Math.min(JA, i.length), i.entries())) {
		let i = 0;
		o.image = {
			width: 0,
			height: 0,
			Y: 0
		}, o.sprite && (o.image.width = 48, o.image.height = 48, o.image.Y = i, i = o.image.Y + o.image.height);
		let l = o.wrap && JL.wrap, h = JM(JL);
		if (h.fontSize = h.fontSize + 2, h.fontWeight = "bold", JO("label", o, l, h, a.data.widthLimit), o.label.Y = i + 8, i = o.label.Y + o.label.height, o.type && "" !== o.type.text && (o.type.text = "[" + o.type.text + "]", JO("type", o, l, JM(JL), a.data.widthLimit), o.type.Y = i + 5, i = o.type.Y + o.type.height), o.descr && "" !== o.descr.text) {
			let e = JM(JL);
			e.fontSize = e.fontSize - 2, JO("descr", o, l, e, a.data.widthLimit), o.descr.Y = i + 20, i = o.descr.Y + o.descr.height;
		}
		if (0 == s || s % JA == 0) {
			let e = r.data.startx + JL.diagramMarginX, t = r.data.stopy + JL.diagramMarginY + i;
			a.setData(e, e, t, t);
		} else {
			let e = a.data.stopx !== a.data.startx ? a.data.stopx + JL.diagramMarginX : a.data.startx, t = a.data.starty;
			a.setData(e, e, t, t);
		}
		a.name = o.alias;
		let u = n.db.getC4ShapeArray(o.alias), d = n.db.getC4ShapeKeys(o.alias);
		d.length > 0 && JP(a, e, u, d), t = o.alias;
		let p = n.db.getBoundaries(t);
		p.length > 0 && JG(e, t, a, p, n), "global" !== o.alias && J$(e, o, a), r.data.stopy = Math.max(a.data.stopy + JL.c4ShapeMargin, r.data.stopy), r.data.stopx = Math.max(a.data.stopx + JL.c4ShapeMargin, r.data.stopx), JE = Math.max(JE, r.data.stopx), JC = Math.max(JC, r.data.stopy);
	}
}
h(JG, "drawInsideBoundary");
var Jq = {
	drawPersonOrSystemArray: JP,
	drawBoundary: J$,
	setConf: JN,
	draw: h(function(e, t, r, i) {
		JL = IA().c4;
		let n = IA().securityLevel, a;
		"sandbox" === n && (a = _t("#i" + t));
		let s = "sandbox" === n ? _t(a.nodes()[0].contentDocument.body) : _t("body"), o = i.db;
		i.db.setWrap(JL.wrap), JS = o.getC4ShapeInRow(), JA = o.getC4BoundaryInRow(), wQ.debug(`C:${JSON.stringify(JL, null, 2)}`);
		let l = "sandbox" === n ? s.select(`[id="${t}"]`) : _t(`[id="${t}"]`);
		Jy(l), Jm(l), Jv(l);
		let h = new JR(i);
		h.setData(JL.diagramMarginX, JL.diagramMarginX, JL.diagramMarginY, JL.diagramMarginY), h.data.widthLimit = screen.availWidth, JE = JL.diagramMarginX, JC = JL.diagramMarginY;
		let u = i.db.getTitle();
		JG(l, "", h, i.db.getBoundaries(""), i), Jx(l), Jb(l), Jk(l), Jw(l), JU(l, i.db.getRels(), i.db.getC4Shape, i), h.data.stopx = JE, h.data.stopy = JC;
		let d = h.data, p = d.stopy - d.starty + 2 * JL.diagramMarginY, f = d.stopx - d.startx + 2 * JL.diagramMarginX;
		u && l.append("text").text(u).attr("x", (d.stopx - d.startx) / 2 - 4 * JL.diagramMarginX).attr("y", d.starty + JL.diagramMarginY), M5(l, p, f, JL.useMaxWidth);
		let g = 60 * !!u;
		l.attr("viewBox", d.startx - JL.diagramMarginX + " -" + (JL.diagramMarginY + g) + " " + f + " " + (p + g)), wQ.debug("models:", d);
	}, "draw")
}, Jj = {
	parser: QD,
	db: Jc,
	renderer: Jq,
	styles: h((e) => `.person {
    stroke: ${e.personBorder};
    fill: ${e.personBkg};
  }
`, "getStyles"),
	init: h(({ c4: e, wrap: t }) => {
		Jq.setConf(e), Jc.setWrap(t);
	}, "init")
}, JW = h((e, t) => {
	let r;
	return "sandbox" === t && (r = _t("#i" + e)), ("sandbox" === t ? _t(r.nodes()[0].contentDocument.body) : _t("body")).select(`[id="${e}"]`);
}, "getDiagramElement"), JY = h((e, t, r, i) => {
	e.attr("class", r);
	let { width: n, height: a, x: s, y: o } = JV(e, t);
	M5(e, a, n, i);
	let l = JH(s, o, n, a, t);
	e.attr("viewBox", l), wQ.debug(`viewBox configured: ${l} with padding: ${t}`);
}, "setupViewPortForSVG"), JV = h((e, t) => {
	let r = e.node()?.getBBox() || {
		width: 0,
		height: 0,
		x: 0,
		y: 0
	};
	return {
		width: r.width + 2 * t,
		height: r.height + 2 * t,
		x: r.x,
		y: r.y
	};
}, "calculateDimensionsWithPadding"), JH = h((e, t, r, i, n) => `${e - n} ${t - n} ${r} ${i}`, "createViewBox"), JX = h((e) => {
	let { handDrawnSeed: t } = IA();
	return {
		fill: e,
		hachureAngle: 120,
		hachureGap: 4,
		fillWeight: 2,
		roughness: .7,
		stroke: e,
		seed: t
	};
}, "solidStateFill"), JK = h((e) => {
	let t = JZ([
		...e.cssCompiledStyles || [],
		...e.cssStyles || [],
		...e.labelStyle || []
	]);
	return {
		stylesMap: t,
		stylesArray: [...t]
	};
}, "compileStyles"), JZ = h((e) => {
	let t = /* @__PURE__ */ new Map();
	return e.forEach((e) => {
		let [r, i] = e.split(":");
		t.set(r.trim(), i?.trim());
	}), t;
}, "styles2Map"), JQ = h((e) => "color" === e || "font-size" === e || "font-family" === e || "font-weight" === e || "font-style" === e || "text-decoration" === e || "text-align" === e || "text-transform" === e || "line-height" === e || "letter-spacing" === e || "word-spacing" === e || "text-shadow" === e || "text-overflow" === e || "white-space" === e || "word-wrap" === e || "word-break" === e || "overflow-wrap" === e || "hyphens" === e, "isLabelStyle"), JJ = h((e) => {
	let { stylesArray: t } = JK(e), r = [], i = [], n = [], a = [];
	return t.forEach((e) => {
		let t = e[0];
		JQ(t) ? r.push(e.join(":") + " !important") : (i.push(e.join(":") + " !important"), t.includes("stroke") && n.push(e.join(":") + " !important"), "fill" === t && a.push(e.join(":") + " !important"));
	}), {
		labelStyles: r.join(";"),
		nodeStyles: i.join(";"),
		stylesArray: t,
		borderStyles: n,
		backgroundStyles: a
	};
}, "styles2String"), J0 = h((e, t) => {
	let { themeVariables: r, handDrawnSeed: i } = IA(), { nodeBorder: n, mainBkg: a } = r, { stylesMap: s } = JK(e);
	return Object.assign({
		roughness: .7,
		fill: s.get("fill") || a,
		fillStyle: "hachure",
		fillWeight: 4,
		hachureGap: 5.2,
		stroke: s.get("stroke") || n,
		seed: i,
		strokeWidth: s.get("stroke-width")?.replace("px", "") || 1.3,
		fillLineDash: [0, 0],
		strokeLineDash: J1(s.get("stroke-dasharray"))
	}, t);
}, "userNodeOverrides"), J1 = h((e) => {
	if (!e) return [0, 0];
	let t = e.trim().split(/\s+/).map(Number);
	if (1 === t.length) {
		let e = isNaN(t[0]) ? 0 : t[0];
		return [e, e];
	}
	return [isNaN(t[0]) ? 0 : t[0], isNaN(t[1]) ? 0 : t[1]];
}, "getStrokeDashArray"), J2 = h(async (e, t, r) => {
	let i = t.useHtmlLabels || MG(IA()?.htmlLabels), n = e.insert("g").attr("class", r || "node default").attr("id", t.domId || t.id), a = n.insert("g").attr("class", "label").attr("style", V8(t.labelStyle)), s;
	s = void 0 === t.label ? "" : "string" == typeof t.label ? t.label : t.label[0];
	let o = await XQ(a, MO(V6(s), IA()), {
		useHtmlLabels: i,
		width: t.width || IA().flowchart?.wrappingWidth,
		cssClasses: "markdown-node-label",
		style: t.labelStyle,
		addSvgBackground: !!t.icon || !!t.img
	}), l = o.getBBox(), u = (t?.padding ?? 0) / 2;
	if (i) {
		let e = o.children[0], t = _t(o), r = e.getElementsByTagName("img");
		if (r) {
			let e = "" === s.replace(/<img[^>]*>/g, "").trim();
			await Promise.all([...r].map((t) => new Promise((r) => {
				function i() {
					if (t.style.display = "flex", t.style.flexDirection = "column", e) {
						let [e = Ip.fontSize] = V4(IA().fontSize ? IA().fontSize : window.getComputedStyle(document.body).fontSize), r = 5 * e + "px";
						t.style.minWidth = r, t.style.maxWidth = r;
					} else t.style.width = "100%";
					r(t);
				}
				h(i, "setupImage"), setTimeout(() => {
					t.complete && i();
				}), t.addEventListener("error", i), t.addEventListener("load", i);
			})));
		}
		l = e.getBoundingClientRect(), t.attr("width", l.width), t.attr("height", l.height);
	}
	return i ? a.attr("transform", "translate(" + -l.width / 2 + ", " + -l.height / 2 + ")") : a.attr("transform", "translate(0, " + -l.height / 2 + ")"), t.centerLabel && a.attr("transform", "translate(" + -l.width / 2 + ", " + -l.height / 2 + ")"), a.insert("rect", ":first-child"), {
		shapeSvg: n,
		bbox: l,
		halfPadding: u,
		label: a
	};
}, "labelHelper"), J4 = h(async (e, t, r) => {
	let i = r.useHtmlLabels || MG(IA()?.flowchart?.htmlLabels), n = e.insert("g").attr("class", "label").attr("style", r.labelStyle || ""), a = await XQ(n, MO(V6(t), IA()), {
		useHtmlLabels: i,
		width: r.width || IA()?.flowchart?.wrappingWidth,
		style: r.labelStyle,
		addSvgBackground: !!r.icon || !!r.img
	}), s = a.getBBox(), o = r.padding / 2;
	if (MG(IA()?.flowchart?.htmlLabels)) {
		let e = a.children[0], t = _t(a);
		s = e.getBoundingClientRect(), t.attr("width", s.width), t.attr("height", s.height);
	}
	return i ? n.attr("transform", "translate(" + -s.width / 2 + ", " + -s.height / 2 + ")") : n.attr("transform", "translate(0, " + -s.height / 2 + ")"), r.centerLabel && n.attr("transform", "translate(" + -s.width / 2 + ", " + -s.height / 2 + ")"), n.insert("rect", ":first-child"), {
		shapeSvg: e,
		bbox: s,
		halfPadding: o,
		label: n
	};
}, "insertLabel"), J5 = h((e, t) => {
	let r = t.node().getBBox();
	e.width = r.width, e.height = r.height;
}, "updateNodeBounds"), J3 = h((e, t) => ("handDrawn" === e.look ? "rough-node" : "node") + " " + e.cssClasses + " " + (t || ""), "getNodeClasses");
function J6(e) {
	let t = e.map((e, t) => `${0 === t ? "M" : "L"}${e.x},${e.y}`);
	return t.push("Z"), t.join(" ");
}
function J7(e, t, r, i, n, a) {
	let s = [], o = r - e, l = 2 * Math.PI / (o / a), h = t + (i - t) / 2;
	for (let t = 0; t <= 50; t++) {
		let r = e + t / 50 * o, i = h + n * Math.sin(l * (r - e));
		s.push({
			x: r,
			y: i
		});
	}
	return s;
}
function J8(e, t, r, i, n, a) {
	let s = [], o = n * Math.PI / 180, l = (a * Math.PI / 180 - o) / (i - 1);
	for (let n = 0; n < i; n++) {
		let i = o + n * l, a = e + r * Math.cos(i), h = t + r * Math.sin(i);
		s.push({
			x: -a,
			y: -h
		});
	}
	return s;
}
function J9(e, t, r) {
	if (e && e.length) {
		let [i, n] = t, a = Math.PI / 180 * r, s = Math.cos(a), o = Math.sin(a);
		for (let t of e) {
			let [e, r] = t;
			t[0] = (e - i) * s - (r - n) * o + i, t[1] = (e - i) * o + (r - n) * s + n;
		}
	}
}
function eee(e, t) {
	return e[0] === t[0] && e[1] === t[1];
}
function eet(e, t, r, i = 1) {
	let n = Math.max(t, .1), a = e[0] && e[0][0] && "number" == typeof e[0][0] ? [e] : e, s = [0, 0];
	if (r) for (let e of a) J9(e, s, r);
	let o = function(e, t, r) {
		let i = [];
		for (let t of e) {
			let e = [...t];
			eee(e[0], e[e.length - 1]) || e.push([e[0][0], e[0][1]]), e.length > 2 && i.push(e);
		}
		let n = [];
		t = Math.max(t, .1);
		let a = [];
		for (let e of i) for (let t = 0; t < e.length - 1; t++) {
			let r = e[t], i = e[t + 1];
			if (r[1] !== i[1]) {
				let e = Math.min(r[1], i[1]);
				a.push({
					ymin: e,
					ymax: Math.max(r[1], i[1]),
					x: e === r[1] ? r[0] : i[0],
					islope: (i[0] - r[0]) / (i[1] - r[1])
				});
			}
		}
		if (a.sort((e, t) => e.ymin < t.ymin ? -1 : e.ymin > t.ymin ? 1 : e.x < t.x ? -1 : e.x > t.x ? 1 : e.ymax === t.ymax ? 0 : (e.ymax - t.ymax) / Math.abs(e.ymax - t.ymax)), !a.length) return n;
		let s = [], o = a[0].ymin, l = 0;
		for (; s.length || a.length;) {
			if (a.length) {
				let e = -1;
				for (let t = 0; t < a.length && !(a[t].ymin > o); t++) e = t;
				a.splice(0, e + 1).forEach((e) => {
					s.push({
						s: o,
						edge: e
					});
				});
			}
			if ((s = s.filter((e) => !(e.edge.ymax <= o))).sort((e, t) => e.edge.x === t.edge.x ? 0 : (e.edge.x - t.edge.x) / Math.abs(e.edge.x - t.edge.x)), (1 !== r || l % t == 0) && s.length > 1) for (let e = 0; e < s.length; e += 2) {
				let t = e + 1;
				if (t >= s.length) break;
				let r = s[e].edge, i = s[t].edge;
				n.push([[Math.round(r.x), o], [Math.round(i.x), o]]);
			}
			o += r, s.forEach((e) => {
				e.edge.x = e.edge.x + r * e.edge.islope;
			}), l++;
		}
		return n;
	}(a, n, i);
	if (r) {
		let e;
		for (let e of a) J9(e, s, -r);
		e = [], o.forEach((t) => e.push(...t)), J9(e, s, -r);
	}
	return o;
}
function eer(e, t) {
	var r;
	let i = t.hachureAngle + 90, n = t.hachureGap;
	n < 0 && (n = 4 * t.strokeWidth), n = Math.round(Math.max(n, .1));
	let a = 1;
	return t.roughness >= 1 && ((null == (r = t.randomizer) ? void 0 : r.next()) || Math.random()) > .7 && (a = n), eet(e, n, i, a || 1);
}
h(J6, "createPathFromPoints"), h(J7, "generateFullSineWavePoints"), h(J8, "generateCirclePoints"), h(J9, "t"), h(eee, "e"), h(eet, "s"), h(eer, "n");
var eei = class {
	static {
		h(this, "o");
	}
	constructor(e) {
		this.helper = e;
	}
	fillPolygons(e, t) {
		return this._fillPolygons(e, t);
	}
	_fillPolygons(e, t) {
		let r = eer(e, t);
		return {
			type: "fillSketch",
			ops: this.renderLines(r, t)
		};
	}
	renderLines(e, t) {
		let r = [];
		for (let i of e) r.push(...this.helper.doubleLineOps(i[0][0], i[0][1], i[1][0], i[1][1], t));
		return r;
	}
};
function een(e) {
	let t = e[0], r = e[1];
	return Math.sqrt(Math.pow(t[0] - r[0], 2) + Math.pow(t[1] - r[1], 2));
}
h(een, "a");
var eea = class extends eei {
	static {
		h(this, "h");
	}
	fillPolygons(e, t) {
		let r = t.hachureGap;
		r < 0 && (r = 4 * t.strokeWidth);
		let i = eer(e, Object.assign({}, t, { hachureGap: r = Math.max(r, .1) })), n = Math.PI / 180 * t.hachureAngle, a = [], s = .5 * r * Math.cos(n), o = .5 * r * Math.sin(n);
		for (let [e, t] of i) een([e, t]) && a.push([[e[0] - s, e[1] + o], [...t]], [[e[0] + s, e[1] - o], [...t]]);
		return {
			type: "fillSketch",
			ops: this.renderLines(a, t)
		};
	}
}, ees = class extends eei {
	static {
		h(this, "r");
	}
	fillPolygons(e, t) {
		let r = this._fillPolygons(e, t), i = Object.assign({}, t, { hachureAngle: t.hachureAngle + 90 }), n = this._fillPolygons(e, i);
		return r.ops = r.ops.concat(n.ops), r;
	}
}, eeo = class {
	static {
		h(this, "i");
	}
	constructor(e) {
		this.helper = e;
	}
	fillPolygons(e, t) {
		let r = eer(e, t = Object.assign({}, t, { hachureAngle: 0 }));
		return this.dotsOnLines(r, t);
	}
	dotsOnLines(e, t) {
		let r = [], i = t.hachureGap;
		i < 0 && (i = 4 * t.strokeWidth), i = Math.max(i, .1);
		let n = t.fillWeight;
		n < 0 && (n = t.strokeWidth / 2);
		let a = i / 4;
		for (let s of e) {
			let e = een(s), o = Math.ceil(e / i) - 1, l = e - o * i, h = (s[0][0] + s[1][0]) / 2 - i / 4, u = Math.min(s[0][1], s[1][1]);
			for (let e = 0; e < o; e++) {
				let s = h - a + 2 * Math.random() * a, o = u + l + e * i - a + 2 * Math.random() * a, d = this.helper.ellipse(s, o, n, n, t);
				r.push(...d.ops);
			}
		}
		return {
			type: "fillSketch",
			ops: r
		};
	}
}, eel = class {
	static {
		h(this, "c");
	}
	constructor(e) {
		this.helper = e;
	}
	fillPolygons(e, t) {
		let r = eer(e, t);
		return {
			type: "fillSketch",
			ops: this.dashedLine(r, t)
		};
	}
	dashedLine(e, t) {
		let r = t.dashOffset < 0 ? t.hachureGap < 0 ? 4 * t.strokeWidth : t.hachureGap : t.dashOffset, i = t.dashGap < 0 ? t.hachureGap < 0 ? 4 * t.strokeWidth : t.hachureGap : t.dashGap, n = [];
		return e.forEach((e) => {
			let a = een(e), s = Math.floor(a / (r + i)), o = (a + i - s * (r + i)) / 2, l = e[0], h = e[1];
			l[0] > h[0] && (l = e[1], h = e[0]);
			let u = Math.atan((h[1] - l[1]) / (h[0] - l[0]));
			for (let e = 0; e < s; e++) {
				let a = e * (r + i), s = a + r, h = [l[0] + a * Math.cos(u) + o * Math.cos(u), l[1] + a * Math.sin(u) + o * Math.sin(u)], d = [l[0] + s * Math.cos(u) + o * Math.cos(u), l[1] + s * Math.sin(u) + o * Math.sin(u)];
				n.push(...this.helper.doubleLineOps(h[0], h[1], d[0], d[1], t));
			}
		}), n;
	}
}, eec = class {
	static {
		h(this, "l");
	}
	constructor(e) {
		this.helper = e;
	}
	fillPolygons(e, t) {
		let r = t.hachureGap < 0 ? 4 * t.strokeWidth : t.hachureGap, i = t.zigzagOffset < 0 ? r : t.zigzagOffset, n = eer(e, t = Object.assign({}, t, { hachureGap: r + i }));
		return {
			type: "fillSketch",
			ops: this.zigzagLines(n, i, t)
		};
	}
	zigzagLines(e, t, r) {
		let i = [];
		return e.forEach((e) => {
			let n = Math.round(een(e) / (2 * t)), a = e[0], s = e[1];
			a[0] > s[0] && (a = e[1], s = e[0]);
			let o = Math.atan((s[1] - a[1]) / (s[0] - a[0]));
			for (let e = 0; e < n; e++) {
				let n = 2 * e * t, s = 2 * (e + 1) * t, l = Math.sqrt(2 * Math.pow(t, 2)), h = [a[0] + n * Math.cos(o), a[1] + n * Math.sin(o)], u = [a[0] + s * Math.cos(o), a[1] + s * Math.sin(o)], d = [h[0] + l * Math.cos(o + Math.PI / 4), h[1] + l * Math.sin(o + Math.PI / 4)];
				i.push(...this.helper.doubleLineOps(h[0], h[1], d[0], d[1], r), ...this.helper.doubleLineOps(d[0], d[1], u[0], u[1], r));
			}
		}), i;
	}
}, eeh = {}, eeu = class {
	static {
		h(this, "p");
	}
	constructor(e) {
		this.seed = e;
	}
	next() {
		return this.seed ? (2147483647 & (this.seed = Math.imul(48271, this.seed))) / 2147483648 : Math.random();
	}
}, eed = {
	A: 7,
	a: 7,
	C: 6,
	c: 6,
	H: 1,
	h: 1,
	L: 2,
	l: 2,
	M: 2,
	m: 2,
	Q: 4,
	q: 4,
	S: 4,
	s: 4,
	T: 2,
	t: 2,
	V: 1,
	v: 1,
	Z: 0,
	z: 0
};
function eep(e, t) {
	return e.type === t;
}
function eef(e) {
	let t = [], r = function(e) {
		let t = [];
		for (; "" !== e;) if (e.match(/^([ \t\r\n,]+)/)) e = e.substr(RegExp.$1.length);
		else if (e.match(/^([aAcChHlLmMqQsStTvVzZ])/)) t[t.length] = {
			type: 0,
			text: RegExp.$1
		}, e = e.substr(RegExp.$1.length);
		else {
			if (!e.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/)) return [];
			t[t.length] = {
				type: 1,
				text: `${parseFloat(RegExp.$1)}`
			}, e = e.substr(RegExp.$1.length);
		}
		return t[t.length] = {
			type: 2,
			text: ""
		}, t;
	}(e), i = "BOD", n = 0, a = r[0];
	for (; !eep(a, 2);) {
		let s = 0, o = [];
		if ("BOD" === i) {
			if ("M" !== a.text && "m" !== a.text) return eef("M0,0" + e);
			n++, s = eed[a.text], i = a.text;
		} else eep(a, 1) ? s = eed[i] : (n++, s = eed[a.text], i = a.text);
		if (!(n + s < r.length)) throw Error("Path data ended short");
		for (let e = n; e < n + s; e++) {
			let t = r[e];
			if (!eep(t, 1)) throw Error("Param not a number: " + i + "," + t.text);
			o[o.length] = +t.text;
		}
		if ("number" != typeof eed[i]) throw Error("Bad segment: " + i);
		{
			let e = {
				key: i,
				data: o
			};
			t.push(e), n += s, a = r[n], "M" === i && (i = "L"), "m" === i && (i = "l");
		}
	}
	return t;
}
function eeg(e) {
	let t = 0, r = 0, i = 0, n = 0, a = [];
	for (let { key: s, data: o } of e) switch (s) {
		case "M":
			a.push({
				key: "M",
				data: [...o]
			}), [t, r] = o, [i, n] = o;
			break;
		case "m":
			t += o[0], r += o[1], a.push({
				key: "M",
				data: [t, r]
			}), i = t, n = r;
			break;
		case "L":
			a.push({
				key: "L",
				data: [...o]
			}), [t, r] = o;
			break;
		case "l":
			t += o[0], r += o[1], a.push({
				key: "L",
				data: [t, r]
			});
			break;
		case "C":
			a.push({
				key: "C",
				data: [...o]
			}), t = o[4], r = o[5];
			break;
		case "c": {
			let e = o.map((e, i) => i % 2 ? e + r : e + t);
			a.push({
				key: "C",
				data: e
			}), t = e[4], r = e[5];
			break;
		}
		case "Q":
			a.push({
				key: "Q",
				data: [...o]
			}), t = o[2], r = o[3];
			break;
		case "q": {
			let e = o.map((e, i) => i % 2 ? e + r : e + t);
			a.push({
				key: "Q",
				data: e
			}), t = e[2], r = e[3];
			break;
		}
		case "A":
			a.push({
				key: "A",
				data: [...o]
			}), t = o[5], r = o[6];
			break;
		case "a":
			t += o[5], r += o[6], a.push({
				key: "A",
				data: [
					o[0],
					o[1],
					o[2],
					o[3],
					o[4],
					t,
					r
				]
			});
			break;
		case "H":
			a.push({
				key: "H",
				data: [...o]
			}), t = o[0];
			break;
		case "h":
			t += o[0], a.push({
				key: "H",
				data: [t]
			});
			break;
		case "V":
			a.push({
				key: "V",
				data: [...o]
			}), r = o[0];
			break;
		case "v":
			r += o[0], a.push({
				key: "V",
				data: [r]
			});
			break;
		case "S":
			a.push({
				key: "S",
				data: [...o]
			}), t = o[2], r = o[3];
			break;
		case "s": {
			let e = o.map((e, i) => i % 2 ? e + r : e + t);
			a.push({
				key: "S",
				data: e
			}), t = e[2], r = e[3];
			break;
		}
		case "T":
			a.push({
				key: "T",
				data: [...o]
			}), t = o[0], r = o[1];
			break;
		case "t":
			t += o[0], r += o[1], a.push({
				key: "T",
				data: [t, r]
			});
			break;
		case "Z":
		case "z": a.push({
			key: "Z",
			data: []
		}), t = i, r = n;
	}
	return a;
}
function eem(e) {
	let t = [], r = "", i = 0, n = 0, a = 0, s = 0, o = 0, l = 0;
	for (let { key: h, data: u } of e) {
		switch (h) {
			case "M":
				t.push({
					key: "M",
					data: [...u]
				}), [i, n] = u, [a, s] = u;
				break;
			case "C":
				t.push({
					key: "C",
					data: [...u]
				}), i = u[4], n = u[5], o = u[2], l = u[3];
				break;
			case "L":
				t.push({
					key: "L",
					data: [...u]
				}), [i, n] = u;
				break;
			case "H":
				i = u[0], t.push({
					key: "L",
					data: [i, n]
				});
				break;
			case "V":
				n = u[0], t.push({
					key: "L",
					data: [i, n]
				});
				break;
			case "S": {
				let e = 0, a = 0;
				"C" === r || "S" === r ? (e = i + (i - o), a = n + (n - l)) : (e = i, a = n), t.push({
					key: "C",
					data: [
						e,
						a,
						...u
					]
				}), o = u[0], l = u[1], i = u[2], n = u[3];
				break;
			}
			case "T": {
				let [e, a] = u, s = 0, h = 0;
				"Q" === r || "T" === r ? (s = i + (i - o), h = n + (n - l)) : (s = i, h = n);
				let d = i + 2 * (s - i) / 3, p = n + 2 * (h - n) / 3, f = e + 2 * (s - e) / 3, g = a + 2 * (h - a) / 3;
				t.push({
					key: "C",
					data: [
						d,
						p,
						f,
						g,
						e,
						a
					]
				}), o = s, l = h, i = e, n = a;
				break;
			}
			case "Q": {
				let [e, r, a, s] = u, h = i + 2 * (e - i) / 3, d = n + 2 * (r - n) / 3, p = a + 2 * (e - a) / 3, f = s + 2 * (r - s) / 3;
				t.push({
					key: "C",
					data: [
						h,
						d,
						p,
						f,
						a,
						s
					]
				}), o = e, l = r, i = a, n = s;
				break;
			}
			case "A": {
				let e = Math.abs(u[0]), r = Math.abs(u[1]), a = u[2], s = u[3], o = u[4], l = u[5], h = u[6];
				0 === e || 0 === r ? (t.push({
					key: "C",
					data: [
						i,
						n,
						l,
						h,
						l,
						h
					]
				}), i = l, n = h) : (i !== l || n !== h) && (eev(i, n, l, h, e, r, a, s, o).forEach(function(e) {
					t.push({
						key: "C",
						data: e
					});
				}), i = l, n = h);
				break;
			}
			case "Z": t.push({
				key: "Z",
				data: []
			}), i = a, n = s;
		}
		r = h;
	}
	return t;
}
function eey(e, t, r) {
	return [e * Math.cos(r) - t * Math.sin(r), e * Math.sin(r) + t * Math.cos(r)];
}
function eev(e, t, r, i, n, a, s, o, l, h) {
	let u = Math.PI * s / 180, d = [], p = 0, f = 0, g = 0, m = 0;
	if (h) [p, f, g, m] = h;
	else {
		[e, t] = eey(e, t, -u), [r, i] = eey(r, i, -u);
		let s = (e - r) / 2, h = (t - i) / 2, d = s * s / (n * n) + h * h / (a * a);
		d > 1 && (n *= d = Math.sqrt(d), a *= d);
		let y = n * n, v = a * a, x = (o === l ? -1 : 1) * Math.sqrt(Math.abs((y * v - y * h * h - v * s * s) / (y * h * h + v * s * s)));
		g = x * n * h / a + (e + r) / 2, m = -(x * a) * s / n + (t + i) / 2, p = Math.asin(parseFloat(((t - m) / a).toFixed(9))), f = Math.asin(parseFloat(((i - m) / a).toFixed(9))), e < g && (p = Math.PI - p), r < g && (f = Math.PI - f), p < 0 && (p = 2 * Math.PI + p), f < 0 && (f = 2 * Math.PI + f), l && p > f && (p -= 2 * Math.PI), !l && f > p && (f -= 2 * Math.PI);
	}
	let y = f - p;
	if (Math.abs(y) > 120 * Math.PI / 180) {
		let e = f, t = r, o = i;
		d = eev(r = g + n * Math.cos(f = l && f > p ? p + 120 * Math.PI / 180 * 1 : p + -(120 * Math.PI / 180 * 1)), i = m + a * Math.sin(f), t, o, n, a, s, 0, l, [
			f,
			e,
			g,
			m
		]);
	}
	y = f - p;
	let v = Math.cos(p), x = Math.cos(f), b = Math.tan(y / 4), w = 4 / 3 * n * b, k = 4 / 3 * a * b, T = [e, t], _ = [e + w * Math.sin(p), t - k * v], E = [r + w * Math.sin(f), i - k * x], C = [r, i];
	if (_[0] = 2 * T[0] - _[0], _[1] = 2 * T[1] - _[1], h) return [
		_,
		E,
		C
	].concat(d);
	{
		d = [
			_,
			E,
			C
		].concat(d);
		let e = [];
		for (let t = 0; t < d.length; t += 3) {
			let r = eey(d[t][0], d[t][1], u), i = eey(d[t + 1][0], d[t + 1][1], u), n = eey(d[t + 2][0], d[t + 2][1], u);
			e.push([
				r[0],
				r[1],
				i[0],
				i[1],
				n[0],
				n[1]
			]);
		}
		return e;
	}
}
h(eep, "k"), h(eef, "b"), h(eeg, "y"), h(eem, "m"), h(eey, "w"), h(eev, "x");
var eex = {
	randOffset: h(function(e, t) {
		return eeM(e, t);
	}, "randOffset"),
	randOffsetWithRange: h(function(e, t, r) {
		return eeI(e, t, r);
	}, "randOffsetWithRange"),
	ellipse: h(function(e, t, r, i, n) {
		return eeE(e, t, n, ee_(r, i, n)).opset;
	}, "ellipse"),
	doubleLineOps: h(function(e, t, r, i, n) {
		return eeD(e, t, r, i, n, !0);
	}, "doubleLineOps")
};
function eeb(e, t, r, i, n) {
	return {
		type: "path",
		ops: eeD(e, t, r, i, n)
	};
}
function eew(e, t, r) {
	let i = (e || []).length;
	if (i > 2) {
		let n = [];
		for (let t = 0; t < i - 1; t++) n.push(...eeD(e[t][0], e[t][1], e[t + 1][0], e[t + 1][1], r));
		return t && n.push(...eeD(e[i - 1][0], e[i - 1][1], e[0][0], e[0][1], r)), {
			type: "path",
			ops: n
		};
	}
	return 2 === i ? eeb(e[0][0], e[0][1], e[1][0], e[1][1], r) : {
		type: "path",
		ops: []
	};
}
function eek(e, t, r, i, n) {
	return eew([
		[e, t],
		[e + r, t],
		[e + r, t + i],
		[e, t + i]
	], !0, n);
}
function eeT(e, t) {
	if (e.length) {
		let r = "number" == typeof e[0][0] ? [e] : e, i = ee$(r[0], +(1 + .2 * t.roughness), t), n = t.disableMultiStroke ? [] : ee$(r[0], 1.5 * (1 + .22 * t.roughness), eeR(t));
		for (let e = 1; e < r.length; e++) {
			let a = r[e];
			if (a.length) {
				let e = ee$(a, +(1 + .2 * t.roughness), t), r = t.disableMultiStroke ? [] : ee$(a, 1.5 * (1 + .22 * t.roughness), eeR(t));
				for (let t of e) "move" !== t.op && i.push(t);
				for (let e of r) "move" !== e.op && n.push(e);
			}
		}
		return {
			type: "path",
			ops: i.concat(n)
		};
	}
	return {
		type: "path",
		ops: []
	};
}
function ee_(e, t, r) {
	let i = Math.sqrt(2 * Math.PI * Math.sqrt((Math.pow(e / 2, 2) + Math.pow(t / 2, 2)) / 2)), n = 2 * Math.PI / Math.ceil(Math.max(r.curveStepCount, r.curveStepCount / Math.sqrt(200) * i)), a = Math.abs(e / 2), s = Math.abs(t / 2), o = 1 - r.curveFitting;
	return a += eeM(a * o, r), s += eeM(s * o, r), {
		increment: n,
		rx: a,
		ry: s
	};
}
function eeE(e, t, r, i) {
	let [n, a] = eeB(i.increment, e, t, i.rx, i.ry, 1, i.increment * eeI(.1, eeI(.4, 1, r), r), r), s = eeP(n, null, r);
	if (!r.disableMultiStroke && 0 !== r.roughness) {
		let [n] = eeB(i.increment, e, t, i.rx, i.ry, 1.5, 0, r), a = eeP(n, null, r);
		s = s.concat(a);
	}
	return {
		estimatedPoints: a,
		opset: {
			type: "path",
			ops: s
		}
	};
}
function eeC(e, t, r, i, n, a, s, o, l) {
	let h = Math.abs(r / 2), u = Math.abs(i / 2);
	h += eeM(.01 * h, l), u += eeM(.01 * u, l);
	let d = n, p = a;
	for (; d < 0;) d += 2 * Math.PI, p += 2 * Math.PI;
	p - d > 2 * Math.PI && (d = 0, p = 2 * Math.PI);
	let f = Math.min(2 * Math.PI / l.curveStepCount / 2, (p - d) / 2), g = eeF(f, e, t, h, u, d, p, 1, l);
	if (!l.disableMultiStroke) {
		let r = eeF(f, e, t, h, u, d, p, 1.5, l);
		g.push(...r);
	}
	return s && (o ? g.push(...eeD(e, t, e + h * Math.cos(d), t + u * Math.sin(d), l), ...eeD(e, t, e + h * Math.cos(p), t + u * Math.sin(p), l)) : g.push({
		op: "lineTo",
		data: [e, t]
	}, {
		op: "lineTo",
		data: [e + h * Math.cos(d), t + u * Math.sin(d)]
	})), {
		type: "path",
		ops: g
	};
}
function eeS(e, t) {
	let r = eem(eeg(eef(e))), i = [], n = [0, 0], a = [0, 0];
	for (let { key: e, data: s } of r) switch (e) {
		case "M":
			a = [s[0], s[1]], n = [s[0], s[1]];
			break;
		case "L":
			i.push(...eeD(a[0], a[1], s[0], s[1], t)), a = [s[0], s[1]];
			break;
		case "C": {
			let [e, r, n, o, l, h] = s;
			i.push(...eez(e, r, n, o, l, h, a, t)), a = [l, h];
			break;
		}
		case "Z": i.push(...eeD(a[0], a[1], n[0], n[1], t)), a = [n[0], n[1]];
	}
	return {
		type: "path",
		ops: i
	};
}
function eeA(e, t) {
	let r = [];
	for (let i of e) if (i.length) {
		let e = t.maxRandomnessOffset || 0, n = i.length;
		if (n > 2) {
			r.push({
				op: "move",
				data: [i[0][0] + eeM(e, t), i[0][1] + eeM(e, t)]
			});
			for (let a = 1; a < n; a++) r.push({
				op: "lineTo",
				data: [i[a][0] + eeM(e, t), i[a][1] + eeM(e, t)]
			});
		}
	}
	return {
		type: "fillPath",
		ops: r
	};
}
function eeL(e, t) {
	return (function(e, t) {
		let r = e.fillStyle || "hachure";
		if (!eeh[r]) switch (r) {
			case "zigzag":
				eeh[r] || (eeh[r] = new eea(t));
				break;
			case "cross-hatch":
				eeh[r] || (eeh[r] = new ees(t));
				break;
			case "dots":
				eeh[r] || (eeh[r] = new eeo(t));
				break;
			case "dashed":
				eeh[r] || (eeh[r] = new eel(t));
				break;
			case "zigzag-line":
				eeh[r] || (eeh[r] = new eec(t));
				break;
			default: eeh[r = "hachure"] || (eeh[r] = new eei(t));
		}
		return eeh[r];
	})(t, eex).fillPolygons(e, t);
}
function eeR(e) {
	let t = Object.assign({}, e);
	return t.randomizer = void 0, e.seed && (t.seed = e.seed + 1), t;
}
function eeN(e) {
	return e.randomizer || (e.randomizer = new eeu(e.seed || 0)), e.randomizer.next();
}
function eeI(e, t, r, i = 1) {
	return r.roughness * i * (eeN(r) * (t - e) + e);
}
function eeM(e, t, r = 1) {
	return eeI(-e, e, t, r);
}
function eeD(e, t, r, i, n, a = !1) {
	let s = a ? n.disableMultiStrokeFill : n.disableMultiStroke, o = eeO(e, t, r, i, n, !0, !1);
	if (s) return o;
	let l = eeO(e, t, r, i, n, !0, !0);
	return o.concat(l);
}
function eeO(e, t, r, i, n, a, s) {
	let o = Math.pow(e - r, 2) + Math.pow(t - i, 2), l = Math.sqrt(o), u = 1;
	u = l < 200 ? 1 : l > 500 ? .4 : -.0016668 * l + 1.233334;
	let d = n.maxRandomnessOffset || 0;
	d * d * 100 > o && (d = l / 10);
	let p = d / 2, f = .2 + .2 * eeN(n), g = n.bowing * n.maxRandomnessOffset * (i - t) / 200, m = n.bowing * n.maxRandomnessOffset * (e - r) / 200;
	g = eeM(g, n, u), m = eeM(m, n, u);
	let y = [], v = h(() => eeM(p, n, u), "M"), x = h(() => eeM(d, n, u), "k"), b = n.preserveVertices;
	return a && (s ? y.push({
		op: "move",
		data: [e + (b ? 0 : v()), t + (b ? 0 : v())]
	}) : y.push({
		op: "move",
		data: [e + (b ? 0 : eeM(d, n, u)), t + (b ? 0 : eeM(d, n, u))]
	})), s ? y.push({
		op: "bcurveTo",
		data: [
			g + e + (r - e) * f + v(),
			m + t + (i - t) * f + v(),
			g + e + 2 * (r - e) * f + v(),
			m + t + 2 * (i - t) * f + v(),
			r + (b ? 0 : v()),
			i + (b ? 0 : v())
		]
	}) : y.push({
		op: "bcurveTo",
		data: [
			g + e + (r - e) * f + x(),
			m + t + (i - t) * f + x(),
			g + e + 2 * (r - e) * f + x(),
			m + t + 2 * (i - t) * f + x(),
			r + (b ? 0 : x()),
			i + (b ? 0 : x())
		]
	}), y;
}
function ee$(e, t, r) {
	if (!e.length) return [];
	let i = [];
	i.push([e[0][0] + eeM(t, r), e[0][1] + eeM(t, r)]), i.push([e[0][0] + eeM(t, r), e[0][1] + eeM(t, r)]);
	for (let n = 1; n < e.length; n++) i.push([e[n][0] + eeM(t, r), e[n][1] + eeM(t, r)]), n === e.length - 1 && i.push([e[n][0] + eeM(t, r), e[n][1] + eeM(t, r)]);
	return eeP(i, null, r);
}
function eeP(e, t, r) {
	let i = e.length, n = [];
	if (i > 3) {
		let a = [], s = 1 - r.curveTightness;
		n.push({
			op: "move",
			data: [e[1][0], e[1][1]]
		});
		for (let t = 1; t + 2 < i; t++) {
			let r = e[t];
			a[0] = [r[0], r[1]], a[1] = [r[0] + (s * e[t + 1][0] - s * e[t - 1][0]) / 6, r[1] + (s * e[t + 1][1] - s * e[t - 1][1]) / 6], a[2] = [e[t + 1][0] + (s * e[t][0] - s * e[t + 2][0]) / 6, e[t + 1][1] + (s * e[t][1] - s * e[t + 2][1]) / 6], a[3] = [e[t + 1][0], e[t + 1][1]], n.push({
				op: "bcurveTo",
				data: [
					a[1][0],
					a[1][1],
					a[2][0],
					a[2][1],
					a[3][0],
					a[3][1]
				]
			});
		}
		if (t && 2 === t.length) {
			let e = r.maxRandomnessOffset;
			n.push({
				op: "lineTo",
				data: [t[0] + eeM(e, r), t[1] + eeM(e, r)]
			});
		}
	} else 3 === i ? (n.push({
		op: "move",
		data: [e[1][0], e[1][1]]
	}), n.push({
		op: "bcurveTo",
		data: [
			e[1][0],
			e[1][1],
			e[2][0],
			e[2][1],
			e[2][0],
			e[2][1]
		]
	})) : 2 === i && n.push(...eeO(e[0][0], e[0][1], e[1][0], e[1][1], r, !0, !0));
	return n;
}
function eeB(e, t, r, i, n, a, s, o) {
	let l = [], h = [];
	if (0 === o.roughness) {
		e /= 4, h.push([t + i * Math.cos(-e), r + n * Math.sin(-e)]);
		for (let a = 0; a <= 2 * Math.PI; a += e) {
			let e = [t + i * Math.cos(a), r + n * Math.sin(a)];
			l.push(e), h.push(e);
		}
		h.push([t + +i, r + 0 * n]), h.push([t + i * Math.cos(e), r + n * Math.sin(e)]);
	} else {
		let u = eeM(.5, o) - Math.PI / 2;
		h.push([eeM(a, o) + t + .9 * i * Math.cos(u - e), eeM(a, o) + r + .9 * n * Math.sin(u - e)]);
		let d = 2 * Math.PI + u - .01;
		for (let s = u; s < d; s += e) {
			let e = [eeM(a, o) + t + i * Math.cos(s), eeM(a, o) + r + n * Math.sin(s)];
			l.push(e), h.push(e);
		}
		h.push([eeM(a, o) + t + i * Math.cos(u + 2 * Math.PI + .5 * s), eeM(a, o) + r + n * Math.sin(u + 2 * Math.PI + .5 * s)]), h.push([eeM(a, o) + t + .98 * i * Math.cos(u + s), eeM(a, o) + r + .98 * n * Math.sin(u + s)]), h.push([eeM(a, o) + t + .9 * i * Math.cos(u + .5 * s), eeM(a, o) + r + .9 * n * Math.sin(u + .5 * s)]);
	}
	return [h, l];
}
function eeF(e, t, r, i, n, a, s, o, l) {
	let h = a + eeM(.1, l), u = [];
	u.push([eeM(o, l) + t + .9 * i * Math.cos(h - e), eeM(o, l) + r + .9 * n * Math.sin(h - e)]);
	for (let a = h; a <= s; a += e) u.push([eeM(o, l) + t + i * Math.cos(a), eeM(o, l) + r + n * Math.sin(a)]);
	return u.push([t + i * Math.cos(s), r + n * Math.sin(s)]), u.push([t + i * Math.cos(s), r + n * Math.sin(s)]), eeP(u, null, l);
}
function eez(e, t, r, i, n, a, s, o) {
	let l = [], h = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + .3], u = [0, 0], d = o.disableMultiStroke ? 1 : 2, p = o.preserveVertices;
	for (let f = 0; f < d; f++) 0 === f ? l.push({
		op: "move",
		data: [s[0], s[1]]
	}) : l.push({
		op: "move",
		data: [s[0] + (p ? 0 : eeM(h[0], o)), s[1] + (p ? 0 : eeM(h[0], o))]
	}), u = p ? [n, a] : [n + eeM(h[f], o), a + eeM(h[f], o)], l.push({
		op: "bcurveTo",
		data: [
			e + eeM(h[f], o),
			t + eeM(h[f], o),
			r + eeM(h[f], o),
			i + eeM(h[f], o),
			u[0],
			u[1]
		]
	});
	return l;
}
function eeU(e) {
	return [...e];
}
function eeG(e, t = 0) {
	let r = e.length;
	if (r < 3) throw Error("A curve must have at least three points.");
	let i = [];
	if (3 === r) i.push(eeU(e[0]), eeU(e[1]), eeU(e[2]), eeU(e[2]));
	else {
		let r = [];
		r.push(e[0], e[0]);
		for (let t = 1; t < e.length; t++) r.push(e[t]), t === e.length - 1 && r.push(e[t]);
		let n = [], a = 1 - t;
		i.push(eeU(r[0]));
		for (let e = 1; e + 2 < r.length; e++) {
			let t = r[e];
			n[0] = [t[0], t[1]], n[1] = [t[0] + (a * r[e + 1][0] - a * r[e - 1][0]) / 6, t[1] + (a * r[e + 1][1] - a * r[e - 1][1]) / 6], n[2] = [r[e + 1][0] + (a * r[e][0] - a * r[e + 2][0]) / 6, r[e + 1][1] + (a * r[e][1] - a * r[e + 2][1]) / 6], n[3] = [r[e + 1][0], r[e + 1][1]], i.push(n[1], n[2], n[3]);
		}
	}
	return i;
}
function eeq(e, t) {
	return Math.pow(e[0] - t[0], 2) + Math.pow(e[1] - t[1], 2);
}
function eej(e, t, r) {
	let i = eeq(t, r);
	if (0 === i) return eeq(e, t);
	let n = ((e[0] - t[0]) * (r[0] - t[0]) + (e[1] - t[1]) * (r[1] - t[1])) / i;
	return eeq(e, eeW(t, r, n = Math.max(0, Math.min(1, n))));
}
function eeW(e, t, r) {
	return [e[0] + (t[0] - e[0]) * r, e[1] + (t[1] - e[1]) * r];
}
function eeY(e, t, r, i) {
	let n, a, s, o, l, h, u, d, p = i || [];
	if (n = e[t + 0], a = e[t + 1], s = e[t + 2], o = e[t + 3], l = 3 * a[0] - 2 * n[0] - o[0], l *= l, h = 3 * a[1] - 2 * n[1] - o[1], h *= h, u = 3 * s[0] - 2 * o[0] - n[0], u *= u, d = 3 * s[1] - 2 * o[1] - n[1], d *= d, l < u && (l = u), h < d && (h = d), l + h < r) {
		let r = e[t + 0];
		p.length ? Math.sqrt(eeq(p[p.length - 1], r)) > 1 && p.push(r) : p.push(r), p.push(e[t + 3]);
	} else {
		let i = e[t + 0], n = e[t + 1], a = e[t + 2], s = e[t + 3], o = eeW(i, n, .5), l = eeW(n, a, .5), h = eeW(a, s, .5), u = eeW(o, l, .5), d = eeW(l, h, .5), f = eeW(u, d, .5);
		eeY([
			i,
			o,
			u,
			f
		], 0, r, p), eeY([
			f,
			d,
			h,
			s
		], 0, r, p);
	}
	return p;
}
function eeV(e, t) {
	return eeH(e, 0, e.length, t);
}
function eeH(e, t, r, i, n) {
	let a = n || [], s = e[t], o = e[r - 1], l = 0, h = 1;
	for (let i = t + 1; i < r - 1; ++i) {
		let t = eej(e[i], s, o);
		t > l && (l = t, h = i);
	}
	return Math.sqrt(l) > i ? (eeH(e, t, h + 1, i, a), eeH(e, h, r, i, a)) : (a.length || a.push(s), a.push(o)), a;
}
function eeX(e, t = .15, r) {
	let i = [], n = (e.length - 1) / 3;
	for (let r = 0; r < n; r++) eeY(e, 3 * r, t, i);
	return r && r > 0 ? eeH(i, 0, i.length, r) : i;
}
h(eeb, "v"), h(eew, "S"), h(eek, "O"), h(eeT, "L"), h(ee_, "T"), h(eeE, "D"), h(eeC, "A"), h(eeS, "_"), h(eeA, "I"), h(eeL, "C"), h(eeR, "z"), h(eeN, "W"), h(eeI, "E"), h(eeM, "G"), h(eeD, "$"), h(eeO, "R"), h(ee$, "j"), h(eeP, "q"), h(eeB, "F"), h(eeF, "V"), h(eez, "Z"), h(eeU, "Q"), h(eeG, "H"), h(eeq, "N"), h(eej, "B"), h(eeW, "J"), h(eeY, "K"), h(eeV, "U"), h(eeH, "X"), h(eeX, "Y");
var eeK = "none", eeZ = class {
	static {
		h(this, "et");
	}
	constructor(e) {
		this.defaultOptions = {
			maxRandomnessOffset: 2,
			roughness: 1,
			bowing: 1,
			stroke: "#000",
			strokeWidth: 1,
			curveTightness: 0,
			curveFitting: .95,
			curveStepCount: 9,
			fillStyle: "hachure",
			fillWeight: -1,
			hachureAngle: -41,
			hachureGap: -1,
			dashOffset: -1,
			dashGap: -1,
			zigzagOffset: -1,
			seed: 0,
			disableMultiStroke: !1,
			disableMultiStrokeFill: !1,
			preserveVertices: !1,
			fillShapeRoughnessGain: .8
		}, this.config = e || {}, this.config.options && (this.defaultOptions = this._o(this.config.options));
	}
	static newSeed() {
		return Math.floor(2147483648 * Math.random());
	}
	_o(e) {
		return e ? Object.assign({}, this.defaultOptions, e) : this.defaultOptions;
	}
	_d(e, t, r) {
		return {
			shape: e,
			sets: t || [],
			options: r || this.defaultOptions
		};
	}
	line(e, t, r, i, n) {
		let a = this._o(n);
		return this._d("line", [eeb(e, t, r, i, a)], a);
	}
	rectangle(e, t, r, i, n) {
		let a = this._o(n), s = [], o = eek(e, t, r, i, a);
		if (a.fill) {
			let n = [
				[e, t],
				[e + r, t],
				[e + r, t + i],
				[e, t + i]
			];
			"solid" === a.fillStyle ? s.push(eeA([n], a)) : s.push(eeL([n], a));
		}
		return a.stroke !== eeK && s.push(o), this._d("rectangle", s, a);
	}
	ellipse(e, t, r, i, n) {
		let a = this._o(n), s = [], o = ee_(r, i, a), l = eeE(e, t, a, o);
		if (a.fill) if ("solid" === a.fillStyle) {
			let r = eeE(e, t, a, o).opset;
			r.type = "fillPath", s.push(r);
		} else s.push(eeL([l.estimatedPoints], a));
		return a.stroke !== eeK && s.push(l.opset), this._d("ellipse", s, a);
	}
	circle(e, t, r, i) {
		let n = this.ellipse(e, t, r, r, i);
		return n.shape = "circle", n;
	}
	linearPath(e, t) {
		let r = this._o(t);
		return this._d("linearPath", [eew(e, !1, r)], r);
	}
	arc(e, t, r, i, n, a, s = !1, o) {
		let l = this._o(o), h = [], u = eeC(e, t, r, i, n, a, s, !0, l);
		if (s && l.fill) if ("solid" === l.fillStyle) {
			let s = Object.assign({}, l);
			s.disableMultiStroke = !0;
			let o = eeC(e, t, r, i, n, a, !0, !1, s);
			o.type = "fillPath", h.push(o);
		} else h.push(function(e, t, r, i, n, a, s) {
			let o = Math.abs(r / 2), l = Math.abs(i / 2);
			o += eeM(.01 * o, s), l += eeM(.01 * l, s);
			let h = n, u = a;
			for (; h < 0;) h += 2 * Math.PI, u += 2 * Math.PI;
			u - h > 2 * Math.PI && (h = 0, u = 2 * Math.PI);
			let d = (u - h) / s.curveStepCount, p = [];
			for (let r = h; r <= u; r += d) p.push([e + o * Math.cos(r), t + l * Math.sin(r)]);
			return p.push([e + o * Math.cos(u), t + l * Math.sin(u)]), p.push([e, t]), eeL([p], s);
		}(e, t, r, i, n, a, l));
		return l.stroke !== eeK && h.push(u), this._d("arc", h, l);
	}
	curve(e, t) {
		let r = this._o(t), i = [], n = eeT(e, r);
		if (r.fill && r.fill !== eeK) if ("solid" === r.fillStyle) {
			let t = eeT(e, Object.assign(Object.assign({}, r), {
				disableMultiStroke: !0,
				roughness: r.roughness ? r.roughness + r.fillShapeRoughnessGain : 0
			}));
			i.push({
				type: "fillPath",
				ops: this._mergedShape(t.ops)
			});
		} else {
			let t = [];
			if (e.length) for (let i of "number" == typeof e[0][0] ? [e] : e) i.length < 3 ? t.push(...i) : 3 === i.length ? t.push(...eeX(eeG([
				i[0],
				i[0],
				i[1],
				i[2]
			]), 10, (1 + r.roughness) / 2)) : t.push(...eeX(eeG(i), 10, (1 + r.roughness) / 2));
			t.length && i.push(eeL([t], r));
		}
		return r.stroke !== eeK && i.push(n), this._d("curve", i, r);
	}
	polygon(e, t) {
		let r = this._o(t), i = [], n = eew(e, !0, r);
		return r.fill && ("solid" === r.fillStyle ? i.push(eeA([e], r)) : i.push(eeL([e], r))), r.stroke !== eeK && i.push(n), this._d("polygon", i, r);
	}
	path(e, t) {
		let r = this._o(t), i = [];
		if (!e) return this._d("path", i, r);
		e = (e || "").replace(/\n/g, " ").replace(/(-\s)/g, "-").replace("/(ss)/g", " ");
		let n = r.fill && "transparent" !== r.fill && r.fill !== eeK, a = r.stroke !== eeK, s = !!(r.simplification && r.simplification < 1), o = function(e, t, r) {
			let i = eem(eeg(eef(e))), n = [], a = [], s = [0, 0], o = [], l = h(() => {
				o.length >= 4 && a.push(...eeX(o, 1)), o = [];
			}, "i"), u = h(() => {
				l(), a.length && (n.push(a), a = []);
			}, "c");
			for (let { key: e, data: t } of i) switch (e) {
				case "M":
					u(), s = [t[0], t[1]], a.push(s);
					break;
				case "L":
					l(), a.push([t[0], t[1]]);
					break;
				case "C":
					if (!o.length) {
						let e = a.length ? a[a.length - 1] : s;
						o.push([e[0], e[1]]);
					}
					o.push([t[0], t[1]]), o.push([t[2], t[3]]), o.push([t[4], t[5]]);
					break;
				case "Z": l(), a.push([s[0], s[1]]);
			}
			if (u(), !r) return n;
			let d = [];
			for (let e of n) {
				let t = eeV(e, r);
				t.length && d.push(t);
			}
			return d;
		}(e, 0, s ? 4 - 4 * (r.simplification || 1) : (1 + r.roughness) / 2), l = eeS(e, r);
		if (n) if ("solid" === r.fillStyle) if (1 === o.length) {
			let t = eeS(e, Object.assign(Object.assign({}, r), {
				disableMultiStroke: !0,
				roughness: r.roughness ? r.roughness + r.fillShapeRoughnessGain : 0
			}));
			i.push({
				type: "fillPath",
				ops: this._mergedShape(t.ops)
			});
		} else i.push(eeA(o, r));
		else i.push(eeL(o, r));
		return a && (s ? o.forEach((e) => {
			i.push(eew(e, !1, r));
		}) : i.push(l)), this._d("path", i, r);
	}
	opsToPath(e, t) {
		let r = "";
		for (let i of e.ops) {
			let e = "number" == typeof t && t >= 0 ? i.data.map((e) => +e.toFixed(t)) : i.data;
			switch (i.op) {
				case "move":
					r += `M${e[0]} ${e[1]} `;
					break;
				case "bcurveTo":
					r += `C${e[0]} ${e[1]}, ${e[2]} ${e[3]}, ${e[4]} ${e[5]} `;
					break;
				case "lineTo": r += `L${e[0]} ${e[1]} `;
			}
		}
		return r.trim();
	}
	toPaths(e) {
		let t = e.sets || [], r = e.options || this.defaultOptions, i = [];
		for (let e of t) {
			let t = null;
			switch (e.type) {
				case "path":
					t = {
						d: this.opsToPath(e),
						stroke: r.stroke,
						strokeWidth: r.strokeWidth,
						fill: eeK
					};
					break;
				case "fillPath":
					t = {
						d: this.opsToPath(e),
						stroke: eeK,
						strokeWidth: 0,
						fill: r.fill || eeK
					};
					break;
				case "fillSketch": t = this.fillSketch(e, r);
			}
			t && i.push(t);
		}
		return i;
	}
	fillSketch(e, t) {
		let r = t.fillWeight;
		return r < 0 && (r = t.strokeWidth / 2), {
			d: this.opsToPath(e),
			stroke: t.fill || eeK,
			strokeWidth: r,
			fill: eeK
		};
	}
	_mergedShape(e) {
		return e.filter((e, t) => 0 === t || "move" !== e.op);
	}
}, eeQ = class {
	static {
		h(this, "st");
	}
	constructor(e, t) {
		this.canvas = e, this.ctx = this.canvas.getContext("2d"), this.gen = new eeZ(t);
	}
	draw(e) {
		let t = e.sets || [], r = e.options || this.getDefaultOptions(), i = this.ctx, n = e.options.fixedDecimalPlaceDigits;
		for (let a of t) switch (a.type) {
			case "path":
				i.save(), i.strokeStyle = "none" === r.stroke ? "transparent" : r.stroke, i.lineWidth = r.strokeWidth, r.strokeLineDash && i.setLineDash(r.strokeLineDash), r.strokeLineDashOffset && (i.lineDashOffset = r.strokeLineDashOffset), this._drawToContext(i, a, n), i.restore();
				break;
			case "fillPath": {
				i.save(), i.fillStyle = r.fill || "";
				let t = "curve" === e.shape || "polygon" === e.shape || "path" === e.shape ? "evenodd" : "nonzero";
				this._drawToContext(i, a, n, t), i.restore();
				break;
			}
			case "fillSketch": this.fillSketch(i, a, r);
		}
	}
	fillSketch(e, t, r) {
		let i = r.fillWeight;
		i < 0 && (i = r.strokeWidth / 2), e.save(), r.fillLineDash && e.setLineDash(r.fillLineDash), r.fillLineDashOffset && (e.lineDashOffset = r.fillLineDashOffset), e.strokeStyle = r.fill || "", e.lineWidth = i, this._drawToContext(e, t, r.fixedDecimalPlaceDigits), e.restore();
	}
	_drawToContext(e, t, r, i = "nonzero") {
		for (let i of (e.beginPath(), t.ops)) {
			let t = "number" == typeof r && r >= 0 ? i.data.map((e) => +e.toFixed(r)) : i.data;
			switch (i.op) {
				case "move":
					e.moveTo(t[0], t[1]);
					break;
				case "bcurveTo":
					e.bezierCurveTo(t[0], t[1], t[2], t[3], t[4], t[5]);
					break;
				case "lineTo": e.lineTo(t[0], t[1]);
			}
		}
		"fillPath" === t.type ? e.fill(i) : e.stroke();
	}
	get generator() {
		return this.gen;
	}
	getDefaultOptions() {
		return this.gen.defaultOptions;
	}
	line(e, t, r, i, n) {
		let a = this.gen.line(e, t, r, i, n);
		return this.draw(a), a;
	}
	rectangle(e, t, r, i, n) {
		let a = this.gen.rectangle(e, t, r, i, n);
		return this.draw(a), a;
	}
	ellipse(e, t, r, i, n) {
		let a = this.gen.ellipse(e, t, r, i, n);
		return this.draw(a), a;
	}
	circle(e, t, r, i) {
		let n = this.gen.circle(e, t, r, i);
		return this.draw(n), n;
	}
	linearPath(e, t) {
		let r = this.gen.linearPath(e, t);
		return this.draw(r), r;
	}
	polygon(e, t) {
		let r = this.gen.polygon(e, t);
		return this.draw(r), r;
	}
	arc(e, t, r, i, n, a, s = !1, o) {
		let l = this.gen.arc(e, t, r, i, n, a, s, o);
		return this.draw(l), l;
	}
	curve(e, t) {
		let r = this.gen.curve(e, t);
		return this.draw(r), r;
	}
	path(e, t) {
		let r = this.gen.path(e, t);
		return this.draw(r), r;
	}
}, eeJ = "http://www.w3.org/2000/svg", ee0 = class {
	static {
		h(this, "ot");
	}
	constructor(e, t) {
		this.svg = e, this.gen = new eeZ(t);
	}
	draw(e) {
		let t = e.sets || [], r = e.options || this.getDefaultOptions(), i = this.svg.ownerDocument || window.document, n = i.createElementNS(eeJ, "g"), a = e.options.fixedDecimalPlaceDigits;
		for (let s of t) {
			let t = null;
			switch (s.type) {
				case "path":
					(t = i.createElementNS(eeJ, "path")).setAttribute("d", this.opsToPath(s, a)), t.setAttribute("stroke", r.stroke), t.setAttribute("stroke-width", r.strokeWidth + ""), t.setAttribute("fill", "none"), r.strokeLineDash && t.setAttribute("stroke-dasharray", r.strokeLineDash.join(" ").trim()), r.strokeLineDashOffset && t.setAttribute("stroke-dashoffset", `${r.strokeLineDashOffset}`);
					break;
				case "fillPath":
					(t = i.createElementNS(eeJ, "path")).setAttribute("d", this.opsToPath(s, a)), t.setAttribute("stroke", "none"), t.setAttribute("stroke-width", "0"), t.setAttribute("fill", r.fill || ""), "curve" !== e.shape && "polygon" !== e.shape || t.setAttribute("fill-rule", "evenodd");
					break;
				case "fillSketch": t = this.fillSketch(i, s, r);
			}
			t && n.appendChild(t);
		}
		return n;
	}
	fillSketch(e, t, r) {
		let i = r.fillWeight;
		i < 0 && (i = r.strokeWidth / 2);
		let n = e.createElementNS(eeJ, "path");
		return n.setAttribute("d", this.opsToPath(t, r.fixedDecimalPlaceDigits)), n.setAttribute("stroke", r.fill || ""), n.setAttribute("stroke-width", i + ""), n.setAttribute("fill", "none"), r.fillLineDash && n.setAttribute("stroke-dasharray", r.fillLineDash.join(" ").trim()), r.fillLineDashOffset && n.setAttribute("stroke-dashoffset", `${r.fillLineDashOffset}`), n;
	}
	get generator() {
		return this.gen;
	}
	getDefaultOptions() {
		return this.gen.defaultOptions;
	}
	opsToPath(e, t) {
		return this.gen.opsToPath(e, t);
	}
	line(e, t, r, i, n) {
		let a = this.gen.line(e, t, r, i, n);
		return this.draw(a);
	}
	rectangle(e, t, r, i, n) {
		let a = this.gen.rectangle(e, t, r, i, n);
		return this.draw(a);
	}
	ellipse(e, t, r, i, n) {
		let a = this.gen.ellipse(e, t, r, i, n);
		return this.draw(a);
	}
	circle(e, t, r, i) {
		let n = this.gen.circle(e, t, r, i);
		return this.draw(n);
	}
	linearPath(e, t) {
		let r = this.gen.linearPath(e, t);
		return this.draw(r);
	}
	polygon(e, t) {
		let r = this.gen.polygon(e, t);
		return this.draw(r);
	}
	arc(e, t, r, i, n, a, s = !1, o) {
		let l = this.gen.arc(e, t, r, i, n, a, s, o);
		return this.draw(l);
	}
	curve(e, t) {
		let r = this.gen.curve(e, t);
		return this.draw(r);
	}
	path(e, t) {
		let r = this.gen.path(e, t);
		return this.draw(r);
	}
}, ee1 = {
	canvas: h((e, t) => new eeQ(e, t), "canvas"),
	svg: h((e, t) => new ee0(e, t), "svg"),
	generator: h((e) => new eeZ(e), "generator"),
	newSeed: h(() => eeZ.newSeed(), "newSeed")
}, ee2 = h((e, t) => {
	var r, i, n = e.x, a = e.y, s = t.x - n, o = t.y - a, l = e.width / 2, h = e.height / 2;
	return Math.abs(o) * l > Math.abs(s) * h ? (o < 0 && (h = -h), r = 0 === o ? 0 : h * s / o, i = h) : (s < 0 && (l = -l), r = l, i = 0 === s ? 0 : l * o / s), {
		x: n + r,
		y: a + i
	};
}, "intersectRect");
function ee4(e, t) {
	t && e.attr("style", t);
}
async function ee5(e) {
	let t = _t(document.createElementNS("http://www.w3.org/2000/svg", "foreignObject")), r = t.append("xhtml:div"), i = IA(), n = e.label;
	e.label && MZ(e.label) && (n = await M0(e.label.replace(M1.lineBreakRegex, `
`), i));
	let a = "<span class=\"" + (e.isNode ? "nodeLabel" : "edgeLabel") + "\" " + (e.labelStyle ? "style=\"" + e.labelStyle + "\"" : "") + ">" + n + "</span>";
	return r.html(MO(a, i)), ee4(r, e.labelStyle), r.style("display", "inline-block"), r.style("padding-right", "1px"), r.style("white-space", "nowrap"), r.attr("xmlns", "http://www.w3.org/1999/xhtml"), t.node();
}
h(ee4, "applyStyle"), h(ee5, "addHtmlLabel");
var ee3 = h(async (e, t, r, i) => {
	let n = e || "";
	if ("object" == typeof n && (n = n[0]), MG(IA().flowchart.htmlLabels)) return n = n.replace(/\\n|\n/g, "<br />"), wQ.info("vertexText" + n), await ee5({
		isNode: i,
		label: V6(n).replace(/fa[blrs]?:fa-[\w-]+/g, (e) => `<i class='${e.replace(":", " ")}'></i>`),
		labelStyle: t && t.replace("fill:", "color:")
	});
	{
		let e = document.createElementNS("http://www.w3.org/2000/svg", "text");
		e.setAttribute("style", t.replace("color:", "fill:"));
		for (let t of "string" == typeof n ? n.split(/\\n|\n|<br\s*\/?>/gi) : Array.isArray(n) ? n : []) {
			let i = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
			i.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), i.setAttribute("dy", "1em"), i.setAttribute("x", "0"), r ? i.setAttribute("class", "title-row") : i.setAttribute("class", "row"), i.textContent = t.trim(), e.appendChild(i);
		}
		return e;
	}
}, "createLabel"), ee6 = h((e, t, r, i, n) => [
	"M",
	e + n,
	t,
	"H",
	e + r - n,
	"A",
	n,
	n,
	"0 0 1",
	e + r,
	t + n,
	"V",
	t + i - n,
	"A",
	n,
	n,
	"0 0 1",
	e + r - n,
	t + i,
	"H",
	e + n,
	"A",
	n,
	n,
	"0 0 1",
	e,
	t + i - n,
	"V",
	t + n,
	"A",
	n,
	n,
	"0 0 1",
	e + n,
	t,
	"Z"
].join(" "), "createRoundedRectPathD"), ee7 = h(async (e, t) => {
	let r;
	wQ.info("Creating subgraph rect for ", t.id, t);
	let i = IA(), { themeVariables: n, handDrawnSeed: a } = i, { clusterBkg: s, clusterBorder: o } = n, { labelStyles: l, nodeStyles: h, borderStyles: u, backgroundStyles: d } = JJ(t), p = e.insert("g").attr("class", "cluster " + t.cssClasses).attr("id", t.id).attr("data-look", t.look), f = MG(i.flowchart.htmlLabels), g = p.insert("g").attr("class", "cluster-label "), m = await XQ(g, t.label, {
		style: t.labelStyle,
		useHtmlLabels: f,
		isNode: !0
	}), y = m.getBBox();
	if (MG(i.flowchart.htmlLabels)) {
		let e = m.children[0], t = _t(m);
		y = e.getBoundingClientRect(), t.attr("width", y.width), t.attr("height", y.height);
	}
	let v = t.width <= y.width + t.padding ? y.width + t.padding : t.width;
	t.width <= y.width + t.padding ? t.diff = (v - t.width) / 2 - t.padding : t.diff = -t.padding;
	let x = t.height, b = t.x - v / 2, w = t.y - x / 2;
	if (wQ.trace("Data ", t, JSON.stringify(t)), "handDrawn" === t.look) {
		let e = ee1.svg(p), i = J0(t, {
			roughness: .7,
			fill: s,
			stroke: o,
			fillWeight: 3,
			seed: a
		}), n = e.path(ee6(b, w, v, x, 0), i);
		(r = p.insert(() => (wQ.debug("Rough node insert CXC", n), n), ":first-child")).select("path:nth-child(2)").attr("style", u.join(";")), r.select("path").attr("style", d.join(";").replace("fill", "stroke"));
	} else (r = p.insert("rect", ":first-child")).attr("style", h).attr("rx", t.rx).attr("ry", t.ry).attr("x", b).attr("y", w).attr("width", v).attr("height", x);
	let { subGraphTitleTopMargin: k } = KY(i);
	if (g.attr("transform", `translate(${t.x - y.width / 2}, ${t.y - t.height / 2 + k})`), l) {
		let e = g.select("span");
		e && e.attr("style", l);
	}
	let T = r.node().getBBox();
	return t.offsetX = 0, t.width = T.width, t.height = T.height, t.offsetY = y.height - t.padding / 2, t.intersect = function(e) {
		return ee2(t, e);
	}, {
		cluster: p,
		labelBBox: y
	};
}, "rect"), ee8 = h((e, t) => {
	let r = e.insert("g").attr("class", "note-cluster").attr("id", t.id), i = r.insert("rect", ":first-child"), n = 0 * t.padding, a = n / 2;
	i.attr("rx", t.rx).attr("ry", t.ry).attr("x", t.x - t.width / 2 - a).attr("y", t.y - t.height / 2 - a).attr("width", t.width + n).attr("height", t.height + n).attr("fill", "none");
	let s = i.node().getBBox();
	return t.width = s.width, t.height = s.height, t.intersect = function(e) {
		return ee2(t, e);
	}, {
		cluster: r,
		labelBBox: {
			width: 0,
			height: 0
		}
	};
}, "noteGroup"), ee9 = h(async (e, t) => {
	let r = IA(), { themeVariables: i, handDrawnSeed: n } = r, { altBackground: a, compositeBackground: s, compositeTitleBackground: o, nodeBorder: l } = i, h = e.insert("g").attr("class", t.cssClasses).attr("id", t.id).attr("data-id", t.id).attr("data-look", t.look), u = h.insert("g", ":first-child"), d = h.insert("g").attr("class", "cluster-label"), p = h.append("rect"), f = d.node().appendChild(await ee3(t.label, t.labelStyle, void 0, !0)), g = f.getBBox();
	if (MG(r.flowchart.htmlLabels)) {
		let e = f.children[0], t = _t(f);
		g = e.getBoundingClientRect(), t.attr("width", g.width), t.attr("height", g.height);
	}
	let m = 0 * t.padding, y = (t.width <= g.width + t.padding ? g.width + t.padding : t.width) + m;
	t.width <= g.width + t.padding ? t.diff = (y - t.width) / 2 - t.padding : t.diff = -t.padding;
	let v = t.height + m, x = t.height + m - g.height - 6, b = t.x - y / 2, w = t.y - v / 2;
	t.width = y;
	let k = t.y - t.height / 2 - m / 2 + g.height + 2, T;
	if ("handDrawn" === t.look) {
		let e = t.cssClasses.includes("statediagram-cluster-alt"), r = ee1.svg(h), i = t.rx || t.ry ? r.path(ee6(b, w, y, v, 10), {
			roughness: .7,
			fill: o,
			fillStyle: "solid",
			stroke: l,
			seed: n
		}) : r.rectangle(b, w, y, v, { seed: n });
		T = h.insert(() => i, ":first-child");
		let u = r.rectangle(b, k, y, x, {
			fill: e ? a : s,
			fillStyle: e ? "hachure" : "solid",
			stroke: l,
			seed: n
		});
		T = h.insert(() => i, ":first-child"), p = h.insert(() => u);
	} else (T = u.insert("rect", ":first-child")).attr("class", "outer").attr("x", b).attr("y", w).attr("width", y).attr("height", v).attr("data-look", t.look), p.attr("class", "inner").attr("x", b).attr("y", k).attr("width", y).attr("height", x);
	return d.attr("transform", `translate(${t.x - g.width / 2}, ${w + 1 - 3 * !MG(r.flowchart.htmlLabels)})`), t.height = T.node().getBBox().height, t.offsetX = 0, t.offsetY = g.height - t.padding / 2, t.labelBBox = g, t.intersect = function(e) {
		return ee2(t, e);
	}, {
		cluster: h,
		labelBBox: g
	};
}, "roundedWithTitle"), ete = h(async (e, t) => {
	let r;
	wQ.info("Creating subgraph rect for ", t.id, t);
	let i = IA(), { themeVariables: n, handDrawnSeed: a } = i, { clusterBkg: s, clusterBorder: o } = n, { labelStyles: l, nodeStyles: h, borderStyles: u, backgroundStyles: d } = JJ(t), p = e.insert("g").attr("class", "cluster " + t.cssClasses).attr("id", t.id).attr("data-look", t.look), f = MG(i.flowchart.htmlLabels), g = p.insert("g").attr("class", "cluster-label "), m = await XQ(g, t.label, {
		style: t.labelStyle,
		useHtmlLabels: f,
		isNode: !0,
		width: t.width
	}), y = m.getBBox();
	if (MG(i.flowchart.htmlLabels)) {
		let e = m.children[0], t = _t(m);
		y = e.getBoundingClientRect(), t.attr("width", y.width), t.attr("height", y.height);
	}
	let v = t.width <= y.width + t.padding ? y.width + t.padding : t.width;
	t.width <= y.width + t.padding ? t.diff = (v - t.width) / 2 - t.padding : t.diff = -t.padding;
	let x = t.height, b = t.x - v / 2, w = t.y - x / 2;
	if (wQ.trace("Data ", t, JSON.stringify(t)), "handDrawn" === t.look) {
		let e = ee1.svg(p), i = J0(t, {
			roughness: .7,
			fill: s,
			stroke: o,
			fillWeight: 4,
			seed: a
		}), n = e.path(ee6(b, w, v, x, t.rx), i);
		(r = p.insert(() => (wQ.debug("Rough node insert CXC", n), n), ":first-child")).select("path:nth-child(2)").attr("style", u.join(";")), r.select("path").attr("style", d.join(";").replace("fill", "stroke"));
	} else (r = p.insert("rect", ":first-child")).attr("style", h).attr("rx", t.rx).attr("ry", t.ry).attr("x", b).attr("y", w).attr("width", v).attr("height", x);
	let { subGraphTitleTopMargin: k } = KY(i);
	if (g.attr("transform", `translate(${t.x - y.width / 2}, ${t.y - t.height / 2 + k})`), l) {
		let e = g.select("span");
		e && e.attr("style", l);
	}
	let T = r.node().getBBox();
	return t.offsetX = 0, t.width = T.width, t.height = T.height, t.offsetY = y.height - t.padding / 2, t.intersect = function(e) {
		return ee2(t, e);
	}, {
		cluster: p,
		labelBBox: y
	};
}, "kanbanSection"), ett = {
	rect: ee7,
	squareRect: ee7,
	roundedWithTitle: ee9,
	noteGroup: ee8,
	divider: h((e, t) => {
		let r, { themeVariables: i, handDrawnSeed: n } = IA(), { nodeBorder: a } = i, s = e.insert("g").attr("class", t.cssClasses).attr("id", t.id).attr("data-look", t.look), o = s.insert("g", ":first-child"), l = 0 * t.padding, h = t.width + l;
		t.diff = -t.padding;
		let u = t.height + l, d = t.x - h / 2, p = t.y - u / 2;
		if (t.width = h, "handDrawn" === t.look) {
			let e = ee1.svg(s).rectangle(d, p, h, u, {
				fill: "lightgrey",
				roughness: .5,
				strokeLineDash: [5],
				stroke: a,
				seed: n
			});
			r = s.insert(() => e, ":first-child");
		} else (r = o.insert("rect", ":first-child")).attr("class", "divider").attr("x", d).attr("y", p).attr("width", h).attr("height", u).attr("data-look", t.look);
		return t.height = r.node().getBBox().height, t.offsetX = 0, t.offsetY = 0, t.intersect = function(e) {
			return ee2(t, e);
		}, {
			cluster: s,
			labelBBox: {}
		};
	}, "divider"),
	kanbanSection: ete
}, etr = /* @__PURE__ */ new Map(), eti = h(async (e, t) => {
	let r = await ett[t.shape || "rect"](e, t);
	return etr.set(t.id, r), r;
}, "insertCluster"), etn = h(() => {
	etr = /* @__PURE__ */ new Map();
}, "clear");
function eta(e, t, r, i) {
	var n = e.x, a = e.y, s = n - i.x, o = a - i.y, l = Math.sqrt(t * t * o * o + r * r * s * s), h = Math.abs(t * r * s / l);
	i.x < n && (h = -h);
	var u = Math.abs(t * r * o / l);
	return i.y < a && (u = -u), {
		x: n + h,
		y: a + u
	};
}
function ets(e, t, r) {
	return eta(e, t, t, r);
}
function eto(e, t, r, i) {
	{
		let n = t.y - e.y, a = e.x - t.x, s = t.x * e.y - e.x * t.y, o = n * r.x + a * r.y + s, l = n * i.x + a * i.y + s;
		if (0 !== o && 0 !== l && etl(o, l)) return;
		let h = i.y - r.y, u = r.x - i.x, d = i.x * r.y - r.x * i.y, p = h * e.x + u * e.y + d, f = h * t.x + u * t.y + d;
		if (1e-6 > Math.abs(p) && 1e-6 > Math.abs(f) && etl(p, f)) return;
		let g = n * u - h * a;
		if (0 === g) return;
		let m = Math.abs(g / 2), y = a * d - u * s;
		return {
			x: y < 0 ? (y - m) / g : (y + m) / g,
			y: (y = h * s - n * d) < 0 ? (y - m) / g : (y + m) / g
		};
	}
}
function etl(e, t) {
	return e * t > 0;
}
function etc(e, t, r) {
	let i = e.x, n = e.y, a = [], s = Infinity, o = Infinity;
	"function" == typeof t.forEach ? t.forEach(function(e) {
		s = Math.min(s, e.x), o = Math.min(o, e.y);
	}) : (s = Math.min(s, t.x), o = Math.min(o, t.y));
	let l = i - e.width / 2 - s, h = n - e.height / 2 - o;
	for (let i = 0; i < t.length; i++) {
		let n = t[i], s = t[i < t.length - 1 ? i + 1 : 0], o = eto(e, r, {
			x: l + n.x,
			y: h + n.y
		}, {
			x: l + s.x,
			y: h + s.y
		});
		o && a.push(o);
	}
	return a.length ? (a.length > 1 && a.sort(function(e, t) {
		let i = e.x - r.x, n = e.y - r.y, a = Math.sqrt(i * i + n * n), s = t.x - r.x, o = t.y - r.y, l = Math.sqrt(s * s + o * o);
		return a < l ? -1 : +(a !== l);
	}), a[0]) : e;
}
h(function(e, t) {
	return e.intersect(t);
}, "intersectNode"), h(eta, "intersectEllipse"), h(ets, "intersectCircle"), h(eto, "intersectLine"), h(etl, "sameSign"), h(etc, "intersectPolygon");
function eth(e, t) {
	let { labelStyles: r } = JJ(t);
	t.labelStyle = r;
	let i = J3(t), n = i;
	i || (n = "anchor");
	let a = e.insert("g").attr("class", n).attr("id", t.domId || t.id), { cssStyles: s } = t, o = ee1.svg(a), l = J0(t, {
		fill: "black",
		stroke: "none",
		fillStyle: "solid"
	});
	"handDrawn" !== t.look && (l.roughness = 0);
	let h = o.circle(0, 0, 2, l), u = a.insert(() => h, ":first-child");
	return u.attr("class", "anchor").attr("style", V8(s)), J5(t, u), t.intersect = function(e) {
		return wQ.info("Circle intersect", t, 1, e), ets(t, 1, e);
	}, a;
}
function etu(e, t, r, i, n, a, s) {
	let o = Math.atan2(i - t, r - e), l = Math.sqrt(((r - e) / 2 / n) ** 2 + ((i - t) / 2 / a) ** 2);
	if (l > 1) throw Error("The given radii are too small to create an arc between the points.");
	let h = Math.sqrt(1 - l ** 2), u = (e + r) / 2 + h * a * Math.sin(o) * (s ? -1 : 1), d = (t + i) / 2 - h * n * Math.cos(o) * (s ? -1 : 1), p = Math.atan2((t - d) / a, (e - u) / n), f = Math.atan2((i - d) / a, (r - u) / n) - p;
	s && f < 0 && (f += 2 * Math.PI), !s && f > 0 && (f -= 2 * Math.PI);
	let g = [];
	for (let e = 0; e < 20; e++) {
		let t = p + e / 19 * f, r = u + n * Math.cos(t), i = d + a * Math.sin(t);
		g.push({
			x: r,
			y: i
		});
	}
	return g;
}
async function etd(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a } = await J2(e, t, J3(t)), s = a.width + t.padding + 20, o = a.height + t.padding, l = o / 2, h = l / (2.5 + o / 50), { cssStyles: u } = t, d = [
		{
			x: s / 2,
			y: -o / 2
		},
		{
			x: -s / 2,
			y: -o / 2
		},
		...etu(-s / 2, -o / 2, -s / 2, o / 2, h, l, !1),
		{
			x: s / 2,
			y: o / 2
		},
		...etu(s / 2, o / 2, s / 2, -o / 2, h, l, !0)
	], p = ee1.svg(n), f = J0(t, {});
	"handDrawn" !== t.look && (f.roughness = 0, f.fillStyle = "solid");
	let g = J6(d), m = p.path(g, f), y = n.insert(() => m, ":first-child");
	return y.attr("class", "basic label-container"), u && "handDrawn" !== t.look && y.selectAll("path").attr("style", u), i && "handDrawn" !== t.look && y.selectAll("path").attr("style", i), y.attr("transform", `translate(${h / 2}, 0)`), J5(t, y), t.intersect = function(e) {
		return etc(t, d, e);
	}, n;
}
function etp(e, t, r, i) {
	return e.insert("polygon", ":first-child").attr("points", i.map(function(e) {
		return e.x + "," + e.y;
	}).join(" ")).attr("class", "label-container").attr("transform", "translate(" + -t / 2 + "," + r / 2 + ")");
}
async function etf(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a } = await J2(e, t, J3(t)), s = a.height + t.padding, o = a.width + t.padding + 12, l = -s, h = [
		{
			x: 12,
			y: l
		},
		{
			x: o,
			y: l
		},
		{
			x: o,
			y: 0
		},
		{
			x: 0,
			y: 0
		},
		{
			x: 0,
			y: l + 12
		},
		{
			x: 12,
			y: l
		}
	], u, { cssStyles: d } = t;
	if ("handDrawn" === t.look) {
		let e = ee1.svg(n), r = J0(t, {}), i = J6(h), a = e.path(i, r);
		u = n.insert(() => a, ":first-child").attr("transform", `translate(${-o / 2}, ${s / 2})`), d && u.attr("style", d);
	} else u = etp(n, o, s, h);
	return i && u.attr("style", i), J5(t, u), t.intersect = function(e) {
		return etc(t, h, e);
	}, n;
}
function etg(e, t) {
	let { nodeStyles: r } = JJ(t);
	t.label = "";
	let i = e.insert("g").attr("class", J3(t)).attr("id", t.domId ?? t.id), { cssStyles: n } = t, a = Math.max(28, t.width ?? 0), s = [
		{
			x: 0,
			y: a / 2
		},
		{
			x: a / 2,
			y: 0
		},
		{
			x: 0,
			y: -a / 2
		},
		{
			x: -a / 2,
			y: 0
		}
	], o = ee1.svg(i), l = J0(t, {});
	"handDrawn" !== t.look && (l.roughness = 0, l.fillStyle = "solid");
	let h = J6(s), u = o.path(h, l), d = i.insert(() => u, ":first-child");
	return n && "handDrawn" !== t.look && d.selectAll("path").attr("style", n), r && "handDrawn" !== t.look && d.selectAll("path").attr("style", r), t.width = 28, t.height = 28, t.intersect = function(e) {
		return etc(t, s, e);
	}, i;
}
async function etm(e, t, r) {
	let { labelStyles: i, nodeStyles: n } = JJ(t);
	t.labelStyle = i;
	let { shapeSvg: a, bbox: s, halfPadding: o } = await J2(e, t, J3(t)), l = r?.padding ?? o, h = s.width / 2 + l, u, { cssStyles: d } = t;
	if ("handDrawn" === t.look) {
		let e = ee1.svg(a), r = J0(t, {}), i = e.circle(0, 0, 2 * h, r);
		(u = a.insert(() => i, ":first-child")).attr("class", "basic label-container").attr("style", V8(d));
	} else u = a.insert("circle", ":first-child").attr("class", "basic label-container").attr("style", n).attr("r", h).attr("cx", 0).attr("cy", 0);
	return J5(t, u), t.calcIntersect = function(e, t) {
		return ets(e, e.width / 2, t);
	}, t.intersect = function(e) {
		return wQ.info("Circle intersect", t, h, e), ets(t, h, e);
	}, a;
}
function ety(e) {
	let t = Math.cos(Math.PI / 4), r = Math.sin(Math.PI / 4), i = 2 * e, n = {
		x: i / 2 * t,
		y: i / 2 * r
	}, a = {
		x: -(i / 2) * t,
		y: i / 2 * r
	}, s = {
		x: -(i / 2) * t,
		y: -(i / 2) * r
	}, o = {
		x: i / 2 * t,
		y: -(i / 2) * r
	};
	return `M ${a.x},${a.y} L ${o.x},${o.y}
                   M ${n.x},${n.y} L ${s.x},${s.y}`;
}
function etv(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r, t.label = "";
	let n = e.insert("g").attr("class", J3(t)).attr("id", t.domId ?? t.id), a = Math.max(30, t?.width ?? 0), { cssStyles: s } = t, o = ee1.svg(n), l = J0(t, {});
	"handDrawn" !== t.look && (l.roughness = 0, l.fillStyle = "solid");
	let h = o.circle(0, 0, 2 * a, l), u = ety(a), d = o.path(u, l), p = n.insert(() => h, ":first-child");
	return p.insert(() => d), s && "handDrawn" !== t.look && p.selectAll("path").attr("style", s), i && "handDrawn" !== t.look && p.selectAll("path").attr("style", i), J5(t, p), t.intersect = function(e) {
		return wQ.info("crossedCircle intersect", t, {
			radius: a,
			point: e
		}), ets(t, a, e);
	}, n;
}
function etx(e, t, r, i = 100, n = 0, a = 180) {
	let s = [], o = n * Math.PI / 180, l = (a * Math.PI / 180 - o) / (i - 1);
	for (let n = 0; n < i; n++) {
		let i = o + n * l, a = e + r * Math.cos(i), h = t + r * Math.sin(i);
		s.push({
			x: -a,
			y: -h
		});
	}
	return s;
}
async function etb(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a, label: s } = await J2(e, t, J3(t)), o = a.width + (t.padding ?? 0), l = a.height + (t.padding ?? 0), h = Math.max(5, .1 * l), { cssStyles: u } = t, d = [
		...etx(o / 2, -l / 2, h, 30, -90, 0),
		{
			x: -o / 2 - h,
			y: h
		},
		...etx(o / 2 + 2 * h, -h, h, 20, -180, -270),
		...etx(o / 2 + 2 * h, h, h, 20, -90, -180),
		{
			x: -o / 2 - h,
			y: -l / 2
		},
		...etx(o / 2, l / 2, h, 20, 0, 90)
	], p = [
		{
			x: o / 2,
			y: -l / 2 - h
		},
		{
			x: -o / 2,
			y: -l / 2 - h
		},
		...etx(o / 2, -l / 2, h, 20, -90, 0),
		{
			x: -o / 2 - h,
			y: -h
		},
		...etx(o / 2 + .1 * o, -h, h, 20, -180, -270),
		...etx(o / 2 + .1 * o, h, h, 20, -90, -180),
		{
			x: -o / 2 - h,
			y: l / 2
		},
		...etx(o / 2, l / 2, h, 20, 0, 90),
		{
			x: -o / 2,
			y: l / 2 + h
		},
		{
			x: o / 2,
			y: l / 2 + h
		}
	], f = ee1.svg(n), g = J0(t, { fill: "none" });
	"handDrawn" !== t.look && (g.roughness = 0, g.fillStyle = "solid");
	let m = J6(d).replace("Z", ""), y = f.path(m, g), v = J6(p), x = f.path(v, { ...g }), b = n.insert("g", ":first-child");
	return b.insert(() => x, ":first-child").attr("stroke-opacity", 0), b.insert(() => y, ":first-child"), b.attr("class", "text"), u && "handDrawn" !== t.look && b.selectAll("path").attr("style", u), i && "handDrawn" !== t.look && b.selectAll("path").attr("style", i), b.attr("transform", `translate(${h}, 0)`), s.attr("transform", `translate(${-o / 2 + h - (a.x - (a.left ?? 0))},${-l / 2 + (t.padding ?? 0) / 2 - (a.y - (a.top ?? 0))})`), J5(t, b), t.intersect = function(e) {
		return etc(t, p, e);
	}, n;
}
function etw(e, t, r, i = 100, n = 0, a = 180) {
	let s = [], o = n * Math.PI / 180, l = (a * Math.PI / 180 - o) / (i - 1);
	for (let n = 0; n < i; n++) {
		let i = o + n * l, a = e + r * Math.cos(i), h = t + r * Math.sin(i);
		s.push({
			x: a,
			y: h
		});
	}
	return s;
}
async function etk(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a, label: s } = await J2(e, t, J3(t)), o = a.width + (t.padding ?? 0), l = a.height + (t.padding ?? 0), h = Math.max(5, .1 * l), { cssStyles: u } = t, d = [
		...etw(o / 2, -l / 2, h, 20, -90, 0),
		{
			x: o / 2 + h,
			y: -h
		},
		...etw(o / 2 + 2 * h, -h, h, 20, -180, -270),
		...etw(o / 2 + 2 * h, h, h, 20, -90, -180),
		{
			x: o / 2 + h,
			y: l / 2
		},
		...etw(o / 2, l / 2, h, 20, 0, 90)
	], p = [
		{
			x: -o / 2,
			y: -l / 2 - h
		},
		{
			x: o / 2,
			y: -l / 2 - h
		},
		...etw(o / 2, -l / 2, h, 20, -90, 0),
		{
			x: o / 2 + h,
			y: -h
		},
		...etw(o / 2 + 2 * h, -h, h, 20, -180, -270),
		...etw(o / 2 + 2 * h, h, h, 20, -90, -180),
		{
			x: o / 2 + h,
			y: l / 2
		},
		...etw(o / 2, l / 2, h, 20, 0, 90),
		{
			x: o / 2,
			y: l / 2 + h
		},
		{
			x: -o / 2,
			y: l / 2 + h
		}
	], f = ee1.svg(n), g = J0(t, { fill: "none" });
	"handDrawn" !== t.look && (g.roughness = 0, g.fillStyle = "solid");
	let m = J6(d).replace("Z", ""), y = f.path(m, g), v = J6(p), x = f.path(v, { ...g }), b = n.insert("g", ":first-child");
	return b.insert(() => x, ":first-child").attr("stroke-opacity", 0), b.insert(() => y, ":first-child"), b.attr("class", "text"), u && "handDrawn" !== t.look && b.selectAll("path").attr("style", u), i && "handDrawn" !== t.look && b.selectAll("path").attr("style", i), b.attr("transform", `translate(${-h}, 0)`), s.attr("transform", `translate(${-o / 2 + (t.padding ?? 0) / 2 - (a.x - (a.left ?? 0))},${-l / 2 + (t.padding ?? 0) / 2 - (a.y - (a.top ?? 0))})`), J5(t, b), t.intersect = function(e) {
		return etc(t, p, e);
	}, n;
}
function etT(e, t, r, i = 100, n = 0, a = 180) {
	let s = [], o = n * Math.PI / 180, l = (a * Math.PI / 180 - o) / (i - 1);
	for (let n = 0; n < i; n++) {
		let i = o + n * l, a = e + r * Math.cos(i), h = t + r * Math.sin(i);
		s.push({
			x: -a,
			y: -h
		});
	}
	return s;
}
async function et_(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a, label: s } = await J2(e, t, J3(t)), o = a.width + (t.padding ?? 0), l = a.height + (t.padding ?? 0), h = Math.max(5, .1 * l), { cssStyles: u } = t, d = [
		...etT(o / 2, -l / 2, h, 30, -90, 0),
		{
			x: -o / 2 - h,
			y: h
		},
		...etT(o / 2 + 2 * h, -h, h, 20, -180, -270),
		...etT(o / 2 + 2 * h, h, h, 20, -90, -180),
		{
			x: -o / 2 - h,
			y: -l / 2
		},
		...etT(o / 2, l / 2, h, 20, 0, 90)
	], p = [
		...etT(-o / 2 + h + h / 2, -l / 2, h, 20, -90, -180),
		{
			x: o / 2 - h / 2,
			y: h
		},
		...etT(-o / 2 - h / 2, -h, h, 20, 0, 90),
		...etT(-o / 2 - h / 2, h, h, 20, -90, 0),
		{
			x: o / 2 - h / 2,
			y: -h
		},
		...etT(-o / 2 + h + h / 2, l / 2, h, 30, -180, -270)
	], f = [
		{
			x: o / 2,
			y: -l / 2 - h
		},
		{
			x: -o / 2,
			y: -l / 2 - h
		},
		...etT(o / 2, -l / 2, h, 20, -90, 0),
		{
			x: -o / 2 - h,
			y: -h
		},
		...etT(o / 2 + 2 * h, -h, h, 20, -180, -270),
		...etT(o / 2 + 2 * h, h, h, 20, -90, -180),
		{
			x: -o / 2 - h,
			y: l / 2
		},
		...etT(o / 2, l / 2, h, 20, 0, 90),
		{
			x: -o / 2,
			y: l / 2 + h
		},
		{
			x: o / 2 - h - h / 2,
			y: l / 2 + h
		},
		...etT(-o / 2 + h + h / 2, -l / 2, h, 20, -90, -180),
		{
			x: o / 2 - h / 2,
			y: h
		},
		...etT(-o / 2 - h / 2, -h, h, 20, 0, 90),
		...etT(-o / 2 - h / 2, h, h, 20, -90, 0),
		{
			x: o / 2 - h / 2,
			y: -h
		},
		...etT(-o / 2 + h + h / 2, l / 2, h, 30, -180, -270)
	], g = ee1.svg(n), m = J0(t, { fill: "none" });
	"handDrawn" !== t.look && (m.roughness = 0, m.fillStyle = "solid");
	let y = J6(d).replace("Z", ""), v = g.path(y, m), x = J6(p).replace("Z", ""), b = g.path(x, m), w = J6(f), k = g.path(w, { ...m }), T = n.insert("g", ":first-child");
	return T.insert(() => k, ":first-child").attr("stroke-opacity", 0), T.insert(() => v, ":first-child"), T.insert(() => b, ":first-child"), T.attr("class", "text"), u && "handDrawn" !== t.look && T.selectAll("path").attr("style", u), i && "handDrawn" !== t.look && T.selectAll("path").attr("style", i), T.attr("transform", `translate(${h - h / 4}, 0)`), s.attr("transform", `translate(${-o / 2 + (t.padding ?? 0) / 2 - (a.x - (a.left ?? 0))},${-l / 2 + (t.padding ?? 0) / 2 - (a.y - (a.top ?? 0))})`), J5(t, T), t.intersect = function(e) {
		return etc(t, f, e);
	}, n;
}
async function etE(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a } = await J2(e, t, J3(t)), s = Math.max(80, (a.width + (t.padding ?? 0) * 2) * 1.25, t?.width ?? 0), o = Math.max(20, a.height + (t.padding ?? 0) * 2, t?.height ?? 0), l = o / 2, { cssStyles: h } = t, u = ee1.svg(n), d = J0(t, {});
	"handDrawn" !== t.look && (d.roughness = 0, d.fillStyle = "solid");
	let p = s - l, f = o / 4, g = [
		{
			x: p,
			y: 0
		},
		{
			x: f,
			y: 0
		},
		{
			x: 0,
			y: o / 2
		},
		{
			x: f,
			y: o
		},
		{
			x: p,
			y: o
		},
		...J8(-p, -o / 2, l, 50, 270, 90)
	], m = J6(g), y = u.path(m, d), v = n.insert(() => y, ":first-child");
	return v.attr("class", "basic label-container"), h && "handDrawn" !== t.look && v.selectChildren("path").attr("style", h), i && "handDrawn" !== t.look && v.selectChildren("path").attr("style", i), v.attr("transform", `translate(${-s / 2}, ${-o / 2})`), J5(t, v), t.intersect = function(e) {
		return etc(t, g, e);
	}, n;
}
h(eth, "anchor"), h(etu, "generateArcPoints"), h(etd, "bowTieRect"), h(etp, "insertPolygonShape"), h(etf, "card"), h(etg, "choice"), h(etm, "circle"), h(ety, "createLine"), h(etv, "crossedCircle"), h(etx, "generateCirclePoints"), h(etb, "curlyBraceLeft"), h(etw, "generateCirclePoints"), h(etk, "curlyBraceRight"), h(etT, "generateCirclePoints"), h(et_, "curlyBraces"), h(etE, "curvedTrapezoid");
var etC = h((e, t, r, i, n, a) => `M${e},${t + a} a${n},${a} 0,0,0 ${r},0 a${n},${a} 0,0,0 ${-r},0 l0,${i} a${n},${a} 0,0,0 ${r},0 l0,${-i}`, "createCylinderPathD"), etS = h((e, t, r, i, n, a) => `M${e},${t + a} M${e + r},${t + a} a${n},${a} 0,0,0 ${-r},0 l0,${i} a${n},${a} 0,0,0 ${r},0 l0,${-i}`, "createOuterCylinderPathD"), etA = h((e, t, r, i, n, a) => `M${e - r / 2},${-i / 2} a${n},${a} 0,0,0 ${r},0`, "createInnerCylinderPathD");
async function etL(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a, label: s } = await J2(e, t, J3(t)), o = Math.max(a.width + t.padding, t.width ?? 0), l = o / 2, h = l / (2.5 + o / 50), u = Math.max(a.height + h + t.padding, t.height ?? 0), d, { cssStyles: p } = t;
	if ("handDrawn" === t.look) {
		let e = ee1.svg(n), r = etS(0, 0, o, u, l, h), i = etA(0, h, o, u, l, h), a = e.path(r, J0(t, {})), s = e.path(i, J0(t, { fill: "none" }));
		d = n.insert(() => s, ":first-child"), (d = n.insert(() => a, ":first-child")).attr("class", "basic label-container"), p && d.attr("style", p);
	} else {
		let e = etC(0, 0, o, u, l, h);
		d = n.insert("path", ":first-child").attr("d", e).attr("class", "basic label-container").attr("style", V8(p)).attr("style", i);
	}
	return d.attr("label-offset-y", h), d.attr("transform", `translate(${-o / 2}, ${-(u / 2 + h)})`), J5(t, d), s.attr("transform", `translate(${-(a.width / 2) - (a.x - (a.left ?? 0))}, ${-(a.height / 2) + (t.padding ?? 0) / 1.5 - (a.y - (a.top ?? 0))})`), t.intersect = function(e) {
		let r = ee2(t, e), i = r.x - (t.x ?? 0);
		if (0 != l && (Math.abs(i) < (t.width ?? 0) / 2 || Math.abs(i) == (t.width ?? 0) / 2 && Math.abs(r.y - (t.y ?? 0)) > (t.height ?? 0) / 2 - h)) {
			let n = h * h * (1 - i * i / (l * l));
			n > 0 && (n = Math.sqrt(n)), n = h - n, e.y - (t.y ?? 0) > 0 && (n = -n), r.y += n;
		}
		return r;
	}, n;
}
async function etR(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a, label: s } = await J2(e, t, J3(t)), o = a.width + t.padding, l = a.height + t.padding, h = .2 * l, u = -o / 2, d = -l / 2 - h / 2, { cssStyles: p } = t, f = ee1.svg(n), g = J0(t, {});
	"handDrawn" !== t.look && (g.roughness = 0, g.fillStyle = "solid");
	let m = f.polygon([
		{
			x: u,
			y: d + h
		},
		{
			x: -u,
			y: d + h
		},
		{
			x: -u,
			y: -d
		},
		{
			x: u,
			y: -d
		},
		{
			x: u,
			y: d
		},
		{
			x: -u,
			y: d
		},
		{
			x: -u,
			y: d + h
		}
	].map((e) => [e.x, e.y]), g), y = n.insert(() => m, ":first-child");
	return y.attr("class", "basic label-container"), p && "handDrawn" !== t.look && y.selectAll("path").attr("style", p), i && "handDrawn" !== t.look && y.selectAll("path").attr("style", i), s.attr("transform", `translate(${u + (t.padding ?? 0) / 2 - (a.x - (a.left ?? 0))}, ${d + h + (t.padding ?? 0) / 2 - (a.y - (a.top ?? 0))})`), J5(t, y), t.intersect = function(e) {
		return ee2(t, e);
	}, n;
}
async function etN(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a, halfPadding: s } = await J2(e, t, J3(t)), o = a.width / 2 + s + 5, l = a.width / 2 + s, h, { cssStyles: u } = t;
	if ("handDrawn" === t.look) {
		let e = ee1.svg(n), r = J0(t, {
			roughness: .2,
			strokeWidth: 2.5
		}), i = J0(t, {
			roughness: .2,
			strokeWidth: 1.5
		}), a = e.circle(0, 0, 2 * o, r), s = e.circle(0, 0, 2 * l, i);
		(h = n.insert("g", ":first-child")).attr("class", V8(t.cssClasses)).attr("style", V8(u)), h.node()?.appendChild(a), h.node()?.appendChild(s);
	} else {
		let e = (h = n.insert("g", ":first-child")).insert("circle", ":first-child"), t = h.insert("circle");
		h.attr("class", "basic label-container").attr("style", i), e.attr("class", "outer-circle").attr("style", i).attr("r", o).attr("cx", 0).attr("cy", 0), t.attr("class", "inner-circle").attr("style", i).attr("r", l).attr("cx", 0).attr("cy", 0);
	}
	return J5(t, h), t.intersect = function(e) {
		return wQ.info("DoubleCircle intersect", t, o, e), ets(t, o, e);
	}, n;
}
function etI(e, t, { config: { themeVariables: r } }) {
	let { labelStyles: i, nodeStyles: n } = JJ(t);
	t.label = "", t.labelStyle = i;
	let a = e.insert("g").attr("class", J3(t)).attr("id", t.domId ?? t.id), { cssStyles: s } = t, o = ee1.svg(a), { nodeBorder: l } = r, h = J0(t, { fillStyle: "solid" });
	"handDrawn" !== t.look && (h.roughness = 0);
	let u = o.circle(0, 0, 14, h), d = a.insert(() => u, ":first-child");
	return d.selectAll("path").attr("style", `fill: ${l} !important;`), s && s.length > 0 && "handDrawn" !== t.look && d.selectAll("path").attr("style", s), n && "handDrawn" !== t.look && d.selectAll("path").attr("style", n), J5(t, d), t.intersect = function(e) {
		return wQ.info("filledCircle intersect", t, {
			radius: 7,
			point: e
		}), ets(t, 7, e);
	}, a;
}
async function etM(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a, label: s } = await J2(e, t, J3(t)), o = a.width + (t.padding ?? 0), l = o + a.height, h = o + a.height, u = [
		{
			x: 0,
			y: -l
		},
		{
			x: h,
			y: -l
		},
		{
			x: h / 2,
			y: 0
		}
	], { cssStyles: d } = t, p = ee1.svg(n), f = J0(t, {});
	"handDrawn" !== t.look && (f.roughness = 0, f.fillStyle = "solid");
	let g = J6(u), m = p.path(g, f), y = n.insert(() => m, ":first-child").attr("transform", `translate(${-l / 2}, ${l / 2})`);
	return d && "handDrawn" !== t.look && y.selectChildren("path").attr("style", d), i && "handDrawn" !== t.look && y.selectChildren("path").attr("style", i), t.width = o, t.height = l, J5(t, y), s.attr("transform", `translate(${-a.width / 2 - (a.x - (a.left ?? 0))}, ${-l / 2 + (t.padding ?? 0) / 2 + (a.y - (a.top ?? 0))})`), t.intersect = function(e) {
		return wQ.info("Triangle intersect", t, u, e), etc(t, u, e);
	}, n;
}
function etD(e, t, { dir: r, config: { state: i, themeVariables: n } }) {
	let { nodeStyles: a } = JJ(t);
	t.label = "";
	let s = e.insert("g").attr("class", J3(t)).attr("id", t.domId ?? t.id), { cssStyles: o } = t, l = Math.max(70, t?.width ?? 0), h = Math.max(10, t?.height ?? 0);
	"LR" === r && (l = Math.max(10, t?.width ?? 0), h = Math.max(70, t?.height ?? 0));
	let u = -1 * l / 2, d = -1 * h / 2, p = ee1.svg(s), f = J0(t, {
		stroke: n.lineColor,
		fill: n.lineColor
	});
	"handDrawn" !== t.look && (f.roughness = 0, f.fillStyle = "solid");
	let g = p.rectangle(u, d, l, h, f), m = s.insert(() => g, ":first-child");
	o && "handDrawn" !== t.look && m.selectAll("path").attr("style", o), a && "handDrawn" !== t.look && m.selectAll("path").attr("style", a), J5(t, m);
	let y = i?.padding ?? 0;
	return t.width && t.height && (t.width += y / 2 || 0, t.height += y / 2 || 0), t.intersect = function(e) {
		return ee2(t, e);
	}, s;
}
async function etO(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a } = await J2(e, t, J3(t)), s = Math.max(80, a.width + (t.padding ?? 0) * 2, t?.width ?? 0), o = Math.max(50, a.height + (t.padding ?? 0) * 2, t?.height ?? 0), l = o / 2, { cssStyles: h } = t, u = ee1.svg(n), d = J0(t, {});
	"handDrawn" !== t.look && (d.roughness = 0, d.fillStyle = "solid");
	let p = [
		{
			x: -s / 2,
			y: -o / 2
		},
		{
			x: s / 2 - l,
			y: -o / 2
		},
		...J8(-s / 2 + l, 0, l, 50, 90, 270),
		{
			x: s / 2 - l,
			y: o / 2
		},
		{
			x: -s / 2,
			y: o / 2
		}
	], f = J6(p), g = u.path(f, d), m = n.insert(() => g, ":first-child");
	return m.attr("class", "basic label-container"), h && "handDrawn" !== t.look && m.selectChildren("path").attr("style", h), i && "handDrawn" !== t.look && m.selectChildren("path").attr("style", i), J5(t, m), t.intersect = function(e) {
		return wQ.info("Pill intersect", t, {
			radius: l,
			point: e
		}), etc(t, p, e);
	}, n;
}
async function et$(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a } = await J2(e, t, J3(t)), s = a.height + (t.padding ?? 0), o = a.width + (t.padding ?? 0) * 2.5, { cssStyles: l } = t, h = ee1.svg(n), u = J0(t, {});
	"handDrawn" !== t.look && (u.roughness = 0, u.fillStyle = "solid");
	let d = o / 2, p = d / 6, f = s / 2, g = (d += p) - f / 2, m = [
		{
			x: -g,
			y: -f
		},
		{
			x: 0,
			y: -f
		},
		{
			x: g,
			y: -f
		},
		{
			x: d,
			y: 0
		},
		{
			x: g,
			y: f
		},
		{
			x: 0,
			y: f
		},
		{
			x: -g,
			y: f
		},
		{
			x: -d,
			y: 0
		}
	], y = J6(m), v = h.path(y, u), x = n.insert(() => v, ":first-child");
	return x.attr("class", "basic label-container"), l && "handDrawn" !== t.look && x.selectChildren("path").attr("style", l), i && "handDrawn" !== t.look && x.selectChildren("path").attr("style", i), t.width = o, t.height = s, J5(t, x), t.intersect = function(e) {
		return etc(t, m, e);
	}, n;
}
async function etP(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.label = "", t.labelStyle = r;
	let { shapeSvg: n } = await J2(e, t, J3(t)), a = Math.max(30, t?.width ?? 0), s = Math.max(30, t?.height ?? 0), { cssStyles: o } = t, l = ee1.svg(n), h = J0(t, {});
	"handDrawn" !== t.look && (h.roughness = 0, h.fillStyle = "solid");
	let u = [
		{
			x: 0,
			y: 0
		},
		{
			x: a,
			y: 0
		},
		{
			x: 0,
			y: s
		},
		{
			x: a,
			y: s
		}
	], d = J6(u), p = l.path(d, h), f = n.insert(() => p, ":first-child");
	return f.attr("class", "basic label-container"), o && "handDrawn" !== t.look && f.selectChildren("path").attr("style", o), i && "handDrawn" !== t.look && f.selectChildren("path").attr("style", i), f.attr("transform", `translate(${-a / 2}, ${-s / 2})`), J5(t, f), t.intersect = function(e) {
		return wQ.info("Pill intersect", t, { points: u }), etc(t, u, e);
	}, n;
}
async function etB(e, t, { config: { themeVariables: r, flowchart: i } }) {
	let { labelStyles: n } = JJ(t);
	t.labelStyle = n;
	let a = Math.max(t.assetHeight ?? 48, t.assetWidth ?? 48);
	t.width = Math.max(a, i?.wrappingWidth ?? 0);
	let { shapeSvg: s, bbox: o, label: l } = await J2(e, t, "icon-shape default"), h = "t" === t.pos, { nodeBorder: u } = r, { stylesMap: d } = JK(t), p = -a / 2, f = -a / 2, g = 8 * !!t.label, m = ee1.svg(s), y = J0(t, {
		stroke: "none",
		fill: "none"
	});
	"handDrawn" !== t.look && (y.roughness = 0, y.fillStyle = "solid");
	let v = m.rectangle(p, f, a, a, y), x = Math.max(a, o.width), b = a + o.height + g, w = m.rectangle(-x / 2, -b / 2, x, b, {
		...y,
		fill: "transparent",
		stroke: "none"
	}), k = s.insert(() => v, ":first-child"), T = s.insert(() => w);
	if (t.icon) {
		let e = s.append("g");
		e.html(`<g>${await HN(t.icon, {
			height: a,
			width: a,
			fallbackPrefix: ""
		})}</g>`);
		let r = e.node().getBBox(), i = r.width, n = r.height, l = r.x, p = r.y;
		e.attr("transform", `translate(${-i / 2 - l},${h ? o.height / 2 + g / 2 - n / 2 - p : -o.height / 2 - g / 2 - n / 2 - p})`), e.attr("style", `color: ${d.get("stroke") ?? u};`);
	}
	return l.attr("transform", `translate(${-o.width / 2 - (o.x - (o.left ?? 0))},${h ? -b / 2 : b / 2 - o.height})`), k.attr("transform", `translate(0,${h ? o.height / 2 + g / 2 : -o.height / 2 - g / 2})`), J5(t, T), t.intersect = function(e) {
		if (wQ.info("iconSquare intersect", t, e), !t.label) return ee2(t, e);
		let r = t.x ?? 0, i = t.y ?? 0, n = t.height ?? 0;
		return etc(t, h ? [
			{
				x: r - o.width / 2,
				y: i - n / 2
			},
			{
				x: r + o.width / 2,
				y: i - n / 2
			},
			{
				x: r + o.width / 2,
				y: i - n / 2 + o.height + g
			},
			{
				x: r + a / 2,
				y: i - n / 2 + o.height + g
			},
			{
				x: r + a / 2,
				y: i + n / 2
			},
			{
				x: r - a / 2,
				y: i + n / 2
			},
			{
				x: r - a / 2,
				y: i - n / 2 + o.height + g
			},
			{
				x: r - o.width / 2,
				y: i - n / 2 + o.height + g
			}
		] : [
			{
				x: r - a / 2,
				y: i - n / 2
			},
			{
				x: r + a / 2,
				y: i - n / 2
			},
			{
				x: r + a / 2,
				y: i - n / 2 + a
			},
			{
				x: r + o.width / 2,
				y: i - n / 2 + a
			},
			{
				x: r + o.width / 2 / 2,
				y: i + n / 2
			},
			{
				x: r - o.width / 2,
				y: i + n / 2
			},
			{
				x: r - o.width / 2,
				y: i - n / 2 + a
			},
			{
				x: r - a / 2,
				y: i - n / 2 + a
			}
		], e);
	}, s;
}
async function etF(e, t, { config: { themeVariables: r, flowchart: i } }) {
	let { labelStyles: n } = JJ(t);
	t.labelStyle = n;
	let a = Math.max(t.assetHeight ?? 48, t.assetWidth ?? 48);
	t.width = Math.max(a, i?.wrappingWidth ?? 0);
	let { shapeSvg: s, bbox: o, label: l } = await J2(e, t, "icon-shape default"), h = 8 * !!t.label, u = "t" === t.pos, { nodeBorder: d, mainBkg: p } = r, { stylesMap: f } = JK(t), g = ee1.svg(s), m = J0(t, {});
	"handDrawn" !== t.look && (m.roughness = 0, m.fillStyle = "solid"), m.stroke = f.get("fill") ?? p;
	let y = s.append("g");
	t.icon && y.html(`<g>${await HN(t.icon, {
		height: a,
		width: a,
		fallbackPrefix: ""
	})}</g>`);
	let v = y.node().getBBox(), x = v.width, b = v.height, w = v.x, k = v.y, T = Math.max(x, b) * Math.SQRT2 + 40, _ = g.circle(0, 0, T, m), E = Math.max(T, o.width), C = T + o.height + h, S = g.rectangle(-E / 2, -C / 2, E, C, {
		...m,
		fill: "transparent",
		stroke: "none"
	}), A = s.insert(() => _, ":first-child"), L = s.insert(() => S);
	return y.attr("transform", `translate(${-x / 2 - w},${u ? o.height / 2 + h / 2 - b / 2 - k : -o.height / 2 - h / 2 - b / 2 - k})`), y.attr("style", `color: ${f.get("stroke") ?? d};`), l.attr("transform", `translate(${-o.width / 2 - (o.x - (o.left ?? 0))},${u ? -C / 2 : C / 2 - o.height})`), A.attr("transform", `translate(0,${u ? o.height / 2 + h / 2 : -o.height / 2 - h / 2})`), J5(t, L), t.intersect = function(e) {
		return wQ.info("iconSquare intersect", t, e), ee2(t, e);
	}, s;
}
async function etz(e, t, { config: { themeVariables: r, flowchart: i } }) {
	let { labelStyles: n } = JJ(t);
	t.labelStyle = n;
	let a = Math.max(t.assetHeight ?? 48, t.assetWidth ?? 48);
	t.width = Math.max(a, i?.wrappingWidth ?? 0);
	let { shapeSvg: s, bbox: o, halfPadding: l, label: h } = await J2(e, t, "icon-shape default"), u = "t" === t.pos, d = a + 2 * l, p = a + 2 * l, { nodeBorder: f, mainBkg: g } = r, { stylesMap: m } = JK(t), y = 8 * !!t.label, v = ee1.svg(s), x = J0(t, {});
	"handDrawn" !== t.look && (x.roughness = 0, x.fillStyle = "solid"), x.stroke = m.get("fill") ?? g;
	let b = v.path(ee6(-p / 2, -d / 2, p, d, 5), x), w = Math.max(p, o.width), k = d + o.height + y, T = v.rectangle(-w / 2, -k / 2, w, k, {
		...x,
		fill: "transparent",
		stroke: "none"
	}), _ = s.insert(() => b, ":first-child").attr("class", "icon-shape2"), E = s.insert(() => T);
	if (t.icon) {
		let e = s.append("g");
		e.html(`<g>${await HN(t.icon, {
			height: a,
			width: a,
			fallbackPrefix: ""
		})}</g>`);
		let r = e.node().getBBox(), i = r.width, n = r.height, l = r.x, h = r.y;
		e.attr("transform", `translate(${-i / 2 - l},${u ? o.height / 2 + y / 2 - n / 2 - h : -o.height / 2 - y / 2 - n / 2 - h})`), e.attr("style", `color: ${m.get("stroke") ?? f};`);
	}
	return h.attr("transform", `translate(${-o.width / 2 - (o.x - (o.left ?? 0))},${u ? -k / 2 : k / 2 - o.height})`), _.attr("transform", `translate(0,${u ? o.height / 2 + y / 2 : -o.height / 2 - y / 2})`), J5(t, E), t.intersect = function(e) {
		if (wQ.info("iconSquare intersect", t, e), !t.label) return ee2(t, e);
		let r = t.x ?? 0, i = t.y ?? 0, n = t.height ?? 0;
		return etc(t, u ? [
			{
				x: r - o.width / 2,
				y: i - n / 2
			},
			{
				x: r + o.width / 2,
				y: i - n / 2
			},
			{
				x: r + o.width / 2,
				y: i - n / 2 + o.height + y
			},
			{
				x: r + p / 2,
				y: i - n / 2 + o.height + y
			},
			{
				x: r + p / 2,
				y: i + n / 2
			},
			{
				x: r - p / 2,
				y: i + n / 2
			},
			{
				x: r - p / 2,
				y: i - n / 2 + o.height + y
			},
			{
				x: r - o.width / 2,
				y: i - n / 2 + o.height + y
			}
		] : [
			{
				x: r - p / 2,
				y: i - n / 2
			},
			{
				x: r + p / 2,
				y: i - n / 2
			},
			{
				x: r + p / 2,
				y: i - n / 2 + d
			},
			{
				x: r + o.width / 2,
				y: i - n / 2 + d
			},
			{
				x: r + o.width / 2 / 2,
				y: i + n / 2
			},
			{
				x: r - o.width / 2,
				y: i + n / 2
			},
			{
				x: r - o.width / 2,
				y: i - n / 2 + d
			},
			{
				x: r - p / 2,
				y: i - n / 2 + d
			}
		], e);
	}, s;
}
async function etU(e, t, { config: { themeVariables: r, flowchart: i } }) {
	let { labelStyles: n } = JJ(t);
	t.labelStyle = n;
	let a = Math.max(t.assetHeight ?? 48, t.assetWidth ?? 48);
	t.width = Math.max(a, i?.wrappingWidth ?? 0);
	let { shapeSvg: s, bbox: o, halfPadding: l, label: h } = await J2(e, t, "icon-shape default"), u = "t" === t.pos, d = a + 2 * l, p = a + 2 * l, { nodeBorder: f, mainBkg: g } = r, { stylesMap: m } = JK(t), y = 8 * !!t.label, v = ee1.svg(s), x = J0(t, {});
	"handDrawn" !== t.look && (x.roughness = 0, x.fillStyle = "solid"), x.stroke = m.get("fill") ?? g;
	let b = v.path(ee6(-p / 2, -d / 2, p, d, .1), x), w = Math.max(p, o.width), k = d + o.height + y, T = v.rectangle(-w / 2, -k / 2, w, k, {
		...x,
		fill: "transparent",
		stroke: "none"
	}), _ = s.insert(() => b, ":first-child"), E = s.insert(() => T);
	if (t.icon) {
		let e = s.append("g");
		e.html(`<g>${await HN(t.icon, {
			height: a,
			width: a,
			fallbackPrefix: ""
		})}</g>`);
		let r = e.node().getBBox(), i = r.width, n = r.height, l = r.x, h = r.y;
		e.attr("transform", `translate(${-i / 2 - l},${u ? o.height / 2 + y / 2 - n / 2 - h : -o.height / 2 - y / 2 - n / 2 - h})`), e.attr("style", `color: ${m.get("stroke") ?? f};`);
	}
	return h.attr("transform", `translate(${-o.width / 2 - (o.x - (o.left ?? 0))},${u ? -k / 2 : k / 2 - o.height})`), _.attr("transform", `translate(0,${u ? o.height / 2 + y / 2 : -o.height / 2 - y / 2})`), J5(t, E), t.intersect = function(e) {
		if (wQ.info("iconSquare intersect", t, e), !t.label) return ee2(t, e);
		let r = t.x ?? 0, i = t.y ?? 0, n = t.height ?? 0;
		return etc(t, u ? [
			{
				x: r - o.width / 2,
				y: i - n / 2
			},
			{
				x: r + o.width / 2,
				y: i - n / 2
			},
			{
				x: r + o.width / 2,
				y: i - n / 2 + o.height + y
			},
			{
				x: r + p / 2,
				y: i - n / 2 + o.height + y
			},
			{
				x: r + p / 2,
				y: i + n / 2
			},
			{
				x: r - p / 2,
				y: i + n / 2
			},
			{
				x: r - p / 2,
				y: i - n / 2 + o.height + y
			},
			{
				x: r - o.width / 2,
				y: i - n / 2 + o.height + y
			}
		] : [
			{
				x: r - p / 2,
				y: i - n / 2
			},
			{
				x: r + p / 2,
				y: i - n / 2
			},
			{
				x: r + p / 2,
				y: i - n / 2 + d
			},
			{
				x: r + o.width / 2,
				y: i - n / 2 + d
			},
			{
				x: r + o.width / 2 / 2,
				y: i + n / 2
			},
			{
				x: r - o.width / 2,
				y: i + n / 2
			},
			{
				x: r - o.width / 2,
				y: i - n / 2 + d
			},
			{
				x: r - p / 2,
				y: i - n / 2 + d
			}
		], e);
	}, s;
}
async function etG(e, t, { config: { flowchart: r } }) {
	let i = new Image();
	i.src = t?.img ?? "", await i.decode();
	let n = Number(i.naturalWidth.toString().replace("px", "")), a = Number(i.naturalHeight.toString().replace("px", ""));
	t.imageAspectRatio = n / a;
	let { labelStyles: s } = JJ(t);
	t.labelStyle = s;
	let o = r?.wrappingWidth;
	t.defaultWidth = r?.wrappingWidth;
	let l = Math.max(t.label ? o ?? 0 : 0, t?.assetWidth ?? n), h = "on" === t.constraint && t?.assetHeight ? t.assetHeight * t.imageAspectRatio : l, u = "on" === t.constraint ? h / t.imageAspectRatio : t?.assetHeight ?? a;
	t.width = Math.max(h, o ?? 0);
	let { shapeSvg: d, bbox: p, label: f } = await J2(e, t, "image-shape default"), g = "t" === t.pos, m = -h / 2, y = 8 * !!t.label, v = ee1.svg(d), x = J0(t, {});
	"handDrawn" !== t.look && (x.roughness = 0, x.fillStyle = "solid");
	let b = v.rectangle(m, -u / 2, h, u, x), w = Math.max(h, p.width), k = u + p.height + y, T = v.rectangle(-w / 2, -k / 2, w, k, {
		...x,
		fill: "none",
		stroke: "none"
	}), _ = d.insert(() => b, ":first-child"), E = d.insert(() => T);
	if (t.img) {
		let e = d.append("image");
		e.attr("href", t.img), e.attr("width", h), e.attr("height", u), e.attr("preserveAspectRatio", "none"), e.attr("transform", `translate(${-h / 2},${g ? k / 2 - u : -k / 2})`);
	}
	return f.attr("transform", `translate(${-p.width / 2 - (p.x - (p.left ?? 0))},${g ? -u / 2 - p.height / 2 - y / 2 : u / 2 - p.height / 2 + y / 2})`), _.attr("transform", `translate(0,${g ? p.height / 2 + y / 2 : -p.height / 2 - y / 2})`), J5(t, E), t.intersect = function(e) {
		if (wQ.info("iconSquare intersect", t, e), !t.label) return ee2(t, e);
		let r = t.x ?? 0, i = t.y ?? 0, n = t.height ?? 0;
		return etc(t, g ? [
			{
				x: r - p.width / 2,
				y: i - n / 2
			},
			{
				x: r + p.width / 2,
				y: i - n / 2
			},
			{
				x: r + p.width / 2,
				y: i - n / 2 + p.height + y
			},
			{
				x: r + h / 2,
				y: i - n / 2 + p.height + y
			},
			{
				x: r + h / 2,
				y: i + n / 2
			},
			{
				x: r - h / 2,
				y: i + n / 2
			},
			{
				x: r - h / 2,
				y: i - n / 2 + p.height + y
			},
			{
				x: r - p.width / 2,
				y: i - n / 2 + p.height + y
			}
		] : [
			{
				x: r - h / 2,
				y: i - n / 2
			},
			{
				x: r + h / 2,
				y: i - n / 2
			},
			{
				x: r + h / 2,
				y: i - n / 2 + u
			},
			{
				x: r + p.width / 2,
				y: i - n / 2 + u
			},
			{
				x: r + p.width / 2 / 2,
				y: i + n / 2
			},
			{
				x: r - p.width / 2,
				y: i + n / 2
			},
			{
				x: r - p.width / 2,
				y: i - n / 2 + u
			},
			{
				x: r - h / 2,
				y: i - n / 2 + u
			}
		], e);
	}, d;
}
async function etq(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a } = await J2(e, t, J3(t)), s = Math.max(a.width + (t.padding ?? 0) * 2, t?.width ?? 0), o = Math.max(a.height + (t.padding ?? 0) * 2, t?.height ?? 0), l = [
		{
			x: 0,
			y: 0
		},
		{
			x: s,
			y: 0
		},
		{
			x: s + 3 * o / 6,
			y: -o
		},
		{
			x: -3 * o / 6,
			y: -o
		}
	], h, { cssStyles: u } = t;
	if ("handDrawn" === t.look) {
		let e = ee1.svg(n), r = J0(t, {}), i = J6(l), a = e.path(i, r);
		h = n.insert(() => a, ":first-child").attr("transform", `translate(${-s / 2}, ${o / 2})`), u && h.attr("style", u);
	} else h = etp(n, s, o, l);
	return i && h.attr("style", i), t.width = s, t.height = o, J5(t, h), t.intersect = function(e) {
		return etc(t, l, e);
	}, n;
}
async function etj(e, t, r) {
	let { labelStyles: i, nodeStyles: n } = JJ(t);
	t.labelStyle = i;
	let { shapeSvg: a, bbox: s } = await J2(e, t, J3(t)), o = Math.max(s.width + 2 * r.labelPaddingX, t?.width || 0), l = Math.max(s.height + 2 * r.labelPaddingY, t?.height || 0), h = -o / 2, u = -l / 2, d, { rx: p, ry: f } = t, { cssStyles: g } = t;
	if (r?.rx && r.ry && (p = r.rx, f = r.ry), "handDrawn" === t.look) {
		let e = ee1.svg(a), r = J0(t, {}), i = p || f ? e.path(ee6(h, u, o, l, p || 0), r) : e.rectangle(h, u, o, l, r);
		(d = a.insert(() => i, ":first-child")).attr("class", "basic label-container").attr("style", V8(g));
	} else (d = a.insert("rect", ":first-child")).attr("class", "basic label-container").attr("style", n).attr("rx", V8(p)).attr("ry", V8(f)).attr("x", h).attr("y", u).attr("width", o).attr("height", l);
	return J5(t, d), t.calcIntersect = function(e, t) {
		return ee2(e, t);
	}, t.intersect = function(e) {
		return ee2(t, e);
	}, a;
}
async function etW(e, t) {
	let { shapeSvg: r, bbox: i, label: n } = await J2(e, t, "label"), a = r.insert("rect", ":first-child");
	return a.attr("width", .1).attr("height", .1), r.attr("class", "label edgeLabel"), n.attr("transform", `translate(${-(i.width / 2) - (i.x - (i.left ?? 0))}, ${-(i.height / 2) - (i.y - (i.top ?? 0))})`), J5(t, a), t.intersect = function(e) {
		return ee2(t, e);
	}, r;
}
async function etY(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a } = await J2(e, t, J3(t)), s = Math.max(a.width + (t.padding ?? 0), t?.width ?? 0), o = Math.max(a.height + (t.padding ?? 0), t?.height ?? 0), l = [
		{
			x: 0,
			y: 0
		},
		{
			x: s + 3 * o / 6,
			y: 0
		},
		{
			x: s,
			y: -o
		},
		{
			x: -(3 * o) / 6,
			y: -o
		}
	], h, { cssStyles: u } = t;
	if ("handDrawn" === t.look) {
		let e = ee1.svg(n), r = J0(t, {}), i = J6(l), a = e.path(i, r);
		h = n.insert(() => a, ":first-child").attr("transform", `translate(${-s / 2}, ${o / 2})`), u && h.attr("style", u);
	} else h = etp(n, s, o, l);
	return i && h.attr("style", i), t.width = s, t.height = o, J5(t, h), t.intersect = function(e) {
		return etc(t, l, e);
	}, n;
}
async function etV(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a } = await J2(e, t, J3(t)), s = Math.max(a.width + (t.padding ?? 0), t?.width ?? 0), o = Math.max(a.height + (t.padding ?? 0), t?.height ?? 0), l = [
		{
			x: -3 * o / 6,
			y: 0
		},
		{
			x: s,
			y: 0
		},
		{
			x: s + 3 * o / 6,
			y: -o
		},
		{
			x: 0,
			y: -o
		}
	], h, { cssStyles: u } = t;
	if ("handDrawn" === t.look) {
		let e = ee1.svg(n), r = J0(t, {}), i = J6(l), a = e.path(i, r);
		h = n.insert(() => a, ":first-child").attr("transform", `translate(${-s / 2}, ${o / 2})`), u && h.attr("style", u);
	} else h = etp(n, s, o, l);
	return i && h.attr("style", i), t.width = s, t.height = o, J5(t, h), t.intersect = function(e) {
		return etc(t, l, e);
	}, n;
}
function etH(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.label = "", t.labelStyle = r;
	let n = e.insert("g").attr("class", J3(t)).attr("id", t.domId ?? t.id), { cssStyles: a } = t, s = Math.max(35, t?.width ?? 0), o = Math.max(35, t?.height ?? 0), l = [
		{
			x: s,
			y: 0
		},
		{
			x: 0,
			y: o + 3.5
		},
		{
			x: s - 14,
			y: o + 3.5
		},
		{
			x: 0,
			y: 2 * o
		},
		{
			x: s,
			y: o - 3.5
		},
		{
			x: 14,
			y: o - 3.5
		}
	], h = ee1.svg(n), u = J0(t, {});
	"handDrawn" !== t.look && (u.roughness = 0, u.fillStyle = "solid");
	let d = J6(l), p = h.path(d, u), f = n.insert(() => p, ":first-child");
	return a && "handDrawn" !== t.look && f.selectAll("path").attr("style", a), i && "handDrawn" !== t.look && f.selectAll("path").attr("style", i), f.attr("transform", `translate(-${s / 2},${-o})`), J5(t, f), t.intersect = function(e) {
		return wQ.info("lightningBolt intersect", t, e), etc(t, l, e);
	}, n;
}
h(etL, "cylinder"), h(etR, "dividedRectangle"), h(etN, "doublecircle"), h(etI, "filledCircle"), h(etM, "flippedTriangle"), h(etD, "forkJoin"), h(etO, "halfRoundedRectangle"), h(et$, "hexagon"), h(etP, "hourglass"), h(etB, "icon"), h(etF, "iconCircle"), h(etz, "iconRounded"), h(etU, "iconSquare"), h(etG, "imageSquare"), h(etq, "inv_trapezoid"), h(etj, "drawRect"), h(etW, "labelRect"), h(etY, "lean_left"), h(etV, "lean_right"), h(etH, "lightningBolt");
var etX = h((e, t, r, i, n, a, s) => `M${e},${t + a} a${n},${a} 0,0,0 ${r},0 a${n},${a} 0,0,0 ${-r},0 l0,${i} a${n},${a} 0,0,0 ${r},0 l0,${-i} M${e},${t + a + s} a${n},${a} 0,0,0 ${r},0`, "createCylinderPathD"), etK = h((e, t, r, i, n, a, s) => `M${e},${t + a} M${e + r},${t + a} a${n},${a} 0,0,0 ${-r},0 l0,${i} a${n},${a} 0,0,0 ${r},0 l0,${-i} M${e},${t + a + s} a${n},${a} 0,0,0 ${r},0`, "createOuterCylinderPathD"), etZ = h((e, t, r, i, n, a) => `M${e - r / 2},${-i / 2} a${n},${a} 0,0,0 ${r},0`, "createInnerCylinderPathD");
async function etQ(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a, label: s } = await J2(e, t, J3(t)), o = Math.max(a.width + (t.padding ?? 0), t.width ?? 0), l = o / 2, h = l / (2.5 + o / 50), u = Math.max(a.height + h + (t.padding ?? 0), t.height ?? 0), d = .1 * u, p, { cssStyles: f } = t;
	if ("handDrawn" === t.look) {
		let e = ee1.svg(n), r = etK(0, 0, o, u, l, h, d), i = etZ(0, h, o, u, l, h), a = J0(t, {}), s = e.path(r, a), g = e.path(i, a);
		n.insert(() => g, ":first-child").attr("class", "line"), (p = n.insert(() => s, ":first-child")).attr("class", "basic label-container"), f && p.attr("style", f);
	} else {
		let e = etX(0, 0, o, u, l, h, d);
		p = n.insert("path", ":first-child").attr("d", e).attr("class", "basic label-container").attr("style", V8(f)).attr("style", i);
	}
	return p.attr("label-offset-y", h), p.attr("transform", `translate(${-o / 2}, ${-(u / 2 + h)})`), J5(t, p), s.attr("transform", `translate(${-(a.width / 2) - (a.x - (a.left ?? 0))}, ${-(a.height / 2) + h - (a.y - (a.top ?? 0))})`), t.intersect = function(e) {
		let r = ee2(t, e), i = r.x - (t.x ?? 0);
		if (0 != l && (Math.abs(i) < (t.width ?? 0) / 2 || Math.abs(i) == (t.width ?? 0) / 2 && Math.abs(r.y - (t.y ?? 0)) > (t.height ?? 0) / 2 - h)) {
			let n = h * h * (1 - i * i / (l * l));
			n > 0 && (n = Math.sqrt(n)), n = h - n, e.y - (t.y ?? 0) > 0 && (n = -n), r.y += n;
		}
		return r;
	}, n;
}
async function etJ(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a, label: s } = await J2(e, t, J3(t)), o = Math.max(a.width + (t.padding ?? 0) * 2, t?.width ?? 0), l = Math.max(a.height + (t.padding ?? 0) * 2, t?.height ?? 0), h = l / 4, u = l + h, { cssStyles: d } = t, p = ee1.svg(n), f = J0(t, {});
	"handDrawn" !== t.look && (f.roughness = 0, f.fillStyle = "solid");
	let g = [
		{
			x: -o / 2 - o / 2 * .1,
			y: -u / 2
		},
		{
			x: -o / 2 - o / 2 * .1,
			y: u / 2
		},
		...J7(-o / 2 - o / 2 * .1, u / 2, o / 2 + o / 2 * .1, u / 2, h, .8),
		{
			x: o / 2 + o / 2 * .1,
			y: -u / 2
		},
		{
			x: -o / 2 - o / 2 * .1,
			y: -u / 2
		},
		{
			x: -o / 2,
			y: -u / 2
		},
		{
			x: -o / 2,
			y: u / 2 * 1.1
		},
		{
			x: -o / 2,
			y: -u / 2
		}
	], m = p.polygon(g.map((e) => [e.x, e.y]), f), y = n.insert(() => m, ":first-child");
	return y.attr("class", "basic label-container"), d && "handDrawn" !== t.look && y.selectAll("path").attr("style", d), i && "handDrawn" !== t.look && y.selectAll("path").attr("style", i), y.attr("transform", `translate(0,${-h / 2})`), s.attr("transform", `translate(${-o / 2 + (t.padding ?? 0) + o / 2 * .1 / 2 - (a.x - (a.left ?? 0))},${-l / 2 + (t.padding ?? 0) - h / 2 - (a.y - (a.top ?? 0))})`), J5(t, y), t.intersect = function(e) {
		return etc(t, g, e);
	}, n;
}
async function et0(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a, label: s } = await J2(e, t, J3(t)), o = Math.max(a.width + (t.padding ?? 0) * 2, t?.width ?? 0), l = Math.max(a.height + (t.padding ?? 0) * 2, t?.height ?? 0), h = -o / 2, u = -l / 2, { cssStyles: d } = t, p = ee1.svg(n), f = J0(t, {}), g = [
		{
			x: h - 5,
			y: u + 5
		},
		{
			x: h - 5,
			y: u + l + 5
		},
		{
			x: h + o - 5,
			y: u + l + 5
		},
		{
			x: h + o - 5,
			y: u + l
		},
		{
			x: h + o,
			y: u + l
		},
		{
			x: h + o,
			y: u + l - 5
		},
		{
			x: h + o + 5,
			y: u + l - 5
		},
		{
			x: h + o + 5,
			y: u - 5
		},
		{
			x: h + 5,
			y: u - 5
		},
		{
			x: h + 5,
			y: u
		},
		{
			x: h,
			y: u
		},
		{
			x: h,
			y: u + 5
		}
	], m = [
		{
			x: h,
			y: u + 5
		},
		{
			x: h + o - 5,
			y: u + 5
		},
		{
			x: h + o - 5,
			y: u + l
		},
		{
			x: h + o,
			y: u + l
		},
		{
			x: h + o,
			y: u
		},
		{
			x: h,
			y: u
		}
	];
	"handDrawn" !== t.look && (f.roughness = 0, f.fillStyle = "solid");
	let y = J6(g), v = p.path(y, f), x = J6(m), b = p.path(x, {
		...f,
		fill: "none"
	}), w = n.insert(() => b, ":first-child");
	return w.insert(() => v, ":first-child"), w.attr("class", "basic label-container"), d && "handDrawn" !== t.look && w.selectAll("path").attr("style", d), i && "handDrawn" !== t.look && w.selectAll("path").attr("style", i), s.attr("transform", `translate(${-(a.width / 2) - 5 - (a.x - (a.left ?? 0))}, ${-(a.height / 2) + 5 - (a.y - (a.top ?? 0))})`), J5(t, w), t.intersect = function(e) {
		return etc(t, g, e);
	}, n;
}
async function et1(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a, label: s } = await J2(e, t, J3(t)), o = Math.max(a.width + (t.padding ?? 0) * 2, t?.width ?? 0), l = Math.max(a.height + (t.padding ?? 0) * 2, t?.height ?? 0), h = l / 4, u = l + h, d = -o / 2, p = -u / 2, { cssStyles: f } = t, g = J7(d - 5, p + u + 5, d + o - 5, p + u + 5, h, .8), m = g?.[g.length - 1], y = [
		{
			x: d - 5,
			y: p + 5
		},
		{
			x: d - 5,
			y: p + u + 5
		},
		...g,
		{
			x: d + o - 5,
			y: m.y - 5
		},
		{
			x: d + o,
			y: m.y - 5
		},
		{
			x: d + o,
			y: m.y - 10
		},
		{
			x: d + o + 5,
			y: m.y - 10
		},
		{
			x: d + o + 5,
			y: p - 5
		},
		{
			x: d + 5,
			y: p - 5
		},
		{
			x: d + 5,
			y: p
		},
		{
			x: d,
			y: p
		},
		{
			x: d,
			y: p + 5
		}
	], v = [
		{
			x: d,
			y: p + 5
		},
		{
			x: d + o - 5,
			y: p + 5
		},
		{
			x: d + o - 5,
			y: m.y - 5
		},
		{
			x: d + o,
			y: m.y - 5
		},
		{
			x: d + o,
			y: p
		},
		{
			x: d,
			y: p
		}
	], x = ee1.svg(n), b = J0(t, {});
	"handDrawn" !== t.look && (b.roughness = 0, b.fillStyle = "solid");
	let w = J6(y), k = x.path(w, b), T = J6(v), _ = x.path(T, b), E = n.insert(() => k, ":first-child");
	return E.insert(() => _), E.attr("class", "basic label-container"), f && "handDrawn" !== t.look && E.selectAll("path").attr("style", f), i && "handDrawn" !== t.look && E.selectAll("path").attr("style", i), E.attr("transform", `translate(0,${-h / 2})`), s.attr("transform", `translate(${-(a.width / 2) - 5 - (a.x - (a.left ?? 0))}, ${-(a.height / 2) + 5 - h / 2 - (a.y - (a.top ?? 0))})`), J5(t, E), t.intersect = function(e) {
		return etc(t, y, e);
	}, n;
}
async function et2(e, t, { config: { themeVariables: r } }) {
	let { labelStyles: i, nodeStyles: n } = JJ(t);
	t.labelStyle = i, t.useHtmlLabels || IA().flowchart?.htmlLabels !== !1 || (t.centerLabel = !0);
	let { shapeSvg: a, bbox: s, label: o } = await J2(e, t, J3(t)), l = Math.max(s.width + (t.padding ?? 0) * 2, t?.width ?? 0), h = Math.max(s.height + (t.padding ?? 0) * 2, t?.height ?? 0), { cssStyles: u } = t, d = ee1.svg(a), p = J0(t, {
		fill: r.noteBkgColor,
		stroke: r.noteBorderColor
	});
	"handDrawn" !== t.look && (p.roughness = 0, p.fillStyle = "solid");
	let f = d.rectangle(-l / 2, -h / 2, l, h, p), g = a.insert(() => f, ":first-child");
	return g.attr("class", "basic label-container"), u && "handDrawn" !== t.look && g.selectAll("path").attr("style", u), n && "handDrawn" !== t.look && g.selectAll("path").attr("style", n), o.attr("transform", `translate(${-s.width / 2 - (s.x - (s.left ?? 0))}, ${-(s.height / 2) - (s.y - (s.top ?? 0))})`), J5(t, g), t.intersect = function(e) {
		return ee2(t, e);
	}, a;
}
h(etQ, "linedCylinder"), h(etJ, "linedWaveEdgedRect"), h(et0, "multiRect"), h(et1, "multiWaveEdgedRectangle"), h(et2, "note");
var et4 = h((e, t, r) => `M${e + r / 2},${t} L${e + r},${t - r / 2} L${e + r / 2},${t - r} L${e},${t - r / 2} Z`, "createDecisionBoxPathD");
async function et5(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a } = await J2(e, t, J3(t)), s = a.width + t.padding + (a.height + t.padding), o = [
		{
			x: s / 2,
			y: 0
		},
		{
			x: s,
			y: -s / 2
		},
		{
			x: s / 2,
			y: -s
		},
		{
			x: 0,
			y: -s / 2
		}
	], l, { cssStyles: h } = t;
	if ("handDrawn" === t.look) {
		let e = ee1.svg(n), r = J0(t, {}), i = et4(0, 0, s), a = e.path(i, r);
		l = n.insert(() => a, ":first-child").attr("transform", `translate(${-s / 2 + .5}, ${s / 2})`), h && l.attr("style", h);
	} else (l = etp(n, s, s, o)).attr("transform", `translate(${-s / 2 + .5}, ${s / 2})`);
	return i && l.attr("style", i), J5(t, l), t.calcIntersect = function(e, t) {
		let r = e.width, i = etc(e, [
			{
				x: r / 2,
				y: 0
			},
			{
				x: r,
				y: -r / 2
			},
			{
				x: r / 2,
				y: -r
			},
			{
				x: 0,
				y: -r / 2
			}
		], t);
		return {
			x: i.x - .5,
			y: i.y - .5
		};
	}, t.intersect = function(e) {
		return this.calcIntersect(t, e);
	}, n;
}
async function et3(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a, label: s } = await J2(e, t, J3(t)), o = Math.max(a.width + (t.padding ?? 0), t?.width ?? 0), l = Math.max(a.height + (t.padding ?? 0), t?.height ?? 0), h = -o / 2, u = -l / 2, d = u / 2, p = [
		{
			x: h + d,
			y: u
		},
		{
			x: h,
			y: 0
		},
		{
			x: h + d,
			y: -u
		},
		{
			x: -h,
			y: -u
		},
		{
			x: -h,
			y: u
		}
	], { cssStyles: f } = t, g = ee1.svg(n), m = J0(t, {});
	"handDrawn" !== t.look && (m.roughness = 0, m.fillStyle = "solid");
	let y = J6(p), v = g.path(y, m), x = n.insert(() => v, ":first-child");
	return x.attr("class", "basic label-container"), f && "handDrawn" !== t.look && x.selectAll("path").attr("style", f), i && "handDrawn" !== t.look && x.selectAll("path").attr("style", i), x.attr("transform", `translate(${-d / 2},0)`), s.attr("transform", `translate(${-d / 2 - a.width / 2 - (a.x - (a.left ?? 0))}, ${-(a.height / 2) - (a.y - (a.top ?? 0))})`), J5(t, x), t.intersect = function(e) {
		return etc(t, p, e);
	}, n;
}
async function et6(e, t) {
	let r, { labelStyles: i, nodeStyles: n } = JJ(t);
	t.labelStyle = i, r = t.cssClasses ? "node " + t.cssClasses : "node default";
	let a = e.insert("g").attr("class", r).attr("id", t.domId || t.id), s = a.insert("g"), o = a.insert("g").attr("class", "label").attr("style", n), l = t.description, h = t.label, u = o.node().appendChild(await ee3(h, t.labelStyle, !0, !0)), d = {
		width: 0,
		height: 0
	};
	if (MG(IA()?.flowchart?.htmlLabels)) {
		let e = u.children[0], t = _t(u);
		d = e.getBoundingClientRect(), t.attr("width", d.width), t.attr("height", d.height);
	}
	wQ.info("Text 2", l);
	let p = l || [], f = u.getBBox(), g = o.node().appendChild(await ee3(p.join ? p.join("<br/>") : p, t.labelStyle, !0, !0)), m = g.children[0], y = _t(g);
	d = m.getBoundingClientRect(), y.attr("width", d.width), y.attr("height", d.height);
	let v = (t.padding || 0) / 2;
	_t(g).attr("transform", "translate( " + (d.width > f.width ? 0 : (f.width - d.width) / 2) + ", " + (f.height + v + 5) + ")"), _t(u).attr("transform", "translate( " + (d.width < f.width ? 0 : -(f.width - d.width) / 2) + ", 0)"), d = o.node().getBBox(), o.attr("transform", "translate(" + -d.width / 2 + ", " + (-d.height / 2 - v + 3) + ")");
	let x = d.width + (t.padding || 0), b = d.height + (t.padding || 0), w = -d.width / 2 - v, k = -d.height / 2 - v, T, _;
	if ("handDrawn" === t.look) {
		let e = ee1.svg(a), r = J0(t, {}), i = e.path(ee6(w, k, x, b, t.rx || 0), r), n = e.line(-d.width / 2 - v, -d.height / 2 - v + f.height + v, d.width / 2 + v, -d.height / 2 - v + f.height + v, r);
		_ = a.insert(() => (wQ.debug("Rough node insert CXC", i), n), ":first-child"), T = a.insert(() => (wQ.debug("Rough node insert CXC", i), i), ":first-child");
	} else T = s.insert("rect", ":first-child"), _ = s.insert("line"), T.attr("class", "outer title-state").attr("style", n).attr("x", -d.width / 2 - v).attr("y", -d.height / 2 - v).attr("width", d.width + (t.padding || 0)).attr("height", d.height + (t.padding || 0)), _.attr("class", "divider").attr("x1", -d.width / 2 - v).attr("x2", d.width / 2 + v).attr("y1", -d.height / 2 - v + f.height + v).attr("y2", -d.height / 2 - v + f.height + v);
	return J5(t, T), t.intersect = function(e) {
		return ee2(t, e);
	}, a;
}
function et7(e, t, r, i, n, a, s) {
	let o = Math.atan2(i - t, r - e), l = Math.sqrt(((r - e) / 2 / n) ** 2 + ((i - t) / 2 / a) ** 2);
	if (l > 1) throw Error("The given radii are too small to create an arc between the points.");
	let h = Math.sqrt(1 - l ** 2), u = (e + r) / 2 + h * a * Math.sin(o) * (s ? -1 : 1), d = (t + i) / 2 - h * n * Math.cos(o) * (s ? -1 : 1), p = Math.atan2((t - d) / a, (e - u) / n), f = Math.atan2((i - d) / a, (r - u) / n) - p;
	s && f < 0 && (f += 2 * Math.PI), !s && f > 0 && (f -= 2 * Math.PI);
	let g = [];
	for (let e = 0; e < 20; e++) {
		let t = p + e / 19 * f, r = u + n * Math.cos(t), i = d + a * Math.sin(t);
		g.push({
			x: r,
			y: i
		});
	}
	return g;
}
async function et8(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a } = await J2(e, t, J3(t)), s = t?.padding ?? 0, o = t?.padding ?? 0, l = (t?.width ? t?.width : a.width) + 2 * s, h = (t?.height ? t?.height : a.height) + 2 * o, u = t.radius || 5, d = t.taper || 5, { cssStyles: p } = t, f = ee1.svg(n), g = J0(t, {});
	t.stroke && (g.stroke = t.stroke), "handDrawn" !== t.look && (g.roughness = 0, g.fillStyle = "solid");
	let m = [
		{
			x: -l / 2 + d,
			y: -h / 2
		},
		{
			x: l / 2 - d,
			y: -h / 2
		},
		...et7(l / 2 - d, -h / 2, l / 2, -h / 2 + d, u, u, !0),
		{
			x: l / 2,
			y: -h / 2 + d
		},
		{
			x: l / 2,
			y: h / 2 - d
		},
		...et7(l / 2, h / 2 - d, l / 2 - d, h / 2, u, u, !0),
		{
			x: l / 2 - d,
			y: h / 2
		},
		{
			x: -l / 2 + d,
			y: h / 2
		},
		...et7(-l / 2 + d, h / 2, -l / 2, h / 2 - d, u, u, !0),
		{
			x: -l / 2,
			y: h / 2 - d
		},
		{
			x: -l / 2,
			y: -h / 2 + d
		},
		...et7(-l / 2, -h / 2 + d, -l / 2 + d, -h / 2, u, u, !0)
	], y = J6(m), v = f.path(y, g), x = n.insert(() => v, ":first-child");
	return x.attr("class", "basic label-container outer-path"), p && "handDrawn" !== t.look && x.selectChildren("path").attr("style", p), i && "handDrawn" !== t.look && x.selectChildren("path").attr("style", i), J5(t, x), t.intersect = function(e) {
		return etc(t, m, e);
	}, n;
}
async function et9(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a, label: s } = await J2(e, t, J3(t)), o = t?.padding ?? 0, l = Math.max(a.width + (t.padding ?? 0) * 2, t?.width ?? 0), h = Math.max(a.height + (t.padding ?? 0) * 2, t?.height ?? 0), u = -a.width / 2 - o, d = -a.height / 2 - o, { cssStyles: p } = t, f = ee1.svg(n), g = J0(t, {});
	"handDrawn" !== t.look && (g.roughness = 0, g.fillStyle = "solid");
	let m = f.polygon([
		{
			x: u,
			y: d
		},
		{
			x: u + l + 8,
			y: d
		},
		{
			x: u + l + 8,
			y: d + h
		},
		{
			x: u - 8,
			y: d + h
		},
		{
			x: u - 8,
			y: d
		},
		{
			x: u,
			y: d
		},
		{
			x: u,
			y: d + h
		}
	].map((e) => [e.x, e.y]), g), y = n.insert(() => m, ":first-child");
	return y.attr("class", "basic label-container").attr("style", V8(p)), i && "handDrawn" !== t.look && y.selectAll("path").attr("style", i), p && "handDrawn" !== t.look && y.selectAll("path").attr("style", i), s.attr("transform", `translate(${-l / 2 + 4 + (t.padding ?? 0) - (a.x - (a.left ?? 0))},${-h / 2 + (t.padding ?? 0) - (a.y - (a.top ?? 0))})`), J5(t, y), t.intersect = function(e) {
		return ee2(t, e);
	}, n;
}
async function ere(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a, label: s } = await J2(e, t, J3(t)), o = Math.max(a.width + (t.padding ?? 0) * 2, t?.width ?? 0), l = Math.max(a.height + (t.padding ?? 0) * 2, t?.height ?? 0), h = -o / 2, u = -l / 2, { cssStyles: d } = t, p = ee1.svg(n), f = J0(t, {});
	"handDrawn" !== t.look && (f.roughness = 0, f.fillStyle = "solid");
	let g = [
		{
			x: h,
			y: u
		},
		{
			x: h,
			y: u + l
		},
		{
			x: h + o,
			y: u + l
		},
		{
			x: h + o,
			y: u - l / 2
		}
	], m = J6(g), y = p.path(m, f), v = n.insert(() => y, ":first-child");
	return v.attr("class", "basic label-container"), d && "handDrawn" !== t.look && v.selectChildren("path").attr("style", d), i && "handDrawn" !== t.look && v.selectChildren("path").attr("style", i), v.attr("transform", `translate(0, ${l / 4})`), s.attr("transform", `translate(${-o / 2 + (t.padding ?? 0) - (a.x - (a.left ?? 0))}, ${-l / 4 + (t.padding ?? 0) - (a.y - (a.top ?? 0))})`), J5(t, v), t.intersect = function(e) {
		return etc(t, g, e);
	}, n;
}
async function ert(e, t) {
	return etj(e, t, {
		rx: 0,
		ry: 0,
		classes: "",
		labelPaddingX: t.labelPaddingX ?? 2 * (t?.padding || 0),
		labelPaddingY: +(t?.padding || 0)
	});
}
async function err(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a } = await J2(e, t, J3(t)), s = a.height + t.padding, o = a.width + s / 4 + t.padding, l = s / 2, { cssStyles: h } = t, u = ee1.svg(n), d = J0(t, {});
	"handDrawn" !== t.look && (d.roughness = 0, d.fillStyle = "solid");
	let p = [
		{
			x: -o / 2 + l,
			y: -s / 2
		},
		{
			x: o / 2 - l,
			y: -s / 2
		},
		...J8(-o / 2 + l, 0, l, 50, 90, 270),
		{
			x: o / 2 - l,
			y: s / 2
		},
		...J8(o / 2 - l, 0, l, 50, 270, 450)
	], f = J6(p), g = u.path(f, d), m = n.insert(() => g, ":first-child");
	return m.attr("class", "basic label-container outer-path"), h && "handDrawn" !== t.look && m.selectChildren("path").attr("style", h), i && "handDrawn" !== t.look && m.selectChildren("path").attr("style", i), J5(t, m), t.intersect = function(e) {
		return etc(t, p, e);
	}, n;
}
async function eri(e, t) {
	return etj(e, t, {
		rx: 5,
		ry: 5,
		classes: "flowchart-node"
	});
}
function ern(e, t, { config: { themeVariables: r } }) {
	let { labelStyles: i, nodeStyles: n } = JJ(t);
	t.labelStyle = i;
	let { cssStyles: a } = t, { lineColor: s, stateBorder: o, nodeBorder: l } = r, h = e.insert("g").attr("class", "node default").attr("id", t.domId || t.id), u = ee1.svg(h), d = J0(t, {});
	"handDrawn" !== t.look && (d.roughness = 0, d.fillStyle = "solid");
	let p = u.circle(0, 0, 14, {
		...d,
		stroke: s,
		strokeWidth: 2
	}), f = o ?? l, g = u.circle(0, 0, 5, {
		...d,
		fill: f,
		stroke: f,
		strokeWidth: 2,
		fillStyle: "solid"
	}), m = h.insert(() => p, ":first-child");
	return m.insert(() => g), a && m.selectAll("path").attr("style", a), n && m.selectAll("path").attr("style", n), J5(t, m), t.intersect = function(e) {
		return ets(t, 7, e);
	}, h;
}
function era(e, t, { config: { themeVariables: r } }) {
	let { lineColor: i } = r, n = e.insert("g").attr("class", "node default").attr("id", t.domId || t.id), a;
	if ("handDrawn" === t.look) {
		let e = ee1.svg(n).circle(0, 0, 14, JX(i));
		(a = n.insert(() => e)).attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14);
	} else (a = n.insert("circle", ":first-child")).attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14);
	return J5(t, a), t.intersect = function(e) {
		return ets(t, 7, e);
	}, n;
}
async function ers(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a } = await J2(e, t, J3(t)), s = (t?.padding || 0) / 2, o = a.width + t.padding, l = a.height + t.padding, h = -a.width / 2 - s, u = -a.height / 2 - s, d = [
		{
			x: 0,
			y: 0
		},
		{
			x: o,
			y: 0
		},
		{
			x: o,
			y: -l
		},
		{
			x: 0,
			y: -l
		},
		{
			x: 0,
			y: 0
		},
		{
			x: -8,
			y: 0
		},
		{
			x: o + 8,
			y: 0
		},
		{
			x: o + 8,
			y: -l
		},
		{
			x: -8,
			y: -l
		},
		{
			x: -8,
			y: 0
		}
	];
	if ("handDrawn" === t.look) {
		let e = ee1.svg(n), r = J0(t, {}), i = e.rectangle(h - 8, u, o + 16, l, r), a = e.line(h, u, h, u + l, r), s = e.line(h + o, u, h + o, u + l, r);
		n.insert(() => a, ":first-child"), n.insert(() => s, ":first-child");
		let d = n.insert(() => i, ":first-child"), { cssStyles: p } = t;
		d.attr("class", "basic label-container").attr("style", V8(p)), J5(t, d);
	} else {
		let e = etp(n, o, l, d);
		i && e.attr("style", i), J5(t, e);
	}
	return t.intersect = function(e) {
		return etc(t, d, e);
	}, n;
}
async function ero(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a } = await J2(e, t, J3(t)), s = Math.max(a.width + (t.padding ?? 0) * 2, t?.width ?? 0), o = Math.max(a.height + (t.padding ?? 0) * 2, t?.height ?? 0), l = -s / 2, h = -o / 2, u = .2 * o, { cssStyles: d } = t, p = ee1.svg(n), f = J0(t, {}), g = [
		{
			x: l - u / 2,
			y: h
		},
		{
			x: l + s + u / 2,
			y: h
		},
		{
			x: l + s + u / 2,
			y: h + o
		},
		{
			x: l - u / 2,
			y: h + o
		}
	];
	"handDrawn" !== t.look && (f.roughness = 0, f.fillStyle = "solid");
	let m = J6(g), y = p.path(m, f), v = J6([
		{
			x: l + s - u / 2,
			y: h + o
		},
		{
			x: l + s + u / 2,
			y: h + o
		},
		{
			x: l + s + u / 2,
			y: h + o - .2 * o
		}
	]), x = p.path(v, {
		...f,
		fillStyle: "solid"
	}), b = n.insert(() => x, ":first-child");
	return b.insert(() => y, ":first-child"), b.attr("class", "basic label-container"), d && "handDrawn" !== t.look && b.selectAll("path").attr("style", d), i && "handDrawn" !== t.look && b.selectAll("path").attr("style", i), J5(t, b), t.intersect = function(e) {
		return etc(t, g, e);
	}, n;
}
async function erl(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a, label: s } = await J2(e, t, J3(t)), o = Math.max(a.width + (t.padding ?? 0) * 2, t?.width ?? 0), l = Math.max(a.height + (t.padding ?? 0) * 2, t?.height ?? 0), h = l / 4, u = .2 * o, d = .2 * l, p = l + h, { cssStyles: f } = t, g = ee1.svg(n), m = J0(t, {});
	"handDrawn" !== t.look && (m.roughness = 0, m.fillStyle = "solid");
	let y = [
		{
			x: -o / 2 - o / 2 * .1,
			y: p / 2
		},
		...J7(-o / 2 - o / 2 * .1, p / 2, o / 2 + o / 2 * .1, p / 2, h, .8),
		{
			x: o / 2 + o / 2 * .1,
			y: -p / 2
		},
		{
			x: -o / 2 - o / 2 * .1,
			y: -p / 2
		}
	], v = -o / 2 + o / 2 * .1, x = -p / 2 - .4 * d, b = [
		{
			x: v + o - u,
			y: (x + l) * 1.4
		},
		{
			x: v + o,
			y: x + l - d
		},
		{
			x: v + o,
			y: (x + l) * .9
		},
		...J7(v + o, (x + l) * 1.3, v + o - u, (x + l) * 1.5, -(.03 * l), .5)
	], w = J6(y), k = g.path(w, m), T = J6(b), _ = g.path(T, {
		...m,
		fillStyle: "solid"
	}), E = n.insert(() => _, ":first-child");
	return E.insert(() => k, ":first-child"), E.attr("class", "basic label-container"), f && "handDrawn" !== t.look && E.selectAll("path").attr("style", f), i && "handDrawn" !== t.look && E.selectAll("path").attr("style", i), E.attr("transform", `translate(0,${-h / 2})`), s.attr("transform", `translate(${-o / 2 + (t.padding ?? 0) - (a.x - (a.left ?? 0))},${-l / 2 + (t.padding ?? 0) - h / 2 - (a.y - (a.top ?? 0))})`), J5(t, E), t.intersect = function(e) {
		return etc(t, y, e);
	}, n;
}
async function erc(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a } = await J2(e, t, J3(t)), s = Math.max(a.width + t.padding, t?.width || 0), o = Math.max(a.height + t.padding, t?.height || 0), l = n.insert("rect", ":first-child");
	return l.attr("class", "text").attr("style", i).attr("rx", 0).attr("ry", 0).attr("x", -s / 2).attr("y", -o / 2).attr("width", s).attr("height", o), J5(t, l), t.intersect = function(e) {
		return ee2(t, e);
	}, n;
}
h(et5, "question"), h(et3, "rect_left_inv_arrow"), h(et6, "rectWithTitle"), h(et7, "generateArcPoints"), h(et8, "roundedRect"), h(et9, "shadedProcess"), h(ere, "slopedRect"), h(ert, "squareRect"), h(err, "stadium"), h(eri, "state"), h(ern, "stateEnd"), h(era, "stateStart"), h(ers, "subroutine"), h(ero, "taggedRect"), h(erl, "taggedWaveEdgedRectangle"), h(erc, "text");
var erh = h((e, t, r, i, n, a) => `M${e},${t}
    a${n},${a} 0,0,1 0,${-i}
    l${r},0
    a${n},${a} 0,0,1 0,${i}
    M${r},${-i}
    a${n},${a} 0,0,0 0,${i}
    l${-r},0`, "createCylinderPathD"), eru = h((e, t, r, i, n, a) => `M${e},${t} M${e + r},${t} a${n},${a} 0,0,0 0,${-i} l${-r},0 a${n},${a} 0,0,0 0,${i} l${r},0`, "createOuterCylinderPathD"), erd = h((e, t, r, i, n, a) => `M${e + r / 2},${-i / 2} a${n},${a} 0,0,0 0,${i}`, "createInnerCylinderPathD");
async function erp(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a, label: s, halfPadding: o } = await J2(e, t, J3(t)), l = "neo" === t.look ? 2 * o : o, h = a.height + l, u = h / 2, d = u / (2.5 + h / 50), p = a.width + d + l, { cssStyles: f } = t, g;
	if ("handDrawn" === t.look) {
		let e = ee1.svg(n), r = eru(0, 0, p, h, d, u), i = erd(0, 0, p, h, d, u), a = e.path(r, J0(t, {})), s = e.path(i, J0(t, { fill: "none" }));
		g = n.insert(() => s, ":first-child"), (g = n.insert(() => a, ":first-child")).attr("class", "basic label-container"), f && g.attr("style", f);
	} else {
		let e = erh(0, 0, p, h, d, u);
		(g = n.insert("path", ":first-child").attr("d", e).attr("class", "basic label-container").attr("style", V8(f)).attr("style", i)).attr("class", "basic label-container"), f && g.selectAll("path").attr("style", f), i && g.selectAll("path").attr("style", i);
	}
	return g.attr("label-offset-x", d), g.attr("transform", `translate(${-p / 2}, ${h / 2} )`), s.attr("transform", `translate(${-(a.width / 2) - d - (a.x - (a.left ?? 0))}, ${-(a.height / 2) - (a.y - (a.top ?? 0))})`), J5(t, g), t.intersect = function(e) {
		let r = ee2(t, e), i = r.y - (t.y ?? 0);
		if (0 != u && (Math.abs(i) < (t.height ?? 0) / 2 || Math.abs(i) == (t.height ?? 0) / 2 && Math.abs(r.x - (t.x ?? 0)) > (t.width ?? 0) / 2 - d)) {
			let n = d * d * (1 - i * i / (u * u));
			0 != n && (n = Math.sqrt(Math.abs(n))), n = d - n, e.x - (t.x ?? 0) > 0 && (n = -n), r.x += n;
		}
		return r;
	}, n;
}
async function erf(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a } = await J2(e, t, J3(t)), s = a.width + t.padding, o = a.height + t.padding, l = [
		{
			x: -3 * o / 6,
			y: 0
		},
		{
			x: s + 3 * o / 6,
			y: 0
		},
		{
			x: s,
			y: -o
		},
		{
			x: 0,
			y: -o
		}
	], h, { cssStyles: u } = t;
	if ("handDrawn" === t.look) {
		let e = ee1.svg(n), r = J0(t, {}), i = J6(l), a = e.path(i, r);
		h = n.insert(() => a, ":first-child").attr("transform", `translate(${-s / 2}, ${o / 2})`), u && h.attr("style", u);
	} else h = etp(n, s, o, l);
	return i && h.attr("style", i), t.width = s, t.height = o, J5(t, h), t.intersect = function(e) {
		return etc(t, l, e);
	}, n;
}
async function erg(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a } = await J2(e, t, J3(t)), s = Math.max(60, a.width + (t.padding ?? 0) * 2, t?.width ?? 0), o = Math.max(20, a.height + (t.padding ?? 0) * 2, t?.height ?? 0), { cssStyles: l } = t, h = ee1.svg(n), u = J0(t, {});
	"handDrawn" !== t.look && (u.roughness = 0, u.fillStyle = "solid");
	let d = [
		{
			x: -s / 2 * .8,
			y: -o / 2
		},
		{
			x: s / 2 * .8,
			y: -o / 2
		},
		{
			x: s / 2,
			y: -o / 2 * .6
		},
		{
			x: s / 2,
			y: o / 2
		},
		{
			x: -s / 2,
			y: o / 2
		},
		{
			x: -s / 2,
			y: -o / 2 * .6
		}
	], p = J6(d), f = h.path(p, u), g = n.insert(() => f, ":first-child");
	return g.attr("class", "basic label-container"), l && "handDrawn" !== t.look && g.selectChildren("path").attr("style", l), i && "handDrawn" !== t.look && g.selectChildren("path").attr("style", i), J5(t, g), t.intersect = function(e) {
		return etc(t, d, e);
	}, n;
}
async function erm(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a, label: s } = await J2(e, t, J3(t)), o = MG(IA().flowchart?.htmlLabels), l = a.width + (t.padding ?? 0), h = l + a.height, u = l + a.height, d = [
		{
			x: 0,
			y: 0
		},
		{
			x: u,
			y: 0
		},
		{
			x: u / 2,
			y: -h
		}
	], { cssStyles: p } = t, f = ee1.svg(n), g = J0(t, {});
	"handDrawn" !== t.look && (g.roughness = 0, g.fillStyle = "solid");
	let m = J6(d), y = f.path(m, g), v = n.insert(() => y, ":first-child").attr("transform", `translate(${-h / 2}, ${h / 2})`);
	return p && "handDrawn" !== t.look && v.selectChildren("path").attr("style", p), i && "handDrawn" !== t.look && v.selectChildren("path").attr("style", i), t.width = l, t.height = h, J5(t, v), s.attr("transform", `translate(${-a.width / 2 - (a.x - (a.left ?? 0))}, ${h / 2 - (a.height + (t.padding ?? 0) / (o ? 2 : 1) - (a.y - (a.top ?? 0)))})`), t.intersect = function(e) {
		return wQ.info("Triangle intersect", t, d, e), etc(t, d, e);
	}, n;
}
async function ery(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a, label: s } = await J2(e, t, J3(t)), o = Math.max(a.width + (t.padding ?? 0) * 2, t?.width ?? 0), l = Math.max(a.height + (t.padding ?? 0) * 2, t?.height ?? 0), h = l / 8, u = l + h, { cssStyles: d } = t, p = 70 - o, f = p > 0 ? p / 2 : 0, g = ee1.svg(n), m = J0(t, {});
	"handDrawn" !== t.look && (m.roughness = 0, m.fillStyle = "solid");
	let y = [
		{
			x: -o / 2 - f,
			y: u / 2
		},
		...J7(-o / 2 - f, u / 2, o / 2 + f, u / 2, h, .8),
		{
			x: o / 2 + f,
			y: -u / 2
		},
		{
			x: -o / 2 - f,
			y: -u / 2
		}
	], v = J6(y), x = g.path(v, m), b = n.insert(() => x, ":first-child");
	return b.attr("class", "basic label-container"), d && "handDrawn" !== t.look && b.selectAll("path").attr("style", d), i && "handDrawn" !== t.look && b.selectAll("path").attr("style", i), b.attr("transform", `translate(0,${-h / 2})`), s.attr("transform", `translate(${-o / 2 + (t.padding ?? 0) - (a.x - (a.left ?? 0))},${-l / 2 + (t.padding ?? 0) - h - (a.y - (a.top ?? 0))})`), J5(t, b), t.intersect = function(e) {
		return etc(t, y, e);
	}, n;
}
async function erv(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a } = await J2(e, t, J3(t)), s = Math.max(a.width + (t.padding ?? 0) * 2, t?.width ?? 0), o = Math.max(a.height + (t.padding ?? 0) * 2, t?.height ?? 0), l = s / o, h = s, u = o;
	h > u * l ? u = h / l : h = u * l, h = Math.max(h, 100);
	let d = Math.min(.2 * (u = Math.max(u, 50)), u / 4), p = u + 2 * d, { cssStyles: f } = t, g = ee1.svg(n), m = J0(t, {});
	"handDrawn" !== t.look && (m.roughness = 0, m.fillStyle = "solid");
	let y = [
		{
			x: -h / 2,
			y: p / 2
		},
		...J7(-h / 2, p / 2, h / 2, p / 2, d, 1),
		{
			x: h / 2,
			y: -p / 2
		},
		...J7(h / 2, -p / 2, -h / 2, -p / 2, d, -1)
	], v = J6(y), x = g.path(v, m), b = n.insert(() => x, ":first-child");
	return b.attr("class", "basic label-container"), f && "handDrawn" !== t.look && b.selectAll("path").attr("style", f), i && "handDrawn" !== t.look && b.selectAll("path").attr("style", i), J5(t, b), t.intersect = function(e) {
		return etc(t, y, e);
	}, n;
}
async function erx(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a, label: s } = await J2(e, t, J3(t)), o = Math.max(a.width + (t.padding ?? 0) * 2, t?.width ?? 0), l = Math.max(a.height + (t.padding ?? 0) * 2, t?.height ?? 0), h = -o / 2, u = -l / 2, { cssStyles: d } = t, p = ee1.svg(n), f = J0(t, {}), g = [
		{
			x: h - 5,
			y: u - 5
		},
		{
			x: h - 5,
			y: u + l
		},
		{
			x: h + o,
			y: u + l
		},
		{
			x: h + o,
			y: u - 5
		}
	], m = `M${h - 5},${u - 5} L${h + o},${u - 5} L${h + o},${u + l} L${h - 5},${u + l} L${h - 5},${u - 5}
                M${h - 5},${u} L${h + o},${u}
                M${h},${u - 5} L${h},${u + l}`;
	"handDrawn" !== t.look && (f.roughness = 0, f.fillStyle = "solid");
	let y = p.path(m, f), v = n.insert(() => y, ":first-child");
	return v.attr("transform", "translate(2.5, 2.5)"), v.attr("class", "basic label-container"), d && "handDrawn" !== t.look && v.selectAll("path").attr("style", d), i && "handDrawn" !== t.look && v.selectAll("path").attr("style", i), s.attr("transform", `translate(${-(a.width / 2) + 2.5 - (a.x - (a.left ?? 0))}, ${-(a.height / 2) + 2.5 - (a.y - (a.top ?? 0))})`), J5(t, v), t.intersect = function(e) {
		return etc(t, g, e);
	}, n;
}
async function erb(e, t) {
	if (t.alias && (t.label = t.alias), "handDrawn" === t.look) {
		let { themeVariables: r } = IA(), { background: i } = r;
		await erb(e, {
			...t,
			id: t.id + "-background",
			look: "default",
			cssStyles: ["stroke: none", `fill: ${i}`]
		});
	}
	let r = IA();
	t.useHtmlLabels = r.htmlLabels;
	let i = r.er?.diagramPadding ?? 10, n = r.er?.entityPadding ?? 6, { cssStyles: a } = t, { labelStyles: s, nodeStyles: o } = JJ(t);
	if (0 === t.attributes.length && t.label) {
		let n = {
			rx: 0,
			ry: 0,
			labelPaddingX: i,
			labelPaddingY: 1.5 * i,
			classes: ""
		};
		VH(t.label, r) + 2 * n.labelPaddingX < r.er.minEntityWidth && (t.width = r.er.minEntityWidth);
		let a = await etj(e, t, n);
		if (!MG(r.htmlLabels)) {
			let e = a.select("text"), t = e.node()?.getBBox();
			e.attr("transform", `translate(${-t.width / 2}, 0)`);
		}
		return a;
	}
	r.htmlLabels || (i *= 1.25, n *= 1.25);
	let l = J3(t);
	l || (l = "node default");
	let h = e.insert("g").attr("class", l).attr("id", t.domId || t.id), u = await erw(h, t.label ?? "", r, 0, 0, ["name"], s);
	u.height += n;
	let d = 0, p = [], f = [], g = 0, m = 0, y = 0, v = 0, x = !0, b = !0;
	for (let e of t.attributes) {
		let t = await erw(h, e.type, r, 0, d, ["attribute-type"], s);
		g = Math.max(g, t.width + i);
		let a = await erw(h, e.name, r, 0, d, ["attribute-name"], s);
		m = Math.max(m, a.width + i);
		let o = await erw(h, e.keys.join(), r, 0, d, ["attribute-keys"], s);
		y = Math.max(y, o.width + i);
		let l = await erw(h, e.comment, r, 0, d, ["attribute-comment"], s);
		v = Math.max(v, l.width + i);
		let u = Math.max(t.height, a.height, o.height, l.height) + n;
		f.push({
			yOffset: d,
			rowHeight: u
		}), d += u;
	}
	let w = 4;
	y <= i && (x = !1, y = 0, w--), v <= i && (b = !1, v = 0, w--);
	let k = h.node().getBBox();
	if (u.width + 2 * i - (g + m + y + v) > 0) {
		let e = u.width + 2 * i - (g + m + y + v);
		g += e / w, m += e / w, y > 0 && (y += e / w), v > 0 && (v += e / w);
	}
	let T = g + m + y + v, _ = ee1.svg(h), E = J0(t, {});
	"handDrawn" !== t.look && (E.roughness = 0, E.fillStyle = "solid");
	let C = 0;
	f.length > 0 && (C = f.reduce((e, t) => e + (t?.rowHeight ?? 0), 0));
	let S = Math.max(k.width + 2 * i, t?.width || 0, T), A = Math.max((C ?? 0) + u.height, t?.height || 0), L = -S / 2, R = -A / 2;
	h.selectAll("g:not(:first-child)").each((e, t, r) => {
		let a = _t(r[t]), s = a.attr("transform"), o = 0, l = 0;
		if (s) {
			let e = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(s);
			e && (o = parseFloat(e[1]), l = parseFloat(e[2]), a.attr("class").includes("attribute-name") ? o += g : a.attr("class").includes("attribute-keys") ? o += g + m : a.attr("class").includes("attribute-comment") && (o += g + m + y));
		}
		a.attr("transform", `translate(${L + i / 2 + o}, ${l + R + u.height + n / 2})`);
	}), h.select(".name").attr("transform", "translate(" + -u.width / 2 + ", " + (R + n / 2) + ")");
	let N = _.rectangle(L, R, S, A, E), I = h.insert(() => N, ":first-child").attr("style", a.join("")), { themeVariables: M } = IA(), { rowEven: D, rowOdd: O, nodeBorder: $ } = M;
	for (let [e, t] of (p.push(0), f.entries())) {
		let r = (e + 1) % 2 == 0 && 0 !== t.yOffset, i = _.rectangle(L, u.height + R + t?.yOffset, S, t?.rowHeight, {
			...E,
			fill: r ? D : O,
			stroke: $
		});
		h.insert(() => i, "g.label").attr("style", a.join("")).attr("class", `row-rect-${r ? "even" : "odd"}`);
	}
	let P = _.line(L, u.height + R, S + L, u.height + R, E);
	for (let e of (h.insert(() => P).attr("class", "divider"), P = _.line(g + L, u.height + R, g + L, A + R, E), h.insert(() => P).attr("class", "divider"), x && (P = _.line(g + m + L, u.height + R, g + m + L, A + R, E), h.insert(() => P).attr("class", "divider")), b && (P = _.line(g + m + y + L, u.height + R, g + m + y + L, A + R, E), h.insert(() => P).attr("class", "divider")), p)) P = _.line(L, u.height + R + e, S + L, u.height + R + e, E), h.insert(() => P).attr("class", "divider");
	if (J5(t, I), o && "handDrawn" !== t.look) {
		let e = o.split(";")?.filter((e) => e.includes("stroke"))?.map((e) => `${e}`).join("; ");
		h.selectAll("path").attr("style", e ?? ""), h.selectAll(".row-rect-even path").attr("style", o);
	}
	return t.intersect = function(e) {
		return ee2(t, e);
	}, h;
}
async function erw(e, t, r, i = 0, n = 0, a = [], s = "") {
	let o = e.insert("g").attr("class", `label ${a.join(" ")}`).attr("transform", `translate(${i}, ${n})`).attr("style", s);
	t !== MW(t) && (t = (t = MW(t)).replaceAll("<", "&lt;").replaceAll(">", "&gt;"));
	let l = o.node().appendChild(await XQ(o, t, {
		width: VH(t, r) + 100,
		style: s,
		useHtmlLabels: r.htmlLabels
	}, r));
	if (t.includes("&lt;") || t.includes("&gt;")) {
		let e = l.children[0];
		for (e.textContent = e.textContent.replaceAll("&lt;", "<").replaceAll("&gt;", ">"); e.childNodes[0];) (e = e.childNodes[0]).textContent = e.textContent.replaceAll("&lt;", "<").replaceAll("&gt;", ">");
	}
	let h = l.getBBox();
	if (MG(r.htmlLabels)) {
		let e = l.children[0];
		e.style.textAlign = "start";
		let t = _t(l);
		h = e.getBoundingClientRect(), t.attr("width", h.width), t.attr("height", h.height);
	}
	return h;
}
async function erk(e, t, r, i, n = r.class.padding ?? 12) {
	let a = 3 * !i, s = e.insert("g").attr("class", J3(t)).attr("id", t.domId || t.id), o = null, l = null, h = null, u = null, d = 0, p = 0, f = 0;
	if (o = s.insert("g").attr("class", "annotation-group text"), t.annotations.length > 0) {
		let e = t.annotations[0];
		await erT(o, { text: `\xab${e}\xbb` }, 0), d = o.node().getBBox().height;
	}
	l = s.insert("g").attr("class", "label-group text"), await erT(l, t, 0, ["font-weight: bolder"]);
	let g = l.node().getBBox();
	p = g.height, h = s.insert("g").attr("class", "members-group text");
	let m = 0;
	for (let e of t.members) {
		let t = await erT(h, e, m, [e.parseClassifier()]);
		m += t + a;
	}
	(f = h.node().getBBox().height) <= 0 && (f = n / 2), u = s.insert("g").attr("class", "methods-group text");
	let y = 0;
	for (let e of t.methods) {
		let t = await erT(u, e, y, [e.parseClassifier()]);
		y += t + a;
	}
	let v = s.node().getBBox();
	if (null !== o) {
		let e = o.node().getBBox();
		o.attr("transform", `translate(${-e.width / 2})`);
	}
	return l.attr("transform", `translate(${-g.width / 2}, ${d})`), v = s.node().getBBox(), h.attr("transform", `translate(0, ${d + p + 2 * n})`), v = s.node().getBBox(), u.attr("transform", `translate(0, ${d + p + (f ? f + 4 * n : 2 * n)})`), v = s.node().getBBox(), {
		shapeSvg: s,
		bbox: v
	};
}
async function erT(e, t, r, i = []) {
	let n = e.insert("g").attr("class", "label").attr("style", i.join("; ")), a = IA(), s = "useHtmlLabels" in t ? t.useHtmlLabels : MG(a.htmlLabels) ?? !0, o = "";
	o = "text" in t ? t.text : t.label, !s && o.startsWith("\\") && (o = o.substring(1)), MZ(o) && (s = !0);
	let l = await XQ(n, Du(V6(o)), {
		width: VH(o, a) + 50,
		classes: "markdown-node-label",
		useHtmlLabels: s
	}, a), u, d = 1;
	if (s) {
		let e = l.children[0], t = _t(l);
		d = e.innerHTML.split("<br>").length, e.innerHTML.includes("</math>") && (d += e.innerHTML.split("<mrow>").length - 1);
		let r = e.getElementsByTagName("img");
		if (r) {
			let e = "" === o.replace(/<img[^>]*>/g, "").trim();
			await Promise.all([...r].map((t) => new Promise((r) => {
				function i() {
					if (t.style.display = "flex", t.style.flexDirection = "column", e) {
						let e = 5 * parseInt(a.fontSize?.toString() ?? window.getComputedStyle(document.body).fontSize, 10) + "px";
						t.style.minWidth = e, t.style.maxWidth = e;
					} else t.style.width = "100%";
					r(t);
				}
				h(i, "setupImage"), setTimeout(() => {
					t.complete && i();
				}), t.addEventListener("error", i), t.addEventListener("load", i);
			})));
		}
		u = e.getBoundingClientRect(), t.attr("width", u.width), t.attr("height", u.height);
	} else {
		i.includes("font-weight: bolder") && _t(l).selectAll("tspan").attr("font-weight", ""), d = l.children.length;
		let e = l.children[0];
		("" === l.textContent || l.textContent.includes("&gt")) && (e.textContent = o[0] + o.substring(1).replaceAll("&gt;", ">").replaceAll("&lt;", "<").trim(), " " === o[1] && (e.textContent = e.textContent[0] + " " + e.textContent.substring(1))), "undefined" === e.textContent && (e.textContent = ""), u = l.getBBox();
	}
	return n.attr("transform", "translate(0," + (-u.height / (2 * d) + r) + ")"), u.height;
}
async function er_(e, t) {
	let r = IA(), i = r.class.padding ?? 12, n = t.useHtmlLabels ?? MG(r.htmlLabels) ?? !0;
	t.annotations = t.annotations ?? [], t.members = t.members ?? [], t.methods = t.methods ?? [];
	let { shapeSvg: a, bbox: s } = await erk(e, t, r, n, i), { labelStyles: o, nodeStyles: l } = JJ(t);
	t.labelStyle = o, t.cssStyles = t.styles || "";
	let h = t.styles?.join(";") || l || "";
	t.cssStyles || (t.cssStyles = h.replaceAll("!important", "").split(";"));
	let u = 0 === t.members.length && 0 === t.methods.length && !r.class?.hideEmptyMembersBox, d = ee1.svg(a), p = J0(t, {});
	"handDrawn" !== t.look && (p.roughness = 0, p.fillStyle = "solid");
	let f = s.width, g = s.height;
	0 === t.members.length && 0 === t.methods.length ? g += i : t.members.length > 0 && 0 === t.methods.length && (g += 2 * i);
	let m = -f / 2, y = -g / 2, v = d.rectangle(m - i, y - i - (u ? i : 0 === t.members.length && 0 === t.methods.length ? -i / 2 : 0), f + 2 * i, g + 2 * i + (u ? 2 * i : 0 === t.members.length && 0 === t.methods.length ? -i : 0), p), x = a.insert(() => v, ":first-child");
	x.attr("class", "basic label-container");
	let b = x.node().getBBox();
	a.selectAll(".text").each((e, r, s) => {
		let o = _t(s[r]), l = o.attr("transform"), h = 0;
		if (l) {
			let e = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(l);
			e && (h = parseFloat(e[2]));
		}
		let d = h + y + i - (u ? i : 0 === t.members.length && 0 === t.methods.length ? -i / 2 : 0);
		n || (d -= 4);
		let p = m;
		(o.attr("class").includes("label-group") || o.attr("class").includes("annotation-group")) && (p = -o.node()?.getBBox().width / 2 || 0, a.selectAll("text").each(function(e, t, r) {
			"middle" === window.getComputedStyle(r[t]).textAnchor && (p = 0);
		})), o.attr("transform", `translate(${p}, ${d})`);
	});
	let w = a.select(".annotation-group").node().getBBox().height - (u ? i / 2 : 0) || 0, k = a.select(".label-group").node().getBBox().height - (u ? i / 2 : 0) || 0, T = a.select(".members-group").node().getBBox().height - (u ? i / 2 : 0) || 0;
	if (t.members.length > 0 || t.methods.length > 0 || u) {
		let e = d.line(b.x, w + k + y + i, b.x + b.width, w + k + y + i, p);
		a.insert(() => e).attr("class", "divider").attr("style", h);
	}
	if (u || t.members.length > 0 || t.methods.length > 0) {
		let e = d.line(b.x, w + k + T + y + 2 * i + i, b.x + b.width, w + k + T + y + i + 2 * i, p);
		a.insert(() => e).attr("class", "divider").attr("style", h);
	}
	if ("handDrawn" !== t.look && a.selectAll("path").attr("style", h), x.select(":nth-child(2)").attr("style", h), a.selectAll(".divider").select("path").attr("style", h), t.labelStyle ? a.selectAll("span").attr("style", t.labelStyle) : a.selectAll("span").attr("style", h), !n) {
		let e = RegExp(/color\s*:\s*([^;]*)/), t = e.exec(h);
		if (t) {
			let e = t[0].replace("color", "fill");
			a.selectAll("tspan").attr("style", e);
		} else if (o) {
			let t = e.exec(o);
			if (t) {
				let e = t[0].replace("color", "fill");
				a.selectAll("tspan").attr("style", e);
			}
		}
	}
	return J5(t, x), t.intersect = function(e) {
		return ee2(t, e);
	}, a;
}
async function erE(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let n = "verifyMethod" in t, a = J3(t), s = e.insert("g").attr("class", a).attr("id", t.domId ?? t.id), o, l = o = n ? await erC(s, `&lt;&lt;${t.type}&gt;&gt;`, 0, t.labelStyle) : await erC(s, "&lt;&lt;Element&gt;&gt;", 0, t.labelStyle), h = await erC(s, t.name, l, t.labelStyle + "; font-weight: bold;");
	if (l += h + 20, n) {
		let e = await erC(s, `${t.requirementId ? `ID: ${t.requirementId}` : ""}`, l, t.labelStyle);
		l += e;
		let r = await erC(s, `${t.text ? `Text: ${t.text}` : ""}`, l, t.labelStyle);
		l += r;
		let i = await erC(s, `${t.risk ? `Risk: ${t.risk}` : ""}`, l, t.labelStyle);
		l += i, await erC(s, `${t.verifyMethod ? `Verification: ${t.verifyMethod}` : ""}`, l, t.labelStyle);
	} else {
		let e = await erC(s, `${t.type ? `Type: ${t.type}` : ""}`, l, t.labelStyle);
		l += e, await erC(s, `${t.docRef ? `Doc Ref: ${t.docRef}` : ""}`, l, t.labelStyle);
	}
	let u = (s.node()?.getBBox().width ?? 200) + 20, d = (s.node()?.getBBox().height ?? 200) + 20, p = -u / 2, f = -d / 2, g = ee1.svg(s), m = J0(t, {});
	"handDrawn" !== t.look && (m.roughness = 0, m.fillStyle = "solid");
	let y = g.rectangle(p, f, u, d, m), v = s.insert(() => y, ":first-child");
	if (v.attr("class", "basic label-container").attr("style", i), s.selectAll(".label").each((e, t, r) => {
		let i = _t(r[t]), n = i.attr("transform"), a = 0, s = 0;
		if (n) {
			let e = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(n);
			e && (a = parseFloat(e[1]), s = parseFloat(e[2]));
		}
		let o = s - d / 2, l = p + 10;
		(0 === t || 1 === t) && (l = a), i.attr("transform", `translate(${l}, ${o + 20})`);
	}), l > o + h + 20) {
		let e = g.line(p, f + o + h + 20, p + u, f + o + h + 20, m);
		s.insert(() => e).attr("style", i);
	}
	return J5(t, v), t.intersect = function(e) {
		return ee2(t, e);
	}, s;
}
async function erC(e, t, r, i = "") {
	if ("" === t) return 0;
	let n = e.insert("g").attr("class", "label").attr("style", i), a = IA(), s = a.htmlLabels ?? !0, o = await XQ(n, Du(V6(t)), {
		width: VH(t, a) + 50,
		classes: "markdown-node-label",
		useHtmlLabels: s,
		style: i
	}, a), l;
	if (s) {
		let e = o.children[0], t = _t(o);
		l = e.getBoundingClientRect(), t.attr("width", l.width), t.attr("height", l.height);
	} else {
		for (let e of o.children[0].children) e.textContent = e.textContent.replaceAll("&gt;", ">").replaceAll("&lt;", "<"), i && e.setAttribute("style", i);
		l = o.getBBox(), l.height += 6;
	}
	return n.attr("transform", `translate(${-l.width / 2},${-l.height / 2 + r})`), l.height;
}
h(erp, "tiltedCylinder"), h(erf, "trapezoid"), h(erg, "trapezoidalPentagon"), h(erm, "triangle"), h(ery, "waveEdgedRectangle"), h(erv, "waveRectangle"), h(erx, "windowPane"), h(erb, "erBox"), h(erw, "addText"), h(erk, "textHelper"), h(erT, "addText"), h(er_, "classBox"), h(erE, "requirementBox"), h(erC, "addText");
var erS = h((e) => {
	switch (e) {
		case "Very High": return "red";
		case "High": return "orange";
		case "Medium": return null;
		case "Low": return "blue";
		case "Very Low": return "lightblue";
	}
}, "colorFromPriority");
async function erA(e, t, { config: r }) {
	let { labelStyles: i, nodeStyles: n } = JJ(t);
	t.labelStyle = i || "";
	let a = t.width;
	t.width = (t.width ?? 200) - 10;
	let { shapeSvg: s, bbox: o, label: l } = await J2(e, t, J3(t)), h = t.padding || 10, u = "", d;
	"ticket" in t && t.ticket && r?.kanban?.ticketBaseUrl && (u = r?.kanban?.ticketBaseUrl.replace("#TICKET#", t.ticket), d = s.insert("svg:a", ":first-child").attr("class", "kanban-ticket-link").attr("xlink:href", u).attr("target", "_blank"));
	let p = {
		useHtmlLabels: t.useHtmlLabels,
		labelStyle: t.labelStyle || "",
		width: t.width,
		img: t.img,
		padding: t.padding || 8,
		centerLabel: !1
	}, f, g;
	d ? {label: f, bbox: g} = await J4(d, "ticket" in t && t.ticket || "", p) : {label: f, bbox: g} = await J4(s, "ticket" in t && t.ticket || "", p);
	let { label: m, bbox: y } = await J4(s, "assigned" in t && t.assigned || "", p);
	t.width = a;
	let v = t?.width || 0, x = Math.max(g.height, y.height) / 2, b = Math.max(o.height + 20, t?.height || 0) + x, w = -v / 2, k = -b / 2;
	l.attr("transform", "translate(" + (h - v / 2) + ", " + (-x - o.height / 2) + ")"), f.attr("transform", "translate(" + (h - v / 2) + ", " + (-x + o.height / 2) + ")"), m.attr("transform", "translate(" + (h + v / 2 - y.width - 20) + ", " + (-x + o.height / 2) + ")");
	let T, { rx: _, ry: E } = t, { cssStyles: C } = t;
	if ("handDrawn" === t.look) {
		let e = ee1.svg(s), r = J0(t, {}), i = _ || E ? e.path(ee6(w, k, v, b, _ || 0), r) : e.rectangle(w, k, v, b, r);
		(T = s.insert(() => i, ":first-child")).attr("class", "basic label-container").attr("style", C || null);
	} else {
		(T = s.insert("rect", ":first-child")).attr("class", "basic label-container __APA__").attr("style", n).attr("rx", _ ?? 5).attr("ry", E ?? 5).attr("x", w).attr("y", k).attr("width", v).attr("height", b);
		let e = "priority" in t && t.priority;
		if (e) {
			let t = s.append("line"), r = w + 2, i = k + Math.floor((_ ?? 0) / 2), n = k + b - Math.floor((_ ?? 0) / 2);
			t.attr("x1", r).attr("y1", i).attr("x2", r).attr("y2", n).attr("stroke-width", "4").attr("stroke", erS(e));
		}
	}
	return J5(t, T), t.height = b, t.intersect = function(e) {
		return ee2(t, e);
	}, s;
}
async function erL(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a, halfPadding: s, label: o } = await J2(e, t, J3(t)), l = a.width + 10 * s, h = a.height + 8 * s, u = .15 * l, { cssStyles: d } = t, p = a.width + 20, f = a.height + 20, g = Math.max(l, p), m = Math.max(h, f);
	o.attr("transform", `translate(${-a.width / 2}, ${-a.height / 2})`);
	let y, v = `M0 0 
    a${u},${u} 1 0,0 ${.25 * g},${-1 * m * .1}
    a${u},${u} 1 0,0 ${.25 * g},0
    a${u},${u} 1 0,0 ${.25 * g},0
    a${u},${u} 1 0,0 ${.25 * g},${.1 * m}

    a${u},${u} 1 0,0 ${.15 * g},${.33 * m}
    a${.8 * u},${.8 * u} 1 0,0 0,${.34 * m}
    a${u},${u} 1 0,0 ${-1 * g * .15},${.33 * m}

    a${u},${u} 1 0,0 ${-1 * g * .25},${.15 * m}
    a${u},${u} 1 0,0 ${-1 * g * .25},0
    a${u},${u} 1 0,0 ${-1 * g * .25},0
    a${u},${u} 1 0,0 ${-1 * g * .25},${-1 * m * .15}

    a${u},${u} 1 0,0 ${-1 * g * .1},${-1 * m * .33}
    a${.8 * u},${.8 * u} 1 0,0 0,${-1 * m * .34}
    a${u},${u} 1 0,0 ${.1 * g},${-1 * m * .33}
  H0 V0 Z`;
	if ("handDrawn" === t.look) {
		let e = ee1.svg(n), r = J0(t, {}), i = e.path(v, r);
		(y = n.insert(() => i, ":first-child")).attr("class", "basic label-container").attr("style", V8(d));
	} else y = n.insert("path", ":first-child").attr("class", "basic label-container").attr("style", i).attr("d", v);
	return y.attr("transform", `translate(${-g / 2}, ${-m / 2})`), J5(t, y), t.calcIntersect = function(e, t) {
		return ee2(e, t);
	}, t.intersect = function(e) {
		return wQ.info("Bang intersect", t, e), ee2(t, e);
	}, n;
}
async function erR(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a, halfPadding: s, label: o } = await J2(e, t, J3(t)), l = a.width + 2 * s, h = a.height + 2 * s, u = .15 * l, d = .25 * l, p = .35 * l, f = .2 * l, { cssStyles: g } = t, m, y = `M0 0 
    a${u},${u} 0 0,1 ${.25 * l},${-1 * l * .1}
    a${p},${p} 1 0,1 ${.4 * l},${-1 * l * .1}
    a${d},${d} 1 0,1 ${.35 * l},${.2 * l}

    a${u},${u} 1 0,1 ${.15 * l},${.35 * h}
    a${f},${f} 1 0,1 ${-1 * l * .15},${.65 * h}

    a${d},${u} 1 0,1 ${-1 * l * .25},${.15 * l}
    a${p},${p} 1 0,1 ${-1 * l * .5},0
    a${u},${u} 1 0,1 ${-1 * l * .25},${-1 * l * .15}

    a${u},${u} 1 0,1 ${-1 * l * .1},${-1 * h * .35}
    a${f},${f} 1 0,1 ${.1 * l},${-1 * h * .65}
  H0 V0 Z`;
	if ("handDrawn" === t.look) {
		let e = ee1.svg(n), r = J0(t, {}), i = e.path(y, r);
		(m = n.insert(() => i, ":first-child")).attr("class", "basic label-container").attr("style", V8(g));
	} else m = n.insert("path", ":first-child").attr("class", "basic label-container").attr("style", i).attr("d", y);
	return o.attr("transform", `translate(${-a.width / 2}, ${-a.height / 2})`), m.attr("transform", `translate(${-l / 2}, ${-h / 2})`), J5(t, m), t.calcIntersect = function(e, t) {
		return ee2(e, t);
	}, t.intersect = function(e) {
		return wQ.info("Cloud intersect", t, e), ee2(t, e);
	}, n;
}
async function erN(e, t) {
	let { labelStyles: r, nodeStyles: i } = JJ(t);
	t.labelStyle = r;
	let { shapeSvg: n, bbox: a, halfPadding: s, label: o } = await J2(e, t, J3(t)), l = a.width + 8 * s, h = a.height + 2 * s, u = `
    M${-l / 2} ${h / 2 - 5}
    v${-h + 10}
    q0,-5 5,-5
    h${l - 10}
    q5,0 5,5
    v${h - 10}
    q0,5 -5,5
    h${-l + 10}
    q-5,0 -5,-5
    Z
  `, d = n.append("path").attr("id", "node-" + t.id).attr("class", "node-bkg node-" + t.type).attr("style", i).attr("d", u);
	return n.append("line").attr("class", "node-line-").attr("x1", -l / 2).attr("y1", h / 2).attr("x2", l / 2).attr("y2", h / 2), o.attr("transform", `translate(${-a.width / 2}, ${-a.height / 2})`), n.append(() => o.node()), J5(t, d), t.calcIntersect = function(e, t) {
		return ee2(e, t);
	}, t.intersect = function(e) {
		return ee2(t, e);
	}, n;
}
async function erI(e, t) {
	return etm(e, t, { padding: t.padding ?? 0 });
}
h(erA, "kanbanItem"), h(erL, "bang"), h(erR, "cloud"), h(erN, "defaultMindmapNode"), h(erI, "mindmapCircle");
var erM = [
	{
		semanticName: "Process",
		name: "Rectangle",
		shortName: "rect",
		description: "Standard process shape",
		aliases: [
			"proc",
			"process",
			"rectangle"
		],
		internalAliases: ["squareRect"],
		handler: ert
	},
	{
		semanticName: "Event",
		name: "Rounded Rectangle",
		shortName: "rounded",
		description: "Represents an event",
		aliases: ["event"],
		internalAliases: ["roundedRect"],
		handler: et8
	},
	{
		semanticName: "Terminal Point",
		name: "Stadium",
		shortName: "stadium",
		description: "Terminal point",
		aliases: ["terminal", "pill"],
		handler: err
	},
	{
		semanticName: "Subprocess",
		name: "Framed Rectangle",
		shortName: "fr-rect",
		description: "Subprocess",
		aliases: [
			"subprocess",
			"subproc",
			"framed-rectangle",
			"subroutine"
		],
		handler: ers
	},
	{
		semanticName: "Database",
		name: "Cylinder",
		shortName: "cyl",
		description: "Database storage",
		aliases: [
			"db",
			"database",
			"cylinder"
		],
		handler: etL
	},
	{
		semanticName: "Start",
		name: "Circle",
		shortName: "circle",
		description: "Starting point",
		aliases: ["circ"],
		handler: etm
	},
	{
		semanticName: "Bang",
		name: "Bang",
		shortName: "bang",
		description: "Bang",
		aliases: ["bang"],
		handler: erL
	},
	{
		semanticName: "Cloud",
		name: "Cloud",
		shortName: "cloud",
		description: "cloud",
		aliases: ["cloud"],
		handler: erR
	},
	{
		semanticName: "Decision",
		name: "Diamond",
		shortName: "diam",
		description: "Decision-making step",
		aliases: [
			"decision",
			"diamond",
			"question"
		],
		handler: et5
	},
	{
		semanticName: "Prepare Conditional",
		name: "Hexagon",
		shortName: "hex",
		description: "Preparation or condition step",
		aliases: ["hexagon", "prepare"],
		handler: et$
	},
	{
		semanticName: "Data Input/Output",
		name: "Lean Right",
		shortName: "lean-r",
		description: "Represents input or output",
		aliases: ["lean-right", "in-out"],
		internalAliases: ["lean_right"],
		handler: etV
	},
	{
		semanticName: "Data Input/Output",
		name: "Lean Left",
		shortName: "lean-l",
		description: "Represents output or input",
		aliases: ["lean-left", "out-in"],
		internalAliases: ["lean_left"],
		handler: etY
	},
	{
		semanticName: "Priority Action",
		name: "Trapezoid Base Bottom",
		shortName: "trap-b",
		description: "Priority action",
		aliases: [
			"priority",
			"trapezoid-bottom",
			"trapezoid"
		],
		handler: erf
	},
	{
		semanticName: "Manual Operation",
		name: "Trapezoid Base Top",
		shortName: "trap-t",
		description: "Represents a manual task",
		aliases: [
			"manual",
			"trapezoid-top",
			"inv-trapezoid"
		],
		internalAliases: ["inv_trapezoid"],
		handler: etq
	},
	{
		semanticName: "Stop",
		name: "Double Circle",
		shortName: "dbl-circ",
		description: "Represents a stop point",
		aliases: ["double-circle"],
		internalAliases: ["doublecircle"],
		handler: etN
	},
	{
		semanticName: "Text Block",
		name: "Text Block",
		shortName: "text",
		description: "Text block",
		handler: erc
	},
	{
		semanticName: "Card",
		name: "Notched Rectangle",
		shortName: "notch-rect",
		description: "Represents a card",
		aliases: ["card", "notched-rectangle"],
		handler: etf
	},
	{
		semanticName: "Lined/Shaded Process",
		name: "Lined Rectangle",
		shortName: "lin-rect",
		description: "Lined process shape",
		aliases: [
			"lined-rectangle",
			"lined-process",
			"lin-proc",
			"shaded-process"
		],
		handler: et9
	},
	{
		semanticName: "Start",
		name: "Small Circle",
		shortName: "sm-circ",
		description: "Small starting point",
		aliases: ["start", "small-circle"],
		internalAliases: ["stateStart"],
		handler: era
	},
	{
		semanticName: "Stop",
		name: "Framed Circle",
		shortName: "fr-circ",
		description: "Stop point",
		aliases: ["stop", "framed-circle"],
		internalAliases: ["stateEnd"],
		handler: ern
	},
	{
		semanticName: "Fork/Join",
		name: "Filled Rectangle",
		shortName: "fork",
		description: "Fork or join in process flow",
		aliases: ["join"],
		internalAliases: ["forkJoin"],
		handler: etD
	},
	{
		semanticName: "Collate",
		name: "Hourglass",
		shortName: "hourglass",
		description: "Represents a collate operation",
		aliases: ["hourglass", "collate"],
		handler: etP
	},
	{
		semanticName: "Comment",
		name: "Curly Brace",
		shortName: "brace",
		description: "Adds a comment",
		aliases: ["comment", "brace-l"],
		handler: etb
	},
	{
		semanticName: "Comment Right",
		name: "Curly Brace",
		shortName: "brace-r",
		description: "Adds a comment",
		handler: etk
	},
	{
		semanticName: "Comment with braces on both sides",
		name: "Curly Braces",
		shortName: "braces",
		description: "Adds a comment",
		handler: et_
	},
	{
		semanticName: "Com Link",
		name: "Lightning Bolt",
		shortName: "bolt",
		description: "Communication link",
		aliases: ["com-link", "lightning-bolt"],
		handler: etH
	},
	{
		semanticName: "Document",
		name: "Document",
		shortName: "doc",
		description: "Represents a document",
		aliases: ["doc", "document"],
		handler: ery
	},
	{
		semanticName: "Delay",
		name: "Half-Rounded Rectangle",
		shortName: "delay",
		description: "Represents a delay",
		aliases: ["half-rounded-rectangle"],
		handler: etO
	},
	{
		semanticName: "Direct Access Storage",
		name: "Horizontal Cylinder",
		shortName: "h-cyl",
		description: "Direct access storage",
		aliases: ["das", "horizontal-cylinder"],
		handler: erp
	},
	{
		semanticName: "Disk Storage",
		name: "Lined Cylinder",
		shortName: "lin-cyl",
		description: "Disk storage",
		aliases: ["disk", "lined-cylinder"],
		handler: etQ
	},
	{
		semanticName: "Display",
		name: "Curved Trapezoid",
		shortName: "curv-trap",
		description: "Represents a display",
		aliases: ["curved-trapezoid", "display"],
		handler: etE
	},
	{
		semanticName: "Divided Process",
		name: "Divided Rectangle",
		shortName: "div-rect",
		description: "Divided process shape",
		aliases: [
			"div-proc",
			"divided-rectangle",
			"divided-process"
		],
		handler: etR
	},
	{
		semanticName: "Extract",
		name: "Triangle",
		shortName: "tri",
		description: "Extraction process",
		aliases: ["extract", "triangle"],
		handler: erm
	},
	{
		semanticName: "Internal Storage",
		name: "Window Pane",
		shortName: "win-pane",
		description: "Internal storage",
		aliases: ["internal-storage", "window-pane"],
		handler: erx
	},
	{
		semanticName: "Junction",
		name: "Filled Circle",
		shortName: "f-circ",
		description: "Junction point",
		aliases: ["junction", "filled-circle"],
		handler: etI
	},
	{
		semanticName: "Loop Limit",
		name: "Trapezoidal Pentagon",
		shortName: "notch-pent",
		description: "Loop limit step",
		aliases: ["loop-limit", "notched-pentagon"],
		handler: erg
	},
	{
		semanticName: "Manual File",
		name: "Flipped Triangle",
		shortName: "flip-tri",
		description: "Manual file operation",
		aliases: ["manual-file", "flipped-triangle"],
		handler: etM
	},
	{
		semanticName: "Manual Input",
		name: "Sloped Rectangle",
		shortName: "sl-rect",
		description: "Manual input step",
		aliases: ["manual-input", "sloped-rectangle"],
		handler: ere
	},
	{
		semanticName: "Multi-Document",
		name: "Stacked Document",
		shortName: "docs",
		description: "Multiple documents",
		aliases: [
			"documents",
			"st-doc",
			"stacked-document"
		],
		handler: et1
	},
	{
		semanticName: "Multi-Process",
		name: "Stacked Rectangle",
		shortName: "st-rect",
		description: "Multiple processes",
		aliases: [
			"procs",
			"processes",
			"stacked-rectangle"
		],
		handler: et0
	},
	{
		semanticName: "Stored Data",
		name: "Bow Tie Rectangle",
		shortName: "bow-rect",
		description: "Stored data",
		aliases: ["stored-data", "bow-tie-rectangle"],
		handler: etd
	},
	{
		semanticName: "Summary",
		name: "Crossed Circle",
		shortName: "cross-circ",
		description: "Summary",
		aliases: ["summary", "crossed-circle"],
		handler: etv
	},
	{
		semanticName: "Tagged Document",
		name: "Tagged Document",
		shortName: "tag-doc",
		description: "Tagged document",
		aliases: ["tag-doc", "tagged-document"],
		handler: erl
	},
	{
		semanticName: "Tagged Process",
		name: "Tagged Rectangle",
		shortName: "tag-rect",
		description: "Tagged process",
		aliases: [
			"tagged-rectangle",
			"tag-proc",
			"tagged-process"
		],
		handler: ero
	},
	{
		semanticName: "Paper Tape",
		name: "Flag",
		shortName: "flag",
		description: "Paper tape",
		aliases: ["paper-tape"],
		handler: erv
	},
	{
		semanticName: "Odd",
		name: "Odd",
		shortName: "odd",
		description: "Odd shape",
		internalAliases: ["rect_left_inv_arrow"],
		handler: et3
	},
	{
		semanticName: "Lined Document",
		name: "Lined Document",
		shortName: "lin-doc",
		description: "Lined document",
		aliases: ["lined-document"],
		handler: etJ
	}
], erD = h(() => Object.fromEntries([...Object.entries({
	state: eri,
	choice: etg,
	note: et2,
	rectWithTitle: et6,
	labelRect: etW,
	iconSquare: etU,
	iconCircle: etF,
	icon: etB,
	iconRounded: etz,
	imageSquare: etG,
	anchor: eth,
	kanbanItem: erA,
	mindmapCircle: erI,
	defaultMindmapNode: erN,
	classBox: er_,
	erBox: erb,
	requirementBox: erE
}), ...erM.flatMap((e) => [
	e.shortName,
	..."aliases" in e ? e.aliases : [],
	..."internalAliases" in e ? e.internalAliases : []
].map((t) => [t, e.handler]))]), "generateShapeMap")();
function erO(e) {
	return e in erD;
}
h(erO, "isValidShape");
var er$ = /* @__PURE__ */ new Map();
async function erP(e, t, r) {
	let i, n;
	"rect" === t.shape && (t.rx && t.ry ? t.shape = "roundedRect" : t.shape = "squareRect");
	let a = t.shape ? erD[t.shape] : void 0;
	if (!a) throw Error(`No such shape: ${t.shape}. Please check your syntax.`);
	if (t.link) {
		let s;
		"sandbox" === r.config.securityLevel ? s = "_top" : t.linkTarget && (s = t.linkTarget || "_blank"), i = e.insert("svg:a").attr("xlink:href", t.link).attr("target", s ?? null), n = await a(i, t, r);
	} else i = n = await a(e, t, r);
	return t.tooltip && n.attr("title", t.tooltip), er$.set(t.id, i), t.haveCallback && i.attr("class", i.attr("class") + " clickable"), i;
}
h(erP, "insertNode");
var erB = h((e, t) => {
	er$.set(t.id, e);
}, "setNodeElem"), erF = h(() => {
	er$.clear();
}, "clear"), erz = h((e) => {
	let t = er$.get(e.id);
	wQ.trace("Transforming node", e.diff, e, "translate(" + (e.x - e.width / 2 - 5) + ", " + e.width / 2 + ")");
	let r = e.diff || 0;
	return e.clusterNode ? t.attr("transform", "translate(" + (e.x + r - e.width / 2) + ", " + (e.y - e.height / 2 - 8) + ")") : t.attr("transform", "translate(" + e.x + ", " + e.y + ")"), r;
}, "positionNode"), erU = h((e, t, r, i, n, a) => {
	t.arrowTypeStart && erq(e, "start", t.arrowTypeStart, r, i, n, a), t.arrowTypeEnd && erq(e, "end", t.arrowTypeEnd, r, i, n, a);
}, "addEdgeMarkers"), erG = {
	arrow_cross: {
		type: "cross",
		fill: !1
	},
	arrow_point: {
		type: "point",
		fill: !0
	},
	arrow_barb: {
		type: "barb",
		fill: !0
	},
	arrow_circle: {
		type: "circle",
		fill: !1
	},
	aggregation: {
		type: "aggregation",
		fill: !1
	},
	extension: {
		type: "extension",
		fill: !1
	},
	composition: {
		type: "composition",
		fill: !0
	},
	dependency: {
		type: "dependency",
		fill: !0
	},
	lollipop: {
		type: "lollipop",
		fill: !1
	},
	only_one: {
		type: "onlyOne",
		fill: !1
	},
	zero_or_one: {
		type: "zeroOrOne",
		fill: !1
	},
	one_or_more: {
		type: "oneOrMore",
		fill: !1
	},
	zero_or_more: {
		type: "zeroOrMore",
		fill: !1
	},
	requirement_arrow: {
		type: "requirement_arrow",
		fill: !1
	},
	requirement_contains: {
		type: "requirement_contains",
		fill: !1
	}
}, erq = h((e, t, r, i, n, a, s) => {
	let o = erG[r];
	if (!o) return void wQ.warn(`Unknown arrow type: ${r}`);
	let l = `${n}_${a}-${o.type}${"start" === t ? "Start" : "End"}`;
	if (s && "" !== s.trim()) {
		let r = `${l}_${s.replace(/[^\dA-Za-z]/g, "_")}`;
		if (!document.getElementById(r)) {
			let e = document.getElementById(l);
			if (e) {
				let t = e.cloneNode(!0);
				t.id = r, t.querySelectorAll("path, circle, line").forEach((e) => {
					e.setAttribute("stroke", s), o.fill && e.setAttribute("fill", s);
				}), e.parentNode?.appendChild(t);
			}
		}
		e.attr(`marker-${t}`, `url(${i}#${r})`);
	} else e.attr(`marker-${t}`, `url(${i}#${l})`);
}, "addEdgeMarker"), erj = /* @__PURE__ */ new Map(), erW = /* @__PURE__ */ new Map(), erY = h(() => {
	erj.clear(), erW.clear();
}, "clear"), erV = h((e) => e ? e.reduce((e, t) => e + ";" + t, "") : "", "getLabelStyles"), erH = h(async (e, t) => {
	let r, i = MG(IA().flowchart.htmlLabels), { labelStyles: n } = JJ(t);
	t.labelStyle = n;
	let a = await XQ(e, t.label, {
		style: t.labelStyle,
		useHtmlLabels: i,
		addSvgBackground: !0,
		isNode: !1
	});
	wQ.info("abc82", t, t.labelType);
	let s = e.insert("g").attr("class", "edgeLabel"), o = s.insert("g").attr("class", "label").attr("data-id", t.id);
	o.node().appendChild(a);
	let l = a.getBBox();
	if (i) {
		let e = a.children[0], t = _t(a);
		l = e.getBoundingClientRect(), t.attr("width", l.width), t.attr("height", l.height);
	}
	if (o.attr("transform", "translate(" + -l.width / 2 + ", " + -l.height / 2 + ")"), erj.set(t.id, s), t.width = l.width, t.height = l.height, t.startLabelLeft) {
		let i = await ee3(t.startLabelLeft, erV(t.labelStyle)), n = e.insert("g").attr("class", "edgeTerminals"), a = n.insert("g").attr("class", "inner");
		r = a.node().appendChild(i);
		let s = i.getBBox();
		a.attr("transform", "translate(" + -s.width / 2 + ", " + -s.height / 2 + ")"), erW.get(t.id) || erW.set(t.id, {}), erW.get(t.id).startLeft = n, erX(r, t.startLabelLeft);
	}
	if (t.startLabelRight) {
		let i = await ee3(t.startLabelRight, erV(t.labelStyle)), n = e.insert("g").attr("class", "edgeTerminals"), a = n.insert("g").attr("class", "inner");
		r = n.node().appendChild(i), a.node().appendChild(i);
		let s = i.getBBox();
		a.attr("transform", "translate(" + -s.width / 2 + ", " + -s.height / 2 + ")"), erW.get(t.id) || erW.set(t.id, {}), erW.get(t.id).startRight = n, erX(r, t.startLabelRight);
	}
	if (t.endLabelLeft) {
		let i = await ee3(t.endLabelLeft, erV(t.labelStyle)), n = e.insert("g").attr("class", "edgeTerminals"), a = n.insert("g").attr("class", "inner");
		r = a.node().appendChild(i);
		let s = i.getBBox();
		a.attr("transform", "translate(" + -s.width / 2 + ", " + -s.height / 2 + ")"), n.node().appendChild(i), erW.get(t.id) || erW.set(t.id, {}), erW.get(t.id).endLeft = n, erX(r, t.endLabelLeft);
	}
	if (t.endLabelRight) {
		let i = await ee3(t.endLabelRight, erV(t.labelStyle)), n = e.insert("g").attr("class", "edgeTerminals"), a = n.insert("g").attr("class", "inner");
		r = a.node().appendChild(i);
		let s = i.getBBox();
		a.attr("transform", "translate(" + -s.width / 2 + ", " + -s.height / 2 + ")"), n.node().appendChild(i), erW.get(t.id) || erW.set(t.id, {}), erW.get(t.id).endRight = n, erX(r, t.endLabelRight);
	}
	return a;
}, "insertEdgeLabel");
function erX(e, t) {
	IA().flowchart.htmlLabels && e && (e.style.width = 9 * t.length + "px", e.style.height = "12px");
}
h(erX, "setTerminalWidth");
var erK = h((e, t) => {
	wQ.debug("Moving label abc88 ", e.id, e.label, erj.get(e.id), t);
	let r = t.updatedPath ? t.updatedPath : t.originalPath, { subGraphTitleTotalMargin: i } = KY(IA());
	if (e.label) {
		let n = erj.get(e.id), a = e.x, s = e.y;
		if (r) {
			let i = VD(r);
			wQ.debug("Moving label " + e.label + " from (", a, ",", s, ") to (", i.x, ",", i.y, ") abc88"), t.updatedPath && (a = i.x, s = i.y);
		}
		n.attr("transform", `translate(${a}, ${s + i / 2})`);
	}
	if (e.startLabelLeft) {
		let t = erW.get(e.id).startLeft, i = e.x, n = e.y;
		if (r) {
			let t = VP(10 * !!e.arrowTypeStart, "start_left", r);
			i = t.x, n = t.y;
		}
		t.attr("transform", `translate(${i}, ${n})`);
	}
	if (e.startLabelRight) {
		let t = erW.get(e.id).startRight, i = e.x, n = e.y;
		if (r) {
			let t = VP(10 * !!e.arrowTypeStart, "start_right", r);
			i = t.x, n = t.y;
		}
		t.attr("transform", `translate(${i}, ${n})`);
	}
	if (e.endLabelLeft) {
		let t = erW.get(e.id).endLeft, i = e.x, n = e.y;
		if (r) {
			let t = VP(10 * !!e.arrowTypeEnd, "end_left", r);
			i = t.x, n = t.y;
		}
		t.attr("transform", `translate(${i}, ${n})`);
	}
	if (e.endLabelRight) {
		let t = erW.get(e.id).endRight, i = e.x, n = e.y;
		if (r) {
			let t = VP(10 * !!e.arrowTypeEnd, "end_right", r);
			i = t.x, n = t.y;
		}
		t.attr("transform", `translate(${i}, ${n})`);
	}
}, "positionEdgeLabel"), erZ = h((e, t) => {
	let r = e.x, i = e.y, n = Math.abs(t.x - r), a = Math.abs(t.y - i), s = e.width / 2, o = e.height / 2;
	return n >= s || a >= o;
}, "outsideNode"), erQ = h((e, t, r) => {
	wQ.debug(`intersection calc abc89:
  outsidePoint: ${JSON.stringify(t)}
  insidePoint : ${JSON.stringify(r)}
  node        : x:${e.x} y:${e.y} w:${e.width} h:${e.height}`);
	let i = e.x, n = e.y, a = Math.abs(i - r.x), s = e.width / 2, o = r.x < t.x ? s - a : s + a, l = e.height / 2, h = Math.abs(t.y - r.y), u = Math.abs(t.x - r.x);
	if (Math.abs(n - t.y) * s > Math.abs(i - t.x) * l) {
		let e = r.y < t.y ? t.y - l - n : n - l - t.y;
		o = u * e / h;
		let i = {
			x: r.x < t.x ? r.x + o : r.x - u + o,
			y: r.y < t.y ? r.y + h - e : r.y - h + e
		};
		return 0 === o && (i.x = t.x, i.y = t.y), 0 === u && (i.x = t.x), 0 === h && (i.y = t.y), wQ.debug(`abc89 top/bottom calc, Q ${h}, q ${e}, R ${u}, r ${o}`, i), i;
	}
	{
		let e = h * (o = r.x < t.x ? t.x - s - i : i - s - t.x) / u, n = r.x < t.x ? r.x + u - o : r.x - u + o, a = r.y < t.y ? r.y + e : r.y - e;
		return wQ.debug(`sides calc abc89, Q ${h}, q ${e}, R ${u}, r ${o}`, {
			_x: n,
			_y: a
		}), 0 === o && (n = t.x, a = t.y), 0 === u && (n = t.x), 0 === h && (a = t.y), {
			x: n,
			y: a
		};
	}
}, "intersection"), erJ = h((e, t) => {
	wQ.warn("abc88 cutPathAtIntersect", e, t);
	let r = [], i = e[0], n = !1;
	return e.forEach((e) => {
		if (wQ.info("abc88 checking point", e, t), erZ(t, e) || n) wQ.warn("abc88 outside", e, i), i = e, n || r.push(e);
		else {
			let a = erQ(t, i, e);
			wQ.debug("abc88 inside", e, i, a), wQ.debug("abc88 intersection", a, t);
			let s = !1;
			r.forEach((e) => {
				s = s || e.x === a.x && e.y === a.y;
			}), r.some((e) => e.x === a.x && e.y === a.y) ? wQ.warn("abc88 no intersect", a, r) : r.push(a), n = !0;
		}
	}), wQ.debug("returning points", r), r;
}, "cutPathAtIntersect");
function er0(e) {
	let t = [], r = [];
	for (let i = 1; i < e.length - 1; i++) {
		let n = e[i - 1], a = e[i], s = e[i + 1];
		(n.x === a.x && a.y === s.y && Math.abs(a.x - s.x) > 5 && Math.abs(a.y - n.y) > 5 || n.y === a.y && a.x === s.x && Math.abs(a.x - n.x) > 5 && Math.abs(a.y - s.y) > 5) && (t.push(a), r.push(i));
	}
	return {
		cornerPoints: t,
		cornerPointPositions: r
	};
}
h(er0, "extractCornerPoints");
var er1 = h(function(e, t, r) {
	let i = t.x - e.x, n = t.y - e.y, a = r / Math.sqrt(i * i + n * n);
	return {
		x: t.x - a * i,
		y: t.y - a * n
	};
}, "findAdjacentPoint"), er2 = h(function(e) {
	let { cornerPointPositions: t } = er0(e), r = [];
	for (let i = 0; i < e.length; i++) if (t.includes(i)) {
		let t = e[i - 1], n = e[i + 1], a = e[i], s = er1(t, a, 5), o = er1(n, a, 5), l = o.x - s.x, h = o.y - s.y;
		r.push(s);
		let u = 2 * Math.sqrt(2), d = {
			x: a.x,
			y: a.y
		};
		Math.abs(n.x - t.x) > 10 && Math.abs(n.y - t.y) >= 10 ? (wQ.debug("Corner point fixing", Math.abs(n.x - t.x), Math.abs(n.y - t.y)), d = a.x === s.x ? {
			x: l < 0 ? s.x - 5 + u : s.x + 5 - u,
			y: h < 0 ? s.y - u : s.y + u
		} : {
			x: l < 0 ? s.x - u : s.x + u,
			y: h < 0 ? s.y - 5 + u : s.y + 5 - u
		}) : wQ.debug("Corner point skipping fixing", Math.abs(n.x - t.x), Math.abs(n.y - t.y)), r.push(d, o);
	} else r.push(e[i]);
	return r;
}, "fixCorners"), er4 = h((e, t, r) => {
	let i = Math.floor((e - t - r) / 4);
	return `0 ${t} ${Array(i).fill("2 2").join(" ")} ${r}`;
}, "generateDashArray"), er5 = h(function(e, t, r, i, n, a, s, o = !1) {
	let { handDrawnSeed: l } = IA(), h = t.points, u = !1, d = [];
	for (let e in t.cssCompiledStyles) JQ(e) || d.push(t.cssCompiledStyles[e]);
	wQ.debug("UIO intersect check", t.points, a.x, n.x), a.intersect && n.intersect && !o && ((h = h.slice(1, t.points.length - 1)).unshift(n.intersect(h[0])), wQ.debug("Last point UIO", t.start, "-->", t.end, h[h.length - 1], a, a.intersect(h[h.length - 1])), h.push(a.intersect(h[h.length - 1])));
	let p = btoa(JSON.stringify(h));
	t.toCluster && (wQ.info("to cluster abc88", r.get(t.toCluster)), h = erJ(t.points, r.get(t.toCluster).node), u = !0), t.fromCluster && (wQ.debug("from cluster abc88", r.get(t.fromCluster), JSON.stringify(h, null, 2)), h = erJ(h.reverse(), r.get(t.fromCluster).node).reverse(), u = !0);
	let f = h.filter((e) => !Number.isNaN(e.y));
	f = er2(f);
	let g = Li;
	switch (g = A0, t.curve) {
		case "linear":
			g = A0;
			break;
		case "basis":
		default:
			g = Li;
			break;
		case "cardinal":
			g = Lp;
			break;
		case "bumpX":
			g = A9;
			break;
		case "bumpY":
			g = Le;
			break;
		case "catmullRom":
			g = Lb;
			break;
		case "monotoneX":
			g = LD;
			break;
		case "monotoneY":
			g = LO;
			break;
		case "natural":
			g = LB;
			break;
		case "step":
			g = Lz;
			break;
		case "stepAfter":
			g = LG;
			break;
		case "stepBefore": g = LU;
	}
	let { x: m, y } = KW(t), v = A5().x(m).y(y).curve(g), x;
	switch (t.thickness) {
		case "normal":
		default:
			x = "edge-thickness-normal";
			break;
		case "thick":
			x = "edge-thickness-thick";
			break;
		case "invisible": x = "edge-thickness-invisible";
	}
	switch (t.pattern) {
		case "solid":
		default:
			x += " edge-pattern-solid";
			break;
		case "dotted":
			x += " edge-pattern-dotted";
			break;
		case "dashed": x += " edge-pattern-dashed";
	}
	let b, w = "rounded" === t.curve ? er3(er7(f, t), 5) : v(f), k = Array.isArray(t.style) ? t.style : [t.style], T = k.find((e) => e?.startsWith("stroke:")), _ = !1;
	if ("handDrawn" === t.look) {
		let r = ee1.svg(e);
		Object.assign([], f), x += " transition";
		let i = (b = _t(r.path(w, {
			roughness: .3,
			seed: l
		})).select("path").attr("id", t.id).attr("class", " " + x + (t.classes ? " " + t.classes : "")).attr("style", k ? k.reduce((e, t) => e + ";" + t, "") : "")).attr("d");
		b.attr("d", i), e.node().appendChild(b.node());
	} else {
		let r = d.join(";"), i = k ? k.reduce((e, t) => e + t + ";", "") : "", n = "";
		t.animate && (n = " edge-animation-fast"), t.animation && (n = " edge-animation-" + t.animation);
		let a = (r ? r + ";" + i + ";" : i) + ";" + (k ? k.reduce((e, t) => e + ";" + t, "") : "");
		b = e.append("path").attr("d", w).attr("id", t.id).attr("class", " " + x + (t.classes ? " " + t.classes : "") + (n ?? "")).attr("style", a), T = a.match(/stroke:([^;]+)/)?.[1], _ = !0 === t.animate || !!t.animation || r.includes("animation");
		let s = b.node(), o = "function" == typeof s.getTotalLength ? s.getTotalLength() : 0, l = KG[t.arrowTypeStart] || 0, h = KG[t.arrowTypeEnd] || 0;
		if ("neo" === t.look && !_) {
			let e = `stroke-dasharray: ${"dotted" === t.pattern || "dashed" === t.pattern ? er4(o, l, h) : `0 ${l} ${o - l - h} ${h}`}; stroke-dashoffset: 0;`;
			b.attr("style", e + b.attr("style"));
		}
	}
	b.attr("data-edge", !0), b.attr("data-et", "edge"), b.attr("data-id", t.id), b.attr("data-points", p), t.showPoints && f.forEach((t) => {
		e.append("circle").style("stroke", "red").style("fill", "red").attr("r", 1).attr("cx", t.x).attr("cy", t.y);
	});
	let E = "";
	(IA().flowchart.arrowMarkerAbsolute || IA().state.arrowMarkerAbsolute) && (E = (E = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search).replace(/\(/g, "\\(").replace(/\)/g, "\\)")), wQ.info("arrowTypeStart", t.arrowTypeStart), wQ.info("arrowTypeEnd", t.arrowTypeEnd), erU(b, t, E, s, i, T);
	let C = Math.floor(h.length / 2);
	V9(h[C], b.attr("d")) || (u = !0);
	let S = {};
	return u && (S.updatedPath = h), S.originalPath = t.points, S;
}, "insertEdge");
function er3(e, t) {
	if (e.length < 2) return "";
	let r = "", i = e.length;
	for (let n = 0; n < i; n++) {
		let a = e[n], s = e[n - 1], o = e[n + 1];
		if (0 === n) r += `M${a.x},${a.y}`;
		else if (n === i - 1) r += `L${a.x},${a.y}`;
		else {
			let e = a.x - s.x, i = a.y - s.y, n = o.x - a.x, l = o.y - a.y, h = Math.hypot(e, i), u = Math.hypot(n, l);
			if (h < 1e-5 || u < 1e-5) {
				r += `L${a.x},${a.y}`;
				continue;
			}
			let d = e / h, p = i / h, f = n / u, g = l / u, m = Math.acos(Math.max(-1, Math.min(1, d * f + p * g)));
			if (m < 1e-5 || 1e-5 > Math.abs(Math.PI - m)) {
				r += `L${a.x},${a.y}`;
				continue;
			}
			let y = Math.min(t / Math.sin(m / 2), h / 2, u / 2), v = a.x - d * y, x = a.y - p * y, b = a.x + f * y, w = a.y + g * y;
			r += `L${v},${x}Q${a.x},${a.y} ${b},${w}`;
		}
	}
	return r;
}
function er6(e, t) {
	if (!e || !t) return {
		angle: 0,
		deltaX: 0,
		deltaY: 0
	};
	let r = t.x - e.x, i = t.y - e.y;
	return {
		angle: Math.atan2(i, r),
		deltaX: r,
		deltaY: i
	};
}
function er7(e, t) {
	let r = e.map((e) => ({ ...e }));
	if (e.length >= 2 && KU[t.arrowTypeStart]) {
		let i = KU[t.arrowTypeStart], n = e[0], { angle: a } = er6(n, e[1]), s = i * Math.cos(a), o = i * Math.sin(a);
		r[0].x = n.x + s, r[0].y = n.y + o;
	}
	let i = e.length;
	if (i >= 2 && KU[t.arrowTypeEnd]) {
		let n = KU[t.arrowTypeEnd], a = e[i - 1], { angle: s } = er6(e[i - 2], a), o = n * Math.cos(s), l = n * Math.sin(s);
		r[i - 1].x = a.x - o, r[i - 1].y = a.y - l;
	}
	return r;
}
h(er3, "generateRoundedPath"), h(er6, "calculateDeltaAndAngle"), h(er7, "applyMarkerOffsetsToPoints");
var er8 = h((e, t, r, i) => {
	t.forEach((t) => {
		er9[t](e, r, i);
	});
}, "insertMarkers"), er9 = {
	extension: h((e, t, r) => {
		wQ.trace("Making markers for ", r), e.append("defs").append("marker").attr("id", r + "_" + t + "-extensionStart").attr("class", "marker extension " + t).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 1,7 L18,13 V 1 Z"), e.append("defs").append("marker").attr("id", r + "_" + t + "-extensionEnd").attr("class", "marker extension " + t).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 1,1 V 13 L18,7 Z");
	}, "extension"),
	composition: h((e, t, r) => {
		e.append("defs").append("marker").attr("id", r + "_" + t + "-compositionStart").attr("class", "marker composition " + t).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), e.append("defs").append("marker").attr("id", r + "_" + t + "-compositionEnd").attr("class", "marker composition " + t).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
	}, "composition"),
	aggregation: h((e, t, r) => {
		e.append("defs").append("marker").attr("id", r + "_" + t + "-aggregationStart").attr("class", "marker aggregation " + t).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"), e.append("defs").append("marker").attr("id", r + "_" + t + "-aggregationEnd").attr("class", "marker aggregation " + t).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
	}, "aggregation"),
	dependency: h((e, t, r) => {
		e.append("defs").append("marker").attr("id", r + "_" + t + "-dependencyStart").attr("class", "marker dependency " + t).attr("refX", 6).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 5,7 L9,13 L1,7 L9,1 Z"), e.append("defs").append("marker").attr("id", r + "_" + t + "-dependencyEnd").attr("class", "marker dependency " + t).attr("refX", 13).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
	}, "dependency"),
	lollipop: h((e, t, r) => {
		e.append("defs").append("marker").attr("id", r + "_" + t + "-lollipopStart").attr("class", "marker lollipop " + t).attr("refX", 13).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6), e.append("defs").append("marker").attr("id", r + "_" + t + "-lollipopEnd").attr("class", "marker lollipop " + t).attr("refX", 1).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6);
	}, "lollipop"),
	point: h((e, t, r) => {
		e.append("marker").attr("id", r + "_" + t + "-pointEnd").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", 5).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 8).attr("markerHeight", 8).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), e.append("marker").attr("id", r + "_" + t + "-pointStart").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", 4.5).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 8).attr("markerHeight", 8).attr("orient", "auto").append("path").attr("d", "M 0 5 L 10 10 L 10 0 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
	}, "point"),
	circle: h((e, t, r) => {
		e.append("marker").attr("id", r + "_" + t + "-circleEnd").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", 11).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0"), e.append("marker").attr("id", r + "_" + t + "-circleStart").attr("class", "marker " + t).attr("viewBox", "0 0 10 10").attr("refX", -1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
	}, "circle"),
	cross: h((e, t, r) => {
		e.append("marker").attr("id", r + "_" + t + "-crossEnd").attr("class", "marker cross " + t).attr("viewBox", "0 0 11 11").attr("refX", 12).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0"), e.append("marker").attr("id", r + "_" + t + "-crossStart").attr("class", "marker cross " + t).attr("viewBox", "0 0 11 11").attr("refX", -1).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0");
	}, "cross"),
	barb: h((e, t, r) => {
		e.append("defs").append("marker").attr("id", r + "_" + t + "-barbEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 14).attr("markerUnits", "userSpaceOnUse").attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
	}, "barb"),
	only_one: h((e, t, r) => {
		e.append("defs").append("marker").attr("id", r + "_" + t + "-onlyOneStart").attr("class", "marker onlyOne " + t).attr("refX", 0).attr("refY", 9).attr("markerWidth", 18).attr("markerHeight", 18).attr("orient", "auto").append("path").attr("d", "M9,0 L9,18 M15,0 L15,18"), e.append("defs").append("marker").attr("id", r + "_" + t + "-onlyOneEnd").attr("class", "marker onlyOne " + t).attr("refX", 18).attr("refY", 9).attr("markerWidth", 18).attr("markerHeight", 18).attr("orient", "auto").append("path").attr("d", "M3,0 L3,18 M9,0 L9,18");
	}, "only_one"),
	zero_or_one: h((e, t, r) => {
		let i = e.append("defs").append("marker").attr("id", r + "_" + t + "-zeroOrOneStart").attr("class", "marker zeroOrOne " + t).attr("refX", 0).attr("refY", 9).attr("markerWidth", 30).attr("markerHeight", 18).attr("orient", "auto");
		i.append("circle").attr("fill", "white").attr("cx", 21).attr("cy", 9).attr("r", 6), i.append("path").attr("d", "M9,0 L9,18");
		let n = e.append("defs").append("marker").attr("id", r + "_" + t + "-zeroOrOneEnd").attr("class", "marker zeroOrOne " + t).attr("refX", 30).attr("refY", 9).attr("markerWidth", 30).attr("markerHeight", 18).attr("orient", "auto");
		n.append("circle").attr("fill", "white").attr("cx", 9).attr("cy", 9).attr("r", 6), n.append("path").attr("d", "M21,0 L21,18");
	}, "zero_or_one"),
	one_or_more: h((e, t, r) => {
		e.append("defs").append("marker").attr("id", r + "_" + t + "-oneOrMoreStart").attr("class", "marker oneOrMore " + t).attr("refX", 18).attr("refY", 18).attr("markerWidth", 45).attr("markerHeight", 36).attr("orient", "auto").append("path").attr("d", "M0,18 Q 18,0 36,18 Q 18,36 0,18 M42,9 L42,27"), e.append("defs").append("marker").attr("id", r + "_" + t + "-oneOrMoreEnd").attr("class", "marker oneOrMore " + t).attr("refX", 27).attr("refY", 18).attr("markerWidth", 45).attr("markerHeight", 36).attr("orient", "auto").append("path").attr("d", "M3,9 L3,27 M9,18 Q27,0 45,18 Q27,36 9,18");
	}, "one_or_more"),
	zero_or_more: h((e, t, r) => {
		let i = e.append("defs").append("marker").attr("id", r + "_" + t + "-zeroOrMoreStart").attr("class", "marker zeroOrMore " + t).attr("refX", 18).attr("refY", 18).attr("markerWidth", 57).attr("markerHeight", 36).attr("orient", "auto");
		i.append("circle").attr("fill", "white").attr("cx", 48).attr("cy", 18).attr("r", 6), i.append("path").attr("d", "M0,18 Q18,0 36,18 Q18,36 0,18");
		let n = e.append("defs").append("marker").attr("id", r + "_" + t + "-zeroOrMoreEnd").attr("class", "marker zeroOrMore " + t).attr("refX", 39).attr("refY", 18).attr("markerWidth", 57).attr("markerHeight", 36).attr("orient", "auto");
		n.append("circle").attr("fill", "white").attr("cx", 9).attr("cy", 18).attr("r", 6), n.append("path").attr("d", "M21,18 Q39,0 57,18 Q39,36 21,18");
	}, "zero_or_more"),
	requirement_arrow: h((e, t, r) => {
		e.append("defs").append("marker").attr("id", r + "_" + t + "-requirement_arrowEnd").attr("refX", 20).attr("refY", 10).attr("markerWidth", 20).attr("markerHeight", 20).attr("orient", "auto").append("path").attr("d", `M0,0
      L20,10
      M20,10
      L0,20`);
	}, "requirement_arrow"),
	requirement_contains: h((e, t, r) => {
		let i = e.append("defs").append("marker").attr("id", r + "_" + t + "-requirement_containsStart").attr("refX", 0).attr("refY", 10).attr("markerWidth", 20).attr("markerHeight", 20).attr("orient", "auto").append("g");
		i.append("circle").attr("cx", 10).attr("cy", 10).attr("r", 9).attr("fill", "none"), i.append("line").attr("x1", 1).attr("x2", 19).attr("y1", 10).attr("y2", 10), i.append("line").attr("y1", 1).attr("y2", 19).attr("x1", 10).attr("x2", 10);
	}, "requirement_contains")
}, eie = {
	common: M1,
	getConfig: IA,
	insertCluster: eti,
	insertEdge: er5,
	insertEdgeLabel: erH,
	insertMarkers: er8,
	insertNode: erP,
	interpolateToCurve: VL,
	labelHelper: J2,
	log: wQ,
	positionEdgeLabel: erK
}, eit = {}, eir = h((e) => {
	for (let t of e) eit[t.name] = t;
}, "registerLayoutLoaders");
h(() => {
	eir([{
		name: "dagre",
		loader: h(async () => await r(() => import("./vendor-mermaid.Da1qoJoi.chunk.js"), []), "loader")
	}, {
		name: "cose-bilkent",
		loader: h(async () => await r(() => import("./vendor-mermaid.DLzty99m.chunk.js"), []), "loader")
	}]);
}, "registerDefaultLayoutLoaders")();
var eii = h(async (e, t) => {
	if (!(e.layoutAlgorithm in eit)) throw Error(`Unknown layout algorithm: ${e.layoutAlgorithm}`);
	let r = eit[e.layoutAlgorithm];
	return (await r.loader()).render(e, t, eie, { algorithm: r.algorithm });
}, "render"), ein = h((e = "", { fallback: t = "dagre" } = {}) => {
	if (e in eit) return e;
	if (t in eit) return wQ.warn(`Layout algorithm ${e} is not registered. Using ${t} as fallback.`), t;
	throw Error(`Both layout algorithms ${e} and ${t} are not registered.`);
}, "getRegisteredLayoutAlgorithm"), eia = function() {
	var e = h(function(e, t, r, i) {
		for (r = r || {}, i = e.length; i--; r[e[i]] = t);
		return r;
	}, "o"), t = [1, 18], r = [1, 19], i = [1, 20], n = [1, 41], a = [1, 42], s = [1, 26], o = [1, 24], l = [1, 25], u = [1, 32], d = [1, 33], p = [1, 34], f = [1, 45], g = [1, 35], m = [1, 36], y = [1, 37], v = [1, 38], x = [1, 27], b = [1, 28], w = [1, 29], k = [1, 30], T = [1, 31], _ = [1, 44], E = [1, 46], C = [1, 43], S = [1, 47], A = [1, 9], L = [
		1,
		8,
		9
	], R = [1, 58], N = [1, 59], I = [1, 60], M = [1, 61], D = [1, 62], O = [1, 63], $ = [1, 64], P = [
		1,
		8,
		9,
		41
	], B = [1, 76], F = [
		1,
		8,
		9,
		12,
		13,
		22,
		39,
		41,
		44,
		68,
		69,
		70,
		71,
		72,
		73,
		74,
		79,
		81
	], z = [
		1,
		8,
		9,
		12,
		13,
		18,
		20,
		22,
		39,
		41,
		44,
		50,
		60,
		68,
		69,
		70,
		71,
		72,
		73,
		74,
		79,
		81,
		86,
		100,
		102,
		103
	], U = [
		13,
		60,
		86,
		100,
		102,
		103
	], G = [
		13,
		60,
		73,
		74,
		86,
		100,
		102,
		103
	], q = [
		13,
		60,
		68,
		69,
		70,
		71,
		72,
		86,
		100,
		102,
		103
	], j = [1, 100], W = [1, 117], Y = [1, 113], V = [1, 109], H = [1, 115], X = [1, 110], K = [1, 111], Z = [1, 112], Q = [1, 114], J = [1, 116], ee = [
		22,
		48,
		60,
		61,
		82,
		86,
		87,
		88,
		89,
		90
	], et = [
		1,
		8,
		9,
		39,
		41,
		44
	], er = [
		1,
		8,
		9,
		22
	], ei = [1, 145], en = [
		1,
		8,
		9,
		61
	], ea = [
		1,
		8,
		9,
		22,
		48,
		60,
		61,
		82,
		86,
		87,
		88,
		89,
		90
	], es = {
		trace: h(function() {}, "trace"),
		yy: {},
		symbols_: {
			error: 2,
			start: 3,
			mermaidDoc: 4,
			statements: 5,
			graphConfig: 6,
			CLASS_DIAGRAM: 7,
			NEWLINE: 8,
			EOF: 9,
			statement: 10,
			classLabel: 11,
			SQS: 12,
			STR: 13,
			SQE: 14,
			namespaceName: 15,
			alphaNumToken: 16,
			classLiteralName: 17,
			DOT: 18,
			className: 19,
			GENERICTYPE: 20,
			relationStatement: 21,
			LABEL: 22,
			namespaceStatement: 23,
			classStatement: 24,
			memberStatement: 25,
			annotationStatement: 26,
			clickStatement: 27,
			styleStatement: 28,
			cssClassStatement: 29,
			noteStatement: 30,
			classDefStatement: 31,
			direction: 32,
			acc_title: 33,
			acc_title_value: 34,
			acc_descr: 35,
			acc_descr_value: 36,
			acc_descr_multiline_value: 37,
			namespaceIdentifier: 38,
			STRUCT_START: 39,
			classStatements: 40,
			STRUCT_STOP: 41,
			NAMESPACE: 42,
			classIdentifier: 43,
			STYLE_SEPARATOR: 44,
			members: 45,
			CLASS: 46,
			emptyBody: 47,
			SPACE: 48,
			ANNOTATION_START: 49,
			ANNOTATION_END: 50,
			MEMBER: 51,
			SEPARATOR: 52,
			relation: 53,
			NOTE_FOR: 54,
			noteText: 55,
			NOTE: 56,
			CLASSDEF: 57,
			classList: 58,
			stylesOpt: 59,
			ALPHA: 60,
			COMMA: 61,
			direction_tb: 62,
			direction_bt: 63,
			direction_rl: 64,
			direction_lr: 65,
			relationType: 66,
			lineType: 67,
			AGGREGATION: 68,
			EXTENSION: 69,
			COMPOSITION: 70,
			DEPENDENCY: 71,
			LOLLIPOP: 72,
			LINE: 73,
			DOTTED_LINE: 74,
			CALLBACK: 75,
			LINK: 76,
			LINK_TARGET: 77,
			CLICK: 78,
			CALLBACK_NAME: 79,
			CALLBACK_ARGS: 80,
			HREF: 81,
			STYLE: 82,
			CSSCLASS: 83,
			style: 84,
			styleComponent: 85,
			NUM: 86,
			COLON: 87,
			UNIT: 88,
			BRKT: 89,
			PCT: 90,
			commentToken: 91,
			textToken: 92,
			graphCodeTokens: 93,
			textNoTagsToken: 94,
			TAGSTART: 95,
			TAGEND: 96,
			"==": 97,
			"--": 98,
			DEFAULT: 99,
			MINUS: 100,
			keywords: 101,
			UNICODE_TEXT: 102,
			BQUOTE_STR: 103,
			$accept: 0,
			$end: 1
		},
		terminals_: {
			2: "error",
			7: "CLASS_DIAGRAM",
			8: "NEWLINE",
			9: "EOF",
			12: "SQS",
			13: "STR",
			14: "SQE",
			18: "DOT",
			20: "GENERICTYPE",
			22: "LABEL",
			33: "acc_title",
			34: "acc_title_value",
			35: "acc_descr",
			36: "acc_descr_value",
			37: "acc_descr_multiline_value",
			39: "STRUCT_START",
			41: "STRUCT_STOP",
			42: "NAMESPACE",
			44: "STYLE_SEPARATOR",
			46: "CLASS",
			48: "SPACE",
			49: "ANNOTATION_START",
			50: "ANNOTATION_END",
			51: "MEMBER",
			52: "SEPARATOR",
			54: "NOTE_FOR",
			56: "NOTE",
			57: "CLASSDEF",
			60: "ALPHA",
			61: "COMMA",
			62: "direction_tb",
			63: "direction_bt",
			64: "direction_rl",
			65: "direction_lr",
			68: "AGGREGATION",
			69: "EXTENSION",
			70: "COMPOSITION",
			71: "DEPENDENCY",
			72: "LOLLIPOP",
			73: "LINE",
			74: "DOTTED_LINE",
			75: "CALLBACK",
			76: "LINK",
			77: "LINK_TARGET",
			78: "CLICK",
			79: "CALLBACK_NAME",
			80: "CALLBACK_ARGS",
			81: "HREF",
			82: "STYLE",
			83: "CSSCLASS",
			86: "NUM",
			87: "COLON",
			88: "UNIT",
			89: "BRKT",
			90: "PCT",
			93: "graphCodeTokens",
			95: "TAGSTART",
			96: "TAGEND",
			97: "==",
			98: "--",
			99: "DEFAULT",
			100: "MINUS",
			101: "keywords",
			102: "UNICODE_TEXT",
			103: "BQUOTE_STR"
		},
		productions_: [
			0,
			[3, 1],
			[3, 1],
			[4, 1],
			[6, 4],
			[5, 1],
			[5, 2],
			[5, 3],
			[11, 3],
			[15, 1],
			[15, 1],
			[15, 3],
			[15, 2],
			[19, 1],
			[19, 3],
			[19, 1],
			[19, 2],
			[19, 2],
			[19, 2],
			[10, 1],
			[10, 2],
			[10, 1],
			[10, 1],
			[10, 1],
			[10, 1],
			[10, 1],
			[10, 1],
			[10, 1],
			[10, 1],
			[10, 1],
			[10, 1],
			[10, 2],
			[10, 2],
			[10, 1],
			[23, 4],
			[23, 5],
			[38, 2],
			[40, 1],
			[40, 2],
			[40, 3],
			[24, 1],
			[24, 3],
			[24, 4],
			[24, 3],
			[24, 6],
			[43, 2],
			[43, 3],
			[47, 0],
			[47, 2],
			[47, 2],
			[26, 4],
			[45, 1],
			[45, 2],
			[25, 1],
			[25, 2],
			[25, 1],
			[25, 1],
			[21, 3],
			[21, 4],
			[21, 4],
			[21, 5],
			[30, 3],
			[30, 2],
			[31, 3],
			[58, 1],
			[58, 3],
			[32, 1],
			[32, 1],
			[32, 1],
			[32, 1],
			[53, 3],
			[53, 2],
			[53, 2],
			[53, 1],
			[66, 1],
			[66, 1],
			[66, 1],
			[66, 1],
			[66, 1],
			[67, 1],
			[67, 1],
			[27, 3],
			[27, 4],
			[27, 3],
			[27, 4],
			[27, 4],
			[27, 5],
			[27, 3],
			[27, 4],
			[27, 4],
			[27, 5],
			[27, 4],
			[27, 5],
			[27, 5],
			[27, 6],
			[28, 3],
			[29, 3],
			[59, 1],
			[59, 3],
			[84, 1],
			[84, 2],
			[85, 1],
			[85, 1],
			[85, 1],
			[85, 1],
			[85, 1],
			[85, 1],
			[85, 1],
			[85, 1],
			[85, 1],
			[91, 1],
			[91, 1],
			[92, 1],
			[92, 1],
			[92, 1],
			[92, 1],
			[92, 1],
			[92, 1],
			[92, 1],
			[94, 1],
			[94, 1],
			[94, 1],
			[94, 1],
			[16, 1],
			[16, 1],
			[16, 1],
			[16, 1],
			[17, 1],
			[55, 1]
		],
		performAction: h(function(e, t, r, i, n, a, s) {
			var o = a.length - 1;
			switch (n) {
				case 8:
					this.$ = a[o - 1];
					break;
				case 9:
				case 10:
				case 13:
				case 15:
					this.$ = a[o];
					break;
				case 11:
				case 14:
					this.$ = a[o - 2] + "." + a[o];
					break;
				case 12:
				case 16:
				case 100:
					this.$ = a[o - 1] + a[o];
					break;
				case 17:
				case 18:
					this.$ = a[o - 1] + "~" + a[o] + "~";
					break;
				case 19:
					i.addRelation(a[o]);
					break;
				case 20:
					a[o - 1].title = i.cleanupLabel(a[o]), i.addRelation(a[o - 1]);
					break;
				case 31:
					this.$ = a[o].trim(), i.setAccTitle(this.$);
					break;
				case 32:
				case 33:
					this.$ = a[o].trim(), i.setAccDescription(this.$);
					break;
				case 34:
					i.addClassesToNamespace(a[o - 3], a[o - 1]);
					break;
				case 35:
					i.addClassesToNamespace(a[o - 4], a[o - 1]);
					break;
				case 36:
					this.$ = a[o], i.addNamespace(a[o]);
					break;
				case 37:
				case 51:
				case 64:
				case 97:
					this.$ = [a[o]];
					break;
				case 38:
					this.$ = [a[o - 1]];
					break;
				case 39:
					a[o].unshift(a[o - 2]), this.$ = a[o];
					break;
				case 41:
					i.setCssClass(a[o - 2], a[o]);
					break;
				case 42:
					i.addMembers(a[o - 3], a[o - 1]);
					break;
				case 44:
					i.setCssClass(a[o - 5], a[o - 3]), i.addMembers(a[o - 5], a[o - 1]);
					break;
				case 45:
					this.$ = a[o], i.addClass(a[o]);
					break;
				case 46:
					this.$ = a[o - 1], i.addClass(a[o - 1]), i.setClassLabel(a[o - 1], a[o]);
					break;
				case 50:
					i.addAnnotation(a[o], a[o - 2]);
					break;
				case 52:
					a[o].push(a[o - 1]), this.$ = a[o];
					break;
				case 53:
				case 55:
				case 56: break;
				case 54:
					i.addMember(a[o - 1], i.cleanupLabel(a[o]));
					break;
				case 57:
					this.$ = {
						id1: a[o - 2],
						id2: a[o],
						relation: a[o - 1],
						relationTitle1: "none",
						relationTitle2: "none"
					};
					break;
				case 58:
					this.$ = {
						id1: a[o - 3],
						id2: a[o],
						relation: a[o - 1],
						relationTitle1: a[o - 2],
						relationTitle2: "none"
					};
					break;
				case 59:
					this.$ = {
						id1: a[o - 3],
						id2: a[o],
						relation: a[o - 2],
						relationTitle1: "none",
						relationTitle2: a[o - 1]
					};
					break;
				case 60:
					this.$ = {
						id1: a[o - 4],
						id2: a[o],
						relation: a[o - 2],
						relationTitle1: a[o - 3],
						relationTitle2: a[o - 1]
					};
					break;
				case 61:
					i.addNote(a[o], a[o - 1]);
					break;
				case 62:
					i.addNote(a[o]);
					break;
				case 63:
					this.$ = a[o - 2], i.defineClass(a[o - 1], a[o]);
					break;
				case 65:
					this.$ = a[o - 2].concat([a[o]]);
					break;
				case 66:
					i.setDirection("TB");
					break;
				case 67:
					i.setDirection("BT");
					break;
				case 68:
					i.setDirection("RL");
					break;
				case 69:
					i.setDirection("LR");
					break;
				case 70:
					this.$ = {
						type1: a[o - 2],
						type2: a[o],
						lineType: a[o - 1]
					};
					break;
				case 71:
					this.$ = {
						type1: "none",
						type2: a[o],
						lineType: a[o - 1]
					};
					break;
				case 72:
					this.$ = {
						type1: a[o - 1],
						type2: "none",
						lineType: a[o]
					};
					break;
				case 73:
					this.$ = {
						type1: "none",
						type2: "none",
						lineType: a[o]
					};
					break;
				case 74:
					this.$ = i.relationType.AGGREGATION;
					break;
				case 75:
					this.$ = i.relationType.EXTENSION;
					break;
				case 76:
					this.$ = i.relationType.COMPOSITION;
					break;
				case 77:
					this.$ = i.relationType.DEPENDENCY;
					break;
				case 78:
					this.$ = i.relationType.LOLLIPOP;
					break;
				case 79:
					this.$ = i.lineType.LINE;
					break;
				case 80:
					this.$ = i.lineType.DOTTED_LINE;
					break;
				case 81:
				case 87:
					this.$ = a[o - 2], i.setClickEvent(a[o - 1], a[o]);
					break;
				case 82:
				case 88:
					this.$ = a[o - 3], i.setClickEvent(a[o - 2], a[o - 1]), i.setTooltip(a[o - 2], a[o]);
					break;
				case 83:
					this.$ = a[o - 2], i.setLink(a[o - 1], a[o]);
					break;
				case 84:
					this.$ = a[o - 3], i.setLink(a[o - 2], a[o - 1], a[o]);
					break;
				case 85:
					this.$ = a[o - 3], i.setLink(a[o - 2], a[o - 1]), i.setTooltip(a[o - 2], a[o]);
					break;
				case 86:
					this.$ = a[o - 4], i.setLink(a[o - 3], a[o - 2], a[o]), i.setTooltip(a[o - 3], a[o - 1]);
					break;
				case 89:
					this.$ = a[o - 3], i.setClickEvent(a[o - 2], a[o - 1], a[o]);
					break;
				case 90:
					this.$ = a[o - 4], i.setClickEvent(a[o - 3], a[o - 2], a[o - 1]), i.setTooltip(a[o - 3], a[o]);
					break;
				case 91:
					this.$ = a[o - 3], i.setLink(a[o - 2], a[o]);
					break;
				case 92:
					this.$ = a[o - 4], i.setLink(a[o - 3], a[o - 1], a[o]);
					break;
				case 93:
					this.$ = a[o - 4], i.setLink(a[o - 3], a[o - 1]), i.setTooltip(a[o - 3], a[o]);
					break;
				case 94:
					this.$ = a[o - 5], i.setLink(a[o - 4], a[o - 2], a[o]), i.setTooltip(a[o - 4], a[o - 1]);
					break;
				case 95:
					this.$ = a[o - 2], i.setCssStyle(a[o - 1], a[o]);
					break;
				case 96:
					i.setCssClass(a[o - 1], a[o]);
					break;
				case 98: a[o - 2].push(a[o]), this.$ = a[o - 2];
			}
		}, "anonymous"),
		table: [
			{
				3: 1,
				4: 2,
				5: 3,
				6: 4,
				7: [1, 6],
				10: 5,
				16: 39,
				17: 40,
				19: 21,
				21: 7,
				23: 8,
				24: 9,
				25: 10,
				26: 11,
				27: 12,
				28: 13,
				29: 14,
				30: 15,
				31: 16,
				32: 17,
				33: t,
				35: r,
				37: i,
				38: 22,
				42: n,
				43: 23,
				46: a,
				49: s,
				51: o,
				52: l,
				54: u,
				56: d,
				57: p,
				60: f,
				62: g,
				63: m,
				64: y,
				65: v,
				75: x,
				76: b,
				78: w,
				82: k,
				83: T,
				86: _,
				100: E,
				102: C,
				103: S
			},
			{ 1: [3] },
			{ 1: [2, 1] },
			{ 1: [2, 2] },
			{ 1: [2, 3] },
			e(A, [2, 5], { 8: [1, 48] }),
			{ 8: [1, 49] },
			e(L, [2, 19], { 22: [1, 50] }),
			e(L, [2, 21]),
			e(L, [2, 22]),
			e(L, [2, 23]),
			e(L, [2, 24]),
			e(L, [2, 25]),
			e(L, [2, 26]),
			e(L, [2, 27]),
			e(L, [2, 28]),
			e(L, [2, 29]),
			e(L, [2, 30]),
			{ 34: [1, 51] },
			{ 36: [1, 52] },
			e(L, [2, 33]),
			e(L, [2, 53], {
				53: 53,
				66: 56,
				67: 57,
				13: [1, 54],
				22: [1, 55],
				68: R,
				69: N,
				70: I,
				71: M,
				72: D,
				73: O,
				74: $
			}),
			{ 39: [1, 65] },
			e(P, [2, 40], {
				39: [1, 67],
				44: [1, 66]
			}),
			e(L, [2, 55]),
			e(L, [2, 56]),
			{
				16: 68,
				60: f,
				86: _,
				100: E,
				102: C
			},
			{
				16: 39,
				17: 40,
				19: 69,
				60: f,
				86: _,
				100: E,
				102: C,
				103: S
			},
			{
				16: 39,
				17: 40,
				19: 70,
				60: f,
				86: _,
				100: E,
				102: C,
				103: S
			},
			{
				16: 39,
				17: 40,
				19: 71,
				60: f,
				86: _,
				100: E,
				102: C,
				103: S
			},
			{ 60: [1, 72] },
			{ 13: [1, 73] },
			{
				16: 39,
				17: 40,
				19: 74,
				60: f,
				86: _,
				100: E,
				102: C,
				103: S
			},
			{
				13: B,
				55: 75
			},
			{
				58: 77,
				60: [1, 78]
			},
			e(L, [2, 66]),
			e(L, [2, 67]),
			e(L, [2, 68]),
			e(L, [2, 69]),
			e(F, [2, 13], {
				16: 39,
				17: 40,
				19: 80,
				18: [1, 79],
				20: [1, 81],
				60: f,
				86: _,
				100: E,
				102: C,
				103: S
			}),
			e(F, [2, 15], { 20: [1, 82] }),
			{
				15: 83,
				16: 84,
				17: 85,
				60: f,
				86: _,
				100: E,
				102: C,
				103: S
			},
			{
				16: 39,
				17: 40,
				19: 86,
				60: f,
				86: _,
				100: E,
				102: C,
				103: S
			},
			e(z, [2, 123]),
			e(z, [2, 124]),
			e(z, [2, 125]),
			e(z, [2, 126]),
			e([
				1,
				8,
				9,
				12,
				13,
				20,
				22,
				39,
				41,
				44,
				68,
				69,
				70,
				71,
				72,
				73,
				74,
				79,
				81
			], [2, 127]),
			e(A, [2, 6], {
				10: 5,
				21: 7,
				23: 8,
				24: 9,
				25: 10,
				26: 11,
				27: 12,
				28: 13,
				29: 14,
				30: 15,
				31: 16,
				32: 17,
				19: 21,
				38: 22,
				43: 23,
				16: 39,
				17: 40,
				5: 87,
				33: t,
				35: r,
				37: i,
				42: n,
				46: a,
				49: s,
				51: o,
				52: l,
				54: u,
				56: d,
				57: p,
				60: f,
				62: g,
				63: m,
				64: y,
				65: v,
				75: x,
				76: b,
				78: w,
				82: k,
				83: T,
				86: _,
				100: E,
				102: C,
				103: S
			}),
			{
				5: 88,
				10: 5,
				16: 39,
				17: 40,
				19: 21,
				21: 7,
				23: 8,
				24: 9,
				25: 10,
				26: 11,
				27: 12,
				28: 13,
				29: 14,
				30: 15,
				31: 16,
				32: 17,
				33: t,
				35: r,
				37: i,
				38: 22,
				42: n,
				43: 23,
				46: a,
				49: s,
				51: o,
				52: l,
				54: u,
				56: d,
				57: p,
				60: f,
				62: g,
				63: m,
				64: y,
				65: v,
				75: x,
				76: b,
				78: w,
				82: k,
				83: T,
				86: _,
				100: E,
				102: C,
				103: S
			},
			e(L, [2, 20]),
			e(L, [2, 31]),
			e(L, [2, 32]),
			{
				13: [1, 90],
				16: 39,
				17: 40,
				19: 89,
				60: f,
				86: _,
				100: E,
				102: C,
				103: S
			},
			{
				53: 91,
				66: 56,
				67: 57,
				68: R,
				69: N,
				70: I,
				71: M,
				72: D,
				73: O,
				74: $
			},
			e(L, [2, 54]),
			{
				67: 92,
				73: O,
				74: $
			},
			e(U, [2, 73], {
				66: 93,
				68: R,
				69: N,
				70: I,
				71: M,
				72: D
			}),
			e(G, [2, 74]),
			e(G, [2, 75]),
			e(G, [2, 76]),
			e(G, [2, 77]),
			e(G, [2, 78]),
			e(q, [2, 79]),
			e(q, [2, 80]),
			{
				8: [1, 95],
				24: 96,
				40: 94,
				43: 23,
				46: a
			},
			{
				16: 97,
				60: f,
				86: _,
				100: E,
				102: C
			},
			{
				41: [1, 99],
				45: 98,
				51: j
			},
			{ 50: [1, 101] },
			{ 13: [1, 102] },
			{ 13: [1, 103] },
			{
				79: [1, 104],
				81: [1, 105]
			},
			{
				22: W,
				48: Y,
				59: 106,
				60: V,
				82: H,
				84: 107,
				85: 108,
				86: X,
				87: K,
				88: Z,
				89: Q,
				90: J
			},
			{ 60: [1, 118] },
			{
				13: B,
				55: 119
			},
			e(L, [2, 62]),
			e(L, [2, 128]),
			{
				22: W,
				48: Y,
				59: 120,
				60: V,
				61: [1, 121],
				82: H,
				84: 107,
				85: 108,
				86: X,
				87: K,
				88: Z,
				89: Q,
				90: J
			},
			e(ee, [2, 64]),
			{
				16: 39,
				17: 40,
				19: 122,
				60: f,
				86: _,
				100: E,
				102: C,
				103: S
			},
			e(F, [2, 16]),
			e(F, [2, 17]),
			e(F, [2, 18]),
			{ 39: [2, 36] },
			{
				15: 124,
				16: 84,
				17: 85,
				18: [1, 123],
				39: [2, 9],
				60: f,
				86: _,
				100: E,
				102: C,
				103: S
			},
			{ 39: [2, 10] },
			e(et, [2, 45], {
				11: 125,
				12: [1, 126]
			}),
			e(A, [2, 7]),
			{ 9: [1, 127] },
			e(er, [2, 57]),
			{
				16: 39,
				17: 40,
				19: 128,
				60: f,
				86: _,
				100: E,
				102: C,
				103: S
			},
			{
				13: [1, 130],
				16: 39,
				17: 40,
				19: 129,
				60: f,
				86: _,
				100: E,
				102: C,
				103: S
			},
			e(U, [2, 72], {
				66: 131,
				68: R,
				69: N,
				70: I,
				71: M,
				72: D
			}),
			e(U, [2, 71]),
			{ 41: [1, 132] },
			{
				24: 96,
				40: 133,
				43: 23,
				46: a
			},
			{
				8: [1, 134],
				41: [2, 37]
			},
			e(P, [2, 41], { 39: [1, 135] }),
			{ 41: [1, 136] },
			e(P, [2, 43]),
			{
				41: [2, 51],
				45: 137,
				51: j
			},
			{
				16: 39,
				17: 40,
				19: 138,
				60: f,
				86: _,
				100: E,
				102: C,
				103: S
			},
			e(L, [2, 81], { 13: [1, 139] }),
			e(L, [2, 83], {
				13: [1, 141],
				77: [1, 140]
			}),
			e(L, [2, 87], {
				13: [1, 142],
				80: [1, 143]
			}),
			{ 13: [1, 144] },
			e(L, [2, 95], { 61: ei }),
			e(en, [2, 97], {
				85: 146,
				22: W,
				48: Y,
				60: V,
				82: H,
				86: X,
				87: K,
				88: Z,
				89: Q,
				90: J
			}),
			e(ea, [2, 99]),
			e(ea, [2, 101]),
			e(ea, [2, 102]),
			e(ea, [2, 103]),
			e(ea, [2, 104]),
			e(ea, [2, 105]),
			e(ea, [2, 106]),
			e(ea, [2, 107]),
			e(ea, [2, 108]),
			e(ea, [2, 109]),
			e(L, [2, 96]),
			e(L, [2, 61]),
			e(L, [2, 63], { 61: ei }),
			{ 60: [1, 147] },
			e(F, [2, 14]),
			{
				15: 148,
				16: 84,
				17: 85,
				60: f,
				86: _,
				100: E,
				102: C,
				103: S
			},
			{ 39: [2, 12] },
			e(et, [2, 46]),
			{ 13: [1, 149] },
			{ 1: [2, 4] },
			e(er, [2, 59]),
			e(er, [2, 58]),
			{
				16: 39,
				17: 40,
				19: 150,
				60: f,
				86: _,
				100: E,
				102: C,
				103: S
			},
			e(U, [2, 70]),
			e(L, [2, 34]),
			{ 41: [1, 151] },
			{
				24: 96,
				40: 152,
				41: [2, 38],
				43: 23,
				46: a
			},
			{
				45: 153,
				51: j
			},
			e(P, [2, 42]),
			{ 41: [2, 52] },
			e(L, [2, 50]),
			e(L, [2, 82]),
			e(L, [2, 84]),
			e(L, [2, 85], { 77: [1, 154] }),
			e(L, [2, 88]),
			e(L, [2, 89], { 13: [1, 155] }),
			e(L, [2, 91], {
				13: [1, 157],
				77: [1, 156]
			}),
			{
				22: W,
				48: Y,
				60: V,
				82: H,
				84: 158,
				85: 108,
				86: X,
				87: K,
				88: Z,
				89: Q,
				90: J
			},
			e(ea, [2, 100]),
			e(ee, [2, 65]),
			{ 39: [2, 11] },
			{ 14: [1, 159] },
			e(er, [2, 60]),
			e(L, [2, 35]),
			{ 41: [2, 39] },
			{ 41: [1, 160] },
			e(L, [2, 86]),
			e(L, [2, 90]),
			e(L, [2, 92]),
			e(L, [2, 93], { 77: [1, 161] }),
			e(en, [2, 98], {
				85: 146,
				22: W,
				48: Y,
				60: V,
				82: H,
				86: X,
				87: K,
				88: Z,
				89: Q,
				90: J
			}),
			e(et, [2, 8]),
			e(P, [2, 44]),
			e(L, [2, 94])
		],
		defaultActions: {
			2: [2, 1],
			3: [2, 2],
			4: [2, 3],
			83: [2, 36],
			85: [2, 10],
			124: [2, 12],
			127: [2, 4],
			137: [2, 52],
			148: [2, 11],
			152: [2, 39]
		},
		parseError: h(function(e, t) {
			if (t.recoverable) this.trace(e);
			else {
				var r = Error(e);
				throw r.hash = t, r;
			}
		}, "parseError"),
		parse: h(function(e) {
			var t = this, r = [0], i = [], n = [null], a = [], s = this.table, o = "", l = 0, u = 0, d = 0, p = a.slice.call(arguments, 1), f = Object.create(this.lexer), g = {};
			for (var m in this.yy) Object.prototype.hasOwnProperty.call(this.yy, m) && (g[m] = this.yy[m]);
			f.setInput(e, g), g.lexer = f, g.parser = this, typeof f.yylloc > "u" && (f.yylloc = {});
			var y = f.yylloc;
			a.push(y);
			var v = f.options && f.options.ranges;
			function x() {
				var e;
				return "number" != typeof (e = i.pop() || f.lex() || 1) && (e instanceof Array && (e = (i = e).pop()), e = t.symbols_[e] || e), e;
			}
			"function" == typeof g.parseError ? this.parseError = g.parseError : this.parseError = Object.getPrototypeOf(this).parseError, h(function(e) {
				r.length = r.length - 2 * e, n.length = n.length - e, a.length = a.length - e;
			}, "popStack"), h(x, "lex");
			for (var b, w, k, T, _, E, C, S, A, L = {};;) {
				if (k = r[r.length - 1], this.defaultActions[k] ? T = this.defaultActions[k] : ((null === b || typeof b > "u") && (b = x()), T = s[k] && s[k][b]), typeof T > "u" || !T.length || !T[0]) {
					var R = "";
					for (E in A = [], s[k]) this.terminals_[E] && E > 2 && A.push("'" + this.terminals_[E] + "'");
					R = f.showPosition ? "Parse error on line " + (l + 1) + `:
` + f.showPosition() + `
Expecting ` + A.join(", ") + ", got '" + (this.terminals_[b] || b) + "'" : "Parse error on line " + (l + 1) + ": Unexpected " + (1 == b ? "end of input" : "'" + (this.terminals_[b] || b) + "'"), this.parseError(R, {
						text: f.match,
						token: this.terminals_[b] || b,
						line: f.yylineno,
						loc: y,
						expected: A
					});
				}
				if (T[0] instanceof Array && T.length > 1) throw Error("Parse Error: multiple actions possible at state: " + k + ", token: " + b);
				switch (T[0]) {
					case 1:
						r.push(b), n.push(f.yytext), a.push(f.yylloc), r.push(T[1]), b = null, w ? (b = w, w = null) : (u = f.yyleng, o = f.yytext, l = f.yylineno, y = f.yylloc, d > 0 && d--);
						break;
					case 2:
						if (C = this.productions_[T[1]][1], L.$ = n[n.length - C], L._$ = {
							first_line: a[a.length - (C || 1)].first_line,
							last_line: a[a.length - 1].last_line,
							first_column: a[a.length - (C || 1)].first_column,
							last_column: a[a.length - 1].last_column
						}, v && (L._$.range = [a[a.length - (C || 1)].range[0], a[a.length - 1].range[1]]), "u" > typeof (_ = this.performAction.apply(L, [
							o,
							u,
							l,
							g,
							T[1],
							n,
							a
						].concat(p)))) return _;
						C && (r = r.slice(0, -1 * C * 2), n = n.slice(0, -1 * C), a = a.slice(0, -1 * C)), r.push(this.productions_[T[1]][0]), n.push(L.$), a.push(L._$), S = s[r[r.length - 2]][r[r.length - 1]], r.push(S);
						break;
					case 3: return !0;
				}
			}
			return !0;
		}, "parse")
	};
	function eo() {
		this.yy = {};
	}
	return es.lexer = {
		EOF: 1,
		parseError: h(function(e, t) {
			if (this.yy.parser) this.yy.parser.parseError(e, t);
			else throw Error(e);
		}, "parseError"),
		setInput: h(function(e, t) {
			return this.yy = t || this.yy || {}, this._input = e, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
				first_line: 1,
				first_column: 0,
				last_line: 1,
				last_column: 0
			}, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
		}, "setInput"),
		input: h(function() {
			var e = this._input[0];
			return this.yytext += e, this.yyleng++, this.offset++, this.match += e, this.matched += e, e.match(/(?:\r\n?|\n).*/g) ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), e;
		}, "input"),
		unput: h(function(e) {
			var t = e.length, r = e.split(/(?:\r\n?|\n)/g);
			this._input = e + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - t), this.offset -= t;
			var i = this.match.split(/(?:\r\n?|\n)/g);
			this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), r.length - 1 && (this.yylineno -= r.length - 1);
			var n = this.yylloc.range;
			return this.yylloc = {
				first_line: this.yylloc.first_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.first_column,
				last_column: r ? (r.length === i.length ? this.yylloc.first_column : 0) + i[i.length - r.length].length - r[0].length : this.yylloc.first_column - t
			}, this.options.ranges && (this.yylloc.range = [n[0], n[0] + this.yyleng - t]), this.yyleng = this.yytext.length, this;
		}, "unput"),
		more: h(function() {
			return this._more = !0, this;
		}, "more"),
		reject: h(function() {
			return this.options.backtrack_lexer ? (this._backtrack = !0, this) : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "reject"),
		less: h(function(e) {
			this.unput(this.match.slice(e));
		}, "less"),
		pastInput: h(function() {
			var e = this.matched.substr(0, this.matched.length - this.match.length);
			return (e.length > 20 ? "..." : "") + e.substr(-20).replace(/\n/g, "");
		}, "pastInput"),
		upcomingInput: h(function() {
			var e = this.match;
			return e.length < 20 && (e += this._input.substr(0, 20 - e.length)), (e.substr(0, 20) + (e.length > 20 ? "..." : "")).replace(/\n/g, "");
		}, "upcomingInput"),
		showPosition: h(function() {
			var e = this.pastInput(), t = Array(e.length + 1).join("-");
			return e + this.upcomingInput() + `
` + t + "^";
		}, "showPosition"),
		test_match: h(function(e, t) {
			var r, i, n;
			if (this.options.backtrack_lexer && (n = {
				yylineno: this.yylineno,
				yylloc: {
					first_line: this.yylloc.first_line,
					last_line: this.last_line,
					first_column: this.yylloc.first_column,
					last_column: this.yylloc.last_column
				},
				yytext: this.yytext,
				match: this.match,
				matches: this.matches,
				matched: this.matched,
				yyleng: this.yyleng,
				offset: this.offset,
				_more: this._more,
				_input: this._input,
				yy: this.yy,
				conditionStack: this.conditionStack.slice(0),
				done: this.done
			}, this.options.ranges && (n.yylloc.range = this.yylloc.range.slice(0))), (i = e[0].match(/(?:\r\n?|\n).*/g)) && (this.yylineno += i.length), this.yylloc = {
				first_line: this.yylloc.last_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.last_column,
				last_column: i ? i[i.length - 1].length - i[i.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + e[0].length
			}, this.yytext += e[0], this.match += e[0], this.matches = e, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(e[0].length), this.matched += e[0], r = this.performAction.call(this, this.yy, this, t, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), r) return r;
			if (this._backtrack) for (var a in n) this[a] = n[a];
			return !1;
		}, "test_match"),
		next: h(function() {
			if (this.done) return this.EOF;
			this._input || (this.done = !0), this._more || (this.yytext = "", this.match = "");
			for (var e, t, r, i, n = this._currentRules(), a = 0; a < n.length; a++) if ((r = this._input.match(this.rules[n[a]])) && (!t || r[0].length > t[0].length)) {
				if (t = r, i = a, this.options.backtrack_lexer) {
					if (!1 !== (e = this.test_match(r, n[a]))) return e;
					if (!this._backtrack) return !1;
					t = !1;
					continue;
				} else if (!this.options.flex) break;
			}
			return t ? !1 !== (e = this.test_match(t, n[i])) && e : "" === this._input ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "next"),
		lex: h(function() {
			return this.next() || this.lex();
		}, "lex"),
		begin: h(function(e) {
			this.conditionStack.push(e);
		}, "begin"),
		popState: h(function() {
			return this.conditionStack.length - 1 > 0 ? this.conditionStack.pop() : this.conditionStack[0];
		}, "popState"),
		_currentRules: h(function() {
			return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
		}, "_currentRules"),
		topState: h(function(e) {
			return (e = this.conditionStack.length - 1 - Math.abs(e || 0)) >= 0 ? this.conditionStack[e] : "INITIAL";
		}, "topState"),
		pushState: h(function(e) {
			this.begin(e);
		}, "pushState"),
		stateStackSize: h(function() {
			return this.conditionStack.length;
		}, "stateStackSize"),
		options: {},
		performAction: h(function(e, t, r, i) {
			switch (r) {
				case 0: return 62;
				case 1: return 63;
				case 2: return 64;
				case 3: return 65;
				case 4:
				case 5:
				case 14:
				case 31:
				case 36:
				case 40:
				case 47: break;
				case 6: return this.begin("acc_title"), 33;
				case 7: return this.popState(), "acc_title_value";
				case 8: return this.begin("acc_descr"), 35;
				case 9: return this.popState(), "acc_descr_value";
				case 10:
					this.begin("acc_descr_multiline");
					break;
				case 11:
				case 19:
				case 22:
				case 24:
				case 58:
				case 61:
					this.popState();
					break;
				case 12: return "acc_descr_multiline_value";
				case 13:
				case 35: return 8;
				case 15:
				case 16: return 7;
				case 17:
				case 37:
				case 45: return "EDGE_STATE";
				case 18:
					this.begin("callback_name");
					break;
				case 20:
					this.popState(), this.begin("callback_args");
					break;
				case 21: return 79;
				case 23: return 80;
				case 25: return "STR";
				case 26:
					this.begin("string");
					break;
				case 27: return 82;
				case 28: return 57;
				case 29: return this.begin("namespace"), 42;
				case 30:
				case 39: return this.popState(), 8;
				case 32: return this.begin("namespace-body"), 39;
				case 33:
				case 43: return this.popState(), 41;
				case 34:
				case 44: return "EOF_IN_STRUCT";
				case 38: return this.begin("class"), 46;
				case 41: return this.popState(), this.popState(), 41;
				case 42: return this.begin("class-body"), 39;
				case 46: return "OPEN_IN_STRUCT";
				case 48: return "MEMBER";
				case 49: return 83;
				case 50: return 75;
				case 51: return 76;
				case 52: return 78;
				case 53: return 54;
				case 54: return 56;
				case 55: return 49;
				case 56: return 50;
				case 57: return 81;
				case 59: return "GENERICTYPE";
				case 60:
					this.begin("generic");
					break;
				case 62: return "BQUOTE_STR";
				case 63:
					this.begin("bqstring");
					break;
				case 64:
				case 65:
				case 66:
				case 67: return 77;
				case 68:
				case 69: return 69;
				case 70:
				case 71: return 71;
				case 72: return 70;
				case 73: return 68;
				case 74: return 72;
				case 75: return 73;
				case 76: return 74;
				case 77: return 22;
				case 78: return 44;
				case 79: return 100;
				case 80: return 18;
				case 81: return "PLUS";
				case 82: return 87;
				case 83: return 61;
				case 84:
				case 85: return 89;
				case 86: return 90;
				case 87:
				case 88: return "EQUALS";
				case 89: return 60;
				case 90: return 12;
				case 91: return 14;
				case 92: return "PUNCTUATION";
				case 93: return 86;
				case 94: return 102;
				case 95:
				case 96: return 48;
				case 97: return 9;
			}
		}, "anonymous"),
		rules: [
			/^(?:.*direction\s+TB[^\n]*)/,
			/^(?:.*direction\s+BT[^\n]*)/,
			/^(?:.*direction\s+RL[^\n]*)/,
			/^(?:.*direction\s+LR[^\n]*)/,
			/^(?:%%(?!\{)*[^\n]*(\r?\n?)+)/,
			/^(?:%%[^\n]*(\r?\n)*)/,
			/^(?:accTitle\s*:\s*)/,
			/^(?:(?!\n||)*[^\n]*)/,
			/^(?:accDescr\s*:\s*)/,
			/^(?:(?!\n||)*[^\n]*)/,
			/^(?:accDescr\s*\{\s*)/,
			/^(?:[\}])/,
			/^(?:[^\}]*)/,
			/^(?:\s*(\r?\n)+)/,
			/^(?:\s+)/,
			/^(?:classDiagram-v2\b)/,
			/^(?:classDiagram\b)/,
			/^(?:\[\*\])/,
			/^(?:call[\s]+)/,
			/^(?:\([\s]*\))/,
			/^(?:\()/,
			/^(?:[^(]*)/,
			/^(?:\))/,
			/^(?:[^)]*)/,
			/^(?:["])/,
			/^(?:[^"]*)/,
			/^(?:["])/,
			/^(?:style\b)/,
			/^(?:classDef\b)/,
			/^(?:namespace\b)/,
			/^(?:\s*(\r?\n)+)/,
			/^(?:\s+)/,
			/^(?:[{])/,
			/^(?:[}])/,
			/^(?:$)/,
			/^(?:\s*(\r?\n)+)/,
			/^(?:\s+)/,
			/^(?:\[\*\])/,
			/^(?:class\b)/,
			/^(?:\s*(\r?\n)+)/,
			/^(?:\s+)/,
			/^(?:[}])/,
			/^(?:[{])/,
			/^(?:[}])/,
			/^(?:$)/,
			/^(?:\[\*\])/,
			/^(?:[{])/,
			/^(?:[\n])/,
			/^(?:[^{}\n]*)/,
			/^(?:cssClass\b)/,
			/^(?:callback\b)/,
			/^(?:link\b)/,
			/^(?:click\b)/,
			/^(?:note for\b)/,
			/^(?:note\b)/,
			/^(?:<<)/,
			/^(?:>>)/,
			/^(?:href\b)/,
			/^(?:[~])/,
			/^(?:[^~]*)/,
			/^(?:~)/,
			/^(?:[`])/,
			/^(?:[^`]+)/,
			/^(?:[`])/,
			/^(?:_self\b)/,
			/^(?:_blank\b)/,
			/^(?:_parent\b)/,
			/^(?:_top\b)/,
			/^(?:\s*<\|)/,
			/^(?:\s*\|>)/,
			/^(?:\s*>)/,
			/^(?:\s*<)/,
			/^(?:\s*\*)/,
			/^(?:\s*o\b)/,
			/^(?:\s*\(\))/,
			/^(?:--)/,
			/^(?:\.\.)/,
			/^(?::{1}[^:\n;]+)/,
			/^(?::{3})/,
			/^(?:-)/,
			/^(?:\.)/,
			/^(?:\+)/,
			/^(?::)/,
			/^(?:,)/,
			/^(?:#)/,
			/^(?:#)/,
			/^(?:%)/,
			/^(?:=)/,
			/^(?:=)/,
			/^(?:\w+)/,
			/^(?:\[)/,
			/^(?:\])/,
			/^(?:[!"#$%&'*+,-.`?\\/])/,
			/^(?:[0-9]+)/,
			/^(?:[\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6]|[\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377]|[\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5]|[\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA]|[\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE]|[\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA]|[\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0]|[\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977]|[\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2]|[\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A]|[\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39]|[\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8]|[\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C]|[\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C]|[\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99]|[\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0]|[\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D]|[\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3]|[\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10]|[\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1]|[\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81]|[\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3]|[\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6]|[\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A]|[\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081]|[\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D]|[\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0]|[\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310]|[\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C]|[\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711]|[\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7]|[\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C]|[\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16]|[\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF]|[\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC]|[\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D]|[\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D]|[\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3]|[\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F]|[\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128]|[\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184]|[\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3]|[\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6]|[\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE]|[\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C]|[\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D]|[\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC]|[\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B]|[\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788]|[\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805]|[\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB]|[\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28]|[\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5]|[\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4]|[\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E]|[\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D]|[\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36]|[\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D]|[\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC]|[\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF]|[\uFFD2-\uFFD7\uFFDA-\uFFDC])/,
			/^(?:\s)/,
			/^(?:\s)/,
			/^(?:$)/
		],
		conditions: {
			"namespace-body": {
				rules: [
					26,
					33,
					34,
					35,
					36,
					37,
					38,
					49,
					50,
					51,
					52,
					53,
					54,
					55,
					56,
					57,
					60,
					63,
					64,
					65,
					66,
					67,
					68,
					69,
					70,
					71,
					72,
					73,
					74,
					75,
					76,
					77,
					78,
					79,
					80,
					81,
					86,
					87,
					88,
					89,
					90,
					91,
					92,
					93,
					94,
					95,
					97
				],
				inclusive: !1
			},
			namespace: {
				rules: [
					26,
					29,
					30,
					31,
					32,
					49,
					50,
					51,
					52,
					53,
					54,
					55,
					56,
					57,
					60,
					63,
					64,
					65,
					66,
					67,
					68,
					69,
					70,
					71,
					72,
					73,
					74,
					75,
					76,
					77,
					78,
					79,
					80,
					81,
					86,
					87,
					88,
					89,
					90,
					91,
					92,
					93,
					94,
					95,
					97
				],
				inclusive: !1
			},
			"class-body": {
				rules: [
					26,
					43,
					44,
					45,
					46,
					47,
					48,
					49,
					50,
					51,
					52,
					53,
					54,
					55,
					56,
					57,
					60,
					63,
					64,
					65,
					66,
					67,
					68,
					69,
					70,
					71,
					72,
					73,
					74,
					75,
					76,
					77,
					78,
					79,
					80,
					81,
					86,
					87,
					88,
					89,
					90,
					91,
					92,
					93,
					94,
					95,
					97
				],
				inclusive: !1
			},
			class: {
				rules: [
					26,
					39,
					40,
					41,
					42,
					49,
					50,
					51,
					52,
					53,
					54,
					55,
					56,
					57,
					60,
					63,
					64,
					65,
					66,
					67,
					68,
					69,
					70,
					71,
					72,
					73,
					74,
					75,
					76,
					77,
					78,
					79,
					80,
					81,
					86,
					87,
					88,
					89,
					90,
					91,
					92,
					93,
					94,
					95,
					97
				],
				inclusive: !1
			},
			acc_descr_multiline: {
				rules: [
					11,
					12,
					26,
					49,
					50,
					51,
					52,
					53,
					54,
					55,
					56,
					57,
					60,
					63,
					64,
					65,
					66,
					67,
					68,
					69,
					70,
					71,
					72,
					73,
					74,
					75,
					76,
					77,
					78,
					79,
					80,
					81,
					86,
					87,
					88,
					89,
					90,
					91,
					92,
					93,
					94,
					95,
					97
				],
				inclusive: !1
			},
			acc_descr: {
				rules: [
					9,
					26,
					49,
					50,
					51,
					52,
					53,
					54,
					55,
					56,
					57,
					60,
					63,
					64,
					65,
					66,
					67,
					68,
					69,
					70,
					71,
					72,
					73,
					74,
					75,
					76,
					77,
					78,
					79,
					80,
					81,
					86,
					87,
					88,
					89,
					90,
					91,
					92,
					93,
					94,
					95,
					97
				],
				inclusive: !1
			},
			acc_title: {
				rules: [
					7,
					26,
					49,
					50,
					51,
					52,
					53,
					54,
					55,
					56,
					57,
					60,
					63,
					64,
					65,
					66,
					67,
					68,
					69,
					70,
					71,
					72,
					73,
					74,
					75,
					76,
					77,
					78,
					79,
					80,
					81,
					86,
					87,
					88,
					89,
					90,
					91,
					92,
					93,
					94,
					95,
					97
				],
				inclusive: !1
			},
			callback_args: {
				rules: [
					22,
					23,
					26,
					49,
					50,
					51,
					52,
					53,
					54,
					55,
					56,
					57,
					60,
					63,
					64,
					65,
					66,
					67,
					68,
					69,
					70,
					71,
					72,
					73,
					74,
					75,
					76,
					77,
					78,
					79,
					80,
					81,
					86,
					87,
					88,
					89,
					90,
					91,
					92,
					93,
					94,
					95,
					97
				],
				inclusive: !1
			},
			callback_name: {
				rules: [
					19,
					20,
					21,
					26,
					49,
					50,
					51,
					52,
					53,
					54,
					55,
					56,
					57,
					60,
					63,
					64,
					65,
					66,
					67,
					68,
					69,
					70,
					71,
					72,
					73,
					74,
					75,
					76,
					77,
					78,
					79,
					80,
					81,
					86,
					87,
					88,
					89,
					90,
					91,
					92,
					93,
					94,
					95,
					97
				],
				inclusive: !1
			},
			href: {
				rules: [
					26,
					49,
					50,
					51,
					52,
					53,
					54,
					55,
					56,
					57,
					60,
					63,
					64,
					65,
					66,
					67,
					68,
					69,
					70,
					71,
					72,
					73,
					74,
					75,
					76,
					77,
					78,
					79,
					80,
					81,
					86,
					87,
					88,
					89,
					90,
					91,
					92,
					93,
					94,
					95,
					97
				],
				inclusive: !1
			},
			struct: {
				rules: [
					26,
					49,
					50,
					51,
					52,
					53,
					54,
					55,
					56,
					57,
					60,
					63,
					64,
					65,
					66,
					67,
					68,
					69,
					70,
					71,
					72,
					73,
					74,
					75,
					76,
					77,
					78,
					79,
					80,
					81,
					86,
					87,
					88,
					89,
					90,
					91,
					92,
					93,
					94,
					95,
					97
				],
				inclusive: !1
			},
			generic: {
				rules: [
					26,
					49,
					50,
					51,
					52,
					53,
					54,
					55,
					56,
					57,
					58,
					59,
					60,
					63,
					64,
					65,
					66,
					67,
					68,
					69,
					70,
					71,
					72,
					73,
					74,
					75,
					76,
					77,
					78,
					79,
					80,
					81,
					86,
					87,
					88,
					89,
					90,
					91,
					92,
					93,
					94,
					95,
					97
				],
				inclusive: !1
			},
			bqstring: {
				rules: [
					26,
					49,
					50,
					51,
					52,
					53,
					54,
					55,
					56,
					57,
					60,
					61,
					62,
					63,
					64,
					65,
					66,
					67,
					68,
					69,
					70,
					71,
					72,
					73,
					74,
					75,
					76,
					77,
					78,
					79,
					80,
					81,
					86,
					87,
					88,
					89,
					90,
					91,
					92,
					93,
					94,
					95,
					97
				],
				inclusive: !1
			},
			string: {
				rules: [
					24,
					25,
					26,
					49,
					50,
					51,
					52,
					53,
					54,
					55,
					56,
					57,
					60,
					63,
					64,
					65,
					66,
					67,
					68,
					69,
					70,
					71,
					72,
					73,
					74,
					75,
					76,
					77,
					78,
					79,
					80,
					81,
					86,
					87,
					88,
					89,
					90,
					91,
					92,
					93,
					94,
					95,
					97
				],
				inclusive: !1
			},
			INITIAL: {
				rules: [
					0,
					1,
					2,
					3,
					4,
					5,
					6,
					8,
					10,
					13,
					14,
					15,
					16,
					17,
					18,
					26,
					27,
					28,
					29,
					38,
					49,
					50,
					51,
					52,
					53,
					54,
					55,
					56,
					57,
					60,
					63,
					64,
					65,
					66,
					67,
					68,
					69,
					70,
					71,
					72,
					73,
					74,
					75,
					76,
					77,
					78,
					79,
					80,
					81,
					82,
					83,
					84,
					85,
					86,
					87,
					88,
					89,
					90,
					91,
					92,
					93,
					94,
					95,
					96,
					97
				],
				inclusive: !0
			}
		}
	}, h(eo, "Parser"), eo.prototype = es, es.Parser = eo, new eo();
}();
eia.parser = eia;
var eis = [
	"#",
	"+",
	"~",
	"-",
	""
], eio = class {
	static {
		h(this, "ClassMember");
	}
	constructor(e, t) {
		this.memberType = t, this.visibility = "", this.classifier = "", this.text = "";
		let r = MO(e, IA());
		this.parseMember(r);
	}
	getDisplayDetails() {
		let e = this.visibility + MW(this.id);
		return "method" === this.memberType && (e += `(${MW(this.parameters.trim())})`, this.returnType && (e += " : " + MW(this.returnType))), {
			displayText: e = e.trim(),
			cssStyle: this.parseClassifier()
		};
	}
	parseMember(e) {
		let t = "";
		if ("method" === this.memberType) {
			let r = /([#+~-])?(.+)\((.*)\)([\s$*])?(.*)([$*])?/.exec(e);
			if (r) {
				let e = r[1] ? r[1].trim() : "";
				if (eis.includes(e) && (this.visibility = e), this.id = r[2], this.parameters = r[3] ? r[3].trim() : "", t = r[4] ? r[4].trim() : "", this.returnType = r[5] ? r[5].trim() : "", "" === t) {
					let e = this.returnType.substring(this.returnType.length - 1);
					/[$*]/.exec(e) && (t = e, this.returnType = this.returnType.substring(0, this.returnType.length - 1));
				}
			}
		} else {
			let r = e.length, i = e.substring(0, 1), n = e.substring(r - 1);
			eis.includes(i) && (this.visibility = i), /[$*]/.exec(n) && (t = n), this.id = e.substring(+("" !== this.visibility), "" === t ? r : r - 1);
		}
		this.classifier = t, this.id = this.id.startsWith(" ") ? " " + this.id.trim() : this.id.trim(), this.text = `${this.visibility ? "\\" + this.visibility : ""}${MW(this.id)}${"method" === this.memberType ? `(${MW(this.parameters)})${this.returnType ? " : " + MW(this.returnType) : ""}` : ""}`.replaceAll("<", "&lt;").replaceAll(">", "&gt;"), this.text.startsWith("\\&lt;") && (this.text = this.text.replace("\\&lt;", "~"));
	}
	parseClassifier() {
		switch (this.classifier) {
			case "*": return "font-style:italic;";
			case "$": return "text-decoration:underline;";
			default: return "";
		}
	}
}, eil = "classId-", eic = 0, eih = h((e) => M1.sanitizeText(e, IA()), "sanitizeText"), eiu = class {
	constructor() {
		this.relations = [], this.classes = /* @__PURE__ */ new Map(), this.styleClasses = /* @__PURE__ */ new Map(), this.notes = [], this.interfaces = [], this.namespaces = /* @__PURE__ */ new Map(), this.namespaceCounter = 0, this.functions = [], this.lineType = {
			LINE: 0,
			DOTTED_LINE: 1
		}, this.relationType = {
			AGGREGATION: 0,
			EXTENSION: 1,
			COMPOSITION: 2,
			DEPENDENCY: 3,
			LOLLIPOP: 4
		}, this.setupToolTips = h((e) => {
			let t = _t(".mermaidTooltip");
			null === (t._groups || t)[0][0] && (t = _t("body").append("div").attr("class", "mermaidTooltip").style("opacity", 0)), _t(e).select("svg").selectAll("g.node").on("mouseover", (e) => {
				let r = _t(e.currentTarget);
				if (null === r.attr("title")) return;
				let i = this.getBoundingClientRect();
				t.transition().duration(200).style("opacity", ".9"), t.text(r.attr("title")).style("left", window.scrollX + i.left + (i.right - i.left) / 2 + "px").style("top", window.scrollY + i.top - 14 + document.body.scrollTop + "px"), t.html(t.html().replace(/&lt;br\/&gt;/g, "<br/>")), r.classed("hover", !0);
			}).on("mouseout", (e) => {
				t.transition().duration(500).style("opacity", 0), _t(e.currentTarget).classed("hover", !1);
			});
		}, "setupToolTips"), this.direction = "TB", this.setAccTitle = Da, this.getAccTitle = Ds, this.setAccDescription = Do, this.getAccDescription = Dl, this.setDiagramTitle = Dc, this.getDiagramTitle = Dh, this.getConfig = h(() => IA().class, "getConfig"), this.functions.push(this.setupToolTips.bind(this)), this.clear(), this.addRelation = this.addRelation.bind(this), this.addClassesToNamespace = this.addClassesToNamespace.bind(this), this.addNamespace = this.addNamespace.bind(this), this.setCssClass = this.setCssClass.bind(this), this.addMembers = this.addMembers.bind(this), this.addClass = this.addClass.bind(this), this.setClassLabel = this.setClassLabel.bind(this), this.addAnnotation = this.addAnnotation.bind(this), this.addMember = this.addMember.bind(this), this.cleanupLabel = this.cleanupLabel.bind(this), this.addNote = this.addNote.bind(this), this.defineClass = this.defineClass.bind(this), this.setDirection = this.setDirection.bind(this), this.setLink = this.setLink.bind(this), this.bindFunctions = this.bindFunctions.bind(this), this.clear = this.clear.bind(this), this.setTooltip = this.setTooltip.bind(this), this.setClickEvent = this.setClickEvent.bind(this), this.setCssStyle = this.setCssStyle.bind(this);
	}
	static {
		h(this, "ClassDB");
	}
	splitClassNameAndType(e) {
		let t = M1.sanitizeText(e, IA()), r = "", i = t;
		if (t.indexOf("~") > 0) {
			let e = t.split("~");
			i = eih(e[0]), r = eih(e[1]);
		}
		return {
			className: i,
			type: r
		};
	}
	setClassLabel(e, t) {
		let r = M1.sanitizeText(e, IA());
		t && (t = eih(t));
		let { className: i } = this.splitClassNameAndType(r);
		this.classes.get(i).label = t, this.classes.get(i).text = `${t}${this.classes.get(i).type ? `<${this.classes.get(i).type}>` : ""}`;
	}
	addClass(e) {
		let t = M1.sanitizeText(e, IA()), { className: r, type: i } = this.splitClassNameAndType(t);
		if (this.classes.has(r)) return;
		let n = M1.sanitizeText(r, IA());
		this.classes.set(n, {
			id: n,
			type: i,
			label: n,
			text: `${n}${i ? `&lt;${i}&gt;` : ""}`,
			shape: "classBox",
			cssClasses: "default",
			methods: [],
			members: [],
			annotations: [],
			styles: [],
			domId: eil + n + "-" + eic
		}), eic++;
	}
	addInterface(e, t) {
		let r = {
			id: `interface${this.interfaces.length}`,
			label: e,
			classId: t
		};
		this.interfaces.push(r);
	}
	lookUpDomId(e) {
		let t = M1.sanitizeText(e, IA());
		if (this.classes.has(t)) return this.classes.get(t).domId;
		throw Error("Class not found: " + t);
	}
	clear() {
		this.relations = [], this.classes = /* @__PURE__ */ new Map(), this.notes = [], this.interfaces = [], this.functions = [], this.functions.push(this.setupToolTips.bind(this)), this.namespaces = /* @__PURE__ */ new Map(), this.namespaceCounter = 0, this.direction = "TB", Dn();
	}
	getClass(e) {
		return this.classes.get(e);
	}
	getClasses() {
		return this.classes;
	}
	getRelations() {
		return this.relations;
	}
	getNotes() {
		return this.notes;
	}
	addRelation(e) {
		wQ.debug("Adding relation: " + JSON.stringify(e));
		let t = [
			this.relationType.LOLLIPOP,
			this.relationType.AGGREGATION,
			this.relationType.COMPOSITION,
			this.relationType.DEPENDENCY,
			this.relationType.EXTENSION
		];
		e.relation.type1 !== this.relationType.LOLLIPOP || t.includes(e.relation.type2) ? e.relation.type2 !== this.relationType.LOLLIPOP || t.includes(e.relation.type1) ? (this.addClass(e.id1), this.addClass(e.id2)) : (this.addClass(e.id1), this.addInterface(e.id2, e.id1), e.id2 = `interface${this.interfaces.length - 1}`) : (this.addClass(e.id2), this.addInterface(e.id1, e.id2), e.id1 = `interface${this.interfaces.length - 1}`), e.id1 = this.splitClassNameAndType(e.id1).className, e.id2 = this.splitClassNameAndType(e.id2).className, e.relationTitle1 = M1.sanitizeText(e.relationTitle1.trim(), IA()), e.relationTitle2 = M1.sanitizeText(e.relationTitle2.trim(), IA()), this.relations.push(e);
	}
	addAnnotation(e, t) {
		let r = this.splitClassNameAndType(e).className;
		this.classes.get(r).annotations.push(t);
	}
	addMember(e, t) {
		this.addClass(e);
		let r = this.splitClassNameAndType(e).className, i = this.classes.get(r);
		if ("string" == typeof t) {
			let e = t.trim();
			e.startsWith("<<") && e.endsWith(">>") ? i.annotations.push(eih(e.substring(2, e.length - 2))) : e.indexOf(")") > 0 ? i.methods.push(new eio(e, "method")) : e && i.members.push(new eio(e, "attribute"));
		}
	}
	addMembers(e, t) {
		Array.isArray(t) && (t.reverse(), t.forEach((t) => this.addMember(e, t)));
	}
	addNote(e, t) {
		let r = {
			id: `note${this.notes.length}`,
			class: t,
			text: e
		};
		this.notes.push(r);
	}
	cleanupLabel(e) {
		return e.startsWith(":") && (e = e.substring(1)), eih(e.trim());
	}
	setCssClass(e, t) {
		e.split(",").forEach((e) => {
			let r = e;
			/\d/.exec(e[0]) && (r = eil + r);
			let i = this.classes.get(r);
			i && (i.cssClasses += " " + t);
		});
	}
	defineClass(e, t) {
		for (let r of e) {
			let e = this.styleClasses.get(r);
			void 0 === e && (e = {
				id: r,
				styles: [],
				textStyles: []
			}, this.styleClasses.set(r, e)), t && t.forEach((t) => {
				if (/color/.exec(t)) {
					let r = t.replace("fill", "bgFill");
					e.textStyles.push(r);
				}
				e.styles.push(t);
			}), this.classes.forEach((e) => {
				e.cssClasses.includes(r) && e.styles.push(...t.flatMap((e) => e.split(",")));
			});
		}
	}
	setTooltip(e, t) {
		e.split(",").forEach((e) => {
			void 0 !== t && (this.classes.get(e).tooltip = eih(t));
		});
	}
	getTooltip(e, t) {
		return t && this.namespaces.has(t) ? this.namespaces.get(t).classes.get(e).tooltip : this.classes.get(e).tooltip;
	}
	setLink(e, t, r) {
		let i = IA();
		e.split(",").forEach((e) => {
			let n = e;
			/\d/.exec(e[0]) && (n = eil + n);
			let a = this.classes.get(n);
			a && (a.link = VR(t, i), "sandbox" === i.securityLevel ? a.linkTarget = "_top" : "string" == typeof r ? a.linkTarget = eih(r) : a.linkTarget = "_blank");
		}), this.setCssClass(e, "clickable");
	}
	setClickEvent(e, t, r) {
		e.split(",").forEach((e) => {
			this.setClickFunc(e, t, r), this.classes.get(e).haveCallback = !0;
		}), this.setCssClass(e, "clickable");
	}
	setClickFunc(e, t, r) {
		let i = M1.sanitizeText(e, IA());
		if ("loose" === IA().securityLevel && void 0 !== t && this.classes.has(i)) {
			let e = this.lookUpDomId(i), n = [];
			if ("string" == typeof r) {
				n = r.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
				for (let e = 0; e < n.length; e++) {
					let t = n[e].trim();
					t.startsWith("\"") && t.endsWith("\"") && (t = t.substr(1, t.length - 2)), n[e] = t;
				}
			}
			0 === n.length && n.push(e), this.functions.push(() => {
				let r = document.querySelector(`[id="${e}"]`);
				null !== r && r.addEventListener("click", () => {
					VN(t, ...n);
				}, !1);
			});
		}
	}
	bindFunctions(e) {
		this.functions.forEach((t) => {
			t(e);
		});
	}
	getDirection() {
		return this.direction;
	}
	setDirection(e) {
		this.direction = e;
	}
	addNamespace(e) {
		this.namespaces.has(e) || (this.namespaces.set(e, {
			id: e,
			classes: /* @__PURE__ */ new Map(),
			children: {},
			domId: eil + e + "-" + this.namespaceCounter
		}), this.namespaceCounter++);
	}
	getNamespace(e) {
		return this.namespaces.get(e);
	}
	getNamespaces() {
		return this.namespaces;
	}
	addClassesToNamespace(e, t) {
		if (this.namespaces.has(e)) for (let r of t) {
			let { className: t } = this.splitClassNameAndType(r);
			this.classes.get(t).parent = e, this.namespaces.get(e).classes.set(t, this.classes.get(t));
		}
	}
	setCssStyle(e, t) {
		let r = this.classes.get(e);
		if (!(!t || !r)) for (let e of t) e.includes(",") ? r.styles.push(...e.split(",")) : r.styles.push(e);
	}
	getArrowMarker(e) {
		let t;
		switch (e) {
			case 0:
				t = "aggregation";
				break;
			case 1:
				t = "extension";
				break;
			case 2:
				t = "composition";
				break;
			case 3:
				t = "dependency";
				break;
			case 4:
				t = "lollipop";
				break;
			default: t = "none";
		}
		return t;
	}
	getData() {
		let e = [], t = [], r = IA();
		for (let t of this.namespaces.keys()) {
			let i = this.namespaces.get(t);
			if (i) {
				let t = {
					id: i.id,
					label: i.id,
					isGroup: !0,
					padding: r.class.padding ?? 16,
					shape: "rect",
					cssStyles: ["fill: none", "stroke: black"],
					look: r.look
				};
				e.push(t);
			}
		}
		for (let t of this.classes.keys()) {
			let i = this.classes.get(t);
			i && (i.parentId = i.parent, i.look = r.look, e.push(i));
		}
		let i = 0;
		for (let n of this.notes) {
			i++;
			let a = {
				id: n.id,
				label: n.text,
				isGroup: !1,
				shape: "note",
				padding: r.class.padding ?? 6,
				cssStyles: [
					"text-align: left",
					"white-space: nowrap",
					`fill: ${r.themeVariables.noteBkgColor}`,
					`stroke: ${r.themeVariables.noteBorderColor}`
				],
				look: r.look
			};
			e.push(a);
			let s = this.classes.get(n.class)?.id ?? "";
			if (s) {
				let e = {
					id: `edgeNote${i}`,
					start: n.id,
					end: s,
					type: "normal",
					thickness: "normal",
					classes: "relation",
					arrowTypeStart: "none",
					arrowTypeEnd: "none",
					arrowheadStyle: "",
					labelStyle: [""],
					style: ["fill: none"],
					pattern: "dotted",
					look: r.look
				};
				t.push(e);
			}
		}
		for (let t of this.interfaces) {
			let i = {
				id: t.id,
				label: t.label,
				isGroup: !1,
				shape: "rect",
				cssStyles: ["opacity: 0;"],
				look: r.look
			};
			e.push(i);
		}
		for (let e of (i = 0, this.relations)) {
			i++;
			let n = {
				id: V7(e.id1, e.id2, {
					prefix: "id",
					counter: i
				}),
				start: e.id1,
				end: e.id2,
				type: "normal",
				label: e.title,
				labelpos: "c",
				thickness: "normal",
				classes: "relation",
				arrowTypeStart: this.getArrowMarker(e.relation.type1),
				arrowTypeEnd: this.getArrowMarker(e.relation.type2),
				startLabelRight: "none" === e.relationTitle1 ? "" : e.relationTitle1,
				endLabelLeft: "none" === e.relationTitle2 ? "" : e.relationTitle2,
				arrowheadStyle: "",
				labelStyle: ["display: inline-block"],
				style: e.style || "",
				pattern: 1 == e.relation.lineType ? "dashed" : "solid",
				look: r.look
			};
			t.push(n);
		}
		return {
			nodes: e,
			edges: t,
			other: {},
			config: r,
			direction: this.getDirection()
		};
	}
}, eid = h((e) => `g.classGroup text {
  fill: ${e.nodeBorder || e.classText};
  stroke: none;
  font-family: ${e.fontFamily};
  font-size: 10px;

  .title {
    font-weight: bolder;
  }

}

.nodeLabel, .edgeLabel {
  color: ${e.classText};
}
.edgeLabel .label rect {
  fill: ${e.mainBkg};
}
.label text {
  fill: ${e.classText};
}

.labelBkg {
  background: ${e.mainBkg};
}
.edgeLabel .label span {
  background: ${e.mainBkg};
}

.classTitle {
  font-weight: bolder;
}
.node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${e.mainBkg};
    stroke: ${e.nodeBorder};
    stroke-width: 1px;
  }


.divider {
  stroke: ${e.nodeBorder};
  stroke-width: 1;
}

g.clickable {
  cursor: pointer;
}

g.classGroup rect {
  fill: ${e.mainBkg};
  stroke: ${e.nodeBorder};
}

g.classGroup line {
  stroke: ${e.nodeBorder};
  stroke-width: 1;
}

.classLabel .box {
  stroke: none;
  stroke-width: 0;
  fill: ${e.mainBkg};
  opacity: 0.5;
}

.classLabel .label {
  fill: ${e.nodeBorder};
  font-size: 10px;
}

.relation {
  stroke: ${e.lineColor};
  stroke-width: 1;
  fill: none;
}

.dashed-line{
  stroke-dasharray: 3;
}

.dotted-line{
  stroke-dasharray: 1 2;
}

#compositionStart, .composition {
  fill: ${e.lineColor} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#compositionEnd, .composition {
  fill: ${e.lineColor} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#dependencyStart, .dependency {
  fill: ${e.lineColor} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#dependencyStart, .dependency {
  fill: ${e.lineColor} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#extensionStart, .extension {
  fill: transparent !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#extensionEnd, .extension {
  fill: transparent !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#aggregationStart, .aggregation {
  fill: transparent !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#aggregationEnd, .aggregation {
  fill: transparent !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#lollipopStart, .lollipop {
  fill: ${e.mainBkg} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#lollipopEnd, .lollipop {
  fill: ${e.mainBkg} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

.edgeTerminals {
  font-size: 11px;
  line-height: initial;
}

.classTitleText {
  text-anchor: middle;
  font-size: 18px;
  fill: ${e.textColor};
}
  ${Kz()}
`, "getStyles"), eip = h((e, t = "TB") => {
	if (!e.doc) return t;
	let r = t;
	for (let t of e.doc) "dir" === t.stmt && (r = t.value);
	return r;
}, "getDir"), eif = {
	getClasses: h(function(e, t) {
		return t.db.getClasses();
	}, "getClasses"),
	draw: h(async function(e, t, r, i) {
		wQ.info("REF0:"), wQ.info("Drawing class diagram (v3)", t);
		let { securityLevel: n, state: a, layout: s } = IA(), o = i.db.getData(), l = JW(t, n);
		o.type = i.type, o.layoutAlgorithm = ein(s), o.nodeSpacing = a?.nodeSpacing || 50, o.rankSpacing = a?.rankSpacing || 50, o.markers = [
			"aggregation",
			"extension",
			"composition",
			"dependency",
			"lollipop"
		], o.diagramId = t, await eii(o, l), V2(l, "classDiagramTitleText", a?.titleTopMargin ?? 25, i.db.getDiagramTitle()), JY(l, 8, "classDiagram", a?.useMaxWidth ?? !0);
	}, "draw"),
	getDir: eip
}, eig = {
	parser: eia,
	get db() {
		return new eiu();
	},
	renderer: eif,
	styles: eid,
	init: h((e) => {
		e.class || (e.class = {}), e.class.arrowMarkerAbsolute = e.arrowMarkerAbsolute;
	}, "init")
}, eim = {
	parser: eia,
	get db() {
		return new eiu();
	},
	renderer: eif,
	styles: eid,
	init: h((e) => {
		e.class || (e.class = {}), e.class.arrowMarkerAbsolute = e.arrowMarkerAbsolute;
	}, "init")
}, eiy = u((e, t) => {
	h(function(r, i) {
		"object" == typeof e && "object" == typeof t ? t.exports = i() : "function" == typeof define && define.amd ? define([], i) : "object" == typeof e ? e.layoutBase = i() : r.layoutBase = i();
	}, "webpackUniversalModuleDefinition")(e, function() {
		var e = [
			function(e, t, r) {
				function i() {}
				h(i, "LayoutConstants"), i.QUALITY = 1, i.DEFAULT_CREATE_BENDS_AS_NEEDED = !1, i.DEFAULT_INCREMENTAL = !1, i.DEFAULT_ANIMATION_ON_LAYOUT = !0, i.DEFAULT_ANIMATION_DURING_LAYOUT = !1, i.DEFAULT_ANIMATION_PERIOD = 50, i.DEFAULT_UNIFORM_LEAF_NODE_SIZES = !1, i.DEFAULT_GRAPH_MARGIN = 15, i.NODE_DIMENSIONS_INCLUDE_LABELS = !1, i.SIMPLE_NODE_SIZE = 40, i.SIMPLE_NODE_HALF_SIZE = i.SIMPLE_NODE_SIZE / 2, i.EMPTY_COMPOUND_NODE_SIZE = 40, i.MIN_EDGE_LENGTH = 1, i.WORLD_BOUNDARY = 1e6, i.INITIAL_WORLD_BOUNDARY = i.WORLD_BOUNDARY / 1e3, i.WORLD_CENTER_X = 1200, i.WORLD_CENTER_Y = 900, e.exports = i;
			},
			function(e, t, r) {
				var i = r(2), n = r(8), a = r(9);
				function s(e, t, r) {
					i.call(this, r), this.isOverlapingSourceAndTarget = !1, this.vGraphObject = r, this.bendpoints = [], this.source = e, this.target = t;
				}
				for (var o in h(s, "LEdge"), s.prototype = Object.create(i.prototype), i) s[o] = i[o];
				s.prototype.getSource = function() {
					return this.source;
				}, s.prototype.getTarget = function() {
					return this.target;
				}, s.prototype.isInterGraph = function() {
					return this.isInterGraph;
				}, s.prototype.getLength = function() {
					return this.length;
				}, s.prototype.isOverlapingSourceAndTarget = function() {
					return this.isOverlapingSourceAndTarget;
				}, s.prototype.getBendpoints = function() {
					return this.bendpoints;
				}, s.prototype.getLca = function() {
					return this.lca;
				}, s.prototype.getSourceInLca = function() {
					return this.sourceInLca;
				}, s.prototype.getTargetInLca = function() {
					return this.targetInLca;
				}, s.prototype.getOtherEnd = function(e) {
					if (this.source === e) return this.target;
					if (this.target === e) return this.source;
					throw "Node is not incident with this edge";
				}, s.prototype.getOtherEndInGraph = function(e, t) {
					for (var r = this.getOtherEnd(e), i = t.getGraphManager().getRoot();;) {
						if (r.getOwner() == t) return r;
						if (r.getOwner() == i) break;
						r = r.getOwner().getParent();
					}
					return null;
				}, s.prototype.updateLength = function() {
					var e = [
						,
						,
						,
						,
					];
					this.isOverlapingSourceAndTarget = n.getIntersection(this.target.getRect(), this.source.getRect(), e), this.isOverlapingSourceAndTarget || (this.lengthX = e[0] - e[2], this.lengthY = e[1] - e[3], 1 > Math.abs(this.lengthX) && (this.lengthX = a.sign(this.lengthX)), 1 > Math.abs(this.lengthY) && (this.lengthY = a.sign(this.lengthY)), this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY));
				}, s.prototype.updateLengthSimple = function() {
					this.lengthX = this.target.getCenterX() - this.source.getCenterX(), this.lengthY = this.target.getCenterY() - this.source.getCenterY(), 1 > Math.abs(this.lengthX) && (this.lengthX = a.sign(this.lengthX)), 1 > Math.abs(this.lengthY) && (this.lengthY = a.sign(this.lengthY)), this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);
				}, e.exports = s;
			},
			function(e, t, r) {
				function i(e) {
					this.vGraphObject = e;
				}
				h(i, "LGraphObject"), e.exports = i;
			},
			function(e, t, r) {
				var i = r(2), n = r(10), a = r(13), s = r(0), o = r(16), l = r(4);
				function u(e, t, r, s) {
					null == r && null == s && (s = t), i.call(this, s), null != e.graphManager && (e = e.graphManager), this.estimatedSize = n.MIN_VALUE, this.inclusionTreeDepth = n.MAX_VALUE, this.vGraphObject = s, this.edges = [], this.graphManager = e, null != r && null != t ? this.rect = new a(t.x, t.y, r.width, r.height) : this.rect = new a();
				}
				for (var d in h(u, "LNode"), u.prototype = Object.create(i.prototype), i) u[d] = i[d];
				u.prototype.getEdges = function() {
					return this.edges;
				}, u.prototype.getChild = function() {
					return this.child;
				}, u.prototype.getOwner = function() {
					return this.owner;
				}, u.prototype.getWidth = function() {
					return this.rect.width;
				}, u.prototype.setWidth = function(e) {
					this.rect.width = e;
				}, u.prototype.getHeight = function() {
					return this.rect.height;
				}, u.prototype.setHeight = function(e) {
					this.rect.height = e;
				}, u.prototype.getCenterX = function() {
					return this.rect.x + this.rect.width / 2;
				}, u.prototype.getCenterY = function() {
					return this.rect.y + this.rect.height / 2;
				}, u.prototype.getCenter = function() {
					return new l(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);
				}, u.prototype.getLocation = function() {
					return new l(this.rect.x, this.rect.y);
				}, u.prototype.getRect = function() {
					return this.rect;
				}, u.prototype.getDiagonal = function() {
					return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);
				}, u.prototype.getHalfTheDiagonal = function() {
					return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;
				}, u.prototype.setRect = function(e, t) {
					this.rect.x = e.x, this.rect.y = e.y, this.rect.width = t.width, this.rect.height = t.height;
				}, u.prototype.setCenter = function(e, t) {
					this.rect.x = e - this.rect.width / 2, this.rect.y = t - this.rect.height / 2;
				}, u.prototype.setLocation = function(e, t) {
					this.rect.x = e, this.rect.y = t;
				}, u.prototype.moveBy = function(e, t) {
					this.rect.x += e, this.rect.y += t;
				}, u.prototype.getEdgeListToNode = function(e) {
					var t = [], r = this;
					return r.edges.forEach(function(i) {
						if (i.target == e) {
							if (i.source != r) throw "Incorrect edge source!";
							t.push(i);
						}
					}), t;
				}, u.prototype.getEdgesBetween = function(e) {
					var t = [], r = this;
					return r.edges.forEach(function(i) {
						if (i.source != r && i.target != r) throw "Incorrect edge source and/or target";
						(i.target == e || i.source == e) && t.push(i);
					}), t;
				}, u.prototype.getNeighborsList = function() {
					var e = /* @__PURE__ */ new Set(), t = this;
					return t.edges.forEach(function(r) {
						if (r.source == t) e.add(r.target);
						else {
							if (r.target != t) throw "Incorrect incidency!";
							e.add(r.source);
						}
					}), e;
				}, u.prototype.withChildren = function() {
					var e = /* @__PURE__ */ new Set();
					if (e.add(this), null != this.child) for (var t = this.child.getNodes(), r = 0; r < t.length; r++) t[r].withChildren().forEach(function(t) {
						e.add(t);
					});
					return e;
				}, u.prototype.getNoOfChildren = function() {
					var e = 0;
					if (null == this.child) e = 1;
					else for (var t = this.child.getNodes(), r = 0; r < t.length; r++) e += t[r].getNoOfChildren();
					return 0 == e && (e = 1), e;
				}, u.prototype.getEstimatedSize = function() {
					if (this.estimatedSize == n.MIN_VALUE) throw "assert failed";
					return this.estimatedSize;
				}, u.prototype.calcEstimatedSize = function() {
					return null == this.child ? this.estimatedSize = (this.rect.width + this.rect.height) / 2 : (this.estimatedSize = this.child.calcEstimatedSize(), this.rect.width = this.estimatedSize, this.rect.height = this.estimatedSize, this.estimatedSize);
				}, u.prototype.scatter = function() {
					var e, t, r = -s.INITIAL_WORLD_BOUNDARY, i = s.INITIAL_WORLD_BOUNDARY;
					e = s.WORLD_CENTER_X + o.nextDouble() * (i - r) + r;
					var n = -s.INITIAL_WORLD_BOUNDARY, a = s.INITIAL_WORLD_BOUNDARY;
					t = s.WORLD_CENTER_Y + o.nextDouble() * (a - n) + n, this.rect.x = e, this.rect.y = t;
				}, u.prototype.updateBounds = function() {
					if (null == this.getChild()) throw "assert failed";
					if (0 != this.getChild().getNodes().length) {
						var e = this.getChild();
						if (e.updateBounds(!0), this.rect.x = e.getLeft(), this.rect.y = e.getTop(), this.setWidth(e.getRight() - e.getLeft()), this.setHeight(e.getBottom() - e.getTop()), s.NODE_DIMENSIONS_INCLUDE_LABELS) {
							var t = e.getRight() - e.getLeft(), r = e.getBottom() - e.getTop();
							this.labelWidth > t && (this.rect.x -= (this.labelWidth - t) / 2, this.setWidth(this.labelWidth)), this.labelHeight > r && ("center" == this.labelPos ? this.rect.y -= (this.labelHeight - r) / 2 : "top" == this.labelPos && (this.rect.y -= this.labelHeight - r), this.setHeight(this.labelHeight));
						}
					}
				}, u.prototype.getInclusionTreeDepth = function() {
					if (this.inclusionTreeDepth == n.MAX_VALUE) throw "assert failed";
					return this.inclusionTreeDepth;
				}, u.prototype.transform = function(e) {
					var t = this.rect.x;
					t > s.WORLD_BOUNDARY ? t = s.WORLD_BOUNDARY : t < -s.WORLD_BOUNDARY && (t = -s.WORLD_BOUNDARY);
					var r = this.rect.y;
					r > s.WORLD_BOUNDARY ? r = s.WORLD_BOUNDARY : r < -s.WORLD_BOUNDARY && (r = -s.WORLD_BOUNDARY);
					var i = new l(t, r), n = e.inverseTransformPoint(i);
					this.setLocation(n.x, n.y);
				}, u.prototype.getLeft = function() {
					return this.rect.x;
				}, u.prototype.getRight = function() {
					return this.rect.x + this.rect.width;
				}, u.prototype.getTop = function() {
					return this.rect.y;
				}, u.prototype.getBottom = function() {
					return this.rect.y + this.rect.height;
				}, u.prototype.getParent = function() {
					return null == this.owner ? null : this.owner.getParent();
				}, e.exports = u;
			},
			function(e, t, r) {
				function i(e, t) {
					null == e && null == t ? (this.x = 0, this.y = 0) : (this.x = e, this.y = t);
				}
				h(i, "PointD"), i.prototype.getX = function() {
					return this.x;
				}, i.prototype.getY = function() {
					return this.y;
				}, i.prototype.setX = function(e) {
					this.x = e;
				}, i.prototype.setY = function(e) {
					this.y = e;
				}, i.prototype.getDifference = function(e) {
					return new DimensionD(this.x - e.x, this.y - e.y);
				}, i.prototype.getCopy = function() {
					return new i(this.x, this.y);
				}, i.prototype.translate = function(e) {
					return this.x += e.width, this.y += e.height, this;
				}, e.exports = i;
			},
			function(e, t, r) {
				var i = r(2), n = r(10), a = r(0), s = r(6), o = r(3), l = r(1), u = r(13), d = r(12), p = r(11);
				function f(e, t, r) {
					i.call(this, r), this.estimatedSize = n.MIN_VALUE, this.margin = a.DEFAULT_GRAPH_MARGIN, this.edges = [], this.nodes = [], this.isConnected = !1, this.parent = e, null != t && t instanceof s ? this.graphManager = t : null != t && t instanceof Layout && (this.graphManager = t.graphManager);
				}
				for (var g in h(f, "LGraph"), f.prototype = Object.create(i.prototype), i) f[g] = i[g];
				f.prototype.getNodes = function() {
					return this.nodes;
				}, f.prototype.getEdges = function() {
					return this.edges;
				}, f.prototype.getGraphManager = function() {
					return this.graphManager;
				}, f.prototype.getParent = function() {
					return this.parent;
				}, f.prototype.getLeft = function() {
					return this.left;
				}, f.prototype.getRight = function() {
					return this.right;
				}, f.prototype.getTop = function() {
					return this.top;
				}, f.prototype.getBottom = function() {
					return this.bottom;
				}, f.prototype.isConnected = function() {
					return this.isConnected;
				}, f.prototype.add = function(e, t, r) {
					if (null == t && null == r) {
						if (null == this.graphManager) throw "Graph has no graph mgr!";
						if (this.getNodes().indexOf(e) > -1) throw "Node already in graph!";
						return e.owner = this, this.getNodes().push(e), e;
					}
					if (!(this.getNodes().indexOf(t) > -1 && this.getNodes().indexOf(r) > -1)) throw "Source or target not in graph!";
					if (t.owner != r.owner || t.owner != this) throw "Both owners must be this graph!";
					return t.owner != r.owner ? null : (e.source = t, e.target = r, e.isInterGraph = !1, this.getEdges().push(e), t.edges.push(e), r != t && r.edges.push(e), e);
				}, f.prototype.remove = function(e) {
					if (e instanceof o) {
						if (null == e) throw "Node is null!";
						if (null == e.owner || e.owner != this) throw "Owner graph is invalid!";
						if (null == this.graphManager) throw "Owner graph manager is invalid!";
						for (var t, r = e.edges.slice(), i = r.length, n = 0; n < i; n++) (t = r[n]).isInterGraph ? this.graphManager.remove(t) : t.source.owner.remove(t);
						var a = this.nodes.indexOf(e);
						if (-1 == a) throw "Node not in owner node list!";
						this.nodes.splice(a, 1);
					} else if (e instanceof l) {
						var t = e;
						if (null == t) throw "Edge is null!";
						if (null == t.source || null == t.target) throw "Source and/or target is null!";
						if (null == t.source.owner || null == t.target.owner || t.source.owner != this || t.target.owner != this) throw "Source and/or target owner is invalid!";
						var s = t.source.edges.indexOf(t), h = t.target.edges.indexOf(t);
						if (!(s > -1 && h > -1)) throw "Source and/or target doesn't know this edge!";
						t.source.edges.splice(s, 1), t.target != t.source && t.target.edges.splice(h, 1);
						var a = t.source.owner.getEdges().indexOf(t);
						if (-1 == a) throw "Not in owner's edge list!";
						t.source.owner.getEdges().splice(a, 1);
					}
				}, f.prototype.updateLeftTop = function() {
					for (var e, t, r, i = n.MAX_VALUE, a = n.MAX_VALUE, s = this.getNodes(), o = s.length, l = 0; l < o; l++) {
						var h = s[l];
						e = h.getTop(), t = h.getLeft(), i > e && (i = e), a > t && (a = t);
					}
					return i == n.MAX_VALUE ? null : (r = null != s[0].getParent().paddingLeft ? s[0].getParent().paddingLeft : this.margin, this.left = a - r, this.top = i - r, new d(this.left, this.top));
				}, f.prototype.updateBounds = function(e) {
					for (var t, r, i, a, s, o = n.MAX_VALUE, l = -n.MAX_VALUE, h = n.MAX_VALUE, d = -n.MAX_VALUE, p = this.nodes, f = p.length, g = 0; g < f; g++) {
						var m = p[g];
						e && null != m.child && m.updateBounds(), t = m.getLeft(), r = m.getRight(), i = m.getTop(), a = m.getBottom(), o > t && (o = t), l < r && (l = r), h > i && (h = i), d < a && (d = a);
					}
					var y = new u(o, h, l - o, d - h);
					o == n.MAX_VALUE && (this.left = this.parent.getLeft(), this.right = this.parent.getRight(), this.top = this.parent.getTop(), this.bottom = this.parent.getBottom()), s = null != p[0].getParent().paddingLeft ? p[0].getParent().paddingLeft : this.margin, this.left = y.x - s, this.right = y.x + y.width + s, this.top = y.y - s, this.bottom = y.y + y.height + s;
				}, f.calculateBounds = function(e) {
					for (var t, r, i, a, s = n.MAX_VALUE, o = -n.MAX_VALUE, l = n.MAX_VALUE, h = -n.MAX_VALUE, d = e.length, p = 0; p < d; p++) {
						var f = e[p];
						t = f.getLeft(), r = f.getRight(), i = f.getTop(), a = f.getBottom(), s > t && (s = t), o < r && (o = r), l > i && (l = i), h < a && (h = a);
					}
					return new u(s, l, o - s, h - l);
				}, f.prototype.getInclusionTreeDepth = function() {
					return this == this.graphManager.getRoot() ? 1 : this.parent.getInclusionTreeDepth();
				}, f.prototype.getEstimatedSize = function() {
					if (this.estimatedSize == n.MIN_VALUE) throw "assert failed";
					return this.estimatedSize;
				}, f.prototype.calcEstimatedSize = function() {
					for (var e = 0, t = this.nodes, r = t.length, i = 0; i < r; i++) e += t[i].calcEstimatedSize();
					return 0 == e ? this.estimatedSize = a.EMPTY_COMPOUND_NODE_SIZE : this.estimatedSize = e / Math.sqrt(this.nodes.length), this.estimatedSize;
				}, f.prototype.updateConnected = function() {
					var e = this;
					if (0 == this.nodes.length) {
						this.isConnected = !0;
						return;
					}
					var t, r, i = new p(), n = /* @__PURE__ */ new Set(), a = this.nodes[0];
					for (a.withChildren().forEach(function(e) {
						i.push(e), n.add(e);
					}); 0 !== i.length;) {
						t = (a = i.shift()).getEdges();
						for (var s = t.length, o = 0; o < s; o++) null == (r = t[o].getOtherEndInGraph(a, this)) || n.has(r) || r.withChildren().forEach(function(e) {
							i.push(e), n.add(e);
						});
					}
					if (this.isConnected = !1, n.size >= this.nodes.length) {
						var l = 0;
						n.forEach(function(t) {
							t.owner == e && l++;
						}), l == this.nodes.length && (this.isConnected = !0);
					}
				}, e.exports = f;
			},
			function(e, t, r) {
				var i, n = r(1);
				function a(e) {
					i = r(5), this.layout = e, this.graphs = [], this.edges = [];
				}
				h(a, "LGraphManager"), a.prototype.addRoot = function() {
					var e = this.layout.newGraph(), t = this.layout.newNode(null), r = this.add(e, t);
					return this.setRootGraph(r), this.rootGraph;
				}, a.prototype.add = function(e, t, r, i, n) {
					if (null == r && null == i && null == n) {
						if (null == e) throw "Graph is null!";
						if (null == t) throw "Parent node is null!";
						if (this.graphs.indexOf(e) > -1) throw "Graph already in this graph mgr!";
						if (this.graphs.push(e), null != e.parent) throw "Already has a parent!";
						if (null != t.child) throw "Already has a child!";
						return e.parent = t, t.child = e, e;
					}
					n = r, i = t, r = e;
					var a = i.getOwner(), s = n.getOwner();
					if (null == a || a.getGraphManager() != this) throw "Source not in this graph mgr!";
					if (null == s || s.getGraphManager() != this) throw "Target not in this graph mgr!";
					if (a == s) return r.isInterGraph = !1, a.add(r, i, n);
					if (r.isInterGraph = !0, r.source = i, r.target = n, this.edges.indexOf(r) > -1) throw "Edge already in inter-graph edge list!";
					if (this.edges.push(r), null == r.source || null == r.target) throw "Edge source and/or target is null!";
					if (-1 != r.source.edges.indexOf(r) || -1 != r.target.edges.indexOf(r)) throw "Edge already in source and/or target incidency list!";
					return r.source.edges.push(r), r.target.edges.push(r), r;
				}, a.prototype.remove = function(e) {
					if (e instanceof i) {
						if (e.getGraphManager() != this) throw "Graph not in this graph mgr";
						if (e != this.rootGraph && (null == e.parent || e.parent.graphManager != this)) throw "Invalid parent node!";
						var t = [];
						t = t.concat(e.getEdges());
						for (var r, a, s = t.length, o = 0; o < s; o++) a = t[o], e.remove(a);
						var l = [];
						s = (l = l.concat(e.getNodes())).length;
						for (var o = 0; o < s; o++) r = l[o], e.remove(r);
						e == this.rootGraph && this.setRootGraph(null);
						var h = this.graphs.indexOf(e);
						this.graphs.splice(h, 1), e.parent = null;
					} else if (e instanceof n) {
						if (null == (a = e)) throw "Edge is null!";
						if (!a.isInterGraph) throw "Not an inter-graph edge!";
						if (null == a.source || null == a.target) throw "Source and/or target is null!";
						if (-1 == a.source.edges.indexOf(a) || -1 == a.target.edges.indexOf(a)) throw "Source and/or target doesn't know this edge!";
						var h = a.source.edges.indexOf(a);
						if (a.source.edges.splice(h, 1), h = a.target.edges.indexOf(a), a.target.edges.splice(h, 1), null == a.source.owner || null == a.source.owner.getGraphManager()) throw "Edge owner graph or owner graph manager is null!";
						if (-1 == a.source.owner.getGraphManager().edges.indexOf(a)) throw "Not in owner graph manager's edge list!";
						var h = a.source.owner.getGraphManager().edges.indexOf(a);
						a.source.owner.getGraphManager().edges.splice(h, 1);
					}
				}, a.prototype.updateBounds = function() {
					this.rootGraph.updateBounds(!0);
				}, a.prototype.getGraphs = function() {
					return this.graphs;
				}, a.prototype.getAllNodes = function() {
					if (null == this.allNodes) {
						for (var e = [], t = this.getGraphs(), r = t.length, i = 0; i < r; i++) e = e.concat(t[i].getNodes());
						this.allNodes = e;
					}
					return this.allNodes;
				}, a.prototype.resetAllNodes = function() {
					this.allNodes = null;
				}, a.prototype.resetAllEdges = function() {
					this.allEdges = null;
				}, a.prototype.resetAllNodesToApplyGravitation = function() {
					this.allNodesToApplyGravitation = null;
				}, a.prototype.getAllEdges = function() {
					if (null == this.allEdges) {
						for (var e = [], t = this.getGraphs(), r = (t.length, 0); r < t.length; r++) e = e.concat(t[r].getEdges());
						e = e.concat(this.edges), this.allEdges = e;
					}
					return this.allEdges;
				}, a.prototype.getAllNodesToApplyGravitation = function() {
					return this.allNodesToApplyGravitation;
				}, a.prototype.setAllNodesToApplyGravitation = function(e) {
					if (null != this.allNodesToApplyGravitation) throw "assert failed";
					this.allNodesToApplyGravitation = e;
				}, a.prototype.getRoot = function() {
					return this.rootGraph;
				}, a.prototype.setRootGraph = function(e) {
					if (e.getGraphManager() != this) throw "Root not in this graph mgr!";
					this.rootGraph = e, e.parent ??= this.layout.newNode("Root node");
				}, a.prototype.getLayout = function() {
					return this.layout;
				}, a.prototype.isOneAncestorOfOther = function(e, t) {
					if (null == e || null == t) throw "assert failed";
					if (e == t) return !0;
					for (var r, i = e.getOwner(); null != (r = i.getParent());) {
						if (r == t) return !0;
						if (null == (i = r.getOwner())) break;
					}
					for (i = t.getOwner(); null != (r = i.getParent());) {
						if (r == e) return !0;
						if (null == (i = r.getOwner())) break;
					}
					return !1;
				}, a.prototype.calcLowestCommonAncestors = function() {
					for (var e, t, r, i, n, a = this.getAllEdges(), s = a.length, o = 0; o < s; o++) {
						if (t = (e = a[o]).source, r = e.target, e.lca = null, e.sourceInLca = t, e.targetInLca = r, t == r) {
							e.lca = t.getOwner();
							continue;
						}
						for (i = t.getOwner(); null == e.lca;) {
							for (e.targetInLca = r, n = r.getOwner(); null == e.lca;) {
								if (n == i) {
									e.lca = n;
									break;
								}
								if (n == this.rootGraph) break;
								if (null != e.lca) throw "assert failed";
								e.targetInLca = n.getParent(), n = e.targetInLca.getOwner();
							}
							if (i == this.rootGraph) break;
							e.lca ?? (e.sourceInLca = i.getParent(), i = e.sourceInLca.getOwner());
						}
						if (null == e.lca) throw "assert failed";
					}
				}, a.prototype.calcLowestCommonAncestor = function(e, t) {
					if (e == t) return e.getOwner();
					for (var r = e.getOwner(); null != r;) {
						for (var i = t.getOwner(); null != i;) {
							if (i == r) return i;
							i = i.getParent().getOwner();
						}
						r = r.getParent().getOwner();
					}
					return r;
				}, a.prototype.calcInclusionTreeDepths = function(e, t) {
					null == e && null == t && (e = this.rootGraph, t = 1);
					for (var r, i = e.getNodes(), n = i.length, a = 0; a < n; a++) (r = i[a]).inclusionTreeDepth = t, null != r.child && this.calcInclusionTreeDepths(r.child, t + 1);
				}, a.prototype.includesInvalidEdge = function() {
					for (var e, t = this.edges.length, r = 0; r < t; r++) if (e = this.edges[r], this.isOneAncestorOfOther(e.source, e.target)) return !0;
					return !1;
				}, e.exports = a;
			},
			function(e, t, r) {
				var i = r(0);
				function n() {}
				for (var a in h(n, "FDLayoutConstants"), i) n[a] = i[a];
				n.MAX_ITERATIONS = 2500, n.DEFAULT_EDGE_LENGTH = 50, n.DEFAULT_SPRING_STRENGTH = .45, n.DEFAULT_REPULSION_STRENGTH = 4500, n.DEFAULT_GRAVITY_STRENGTH = .4, n.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1, n.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8, n.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5, n.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = !0, n.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = !0, n.DEFAULT_COOLING_FACTOR_INCREMENTAL = .3, n.COOLING_ADAPTATION_FACTOR = .33, n.ADAPTATION_LOWER_NODE_LIMIT = 1e3, n.ADAPTATION_UPPER_NODE_LIMIT = 5e3, n.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100, n.MAX_NODE_DISPLACEMENT = 3 * n.MAX_NODE_DISPLACEMENT_INCREMENTAL, n.MIN_REPULSION_DIST = n.DEFAULT_EDGE_LENGTH / 10, n.CONVERGENCE_CHECK_PERIOD = 100, n.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = .1, n.MIN_EDGE_LENGTH = 1, n.GRID_CALCULATION_CHECK_PERIOD = 10, e.exports = n;
			},
			function(e, t, r) {
				var i = r(12);
				function n() {}
				h(n, "IGeometry"), n.calcSeparationAmount = function(e, t, r, i) {
					if (!e.intersects(t)) throw "assert failed";
					var n = [, ,];
					this.decideDirectionsForOverlappingNodes(e, t, n), r[0] = Math.min(e.getRight(), t.getRight()) - Math.max(e.x, t.x), r[1] = Math.min(e.getBottom(), t.getBottom()) - Math.max(e.y, t.y), e.getX() <= t.getX() && e.getRight() >= t.getRight() ? r[0] += Math.min(t.getX() - e.getX(), e.getRight() - t.getRight()) : t.getX() <= e.getX() && t.getRight() >= e.getRight() && (r[0] += Math.min(e.getX() - t.getX(), t.getRight() - e.getRight())), e.getY() <= t.getY() && e.getBottom() >= t.getBottom() ? r[1] += Math.min(t.getY() - e.getY(), e.getBottom() - t.getBottom()) : t.getY() <= e.getY() && t.getBottom() >= e.getBottom() && (r[1] += Math.min(e.getY() - t.getY(), t.getBottom() - e.getBottom()));
					var a = Math.abs((t.getCenterY() - e.getCenterY()) / (t.getCenterX() - e.getCenterX()));
					t.getCenterY() === e.getCenterY() && t.getCenterX() === e.getCenterX() && (a = 1);
					var s = a * r[0], o = r[1] / a;
					r[0] < o ? o = r[0] : s = r[1], r[0] = -1 * n[0] * (o / 2 + i), r[1] = -1 * n[1] * (s / 2 + i);
				}, n.decideDirectionsForOverlappingNodes = function(e, t, r) {
					e.getCenterX() < t.getCenterX() ? r[0] = -1 : r[0] = 1, e.getCenterY() < t.getCenterY() ? r[1] = -1 : r[1] = 1;
				}, n.getIntersection2 = function(e, t, r) {
					var i = e.getCenterX(), n = e.getCenterY(), a = t.getCenterX(), s = t.getCenterY();
					if (e.intersects(t)) return r[0] = i, r[1] = n, r[2] = a, r[3] = s, !0;
					var o = e.getX(), l = e.getY(), h = e.getRight(), u = e.getX(), d = e.getBottom(), p = e.getRight(), f = e.getWidthHalf(), g = e.getHeightHalf(), m = t.getX(), y = t.getY(), v = t.getRight(), x = t.getX(), b = t.getBottom(), w = t.getRight(), k = t.getWidthHalf(), T = t.getHeightHalf(), _ = !1, E = !1;
					if (i === a) {
						if (n > s) return r[0] = i, r[1] = l, r[2] = a, r[3] = b, !1;
						if (n < s) return r[0] = i, r[1] = d, r[2] = a, r[3] = y, !1;
					} else if (n === s) {
						if (i > a) return r[0] = o, r[1] = n, r[2] = v, r[3] = s, !1;
						if (i < a) return r[0] = h, r[1] = n, r[2] = m, r[3] = s, !1;
					} else {
						var C = e.height / e.width, S = t.height / t.width, A = (s - n) / (a - i), L = void 0, R = void 0, N = void 0, I = void 0, M = void 0, D = void 0;
						if (-C === A ? (i > a ? (r[0] = u, r[1] = d) : (r[0] = h, r[1] = l), _ = !0) : C === A && (i > a ? (r[0] = o, r[1] = l) : (r[0] = p, r[1] = d), _ = !0), -S === A ? (a > i ? (r[2] = x, r[3] = b) : (r[2] = v, r[3] = y), E = !0) : S === A && (a > i ? (r[2] = m, r[3] = y) : (r[2] = w, r[3] = b), E = !0), _ && E) return !1;
						if (i > a ? n > s ? (L = this.getCardinalDirection(C, A, 4), R = this.getCardinalDirection(S, A, 2)) : (L = this.getCardinalDirection(-C, A, 3), R = this.getCardinalDirection(-S, A, 1)) : n > s ? (L = this.getCardinalDirection(-C, A, 1), R = this.getCardinalDirection(-S, A, 3)) : (L = this.getCardinalDirection(C, A, 2), R = this.getCardinalDirection(S, A, 4)), !_) switch (L) {
							case 1:
								I = l, N = i + -g / A, r[0] = N, r[1] = I;
								break;
							case 2:
								N = p, I = n + f * A, r[0] = N, r[1] = I;
								break;
							case 3:
								I = d, N = i + g / A, r[0] = N, r[1] = I;
								break;
							case 4: N = u, I = n + -f * A, r[0] = N, r[1] = I;
						}
						if (!E) switch (R) {
							case 1:
								D = y, M = a + -T / A, r[2] = M, r[3] = D;
								break;
							case 2:
								M = w, D = s + k * A, r[2] = M, r[3] = D;
								break;
							case 3:
								D = b, M = a + T / A, r[2] = M, r[3] = D;
								break;
							case 4: M = x, D = s + -k * A, r[2] = M, r[3] = D;
						}
					}
					return !1;
				}, n.getCardinalDirection = function(e, t, r) {
					return e > t ? r : 1 + r % 4;
				}, n.getIntersection = function(e, t, r, n) {
					if (null == n) return this.getIntersection2(e, t, r);
					var a = e.x, s = e.y, o = t.x, l = t.y, h = r.x, u = r.y, d = n.x, p = n.y, f = void 0, g = void 0, m = void 0, y = void 0, v = void 0, x = void 0, b = void 0;
					return f = l - s, m = a - o, v = o * s - a * l, g = p - u, y = h - d, x = d * u - h * p, 0 == (b = f * y - g * m) ? null : new i((m * x - y * v) / b, (g * v - f * x) / b);
				}, n.angleOfVector = function(e, t, r, i) {
					var n = void 0;
					return e !== r ? (n = Math.atan((i - t) / (r - e)), r < e ? n += Math.PI : i < t && (n += this.TWO_PI)) : n = i < t ? this.ONE_AND_HALF_PI : this.HALF_PI, n;
				}, n.doIntersect = function(e, t, r, i) {
					var n = e.x, a = e.y, s = t.x, o = t.y, l = r.x, h = r.y, u = i.x, d = i.y, p = (s - n) * (d - h) - (u - l) * (o - a);
					if (0 === p) return !1;
					var f = ((d - h) * (u - n) + (l - u) * (d - a)) / p, g = ((a - o) * (u - n) + (s - n) * (d - a)) / p;
					return 0 < f && f < 1 && 0 < g && g < 1;
				}, n.HALF_PI = .5 * Math.PI, n.ONE_AND_HALF_PI = 1.5 * Math.PI, n.TWO_PI = 2 * Math.PI, n.THREE_PI = 3 * Math.PI, e.exports = n;
			},
			function(e, t, r) {
				function i() {}
				h(i, "IMath"), i.sign = function(e) {
					return e > 0 ? 1 : e < 0 ? -1 : 0;
				}, i.floor = function(e) {
					return e < 0 ? Math.ceil(e) : Math.floor(e);
				}, i.ceil = function(e) {
					return e < 0 ? Math.floor(e) : Math.ceil(e);
				}, e.exports = i;
			},
			function(e, t, r) {
				function i() {}
				h(i, "Integer"), i.MAX_VALUE = 2147483647, i.MIN_VALUE = -2147483648, e.exports = i;
			},
			function(e, t, r) {
				var i = function() {
					function e(e, t) {
						for (var r = 0; r < t.length; r++) {
							var i = t[r];
							i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
						}
					}
					return h(e, "defineProperties"), function(t, r, i) {
						return r && e(t.prototype, r), i && e(t, i), t;
					};
				}();
				function n(e, t) {
					if (!(e instanceof t)) throw TypeError("Cannot call a class as a function");
				}
				h(n, "_classCallCheck");
				var a = h(function(e) {
					return {
						value: e,
						next: null,
						prev: null
					};
				}, "nodeFrom"), s = h(function(e, t, r, i) {
					return null !== e ? e.next = t : i.head = t, null !== r ? r.prev = t : i.tail = t, t.prev = e, t.next = r, i.length++, t;
				}, "add"), o = h(function(e, t) {
					var r = e.prev, i = e.next;
					return null !== r ? r.next = i : t.head = i, null !== i ? i.prev = r : t.tail = r, e.prev = e.next = null, t.length--, e;
				}, "_remove");
				e.exports = function() {
					function e(t) {
						var r = this;
						n(this, e), this.length = 0, this.head = null, this.tail = null, t?.forEach(function(e) {
							return r.push(e);
						});
					}
					return h(e, "LinkedList"), i(e, [
						{
							key: "size",
							value: h(function() {
								return this.length;
							}, "size")
						},
						{
							key: "insertBefore",
							value: h(function(e, t) {
								return s(t.prev, a(e), t, this);
							}, "insertBefore")
						},
						{
							key: "insertAfter",
							value: h(function(e, t) {
								return s(t, a(e), t.next, this);
							}, "insertAfter")
						},
						{
							key: "insertNodeBefore",
							value: h(function(e, t) {
								return s(t.prev, e, t, this);
							}, "insertNodeBefore")
						},
						{
							key: "insertNodeAfter",
							value: h(function(e, t) {
								return s(t, e, t.next, this);
							}, "insertNodeAfter")
						},
						{
							key: "push",
							value: h(function(e) {
								return s(this.tail, a(e), null, this);
							}, "push")
						},
						{
							key: "unshift",
							value: h(function(e) {
								return s(null, a(e), this.head, this);
							}, "unshift")
						},
						{
							key: "remove",
							value: h(function(e) {
								return o(e, this);
							}, "remove")
						},
						{
							key: "pop",
							value: h(function() {
								return o(this.tail, this).value;
							}, "pop")
						},
						{
							key: "popNode",
							value: h(function() {
								return o(this.tail, this);
							}, "popNode")
						},
						{
							key: "shift",
							value: h(function() {
								return o(this.head, this).value;
							}, "shift")
						},
						{
							key: "shiftNode",
							value: h(function() {
								return o(this.head, this);
							}, "shiftNode")
						},
						{
							key: "get_object_at",
							value: h(function(e) {
								if (e <= this.length()) {
									for (var t = 1, r = this.head; t < e;) r = r.next, t++;
									return r.value;
								}
							}, "get_object_at")
						},
						{
							key: "set_object_at",
							value: h(function(e, t) {
								if (e <= this.length()) {
									for (var r = 1, i = this.head; r < e;) i = i.next, r++;
									i.value = t;
								}
							}, "set_object_at")
						}
					]), e;
				}();
			},
			function(e, t, r) {
				function i(e, t, r) {
					this.x = null, this.y = null, null == e && null == t && null == r ? (this.x = 0, this.y = 0) : "number" == typeof e && "number" == typeof t && null == r ? (this.x = e, this.y = t) : "Point" == e.constructor.name && null == t && null == r && (r = e, this.x = r.x, this.y = r.y);
				}
				h(i, "Point"), i.prototype.getX = function() {
					return this.x;
				}, i.prototype.getY = function() {
					return this.y;
				}, i.prototype.getLocation = function() {
					return new i(this.x, this.y);
				}, i.prototype.setLocation = function(e, t, r) {
					"Point" == e.constructor.name && null == t && null == r ? (r = e, this.setLocation(r.x, r.y)) : "number" == typeof e && "number" == typeof t && null == r && (parseInt(e) == e && parseInt(t) == t ? this.move(e, t) : (this.x = Math.floor(e + .5), this.y = Math.floor(t + .5)));
				}, i.prototype.move = function(e, t) {
					this.x = e, this.y = t;
				}, i.prototype.translate = function(e, t) {
					this.x += e, this.y += t;
				}, i.prototype.equals = function(e) {
					return "Point" == e.constructor.name ? this.x == e.x && this.y == e.y : this == e;
				}, i.prototype.toString = function() {
					return new i().constructor.name + "[x=" + this.x + ",y=" + this.y + "]";
				}, e.exports = i;
			},
			function(e, t, r) {
				function i(e, t, r, i) {
					this.x = 0, this.y = 0, this.width = 0, this.height = 0, null != e && null != t && null != r && null != i && (this.x = e, this.y = t, this.width = r, this.height = i);
				}
				h(i, "RectangleD"), i.prototype.getX = function() {
					return this.x;
				}, i.prototype.setX = function(e) {
					this.x = e;
				}, i.prototype.getY = function() {
					return this.y;
				}, i.prototype.setY = function(e) {
					this.y = e;
				}, i.prototype.getWidth = function() {
					return this.width;
				}, i.prototype.setWidth = function(e) {
					this.width = e;
				}, i.prototype.getHeight = function() {
					return this.height;
				}, i.prototype.setHeight = function(e) {
					this.height = e;
				}, i.prototype.getRight = function() {
					return this.x + this.width;
				}, i.prototype.getBottom = function() {
					return this.y + this.height;
				}, i.prototype.intersects = function(e) {
					return !(this.getRight() < e.x || this.getBottom() < e.y || e.getRight() < this.x || e.getBottom() < this.y);
				}, i.prototype.getCenterX = function() {
					return this.x + this.width / 2;
				}, i.prototype.getMinX = function() {
					return this.getX();
				}, i.prototype.getMaxX = function() {
					return this.getX() + this.width;
				}, i.prototype.getCenterY = function() {
					return this.y + this.height / 2;
				}, i.prototype.getMinY = function() {
					return this.getY();
				}, i.prototype.getMaxY = function() {
					return this.getY() + this.height;
				}, i.prototype.getWidthHalf = function() {
					return this.width / 2;
				}, i.prototype.getHeightHalf = function() {
					return this.height / 2;
				}, e.exports = i;
			},
			function(e, t, r) {
				var i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
					return typeof e;
				} : function(e) {
					return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
				};
				function n() {}
				h(n, "UniqueIDGeneretor"), n.lastID = 0, n.createID = function(e) {
					return n.isPrimitive(e) ? e : (e.uniqueID ?? (e.uniqueID = n.getString(), n.lastID++), e.uniqueID);
				}, n.getString = function(e) {
					return "Object#" + (e ??= n.lastID);
				}, n.isPrimitive = function(e) {
					var t = typeof e > "u" ? "undefined" : i(e);
					return null == e || "object" != t && "function" != t;
				}, e.exports = n;
			},
			function(e, t, r) {
				function i(e) {
					if (!Array.isArray(e)) return Array.from(e);
					for (var t = 0, r = Array(e.length); t < e.length; t++) r[t] = e[t];
					return r;
				}
				h(i, "_toConsumableArray");
				var n = r(0), a = r(6), s = r(3), o = r(1), l = r(5), u = r(4), d = r(17), p = r(27);
				function f(e) {
					p.call(this), this.layoutQuality = n.QUALITY, this.createBendsAsNeeded = n.DEFAULT_CREATE_BENDS_AS_NEEDED, this.incremental = n.DEFAULT_INCREMENTAL, this.animationOnLayout = n.DEFAULT_ANIMATION_ON_LAYOUT, this.animationDuringLayout = n.DEFAULT_ANIMATION_DURING_LAYOUT, this.animationPeriod = n.DEFAULT_ANIMATION_PERIOD, this.uniformLeafNodeSizes = n.DEFAULT_UNIFORM_LEAF_NODE_SIZES, this.edgeToDummyNodes = /* @__PURE__ */ new Map(), this.graphManager = new a(this), this.isLayoutFinished = !1, this.isSubLayout = !1, this.isRemoteUse = !1, null != e && (this.isRemoteUse = e);
				}
				h(f, "Layout"), f.RANDOM_SEED = 1, f.prototype = Object.create(p.prototype), f.prototype.getGraphManager = function() {
					return this.graphManager;
				}, f.prototype.getAllNodes = function() {
					return this.graphManager.getAllNodes();
				}, f.prototype.getAllEdges = function() {
					return this.graphManager.getAllEdges();
				}, f.prototype.getAllNodesToApplyGravitation = function() {
					return this.graphManager.getAllNodesToApplyGravitation();
				}, f.prototype.newGraphManager = function() {
					var e = new a(this);
					return this.graphManager = e, e;
				}, f.prototype.newGraph = function(e) {
					return new l(null, this.graphManager, e);
				}, f.prototype.newNode = function(e) {
					return new s(this.graphManager, e);
				}, f.prototype.newEdge = function(e) {
					return new o(null, null, e);
				}, f.prototype.checkLayoutSuccess = function() {
					return null == this.graphManager.getRoot() || 0 == this.graphManager.getRoot().getNodes().length || this.graphManager.includesInvalidEdge();
				}, f.prototype.runLayout = function() {
					var e;
					return this.isLayoutFinished = !1, this.tilingPreLayout && this.tilingPreLayout(), this.initParameters(), e = !this.checkLayoutSuccess() && this.layout(), "during" !== n.ANIMATE && (e && (this.isSubLayout || this.doPostLayout()), this.tilingPostLayout && this.tilingPostLayout(), this.isLayoutFinished = !0, e);
				}, f.prototype.doPostLayout = function() {
					this.incremental || this.transform(), this.update();
				}, f.prototype.update2 = function() {
					if (this.createBendsAsNeeded && (this.createBendpointsFromDummyNodes(), this.graphManager.resetAllEdges()), !this.isRemoteUse) {
						for (var e = this.graphManager.getAllEdges(), t = 0; t < e.length; t++) e[t];
						for (var r = this.graphManager.getRoot().getNodes(), t = 0; t < r.length; t++) r[t];
						this.update(this.graphManager.getRoot());
					}
				}, f.prototype.update = function(e) {
					if (null == e) this.update2();
					else if (e instanceof s) {
						if (null != e.getChild()) for (var t = e.getChild().getNodes(), r = 0; r < t.length; r++) update(t[r]);
						null != e.vGraphObject && e.vGraphObject.update(e);
					} else e instanceof o ? null != e.vGraphObject && e.vGraphObject.update(e) : e instanceof l && null != e.vGraphObject && e.vGraphObject.update(e);
				}, f.prototype.initParameters = function() {
					this.isSubLayout || (this.layoutQuality = n.QUALITY, this.animationDuringLayout = n.DEFAULT_ANIMATION_DURING_LAYOUT, this.animationPeriod = n.DEFAULT_ANIMATION_PERIOD, this.animationOnLayout = n.DEFAULT_ANIMATION_ON_LAYOUT, this.incremental = n.DEFAULT_INCREMENTAL, this.createBendsAsNeeded = n.DEFAULT_CREATE_BENDS_AS_NEEDED, this.uniformLeafNodeSizes = n.DEFAULT_UNIFORM_LEAF_NODE_SIZES), this.animationDuringLayout && (this.animationOnLayout = !1);
				}, f.prototype.transform = function(e) {
					if (null == e) this.transform(new u(0, 0));
					else {
						var t = new d(), r = this.graphManager.getRoot().updateLeftTop();
						if (null != r) {
							t.setWorldOrgX(e.x), t.setWorldOrgY(e.y), t.setDeviceOrgX(r.x), t.setDeviceOrgY(r.y);
							for (var i = this.getAllNodes(), n = 0; n < i.length; n++) i[n].transform(t);
						}
					}
				}, f.prototype.positionNodesRandomly = function(e) {
					if (null == e) this.positionNodesRandomly(this.getGraphManager().getRoot()), this.getGraphManager().getRoot().updateBounds(!0);
					else for (var t, r, i = e.getNodes(), n = 0; n < i.length; n++) null == (r = (t = i[n]).getChild()) || 0 == r.getNodes().length ? t.scatter() : (this.positionNodesRandomly(r), t.updateBounds());
				}, f.prototype.getFlatForest = function() {
					for (var e = [], t = !0, r = this.graphManager.getRoot().getNodes(), n = !0, a = 0; a < r.length; a++) null != r[a].getChild() && (n = !1);
					if (!n) return e;
					var s = /* @__PURE__ */ new Set(), o = [], l = /* @__PURE__ */ new Map(), h = [];
					for (h = h.concat(r); h.length > 0 && t;) {
						for (o.push(h[0]); o.length > 0 && t;) {
							var u = o[0];
							o.splice(0, 1), s.add(u);
							for (var d = u.getEdges(), a = 0; a < d.length; a++) {
								var p = d[a].getOtherEnd(u);
								if (l.get(u) != p) if (s.has(p)) {
									t = !1;
									break;
								} else o.push(p), l.set(p, u);
							}
						}
						if (t) {
							var f = [].concat(i(s));
							e.push(f);
							for (var a = 0; a < f.length; a++) {
								var g = f[a], m = h.indexOf(g);
								m > -1 && h.splice(m, 1);
							}
							s = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Map();
						} else e = [];
					}
					return e;
				}, f.prototype.createDummyNodesForBendpoints = function(e) {
					for (var t = [], r = e.source, i = this.graphManager.calcLowestCommonAncestor(e.source, e.target), n = 0; n < e.bendpoints.length; n++) {
						var a = this.newNode(null);
						a.setRect(new Point(0, 0), new Dimension(1, 1)), i.add(a);
						var s = this.newEdge(null);
						this.graphManager.add(s, r, a), t.add(a), r = a;
					}
					var s = this.newEdge(null);
					return this.graphManager.add(s, r, e.target), this.edgeToDummyNodes.set(e, t), e.isInterGraph() ? this.graphManager.remove(e) : i.remove(e), t;
				}, f.prototype.createBendpointsFromDummyNodes = function() {
					var e = [];
					e = e.concat(this.graphManager.getAllEdges()), e = [].concat(i(this.edgeToDummyNodes.keys())).concat(e);
					for (var t = 0; t < e.length; t++) {
						var r = e[t];
						if (r.bendpoints.length > 0) {
							for (var n = this.edgeToDummyNodes.get(r), a = 0; a < n.length; a++) {
								var s = n[a], o = new u(s.getCenterX(), s.getCenterY()), l = r.bendpoints.get(a);
								l.x = o.x, l.y = o.y, s.getOwner().remove(s);
							}
							this.graphManager.add(r, r.source, r.target);
						}
					}
				}, f.transform = function(e, t, r, i) {
					if (null == r || null == i) return e <= 50 ? (n = 9 * t / 500, a = t / 10) : (n = 9 * t / 50, a = -8 * t), n * e + a;
					var n, a, s = t;
					return e <= 50 ? s -= (t - t / r) / 50 * (50 - e) : s += (t * i - t) / 50 * (e - 50), s;
				}, f.findCenterOfTree = function(e) {
					var t = [];
					t = t.concat(e);
					var r = [], i = /* @__PURE__ */ new Map(), n = !1, a = null;
					(1 == t.length || 2 == t.length) && (n = !0, a = t[0]);
					for (var s = 0; s < t.length; s++) {
						var o = t[s], l = o.getNeighborsList().size;
						i.set(o, o.getNeighborsList().size), 1 == l && r.push(o);
					}
					var h = [];
					for (h = h.concat(r); !n;) {
						var u = [];
						u = u.concat(h), h = [];
						for (var s = 0; s < t.length; s++) {
							var o = t[s], d = t.indexOf(o);
							d >= 0 && t.splice(d, 1), o.getNeighborsList().forEach(function(e) {
								if (0 > r.indexOf(e)) {
									var t = i.get(e) - 1;
									1 == t && h.push(e), i.set(e, t);
								}
							});
						}
						r = r.concat(h), (1 == t.length || 2 == t.length) && (n = !0, a = t[0]);
					}
					return a;
				}, f.prototype.setGraphManager = function(e) {
					this.graphManager = e;
				}, e.exports = f;
			},
			function(e, t, r) {
				function i() {}
				h(i, "RandomSeed"), i.seed = 1, i.x = 0, i.nextDouble = function() {
					return i.x = 1e4 * Math.sin(i.seed++), i.x - Math.floor(i.x);
				}, e.exports = i;
			},
			function(e, t, r) {
				var i = r(4);
				function n(e, t) {
					this.lworldOrgX = 0, this.lworldOrgY = 0, this.ldeviceOrgX = 0, this.ldeviceOrgY = 0, this.lworldExtX = 1, this.lworldExtY = 1, this.ldeviceExtX = 1, this.ldeviceExtY = 1;
				}
				h(n, "Transform"), n.prototype.getWorldOrgX = function() {
					return this.lworldOrgX;
				}, n.prototype.setWorldOrgX = function(e) {
					this.lworldOrgX = e;
				}, n.prototype.getWorldOrgY = function() {
					return this.lworldOrgY;
				}, n.prototype.setWorldOrgY = function(e) {
					this.lworldOrgY = e;
				}, n.prototype.getWorldExtX = function() {
					return this.lworldExtX;
				}, n.prototype.setWorldExtX = function(e) {
					this.lworldExtX = e;
				}, n.prototype.getWorldExtY = function() {
					return this.lworldExtY;
				}, n.prototype.setWorldExtY = function(e) {
					this.lworldExtY = e;
				}, n.prototype.getDeviceOrgX = function() {
					return this.ldeviceOrgX;
				}, n.prototype.setDeviceOrgX = function(e) {
					this.ldeviceOrgX = e;
				}, n.prototype.getDeviceOrgY = function() {
					return this.ldeviceOrgY;
				}, n.prototype.setDeviceOrgY = function(e) {
					this.ldeviceOrgY = e;
				}, n.prototype.getDeviceExtX = function() {
					return this.ldeviceExtX;
				}, n.prototype.setDeviceExtX = function(e) {
					this.ldeviceExtX = e;
				}, n.prototype.getDeviceExtY = function() {
					return this.ldeviceExtY;
				}, n.prototype.setDeviceExtY = function(e) {
					this.ldeviceExtY = e;
				}, n.prototype.transformX = function(e) {
					var t = 0, r = this.lworldExtX;
					return 0 != r && (t = this.ldeviceOrgX + (e - this.lworldOrgX) * this.ldeviceExtX / r), t;
				}, n.prototype.transformY = function(e) {
					var t = 0, r = this.lworldExtY;
					return 0 != r && (t = this.ldeviceOrgY + (e - this.lworldOrgY) * this.ldeviceExtY / r), t;
				}, n.prototype.inverseTransformX = function(e) {
					var t = 0, r = this.ldeviceExtX;
					return 0 != r && (t = this.lworldOrgX + (e - this.ldeviceOrgX) * this.lworldExtX / r), t;
				}, n.prototype.inverseTransformY = function(e) {
					var t = 0, r = this.ldeviceExtY;
					return 0 != r && (t = this.lworldOrgY + (e - this.ldeviceOrgY) * this.lworldExtY / r), t;
				}, n.prototype.inverseTransformPoint = function(e) {
					return new i(this.inverseTransformX(e.x), this.inverseTransformY(e.y));
				}, e.exports = n;
			},
			function(e, t, r) {
				function i(e) {
					if (!Array.isArray(e)) return Array.from(e);
					for (var t = 0, r = Array(e.length); t < e.length; t++) r[t] = e[t];
					return r;
				}
				h(i, "_toConsumableArray");
				var n = r(15), a = r(7), s = r(0), o = r(8), l = r(9);
				function u() {
					n.call(this), this.useSmartIdealEdgeLengthCalculation = a.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION, this.idealEdgeLength = a.DEFAULT_EDGE_LENGTH, this.springConstant = a.DEFAULT_SPRING_STRENGTH, this.repulsionConstant = a.DEFAULT_REPULSION_STRENGTH, this.gravityConstant = a.DEFAULT_GRAVITY_STRENGTH, this.compoundGravityConstant = a.DEFAULT_COMPOUND_GRAVITY_STRENGTH, this.gravityRangeFactor = a.DEFAULT_GRAVITY_RANGE_FACTOR, this.compoundGravityRangeFactor = a.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR, this.displacementThresholdPerNode = 3 * a.DEFAULT_EDGE_LENGTH / 100, this.coolingFactor = a.DEFAULT_COOLING_FACTOR_INCREMENTAL, this.initialCoolingFactor = a.DEFAULT_COOLING_FACTOR_INCREMENTAL, this.totalDisplacement = 0, this.oldTotalDisplacement = 0, this.maxIterations = a.MAX_ITERATIONS;
				}
				for (var d in h(u, "FDLayout"), u.prototype = Object.create(n.prototype), n) u[d] = n[d];
				u.prototype.initParameters = function() {
					n.prototype.initParameters.call(this, arguments), this.totalIterations = 0, this.notAnimatedIterations = 0, this.useFRGridVariant = a.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION, this.grid = [];
				}, u.prototype.calcIdealEdgeLengths = function() {
					for (var e, t, r, i, n, o, l = this.getGraphManager().getAllEdges(), h = 0; h < l.length; h++) (e = l[h]).idealLength = this.idealEdgeLength, e.isInterGraph && (r = e.getSource(), i = e.getTarget(), n = e.getSourceInLca().getEstimatedSize(), o = e.getTargetInLca().getEstimatedSize(), this.useSmartIdealEdgeLengthCalculation && (e.idealLength += n + o - 2 * s.SIMPLE_NODE_SIZE), t = e.getLca().getInclusionTreeDepth(), e.idealLength += a.DEFAULT_EDGE_LENGTH * a.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (r.getInclusionTreeDepth() + i.getInclusionTreeDepth() - 2 * t));
				}, u.prototype.initSpringEmbedder = function() {
					var e = this.getAllNodes().length;
					this.incremental ? (e > a.ADAPTATION_LOWER_NODE_LIMIT && (this.coolingFactor = Math.max(this.coolingFactor * a.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (e - a.ADAPTATION_LOWER_NODE_LIMIT) / (a.ADAPTATION_UPPER_NODE_LIMIT - a.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - a.COOLING_ADAPTATION_FACTOR))), this.maxNodeDisplacement = a.MAX_NODE_DISPLACEMENT_INCREMENTAL) : (e > a.ADAPTATION_LOWER_NODE_LIMIT ? this.coolingFactor = Math.max(a.COOLING_ADAPTATION_FACTOR, 1 - (e - a.ADAPTATION_LOWER_NODE_LIMIT) / (a.ADAPTATION_UPPER_NODE_LIMIT - a.ADAPTATION_LOWER_NODE_LIMIT) * (1 - a.COOLING_ADAPTATION_FACTOR)) : this.coolingFactor = 1, this.initialCoolingFactor = this.coolingFactor, this.maxNodeDisplacement = a.MAX_NODE_DISPLACEMENT), this.maxIterations = Math.max(5 * this.getAllNodes().length, this.maxIterations), this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length, this.repulsionRange = this.calcRepulsionRange();
				}, u.prototype.calcSpringForces = function() {
					for (var e, t = this.getAllEdges(), r = 0; r < t.length; r++) e = t[r], this.calcSpringForce(e, e.idealLength);
				}, u.prototype.calcRepulsionForces = function() {
					var e, t, r, i, n, s = !(arguments.length > 0) || void 0 === arguments[0] || arguments[0], o = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], l = this.getAllNodes();
					if (this.useFRGridVariant) for (this.totalIterations % a.GRID_CALCULATION_CHECK_PERIOD == 1 && s && this.updateGrid(), n = /* @__PURE__ */ new Set(), e = 0; e < l.length; e++) r = l[e], this.calculateRepulsionForceOfANode(r, n, s, o), n.add(r);
					else for (e = 0; e < l.length; e++) for (r = l[e], t = e + 1; t < l.length; t++) i = l[t], r.getOwner() == i.getOwner() && this.calcRepulsionForce(r, i);
				}, u.prototype.calcGravitationalForces = function() {
					for (var e, t = this.getAllNodesToApplyGravitation(), r = 0; r < t.length; r++) e = t[r], this.calcGravitationalForce(e);
				}, u.prototype.moveNodes = function() {
					for (var e = this.getAllNodes(), t = 0; t < e.length; t++) e[t].move();
				}, u.prototype.calcSpringForce = function(e, t) {
					var r, i, n, a, s = e.getSource(), o = e.getTarget();
					if (this.uniformLeafNodeSizes && null == s.getChild() && null == o.getChild()) e.updateLengthSimple();
					else if (e.updateLength(), e.isOverlapingSourceAndTarget) return;
					0 != (r = e.getLength()) && (n = (i = this.springConstant * (r - t)) * (e.lengthX / r), a = i * (e.lengthY / r), s.springForceX += n, s.springForceY += a, o.springForceX -= n, o.springForceY -= a);
				}, u.prototype.calcRepulsionForce = function(e, t) {
					var r, i, n, s, h, u, d, p = e.getRect(), f = t.getRect(), g = [, ,], m = [
						,
						,
						,
						,
					];
					if (p.intersects(f)) {
						o.calcSeparationAmount(p, f, g, a.DEFAULT_EDGE_LENGTH / 2), u = 2 * g[0], d = 2 * g[1];
						var y = e.noOfChildren * t.noOfChildren / (e.noOfChildren + t.noOfChildren);
						e.repulsionForceX -= y * u, e.repulsionForceY -= y * d, t.repulsionForceX += y * u, t.repulsionForceY += y * d;
					} else this.uniformLeafNodeSizes && null == e.getChild() && null == t.getChild() ? (r = f.getCenterX() - p.getCenterX(), i = f.getCenterY() - p.getCenterY()) : (o.getIntersection(p, f, m), r = m[2] - m[0], i = m[3] - m[1]), Math.abs(r) < a.MIN_REPULSION_DIST && (r = l.sign(r) * a.MIN_REPULSION_DIST), Math.abs(i) < a.MIN_REPULSION_DIST && (i = l.sign(i) * a.MIN_REPULSION_DIST), s = Math.sqrt(n = r * r + i * i), u = (h = this.repulsionConstant * e.noOfChildren * t.noOfChildren / n) * r / s, d = h * i / s, e.repulsionForceX -= u, e.repulsionForceY -= d, t.repulsionForceX += u, t.repulsionForceY += d;
				}, u.prototype.calcGravitationalForce = function(e) {
					var t, r = e.getOwner(), i = (r.getRight() + r.getLeft()) / 2, n = (r.getTop() + r.getBottom()) / 2, a = e.getCenterX() - i, s = e.getCenterY() - n, o = Math.abs(a) + e.getWidth() / 2, l = Math.abs(s) + e.getHeight() / 2;
					e.getOwner() == this.graphManager.getRoot() ? (o > (t = r.getEstimatedSize() * this.gravityRangeFactor) || l > t) && (e.gravitationForceX = -this.gravityConstant * a, e.gravitationForceY = -this.gravityConstant * s) : (o > (t = r.getEstimatedSize() * this.compoundGravityRangeFactor) || l > t) && (e.gravitationForceX = -this.gravityConstant * a * this.compoundGravityConstant, e.gravitationForceY = -this.gravityConstant * s * this.compoundGravityConstant);
				}, u.prototype.isConverged = function() {
					var e, t = !1;
					return this.totalIterations > this.maxIterations / 3 && (t = 2 > Math.abs(this.totalDisplacement - this.oldTotalDisplacement)), e = this.totalDisplacement < this.totalDisplacementThreshold, this.oldTotalDisplacement = this.totalDisplacement, e || t;
				}, u.prototype.animate = function() {
					this.animationDuringLayout && !this.isSubLayout && (this.notAnimatedIterations == this.animationPeriod ? (this.update(), this.notAnimatedIterations = 0) : this.notAnimatedIterations++);
				}, u.prototype.calcNoOfChildrenForAllNodes = function() {
					for (var e, t = this.graphManager.getAllNodes(), r = 0; r < t.length; r++) (e = t[r]).noOfChildren = e.getNoOfChildren();
				}, u.prototype.calcGrid = function(e) {
					var t = 0, r = 0;
					t = parseInt(Math.ceil((e.getRight() - e.getLeft()) / this.repulsionRange)), r = parseInt(Math.ceil((e.getBottom() - e.getTop()) / this.repulsionRange));
					for (var i = Array(t), n = 0; n < t; n++) i[n] = Array(r);
					for (var n = 0; n < t; n++) for (var a = 0; a < r; a++) i[n][a] = [];
					return i;
				}, u.prototype.addNodeToGrid = function(e, t, r) {
					var i = 0, n = 0, a = 0, s = 0;
					i = parseInt(Math.floor((e.getRect().x - t) / this.repulsionRange)), n = parseInt(Math.floor((e.getRect().width + e.getRect().x - t) / this.repulsionRange)), a = parseInt(Math.floor((e.getRect().y - r) / this.repulsionRange)), s = parseInt(Math.floor((e.getRect().height + e.getRect().y - r) / this.repulsionRange));
					for (var o = i; o <= n; o++) for (var l = a; l <= s; l++) this.grid[o][l].push(e), e.setGridCoordinates(i, n, a, s);
				}, u.prototype.updateGrid = function() {
					var e, t, r = this.getAllNodes();
					for (this.grid = this.calcGrid(this.graphManager.getRoot()), e = 0; e < r.length; e++) t = r[e], this.addNodeToGrid(t, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());
				}, u.prototype.calculateRepulsionForceOfANode = function(e, t, r, n) {
					if (this.totalIterations % a.GRID_CALCULATION_CHECK_PERIOD == 1 && r || n) {
						var s = /* @__PURE__ */ new Set();
						e.surrounding = [];
						for (var o, l = this.grid, h = e.startX - 1; h < e.finishX + 2; h++) for (var u = e.startY - 1; u < e.finishY + 2; u++) if (!(h < 0 || u < 0 || h >= l.length || u >= l[0].length)) {
							for (var d = 0; d < l[h][u].length; d++) if (o = l[h][u][d], e.getOwner() == o.getOwner() && e != o && !t.has(o) && !s.has(o)) {
								var p = Math.abs(e.getCenterX() - o.getCenterX()) - (e.getWidth() / 2 + o.getWidth() / 2), f = Math.abs(e.getCenterY() - o.getCenterY()) - (e.getHeight() / 2 + o.getHeight() / 2);
								p <= this.repulsionRange && f <= this.repulsionRange && s.add(o);
							}
						}
						e.surrounding = [].concat(i(s));
					}
					for (h = 0; h < e.surrounding.length; h++) this.calcRepulsionForce(e, e.surrounding[h]);
				}, u.prototype.calcRepulsionRange = function() {
					return 0;
				}, e.exports = u;
			},
			function(e, t, r) {
				var i = r(1), n = r(7);
				function a(e, t, r) {
					i.call(this, e, t, r), this.idealLength = n.DEFAULT_EDGE_LENGTH;
				}
				for (var s in h(a, "FDLayoutEdge"), a.prototype = Object.create(i.prototype), i) a[s] = i[s];
				e.exports = a;
			},
			function(e, t, r) {
				var i = r(3);
				function n(e, t, r, n) {
					i.call(this, e, t, r, n), this.springForceX = 0, this.springForceY = 0, this.repulsionForceX = 0, this.repulsionForceY = 0, this.gravitationForceX = 0, this.gravitationForceY = 0, this.displacementX = 0, this.displacementY = 0, this.startX = 0, this.finishX = 0, this.startY = 0, this.finishY = 0, this.surrounding = [];
				}
				for (var a in h(n, "FDLayoutNode"), n.prototype = Object.create(i.prototype), i) n[a] = i[a];
				n.prototype.setGridCoordinates = function(e, t, r, i) {
					this.startX = e, this.finishX = t, this.startY = r, this.finishY = i;
				}, e.exports = n;
			},
			function(e, t, r) {
				function i(e, t) {
					this.width = 0, this.height = 0, null !== e && null !== t && (this.height = t, this.width = e);
				}
				h(i, "DimensionD"), i.prototype.getWidth = function() {
					return this.width;
				}, i.prototype.setWidth = function(e) {
					this.width = e;
				}, i.prototype.getHeight = function() {
					return this.height;
				}, i.prototype.setHeight = function(e) {
					this.height = e;
				}, e.exports = i;
			},
			function(e, t, r) {
				var i = r(14);
				function n() {
					this.map = {}, this.keys = [];
				}
				h(n, "HashMap"), n.prototype.put = function(e, t) {
					var r = i.createID(e);
					this.contains(r) || (this.map[r] = t, this.keys.push(e));
				}, n.prototype.contains = function(e) {
					return i.createID(e), null != this.map[e];
				}, n.prototype.get = function(e) {
					var t = i.createID(e);
					return this.map[t];
				}, n.prototype.keySet = function() {
					return this.keys;
				}, e.exports = n;
			},
			function(e, t, r) {
				var i = r(14);
				function n() {
					this.set = {};
				}
				h(n, "HashSet"), n.prototype.add = function(e) {
					var t = i.createID(e);
					this.contains(t) || (this.set[t] = e);
				}, n.prototype.remove = function(e) {
					delete this.set[i.createID(e)];
				}, n.prototype.clear = function() {
					this.set = {};
				}, n.prototype.contains = function(e) {
					return this.set[i.createID(e)] == e;
				}, n.prototype.isEmpty = function() {
					return 0 === this.size();
				}, n.prototype.size = function() {
					return Object.keys(this.set).length;
				}, n.prototype.addAllTo = function(e) {
					for (var t = Object.keys(this.set), r = t.length, i = 0; i < r; i++) e.push(this.set[t[i]]);
				}, n.prototype.size = function() {
					return Object.keys(this.set).length;
				}, n.prototype.addAll = function(e) {
					for (var t = e.length, r = 0; r < t; r++) {
						var i = e[r];
						this.add(i);
					}
				}, e.exports = n;
			},
			function(e, t, r) {
				var i = function() {
					function e(e, t) {
						for (var r = 0; r < t.length; r++) {
							var i = t[r];
							i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
						}
					}
					return h(e, "defineProperties"), function(t, r, i) {
						return r && e(t.prototype, r), i && e(t, i), t;
					};
				}();
				function n(e, t) {
					if (!(e instanceof t)) throw TypeError("Cannot call a class as a function");
				}
				h(n, "_classCallCheck");
				var a = r(11);
				e.exports = function() {
					function e(t, r) {
						n(this, e), (null !== r || void 0 !== r) && (this.compareFunction = this._defaultCompareFunction);
						var i = void 0;
						i = t instanceof a ? t.size() : t.length, this._quicksort(t, 0, i - 1);
					}
					return h(e, "Quicksort"), i(e, [
						{
							key: "_quicksort",
							value: h(function(e, t, r) {
								if (t < r) {
									var i = this._partition(e, t, r);
									this._quicksort(e, t, i), this._quicksort(e, i + 1, r);
								}
							}, "_quicksort")
						},
						{
							key: "_partition",
							value: h(function(e, t, r) {
								for (var i = this._get(e, t), n = t, a = r;;) {
									for (; this.compareFunction(i, this._get(e, a));) a--;
									for (; this.compareFunction(this._get(e, n), i);) n++;
									if (!(n < a)) return a;
									this._swap(e, n, a), n++, a--;
								}
							}, "_partition")
						},
						{
							key: "_get",
							value: h(function(e, t) {
								return e instanceof a ? e.get_object_at(t) : e[t];
							}, "_get")
						},
						{
							key: "_set",
							value: h(function(e, t, r) {
								e instanceof a ? e.set_object_at(t, r) : e[t] = r;
							}, "_set")
						},
						{
							key: "_swap",
							value: h(function(e, t, r) {
								var i = this._get(e, t);
								this._set(e, t, this._get(e, r)), this._set(e, r, i);
							}, "_swap")
						},
						{
							key: "_defaultCompareFunction",
							value: h(function(e, t) {
								return t > e;
							}, "_defaultCompareFunction")
						}
					]), e;
				}();
			},
			function(e, t, r) {
				var i = function() {
					function e(e, t) {
						for (var r = 0; r < t.length; r++) {
							var i = t[r];
							i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);
						}
					}
					return h(e, "defineProperties"), function(t, r, i) {
						return r && e(t.prototype, r), i && e(t, i), t;
					};
				}();
				function n(e, t) {
					if (!(e instanceof t)) throw TypeError("Cannot call a class as a function");
				}
				h(n, "_classCallCheck"), e.exports = function() {
					function e(t, r) {
						var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : -1, s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : -1;
						n(this, e), this.sequence1 = t, this.sequence2 = r, this.match_score = i, this.mismatch_penalty = a, this.gap_penalty = s, this.iMax = t.length + 1, this.jMax = r.length + 1, this.grid = Array(this.iMax);
						for (var o = 0; o < this.iMax; o++) {
							this.grid[o] = Array(this.jMax);
							for (var l = 0; l < this.jMax; l++) this.grid[o][l] = 0;
						}
						this.tracebackGrid = Array(this.iMax);
						for (var h = 0; h < this.iMax; h++) {
							this.tracebackGrid[h] = Array(this.jMax);
							for (var u = 0; u < this.jMax; u++) this.tracebackGrid[h][u] = [
								null,
								null,
								null
							];
						}
						this.alignments = [], this.score = -1, this.computeGrids();
					}
					return h(e, "NeedlemanWunsch"), i(e, [
						{
							key: "getScore",
							value: h(function() {
								return this.score;
							}, "getScore")
						},
						{
							key: "getAlignments",
							value: h(function() {
								return this.alignments;
							}, "getAlignments")
						},
						{
							key: "computeGrids",
							value: h(function() {
								for (var e = 1; e < this.jMax; e++) this.grid[0][e] = this.grid[0][e - 1] + this.gap_penalty, this.tracebackGrid[0][e] = [
									!1,
									!1,
									!0
								];
								for (var t = 1; t < this.iMax; t++) this.grid[t][0] = this.grid[t - 1][0] + this.gap_penalty, this.tracebackGrid[t][0] = [
									!1,
									!0,
									!1
								];
								for (var r = 1; r < this.iMax; r++) for (var i = 1; i < this.jMax; i++) {
									var n = [
										this.sequence1[r - 1] === this.sequence2[i - 1] ? this.grid[r - 1][i - 1] + this.match_score : this.grid[r - 1][i - 1] + this.mismatch_penalty,
										this.grid[r - 1][i] + this.gap_penalty,
										this.grid[r][i - 1] + this.gap_penalty
									], a = this.arrayAllMaxIndexes(n);
									this.grid[r][i] = n[a[0]], this.tracebackGrid[r][i] = [
										a.includes(0),
										a.includes(1),
										a.includes(2)
									];
								}
								this.score = this.grid[this.iMax - 1][this.jMax - 1];
							}, "computeGrids")
						},
						{
							key: "alignmentTraceback",
							value: h(function() {
								var e = [];
								for (e.push({
									pos: [this.sequence1.length, this.sequence2.length],
									seq1: "",
									seq2: ""
								}); e[0];) {
									var t = e[0], r = this.tracebackGrid[t.pos[0]][t.pos[1]];
									r[0] && e.push({
										pos: [t.pos[0] - 1, t.pos[1] - 1],
										seq1: this.sequence1[t.pos[0] - 1] + t.seq1,
										seq2: this.sequence2[t.pos[1] - 1] + t.seq2
									}), r[1] && e.push({
										pos: [t.pos[0] - 1, t.pos[1]],
										seq1: this.sequence1[t.pos[0] - 1] + t.seq1,
										seq2: "-" + t.seq2
									}), r[2] && e.push({
										pos: [t.pos[0], t.pos[1] - 1],
										seq1: "-" + t.seq1,
										seq2: this.sequence2[t.pos[1] - 1] + t.seq2
									}), 0 === t.pos[0] && 0 === t.pos[1] && this.alignments.push({
										sequence1: t.seq1,
										sequence2: t.seq2
									}), e.shift();
								}
								return this.alignments;
							}, "alignmentTraceback")
						},
						{
							key: "getAllIndexes",
							value: h(function(e, t) {
								for (var r = [], i = -1; -1 !== (i = e.indexOf(t, i + 1));) r.push(i);
								return r;
							}, "getAllIndexes")
						},
						{
							key: "arrayAllMaxIndexes",
							value: h(function(e) {
								return this.getAllIndexes(e, Math.max.apply(null, e));
							}, "arrayAllMaxIndexes")
						}
					]), e;
				}();
			},
			function(e, t, r) {
				var i = h(function() {}, "layoutBase");
				i.FDLayout = r(18), i.FDLayoutConstants = r(7), i.FDLayoutEdge = r(19), i.FDLayoutNode = r(20), i.DimensionD = r(21), i.HashMap = r(22), i.HashSet = r(23), i.IGeometry = r(8), i.IMath = r(9), i.Integer = r(10), i.Point = r(12), i.PointD = r(4), i.RandomSeed = r(16), i.RectangleD = r(13), i.Transform = r(17), i.UniqueIDGeneretor = r(14), i.Quicksort = r(24), i.LinkedList = r(11), i.LGraphObject = r(2), i.LGraph = r(5), i.LEdge = r(1), i.LGraphManager = r(6), i.LNode = r(3), i.Layout = r(15), i.LayoutConstants = r(0), i.NeedlemanWunsch = r(25), e.exports = i;
			},
			function(e, t, r) {
				function i() {
					this.listeners = [];
				}
				h(i, "Emitter");
				var n = i.prototype;
				n.addListener = function(e, t) {
					this.listeners.push({
						event: e,
						callback: t
					});
				}, n.removeListener = function(e, t) {
					for (var r = this.listeners.length; r >= 0; r--) {
						var i = this.listeners[r];
						i.event === e && i.callback === t && this.listeners.splice(r, 1);
					}
				}, n.emit = function(e, t) {
					for (var r = 0; r < this.listeners.length; r++) {
						var i = this.listeners[r];
						e === i.event && i.callback(t);
					}
				}, e.exports = i;
			}
		], t = {};
		function r(i) {
			if (t[i]) return t[i].exports;
			var n = t[i] = {
				i,
				l: !1,
				exports: {}
			};
			return e[i].call(n.exports, n, n.exports, r), n.l = !0, n.exports;
		}
		return h(r, "__webpack_require__"), r.m = e, r.c = t, r.i = function(e) {
			return e;
		}, r.d = function(e, t, i) {
			r.o(e, t) || Object.defineProperty(e, t, {
				configurable: !1,
				enumerable: !0,
				get: i
			});
		}, r.n = function(e) {
			var t = e && e.__esModule ? h(function() {
				return e.default;
			}, "getDefault") : h(function() {
				return e;
			}, "getModuleExports");
			return r.d(t, "a", t), t;
		}, r.o = function(e, t) {
			return Object.prototype.hasOwnProperty.call(e, t);
		}, r.p = "", r(r.s = 26);
	});
}), eiv = u((e, t) => {
	h(function(r, i) {
		"object" == typeof e && "object" == typeof t ? t.exports = i(eiy()) : "function" == typeof define && define.amd ? define(["layout-base"], i) : "object" == typeof e ? e.coseBase = i(eiy()) : r.coseBase = i(r.layoutBase);
	}, "webpackUniversalModuleDefinition")(e, function(e) {
		var t = [
			function(t, r) {
				t.exports = e;
			},
			function(e, t, r) {
				var i = r(0).FDLayoutConstants;
				function n() {}
				for (var a in h(n, "CoSEConstants"), i) n[a] = i[a];
				n.DEFAULT_USE_MULTI_LEVEL_SCALING = !1, n.DEFAULT_RADIAL_SEPARATION = i.DEFAULT_EDGE_LENGTH, n.DEFAULT_COMPONENT_SEPERATION = 60, n.TILE = !0, n.TILING_PADDING_VERTICAL = 10, n.TILING_PADDING_HORIZONTAL = 10, n.TREE_REDUCTION_ON_INCREMENTAL = !1, e.exports = n;
			},
			function(e, t, r) {
				var i = r(0).FDLayoutEdge;
				function n(e, t, r) {
					i.call(this, e, t, r);
				}
				for (var a in h(n, "CoSEEdge"), n.prototype = Object.create(i.prototype), i) n[a] = i[a];
				e.exports = n;
			},
			function(e, t, r) {
				var i = r(0).LGraph;
				function n(e, t, r) {
					i.call(this, e, t, r);
				}
				for (var a in h(n, "CoSEGraph"), n.prototype = Object.create(i.prototype), i) n[a] = i[a];
				e.exports = n;
			},
			function(e, t, r) {
				var i = r(0).LGraphManager;
				function n(e) {
					i.call(this, e);
				}
				for (var a in h(n, "CoSEGraphManager"), n.prototype = Object.create(i.prototype), i) n[a] = i[a];
				e.exports = n;
			},
			function(e, t, r) {
				var i = r(0).FDLayoutNode, n = r(0).IMath;
				function a(e, t, r, n) {
					i.call(this, e, t, r, n);
				}
				for (var s in h(a, "CoSENode"), a.prototype = Object.create(i.prototype), i) a[s] = i[s];
				a.prototype.move = function() {
					var e = this.graphManager.getLayout();
					this.displacementX = e.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren, this.displacementY = e.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren, Math.abs(this.displacementX) > e.coolingFactor * e.maxNodeDisplacement && (this.displacementX = e.coolingFactor * e.maxNodeDisplacement * n.sign(this.displacementX)), Math.abs(this.displacementY) > e.coolingFactor * e.maxNodeDisplacement && (this.displacementY = e.coolingFactor * e.maxNodeDisplacement * n.sign(this.displacementY)), null == this.child || 0 == this.child.getNodes().length ? this.moveBy(this.displacementX, this.displacementY) : this.propogateDisplacementToChildren(this.displacementX, this.displacementY), e.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY), this.springForceX = 0, this.springForceY = 0, this.repulsionForceX = 0, this.repulsionForceY = 0, this.gravitationForceX = 0, this.gravitationForceY = 0, this.displacementX = 0, this.displacementY = 0;
				}, a.prototype.propogateDisplacementToChildren = function(e, t) {
					for (var r, i = this.getChild().getNodes(), n = 0; n < i.length; n++) null == (r = i[n]).getChild() ? (r.moveBy(e, t), r.displacementX += e, r.displacementY += t) : r.propogateDisplacementToChildren(e, t);
				}, a.prototype.setPred1 = function(e) {
					this.pred1 = e;
				}, a.prototype.getPred1 = function() {
					return pred1;
				}, a.prototype.getPred2 = function() {
					return pred2;
				}, a.prototype.setNext = function(e) {
					this.next = e;
				}, a.prototype.getNext = function() {
					return next;
				}, a.prototype.setProcessed = function(e) {
					this.processed = e;
				}, a.prototype.isProcessed = function() {
					return processed;
				}, e.exports = a;
			},
			function(e, t, r) {
				var i = r(0).FDLayout, n = r(4), a = r(3), s = r(5), o = r(2), l = r(1), u = r(0).FDLayoutConstants, d = r(0).LayoutConstants, p = r(0).Point, f = r(0).PointD, g = r(0).Layout, m = r(0).Integer, y = r(0).IGeometry, v = r(0).LGraph, x = r(0).Transform;
				function b() {
					i.call(this), this.toBeTiled = {};
				}
				for (var w in h(b, "CoSELayout"), b.prototype = Object.create(i.prototype), i) b[w] = i[w];
				b.prototype.newGraphManager = function() {
					var e = new n(this);
					return this.graphManager = e, e;
				}, b.prototype.newGraph = function(e) {
					return new a(null, this.graphManager, e);
				}, b.prototype.newNode = function(e) {
					return new s(this.graphManager, e);
				}, b.prototype.newEdge = function(e) {
					return new o(null, null, e);
				}, b.prototype.initParameters = function() {
					i.prototype.initParameters.call(this, arguments), this.isSubLayout || (l.DEFAULT_EDGE_LENGTH < 10 ? this.idealEdgeLength = 10 : this.idealEdgeLength = l.DEFAULT_EDGE_LENGTH, this.useSmartIdealEdgeLengthCalculation = l.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION, this.springConstant = u.DEFAULT_SPRING_STRENGTH, this.repulsionConstant = u.DEFAULT_REPULSION_STRENGTH, this.gravityConstant = u.DEFAULT_GRAVITY_STRENGTH, this.compoundGravityConstant = u.DEFAULT_COMPOUND_GRAVITY_STRENGTH, this.gravityRangeFactor = u.DEFAULT_GRAVITY_RANGE_FACTOR, this.compoundGravityRangeFactor = u.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR, this.prunedNodesAll = [], this.growTreeIterations = 0, this.afterGrowthIterations = 0, this.isTreeGrowing = !1, this.isGrowthFinished = !1, this.coolingCycle = 0, this.maxCoolingCycle = this.maxIterations / u.CONVERGENCE_CHECK_PERIOD, this.finalTemperature = u.CONVERGENCE_CHECK_PERIOD / this.maxIterations, this.coolingAdjuster = 1);
				}, b.prototype.layout = function() {
					return d.DEFAULT_CREATE_BENDS_AS_NEEDED && (this.createBendpoints(), this.graphManager.resetAllEdges()), this.level = 0, this.classicLayout();
				}, b.prototype.classicLayout = function() {
					if (this.nodesWithGravity = this.calculateNodesToApplyGravitationTo(), this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity), this.calcNoOfChildrenForAllNodes(), this.graphManager.calcLowestCommonAncestors(), this.graphManager.calcInclusionTreeDepths(), this.graphManager.getRoot().calcEstimatedSize(), this.calcIdealEdgeLengths(), this.incremental) {
						if (l.TREE_REDUCTION_ON_INCREMENTAL) {
							this.reduceTrees(), this.graphManager.resetAllNodesToApplyGravitation();
							var e = new Set(this.getAllNodes()), t = this.nodesWithGravity.filter(function(t) {
								return e.has(t);
							});
							this.graphManager.setAllNodesToApplyGravitation(t);
						}
					} else {
						var r = this.getFlatForest();
						if (r.length > 0) this.positionNodesRadially(r);
						else {
							this.reduceTrees(), this.graphManager.resetAllNodesToApplyGravitation();
							var e = new Set(this.getAllNodes()), t = this.nodesWithGravity.filter(function(t) {
								return e.has(t);
							});
							this.graphManager.setAllNodesToApplyGravitation(t), this.positionNodesRandomly();
						}
					}
					return this.initSpringEmbedder(), this.runSpringEmbedder(), !0;
				}, b.prototype.tick = function() {
					if (this.totalIterations++, this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) if (!(this.prunedNodesAll.length > 0)) return !0;
					else this.isTreeGrowing = !0;
					if (this.totalIterations % u.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {
						if (this.isConverged()) if (!(this.prunedNodesAll.length > 0)) return !0;
						else this.isTreeGrowing = !0;
						this.coolingCycle++, 0 == this.layoutQuality ? this.coolingAdjuster = this.coolingCycle : 1 == this.layoutQuality && (this.coolingAdjuster = this.coolingCycle / 3), this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature), this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));
					}
					if (this.isTreeGrowing) {
						if (this.growTreeIterations % 10 == 0) if (this.prunedNodesAll.length > 0) {
							this.graphManager.updateBounds(), this.updateGrid(), this.growTree(this.prunedNodesAll), this.graphManager.resetAllNodesToApplyGravitation();
							var e = new Set(this.getAllNodes()), t = this.nodesWithGravity.filter(function(t) {
								return e.has(t);
							});
							this.graphManager.setAllNodesToApplyGravitation(t), this.graphManager.updateBounds(), this.updateGrid(), this.coolingFactor = u.DEFAULT_COOLING_FACTOR_INCREMENTAL;
						} else this.isTreeGrowing = !1, this.isGrowthFinished = !0;
						this.growTreeIterations++;
					}
					if (this.isGrowthFinished) {
						if (this.isConverged()) return !0;
						this.afterGrowthIterations % 10 == 0 && (this.graphManager.updateBounds(), this.updateGrid()), this.coolingFactor = u.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100), this.afterGrowthIterations++;
					}
					var r = !this.isTreeGrowing && !this.isGrowthFinished, i = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;
					return this.totalDisplacement = 0, this.graphManager.updateBounds(), this.calcSpringForces(), this.calcRepulsionForces(r, i), this.calcGravitationalForces(), this.moveNodes(), this.animate(), !1;
				}, b.prototype.getPositionsData = function() {
					for (var e = this.graphManager.getAllNodes(), t = {}, r = 0; r < e.length; r++) {
						var i = e[r].rect, n = e[r].id;
						t[n] = {
							id: n,
							x: i.getCenterX(),
							y: i.getCenterY(),
							w: i.width,
							h: i.height
						};
					}
					return t;
				}, b.prototype.runSpringEmbedder = function() {
					this.initialAnimationPeriod = 25, this.animationPeriod = this.initialAnimationPeriod;
					var e = !1;
					if ("during" === u.ANIMATE) this.emit("layoutstarted");
					else {
						for (; !e;) e = this.tick();
						this.graphManager.updateBounds();
					}
				}, b.prototype.calculateNodesToApplyGravitationTo = function() {
					var e, t, r = [], i = this.graphManager.getGraphs(), n = i.length;
					for (t = 0; t < n; t++) (e = i[t]).updateConnected(), e.isConnected || (r = r.concat(e.getNodes()));
					return r;
				}, b.prototype.createBendpoints = function() {
					var e = [];
					e = e.concat(this.graphManager.getAllEdges());
					var t, r = /* @__PURE__ */ new Set();
					for (t = 0; t < e.length; t++) {
						var i = e[t];
						if (!r.has(i)) {
							var n = i.getSource(), a = i.getTarget();
							if (n == a) i.getBendpoints().push(new f()), i.getBendpoints().push(new f()), this.createDummyNodesForBendpoints(i), r.add(i);
							else {
								var s, o = [];
								if (o = (o = o.concat(n.getEdgeListToNode(a))).concat(a.getEdgeListToNode(n)), !r.has(o[0])) {
									if (o.length > 1) for (s = 0; s < o.length; s++) {
										var l = o[s];
										l.getBendpoints().push(new f()), this.createDummyNodesForBendpoints(l);
									}
									o.forEach(function(e) {
										r.add(e);
									});
								}
							}
						}
						if (r.size == e.length) break;
					}
				}, b.prototype.positionNodesRadially = function(e) {
					for (var t = new p(0, 0), r = Math.ceil(Math.sqrt(e.length)), i = 0, n = 0, a = 0, s = new f(0, 0), o = 0; o < e.length; o++) {
						o % r == 0 && (a = 0, n = i, 0 != o && (n += l.DEFAULT_COMPONENT_SEPERATION), i = 0);
						var h = e[o], u = g.findCenterOfTree(h);
						t.x = a, t.y = n, (s = b.radialLayout(h, u, t)).y > i && (i = Math.floor(s.y)), a = Math.floor(s.x + l.DEFAULT_COMPONENT_SEPERATION);
					}
					this.transform(new f(d.WORLD_CENTER_X - s.x / 2, d.WORLD_CENTER_Y - s.y / 2));
				}, b.radialLayout = function(e, t, r) {
					var i = Math.max(this.maxDiagonalInTree(e), l.DEFAULT_RADIAL_SEPARATION);
					b.branchRadialLayout(t, null, 0, 359, 0, i);
					var n = v.calculateBounds(e), a = new x();
					a.setDeviceOrgX(n.getMinX()), a.setDeviceOrgY(n.getMinY()), a.setWorldOrgX(r.x), a.setWorldOrgY(r.y);
					for (var s = 0; s < e.length; s++) e[s].transform(a);
					var o = new f(n.getMaxX(), n.getMaxY());
					return a.inverseTransformPoint(o);
				}, b.branchRadialLayout = function(e, t, r, i, n, a) {
					var s = (i - r + 1) / 2;
					s < 0 && (s += 180);
					var o = (s + r) % 360 * y.TWO_PI / 360, l = n * Math.cos(o), h = n * Math.sin(o);
					e.setCenter(l, h);
					var u = [], d = (u = u.concat(e.getEdges())).length;
					null != t && d--;
					for (var p, f = 0, g = u.length, m = e.getEdgesBetween(t); m.length > 1;) {
						var v = m[0];
						m.splice(0, 1);
						var x = u.indexOf(v);
						x >= 0 && u.splice(x, 1), g--, d--;
					}
					p = null != t ? (u.indexOf(m[0]) + 1) % g : 0;
					for (var w = Math.abs(i - r) / d, k = p; f != d; k = ++k % g) {
						var T = u[k].getOtherEnd(e);
						if (T != t) {
							var _ = (r + f * w) % 360, E = (_ + w) % 360;
							b.branchRadialLayout(T, e, _, E, n + a, a), f++;
						}
					}
				}, b.maxDiagonalInTree = function(e) {
					for (var t = m.MIN_VALUE, r = 0; r < e.length; r++) {
						var i = e[r].getDiagonal();
						i > t && (t = i);
					}
					return t;
				}, b.prototype.calcRepulsionRange = function() {
					return 2 * (this.level + 1) * this.idealEdgeLength;
				}, b.prototype.groupZeroDegreeMembers = function() {
					var e = this, t = {};
					this.memberGroups = {}, this.idToDummyNode = {};
					for (var r = [], i = this.graphManager.getAllNodes(), n = 0; n < i.length; n++) {
						var a = i[n], o = a.getParent();
						0 !== this.getNodeDegreeWithChildren(a) || null != o.id && this.getToBeTiled(o) || r.push(a);
					}
					for (var n = 0; n < r.length; n++) {
						var a = r[n], l = a.getParent().id;
						typeof t[l] > "u" && (t[l] = []), t[l] = t[l].concat(a);
					}
					Object.keys(t).forEach(function(r) {
						if (t[r].length > 1) {
							var i = "DummyCompound_" + r;
							e.memberGroups[i] = t[r];
							var n = t[r][0].getParent(), a = new s(e.graphManager);
							a.id = i, a.paddingLeft = n.paddingLeft || 0, a.paddingRight = n.paddingRight || 0, a.paddingBottom = n.paddingBottom || 0, a.paddingTop = n.paddingTop || 0, e.idToDummyNode[i] = a;
							var o = e.getGraphManager().add(e.newGraph(), a), l = n.getChild();
							l.add(a);
							for (var h = 0; h < t[r].length; h++) {
								var u = t[r][h];
								l.remove(u), o.add(u);
							}
						}
					});
				}, b.prototype.clearCompounds = function() {
					var e = {}, t = {};
					this.performDFSOnCompounds();
					for (var r = 0; r < this.compoundOrder.length; r++) t[this.compoundOrder[r].id] = this.compoundOrder[r], e[this.compoundOrder[r].id] = [].concat(this.compoundOrder[r].getChild().getNodes()), this.graphManager.remove(this.compoundOrder[r].getChild()), this.compoundOrder[r].child = null;
					this.graphManager.resetAllNodes(), this.tileCompoundMembers(e, t);
				}, b.prototype.clearZeroDegreeMembers = function() {
					var e = this, t = this.tiledZeroDegreePack = [];
					Object.keys(this.memberGroups).forEach(function(r) {
						var i = e.idToDummyNode[r];
						t[r] = e.tileNodes(e.memberGroups[r], i.paddingLeft + i.paddingRight), i.rect.width = t[r].width, i.rect.height = t[r].height;
					});
				}, b.prototype.repopulateCompounds = function() {
					for (var e = this.compoundOrder.length - 1; e >= 0; e--) {
						var t = this.compoundOrder[e], r = t.id, i = t.paddingLeft, n = t.paddingTop;
						this.adjustLocations(this.tiledMemberPack[r], t.rect.x, t.rect.y, i, n);
					}
				}, b.prototype.repopulateZeroDegreeMembers = function() {
					var e = this, t = this.tiledZeroDegreePack;
					Object.keys(t).forEach(function(r) {
						var i = e.idToDummyNode[r], n = i.paddingLeft, a = i.paddingTop;
						e.adjustLocations(t[r], i.rect.x, i.rect.y, n, a);
					});
				}, b.prototype.getToBeTiled = function(e) {
					var t = e.id;
					if (null != this.toBeTiled[t]) return this.toBeTiled[t];
					var r = e.getChild();
					if (null == r) return this.toBeTiled[t] = !1, !1;
					for (var i = r.getNodes(), n = 0; n < i.length; n++) {
						var a = i[n];
						if (this.getNodeDegree(a) > 0) return this.toBeTiled[t] = !1, !1;
						if (null == a.getChild()) {
							this.toBeTiled[a.id] = !1;
							continue;
						}
						if (!this.getToBeTiled(a)) return this.toBeTiled[t] = !1, !1;
					}
					return this.toBeTiled[t] = !0, !0;
				}, b.prototype.getNodeDegree = function(e) {
					e.id;
					for (var t = e.getEdges(), r = 0, i = 0; i < t.length; i++) {
						var n = t[i];
						n.getSource().id !== n.getTarget().id && (r += 1);
					}
					return r;
				}, b.prototype.getNodeDegreeWithChildren = function(e) {
					var t = this.getNodeDegree(e);
					if (null == e.getChild()) return t;
					for (var r = e.getChild().getNodes(), i = 0; i < r.length; i++) {
						var n = r[i];
						t += this.getNodeDegreeWithChildren(n);
					}
					return t;
				}, b.prototype.performDFSOnCompounds = function() {
					this.compoundOrder = [], this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());
				}, b.prototype.fillCompexOrderByDFS = function(e) {
					for (var t = 0; t < e.length; t++) {
						var r = e[t];
						null != r.getChild() && this.fillCompexOrderByDFS(r.getChild().getNodes()), this.getToBeTiled(r) && this.compoundOrder.push(r);
					}
				}, b.prototype.adjustLocations = function(e, t, r, i, n) {
					t += i, r += n;
					for (var a = t, s = 0; s < e.rows.length; s++) {
						var o = e.rows[s];
						t = a;
						for (var l = 0, h = 0; h < o.length; h++) {
							var u = o[h];
							u.rect.x = t, u.rect.y = r, t += u.rect.width + e.horizontalPadding, u.rect.height > l && (l = u.rect.height);
						}
						r += l + e.verticalPadding;
					}
				}, b.prototype.tileCompoundMembers = function(e, t) {
					var r = this;
					this.tiledMemberPack = [], Object.keys(e).forEach(function(i) {
						var n = t[i];
						r.tiledMemberPack[i] = r.tileNodes(e[i], n.paddingLeft + n.paddingRight), n.rect.width = r.tiledMemberPack[i].width, n.rect.height = r.tiledMemberPack[i].height;
					});
				}, b.prototype.tileNodes = function(e, t) {
					var r = {
						rows: [],
						rowWidth: [],
						rowHeight: [],
						width: 0,
						height: t,
						verticalPadding: l.TILING_PADDING_VERTICAL,
						horizontalPadding: l.TILING_PADDING_HORIZONTAL
					};
					e.sort(function(e, t) {
						return e.rect.width * e.rect.height > t.rect.width * t.rect.height ? -1 : +(e.rect.width * e.rect.height < t.rect.width * t.rect.height);
					});
					for (var i = 0; i < e.length; i++) {
						var n = e[i];
						0 == r.rows.length ? this.insertNodeToRow(r, n, 0, t) : this.canAddHorizontal(r, n.rect.width, n.rect.height) ? this.insertNodeToRow(r, n, this.getShortestRowIndex(r), t) : this.insertNodeToRow(r, n, r.rows.length, t), this.shiftToLastRow(r);
					}
					return r;
				}, b.prototype.insertNodeToRow = function(e, t, r, i) {
					r == e.rows.length && (e.rows.push([]), e.rowWidth.push(i), e.rowHeight.push(0));
					var n = e.rowWidth[r] + t.rect.width;
					e.rows[r].length > 0 && (n += e.horizontalPadding), e.rowWidth[r] = n, e.width < n && (e.width = n);
					var a = t.rect.height;
					r > 0 && (a += e.verticalPadding);
					var s = 0;
					a > e.rowHeight[r] && (s = e.rowHeight[r], e.rowHeight[r] = a, s = e.rowHeight[r] - s), e.height += s, e.rows[r].push(t);
				}, b.prototype.getShortestRowIndex = function(e) {
					for (var t = -1, r = Number.MAX_VALUE, i = 0; i < e.rows.length; i++) e.rowWidth[i] < r && (t = i, r = e.rowWidth[i]);
					return t;
				}, b.prototype.getLongestRowIndex = function(e) {
					for (var t = -1, r = 5e-324, i = 0; i < e.rows.length; i++) e.rowWidth[i] > r && (t = i, r = e.rowWidth[i]);
					return t;
				}, b.prototype.canAddHorizontal = function(e, t, r) {
					var i, n, a = this.getShortestRowIndex(e);
					if (a < 0) return !0;
					var s = e.rowWidth[a];
					if (s + e.horizontalPadding + t <= e.width) return !0;
					var o = 0;
					return e.rowHeight[a] < r && a > 0 && (o = r + e.verticalPadding - e.rowHeight[a]), i = e.width - s >= t + e.horizontalPadding ? (e.height + o) / (s + t + e.horizontalPadding) : (e.height + o) / e.width, o = r + e.verticalPadding, (n = e.width < t ? (e.height + o) / t : (e.height + o) / e.width) < 1 && (n = 1 / n), i < 1 && (i = 1 / i), i < n;
				}, b.prototype.shiftToLastRow = function(e) {
					var t = this.getLongestRowIndex(e), r = e.rowWidth.length - 1, i = e.rows[t], n = i[i.length - 1], a = n.width + e.horizontalPadding;
					if (e.width - e.rowWidth[r] > a && t != r) {
						i.splice(-1, 1), e.rows[r].push(n), e.rowWidth[t] = e.rowWidth[t] - a, e.rowWidth[r] = e.rowWidth[r] + a, e.width = e.rowWidth[instance.getLongestRowIndex(e)];
						for (var s = 5e-324, o = 0; o < i.length; o++) i[o].height > s && (s = i[o].height);
						t > 0 && (s += e.verticalPadding);
						var l = e.rowHeight[t] + e.rowHeight[r];
						e.rowHeight[t] = s, e.rowHeight[r] < n.height + e.verticalPadding && (e.rowHeight[r] = n.height + e.verticalPadding);
						var h = e.rowHeight[t] + e.rowHeight[r];
						e.height += h - l, this.shiftToLastRow(e);
					}
				}, b.prototype.tilingPreLayout = function() {
					l.TILE && (this.groupZeroDegreeMembers(), this.clearCompounds(), this.clearZeroDegreeMembers());
				}, b.prototype.tilingPostLayout = function() {
					l.TILE && (this.repopulateZeroDegreeMembers(), this.repopulateCompounds());
				}, b.prototype.reduceTrees = function() {
					for (var e, t = [], r = !0; r;) {
						var i = this.graphManager.getAllNodes(), n = [];
						r = !1;
						for (var a = 0; a < i.length; a++) 1 != (e = i[a]).getEdges().length || e.getEdges()[0].isInterGraph || null != e.getChild() || (n.push([
							e,
							e.getEdges()[0],
							e.getOwner()
						]), r = !0);
						if (!0 == r) {
							for (var s = [], o = 0; o < n.length; o++) 1 == n[o][0].getEdges().length && (s.push(n[o]), n[o][0].getOwner().remove(n[o][0]));
							t.push(s), this.graphManager.resetAllNodes(), this.graphManager.resetAllEdges();
						}
					}
					this.prunedNodesAll = t;
				}, b.prototype.growTree = function(e) {
					for (var t, r = e[e.length - 1], i = 0; i < r.length; i++) t = r[i], this.findPlaceforPrunedNode(t), t[2].add(t[0]), t[2].add(t[1], t[1].source, t[1].target);
					e.splice(e.length - 1, 1), this.graphManager.resetAllNodes(), this.graphManager.resetAllEdges();
				}, b.prototype.findPlaceforPrunedNode = function(e) {
					var t, r, i = e[0], n = (r = i == e[1].source ? e[1].target : e[1].source).startX, a = r.finishX, s = r.startY, o = r.finishY, l = [
						0,
						0,
						0,
						0
					];
					if (s > 0) for (var h = n; h <= a; h++) l[0] += this.grid[h][s - 1].length + this.grid[h][s].length - 1;
					if (a < this.grid.length - 1) for (var h = s; h <= o; h++) l[1] += this.grid[a + 1][h].length + this.grid[a][h].length - 1;
					if (o < this.grid[0].length - 1) for (var h = n; h <= a; h++) l[2] += this.grid[h][o + 1].length + this.grid[h][o].length - 1;
					if (n > 0) for (var h = s; h <= o; h++) l[3] += this.grid[n - 1][h].length + this.grid[n][h].length - 1;
					for (var d, p, f = m.MAX_VALUE, g = 0; g < l.length; g++) l[g] < f ? (f = l[g], d = 1, p = g) : l[g] == f && d++;
					if (3 == d && 0 == f) 0 == l[0] && 0 == l[1] && 0 == l[2] ? t = 1 : 0 == l[0] && 0 == l[1] && 0 == l[3] ? t = 0 : 0 == l[0] && 0 == l[2] && 0 == l[3] ? t = 3 : 0 == l[1] && 0 == l[2] && 0 == l[3] && (t = 2);
					else if (2 == d && 0 == f) {
						var y = Math.floor(2 * Math.random());
						t = 0 == l[0] && 0 == l[1] ? +(0 != y) : 0 == l[0] && 0 == l[2] ? 2 * (0 != y) : 0 == l[0] && 0 == l[3] ? 3 * (0 != y) : 0 == l[1] && 0 == l[2] ? 0 == y ? 1 : 2 : 0 == l[1] && 0 == l[3] ? 0 == y ? 1 : 3 : 0 == y ? 2 : 3;
					} else if (4 == d && 0 == f) {
						var y = Math.floor(4 * Math.random());
						t = y;
					} else t = p;
					0 == t ? i.setCenter(r.getCenterX(), r.getCenterY() - r.getHeight() / 2 - u.DEFAULT_EDGE_LENGTH - i.getHeight() / 2) : 1 == t ? i.setCenter(r.getCenterX() + r.getWidth() / 2 + u.DEFAULT_EDGE_LENGTH + i.getWidth() / 2, r.getCenterY()) : 2 == t ? i.setCenter(r.getCenterX(), r.getCenterY() + r.getHeight() / 2 + u.DEFAULT_EDGE_LENGTH + i.getHeight() / 2) : i.setCenter(r.getCenterX() - r.getWidth() / 2 - u.DEFAULT_EDGE_LENGTH - i.getWidth() / 2, r.getCenterY());
				}, e.exports = b;
			},
			function(e, t, r) {
				var i = {};
				i.layoutBase = r(0), i.CoSEConstants = r(1), i.CoSEEdge = r(2), i.CoSEGraph = r(3), i.CoSEGraphManager = r(4), i.CoSELayout = r(6), i.CoSENode = r(5), e.exports = i;
			}
		], r = {};
		function i(e) {
			if (r[e]) return r[e].exports;
			var n = r[e] = {
				i: e,
				l: !1,
				exports: {}
			};
			return t[e].call(n.exports, n, n.exports, i), n.l = !0, n.exports;
		}
		return h(i, "__webpack_require__"), i.m = t, i.c = r, i.i = function(e) {
			return e;
		}, i.d = function(e, t, r) {
			i.o(e, t) || Object.defineProperty(e, t, {
				configurable: !1,
				enumerable: !0,
				get: r
			});
		}, i.n = function(e) {
			var t = e && e.__esModule ? h(function() {
				return e.default;
			}, "getDefault") : h(function() {
				return e;
			}, "getModuleExports");
			return i.d(t, "a", t), t;
		}, i.o = function(e, t) {
			return Object.prototype.hasOwnProperty.call(e, t);
		}, i.p = "", i(i.s = 7);
	});
}), eix = g(u((e, t) => {
	h(function(r, i) {
		"object" == typeof e && "object" == typeof t ? t.exports = i(eiv()) : "function" == typeof define && define.amd ? define(["cose-base"], i) : "object" == typeof e ? e.cytoscapeCoseBilkent = i(eiv()) : r.cytoscapeCoseBilkent = i(r.coseBase);
	}, "webpackUniversalModuleDefinition")(e, function(e) {
		var t = [function(t, r) {
			t.exports = e;
		}, function(e, t, r) {
			var i = r(0).layoutBase.LayoutConstants, n = r(0).layoutBase.FDLayoutConstants, a = r(0).CoSEConstants, s = r(0).CoSELayout, o = r(0).CoSENode, l = r(0).layoutBase.PointD, u = r(0).layoutBase.DimensionD, d = {
				ready: h(function() {}, "ready"),
				stop: h(function() {}, "stop"),
				quality: "default",
				nodeDimensionsIncludeLabels: !1,
				refresh: 30,
				fit: !0,
				padding: 10,
				randomize: !0,
				nodeRepulsion: 4500,
				idealEdgeLength: 50,
				edgeElasticity: .45,
				nestingFactor: .1,
				gravity: .25,
				numIter: 2500,
				tile: !0,
				animate: "end",
				animationDuration: 500,
				tilingPaddingVertical: 10,
				tilingPaddingHorizontal: 10,
				gravityRangeCompound: 1.5,
				gravityCompound: 1,
				gravityRange: 3.8,
				initialEnergyOnIncremental: .5
			};
			function p(e, t) {
				var r = {};
				for (var i in e) r[i] = e[i];
				for (var i in t) r[i] = t[i];
				return r;
			}
			function f(e) {
				this.options = p(d, e), g(this.options);
			}
			h(p, "extend"), h(f, "_CoSELayout");
			var g = h(function(e) {
				null != e.nodeRepulsion && (a.DEFAULT_REPULSION_STRENGTH = n.DEFAULT_REPULSION_STRENGTH = e.nodeRepulsion), null != e.idealEdgeLength && (a.DEFAULT_EDGE_LENGTH = n.DEFAULT_EDGE_LENGTH = e.idealEdgeLength), null != e.edgeElasticity && (a.DEFAULT_SPRING_STRENGTH = n.DEFAULT_SPRING_STRENGTH = e.edgeElasticity), null != e.nestingFactor && (a.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = n.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = e.nestingFactor), null != e.gravity && (a.DEFAULT_GRAVITY_STRENGTH = n.DEFAULT_GRAVITY_STRENGTH = e.gravity), null != e.numIter && (a.MAX_ITERATIONS = n.MAX_ITERATIONS = e.numIter), null != e.gravityRange && (a.DEFAULT_GRAVITY_RANGE_FACTOR = n.DEFAULT_GRAVITY_RANGE_FACTOR = e.gravityRange), null != e.gravityCompound && (a.DEFAULT_COMPOUND_GRAVITY_STRENGTH = n.DEFAULT_COMPOUND_GRAVITY_STRENGTH = e.gravityCompound), null != e.gravityRangeCompound && (a.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = n.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = e.gravityRangeCompound), null != e.initialEnergyOnIncremental && (a.DEFAULT_COOLING_FACTOR_INCREMENTAL = n.DEFAULT_COOLING_FACTOR_INCREMENTAL = e.initialEnergyOnIncremental), "draft" == e.quality ? i.QUALITY = 0 : "proof" == e.quality ? i.QUALITY = 2 : i.QUALITY = 1, a.NODE_DIMENSIONS_INCLUDE_LABELS = n.NODE_DIMENSIONS_INCLUDE_LABELS = i.NODE_DIMENSIONS_INCLUDE_LABELS = e.nodeDimensionsIncludeLabels, a.DEFAULT_INCREMENTAL = n.DEFAULT_INCREMENTAL = i.DEFAULT_INCREMENTAL = !e.randomize, a.ANIMATE = n.ANIMATE = i.ANIMATE = e.animate, a.TILE = e.tile, a.TILING_PADDING_VERTICAL = "function" == typeof e.tilingPaddingVertical ? e.tilingPaddingVertical.call() : e.tilingPaddingVertical, a.TILING_PADDING_HORIZONTAL = "function" == typeof e.tilingPaddingHorizontal ? e.tilingPaddingHorizontal.call() : e.tilingPaddingHorizontal;
			}, "getUserOptions");
			f.prototype.run = function() {
				var e, t, r = this.options;
				this.idToLNode = {};
				var i = this.layout = new s(), n = this;
				n.stopped = !1, this.cy = this.options.cy, this.cy.trigger({
					type: "layoutstart",
					layout: this
				});
				var a = i.newGraphManager();
				this.gm = a;
				var o = this.options.eles.nodes(), l = this.options.eles.edges();
				this.root = a.addRoot(), this.processChildrenList(this.root, this.getTopMostNodes(o), i);
				for (var u = 0; u < l.length; u++) {
					var d = l[u], p = this.idToLNode[d.data("source")], f = this.idToLNode[d.data("target")];
					p !== f && 0 == p.getEdgesBetween(f).length && (a.add(i.newEdge(), p, f).id = d.id());
				}
				var g = h(function(e, t) {
					"number" == typeof e && (e = t);
					var r = e.data("id"), i = n.idToLNode[r];
					return {
						x: i.getRect().getCenterX(),
						y: i.getRect().getCenterY()
					};
				}, "getPositions"), m = h(function a() {
					for (var s, o = h(function() {
						r.fit && r.cy.fit(r.eles, r.padding), e || (e = !0, n.cy.one("layoutready", r.ready), n.cy.trigger({
							type: "layoutready",
							layout: n
						}));
					}, "afterReposition"), l = n.options.refresh, u = 0; u < l && !s; u++) s = n.stopped || n.layout.tick();
					if (s) {
						i.checkLayoutSuccess() && !i.isSubLayout && i.doPostLayout(), i.tilingPostLayout && i.tilingPostLayout(), i.isLayoutFinished = !0, n.options.eles.nodes().positions(g), o(), n.cy.one("layoutstop", n.options.stop), n.cy.trigger({
							type: "layoutstop",
							layout: n
						}), t && cancelAnimationFrame(t), e = !1;
						return;
					}
					var d = n.layout.getPositionsData();
					r.eles.nodes().positions(function(e, t) {
						if ("number" == typeof e && (e = t), !e.isParent()) {
							for (var r = e.id(), i = d[r], n = e; null == i && (i = d[n.data("parent")] || d["DummyCompound_" + n.data("parent")], d[r] = i, null != (n = n.parent()[0])););
							return null != i ? {
								x: i.x,
								y: i.y
							} : {
								x: e.position("x"),
								y: e.position("y")
							};
						}
					}), o(), t = requestAnimationFrame(a);
				}, "iterateAnimated");
				return i.addListener("layoutstarted", function() {
					"during" === n.options.animate && (t = requestAnimationFrame(m));
				}), i.runLayout(), "during" !== this.options.animate && (n.options.eles.nodes().not(":parent").layoutPositions(n, n.options, g), e = !1), this;
			}, f.prototype.getTopMostNodes = function(e) {
				for (var t = {}, r = 0; r < e.length; r++) t[e[r].id()] = !0;
				return e.filter(function(e, r) {
					"number" == typeof e && (e = r);
					for (var i = e.parent()[0]; null != i;) {
						if (t[i.id()]) return !1;
						i = i.parent()[0];
					}
					return !0;
				});
			}, f.prototype.processChildrenList = function(e, t, r) {
				for (var i = t.length, n = 0; n < i; n++) {
					var a, s = t[n], h = s.children(), d = s.layoutDimensions({ nodeDimensionsIncludeLabels: this.options.nodeDimensionsIncludeLabels });
					if ((a = null != s.outerWidth() && null != s.outerHeight() ? e.add(new o(r.graphManager, new l(s.position("x") - d.w / 2, s.position("y") - d.h / 2), new u(parseFloat(d.w), parseFloat(d.h)))) : e.add(new o(this.graphManager))).id = s.data("id"), a.paddingLeft = parseInt(s.css("padding")), a.paddingTop = parseInt(s.css("padding")), a.paddingRight = parseInt(s.css("padding")), a.paddingBottom = parseInt(s.css("padding")), this.options.nodeDimensionsIncludeLabels && s.isParent()) {
						var p = s.boundingBox({
							includeLabels: !0,
							includeNodes: !1
						}).w, f = s.boundingBox({
							includeLabels: !0,
							includeNodes: !1
						}).h, g = s.css("text-halign");
						a.labelWidth = p, a.labelHeight = f, a.labelPos = g;
					}
					if (this.idToLNode[s.data("id")] = a, isNaN(a.rect.x) && (a.rect.x = 0), isNaN(a.rect.y) && (a.rect.y = 0), null != h && h.length > 0) {
						var m = r.getGraphManager().add(r.newGraph(), a);
						this.processChildrenList(m, h, r);
					}
				}
			}, f.prototype.stop = function() {
				return this.stopped = !0, this;
			};
			var m = h(function(e) {
				e("layout", "cose-bilkent", f);
			}, "register");
			"u" > typeof cytoscape && m(cytoscape), e.exports = m;
		}], r = {};
		function i(e) {
			if (r[e]) return r[e].exports;
			var n = r[e] = {
				i: e,
				l: !1,
				exports: {}
			};
			return t[e].call(n.exports, n, n.exports, i), n.l = !0, n.exports;
		}
		return h(i, "__webpack_require__"), i.m = t, i.c = r, i.i = function(e) {
			return e;
		}, i.d = function(e, t, r) {
			i.o(e, t) || Object.defineProperty(e, t, {
				configurable: !1,
				enumerable: !0,
				get: r
			});
		}, i.n = function(e) {
			var t = e && e.__esModule ? h(function() {
				return e.default;
			}, "getDefault") : h(function() {
				return e;
			}, "getModuleExports");
			return i.d(t, "a", t), t;
		}, i.o = function(e, t) {
			return Object.prototype.hasOwnProperty.call(e, t);
		}, i.p = "", i(i.s = 1);
	});
})(), 1);
function eib(e, t) {
	e.forEach((e) => {
		let r = {
			id: e.id,
			labelText: e.label,
			height: e.height,
			width: e.width,
			padding: e.padding ?? 0
		};
		Object.keys(e).forEach((t) => {
			[
				"id",
				"label",
				"height",
				"width",
				"padding",
				"x",
				"y"
			].includes(t) || (r[t] = e[t]);
		}), t.add({
			group: "nodes",
			data: r,
			position: {
				x: e.x ?? 0,
				y: e.y ?? 0
			}
		});
	});
}
function eiw(e, t) {
	e.forEach((e) => {
		let r = {
			id: e.id,
			source: e.start,
			target: e.end
		};
		Object.keys(e).forEach((t) => {
			[
				"id",
				"start",
				"end"
			].includes(t) || (r[t] = e[t]);
		}), t.add({
			group: "edges",
			data: r
		});
	});
}
function eik(e) {
	return new Promise((t) => {
		let r = _t("body").append("div").attr("id", "cy").attr("style", "display:none"), i = Vb({
			container: document.getElementById("cy"),
			style: [{
				selector: "edge",
				style: { "curve-style": "bezier" }
			}]
		});
		r.remove(), eib(e.nodes, i), eiw(e.edges, i), i.nodes().forEach(function(e) {
			e.layoutDimensions = () => {
				let t = e.data();
				return {
					w: t.width,
					h: t.height
				};
			};
		}), i.layout({
			name: "cose-bilkent",
			quality: "proof",
			styleEnabled: !1,
			animate: !1
		}).run(), i.ready((e) => {
			wQ.info("Cytoscape ready", e), t(i);
		});
	});
}
function eiT(e) {
	return e.nodes().map((e) => {
		let t = e.data(), r = e.position(), i = {
			id: t.id,
			x: r.x,
			y: r.y
		};
		return Object.keys(t).forEach((e) => {
			"id" !== e && (i[e] = t[e]);
		}), i;
	});
}
function ei_(e) {
	return e.edges().map((e) => {
		let t = e.data(), r = e._private.rscratch, i = {
			id: t.id,
			source: t.source,
			target: t.target,
			startX: r.startX,
			startY: r.startY,
			midX: r.midX,
			midY: r.midY,
			endX: r.endX,
			endY: r.endY
		};
		return Object.keys(t).forEach((e) => {
			[
				"id",
				"source",
				"target"
			].includes(e) || (i[e] = t[e]);
		}), i;
	});
}
async function eiE(e, t) {
	wQ.debug("Starting cose-bilkent layout algorithm");
	try {
		eiC(e);
		let t = await eik(e), r = eiT(t), i = ei_(t);
		return wQ.debug(`Layout completed: ${r.length} nodes, ${i.length} edges`), {
			nodes: r,
			edges: i
		};
	} catch (e) {
		throw wQ.error("Error in cose-bilkent layout algorithm:", e), e;
	}
}
function eiC(e) {
	if (!e) throw Error("Layout data is required");
	if (!e.config) throw Error("Configuration is required in layout data");
	if (!e.rootNode) throw Error("Root node is required");
	if (!e.nodes || !Array.isArray(e.nodes)) throw Error("No nodes found in layout data");
	if (!Array.isArray(e.edges)) throw Error("Edges array is required in layout data");
	return !0;
}
Vb.use(eix.default), h(eib, "addNodes"), h(eiw, "addEdges"), h(eik, "createCytoscapeInstance"), h(eiT, "extractPositionedNodes"), h(ei_, "extractPositionedEdges"), h(eiE, "executeCoseBilkentLayout"), h(eiC, "validateLayoutData");
var eiS = h(async (e, t, { insertCluster: r, insertEdge: i, insertEdgeLabel: n, insertMarkers: a, insertNode: s, log: o, positionEdgeLabel: l }, { algorithm: h }) => {
	let u = {}, d = {}, p = t.select("g");
	a(p, e.markers, e.type, e.diagramId);
	let f = p.insert("g").attr("class", "subgraphs"), g = p.insert("g").attr("class", "edgePaths"), m = p.insert("g").attr("class", "edgeLabels"), y = p.insert("g").attr("class", "nodes");
	o.debug("Inserting nodes into DOM for dimension calculation"), await Promise.all(e.nodes.map(async (t) => {
		if (t.isGroup) {
			let e = { ...t };
			d[t.id] = e, u[t.id] = e, await r(f, t);
		} else {
			let r = { ...t };
			u[t.id] = r;
			let i = await s(y, t, {
				config: e.config,
				dir: e.direction || "TB"
			}), n = i.node().getBBox();
			r.width = n.width, r.height = n.height, r.domId = i, o.debug(`Node ${t.id} dimensions: ${n.width}x${n.height}`);
		}
	})), o.debug("Running cose-bilkent layout algorithm");
	let v = await eiE({
		...e,
		nodes: e.nodes.map((e) => {
			let t = u[e.id];
			return {
				...e,
				width: t.width,
				height: t.height
			};
		})
	}, e.config);
	o.debug("Positioning nodes based on layout results"), v.nodes.forEach((e) => {
		let t = u[e.id];
		t?.domId && (t.domId.attr("transform", `translate(${e.x}, ${e.y})`), t.x = e.x, t.y = e.y, o.debug(`Positioned node ${t.id} at center (${e.x}, ${e.y})`));
	}), v.edges.forEach((t) => {
		let r = e.edges.find((e) => e.id === t.id);
		r && (r.points = [
			{
				x: t.startX,
				y: t.startY
			},
			{
				x: t.midX,
				y: t.midY
			},
			{
				x: t.endX,
				y: t.endY
			}
		]);
	}), o.debug("Inserting and positioning edges"), await Promise.all(e.edges.map(async (t) => {
		await n(m, t);
		let r = u[t.start ?? ""], a = u[t.end ?? ""];
		if (r && a) {
			let n = v.edges.find((e) => e.id === t.id);
			if (n) {
				o.debug("APA01 positionedEdge", n);
				let s = { ...t };
				l(s, i(g, s, d, e.type, r, a, e.diagramId));
			} else {
				let n = {
					...t,
					points: [{
						x: r.x || 0,
						y: r.y || 0
					}, {
						x: a.x || 0,
						y: a.y || 0
					}]
				};
				l(n, i(g, n, d, e.type, r, a, e.diagramId));
			}
		}
	})), o.debug("Cose-bilkent rendering completed");
}, "render");
function eiA(e, t, r, i) {
	var n;
	do
		n = aT(i);
	while (e.hasNode(n));
	return r.dummy = t, e.setNode(n, r), n;
}
function eiL(e) {
	var t = new KD().setGraph(e.graph());
	return rU(e.nodes(), function(r) {
		t.setNode(r, e.node(r));
	}), rU(e.edges(), function(r) {
		var i = t.edge(r.v, r.w) || {
			weight: 0,
			minlen: 1
		}, n = e.edge(r);
		t.setEdge(r.v, r.w, {
			weight: i.weight + n.weight,
			minlen: Math.max(i.minlen, n.minlen)
		});
	}), t;
}
function eiR(e) {
	var t = new KD({ multigraph: e.isMultigraph() }).setGraph(e.graph());
	return rU(e.nodes(), function(r) {
		e.children(r).length || t.setNode(r, e.node(r));
	}), rU(e.edges(), function(r) {
		t.setEdge(r, e.edge(r));
	}), t;
}
function eiN(e, t) {
	var r, i, n = e.x, a = e.y, s = t.x - n, o = t.y - a, l = e.width / 2, h = e.height / 2;
	if (!s && !o) throw Error("Not possible to find intersection inside of the rectangle");
	return Math.abs(o) * l > Math.abs(s) * h ? (o < 0 && (h = -h), r = h * s / o, i = h) : (s < 0 && (l = -l), r = l, i = l * o / s), {
		x: n + r,
		y: a + i
	};
}
function eiI(e) {
	var t = iD(af(ei$(e) + 1), function() {
		return [];
	});
	return rU(e.nodes(), function(r) {
		var i = e.node(r), n = i.rank;
		iP(n) || (t[n][i.order] = r);
	}), t;
}
function eiM(e) {
	var t = nJ(iD(e.nodes(), function(t) {
		return e.node(t).rank;
	}));
	rU(e.nodes(), function(r) {
		var i = e.node(r);
		nq(i, "rank") && (i.rank -= t);
	});
}
function eiD(e) {
	var t = nJ(iD(e.nodes(), function(t) {
		return e.node(t).rank;
	})), r = [];
	rU(e.nodes(), function(i) {
		var n = e.node(i).rank - t;
		r[n] || (r[n] = []), r[n].push(i);
	});
	var i = 0, n = e.graph().nodeRankFactor;
	rU(r, function(t, r) {
		iP(t) && r % n != 0 ? --i : i && rU(t, function(t) {
			e.node(t).rank += i;
		});
	});
}
function eiO(e, t, r, i) {
	var n = {
		width: 0,
		height: 0
	};
	return arguments.length >= 4 && (n.rank = r, n.order = i), eiA(e, "border", n, t);
}
function ei$(e) {
	return iU(iD(e.nodes(), function(t) {
		var r = e.node(t).rank;
		if (!iP(r)) return r;
	}));
}
function eiP(e, t) {
	var r = {
		lhs: [],
		rhs: []
	};
	return rU(e, function(e) {
		t(e) ? r.lhs.push(e) : r.rhs.push(e);
	}), r;
}
function eiB(e, t) {
	var r = nT();
	try {
		return t();
	} finally {
		console.log(e + " time: " + (nT() - r) + "ms");
	}
}
function eiF(e, t) {
	return t();
}
function eiz(e) {
	function t(r) {
		var i = e.children(r), n = e.node(r);
		if (i.length && rU(i, t), Object.prototype.hasOwnProperty.call(n, "minRank")) {
			n.borderLeft = [], n.borderRight = [];
			for (var a = n.minRank, s = n.maxRank + 1; a < s; ++a) eiU(e, "borderLeft", "_bl", r, n, a), eiU(e, "borderRight", "_br", r, n, a);
		}
	}
	h(t, "dfs"), rU(e.children(), t);
}
function eiU(e, t, r, i, n, a) {
	var s = n[t][a - 1], o = eiA(e, "border", {
		width: 0,
		height: 0,
		rank: a,
		borderType: t
	}, r);
	n[t][a] = o, e.setParent(o, i), s && e.setEdge(s, o, { weight: 1 });
}
function eiG(e) {
	var t = e.graph().rankdir.toLowerCase();
	("lr" === t || "rl" === t) && eij(e);
}
function eiq(e) {
	var t = e.graph().rankdir.toLowerCase();
	("bt" === t || "rl" === t) && eiY(e), ("lr" === t || "rl" === t) && (eiH(e), eij(e));
}
function eij(e) {
	rU(e.nodes(), function(t) {
		eiW(e.node(t));
	}), rU(e.edges(), function(t) {
		eiW(e.edge(t));
	});
}
function eiW(e) {
	var t = e.width;
	e.width = e.height, e.height = t;
}
function eiY(e) {
	rU(e.nodes(), function(t) {
		eiV(e.node(t));
	}), rU(e.edges(), function(t) {
		var r = e.edge(t);
		rU(r.points, eiV), Object.prototype.hasOwnProperty.call(r, "y") && eiV(r);
	});
}
function eiV(e) {
	e.y = -e.y;
}
function eiH(e) {
	rU(e.nodes(), function(t) {
		eiX(e.node(t));
	}), rU(e.edges(), function(t) {
		var r = e.edge(t);
		rU(r.points, eiX), Object.prototype.hasOwnProperty.call(r, "x") && eiX(r);
	});
}
function eiX(e) {
	var t = e.x;
	e.x = e.y, e.y = t;
}
h(eiA, "addDummyNode"), h(eiL, "simplify"), h(eiR, "asNonCompoundGraph"), h(eiN, "intersectRect"), h(eiI, "buildLayerMatrix"), h(eiM, "normalizeRanks"), h(eiD, "removeEmptyRanks"), h(eiO, "addBorderNode"), h(ei$, "maxRank"), h(eiP, "partition"), h(eiB, "time"), h(eiF, "notime"), h(eiz, "addBorderSegments"), h(eiU, "addBorderNode"), h(eiG, "adjust"), h(eiq, "undo"), h(eij, "swapWidthHeight"), h(eiW, "swapWidthHeightOne"), h(eiY, "reverseY"), h(eiV, "reverseYOne"), h(eiH, "swapXY"), h(eiX, "swapXYOne");
var eiK = class {
	static {
		h(this, "List");
	}
	constructor() {
		var e = {};
		e._next = e._prev = e, this._sentinel = e;
	}
	dequeue() {
		var e = this._sentinel, t = e._prev;
		if (t !== e) return eiZ(t), t;
	}
	enqueue(e) {
		var t = this._sentinel;
		e._prev && e._next && eiZ(e), e._next = t._next, t._next._prev = e, t._next = e, e._prev = t;
	}
	toString() {
		for (var e = [], t = this._sentinel, r = t._prev; r !== t;) e.push(JSON.stringify(r, eiQ)), r = r._prev;
		return "[" + e.join(", ") + "]";
	}
};
function eiZ(e) {
	e._prev._next = e._next, e._next._prev = e._prev, delete e._next, delete e._prev;
}
function eiQ(e, t) {
	if ("_next" !== e && "_prev" !== e) return t;
}
h(eiZ, "unlink"), h(eiQ, "filterOutLinks");
var eiJ = ev(1);
function ei0(e, t) {
	if (1 >= e.nodeCount()) return [];
	var r = ei4(e, t || eiJ);
	return iH(iD(ei1(r.graph, r.buckets, r.zeroIdx), function(t) {
		return e.outEdges(t.v, t.w);
	}));
}
function ei1(e, t, r) {
	for (var i, n = [], a = t[t.length - 1], s = t[0]; e.nodeCount();) {
		for (; i = s.dequeue();) ei2(e, t, r, i);
		for (; i = a.dequeue();) ei2(e, t, r, i);
		if (e.nodeCount()) {
			for (var o = t.length - 2; o > 0; --o) if (i = t[o].dequeue()) {
				n = n.concat(ei2(e, t, r, i, !0));
				break;
			}
		}
	}
	return n;
}
function ei2(e, t, r, i, n) {
	var a = n ? [] : void 0;
	return rU(e.inEdges(i.v), function(i) {
		var s = e.edge(i), o = e.node(i.v);
		n && a.push({
			v: i.v,
			w: i.w
		}), o.out -= s, ei5(t, r, o);
	}), rU(e.outEdges(i.v), function(i) {
		var n = e.edge(i), a = i.w, s = e.node(a);
		s.in -= n, ei5(t, r, s);
	}), e.removeNode(i.v), a;
}
function ei4(e, t) {
	var r = new KD(), i = 0, n = 0;
	rU(e.nodes(), function(e) {
		r.setNode(e, {
			v: e,
			in: 0,
			out: 0
		});
	}), rU(e.edges(), function(e) {
		var a = r.edge(e.v, e.w) || 0, s = t(e);
		r.setEdge(e.v, e.w, a + s), n = Math.max(n, r.node(e.v).out += s), i = Math.max(i, r.node(e.w).in += s);
	});
	var a = af(n + i + 3).map(function() {
		return new eiK();
	}), s = i + 1;
	return rU(r.nodes(), function(e) {
		ei5(a, s, r.node(e));
	}), {
		graph: r,
		buckets: a,
		zeroIdx: s
	};
}
function ei5(e, t, r) {
	r.out ? r.in ? e[r.out - r.in + t].enqueue(r) : e[e.length - 1].enqueue(r) : e[0].enqueue(r);
}
function ei3(e) {
	function t(e) {
		return function(t) {
			return e.edge(t).weight;
		};
	}
	rU("greedy" === e.graph().acyclicer ? ei0(e, t(e)) : ei6(e), function(t) {
		var r = e.edge(t);
		e.removeEdge(t), r.forwardName = t.name, r.reversed = !0, e.setEdge(t.w, t.v, r, aT("rev"));
	}), h(t, "weightFn");
}
function ei6(e) {
	var t = [], r = {}, i = {};
	function n(a) {
		Object.prototype.hasOwnProperty.call(i, a) || (i[a] = !0, r[a] = !0, rU(e.outEdges(a), function(e) {
			Object.prototype.hasOwnProperty.call(r, e.w) ? t.push(e) : n(e.w);
		}), delete r[a]);
	}
	return h(n, "dfs"), rU(e.nodes(), n), t;
}
function ei7(e) {
	rU(e.edges(), function(t) {
		var r = e.edge(t);
		if (r.reversed) {
			e.removeEdge(t);
			var i = r.forwardName;
			delete r.reversed, delete r.forwardName, e.setEdge(t.w, t.v, r, i);
		}
	});
}
function ei8(e) {
	e.graph().dummyChains = [], rU(e.edges(), function(t) {
		ei9(e, t);
	});
}
function ei9(e, t) {
	var r = t.v, i = e.node(r).rank, n = t.w, a = e.node(n).rank, s = t.name, o = e.edge(t), l = o.labelRank;
	if (a !== i + 1) {
		e.removeEdge(t);
		var h, u, d = void 0;
		for (u = 0, ++i; i < a; ++u, ++i) o.points = [], h = eiA(e, "edge", d = {
			width: 0,
			height: 0,
			edgeLabel: o,
			edgeObj: t,
			rank: i
		}, "_d"), i === l && (d.width = o.width, d.height = o.height, d.dummy = "edge-label", d.labelpos = o.labelpos), e.setEdge(r, h, { weight: o.weight }, s), 0 === u && e.graph().dummyChains.push(h), r = h;
		e.setEdge(r, n, { weight: o.weight }, s);
	}
}
function ene(e) {
	rU(e.graph().dummyChains, function(t) {
		var r, i = e.node(t), n = i.edgeLabel;
		for (e.setEdge(i.edgeObj, n); i.dummy;) r = e.successors(t)[0], e.removeNode(t), n.points.push({
			x: i.x,
			y: i.y
		}), "edge-label" === i.dummy && (n.x = i.x, n.y = i.y, n.width = i.width, n.height = i.height), t = r, i = e.node(t);
	});
}
function ent(e) {
	var t = {};
	function r(i) {
		var n = e.node(i);
		if (Object.prototype.hasOwnProperty.call(t, i)) return n.rank;
		t[i] = !0;
		var a = nJ(iD(e.outEdges(i), function(t) {
			return r(t.w) - e.edge(t).minlen;
		}));
		return (a === Infinity || null == a) && (a = 0), n.rank = a;
	}
	h(r, "dfs"), rU(e.sources(), r);
}
function enr(e, t) {
	return e.node(t.w).rank - e.node(t.v).rank - e.edge(t).minlen;
}
function eni(e) {
	var t, r, i = new KD({ directed: !1 }), n = e.nodes()[0], a = e.nodeCount();
	for (i.setNode(n, {}); enn(i, e) < a;) t = ena(i, e), r = i.hasNode(t.v) ? enr(e, t) : -enr(e, t), ens(i, e, r);
	return i;
}
function enn(e, t) {
	function r(i) {
		rU(t.nodeEdges(i), function(n) {
			var a = n.v, s = i === a ? n.w : a;
			e.hasNode(s) || enr(t, n) || (e.setNode(s, {}), e.setEdge(i, s, {}), r(s));
		});
	}
	return h(r, "dfs"), rU(e.nodes(), r), e.nodeCount();
}
function ena(e, t) {
	return n0(t.edges(), function(r) {
		if (e.hasNode(r.v) !== e.hasNode(r.w)) return enr(t, r);
	});
}
function ens(e, t, r) {
	rU(e.nodes(), function(e) {
		t.node(e).rank += r;
	});
}
function eno(e) {
	var t = {}, r = {}, i = [];
	function n(a) {
		if (Object.prototype.hasOwnProperty.call(r, a)) throw new enl();
		Object.prototype.hasOwnProperty.call(t, a) || (r[a] = !0, t[a] = !0, rU(e.predecessors(a), n), delete r[a], i.push(a));
	}
	if (h(n, "visit"), rU(e.sinks(), n), am(t) !== e.nodeCount()) throw new enl();
	return i;
}
function enl() {}
function enc(e, t, r) {
	eQ(t) || (t = [t]);
	var i = (e.isDirected() ? e.successors : e.neighbors).bind(e), n = [], a = {};
	return rU(t, function(t) {
		if (!e.hasNode(t)) throw Error("Graph does not have node: " + t);
		enh(e, t, "post" === r, a, i, n);
	}), n;
}
function enh(e, t, r, i, n, a) {
	Object.prototype.hasOwnProperty.call(i, t) || (i[t] = !0, r || a.push(t), rU(n(t), function(t) {
		enh(e, t, r, i, n, a);
	}), r && a.push(t));
}
function enu(e, t) {
	return enc(e, t, "post");
}
function end(e, t) {
	return enc(e, t, "pre");
}
function enp(e) {
	ent(e = eiL(e));
	var t, r, i = eni(e);
	for (eny(i), enf(i, e); t = enx(i);) r = enb(i, e, t), enw(i, e, t, r);
}
function enf(e, t) {
	var r = enu(e, e.nodes());
	rU(r = r.slice(0, r.length - 1), function(r) {
		eng(e, t, r);
	});
}
function eng(e, t, r) {
	var i = e.node(r).parent;
	e.edge(r, i).cutvalue = enm(e, t, r);
}
function enm(e, t, r) {
	var i = e.node(r).parent, n = !0, a = t.edge(r, i), s = 0;
	return a || (n = !1, a = t.edge(i, r)), s = a.weight, rU(t.nodeEdges(r), function(a) {
		var o = a.v === r, l = o ? a.w : a.v;
		if (l !== i) {
			var h = o === n, u = t.edge(a).weight;
			if (s += h ? u : -u, enT(e, r, l)) {
				var d = e.edge(r, l).cutvalue;
				s += h ? -d : d;
			}
		}
	}), s;
}
function eny(e, t) {
	arguments.length < 2 && (t = e.nodes()[0]), env(e, {}, 1, t);
}
function env(e, t, r, i, n) {
	var a = r, s = e.node(i);
	return t[i] = !0, rU(e.neighbors(i), function(n) {
		Object.prototype.hasOwnProperty.call(t, n) || (r = env(e, t, r, n, i));
	}), s.low = a, s.lim = r++, n ? s.parent = n : delete s.parent, r;
}
function enx(e) {
	return nD(e.edges(), function(t) {
		return e.edge(t).cutvalue < 0;
	});
}
function enb(e, t, r) {
	var i = r.v, n = r.w;
	t.hasEdge(i, n) || (i = r.w, n = r.v);
	var a = e.node(i), s = e.node(n), o = a, l = !1;
	return a.lim > s.lim && (o = s, l = !0), n0(iI(t.edges(), function(t) {
		return l === en_(e, e.node(t.v), o) && l !== en_(e, e.node(t.w), o);
	}), function(e) {
		return enr(t, e);
	});
}
function enw(e, t, r, i) {
	var n = r.v, a = r.w;
	e.removeEdge(n, a), e.setEdge(i.v, i.w, {}), eny(e), enf(e, t), enk(e, t);
}
function enk(e, t) {
	var r = end(e, nD(e.nodes(), function(e) {
		return !t.node(e).parent;
	}));
	rU(r = r.slice(1), function(r) {
		var i = e.node(r).parent, n = t.edge(r, i), a = !1;
		n || (n = t.edge(i, r), a = !0), t.node(r).rank = t.node(i).rank + (a ? n.minlen : -n.minlen);
	});
}
function enT(e, t, r) {
	return e.hasEdge(t, r);
}
function en_(e, t, r) {
	return r.low <= t.lim && t.lim <= r.lim;
}
function enE(e) {
	switch (e.graph().ranker) {
		case "network-simplex":
		default:
			enA(e);
			break;
		case "tight-tree":
			enS(e);
			break;
		case "longest-path": enC(e);
	}
}
h(ei0, "greedyFAS"), h(ei1, "doGreedyFAS"), h(ei2, "removeNode"), h(ei4, "buildState"), h(ei5, "assignBucket"), h(ei3, "run"), h(ei6, "dfsFAS"), h(ei7, "undo"), h(ei8, "run"), h(ei9, "normalizeEdge"), h(ene, "undo"), h(ent, "longestPath"), h(enr, "slack"), h(eni, "feasibleTree"), h(enn, "tightTree"), h(ena, "findMinSlackEdge"), h(ens, "shiftRanks"), ev(1), ev(1), eno.CycleException = enl, h(eno, "topsort"), h(enl, "CycleException"), enl.prototype = Error(), h(enc, "dfs"), h(enh, "doDfs"), h(enu, "postorder"), h(end, "preorder"), enp.initLowLimValues = eny, enp.initCutValues = enf, enp.calcCutValue = enm, enp.leaveEdge = enx, enp.enterEdge = enb, enp.exchangeEdges = enw, h(enp, "networkSimplex"), h(enf, "initCutValues"), h(eng, "assignCutValue"), h(enm, "calcCutValue"), h(eny, "initLowLimValues"), h(env, "dfsAssignLowLim"), h(enx, "leaveEdge"), h(enb, "enterEdge"), h(enw, "exchangeEdges"), h(enk, "updateRanks"), h(enT, "isTreeEdge"), h(en_, "isDescendant"), h(enE, "rank");
var enC = ent;
function enS(e) {
	ent(e), eni(e);
}
function enA(e) {
	enp(e);
}
function enL(e) {
	var t = eiA(e, "root", {}, "_root"), r = enN(e), i = iU(i$(r)) - 1, n = 2 * i + 1;
	e.graph().nestingRoot = t, rU(e.edges(), function(t) {
		e.edge(t).minlen *= n;
	});
	var a = enI(e) + 1;
	rU(e.children(), function(s) {
		enR(e, t, n, a, i, r, s);
	}), e.graph().nodeRankFactor = n;
}
function enR(e, t, r, i, n, a, s) {
	var o = e.children(s);
	if (!o.length) {
		s !== t && e.setEdge(t, s, {
			weight: 0,
			minlen: r
		});
		return;
	}
	var l = eiO(e, "_bt"), h = eiO(e, "_bb"), u = e.node(s);
	e.setParent(l, s), u.borderTop = l, e.setParent(h, s), u.borderBottom = h, rU(o, function(o) {
		enR(e, t, r, i, n, a, o);
		var u = e.node(o), d = u.borderTop ? u.borderTop : o, p = u.borderBottom ? u.borderBottom : o, f = u.borderTop ? i : 2 * i, g = d !== p ? 1 : n - a[s] + 1;
		e.setEdge(l, d, {
			weight: f,
			minlen: g,
			nestingEdge: !0
		}), e.setEdge(p, h, {
			weight: f,
			minlen: g,
			nestingEdge: !0
		});
	}), e.parent(s) || e.setEdge(t, l, {
		weight: 0,
		minlen: n + a[s]
	});
}
function enN(e) {
	var t = {};
	function r(i, n) {
		var a = e.children(i);
		a && a.length && rU(a, function(e) {
			r(e, n + 1);
		}), t[i] = n;
	}
	return h(r, "dfs"), rU(e.children(), function(e) {
		r(e, 1);
	}), t;
}
function enI(e) {
	return iJ(e.edges(), function(t, r) {
		return t + e.edge(r).weight;
	}, 0);
}
function enM(e) {
	var t = e.graph();
	e.removeNode(t.nestingRoot), delete t.nestingRoot, rU(e.edges(), function(t) {
		e.edge(t).nestingEdge && e.removeEdge(t);
	});
}
function enD(e, t, r) {
	var i, n = {};
	rU(r, function(r) {
		for (var a, s, o = e.parent(r); o;) {
			if ((a = e.parent(o)) ? (s = n[a], n[a] = o) : (s = i, i = o), s && s !== o) return void t.setEdge(s, o);
			o = a;
		}
	});
}
function enO(e, t, r) {
	var i = en$(e), n = new KD({ compound: !0 }).setGraph({ root: i }).setDefaultNodeLabel(function(t) {
		return e.node(t);
	});
	return rU(e.nodes(), function(a) {
		var s = e.node(a), o = e.parent(a);
		(s.rank === t || s.minRank <= t && t <= s.maxRank) && (n.setNode(a), n.setParent(a, o || i), rU(e[r](a), function(t) {
			var r = t.v === a ? t.w : t.v, i = n.edge(r, a), s = iP(i) ? 0 : i.weight;
			n.setEdge(r, a, { weight: e.edge(t).weight + s });
		}), Object.prototype.hasOwnProperty.call(s, "minRank") && n.setNode(a, {
			borderLeft: s.borderLeft[t],
			borderRight: s.borderRight[t]
		}));
	}), n;
}
function en$(e) {
	for (var t; e.hasNode(t = aT("_root")););
	return t;
}
function enP(e, t) {
	for (var r = 0, i = 1; i < t.length; ++i) r += enB(e, t[i - 1], t[i]);
	return r;
}
function enB(e, t, r) {
	for (var i = aE(r, iD(r, function(e, t) {
		return t;
	})), n = iH(iD(t, function(t) {
		return ax(iD(e.outEdges(t), function(t) {
			return {
				pos: i[t.w],
				weight: e.edge(t).weight
			};
		}), "pos");
	})), a = 1; a < r.length;) a <<= 1;
	var s = 2 * a - 1;
	a -= 1;
	var o = iD(Array(s), function() {
		return 0;
	}), l = 0;
	return rU(n.forEach(function(e) {
		var t = e.pos + a;
		o[t] += e.weight;
		for (var r = 0; t > 0;) t % 2 && (r += o[t + 1]), t = t - 1 >> 1, o[t] += e.weight;
		l += e.weight * r;
	})), l;
}
function enF(e) {
	var t = {}, r = iI(e.nodes(), function(t) {
		return !e.children(t).length;
	}), i = iD(af(iU(iD(r, function(t) {
		return e.node(t).rank;
	})) + 1), function() {
		return [];
	});
	function n(r) {
		nq(t, r) || (t[r] = !0, i[e.node(r).rank].push(r), rU(e.successors(r), n));
	}
	return h(n, "dfs"), rU(ax(r, function(t) {
		return e.node(t).rank;
	}), n), i;
}
function enz(e, t) {
	return iD(t, function(t) {
		var r = e.inEdges(t);
		if (!r.length) return { v: t };
		var i = iJ(r, function(t, r) {
			var i = e.edge(r), n = e.node(r.v);
			return {
				sum: t.sum + i.weight * n.order,
				weight: t.weight + i.weight
			};
		}, {
			sum: 0,
			weight: 0
		});
		return {
			v: t,
			barycenter: i.sum / i.weight,
			weight: i.weight
		};
	});
}
function enU(e, t) {
	var r = {};
	return rU(e, function(e, t) {
		var i = r[e.v] = {
			indegree: 0,
			in: [],
			out: [],
			vs: [e.v],
			i: t
		};
		iP(e.barycenter) || (i.barycenter = e.barycenter, i.weight = e.weight);
	}), rU(t.edges(), function(e) {
		var t = r[e.v], i = r[e.w];
		iP(t) || iP(i) || (i.indegree++, t.out.push(r[e.w]));
	}), enG(iI(r, function(e) {
		return !e.indegree;
	}));
}
function enG(e) {
	var t = [];
	function r(e) {
		return function(t) {
			t.merged || (iP(t.barycenter) || iP(e.barycenter) || t.barycenter >= e.barycenter) && enq(e, t);
		};
	}
	function i(t) {
		return function(r) {
			r.in.push(t), 0 == --r.indegree && e.push(r);
		};
	}
	for (h(r, "handleIn"), h(i, "handleOut"); e.length;) {
		var n = e.pop();
		t.push(n), rU(n.in.reverse(), r(n)), rU(n.out, i(n));
	}
	return iD(iI(t, function(e) {
		return !e.merged;
	}), function(e) {
		return iK(e, [
			"vs",
			"i",
			"barycenter",
			"weight"
		]);
	});
}
function enq(e, t) {
	var r = 0, i = 0;
	e.weight && (r += e.barycenter * e.weight, i += e.weight), t.weight && (r += t.barycenter * t.weight, i += t.weight), e.vs = t.vs.concat(e.vs), e.barycenter = r / i, e.weight = i, e.i = Math.min(t.i, e.i), t.merged = !0;
}
function enj(e, t) {
	var r = eiP(e, function(e) {
		return Object.prototype.hasOwnProperty.call(e, "barycenter");
	}), i = r.lhs, n = ax(r.rhs, function(e) {
		return -e.i;
	}), a = [], s = 0, o = 0, l = 0;
	i.sort(enY(!!t)), l = enW(a, n, l), rU(i, function(e) {
		l += e.vs.length, a.push(e.vs), s += e.barycenter * e.weight, o += e.weight, l = enW(a, n, l);
	});
	var h = { vs: iH(a) };
	return o && (h.barycenter = s / o, h.weight = o), h;
}
function enW(e, t, r) {
	for (var i; t.length && (i = r$(t)).i <= r;) t.pop(), e.push(i.vs), r++;
	return r;
}
function enY(e) {
	return function(t, r) {
		return t.barycenter < r.barycenter ? -1 : t.barycenter > r.barycenter ? 1 : e ? r.i - t.i : t.i - r.i;
	};
}
function enV(e, t, r, i) {
	var n = e.children(t), a = e.node(t), s = a ? a.borderLeft : void 0, o = a ? a.borderRight : void 0, l = {};
	s && (n = iI(n, function(e) {
		return e !== s && e !== o;
	}));
	var h = enz(e, n);
	rU(h, function(t) {
		if (e.children(t.v).length) {
			var n = enV(e, t.v, r, i);
			l[t.v] = n, Object.prototype.hasOwnProperty.call(n, "barycenter") && enX(t, n);
		}
	});
	var u = enU(h, r);
	enH(u, l);
	var d = enj(u, i);
	if (s && (d.vs = iH([
		s,
		d.vs,
		o
	]), e.predecessors(s).length)) {
		var p = e.node(e.predecessors(s)[0]), f = e.node(e.predecessors(o)[0]);
		Object.prototype.hasOwnProperty.call(d, "barycenter") || (d.barycenter = 0, d.weight = 0), d.barycenter = (d.barycenter * d.weight + p.order + f.order) / (d.weight + 2), d.weight += 2;
	}
	return d;
}
function enH(e, t) {
	rU(e, function(e) {
		e.vs = iH(e.vs.map(function(e) {
			return t[e] ? t[e].vs : e;
		}));
	});
}
function enX(e, t) {
	iP(e.barycenter) ? (e.barycenter = t.barycenter, e.weight = t.weight) : (e.barycenter = (e.barycenter * e.weight + t.barycenter * t.weight) / (e.weight + t.weight), e.weight += t.weight);
}
function enK(e) {
	var t = ei$(e), r = enZ(e, af(1, t + 1), "inEdges"), i = enZ(e, af(t - 1, -1, -1), "outEdges"), n = enF(e);
	enJ(e, n);
	for (var a, s = Infinity, o = 0, l = 0; l < 4; ++o, ++l) {
		enQ(o % 2 ? r : i, o % 4 >= 2), n = eiI(e);
		var h = enP(e, n);
		h < s && (l = 0, a = nv(n), s = h);
	}
	enJ(e, a);
}
function enZ(e, t, r) {
	return iD(t, function(t) {
		return enO(e, t, r);
	});
}
function enQ(e, t) {
	var r = new KD();
	rU(e, function(e) {
		var i = e.graph().root, n = enV(e, i, r, t);
		rU(n.vs, function(t, r) {
			e.node(t).order = r;
		}), enD(e, r, n.vs);
	});
}
function enJ(e, t) {
	rU(t, function(t) {
		rU(t, function(t, r) {
			e.node(t).order = r;
		});
	});
}
function en0(e) {
	var t = en2(e);
	rU(e.graph().dummyChains, function(r) {
		for (var i = e.node(r), n = i.edgeObj, a = en1(e, t, n.v, n.w), s = a.path, o = a.lca, l = 0, h = s[l], u = !0; r !== n.w;) {
			if (i = e.node(r), u) {
				for (; (h = s[l]) !== o && e.node(h).maxRank < i.rank;) l++;
				h === o && (u = !1);
			}
			if (!u) {
				for (; l < s.length - 1 && e.node(h = s[l + 1]).minRank <= i.rank;) l++;
				h = s[l];
			}
			e.setParent(r, h), r = e.successors(r)[0];
		}
	});
}
function en1(e, t, r, i) {
	var n, a = [], s = [], o = Math.min(t[r].low, t[i].low), l = Math.max(t[r].lim, t[i].lim), h = r;
	do
		a.push(h = e.parent(h));
	while (h && (t[h].low > o || l > t[h].lim));
	for (n = h, h = i; (h = e.parent(h)) !== n;) s.push(h);
	return {
		path: a.concat(s.reverse()),
		lca: n
	};
}
function en2(e) {
	var t = {}, r = 0;
	function i(n) {
		var a = r;
		rU(e.children(n), i), t[n] = {
			low: a,
			lim: r++
		};
	}
	return h(i, "dfs"), rU(e.children(), i), t;
}
function en4(e, t) {
	var r = {};
	function i(t, i) {
		var n = 0, a = 0, s = t.length, o = r$(i);
		return rU(i, function(t, l) {
			var h = en3(e, t), u = h ? e.node(h).order : s;
			(h || t === o) && (rU(i.slice(a, l + 1), function(t) {
				rU(e.predecessors(t), function(i) {
					var a = e.node(i), s = a.order;
					(s < n || u < s) && !(a.dummy && e.node(t).dummy) && en6(r, i, t);
				});
			}), a = l + 1, n = u);
		}), i;
	}
	return h(i, "visitLayer"), iJ(t, i), r;
}
function en5(e, t) {
	var r = {};
	function i(t, i, n, a, s) {
		var o;
		rU(af(i, n), function(i) {
			o = t[i], e.node(o).dummy && rU(e.predecessors(o), function(t) {
				var i = e.node(t);
				i.dummy && (i.order < a || i.order > s) && en6(r, t, o);
			});
		});
	}
	function n(t, r) {
		var n, a = -1, s = 0;
		return rU(r, function(o, l) {
			if ("border" === e.node(o).dummy) {
				var h = e.predecessors(o);
				h.length && (n = e.node(h[0]).order, i(r, s, l, a, n), s = l, a = n);
			}
			i(r, s, r.length, n, t.length);
		}), r;
	}
	return h(i, "scan"), h(n, "visitLayer"), iJ(t, n), r;
}
function en3(e, t) {
	if (e.node(t).dummy) return nD(e.predecessors(t), function(t) {
		return e.node(t).dummy;
	});
}
function en6(e, t, r) {
	if (t > r) {
		var i = t;
		t = r, r = i;
	}
	Object.prototype.hasOwnProperty.call(e, t) || Object.defineProperty(e, t, {
		enumerable: !0,
		configurable: !0,
		value: {},
		writable: !0
	}), Object.defineProperty(e[t], r, {
		enumerable: !0,
		configurable: !0,
		value: !0,
		writable: !0
	});
}
function en7(e, t, r) {
	if (t > r) {
		var i = t;
		t = r, r = i;
	}
	return !!e[t] && Object.prototype.hasOwnProperty.call(e[t], r);
}
function en8(e, t, r, i) {
	var n = {}, a = {}, s = {};
	return rU(t, function(e) {
		rU(e, function(e, t) {
			n[e] = e, a[e] = e, s[e] = t;
		});
	}), rU(t, function(e) {
		var t = -1;
		rU(e, function(e) {
			var o = i(e);
			if (o.length) {
				o = ax(o, function(e) {
					return s[e];
				});
				for (var l = (o.length - 1) / 2, h = Math.floor(l), u = Math.ceil(l); h <= u; ++h) {
					var d = o[h];
					a[e] === e && t < s[d] && !en7(r, e, d) && (a[d] = e, a[e] = n[e] = n[d], t = s[d]);
				}
			}
		});
	}), {
		root: n,
		align: a
	};
}
function en9(e, t, r, i, n) {
	var a = {}, s = eae(e, t, r, n), o = n ? "borderLeft" : "borderRight";
	function l(e, t) {
		for (var r = s.nodes(), i = r.pop(), n = {}; i;) n[i] ? e(i) : (n[i] = !0, r.push(i), r = r.concat(t(i))), i = r.pop();
	}
	function u(e) {
		a[e] = s.inEdges(e).reduce(function(e, t) {
			return Math.max(e, a[t.v] + s.edge(t));
		}, 0);
	}
	function d(t) {
		var r = s.outEdges(t).reduce(function(e, t) {
			return Math.min(e, a[t.w] - s.edge(t));
		}, Infinity), i = e.node(t);
		r !== Infinity && i.borderType !== o && (a[t] = Math.max(a[t], r));
	}
	return h(l, "iterate"), h(u, "pass1"), h(d, "pass2"), l(u, s.predecessors.bind(s)), l(d, s.successors.bind(s)), rU(i, function(e) {
		a[e] = a[r[e]];
	}), a;
}
function eae(e, t, r, i) {
	var n = new KD(), a = e.graph(), s = eaa(a.nodesep, a.edgesep, i);
	return rU(t, function(t) {
		var i;
		rU(t, function(t) {
			var a = r[t];
			if (n.setNode(a), i) {
				var o = r[i], l = n.edge(o, a);
				n.setEdge(o, a, Math.max(s(e, t, i), l || 0));
			}
			i = t;
		});
	}), n;
}
function eat(e, t) {
	return n0(i$(t), function(t) {
		var r = -Infinity, i = Infinity;
		return nP(t, function(t, n) {
			var a = eas(e, n) / 2;
			r = Math.max(t + a, r), i = Math.min(t - a, i);
		}), r - i;
	});
}
function ear(e, t) {
	var r = i$(t), i = nJ(r), n = iU(r);
	rU(["u", "d"], function(r) {
		rU(["l", "r"], function(a) {
			var s, o = r + a, l = e[o];
			if (l !== t) {
				var h = i$(l);
				(s = "l" === a ? i - nJ(h) : n - iU(h)) && (e[o] = iB(l, function(e) {
					return e + s;
				}));
			}
		});
	});
}
function eai(e, t) {
	return iB(e.ul, function(r, i) {
		if (t) return e[t.toLowerCase()][i];
		var n = ax(iD(e, i));
		return (n[1] + n[2]) / 2;
	});
}
function ean(e) {
	var t, r = eiI(e), i = tB(en4(e, r), en5(e, r)), n = {};
	return rU(["u", "d"], function(a) {
		t = "u" === a ? r : i$(r).reverse(), rU(["l", "r"], function(r) {
			"r" === r && (t = iD(t, function(e) {
				return i$(e).reverse();
			}));
			var s = ("u" === a ? e.predecessors : e.successors).bind(e), o = en8(e, t, i, s), l = en9(e, t, o.root, o.align, "r" === r);
			"r" === r && (l = iB(l, function(e) {
				return -e;
			})), n[a + r] = l;
		});
	}), ear(n, eat(e, n)), eai(n, e.graph().align);
}
function eaa(e, t, r) {
	return function(i, n, a) {
		var s, o, l = i.node(n), h = i.node(a);
		if (o = 0 + l.width / 2, Object.prototype.hasOwnProperty.call(l, "labelpos")) switch (l.labelpos.toLowerCase()) {
			case "l":
				s = -l.width / 2;
				break;
			case "r": s = l.width / 2;
		}
		if (s && (o += r ? s : -s), s = 0, o += (l.dummy ? t : e) / 2, o += (h.dummy ? t : e) / 2, o += h.width / 2, Object.prototype.hasOwnProperty.call(h, "labelpos")) switch (h.labelpos.toLowerCase()) {
			case "l":
				s = h.width / 2;
				break;
			case "r": s = -h.width / 2;
		}
		return s && (o += r ? s : -s), s = 0, o;
	};
}
function eas(e, t) {
	return e.node(t).width;
}
function eao(e) {
	eal(e = eiR(e)), nB(ean(e), function(t, r) {
		e.node(r).x = t;
	});
}
function eal(e) {
	var t = eiI(e), r = e.graph().ranksep, i = 0;
	rU(t, function(t) {
		var n = iU(iD(t, function(t) {
			return e.node(t).height;
		}));
		rU(t, function(t) {
			e.node(t).y = i + n / 2;
		}), i += n + r;
	});
}
function eac(e, t) {
	var r = t && t.debugTiming ? eiB : eiF;
	r("layout", () => {
		var t = r("  buildLayoutGraph", () => eab(e));
		r("  runLayout", () => eah(t, r)), r("  updateInputGraph", () => eau(e, t));
	});
}
function eah(e, t) {
	t("    makeSpaceForEdgeLabels", () => eaw(e)), t("    removeSelfEdges", () => eaR(e)), t("    acyclic", () => ei3(e)), t("    nestingGraph.run", () => enL(e)), t("    rank", () => enE(eiR(e))), t("    injectEdgeLabelProxies", () => eak(e)), t("    removeEmptyRanks", () => eiD(e)), t("    nestingGraph.cleanup", () => enM(e)), t("    normalizeRanks", () => eiM(e)), t("    assignRankMinMax", () => eaT(e)), t("    removeEdgeLabelProxies", () => ea_(e)), t("    normalize.run", () => ei8(e)), t("    parentDummyChains", () => en0(e)), t("    addBorderSegments", () => eiz(e)), t("    order", () => enK(e)), t("    insertSelfEdges", () => eaN(e)), t("    adjustCoordinateSystem", () => eiG(e)), t("    position", () => eao(e)), t("    positionSelfEdges", () => eaI(e)), t("    removeBorderNodes", () => eaL(e)), t("    normalize.undo", () => ene(e)), t("    fixupEdgeLabelCoords", () => eaS(e)), t("    undoCoordinateSystem", () => eiq(e)), t("    translateGraph", () => eaE(e)), t("    assignNodeIntersects", () => eaC(e)), t("    reversePoints", () => eaA(e)), t("    acyclic.undo", () => ei7(e));
}
function eau(e, t) {
	rU(e.nodes(), function(r) {
		var i = e.node(r), n = t.node(r);
		i && (i.x = n.x, i.y = n.y, t.children(r).length && (i.width = n.width, i.height = n.height));
	}), rU(e.edges(), function(r) {
		var i = e.edge(r), n = t.edge(r);
		i.points = n.points, Object.prototype.hasOwnProperty.call(n, "x") && (i.x = n.x, i.y = n.y);
	}), e.graph().width = t.graph().width, e.graph().height = t.graph().height;
}
h(enS, "tightTreeRanker"), h(enA, "networkSimplexRanker"), h(enL, "run"), h(enR, "dfs"), h(enN, "treeDepths"), h(enI, "sumWeights"), h(enM, "cleanup"), h(enD, "addSubgraphConstraints"), h(enO, "buildLayerGraph"), h(en$, "createRootNode"), h(enP, "crossCount"), h(enB, "twoLayerCrossCount"), h(enF, "initOrder"), h(enz, "barycenter"), h(enU, "resolveConflicts"), h(enG, "doResolveConflicts"), h(enq, "mergeEntries"), h(enj, "sort"), h(enW, "consumeUnsortable"), h(enY, "compareWithBias"), h(enV, "sortSubgraph"), h(enH, "expandSubgraphs"), h(enX, "mergeBarycenters"), h(enK, "order"), h(enZ, "buildLayerGraphs"), h(enQ, "sweepLayerGraphs"), h(enJ, "assignOrder"), h(en0, "parentDummyChains"), h(en1, "findPath"), h(en2, "postorder"), h(en4, "findType1Conflicts"), h(en5, "findType2Conflicts"), h(en3, "findOtherInnerSegmentNode"), h(en6, "addConflict"), h(en7, "hasConflict"), h(en8, "verticalAlignment"), h(en9, "horizontalCompaction"), h(eae, "buildBlockGraph"), h(eat, "findSmallestWidthAlignment"), h(ear, "alignCoordinates"), h(eai, "balance"), h(ean, "positionX"), h(eaa, "sep"), h(eas, "width"), h(eao, "position"), h(eal, "positionY"), h(eac, "layout"), h(eah, "runLayout"), h(eau, "updateInputGraph");
var ead = [
	"nodesep",
	"edgesep",
	"ranksep",
	"marginx",
	"marginy"
], eap = {
	ranksep: 50,
	edgesep: 20,
	nodesep: 50,
	rankdir: "tb"
}, eaf = [
	"acyclicer",
	"ranker",
	"rankdir",
	"align"
], eag = ["width", "height"], eam = {
	width: 0,
	height: 0
}, eay = [
	"minlen",
	"weight",
	"width",
	"height",
	"labeloffset"
], eav = {
	minlen: 1,
	weight: 1,
	width: 0,
	height: 0,
	labeloffset: 10,
	labelpos: "r"
}, eax = ["labelpos"];
function eab(e) {
	var t = new KD({
		multigraph: !0,
		compound: !0
	}), r = eaD(e.graph());
	return t.setGraph(tB({}, eap, eaM(r, ead), iK(r, eaf))), rU(e.nodes(), function(r) {
		var i = eaD(e.node(r));
		t.setNode(r, rO(eaM(i, eag), eam)), t.setParent(r, e.parent(r));
	}), rU(e.edges(), function(r) {
		var i = eaD(e.edge(r));
		t.setEdge(r, tB({}, eav, eaM(i, eay), iK(i, eax)));
	}), t;
}
function eaw(e) {
	var t = e.graph();
	t.ranksep /= 2, rU(e.edges(), function(r) {
		var i = e.edge(r);
		i.minlen *= 2, "c" !== i.labelpos.toLowerCase() && ("TB" === t.rankdir || "BT" === t.rankdir ? i.width += i.labeloffset : i.height += i.labeloffset);
	});
}
function eak(e) {
	rU(e.edges(), function(t) {
		var r = e.edge(t);
		if (r.width && r.height) {
			var i = e.node(t.v);
			eiA(e, "edge-proxy", {
				rank: (e.node(t.w).rank - i.rank) / 2 + i.rank,
				e: t
			}, "_ep");
		}
	});
}
function eaT(e) {
	var t = 0;
	rU(e.nodes(), function(r) {
		var i = e.node(r);
		i.borderTop && (i.minRank = e.node(i.borderTop).rank, i.maxRank = e.node(i.borderBottom).rank, t = iU(t, i.maxRank));
	}), e.graph().maxRank = t;
}
function ea_(e) {
	rU(e.nodes(), function(t) {
		var r = e.node(t);
		"edge-proxy" === r.dummy && (e.edge(r.e).labelRank = r.rank, e.removeNode(t));
	});
}
function eaE(e) {
	var t = Infinity, r = 0, i = Infinity, n = 0, a = e.graph(), s = a.marginx || 0, o = a.marginy || 0;
	function l(e) {
		var a = e.x, s = e.y, o = e.width, l = e.height;
		t = Math.min(t, a - o / 2), r = Math.max(r, a + o / 2), i = Math.min(i, s - l / 2), n = Math.max(n, s + l / 2);
	}
	h(l, "getExtremes"), rU(e.nodes(), function(t) {
		l(e.node(t));
	}), rU(e.edges(), function(t) {
		var r = e.edge(t);
		Object.prototype.hasOwnProperty.call(r, "x") && l(r);
	}), t -= s, i -= o, rU(e.nodes(), function(r) {
		var n = e.node(r);
		n.x -= t, n.y -= i;
	}), rU(e.edges(), function(r) {
		var n = e.edge(r);
		rU(n.points, function(e) {
			e.x -= t, e.y -= i;
		}), Object.prototype.hasOwnProperty.call(n, "x") && (n.x -= t), Object.prototype.hasOwnProperty.call(n, "y") && (n.y -= i);
	}), a.width = r - t + s, a.height = n - i + o;
}
function eaC(e) {
	rU(e.edges(), function(t) {
		var r, i, n = e.edge(t), a = e.node(t.v), s = e.node(t.w);
		n.points ? (r = n.points[0], i = n.points[n.points.length - 1]) : (n.points = [], r = s, i = a), n.points.unshift(eiN(a, r)), n.points.push(eiN(s, i));
	});
}
function eaS(e) {
	rU(e.edges(), function(t) {
		var r = e.edge(t);
		if (Object.prototype.hasOwnProperty.call(r, "x")) switch (("l" === r.labelpos || "r" === r.labelpos) && (r.width -= r.labeloffset), r.labelpos) {
			case "l":
				r.x -= r.width / 2 + r.labeloffset;
				break;
			case "r": r.x += r.width / 2 + r.labeloffset;
		}
	});
}
function eaA(e) {
	rU(e.edges(), function(t) {
		var r = e.edge(t);
		r.reversed && r.points.reverse();
	});
}
function eaL(e) {
	rU(e.nodes(), function(t) {
		if (e.children(t).length) {
			var r = e.node(t), i = e.node(r.borderTop), n = e.node(r.borderBottom), a = e.node(r$(r.borderLeft)), s = e.node(r$(r.borderRight));
			r.width = Math.abs(s.x - a.x), r.height = Math.abs(n.y - i.y), r.x = a.x + r.width / 2, r.y = i.y + r.height / 2;
		}
	}), rU(e.nodes(), function(t) {
		"border" === e.node(t).dummy && e.removeNode(t);
	});
}
function eaR(e) {
	rU(e.edges(), function(t) {
		if (t.v === t.w) {
			var r = e.node(t.v);
			r.selfEdges || (r.selfEdges = []), r.selfEdges.push({
				e: t,
				label: e.edge(t)
			}), e.removeEdge(t);
		}
	});
}
function eaN(e) {
	rU(eiI(e), function(t) {
		var r = 0;
		rU(t, function(t, i) {
			var n = e.node(t);
			n.order = i + r, rU(n.selfEdges, function(t) {
				eiA(e, "selfedge", {
					width: t.label.width,
					height: t.label.height,
					rank: n.rank,
					order: i + ++r,
					e: t.e,
					label: t.label
				}, "_se");
			}), delete n.selfEdges;
		});
	});
}
function eaI(e) {
	rU(e.nodes(), function(t) {
		var r = e.node(t);
		if ("selfedge" === r.dummy) {
			var i = e.node(r.e.v), n = i.x + i.width / 2, a = i.y, s = r.x - n, o = i.height / 2;
			e.setEdge(r.e, r.label), e.removeNode(t), r.label.points = [
				{
					x: n + 2 * s / 3,
					y: a - o
				},
				{
					x: n + 5 * s / 6,
					y: a - o
				},
				{
					x: n + s,
					y: a
				},
				{
					x: n + 5 * s / 6,
					y: a + o
				},
				{
					x: n + 2 * s / 3,
					y: a + o
				}
			], r.label.x = r.x, r.label.y = r.y;
		}
	});
}
function eaM(e, t) {
	return iB(iK(e, t), Number);
}
function eaD(e) {
	var t = {};
	return rU(e, function(e, r) {
		t[r.toLowerCase()] = e;
	}), t;
}
function eaO(e) {
	var t = {
		options: {
			directed: e.isDirected(),
			multigraph: e.isMultigraph(),
			compound: e.isCompound()
		},
		nodes: ea$(e),
		edges: eaP(e)
	};
	return iP(e.graph()) || (t.value = rI(e.graph())), t;
}
function ea$(e) {
	return iD(e.nodes(), function(t) {
		var r = e.node(t), i = e.parent(t), n = { v: t };
		return iP(r) || (n.value = r), iP(i) || (n.parent = i), n;
	});
}
function eaP(e) {
	return iD(e.edges(), function(t) {
		var r = e.edge(t), i = {
			v: t.v,
			w: t.w
		};
		return iP(t.name) || (i.name = t.name), iP(r) || (i.value = r), i;
	});
}
h(eab, "buildLayoutGraph"), h(eaw, "makeSpaceForEdgeLabels"), h(eak, "injectEdgeLabelProxies"), h(eaT, "assignRankMinMax"), h(ea_, "removeEdgeLabelProxies"), h(eaE, "translateGraph"), h(eaC, "assignNodeIntersects"), h(eaS, "fixupEdgeLabelCoords"), h(eaA, "reversePointsForReversedEdges"), h(eaL, "removeBorderNodes"), h(eaR, "removeSelfEdges"), h(eaN, "insertSelfEdges"), h(eaI, "positionSelfEdges"), h(eaM, "selectNumberAttrs"), h(eaD, "canonicalize"), h(eaO, "write"), h(ea$, "writeNodes"), h(eaP, "writeEdges");
var eaB = /* @__PURE__ */ new Map(), eaF = /* @__PURE__ */ new Map(), eaz = /* @__PURE__ */ new Map(), eaU = h(() => {
	eaF.clear(), eaz.clear(), eaB.clear();
}, "clear"), eaG = h((e, t) => {
	let r = eaF.get(t) || [];
	return wQ.trace("In isDescendant", t, " ", e, " = ", r.includes(e)), r.includes(e);
}, "isDescendant"), eaq = h((e, t) => {
	let r = eaF.get(t) || [];
	return wQ.info("Descendants of ", t, " is ", r), wQ.info("Edge is ", e), e.v !== t && e.w !== t && (r ? r.includes(e.v) || eaG(e.v, t) || eaG(e.w, t) || r.includes(e.w) : (wQ.debug("Tilt, ", t, ",not in descendants"), !1));
}, "edgeInCluster"), eaj = h((e, t, r, i) => {
	wQ.warn("Copying children of ", e, "root", i, "data", t.node(e), i);
	let n = t.children(e) || [];
	e !== i && n.push(e), wQ.warn("Copying (nodes) clusterId", e, "nodes", n), n.forEach((n) => {
		if (t.children(n).length > 0) eaj(n, t, r, i);
		else {
			let a = t.node(n);
			wQ.info("cp ", n, " to ", i, " with parent ", e), r.setNode(n, a), i !== t.parent(n) && (wQ.warn("Setting parent", n, t.parent(n)), r.setParent(n, t.parent(n))), e !== i && n !== e ? (wQ.debug("Setting parent", n, e), r.setParent(n, e)) : (wQ.info("In copy ", e, "root", i, "data", t.node(e), i), wQ.debug("Not Setting parent for node=", n, "cluster!==rootId", e !== i, "node!==clusterId", n !== e));
			let s = t.edges(n);
			wQ.debug("Copying Edges", s), s.forEach((n) => {
				wQ.info("Edge", n);
				let a = t.edge(n.v, n.w, n.name);
				wQ.info("Edge data", a, i);
				try {
					eaq(n, i) ? (wQ.info("Copying as ", n.v, n.w, a, n.name), r.setEdge(n.v, n.w, a, n.name), wQ.info("newGraph edges ", r.edges(), r.edge(r.edges()[0]))) : wQ.info("Skipping copy of edge ", n.v, "-->", n.w, " rootId: ", i, " clusterId:", e);
				} catch (e) {
					wQ.error(e);
				}
			});
		}
		wQ.debug("Removing node", n), t.removeNode(n);
	});
}, "copy"), eaW = h((e, t) => {
	let r = t.children(e), i = [...r];
	for (let n of r) eaz.set(n, e), i = [...i, ...eaW(n, t)];
	return i;
}, "extractDescendants"), eaY = h((e, t, r) => {
	let i = e.edges().filter((e) => e.v === t || e.w === t), n = e.edges().filter((e) => e.v === r || e.w === r), a = i.map((e) => ({
		v: e.v === t ? r : e.v,
		w: e.w === t ? t : e.w
	})), s = n.map((e) => ({
		v: e.v,
		w: e.w
	}));
	return a.filter((e) => s.some((t) => e.v === t.v && e.w === t.w));
}, "findCommonEdges"), eaV = h((e, t, r) => {
	let i, n = t.children(e);
	if (wQ.trace("Searching children of id ", e, n), n.length < 1) return e;
	for (let e of n) {
		let n = eaV(e, t, r), a = eaY(t, r, n);
		if (n) if (!(a.length > 0)) return n;
		else i = n;
	}
	return i;
}, "findNonClusterChild"), eaH = h((e) => eaB.has(e) && eaB.get(e).externalConnections && eaB.has(e) ? eaB.get(e).id : e, "getAnchorId"), eaX = h((e, t) => {
	if (!e || t > 10) return void wQ.debug("Opting out, no graph ");
	for (let t of (wQ.debug("Opting in, graph "), e.nodes().forEach(function(t) {
		e.children(t).length > 0 && (wQ.warn("Cluster identified", t, " Replacement id in edges: ", eaV(t, e, t)), eaF.set(t, eaW(t, e)), eaB.set(t, {
			id: eaV(t, e, t),
			clusterData: e.node(t)
		}));
	}), e.nodes().forEach(function(t) {
		let r = e.children(t), i = e.edges();
		r.length > 0 ? (wQ.debug("Cluster identified", t, eaF), i.forEach((e) => {
			eaG(e.v, t) ^ eaG(e.w, t) && (wQ.warn("Edge: ", e, " leaves cluster ", t), wQ.warn("Descendants of XXX ", t, ": ", eaF.get(t)), eaB.get(t).externalConnections = !0);
		})) : wQ.debug("Not a cluster ", t, eaF);
	}), eaB.keys())) {
		let r = eaB.get(t).id, i = e.parent(r);
		i !== t && eaB.has(i) && !eaB.get(i).externalConnections && (eaB.get(t).id = i);
	}
	e.edges().forEach(function(t) {
		let r = e.edge(t);
		wQ.warn("Edge " + t.v + " -> " + t.w + ": " + JSON.stringify(t)), wQ.warn("Edge " + t.v + " -> " + t.w + ": " + JSON.stringify(e.edge(t)));
		let i = t.v, n = t.w;
		if (wQ.warn("Fix XXX", eaB, "ids:", t.v, t.w, "Translating: ", eaB.get(t.v), " --- ", eaB.get(t.w)), eaB.get(t.v) || eaB.get(t.w)) {
			if (wQ.warn("Fixing and trying - removing XXX", t.v, t.w, t.name), i = eaH(t.v), n = eaH(t.w), e.removeEdge(t.v, t.w, t.name), i !== t.v) {
				let n = e.parent(i);
				eaB.get(n).externalConnections = !0, r.fromCluster = t.v;
			}
			if (n !== t.w) {
				let i = e.parent(n);
				eaB.get(i).externalConnections = !0, r.toCluster = t.w;
			}
			wQ.warn("Fix Replacing with XXX", i, n, t.name), e.setEdge(i, n, r, t.name);
		}
	}), wQ.warn("Adjusted Graph", eaO(e)), eaK(e, 0), wQ.trace(eaB);
}, "adjustClustersAndEdges"), eaK = h((e, t) => {
	if (wQ.warn("extractor - ", t, eaO(e), e.children("D")), t > 10) return void wQ.error("Bailing out");
	let r = e.nodes(), i = !1;
	for (let t of r) {
		let r = e.children(t);
		i = i || r.length > 0;
	}
	if (!i) return void wQ.debug("Done, no node has children", e.nodes());
	for (let i of (wQ.debug("Nodes = ", r, t), r)) if (wQ.debug("Extracting node", i, eaB, eaB.has(i) && !eaB.get(i).externalConnections, !e.parent(i), e.node(i), e.children("D"), " Depth ", t), eaB.has(i)) if (!eaB.get(i).externalConnections && e.children(i) && e.children(i).length > 0) {
		wQ.warn("Cluster without external connections, without a parent and with children", i, t);
		let r = "TB" === e.graph().rankdir ? "LR" : "TB";
		eaB.get(i)?.clusterData?.dir && (r = eaB.get(i).clusterData.dir, wQ.warn("Fixing dir", eaB.get(i).clusterData.dir, r));
		let n = new KD({
			multigraph: !0,
			compound: !0
		}).setGraph({
			rankdir: r,
			nodesep: 50,
			ranksep: 50,
			marginx: 8,
			marginy: 8
		}).setDefaultEdgeLabel(function() {
			return {};
		});
		wQ.warn("Old graph before copy", eaO(e)), eaj(i, e, n, i), e.setNode(i, {
			clusterNode: !0,
			id: i,
			clusterData: eaB.get(i).clusterData,
			label: eaB.get(i).label,
			graph: n
		}), wQ.warn("New graph after copy node: (", i, ")", eaO(n)), wQ.debug("Old graph after copy", eaO(e));
	} else wQ.warn("Cluster ** ", i, " **not meeting the criteria !externalConnections:", !eaB.get(i).externalConnections, " no parent: ", !e.parent(i), " children ", e.children(i) && e.children(i).length > 0, e.children("D"), t), wQ.debug(eaB);
	else wQ.debug("Not a cluster", i, t);
	for (let i of (r = e.nodes(), wQ.warn("New list of nodes", r), r)) {
		let r = e.node(i);
		wQ.warn(" Now next level", i, r), r?.clusterNode && eaK(r.graph, t + 1);
	}
}, "extractor"), eaZ = h((e, t) => {
	if (0 === t.length) return [];
	let r = Object.assign([], t);
	return t.forEach((t) => {
		let i = eaZ(e, e.children(t));
		r = [...r, ...i];
	}), r;
}, "sorter"), eaQ = h((e) => eaZ(e, e.children()), "sortNodesByHierarchy"), eaJ = h(async (e, t, r, i, n, a) => {
	wQ.warn("Graph in recursive render:XAX", eaO(t), n);
	let s = t.graph().rankdir;
	wQ.trace("Dir in recursive render - dir:", s);
	let o = e.insert("g").attr("class", "root");
	t.nodes() ? wQ.info("Recursive render XXX", t.nodes()) : wQ.info("No nodes found for", t), t.edges().length > 0 && wQ.info("Recursive edges", t.edge(t.edges()[0]));
	let l = o.insert("g").attr("class", "clusters"), u = o.insert("g").attr("class", "edgePaths"), d = o.insert("g").attr("class", "edgeLabels"), p = o.insert("g").attr("class", "nodes");
	await Promise.all(t.nodes().map(async function(e) {
		let o = t.node(e);
		if (void 0 !== n) {
			let r = JSON.parse(JSON.stringify(n.clusterData));
			wQ.trace(`Setting data for parent cluster XXX
 Node.id = `, e, `
 data=`, r.height, `
Parent cluster`, n.height), t.setNode(n.id, r), t.parent(e) || (wQ.trace("Setting parent", e, n.id), t.setParent(e, n.id, r));
		}
		if (wQ.info("(Insert) Node XXX" + e + ": " + JSON.stringify(t.node(e))), o?.clusterNode) {
			wQ.info("Cluster identified XBX", e, o.width, t.node(e));
			let { ranksep: n, nodesep: s } = t.graph();
			o.graph.setGraph({
				...o.graph.graph(),
				ranksep: n + 25,
				nodesep: s
			});
			let l = await eaJ(p, o.graph, r, i, t.node(e), a), h = l.elem;
			J5(o, h), o.diff = l.diff || 0, wQ.info("New compound node after recursive render XAX", e, "width", o.width, "height", o.height), erB(h, o);
		} else t.children(e).length > 0 ? (wQ.trace("Cluster - the non recursive path XBX", e, o.id, o, o.width, "Graph:", t), wQ.trace(eaV(o.id, t)), eaB.set(o.id, {
			id: eaV(o.id, t),
			node: o
		})) : (wQ.trace("Node - the non recursive path XAX", e, p, t.node(e), s), await erP(p, t.node(e), {
			config: a,
			dir: s
		}));
	})), await h(async () => {
		let e = t.edges().map(async function(e) {
			let r = t.edge(e.v, e.w, e.name);
			wQ.info("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(e)), wQ.info("Edge " + e.v + " -> " + e.w + ": ", e, " ", JSON.stringify(t.edge(e))), wQ.info("Fix", eaB, "ids:", e.v, e.w, "Translating: ", eaB.get(e.v), eaB.get(e.w)), await erH(d, r);
		});
		await Promise.all(e);
	}, "processEdges")(), wQ.info("Graph before layout:", JSON.stringify(eaO(t))), wQ.info("############################################# XXX"), wQ.info("###                Layout                 ### XXX"), wQ.info("############################################# XXX"), eac(t), wQ.info("Graph after layout:", JSON.stringify(eaO(t)));
	let f = 0, { subGraphTitleTotalMargin: g } = KY(a);
	return await Promise.all(eaQ(t).map(async function(e) {
		let r = t.node(e);
		if (wQ.info("Position XBX => " + e + ": (" + r.x, "," + r.y, ") width: ", r.width, " height: ", r.height), r?.clusterNode) r.y += g, wQ.info("A tainted cluster node XBX1", e, r.id, r.width, r.height, r.x, r.y, t.parent(e)), eaB.get(r.id).node = r, erz(r);
		else if (t.children(e).length > 0) {
			wQ.info("A pure cluster node XBX1", e, r.id, r.x, r.y, r.width, r.height, t.parent(e)), r.height += g, t.node(r.parentId);
			let i = r?.padding / 2 || 0, n = r?.labelBBox?.height || 0;
			wQ.debug("OffsetY", n - i || 0, "labelHeight", n, "halfPadding", i), await eti(l, r), eaB.get(r.id).node = r;
		} else {
			let e = t.node(r.parentId);
			r.y += g / 2, wQ.info("A regular node XBX1 - using the padding", r.id, "parent", r.parentId, r.width, r.height, r.x, r.y, "offsetY", r.offsetY, "parent", e, e?.offsetY, r), erz(r);
		}
	})), t.edges().forEach(function(e) {
		let n = t.edge(e);
		wQ.info("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(n), n), n.points.forEach((e) => e.y += g / 2), erK(n, er5(u, n, eaB, r, t.node(e.v), t.node(e.w), i));
	}), t.nodes().forEach(function(e) {
		let r = t.node(e);
		wQ.info(e, r.type, r.diff), r.isGroup && (f = r.diff);
	}), wQ.warn("Returning from recursive render XAX", o, f), {
		elem: o,
		diff: f
	};
}, "recursiveRender"), ea0 = h(async (e, t) => {
	let r = new KD({
		multigraph: !0,
		compound: !0
	}).setGraph({
		rankdir: e.direction,
		nodesep: e.config?.nodeSpacing || e.config?.flowchart?.nodeSpacing || e.nodeSpacing,
		ranksep: e.config?.rankSpacing || e.config?.flowchart?.rankSpacing || e.rankSpacing,
		marginx: 8,
		marginy: 8
	}).setDefaultEdgeLabel(function() {
		return {};
	}), i = t.select("g");
	er8(i, e.markers, e.type, e.diagramId), erF(), erY(), etn(), eaU(), e.nodes.forEach((e) => {
		r.setNode(e.id, { ...e }), e.parentId && r.setParent(e.id, e.parentId);
	}), wQ.debug("Edges:", e.edges), e.edges.forEach((e) => {
		if (e.start === e.end) {
			let t = e.start, i = t + "---" + t + "---1", n = t + "---" + t + "---2", a = r.node(t);
			r.setNode(i, {
				domId: i,
				id: i,
				parentId: a.parentId,
				labelStyle: "",
				label: "",
				padding: 0,
				shape: "labelRect",
				style: "",
				width: 10,
				height: 10
			}), r.setParent(i, a.parentId), r.setNode(n, {
				domId: n,
				id: n,
				parentId: a.parentId,
				labelStyle: "",
				padding: 0,
				shape: "labelRect",
				label: "",
				style: "",
				width: 10,
				height: 10
			}), r.setParent(n, a.parentId);
			let s = structuredClone(e), o = structuredClone(e), l = structuredClone(e);
			s.label = "", s.arrowTypeEnd = "none", s.id = t + "-cyclic-special-1", o.arrowTypeStart = "none", o.arrowTypeEnd = "none", o.id = t + "-cyclic-special-mid", l.label = "", a.isGroup && (s.fromCluster = t, l.toCluster = t), l.id = t + "-cyclic-special-2", l.arrowTypeStart = "none", r.setEdge(t, i, s, t + "-cyclic-special-0"), r.setEdge(i, n, o, t + "-cyclic-special-1"), r.setEdge(n, t, l, t + "-cyc<lic-special-2");
		} else r.setEdge(e.start, e.end, { ...e }, e.id);
	}), wQ.warn("Graph at first:", JSON.stringify(eaO(r))), eaX(r), wQ.warn("Graph after XAX:", JSON.stringify(eaO(r)));
	let n = IA();
	await eaJ(i, r, e.type, e.diagramId, void 0, n);
}, "render"), ea1 = Ip.packet, ea2 = class {
	constructor() {
		this.packet = [], this.setAccTitle = Da, this.getAccTitle = Ds, this.setDiagramTitle = Dc, this.getDiagramTitle = Dh, this.getAccDescription = Dl, this.setAccDescription = Do;
	}
	static {
		h(this, "PacketDB");
	}
	getConfig() {
		let e = V5({
			...ea1,
			...IA().packet
		});
		return e.showBits && (e.paddingY += 10), e;
	}
	getPacket() {
		return this.packet;
	}
	pushWord(e) {
		e.length > 0 && this.packet.push(e);
	}
	clear() {
		Dn(), this.packet = [];
	}
}, ea4 = h((e, t) => {
	w_(e, t);
	let r = -1, i = [], n = 1, { bitsPerRow: a } = t.getConfig();
	for (let { start: s, end: o, bits: l, label: h } of e.blocks) {
		if (void 0 !== s && void 0 !== o && o < s) throw Error(`Packet block ${s} - ${o} is invalid. End must be greater than start.`);
		if ((s ??= r + 1) !== r + 1) throw Error(`Packet block ${s} - ${o ?? s} is not contiguous. It should start from ${r + 1}.`);
		if (0 === l) throw Error(`Packet block ${s} is invalid. Cannot have a zero bit field.`);
		for (o ??= s + (l ?? 1) - 1, l ??= o - s + 1, r = o, wQ.debug(`Packet block ${s} - ${r} with label ${h}`); i.length <= a + 1 && t.getPacket().length < 1e4;) {
			let [e, r] = ea5({
				start: s,
				end: o,
				bits: l,
				label: h
			}, n, a);
			if (i.push(e), e.end + 1 === n * a && (t.pushWord(i), i = [], n++), !r) break;
			({start: s, end: o, bits: l, label: h} = r);
		}
	}
	t.pushWord(i);
}, "populate"), ea5 = h((e, t, r) => {
	if (void 0 === e.start) throw Error("start should have been set during first phase");
	if (void 0 === e.end) throw Error("end should have been set during first phase");
	if (e.start > e.end) throw Error(`Block start ${e.start} is greater than block end ${e.end}.`);
	if (e.end + 1 <= t * r) return [e, void 0];
	let i = t * r - 1, n = t * r;
	return [{
		start: e.start,
		end: i,
		label: e.label,
		bits: i - e.start
	}, {
		start: n,
		end: e.end,
		label: e.label,
		bits: e.end - n
	}];
}, "getNextFittingBlock"), ea3 = {
	parser: { yy: void 0 },
	parse: h(async (e) => {
		let t = await wS("packet", e), r = ea3.parser?.yy;
		if (!(r instanceof ea2)) throw Error("parser.parser?.yy was not a PacketDB. This is due to a bug within Mermaid, please report this issue at https://github.com/mermaid-js/mermaid/issues.");
		wQ.debug(t), ea4(t, r);
	}, "parse")
}, ea6 = h((e, t, r, i) => {
	let n = i.db, a = n.getConfig(), { rowHeight: s, paddingY: o, bitWidth: l, bitsPerRow: h } = a, u = n.getPacket(), d = n.getDiagramTitle(), p = s + o, f = p * (u.length + 1) - (d ? 0 : s), g = l * h + 2, m = Dy(t);
	for (let [e, t] of (m.attr("viewbox", `0 0 ${g} ${f}`), M5(m, f, g, a.useMaxWidth), u.entries())) ea7(m, t, e, a);
	m.append("text").text(d).attr("x", g / 2).attr("y", f - p / 2).attr("dominant-baseline", "middle").attr("text-anchor", "middle").attr("class", "packetTitle");
}, "draw"), ea7 = h((e, t, r, { rowHeight: i, paddingX: n, paddingY: a, bitWidth: s, bitsPerRow: o, showBits: l }) => {
	let h = e.append("g"), u = r * (i + a) + a;
	for (let e of t) {
		let t = e.start % o * s + 1, r = (e.end - e.start + 1) * s - n;
		if (h.append("rect").attr("x", t).attr("y", u).attr("width", r).attr("height", i).attr("class", "packetBlock"), h.append("text").attr("x", t + r / 2).attr("y", u + i / 2).attr("class", "packetLabel").attr("dominant-baseline", "middle").attr("text-anchor", "middle").text(e.label), !l) continue;
		let a = e.end === e.start, d = u - 2;
		h.append("text").attr("x", t + (a ? r / 2 : 0)).attr("y", d).attr("class", "packetByte start").attr("dominant-baseline", "auto").attr("text-anchor", a ? "middle" : "start").text(e.start), a || h.append("text").attr("x", t + r).attr("y", d).attr("class", "packetByte end").attr("dominant-baseline", "auto").attr("text-anchor", "end").text(e.end);
	}
}, "drawWord"), ea8 = {
	byteFontSize: "10px",
	startByteColor: "black",
	endByteColor: "black",
	labelColor: "black",
	labelFontSize: "12px",
	titleColor: "black",
	titleFontSize: "14px",
	blockStrokeColor: "black",
	blockStrokeWidth: "1",
	blockFillColor: "#efefef"
}, ea9 = {
	parser: ea3,
	get db() {
		return new ea2();
	},
	renderer: { draw: ea6 },
	styles: h(({ packet: e } = {}) => {
		let t = V5(ea8, e);
		return `
	.packetByte {
		font-size: ${t.byteFontSize};
	}
	.packetByte.start {
		fill: ${t.startByteColor};
	}
	.packetByte.end {
		fill: ${t.endByteColor};
	}
	.packetLabel {
		fill: ${t.labelColor};
		font-size: ${t.labelFontSize};
	}
	.packetTitle {
		fill: ${t.titleColor};
		font-size: ${t.titleFontSize};
	}
	.packetBlock {
		stroke: ${t.blockStrokeColor};
		stroke-width: ${t.blockStrokeWidth};
		fill: ${t.blockFillColor};
	}
	`;
	}, "styles")
}, ese = {
	showLegend: !0,
	ticks: 5,
	max: null,
	min: 0,
	graticule: "circle"
}, est = {
	axes: [],
	curves: [],
	options: ese
}, esr = structuredClone(est), esi = Ip.radar, esn = h(() => V5({
	...esi,
	...IA().radar
}), "getConfig"), esa = h(() => esr.axes, "getAxes"), ess = h(() => esr.curves, "getCurves"), eso = h(() => esr.options, "getOptions"), esl = h((e) => {
	esr.axes = e.map((e) => ({
		name: e.name,
		label: e.label ?? e.name
	}));
}, "setAxes"), esc = h((e) => {
	esr.curves = e.map((e) => ({
		name: e.name,
		label: e.label ?? e.name,
		entries: esh(e.entries)
	}));
}, "setCurves"), esh = h((e) => {
	if (null == e[0].axis) return e.map((e) => e.value);
	let t = esa();
	if (0 === t.length) throw Error("Axes must be populated before curves for reference entries");
	return t.map((t) => {
		let r = e.find((e) => e.axis?.$refText === t.name);
		if (void 0 === r) throw Error("Missing entry for axis " + t.label);
		return r.value;
	});
}, "computeCurveEntries"), esu = {
	getAxes: esa,
	getCurves: ess,
	getOptions: eso,
	setAxes: esl,
	setCurves: esc,
	setOptions: h((e) => {
		let t = e.reduce((e, t) => (e[t.name] = t, e), {});
		esr.options = {
			showLegend: t.showLegend?.value ?? ese.showLegend,
			ticks: t.ticks?.value ?? ese.ticks,
			max: t.max?.value ?? ese.max,
			min: t.min?.value ?? ese.min,
			graticule: t.graticule?.value ?? ese.graticule
		};
	}, "setOptions"),
	getConfig: esn,
	clear: h(() => {
		Dn(), esr = structuredClone(est);
	}, "clear"),
	setAccTitle: Da,
	getAccTitle: Ds,
	setDiagramTitle: Dc,
	getDiagramTitle: Dh,
	getAccDescription: Dl,
	setAccDescription: Do
}, esd = h((e) => {
	w_(e, esu);
	let { axes: t, curves: r, options: i } = e;
	esu.setAxes(t), esu.setCurves(r), esu.setOptions(i);
}, "populate"), esp = { parse: h(async (e) => {
	let t = await wS("radar", e);
	wQ.debug(t), esd(t);
}, "parse") }, esf = h((e, t, r, i) => {
	let n = i.db, a = n.getAxes(), s = n.getCurves(), o = n.getOptions(), l = n.getConfig(), h = n.getDiagramTitle(), u = esg(Dy(t), l), d = o.max ?? Math.max(...s.map((e) => Math.max(...e.entries))), p = o.min, f = Math.min(l.width, l.height) / 2;
	esm(u, a, f, o.ticks, o.graticule), esy(u, a, f, l), esv(u, a, s, p, d, o.graticule, l), esw(u, s, o.showLegend, l), u.append("text").attr("class", "radarTitle").text(h).attr("x", 0).attr("y", -l.height / 2 - l.marginTop);
}, "draw"), esg = h((e, t) => {
	let r = t.width + t.marginLeft + t.marginRight, i = t.height + t.marginTop + t.marginBottom, n = {
		x: t.marginLeft + t.width / 2,
		y: t.marginTop + t.height / 2
	};
	return e.attr("viewbox", `0 0 ${r} ${i}`).attr("width", r).attr("height", i), e.append("g").attr("transform", `translate(${n.x}, ${n.y})`);
}, "drawFrame"), esm = h((e, t, r, i, n) => {
	if ("circle" === n) for (let t = 0; t < i; t++) {
		let n = r * (t + 1) / i;
		e.append("circle").attr("r", n).attr("class", "radarGraticule");
	}
	else if ("polygon" === n) {
		let n = t.length;
		for (let a = 0; a < i; a++) {
			let s = r * (a + 1) / i, o = t.map((e, t) => {
				let r = 2 * t * Math.PI / n - Math.PI / 2;
				return `${s * Math.cos(r)},${s * Math.sin(r)}`;
			}).join(" ");
			e.append("polygon").attr("points", o).attr("class", "radarGraticule");
		}
	}
}, "drawGraticule"), esy = h((e, t, r, i) => {
	let n = t.length;
	for (let a = 0; a < n; a++) {
		let s = t[a].label, o = 2 * a * Math.PI / n - Math.PI / 2;
		e.append("line").attr("x1", 0).attr("y1", 0).attr("x2", r * i.axisScaleFactor * Math.cos(o)).attr("y2", r * i.axisScaleFactor * Math.sin(o)).attr("class", "radarAxisLine"), e.append("text").text(s).attr("x", r * i.axisLabelFactor * Math.cos(o)).attr("y", r * i.axisLabelFactor * Math.sin(o)).attr("class", "radarAxisLabel");
	}
}, "drawAxes");
function esv(e, t, r, i, n, a, s) {
	let o = t.length, l = Math.min(s.width, s.height) / 2;
	r.forEach((t, r) => {
		if (t.entries.length !== o) return;
		let h = t.entries.map((e, t) => {
			let r = 2 * Math.PI * t / o - Math.PI / 2, a = esx(e, i, n, l);
			return {
				x: a * Math.cos(r),
				y: a * Math.sin(r)
			};
		});
		"circle" === a ? e.append("path").attr("d", esb(h, s.curveTension)).attr("class", `radarCurve-${r}`) : "polygon" === a && e.append("polygon").attr("points", h.map((e) => `${e.x},${e.y}`).join(" ")).attr("class", `radarCurve-${r}`);
	});
}
function esx(e, t, r, i) {
	return i * (Math.min(Math.max(e, t), r) - t) / (r - t);
}
function esb(e, t) {
	let r = e.length, i = `M${e[0].x},${e[0].y}`;
	for (let n = 0; n < r; n++) {
		let a = e[(n - 1 + r) % r], s = e[n], o = e[(n + 1) % r], l = e[(n + 2) % r], h = {
			x: s.x + (o.x - a.x) * t,
			y: s.y + (o.y - a.y) * t
		}, u = {
			x: o.x - (l.x - s.x) * t,
			y: o.y - (l.y - s.y) * t
		};
		i += ` C${h.x},${h.y} ${u.x},${u.y} ${o.x},${o.y}`;
	}
	return `${i} Z`;
}
function esw(e, t, r, i) {
	if (!r) return;
	let n = (i.width / 2 + i.marginRight) * 3 / 4, a = -(3 * (i.height / 2 + i.marginTop)) / 4;
	t.forEach((t, r) => {
		let i = e.append("g").attr("transform", `translate(${n}, ${a + 20 * r})`);
		i.append("rect").attr("width", 12).attr("height", 12).attr("class", `radarLegendBox-${r}`), i.append("text").attr("x", 16).attr("y", 0).attr("class", "radarLegendText").text(t.label);
	});
}
h(esv, "drawCurves"), h(esx, "relativeRadius"), h(esb, "closedRoundCurve"), h(esw, "drawLegend");
var esk = h((e, t) => {
	let r = "";
	for (let i = 0; i < e.THEME_COLOR_LIMIT; i++) {
		let n = e[`cScale${i}`];
		r += `
		.radarCurve-${i} {
			color: ${n};
			fill: ${n};
			fill-opacity: ${t.curveOpacity};
			stroke: ${n};
			stroke-width: ${t.curveStrokeWidth};
		}
		.radarLegendBox-${i} {
			fill: ${n};
			fill-opacity: ${t.curveOpacity};
			stroke: ${n};
		}
		`;
	}
	return r;
}, "genIndexStyles"), esT = h((e) => {
	let t = V5(Io(), IA().themeVariables);
	return {
		themeVariables: t,
		radarOptions: V5(t.radar, e)
	};
}, "buildRadarStyleOptions"), es_ = {
	parser: esp,
	db: esu,
	renderer: { draw: esf },
	styles: h(({ radar: e } = {}) => {
		let { themeVariables: t, radarOptions: r } = esT(e);
		return `
	.radarTitle {
		font-size: ${t.fontSize};
		color: ${t.titleColor};
		dominant-baseline: hanging;
		text-anchor: middle;
	}
	.radarAxisLine {
		stroke: ${r.axisColor};
		stroke-width: ${r.axisStrokeWidth};
	}
	.radarAxisLabel {
		dominant-baseline: middle;
		text-anchor: middle;
		font-size: ${r.axisLabelFontSize}px;
		color: ${r.axisColor};
	}
	.radarGraticule {
		fill: ${r.graticuleColor};
		fill-opacity: ${r.graticuleOpacity};
		stroke: ${r.graticuleColor};
		stroke-width: ${r.graticuleStrokeWidth};
	}
	.radarLegendText {
		text-anchor: start;
		font-size: ${r.legendFontSize}px;
		dominant-baseline: hanging;
	}
	${esk(t, r)}
	`;
	}, "styles")
}, esE = class {
	constructor() {
		this.nodes = [], this.levels = /* @__PURE__ */ new Map(), this.outerNodes = [], this.classes = /* @__PURE__ */ new Map(), this.setAccTitle = Da, this.getAccTitle = Ds, this.setDiagramTitle = Dc, this.getDiagramTitle = Dh, this.getAccDescription = Dl, this.setAccDescription = Do;
	}
	static {
		h(this, "TreeMapDB");
	}
	getNodes() {
		return this.nodes;
	}
	getConfig() {
		let e = IA();
		return V5({
			...Ip.treemap,
			...e.treemap ?? {}
		});
	}
	addNode(e, t) {
		this.nodes.push(e), this.levels.set(e, t), 0 === t && (this.outerNodes.push(e), this.root ??= e);
	}
	getRoot() {
		return {
			name: "",
			children: this.outerNodes
		};
	}
	addClass(e, t) {
		let r = this.classes.get(e) ?? {
			id: e,
			styles: [],
			textStyles: []
		}, i = t.replace(/\\,/g, "").replace(/,/g, ";").replace(//g, ",").split(";");
		i && i.forEach((e) => {
			JQ(e) && (r?.textStyles ? r.textStyles.push(e) : r.textStyles = [e]), r?.styles ? r.styles.push(e) : r.styles = [e];
		}), this.classes.set(e, r);
	}
	getClasses() {
		return this.classes;
	}
	getStylesForClass(e) {
		return this.classes.get(e)?.styles ?? [];
	}
	clear() {
		Dn(), this.nodes = [], this.levels = /* @__PURE__ */ new Map(), this.outerNodes = [], this.classes = /* @__PURE__ */ new Map(), this.root = void 0;
	}
};
function esC(e) {
	if (!e.length) return [];
	let t = [], r = [];
	return e.forEach((e) => {
		let i = {
			name: e.name,
			children: "Leaf" === e.type ? void 0 : []
		};
		for (i.classSelector = e?.classSelector, e?.cssCompiledStyles && (i.cssCompiledStyles = [e.cssCompiledStyles]), "Leaf" === e.type && void 0 !== e.value && (i.value = e.value); r.length > 0 && r[r.length - 1].level >= e.level;) r.pop();
		if (0 === r.length) t.push(i);
		else {
			let e = r[r.length - 1].node;
			e.children ? e.children.push(i) : e.children = [i];
		}
		"Leaf" !== e.type && r.push({
			node: i,
			level: e.level
		});
	}), t;
}
h(esC, "buildHierarchy");
var esS = h((e, t) => {
	w_(e, t);
	let r = [];
	for (let r of e.TreemapRows ?? []) "ClassDefStatement" === r.$type && t.addClass(r.className ?? "", r.styleText ?? "");
	for (let i of e.TreemapRows ?? []) {
		let e = i.item;
		if (!e) continue;
		let n = i.indent ? parseInt(i.indent) : 0, a = esA(e), s = e.classSelector ? t.getStylesForClass(e.classSelector) : [], o = s.length > 0 ? s.join(";") : void 0, l = {
			level: n,
			name: a,
			type: e.$type,
			value: e.value,
			classSelector: e.classSelector,
			cssCompiledStyles: o
		};
		r.push(l);
	}
	let i = esC(r), n = h((e, r) => {
		for (let i of e) t.addNode(i, r), i.children && i.children.length > 0 && n(i.children, r + 1);
	}, "addNodesRecursively");
	n(i, 0);
}, "populate"), esA = h((e) => e.name ? String(e.name) : "", "getItemName"), esL = {
	parser: { yy: void 0 },
	parse: h(async (e) => {
		try {
			let t = await wS("treemap", e);
			wQ.debug("Treemap AST:", t);
			let r = esL.parser?.yy;
			if (!(r instanceof esE)) throw Error("parser.parser?.yy was not a TreemapDB. This is due to a bug within Mermaid, please report this issue at https://github.com/mermaid-js/mermaid/issues.");
			esS(t, r);
		} catch (e) {
			throw wQ.error("Error parsing treemap:", e), e;
		}
	}, "parse")
}, esR = {
	draw: h((e, t, r, i) => {
		let n, a = i.db, s = a.getConfig(), o = s.padding ?? 10, l = a.getDiagramTitle(), u = a.getRoot(), { themeVariables: d } = IA();
		if (!u) return;
		let p = 30 * !!l, f = Dy(t), g = s.nodeWidth ? 10 * s.nodeWidth : 960, m = s.nodeHeight ? 10 * s.nodeHeight : 500, y = m + p;
		f.attr("viewBox", `0 0 ${g} ${y}`), M5(f, y, g, s.useMaxWidth);
		try {
			let e = s.valueFormat || ",";
			if ("$0,0" === e) n = h((e) => "$" + LQ(",")(e), "valueFormat");
			else if (e.startsWith("$") && e.includes(",")) {
				let t = /\.\d+/.exec(e), r = t ? t[0] : "";
				n = h((e) => "$" + LQ("," + r)(e), "valueFormat");
			} else if (e.startsWith("$")) {
				let t = e.substring(1);
				n = h((e) => "$" + LQ(t || "")(e), "valueFormat");
			} else n = LQ(e);
		} catch (e) {
			wQ.error("Error creating format function:", e), n = LQ(",");
		}
		let v = Cm().range([
			"transparent",
			d.cScale0,
			d.cScale1,
			d.cScale2,
			d.cScale3,
			d.cScale4,
			d.cScale5,
			d.cScale6,
			d.cScale7,
			d.cScale8,
			d.cScale9,
			d.cScale10,
			d.cScale11
		]), x = Cm().range([
			"transparent",
			d.cScalePeer0,
			d.cScalePeer1,
			d.cScalePeer2,
			d.cScalePeer3,
			d.cScalePeer4,
			d.cScalePeer5,
			d.cScalePeer6,
			d.cScalePeer7,
			d.cScalePeer8,
			d.cScalePeer9,
			d.cScalePeer10,
			d.cScalePeer11
		]), b = Cm().range([
			d.cScaleLabel0,
			d.cScaleLabel1,
			d.cScaleLabel2,
			d.cScaleLabel3,
			d.cScaleLabel4,
			d.cScaleLabel5,
			d.cScaleLabel6,
			d.cScaleLabel7,
			d.cScaleLabel8,
			d.cScaleLabel9,
			d.cScaleLabel10,
			d.cScaleLabel11
		]);
		l && f.append("text").attr("x", g / 2).attr("y", p / 2).attr("class", "treemapTitle").attr("text-anchor", "middle").attr("dominant-baseline", "middle").text(l);
		let w = f.append("g").attr("transform", `translate(0, ${p})`).attr("class", "treemapContainer"), k = E7(u).sum((e) => e.value ?? 0).sort((e, t) => (t.value ?? 0) - (e.value ?? 0)), T = Cp().size([g, m]).paddingTop((e) => e.children && e.children.length > 0 ? 35 : 0).paddingInner(o).paddingLeft((e) => e.children && e.children.length > 0 ? 10 : 0).paddingRight((e) => e.children && e.children.length > 0 ? 10 : 0).paddingBottom((e) => e.children && e.children.length > 0 ? 10 : 0).round(!0)(k), _ = T.descendants().filter((e) => e.children && e.children.length > 0), E = w.selectAll(".treemapSection").data(_).enter().append("g").attr("class", "treemapSection").attr("transform", (e) => `translate(${e.x0},${e.y0})`);
		E.append("rect").attr("width", (e) => e.x1 - e.x0).attr("height", 25).attr("class", "treemapSectionHeader").attr("fill", "none").attr("fill-opacity", .6).attr("stroke-width", .6).attr("style", (e) => 0 === e.depth ? "display: none;" : ""), E.append("clipPath").attr("id", (e, r) => `clip-section-${t}-${r}`).append("rect").attr("width", (e) => Math.max(0, e.x1 - e.x0 - 12)).attr("height", 25), E.append("rect").attr("width", (e) => e.x1 - e.x0).attr("height", (e) => e.y1 - e.y0).attr("class", (e, t) => `treemapSection section${t}`).attr("fill", (e) => v(e.data.name)).attr("fill-opacity", .6).attr("stroke", (e) => x(e.data.name)).attr("stroke-width", 2).attr("stroke-opacity", .4).attr("style", (e) => {
			if (0 === e.depth) return "display: none;";
			let t = JJ({ cssCompiledStyles: e.data.cssCompiledStyles });
			return t.nodeStyles + ";" + t.borderStyles.join(";");
		}), E.append("text").attr("class", "treemapSectionLabel").attr("x", 6).attr("y", 12.5).attr("dominant-baseline", "middle").text((e) => 0 === e.depth ? "" : e.data.name).attr("font-weight", "bold").attr("style", (e) => 0 === e.depth ? "display: none;" : "dominant-baseline: middle; font-size: 12px; fill:" + b(e.data.name) + "; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" + JJ({ cssCompiledStyles: e.data.cssCompiledStyles }).labelStyles.replace("color:", "fill:")).each(function(e) {
			if (0 === e.depth) return;
			let t = _t(this), r = e.data.name;
			t.text(r);
			let i = e.x1 - e.x0, n = Math.max(15, !1 !== s.showValues && e.value ? i - 10 - 30 - 10 - 6 : i - 6 - 6), a = t.node();
			if (a.getComputedTextLength() > n) {
				let e = r;
				for (; e.length > 0;) {
					if (0 === (e = r.substring(0, e.length - 1)).length) {
						t.text("..."), a.getComputedTextLength() > n && t.text("");
						break;
					}
					if (t.text(e + "..."), a.getComputedTextLength() <= n) break;
				}
			}
		}), !1 !== s.showValues && E.append("text").attr("class", "treemapSectionValue").attr("x", (e) => e.x1 - e.x0 - 10).attr("y", 12.5).attr("text-anchor", "end").attr("dominant-baseline", "middle").text((e) => e.value ? n(e.value) : "").attr("font-style", "italic").attr("style", (e) => 0 === e.depth ? "display: none;" : "text-anchor: end; dominant-baseline: middle; font-size: 10px; fill:" + b(e.data.name) + "; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" + JJ({ cssCompiledStyles: e.data.cssCompiledStyles }).labelStyles.replace("color:", "fill:"));
		let C = T.leaves(), S = w.selectAll(".treemapLeafGroup").data(C).enter().append("g").attr("class", (e, t) => `treemapNode treemapLeafGroup leaf${t}${e.data.classSelector ? ` ${e.data.classSelector}` : ""}x`).attr("transform", (e) => `translate(${e.x0},${e.y0})`);
		S.append("rect").attr("width", (e) => e.x1 - e.x0).attr("height", (e) => e.y1 - e.y0).attr("class", "treemapLeaf").attr("fill", (e) => e.parent ? v(e.parent.data.name) : v(e.data.name)).attr("style", (e) => JJ({ cssCompiledStyles: e.data.cssCompiledStyles }).nodeStyles).attr("fill-opacity", .3).attr("stroke", (e) => e.parent ? v(e.parent.data.name) : v(e.data.name)).attr("stroke-width", 3), S.append("clipPath").attr("id", (e, r) => `clip-${t}-${r}`).append("rect").attr("width", (e) => Math.max(0, e.x1 - e.x0 - 4)).attr("height", (e) => Math.max(0, e.y1 - e.y0 - 4)), S.append("text").attr("class", "treemapLabel").attr("x", (e) => (e.x1 - e.x0) / 2).attr("y", (e) => (e.y1 - e.y0) / 2).attr("style", (e) => "text-anchor: middle; dominant-baseline: middle; font-size: 38px;fill:" + b(e.data.name) + ";" + JJ({ cssCompiledStyles: e.data.cssCompiledStyles }).labelStyles.replace("color:", "fill:")).attr("clip-path", (e, r) => `url(#clip-${t}-${r})`).text((e) => e.data.name).each(function(e) {
			let t = _t(this), r = e.x1 - e.x0, i = e.y1 - e.y0, n = t.node(), a = r - 8, s = i - 8;
			if (a < 10 || s < 10) return void t.style("display", "none");
			let o = parseInt(t.style("font-size"), 10);
			for (; n.getComputedTextLength() > a && o > 8;) o--, t.style("font-size", `${o}px`);
			let l = Math.max(6, Math.min(28, Math.round(.6 * o))), h = o + 2 + l;
			for (; h > s && o > 8 && !((l = Math.max(6, Math.min(28, Math.round(.6 * --o)))) < 6 && 8 === o);) t.style("font-size", `${o}px`), h = o + 2 + l;
			t.style("font-size", `${o}px`), (n.getComputedTextLength() > a || o < 8 || s < o) && t.style("display", "none");
		}), !1 !== s.showValues && S.append("text").attr("class", "treemapValue").attr("x", (e) => (e.x1 - e.x0) / 2).attr("y", function(e) {
			return (e.y1 - e.y0) / 2;
		}).attr("style", (e) => "text-anchor: middle; dominant-baseline: hanging; font-size: 28px;fill:" + b(e.data.name) + ";" + JJ({ cssCompiledStyles: e.data.cssCompiledStyles }).labelStyles.replace("color:", "fill:")).attr("clip-path", (e, r) => `url(#clip-${t}-${r})`).text((e) => e.value ? n(e.value) : "").each(function(e) {
			let t = _t(this), r = this.parentNode;
			if (!r) return void t.style("display", "none");
			let i = _t(r).select(".treemapLabel");
			if (i.empty() || "none" === i.style("display")) return void t.style("display", "none");
			let n = parseFloat(i.style("font-size")), a = Math.max(6, Math.min(28, Math.round(.6 * n)));
			t.style("font-size", `${a}px`);
			let s = (e.y1 - e.y0) / 2 + n / 2 + 2;
			t.attr("y", s);
			let o = e.x1 - e.x0, l = e.y1 - e.y0 - 4;
			t.node().getComputedTextLength() > o - 8 || s + a > l || a < 6 ? t.style("display", "none") : t.style("display", null);
		}), JY(f, s.diagramPadding ?? 8, "flowchart", s?.useMaxWidth || !1);
	}, "draw"),
	getClasses: h(function(e, t) {
		return t.db.getClasses();
	}, "getClasses")
}, esN = {
	sectionStrokeColor: "black",
	sectionStrokeWidth: "1",
	sectionFillColor: "#efefef",
	leafStrokeColor: "black",
	leafStrokeWidth: "1",
	leafFillColor: "#efefef",
	labelColor: "black",
	labelFontSize: "12px",
	valueFontSize: "10px",
	valueColor: "black",
	titleColor: "black",
	titleFontSize: "14px"
}, esI = {
	parser: esL,
	get db() {
		return new esE();
	},
	renderer: esR,
	styles: h(({ treemap: e } = {}) => {
		let t = V5(esN, e);
		return `
  .treemapNode.section {
    stroke: ${t.sectionStrokeColor};
    stroke-width: ${t.sectionStrokeWidth};
    fill: ${t.sectionFillColor};
  }
  .treemapNode.leaf {
    stroke: ${t.leafStrokeColor};
    stroke-width: ${t.leafStrokeWidth};
    fill: ${t.leafFillColor};
  }
  .treemapLabel {
    fill: ${t.labelColor};
    font-size: ${t.labelFontSize};
  }
  .treemapValue {
    fill: ${t.valueColor};
    font-size: ${t.valueFontSize};
  }
  .treemapTitle {
    fill: ${t.titleColor};
    font-size: ${t.titleFontSize};
  }
  `;
	}, "getStyles")
}, esM = function() {
	var e = h(function(e, t, r, i) {
		for (r = r || {}, i = e.length; i--; r[e[i]] = t);
		return r;
	}, "o"), t = [
		6,
		8,
		10,
		22,
		24,
		26,
		28,
		33,
		34,
		35,
		36,
		37,
		40,
		43,
		44,
		50
	], r = [1, 10], i = [1, 11], n = [1, 12], a = [1, 13], s = [1, 20], o = [1, 21], l = [1, 22], u = [1, 23], d = [1, 24], p = [1, 19], f = [1, 25], g = [1, 26], m = [1, 18], y = [1, 33], v = [1, 34], x = [1, 35], b = [1, 36], w = [1, 37], k = [
		6,
		8,
		10,
		13,
		15,
		17,
		20,
		21,
		22,
		24,
		26,
		28,
		33,
		34,
		35,
		36,
		37,
		40,
		43,
		44,
		50,
		63,
		64,
		65,
		66,
		67
	], T = [1, 42], _ = [1, 43], E = [1, 52], C = [
		40,
		50,
		68,
		69
	], S = [1, 63], A = [1, 61], L = [1, 58], R = [1, 62], N = [1, 64], I = [
		6,
		8,
		10,
		13,
		17,
		22,
		24,
		26,
		28,
		33,
		34,
		35,
		36,
		37,
		40,
		41,
		42,
		43,
		44,
		48,
		49,
		50,
		63,
		64,
		65,
		66,
		67
	], M = [
		63,
		64,
		65,
		66,
		67
	], D = [1, 81], O = [1, 80], $ = [1, 78], P = [1, 79], B = [
		6,
		10,
		42,
		47
	], F = [
		6,
		10,
		13,
		41,
		42,
		47,
		48,
		49
	], z = [1, 89], U = [1, 88], G = [1, 87], q = [19, 56], j = [1, 98], W = [1, 97], Y = [
		19,
		56,
		58,
		60
	], V = {
		trace: h(function() {}, "trace"),
		yy: {},
		symbols_: {
			error: 2,
			start: 3,
			ER_DIAGRAM: 4,
			document: 5,
			EOF: 6,
			line: 7,
			SPACE: 8,
			statement: 9,
			NEWLINE: 10,
			entityName: 11,
			relSpec: 12,
			COLON: 13,
			role: 14,
			STYLE_SEPARATOR: 15,
			idList: 16,
			BLOCK_START: 17,
			attributes: 18,
			BLOCK_STOP: 19,
			SQS: 20,
			SQE: 21,
			title: 22,
			title_value: 23,
			acc_title: 24,
			acc_title_value: 25,
			acc_descr: 26,
			acc_descr_value: 27,
			acc_descr_multiline_value: 28,
			direction: 29,
			classDefStatement: 30,
			classStatement: 31,
			styleStatement: 32,
			direction_tb: 33,
			direction_bt: 34,
			direction_rl: 35,
			direction_lr: 36,
			CLASSDEF: 37,
			stylesOpt: 38,
			separator: 39,
			UNICODE_TEXT: 40,
			STYLE_TEXT: 41,
			COMMA: 42,
			CLASS: 43,
			STYLE: 44,
			style: 45,
			styleComponent: 46,
			SEMI: 47,
			NUM: 48,
			BRKT: 49,
			ENTITY_NAME: 50,
			attribute: 51,
			attributeType: 52,
			attributeName: 53,
			attributeKeyTypeList: 54,
			attributeComment: 55,
			ATTRIBUTE_WORD: 56,
			attributeKeyType: 57,
			",": 58,
			ATTRIBUTE_KEY: 59,
			COMMENT: 60,
			cardinality: 61,
			relType: 62,
			ZERO_OR_ONE: 63,
			ZERO_OR_MORE: 64,
			ONE_OR_MORE: 65,
			ONLY_ONE: 66,
			MD_PARENT: 67,
			NON_IDENTIFYING: 68,
			IDENTIFYING: 69,
			WORD: 70,
			$accept: 0,
			$end: 1
		},
		terminals_: {
			2: "error",
			4: "ER_DIAGRAM",
			6: "EOF",
			8: "SPACE",
			10: "NEWLINE",
			13: "COLON",
			15: "STYLE_SEPARATOR",
			17: "BLOCK_START",
			19: "BLOCK_STOP",
			20: "SQS",
			21: "SQE",
			22: "title",
			23: "title_value",
			24: "acc_title",
			25: "acc_title_value",
			26: "acc_descr",
			27: "acc_descr_value",
			28: "acc_descr_multiline_value",
			33: "direction_tb",
			34: "direction_bt",
			35: "direction_rl",
			36: "direction_lr",
			37: "CLASSDEF",
			40: "UNICODE_TEXT",
			41: "STYLE_TEXT",
			42: "COMMA",
			43: "CLASS",
			44: "STYLE",
			47: "SEMI",
			48: "NUM",
			49: "BRKT",
			50: "ENTITY_NAME",
			56: "ATTRIBUTE_WORD",
			58: ",",
			59: "ATTRIBUTE_KEY",
			60: "COMMENT",
			63: "ZERO_OR_ONE",
			64: "ZERO_OR_MORE",
			65: "ONE_OR_MORE",
			66: "ONLY_ONE",
			67: "MD_PARENT",
			68: "NON_IDENTIFYING",
			69: "IDENTIFYING",
			70: "WORD"
		},
		productions_: [
			0,
			[3, 3],
			[5, 0],
			[5, 2],
			[7, 2],
			[7, 1],
			[7, 1],
			[7, 1],
			[9, 5],
			[9, 9],
			[9, 7],
			[9, 7],
			[9, 4],
			[9, 6],
			[9, 3],
			[9, 5],
			[9, 1],
			[9, 3],
			[9, 7],
			[9, 9],
			[9, 6],
			[9, 8],
			[9, 4],
			[9, 6],
			[9, 2],
			[9, 2],
			[9, 2],
			[9, 1],
			[9, 1],
			[9, 1],
			[9, 1],
			[9, 1],
			[29, 1],
			[29, 1],
			[29, 1],
			[29, 1],
			[30, 4],
			[16, 1],
			[16, 1],
			[16, 3],
			[16, 3],
			[31, 3],
			[32, 4],
			[38, 1],
			[38, 3],
			[45, 1],
			[45, 2],
			[39, 1],
			[39, 1],
			[39, 1],
			[46, 1],
			[46, 1],
			[46, 1],
			[46, 1],
			[11, 1],
			[11, 1],
			[18, 1],
			[18, 2],
			[51, 2],
			[51, 3],
			[51, 3],
			[51, 4],
			[52, 1],
			[53, 1],
			[54, 1],
			[54, 3],
			[57, 1],
			[55, 1],
			[12, 3],
			[61, 1],
			[61, 1],
			[61, 1],
			[61, 1],
			[61, 1],
			[62, 1],
			[62, 1],
			[14, 1],
			[14, 1],
			[14, 1]
		],
		performAction: h(function(e, t, r, i, n, a, s) {
			var o = a.length - 1;
			switch (n) {
				case 1: break;
				case 2:
				case 6:
				case 7:
					this.$ = [];
					break;
				case 3:
					a[o - 1].push(a[o]), this.$ = a[o - 1];
					break;
				case 4:
				case 5:
				case 55:
				case 78:
				case 62:
				case 63:
				case 66:
					this.$ = a[o];
					break;
				case 8:
					i.addEntity(a[o - 4]), i.addEntity(a[o - 2]), i.addRelationship(a[o - 4], a[o], a[o - 2], a[o - 3]);
					break;
				case 9:
					i.addEntity(a[o - 8]), i.addEntity(a[o - 4]), i.addRelationship(a[o - 8], a[o], a[o - 4], a[o - 5]), i.setClass([a[o - 8]], a[o - 6]), i.setClass([a[o - 4]], a[o - 2]);
					break;
				case 10:
					i.addEntity(a[o - 6]), i.addEntity(a[o - 2]), i.addRelationship(a[o - 6], a[o], a[o - 2], a[o - 3]), i.setClass([a[o - 6]], a[o - 4]);
					break;
				case 11:
					i.addEntity(a[o - 6]), i.addEntity(a[o - 4]), i.addRelationship(a[o - 6], a[o], a[o - 4], a[o - 5]), i.setClass([a[o - 4]], a[o - 2]);
					break;
				case 12:
					i.addEntity(a[o - 3]), i.addAttributes(a[o - 3], a[o - 1]);
					break;
				case 13:
					i.addEntity(a[o - 5]), i.addAttributes(a[o - 5], a[o - 1]), i.setClass([a[o - 5]], a[o - 3]);
					break;
				case 14:
					i.addEntity(a[o - 2]);
					break;
				case 15:
					i.addEntity(a[o - 4]), i.setClass([a[o - 4]], a[o - 2]);
					break;
				case 16:
					i.addEntity(a[o]);
					break;
				case 17:
					i.addEntity(a[o - 2]), i.setClass([a[o - 2]], a[o]);
					break;
				case 18:
					i.addEntity(a[o - 6], a[o - 4]), i.addAttributes(a[o - 6], a[o - 1]);
					break;
				case 19:
					i.addEntity(a[o - 8], a[o - 6]), i.addAttributes(a[o - 8], a[o - 1]), i.setClass([a[o - 8]], a[o - 3]);
					break;
				case 20:
					i.addEntity(a[o - 5], a[o - 3]);
					break;
				case 21:
					i.addEntity(a[o - 7], a[o - 5]), i.setClass([a[o - 7]], a[o - 2]);
					break;
				case 22:
					i.addEntity(a[o - 3], a[o - 1]);
					break;
				case 23:
					i.addEntity(a[o - 5], a[o - 3]), i.setClass([a[o - 5]], a[o]);
					break;
				case 24:
				case 25:
					this.$ = a[o].trim(), i.setAccTitle(this.$);
					break;
				case 26:
				case 27:
					this.$ = a[o].trim(), i.setAccDescription(this.$);
					break;
				case 32:
					i.setDirection("TB");
					break;
				case 33:
					i.setDirection("BT");
					break;
				case 34:
					i.setDirection("RL");
					break;
				case 35:
					i.setDirection("LR");
					break;
				case 36:
					this.$ = a[o - 3], i.addClass(a[o - 2], a[o - 1]);
					break;
				case 37:
				case 38:
				case 56:
				case 64:
				case 43:
					this.$ = [a[o]];
					break;
				case 39:
				case 40:
					this.$ = a[o - 2].concat([a[o]]);
					break;
				case 41:
					this.$ = a[o - 2], i.setClass(a[o - 1], a[o]);
					break;
				case 42:
					this.$ = a[o - 3], i.addCssStyles(a[o - 2], a[o - 1]);
					break;
				case 44:
				case 65:
					a[o - 2].push(a[o]), this.$ = a[o - 2];
					break;
				case 46:
					this.$ = a[o - 1] + a[o];
					break;
				case 54:
				case 76:
				case 77:
				case 67:
					this.$ = a[o].replace(/"/g, "");
					break;
				case 57:
					a[o].push(a[o - 1]), this.$ = a[o];
					break;
				case 58:
					this.$ = {
						type: a[o - 1],
						name: a[o]
					};
					break;
				case 59:
					this.$ = {
						type: a[o - 2],
						name: a[o - 1],
						keys: a[o]
					};
					break;
				case 60:
					this.$ = {
						type: a[o - 2],
						name: a[o - 1],
						comment: a[o]
					};
					break;
				case 61:
					this.$ = {
						type: a[o - 3],
						name: a[o - 2],
						keys: a[o - 1],
						comment: a[o]
					};
					break;
				case 68:
					this.$ = {
						cardA: a[o],
						relType: a[o - 1],
						cardB: a[o - 2]
					};
					break;
				case 69:
					this.$ = i.Cardinality.ZERO_OR_ONE;
					break;
				case 70:
					this.$ = i.Cardinality.ZERO_OR_MORE;
					break;
				case 71:
					this.$ = i.Cardinality.ONE_OR_MORE;
					break;
				case 72:
					this.$ = i.Cardinality.ONLY_ONE;
					break;
				case 73:
					this.$ = i.Cardinality.MD_PARENT;
					break;
				case 74:
					this.$ = i.Identification.NON_IDENTIFYING;
					break;
				case 75: this.$ = i.Identification.IDENTIFYING;
			}
		}, "anonymous"),
		table: [
			{
				3: 1,
				4: [1, 2]
			},
			{ 1: [3] },
			e(t, [2, 2], { 5: 3 }),
			{
				6: [1, 4],
				7: 5,
				8: [1, 6],
				9: 7,
				10: [1, 8],
				11: 9,
				22: r,
				24: i,
				26: n,
				28: a,
				29: 14,
				30: 15,
				31: 16,
				32: 17,
				33: s,
				34: o,
				35: l,
				36: u,
				37: d,
				40: p,
				43: f,
				44: g,
				50: m
			},
			e(t, [2, 7], { 1: [2, 1] }),
			e(t, [2, 3]),
			{
				9: 27,
				11: 9,
				22: r,
				24: i,
				26: n,
				28: a,
				29: 14,
				30: 15,
				31: 16,
				32: 17,
				33: s,
				34: o,
				35: l,
				36: u,
				37: d,
				40: p,
				43: f,
				44: g,
				50: m
			},
			e(t, [2, 5]),
			e(t, [2, 6]),
			e(t, [2, 16], {
				12: 28,
				61: 32,
				15: [1, 29],
				17: [1, 30],
				20: [1, 31],
				63: y,
				64: v,
				65: x,
				66: b,
				67: w
			}),
			{ 23: [1, 38] },
			{ 25: [1, 39] },
			{ 27: [1, 40] },
			e(t, [2, 27]),
			e(t, [2, 28]),
			e(t, [2, 29]),
			e(t, [2, 30]),
			e(t, [2, 31]),
			e(k, [2, 54]),
			e(k, [2, 55]),
			e(t, [2, 32]),
			e(t, [2, 33]),
			e(t, [2, 34]),
			e(t, [2, 35]),
			{
				16: 41,
				40: T,
				41: _
			},
			{
				16: 44,
				40: T,
				41: _
			},
			{
				16: 45,
				40: T,
				41: _
			},
			e(t, [2, 4]),
			{
				11: 46,
				40: p,
				50: m
			},
			{
				16: 47,
				40: T,
				41: _
			},
			{
				18: 48,
				19: [1, 49],
				51: 50,
				52: 51,
				56: E
			},
			{
				11: 53,
				40: p,
				50: m
			},
			{
				62: 54,
				68: [1, 55],
				69: [1, 56]
			},
			e(C, [2, 69]),
			e(C, [2, 70]),
			e(C, [2, 71]),
			e(C, [2, 72]),
			e(C, [2, 73]),
			e(t, [2, 24]),
			e(t, [2, 25]),
			e(t, [2, 26]),
			{
				13: S,
				38: 57,
				41: A,
				42: L,
				45: 59,
				46: 60,
				48: R,
				49: N
			},
			e(I, [2, 37]),
			e(I, [2, 38]),
			{
				16: 65,
				40: T,
				41: _,
				42: L
			},
			{
				13: S,
				38: 66,
				41: A,
				42: L,
				45: 59,
				46: 60,
				48: R,
				49: N
			},
			{
				13: [1, 67],
				15: [1, 68]
			},
			e(t, [2, 17], {
				61: 32,
				12: 69,
				17: [1, 70],
				42: L,
				63: y,
				64: v,
				65: x,
				66: b,
				67: w
			}),
			{ 19: [1, 71] },
			e(t, [2, 14]),
			{
				18: 72,
				19: [2, 56],
				51: 50,
				52: 51,
				56: E
			},
			{
				53: 73,
				56: [1, 74]
			},
			{ 56: [2, 62] },
			{ 21: [1, 75] },
			{
				61: 76,
				63: y,
				64: v,
				65: x,
				66: b,
				67: w
			},
			e(M, [2, 74]),
			e(M, [2, 75]),
			{
				6: D,
				10: O,
				39: 77,
				42: $,
				47: P
			},
			{
				40: [1, 82],
				41: [1, 83]
			},
			e(B, [2, 43], {
				46: 84,
				13: S,
				41: A,
				48: R,
				49: N
			}),
			e(F, [2, 45]),
			e(F, [2, 50]),
			e(F, [2, 51]),
			e(F, [2, 52]),
			e(F, [2, 53]),
			e(t, [2, 41], { 42: L }),
			{
				6: D,
				10: O,
				39: 85,
				42: $,
				47: P
			},
			{
				14: 86,
				40: z,
				50: U,
				70: G
			},
			{
				16: 90,
				40: T,
				41: _
			},
			{
				11: 91,
				40: p,
				50: m
			},
			{
				18: 92,
				19: [1, 93],
				51: 50,
				52: 51,
				56: E
			},
			e(t, [2, 12]),
			{ 19: [2, 57] },
			e(q, [2, 58], {
				54: 94,
				55: 95,
				57: 96,
				59: j,
				60: W
			}),
			e([
				19,
				56,
				59,
				60
			], [2, 63]),
			e(t, [2, 22], {
				15: [1, 100],
				17: [1, 99]
			}),
			e([40, 50], [2, 68]),
			e(t, [2, 36]),
			{
				13: S,
				41: A,
				45: 101,
				46: 60,
				48: R,
				49: N
			},
			e(t, [2, 47]),
			e(t, [2, 48]),
			e(t, [2, 49]),
			e(I, [2, 39]),
			e(I, [2, 40]),
			e(F, [2, 46]),
			e(t, [2, 42]),
			e(t, [2, 8]),
			e(t, [2, 76]),
			e(t, [2, 77]),
			e(t, [2, 78]),
			{
				13: [1, 102],
				42: L
			},
			{
				13: [1, 104],
				15: [1, 103]
			},
			{ 19: [1, 105] },
			e(t, [2, 15]),
			e(q, [2, 59], {
				55: 106,
				58: [1, 107],
				60: W
			}),
			e(q, [2, 60]),
			e(Y, [2, 64]),
			e(q, [2, 67]),
			e(Y, [2, 66]),
			{
				18: 108,
				19: [1, 109],
				51: 50,
				52: 51,
				56: E
			},
			{
				16: 110,
				40: T,
				41: _
			},
			e(B, [2, 44], {
				46: 84,
				13: S,
				41: A,
				48: R,
				49: N
			}),
			{
				14: 111,
				40: z,
				50: U,
				70: G
			},
			{
				16: 112,
				40: T,
				41: _
			},
			{
				14: 113,
				40: z,
				50: U,
				70: G
			},
			e(t, [2, 13]),
			e(q, [2, 61]),
			{
				57: 114,
				59: j
			},
			{ 19: [1, 115] },
			e(t, [2, 20]),
			e(t, [2, 23], {
				17: [1, 116],
				42: L
			}),
			e(t, [2, 11]),
			{
				13: [1, 117],
				42: L
			},
			e(t, [2, 10]),
			e(Y, [2, 65]),
			e(t, [2, 18]),
			{
				18: 118,
				19: [1, 119],
				51: 50,
				52: 51,
				56: E
			},
			{
				14: 120,
				40: z,
				50: U,
				70: G
			},
			{ 19: [1, 121] },
			e(t, [2, 21]),
			e(t, [2, 9]),
			e(t, [2, 19])
		],
		defaultActions: {
			52: [2, 62],
			72: [2, 57]
		},
		parseError: h(function(e, t) {
			if (t.recoverable) this.trace(e);
			else {
				var r = Error(e);
				throw r.hash = t, r;
			}
		}, "parseError"),
		parse: h(function(e) {
			var t = this, r = [0], i = [], n = [null], a = [], s = this.table, o = "", l = 0, u = 0, d = 0, p = a.slice.call(arguments, 1), f = Object.create(this.lexer), g = {};
			for (var m in this.yy) Object.prototype.hasOwnProperty.call(this.yy, m) && (g[m] = this.yy[m]);
			f.setInput(e, g), g.lexer = f, g.parser = this, typeof f.yylloc > "u" && (f.yylloc = {});
			var y = f.yylloc;
			a.push(y);
			var v = f.options && f.options.ranges;
			function x() {
				var e;
				return "number" != typeof (e = i.pop() || f.lex() || 1) && (e instanceof Array && (e = (i = e).pop()), e = t.symbols_[e] || e), e;
			}
			"function" == typeof g.parseError ? this.parseError = g.parseError : this.parseError = Object.getPrototypeOf(this).parseError, h(function(e) {
				r.length = r.length - 2 * e, n.length = n.length - e, a.length = a.length - e;
			}, "popStack"), h(x, "lex");
			for (var b, w, k, T, _, E, C, S, A, L = {};;) {
				if (k = r[r.length - 1], this.defaultActions[k] ? T = this.defaultActions[k] : ((null === b || typeof b > "u") && (b = x()), T = s[k] && s[k][b]), typeof T > "u" || !T.length || !T[0]) {
					var R = "";
					for (E in A = [], s[k]) this.terminals_[E] && E > 2 && A.push("'" + this.terminals_[E] + "'");
					R = f.showPosition ? "Parse error on line " + (l + 1) + `:
` + f.showPosition() + `
Expecting ` + A.join(", ") + ", got '" + (this.terminals_[b] || b) + "'" : "Parse error on line " + (l + 1) + ": Unexpected " + (1 == b ? "end of input" : "'" + (this.terminals_[b] || b) + "'"), this.parseError(R, {
						text: f.match,
						token: this.terminals_[b] || b,
						line: f.yylineno,
						loc: y,
						expected: A
					});
				}
				if (T[0] instanceof Array && T.length > 1) throw Error("Parse Error: multiple actions possible at state: " + k + ", token: " + b);
				switch (T[0]) {
					case 1:
						r.push(b), n.push(f.yytext), a.push(f.yylloc), r.push(T[1]), b = null, w ? (b = w, w = null) : (u = f.yyleng, o = f.yytext, l = f.yylineno, y = f.yylloc, d > 0 && d--);
						break;
					case 2:
						if (C = this.productions_[T[1]][1], L.$ = n[n.length - C], L._$ = {
							first_line: a[a.length - (C || 1)].first_line,
							last_line: a[a.length - 1].last_line,
							first_column: a[a.length - (C || 1)].first_column,
							last_column: a[a.length - 1].last_column
						}, v && (L._$.range = [a[a.length - (C || 1)].range[0], a[a.length - 1].range[1]]), "u" > typeof (_ = this.performAction.apply(L, [
							o,
							u,
							l,
							g,
							T[1],
							n,
							a
						].concat(p)))) return _;
						C && (r = r.slice(0, -1 * C * 2), n = n.slice(0, -1 * C), a = a.slice(0, -1 * C)), r.push(this.productions_[T[1]][0]), n.push(L.$), a.push(L._$), S = s[r[r.length - 2]][r[r.length - 1]], r.push(S);
						break;
					case 3: return !0;
				}
			}
			return !0;
		}, "parse")
	};
	function H() {
		this.yy = {};
	}
	return V.lexer = {
		EOF: 1,
		parseError: h(function(e, t) {
			if (this.yy.parser) this.yy.parser.parseError(e, t);
			else throw Error(e);
		}, "parseError"),
		setInput: h(function(e, t) {
			return this.yy = t || this.yy || {}, this._input = e, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
				first_line: 1,
				first_column: 0,
				last_line: 1,
				last_column: 0
			}, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
		}, "setInput"),
		input: h(function() {
			var e = this._input[0];
			return this.yytext += e, this.yyleng++, this.offset++, this.match += e, this.matched += e, e.match(/(?:\r\n?|\n).*/g) ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), e;
		}, "input"),
		unput: h(function(e) {
			var t = e.length, r = e.split(/(?:\r\n?|\n)/g);
			this._input = e + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - t), this.offset -= t;
			var i = this.match.split(/(?:\r\n?|\n)/g);
			this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), r.length - 1 && (this.yylineno -= r.length - 1);
			var n = this.yylloc.range;
			return this.yylloc = {
				first_line: this.yylloc.first_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.first_column,
				last_column: r ? (r.length === i.length ? this.yylloc.first_column : 0) + i[i.length - r.length].length - r[0].length : this.yylloc.first_column - t
			}, this.options.ranges && (this.yylloc.range = [n[0], n[0] + this.yyleng - t]), this.yyleng = this.yytext.length, this;
		}, "unput"),
		more: h(function() {
			return this._more = !0, this;
		}, "more"),
		reject: h(function() {
			return this.options.backtrack_lexer ? (this._backtrack = !0, this) : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "reject"),
		less: h(function(e) {
			this.unput(this.match.slice(e));
		}, "less"),
		pastInput: h(function() {
			var e = this.matched.substr(0, this.matched.length - this.match.length);
			return (e.length > 20 ? "..." : "") + e.substr(-20).replace(/\n/g, "");
		}, "pastInput"),
		upcomingInput: h(function() {
			var e = this.match;
			return e.length < 20 && (e += this._input.substr(0, 20 - e.length)), (e.substr(0, 20) + (e.length > 20 ? "..." : "")).replace(/\n/g, "");
		}, "upcomingInput"),
		showPosition: h(function() {
			var e = this.pastInput(), t = Array(e.length + 1).join("-");
			return e + this.upcomingInput() + `
` + t + "^";
		}, "showPosition"),
		test_match: h(function(e, t) {
			var r, i, n;
			if (this.options.backtrack_lexer && (n = {
				yylineno: this.yylineno,
				yylloc: {
					first_line: this.yylloc.first_line,
					last_line: this.last_line,
					first_column: this.yylloc.first_column,
					last_column: this.yylloc.last_column
				},
				yytext: this.yytext,
				match: this.match,
				matches: this.matches,
				matched: this.matched,
				yyleng: this.yyleng,
				offset: this.offset,
				_more: this._more,
				_input: this._input,
				yy: this.yy,
				conditionStack: this.conditionStack.slice(0),
				done: this.done
			}, this.options.ranges && (n.yylloc.range = this.yylloc.range.slice(0))), (i = e[0].match(/(?:\r\n?|\n).*/g)) && (this.yylineno += i.length), this.yylloc = {
				first_line: this.yylloc.last_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.last_column,
				last_column: i ? i[i.length - 1].length - i[i.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + e[0].length
			}, this.yytext += e[0], this.match += e[0], this.matches = e, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(e[0].length), this.matched += e[0], r = this.performAction.call(this, this.yy, this, t, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), r) return r;
			if (this._backtrack) for (var a in n) this[a] = n[a];
			return !1;
		}, "test_match"),
		next: h(function() {
			if (this.done) return this.EOF;
			this._input || (this.done = !0), this._more || (this.yytext = "", this.match = "");
			for (var e, t, r, i, n = this._currentRules(), a = 0; a < n.length; a++) if ((r = this._input.match(this.rules[n[a]])) && (!t || r[0].length > t[0].length)) {
				if (t = r, i = a, this.options.backtrack_lexer) {
					if (!1 !== (e = this.test_match(r, n[a]))) return e;
					if (!this._backtrack) return !1;
					t = !1;
					continue;
				} else if (!this.options.flex) break;
			}
			return t ? !1 !== (e = this.test_match(t, n[i])) && e : "" === this._input ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "next"),
		lex: h(function() {
			return this.next() || this.lex();
		}, "lex"),
		begin: h(function(e) {
			this.conditionStack.push(e);
		}, "begin"),
		popState: h(function() {
			return this.conditionStack.length - 1 > 0 ? this.conditionStack.pop() : this.conditionStack[0];
		}, "popState"),
		_currentRules: h(function() {
			return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
		}, "_currentRules"),
		topState: h(function(e) {
			return (e = this.conditionStack.length - 1 - Math.abs(e || 0)) >= 0 ? this.conditionStack[e] : "INITIAL";
		}, "topState"),
		pushState: h(function(e) {
			this.begin(e);
		}, "pushState"),
		stateStackSize: h(function() {
			return this.conditionStack.length;
		}, "stateStackSize"),
		options: { "case-insensitive": !0 },
		performAction: h(function(e, t, r, i) {
			switch (r) {
				case 0: return this.begin("acc_title"), 24;
				case 1: return this.popState(), "acc_title_value";
				case 2: return this.begin("acc_descr"), 26;
				case 3: return this.popState(), "acc_descr_value";
				case 4:
					this.begin("acc_descr_multiline");
					break;
				case 5:
					this.popState();
					break;
				case 6: return "acc_descr_multiline_value";
				case 7: return 33;
				case 8: return 34;
				case 9: return 35;
				case 10: return 36;
				case 11: return 10;
				case 12:
				case 23:
				case 28:
				case 35: break;
				case 13: return 8;
				case 14: return 50;
				case 15: return 70;
				case 16: return 4;
				case 17: return this.begin("block"), 17;
				case 18:
				case 19:
				case 38: return 49;
				case 20:
				case 37: return 42;
				case 21: return 15;
				case 22:
				case 36: return 13;
				case 24: return 59;
				case 25:
				case 26: return 56;
				case 27: return 60;
				case 29: return this.popState(), 19;
				case 30:
				case 73: return t.yytext[0];
				case 31: return 20;
				case 32: return 21;
				case 33: return this.begin("style"), 44;
				case 34: return this.popState(), 10;
				case 39: return this.begin("style"), 37;
				case 40: return 43;
				case 41:
				case 45:
				case 46:
				case 59: return 63;
				case 42:
				case 43:
				case 44:
				case 52:
				case 54:
				case 61: return 65;
				case 47:
				case 48:
				case 49:
				case 50:
				case 51:
				case 53:
				case 60: return 64;
				case 55:
				case 56:
				case 57:
				case 58: return 66;
				case 62: return 67;
				case 63:
				case 66:
				case 67:
				case 68: return 68;
				case 64:
				case 65: return 69;
				case 69: return 41;
				case 70: return 47;
				case 71: return 40;
				case 72: return 48;
				case 74: return 6;
			}
		}, "anonymous"),
		rules: [
			/^(?:accTitle\s*:\s*)/i,
			/^(?:(?!\n||)*[^\n]*)/i,
			/^(?:accDescr\s*:\s*)/i,
			/^(?:(?!\n||)*[^\n]*)/i,
			/^(?:accDescr\s*\{\s*)/i,
			/^(?:[\}])/i,
			/^(?:[^\}]*)/i,
			/^(?:.*direction\s+TB[^\n]*)/i,
			/^(?:.*direction\s+BT[^\n]*)/i,
			/^(?:.*direction\s+RL[^\n]*)/i,
			/^(?:.*direction\s+LR[^\n]*)/i,
			/^(?:[\n]+)/i,
			/^(?:\s+)/i,
			/^(?:[\s]+)/i,
			/^(?:"[^"%\r\n\v\b\\]+")/i,
			/^(?:"[^"]*")/i,
			/^(?:erDiagram\b)/i,
			/^(?:\{)/i,
			/^(?:#)/i,
			/^(?:#)/i,
			/^(?:,)/i,
			/^(?::::)/i,
			/^(?::)/i,
			/^(?:\s+)/i,
			/^(?:\b((?:PK)|(?:FK)|(?:UK))\b)/i,
			/^(?:([^\s]*)[~].*[~]([^\s]*))/i,
			/^(?:([\*A-Za-z_\u00C0-\uFFFF][A-Za-z0-9\-\_\[\]\(\)\u00C0-\uFFFF\*]*))/i,
			/^(?:"[^"]*")/i,
			/^(?:[\n]+)/i,
			/^(?:\})/i,
			/^(?:.)/i,
			/^(?:\[)/i,
			/^(?:\])/i,
			/^(?:style\b)/i,
			/^(?:[\n]+)/i,
			/^(?:\s+)/i,
			/^(?::)/i,
			/^(?:,)/i,
			/^(?:#)/i,
			/^(?:classDef\b)/i,
			/^(?:class\b)/i,
			/^(?:one or zero\b)/i,
			/^(?:one or more\b)/i,
			/^(?:one or many\b)/i,
			/^(?:1\+)/i,
			/^(?:\|o\b)/i,
			/^(?:zero or one\b)/i,
			/^(?:zero or more\b)/i,
			/^(?:zero or many\b)/i,
			/^(?:0\+)/i,
			/^(?:\}o\b)/i,
			/^(?:many\(0\))/i,
			/^(?:many\(1\))/i,
			/^(?:many\b)/i,
			/^(?:\}\|)/i,
			/^(?:one\b)/i,
			/^(?:only one\b)/i,
			/^(?:1\b)/i,
			/^(?:\|\|)/i,
			/^(?:o\|)/i,
			/^(?:o\{)/i,
			/^(?:\|\{)/i,
			/^(?:\s*u\b)/i,
			/^(?:\.\.)/i,
			/^(?:--)/i,
			/^(?:to\b)/i,
			/^(?:optionally to\b)/i,
			/^(?:\.-)/i,
			/^(?:-\.)/i,
			/^(?:([^\x00-\x7F]|\w|-|\*)+)/i,
			/^(?:;)/i,
			/^(?:([^\x00-\x7F]|\w|-|\*)+)/i,
			/^(?:[0-9])/i,
			/^(?:.)/i,
			/^(?:$)/i
		],
		conditions: {
			style: {
				rules: [
					34,
					35,
					36,
					37,
					38,
					69,
					70
				],
				inclusive: !1
			},
			acc_descr_multiline: {
				rules: [5, 6],
				inclusive: !1
			},
			acc_descr: {
				rules: [3],
				inclusive: !1
			},
			acc_title: {
				rules: [1],
				inclusive: !1
			},
			block: {
				rules: [
					23,
					24,
					25,
					26,
					27,
					28,
					29,
					30
				],
				inclusive: !1
			},
			INITIAL: {
				rules: [
					0,
					2,
					4,
					7,
					8,
					9,
					10,
					11,
					12,
					13,
					14,
					15,
					16,
					17,
					18,
					19,
					20,
					21,
					22,
					31,
					32,
					33,
					39,
					40,
					41,
					42,
					43,
					44,
					45,
					46,
					47,
					48,
					49,
					50,
					51,
					52,
					53,
					54,
					55,
					56,
					57,
					58,
					59,
					60,
					61,
					62,
					63,
					64,
					65,
					66,
					67,
					68,
					71,
					72,
					73,
					74
				],
				inclusive: !0
			}
		}
	}, h(H, "Parser"), H.prototype = V, V.Parser = H, new H();
}();
esM.parser = esM;
var esD = class {
	constructor() {
		this.entities = /* @__PURE__ */ new Map(), this.relationships = [], this.classes = /* @__PURE__ */ new Map(), this.direction = "TB", this.Cardinality = {
			ZERO_OR_ONE: "ZERO_OR_ONE",
			ZERO_OR_MORE: "ZERO_OR_MORE",
			ONE_OR_MORE: "ONE_OR_MORE",
			ONLY_ONE: "ONLY_ONE",
			MD_PARENT: "MD_PARENT"
		}, this.Identification = {
			NON_IDENTIFYING: "NON_IDENTIFYING",
			IDENTIFYING: "IDENTIFYING"
		}, this.setAccTitle = Da, this.getAccTitle = Ds, this.setAccDescription = Do, this.getAccDescription = Dl, this.setDiagramTitle = Dc, this.getDiagramTitle = Dh, this.getConfig = h(() => IA().er, "getConfig"), this.clear(), this.addEntity = this.addEntity.bind(this), this.addAttributes = this.addAttributes.bind(this), this.addRelationship = this.addRelationship.bind(this), this.setDirection = this.setDirection.bind(this), this.addCssStyles = this.addCssStyles.bind(this), this.addClass = this.addClass.bind(this), this.setClass = this.setClass.bind(this), this.setAccTitle = this.setAccTitle.bind(this), this.setAccDescription = this.setAccDescription.bind(this);
	}
	static {
		h(this, "ErDB");
	}
	addEntity(e, t = "") {
		return this.entities.has(e) ? !this.entities.get(e)?.alias && t && (this.entities.get(e).alias = t, wQ.info(`Add alias '${t}' to entity '${e}'`)) : (this.entities.set(e, {
			id: `entity-${e}-${this.entities.size}`,
			label: e,
			attributes: [],
			alias: t,
			shape: "erBox",
			look: IA().look ?? "default",
			cssClasses: "default",
			cssStyles: []
		}), wQ.info("Added new entity :", e)), this.entities.get(e);
	}
	getEntity(e) {
		return this.entities.get(e);
	}
	getEntities() {
		return this.entities;
	}
	getClasses() {
		return this.classes;
	}
	addAttributes(e, t) {
		let r = this.addEntity(e), i;
		for (i = t.length - 1; i >= 0; i--) t[i].keys || (t[i].keys = []), t[i].comment || (t[i].comment = ""), r.attributes.push(t[i]), wQ.debug("Added attribute ", t[i].name);
	}
	addRelationship(e, t, r, i) {
		let n = this.entities.get(e), a = this.entities.get(r);
		if (!n || !a) return;
		let s = {
			entityA: n.id,
			roleA: t,
			entityB: a.id,
			relSpec: i
		};
		this.relationships.push(s), wQ.debug("Added new relationship :", s);
	}
	getRelationships() {
		return this.relationships;
	}
	getDirection() {
		return this.direction;
	}
	setDirection(e) {
		this.direction = e;
	}
	getCompiledStyles(e) {
		let t = [];
		for (let r of e) {
			let e = this.classes.get(r);
			e?.styles && (t = [...t, ...e.styles ?? []].map((e) => e.trim())), e?.textStyles && (t = [...t, ...e.textStyles ?? []].map((e) => e.trim()));
		}
		return t;
	}
	addCssStyles(e, t) {
		for (let r of e) {
			let e = this.entities.get(r);
			if (!t || !e) return;
			for (let r of t) e.cssStyles.push(r);
		}
	}
	addClass(e, t) {
		e.forEach((e) => {
			let r = this.classes.get(e);
			void 0 === r && (r = {
				id: e,
				styles: [],
				textStyles: []
			}, this.classes.set(e, r)), t && t.forEach(function(e) {
				if (/color/.exec(e)) {
					let t = e.replace("fill", "bgFill");
					r.textStyles.push(t);
				}
				r.styles.push(e);
			});
		});
	}
	setClass(e, t) {
		for (let r of e) {
			let e = this.entities.get(r);
			if (e) for (let r of t) e.cssClasses += " " + r;
		}
	}
	clear() {
		this.entities = /* @__PURE__ */ new Map(), this.classes = /* @__PURE__ */ new Map(), this.relationships = [], Dn();
	}
	getData() {
		let e = [], t = [], r = IA();
		for (let t of this.entities.keys()) {
			let r = this.entities.get(t);
			r && (r.cssCompiledStyles = this.getCompiledStyles(r.cssClasses.split(" ")), e.push(r));
		}
		let i = 0;
		for (let e of this.relationships) {
			let n = {
				id: V7(e.entityA, e.entityB, {
					prefix: "id",
					counter: i++
				}),
				type: "normal",
				curve: "basis",
				start: e.entityA,
				end: e.entityB,
				label: e.roleA,
				labelpos: "c",
				thickness: "normal",
				classes: "relationshipLine",
				arrowTypeStart: e.relSpec.cardB.toLowerCase(),
				arrowTypeEnd: e.relSpec.cardA.toLowerCase(),
				pattern: "IDENTIFYING" == e.relSpec.relType ? "solid" : "dashed",
				look: r.look
			};
			t.push(n);
		}
		return {
			nodes: e,
			edges: t,
			other: {},
			config: r,
			direction: "TB"
		};
	}
}, esO = {};
d(esO, { draw: () => es$ });
var es$ = h(async function(e, t, r, i) {
	wQ.info("REF0:"), wQ.info("Drawing er diagram (unified)", t);
	let { securityLevel: n, er: a, layout: s } = IA(), o = i.db.getData(), l = JW(t, n);
	o.type = i.type, o.layoutAlgorithm = ein(s), o.config.flowchart.nodeSpacing = a?.nodeSpacing || 140, o.config.flowchart.rankSpacing = a?.rankSpacing || 80, o.direction = i.db.getDirection(), o.markers = [
		"only_one",
		"zero_or_one",
		"one_or_more",
		"zero_or_more"
	], o.diagramId = t, await eii(o, l), "elk" === o.layoutAlgorithm && l.select(".edges").lower();
	let h = l.selectAll("[id*=\"-background\"]");
	Array.from(h).length > 0 && h.each(function() {
		let e = _t(this), t = e.attr("id").replace("-background", ""), r = l.select(`#${CSS.escape(t)}`);
		if (!r.empty()) {
			let t = r.attr("transform");
			e.attr("transform", t);
		}
	}), V2(l, "erDiagramTitleText", a?.titleTopMargin ?? 25, i.db.getDiagramTitle()), JY(l, 8, "erDiagram", a?.useMaxWidth ?? !0);
}, "draw"), esP = h((e, t) => NQ(NJ(e, "r"), NJ(e, "g"), NJ(e, "b"), t), "fade"), esB = {
	parser: esM,
	get db() {
		return new esD();
	},
	renderer: esO,
	styles: h((e) => `
  .entityBox {
    fill: ${e.mainBkg};
    stroke: ${e.nodeBorder};
  }

  .relationshipLabelBox {
    fill: ${e.tertiaryColor};
    opacity: 0.7;
    background-color: ${e.tertiaryColor};
      rect {
        opacity: 0.5;
      }
  }

  .labelBkg {
    background-color: ${esP(e.tertiaryColor, .5)};
  }

  .edgeLabel .label {
    fill: ${e.nodeBorder};
    font-size: 14px;
  }

  .label {
    font-family: ${e.fontFamily};
    color: ${e.nodeTextColor || e.textColor};
  }

  .edge-pattern-dashed {
    stroke-dasharray: 8,8;
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon
  {
    fill: ${e.mainBkg};
    stroke: ${e.nodeBorder};
    stroke-width: 1px;
  }

  .relationshipLine {
    stroke: ${e.lineColor};
    stroke-width: 1;
    fill: none;
  }

  .marker {
    fill: none !important;
    stroke: ${e.lineColor} !important;
    stroke-width: 1;
  }
`, "getStyles")
};
function esF(e) {
	return typeof e > "u" || null === e;
}
function esz(e) {
	return "object" == typeof e && null !== e;
}
function esU(e, t) {
	var r, i = "";
	for (r = 0; r < t; r += 1) i += e;
	return i;
}
function esG(e) {
	return 0 === e && -Infinity == 1 / e;
}
h(esF, "isNothing"), h(esz, "isObject"), h(function(e) {
	return Array.isArray(e) ? e : esF(e) ? [] : [e];
}, "toArray"), h(function(e, t) {
	var r, i, n, a;
	if (t) for (a = Object.keys(t), r = 0, i = a.length; r < i; r += 1) e[n = a[r]] = t[n];
	return e;
}, "extend"), h(esU, "repeat"), h(esG, "isNegativeZero");
function esq(e, t) {
	var r = "", i = e.reason || "(unknown reason)";
	return e.mark ? (e.mark.name && (r += "in \"" + e.mark.name + "\" "), r += "(" + (e.mark.line + 1) + ":" + (e.mark.column + 1) + ")", !t && e.mark.snippet && (r += `

` + e.mark.snippet), i + " " + r) : i;
}
function esj(e, t) {
	Error.call(this), this.name = "YAMLException", this.reason = e, this.mark = t, this.message = esq(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = Error().stack || "";
}
function esW(e, t, r, i, n) {
	var a = "", s = "", o = Math.floor(n / 2) - 1;
	return i - t > o && (t = i - o + (a = " ... ").length), r - i > o && (r = i + o - (s = " ...").length), {
		str: a + e.slice(t, r).replace(/\t/g, "") + s,
		pos: i - t + a.length
	};
}
function esY(e, t) {
	return esU(" ", t - e.length) + e;
}
function esV(e, t) {
	if (t = Object.create(t || null), !e.buffer) return null;
	t.maxLength || (t.maxLength = 79), "number" != typeof t.indent && (t.indent = 1), "number" != typeof t.linesBefore && (t.linesBefore = 3), "number" != typeof t.linesAfter && (t.linesAfter = 2);
	for (var r, i = /\r?\n|\r|\0/g, n = [0], a = [], s = -1; r = i.exec(e.buffer);) a.push(r.index), n.push(r.index + r[0].length), e.position <= r.index && s < 0 && (s = n.length - 2);
	s < 0 && (s = n.length - 1);
	var o, l, h = "", u = Math.min(e.line + t.linesAfter, a.length).toString().length, d = t.maxLength - (t.indent + u + 3);
	for (o = 1; o <= t.linesBefore && !(s - o < 0); o++) l = esW(e.buffer, n[s - o], a[s - o], e.position - (n[s] - n[s - o]), d), h = esU(" ", t.indent) + esY((e.line - o + 1).toString(), u) + " | " + l.str + `
` + h;
	for (l = esW(e.buffer, n[s], a[s], e.position, d), h += esU(" ", t.indent) + esY((e.line + 1).toString(), u) + " | " + l.str + `
` + esU("-", t.indent + u + 3 + l.pos) + `^
`, o = 1; o <= t.linesAfter && !(s + o >= a.length); o++) l = esW(e.buffer, n[s + o], a[s + o], e.position - (n[s] - n[s + o]), d), h += esU(" ", t.indent) + esY((e.line + o + 1).toString(), u) + " | " + l.str + `
`;
	return h.replace(/\n$/, "");
}
h(esq, "formatError"), h(esj, "YAMLException$1"), esj.prototype = Object.create(Error.prototype), esj.prototype.constructor = esj, esj.prototype.toString = h(function(e) {
	return this.name + ": " + esq(this, e);
}, "toString"), h(esW, "getLine"), h(esY, "padStart"), h(esV, "makeSnippet");
var esH = [
	"kind",
	"multi",
	"resolve",
	"construct",
	"instanceOf",
	"predicate",
	"represent",
	"representName",
	"defaultStyle",
	"styleAliases"
], esX = [
	"scalar",
	"sequence",
	"mapping"
];
function esK(e) {
	var t = {};
	return null !== e && Object.keys(e).forEach(function(r) {
		e[r].forEach(function(e) {
			t[String(e)] = r;
		});
	}), t;
}
function esZ(e, t) {
	if (Object.keys(t = t || {}).forEach(function(t) {
		if (-1 === esH.indexOf(t)) throw new esj("Unknown option \"" + t + "\" is met in definition of \"" + e + "\" YAML type.");
	}), this.options = t, this.tag = e, this.kind = t.kind || null, this.resolve = t.resolve || function() {
		return !0;
	}, this.construct = t.construct || function(e) {
		return e;
	}, this.instanceOf = t.instanceOf || null, this.predicate = t.predicate || null, this.represent = t.represent || null, this.representName = t.representName || null, this.defaultStyle = t.defaultStyle || null, this.multi = t.multi || !1, this.styleAliases = esK(t.styleAliases || null), -1 === esX.indexOf(this.kind)) throw new esj("Unknown kind \"" + this.kind + "\" is specified for \"" + e + "\" YAML type.");
}
function esQ(e, t) {
	var r = [];
	return e[t].forEach(function(e) {
		var t = r.length;
		r.forEach(function(r, i) {
			r.tag === e.tag && r.kind === e.kind && r.multi === e.multi && (t = i);
		}), r[t] = e;
	}), r;
}
function esJ() {
	var e, t, r = {
		scalar: {},
		sequence: {},
		mapping: {},
		fallback: {},
		multi: {
			scalar: [],
			sequence: [],
			mapping: [],
			fallback: []
		}
	};
	function i(e) {
		e.multi ? (r.multi[e.kind].push(e), r.multi.fallback.push(e)) : r[e.kind][e.tag] = r.fallback[e.tag] = e;
	}
	for (h(i, "collectType"), e = 0, t = arguments.length; e < t; e += 1) arguments[e].forEach(i);
	return r;
}
function es0(e) {
	return this.extend(e);
}
h(esK, "compileStyleAliases"), h(esZ, "Type$1"), h(esQ, "compileList"), h(esJ, "compileMap"), h(es0, "Schema$1"), es0.prototype.extend = h(function(e) {
	var t = [], r = [];
	if (e instanceof esZ) r.push(e);
	else if (Array.isArray(e)) r = r.concat(e);
	else if (e && (Array.isArray(e.implicit) || Array.isArray(e.explicit))) e.implicit && (t = t.concat(e.implicit)), e.explicit && (r = r.concat(e.explicit));
	else throw new esj("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
	t.forEach(function(e) {
		if (!(e instanceof esZ)) throw new esj("Specified list of YAML types (or a single Type object) contains a non-Type object.");
		if (e.loadKind && "scalar" !== e.loadKind) throw new esj("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
		if (e.multi) throw new esj("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
	}), r.forEach(function(e) {
		if (!(e instanceof esZ)) throw new esj("Specified list of YAML types (or a single Type object) contains a non-Type object.");
	});
	var i = Object.create(es0.prototype);
	return i.implicit = (this.implicit || []).concat(t), i.explicit = (this.explicit || []).concat(r), i.compiledImplicit = esQ(i, "implicit"), i.compiledExplicit = esQ(i, "explicit"), i.compiledTypeMap = esJ(i.compiledImplicit, i.compiledExplicit), i;
}, "extend");
var es1 = new es0({ explicit: [
	new esZ("tag:yaml.org,2002:str", {
		kind: "scalar",
		construct: h(function(e) {
			return null !== e ? e : "";
		}, "construct")
	}),
	new esZ("tag:yaml.org,2002:seq", {
		kind: "sequence",
		construct: h(function(e) {
			return null !== e ? e : [];
		}, "construct")
	}),
	new esZ("tag:yaml.org,2002:map", {
		kind: "mapping",
		construct: h(function(e) {
			return null !== e ? e : {};
		}, "construct")
	})
] });
function es2(e) {
	if (null === e) return !0;
	var t = e.length;
	return 1 === t && "~" === e || 4 === t && ("null" === e || "Null" === e || "NULL" === e);
}
function es4() {
	return null;
}
function es5(e) {
	return null === e;
}
h(es2, "resolveYamlNull"), h(es4, "constructYamlNull"), h(es5, "isNull");
var es3 = new esZ("tag:yaml.org,2002:null", {
	kind: "scalar",
	resolve: es2,
	construct: es4,
	predicate: es5,
	represent: {
		canonical: h(function() {
			return "~";
		}, "canonical"),
		lowercase: h(function() {
			return "null";
		}, "lowercase"),
		uppercase: h(function() {
			return "NULL";
		}, "uppercase"),
		camelcase: h(function() {
			return "Null";
		}, "camelcase"),
		empty: h(function() {
			return "";
		}, "empty")
	},
	defaultStyle: "lowercase"
});
function es6(e) {
	if (null === e) return !1;
	var t = e.length;
	return 4 === t && ("true" === e || "True" === e || "TRUE" === e) || 5 === t && ("false" === e || "False" === e || "FALSE" === e);
}
function es7(e) {
	return "true" === e || "True" === e || "TRUE" === e;
}
function es8(e) {
	return "[object Boolean]" === Object.prototype.toString.call(e);
}
h(es6, "resolveYamlBoolean"), h(es7, "constructYamlBoolean"), h(es8, "isBoolean");
var es9 = new esZ("tag:yaml.org,2002:bool", {
	kind: "scalar",
	resolve: es6,
	construct: es7,
	predicate: es8,
	represent: {
		lowercase: h(function(e) {
			return e ? "true" : "false";
		}, "lowercase"),
		uppercase: h(function(e) {
			return e ? "TRUE" : "FALSE";
		}, "uppercase"),
		camelcase: h(function(e) {
			return e ? "True" : "False";
		}, "camelcase")
	},
	defaultStyle: "lowercase"
});
function eoe(e) {
	return 48 <= e && e <= 57 || 65 <= e && e <= 70 || 97 <= e && e <= 102;
}
function eot(e) {
	return 48 <= e && e <= 55;
}
function eor(e) {
	return 48 <= e && e <= 57;
}
function eoi(e) {
	if (null === e) return !1;
	var t, r = e.length, i = 0, n = !1;
	if (!r) return !1;
	if (("-" === (t = e[i]) || "+" === t) && (t = e[++i]), "0" === t) {
		if (i + 1 === r) return !0;
		if ("b" === (t = e[++i])) {
			for (i++; i < r; i++) if ("_" !== (t = e[i])) {
				if ("0" !== t && "1" !== t) return !1;
				n = !0;
			}
			return n && "_" !== t;
		}
		if ("x" === t) {
			for (i++; i < r; i++) if ("_" !== (t = e[i])) {
				if (!eoe(e.charCodeAt(i))) return !1;
				n = !0;
			}
			return n && "_" !== t;
		}
		if ("o" === t) {
			for (i++; i < r; i++) if ("_" !== (t = e[i])) {
				if (!eot(e.charCodeAt(i))) return !1;
				n = !0;
			}
			return n && "_" !== t;
		}
	}
	if ("_" === t) return !1;
	for (; i < r; i++) if ("_" !== (t = e[i])) {
		if (!eor(e.charCodeAt(i))) return !1;
		n = !0;
	}
	return !(!n || "_" === t);
}
function eon(e) {
	var t, r = e, i = 1;
	if (-1 !== r.indexOf("_") && (r = r.replace(/_/g, "")), ("-" === (t = r[0]) || "+" === t) && ("-" === t && (i = -1), t = (r = r.slice(1))[0]), "0" === r) return 0;
	if ("0" === t) {
		if ("b" === r[1]) return i * parseInt(r.slice(2), 2);
		if ("x" === r[1]) return i * parseInt(r.slice(2), 16);
		if ("o" === r[1]) return i * parseInt(r.slice(2), 8);
	}
	return i * parseInt(r, 10);
}
function eoa(e) {
	return "[object Number]" === Object.prototype.toString.call(e) && e % 1 == 0 && !esG(e);
}
h(eoe, "isHexCode"), h(eot, "isOctCode"), h(eor, "isDecCode"), h(eoi, "resolveYamlInteger"), h(eon, "constructYamlInteger"), h(eoa, "isInteger");
var eos = new esZ("tag:yaml.org,2002:int", {
	kind: "scalar",
	resolve: eoi,
	construct: eon,
	predicate: eoa,
	represent: {
		binary: h(function(e) {
			return e >= 0 ? "0b" + e.toString(2) : "-0b" + e.toString(2).slice(1);
		}, "binary"),
		octal: h(function(e) {
			return e >= 0 ? "0o" + e.toString(8) : "-0o" + e.toString(8).slice(1);
		}, "octal"),
		decimal: h(function(e) {
			return e.toString(10);
		}, "decimal"),
		hexadecimal: h(function(e) {
			return e >= 0 ? "0x" + e.toString(16).toUpperCase() : "-0x" + e.toString(16).toUpperCase().slice(1);
		}, "hexadecimal")
	},
	defaultStyle: "decimal",
	styleAliases: {
		binary: [2, "bin"],
		octal: [8, "oct"],
		decimal: [10, "dec"],
		hexadecimal: [16, "hex"]
	}
}), eoo = RegExp("^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
function eol(e) {
	return !(null === e || !eoo.test(e) || "_" === e[e.length - 1]);
}
function eoc(e) {
	var t, r;
	return r = "-" === (t = e.replace(/_/g, "").toLowerCase())[0] ? -1 : 1, "+-".indexOf(t[0]) >= 0 && (t = t.slice(1)), ".inf" === t ? 1 === r ? Infinity : -Infinity : ".nan" === t ? NaN : r * parseFloat(t, 10);
}
h(eol, "resolveYamlFloat"), h(eoc, "constructYamlFloat");
var eoh = /^[-+]?[0-9]+e/;
function eou(e, t) {
	var r;
	if (isNaN(e)) switch (t) {
		case "lowercase": return ".nan";
		case "uppercase": return ".NAN";
		case "camelcase": return ".NaN";
	}
	else if (Infinity === e) switch (t) {
		case "lowercase": return ".inf";
		case "uppercase": return ".INF";
		case "camelcase": return ".Inf";
	}
	else if (-Infinity === e) switch (t) {
		case "lowercase": return "-.inf";
		case "uppercase": return "-.INF";
		case "camelcase": return "-.Inf";
	}
	else if (esG(e)) return "-0.0";
	return r = e.toString(10), eoh.test(r) ? r.replace("e", ".e") : r;
}
function eod(e) {
	return "[object Number]" === Object.prototype.toString.call(e) && (e % 1 != 0 || esG(e));
}
h(eou, "representYamlFloat"), h(eod, "isFloat");
var eop = new esZ("tag:yaml.org,2002:float", {
	kind: "scalar",
	resolve: eol,
	construct: eoc,
	predicate: eod,
	represent: eou,
	defaultStyle: "lowercase"
}), eof = es1.extend({ implicit: [
	es3,
	es9,
	eos,
	eop
] }), eog = RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"), eom = RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
function eoy(e) {
	return null !== e && (null !== eog.exec(e) || null !== eom.exec(e));
}
function eov(e) {
	var t, r, i, n, a, s, o, l, h = 0, u = null;
	if (null === (t = eog.exec(e)) && (t = eom.exec(e)), null === t) throw Error("Date resolve error");
	if (r = +t[1], i = t[2] - 1, n = +t[3], !t[4]) return new Date(Date.UTC(r, i, n));
	if (a = +t[4], s = +t[5], o = +t[6], t[7]) {
		for (h = t[7].slice(0, 3); h.length < 3;) h += "0";
		h *= 1;
	}
	return t[9] && (u = (60 * t[10] + +(t[11] || 0)) * 6e4, "-" === t[9] && (u = -u)), l = new Date(Date.UTC(r, i, n, a, s, o, h)), u && l.setTime(l.getTime() - u), l;
}
function eox(e) {
	return e.toISOString();
}
h(eoy, "resolveYamlTimestamp"), h(eov, "constructYamlTimestamp"), h(eox, "representYamlTimestamp");
var eob = new esZ("tag:yaml.org,2002:timestamp", {
	kind: "scalar",
	resolve: eoy,
	construct: eov,
	instanceOf: Date,
	represent: eox
});
function eow(e) {
	return "<<" === e || null === e;
}
h(eow, "resolveYamlMerge");
var eok = new esZ("tag:yaml.org,2002:merge", {
	kind: "scalar",
	resolve: eow
}), eoT = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function eo_(e) {
	if (null === e) return !1;
	var t, r, i = 0, n = e.length;
	for (r = 0; r < n; r++) if (!((t = eoT.indexOf(e.charAt(r))) > 64)) {
		if (t < 0) return !1;
		i += 6;
	}
	return i % 8 == 0;
}
function eoE(e) {
	var t, r, i = e.replace(/[\r\n=]/g, ""), n = i.length, a = 0, s = [];
	for (t = 0; t < n; t++) t % 4 == 0 && t && (s.push(a >> 16 & 255), s.push(a >> 8 & 255), s.push(255 & a)), a = a << 6 | eoT.indexOf(i.charAt(t));
	return 0 == (r = n % 4 * 6) ? (s.push(a >> 16 & 255), s.push(a >> 8 & 255), s.push(255 & a)) : 18 === r ? (s.push(a >> 10 & 255), s.push(a >> 2 & 255)) : 12 === r && s.push(a >> 4 & 255), new Uint8Array(s);
}
function eoC(e) {
	var t, r, i = "", n = 0, a = e.length;
	for (t = 0; t < a; t++) t % 3 == 0 && t && (i += eoT[n >> 18 & 63], i += eoT[n >> 12 & 63], i += eoT[n >> 6 & 63], i += eoT[63 & n]), n = (n << 8) + e[t];
	return 0 == (r = a % 3) ? (i += eoT[n >> 18 & 63], i += eoT[n >> 12 & 63], i += eoT[n >> 6 & 63], i += eoT[63 & n]) : 2 === r ? (i += eoT[n >> 10 & 63], i += eoT[n >> 4 & 63], i += eoT[n << 2 & 63], i += eoT[64]) : 1 === r && (i += eoT[n >> 2 & 63], i += eoT[n << 4 & 63], i += eoT[64], i += eoT[64]), i;
}
function eoS(e) {
	return "[object Uint8Array]" === Object.prototype.toString.call(e);
}
h(eo_, "resolveYamlBinary"), h(eoE, "constructYamlBinary"), h(eoC, "representYamlBinary"), h(eoS, "isBinary");
var eoA = new esZ("tag:yaml.org,2002:binary", {
	kind: "scalar",
	resolve: eo_,
	construct: eoE,
	predicate: eoS,
	represent: eoC
}), eoL = Object.prototype.hasOwnProperty, eoR = Object.prototype.toString;
function eoN(e) {
	if (null === e) return !0;
	var t, r, i, n, a, s = [];
	for (t = 0, r = e.length; t < r; t += 1) {
		if (i = e[t], a = !1, "[object Object]" !== eoR.call(i)) return !1;
		for (n in i) if (eoL.call(i, n)) if (a) return !1;
		else a = !0;
		if (!a || -1 !== s.indexOf(n)) return !1;
		s.push(n);
	}
	return !0;
}
function eoI(e) {
	return null !== e ? e : [];
}
h(eoN, "resolveYamlOmap"), h(eoI, "constructYamlOmap");
var eoM = new esZ("tag:yaml.org,2002:omap", {
	kind: "sequence",
	resolve: eoN,
	construct: eoI
}), eoD = Object.prototype.toString;
function eoO(e) {
	var t, r, i, n, a;
	if (null === e) return !0;
	for (a = Array(e.length), t = 0, r = e.length; t < r; t += 1) {
		if (i = e[t], "[object Object]" !== eoD.call(i) || 1 !== (n = Object.keys(i)).length) return !1;
		a[t] = [n[0], i[n[0]]];
	}
	return !0;
}
function eo$(e) {
	var t, r, i, n, a;
	if (null === e) return [];
	for (a = Array(e.length), t = 0, r = e.length; t < r; t += 1) n = Object.keys(i = e[t]), a[t] = [n[0], i[n[0]]];
	return a;
}
h(eoO, "resolveYamlPairs"), h(eo$, "constructYamlPairs");
var eoP = new esZ("tag:yaml.org,2002:pairs", {
	kind: "sequence",
	resolve: eoO,
	construct: eo$
}), eoB = Object.prototype.hasOwnProperty;
function eoF(e) {
	var t;
	if (null === e) return !0;
	for (t in e) if (eoB.call(e, t) && null !== e[t]) return !1;
	return !0;
}
function eoz(e) {
	return null !== e ? e : {};
}
h(eoF, "resolveYamlSet"), h(eoz, "constructYamlSet");
var eoU = new esZ("tag:yaml.org,2002:set", {
	kind: "mapping",
	resolve: eoF,
	construct: eoz
}), eoG = eof.extend({
	implicit: [eob, eok],
	explicit: [
		eoA,
		eoM,
		eoP,
		eoU
	]
}), eoq = Object.prototype.hasOwnProperty, eoj = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, eoW = /[\x85\u2028\u2029]/, eoY = /[,\[\]\{\}]/, eoV = /^(?:!|!!|![a-z\-]+!)$/i, eoH = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function eoX(e) {
	return Object.prototype.toString.call(e);
}
function eoK(e) {
	return 10 === e || 13 === e;
}
function eoZ(e) {
	return 9 === e || 32 === e;
}
function eoQ(e) {
	return 9 === e || 32 === e || 10 === e || 13 === e;
}
function eoJ(e) {
	return 44 === e || 91 === e || 93 === e || 123 === e || 125 === e;
}
function eo0(e) {
	var t;
	return 48 <= e && e <= 57 ? e - 48 : 97 <= (t = 32 | e) && t <= 102 ? t - 97 + 10 : -1;
}
function eo1(e) {
	return 120 === e ? 2 : 117 === e ? 4 : 8 * (85 === e);
}
function eo2(e) {
	return 48 <= e && e <= 57 ? e - 48 : -1;
}
function eo4(e) {
	return 48 === e ? "\0" : 97 === e ? "\x07" : 98 === e ? "\b" : 116 === e || 9 === e ? "	" : 110 === e ? `
` : 118 === e ? "\v" : 102 === e ? "\f" : 114 === e ? "\r" : 101 === e ? "\x1B" : 32 === e ? " " : 34 === e ? "\"" : 47 === e ? "/" : 92 === e ? "\\" : 78 === e ? "" : 95 === e ? "\xA0" : 76 === e ? "\u2028" : 80 === e ? "\u2029" : "";
}
function eo5(e) {
	return e <= 65535 ? String.fromCharCode(e) : String.fromCharCode((e - 65536 >> 10) + 55296, (e - 65536 & 1023) + 56320);
}
h(eoX, "_class"), h(eoK, "is_EOL"), h(eoZ, "is_WHITE_SPACE"), h(eoQ, "is_WS_OR_EOL"), h(eoJ, "is_FLOW_INDICATOR"), h(eo0, "fromHexCode"), h(eo1, "escapedHexLen"), h(eo2, "fromDecimalCode"), h(eo4, "simpleEscapeSequence"), h(eo5, "charFromCodepoint");
var eo3 = Array(256), eo6 = Array(256);
for (ech = 0; ech < 256; ech++) eo3[ech] = +!!eo4(ech), eo6[ech] = eo4(ech);
function eo7(e, t) {
	this.input = e, this.filename = t.filename || null, this.schema = t.schema || eoG, this.onWarning = t.onWarning || null, this.legacy = t.legacy || !1, this.json = t.json || !1, this.listener = t.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = e.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
}
function eo8(e, t) {
	var r = {
		name: e.filename,
		buffer: e.input.slice(0, -1),
		position: e.position,
		line: e.line,
		column: e.position - e.lineStart
	};
	return r.snippet = esV(r), new esj(t, r);
}
function eo9(e, t) {
	throw eo8(e, t);
}
function ele(e, t) {
	e.onWarning && e.onWarning.call(null, eo8(e, t));
}
h(eo7, "State$1"), h(eo8, "generateError"), h(eo9, "throwError"), h(ele, "throwWarning");
var elt = {
	YAML: h(function(e, t, r) {
		var i, n, a;
		null !== e.version && eo9(e, "duplication of %YAML directive"), 1 !== r.length && eo9(e, "YAML directive accepts exactly one argument"), null === (i = /^([0-9]+)\.([0-9]+)$/.exec(r[0])) && eo9(e, "ill-formed argument of the YAML directive"), n = parseInt(i[1], 10), a = parseInt(i[2], 10), 1 !== n && eo9(e, "unacceptable YAML version of the document"), e.version = r[0], e.checkLineBreaks = a < 2, 1 !== a && 2 !== a && ele(e, "unsupported YAML version of the document");
	}, "handleYamlDirective"),
	TAG: h(function(e, t, r) {
		var i, n;
		2 !== r.length && eo9(e, "TAG directive accepts exactly two arguments"), i = r[0], n = r[1], eoV.test(i) || eo9(e, "ill-formed tag handle (first argument) of the TAG directive"), eoq.call(e.tagMap, i) && eo9(e, "there is a previously declared suffix for \"" + i + "\" tag handle"), eoH.test(n) || eo9(e, "ill-formed tag prefix (second argument) of the TAG directive");
		try {
			n = decodeURIComponent(n);
		} catch {
			eo9(e, "tag prefix is malformed: " + n);
		}
		e.tagMap[i] = n;
	}, "handleTagDirective")
};
function elr(e, t, r, i) {
	var n, a, s, o;
	if (t < r) {
		if (o = e.input.slice(t, r), i) for (n = 0, a = o.length; n < a; n += 1) 9 === (s = o.charCodeAt(n)) || 32 <= s && s <= 1114111 || eo9(e, "expected valid JSON character");
		else eoj.test(o) && eo9(e, "the stream contains non-printable characters");
		e.result += o;
	}
}
function eli(e, t, r, i) {
	var n, a, s, o;
	for (esz(r) || eo9(e, "cannot merge mappings; the provided source object is unacceptable"), n = Object.keys(r), s = 0, o = n.length; s < o; s += 1) a = n[s], eoq.call(t, a) || (t[a] = r[a], i[a] = !0);
}
function eln(e, t, r, i, n, a, s, o, l) {
	var h, u;
	if (Array.isArray(n)) for (n = Array.prototype.slice.call(n), h = 0, u = n.length; h < u; h += 1) Array.isArray(n[h]) && eo9(e, "nested arrays are not supported inside keys"), "object" == typeof n && "[object Object]" === eoX(n[h]) && (n[h] = "[object Object]");
	if ("object" == typeof n && "[object Object]" === eoX(n) && (n = "[object Object]"), n = String(n), null === t && (t = {}), "tag:yaml.org,2002:merge" === i) if (Array.isArray(a)) for (h = 0, u = a.length; h < u; h += 1) eli(e, t, a[h], r);
	else eli(e, t, a, r);
	else !e.json && !eoq.call(r, n) && eoq.call(t, n) && (e.line = s || e.line, e.lineStart = o || e.lineStart, e.position = l || e.position, eo9(e, "duplicated mapping key")), "__proto__" === n ? Object.defineProperty(t, n, {
		configurable: !0,
		enumerable: !0,
		writable: !0,
		value: a
	}) : t[n] = a, delete r[n];
	return t;
}
function ela(e) {
	var t = e.input.charCodeAt(e.position);
	10 === t ? e.position++ : 13 === t ? (e.position++, 10 === e.input.charCodeAt(e.position) && e.position++) : eo9(e, "a line break is expected"), e.line += 1, e.lineStart = e.position, e.firstTabInLine = -1;
}
function els(e, t, r) {
	for (var i = 0, n = e.input.charCodeAt(e.position); 0 !== n;) {
		for (; eoZ(n);) 9 === n && -1 === e.firstTabInLine && (e.firstTabInLine = e.position), n = e.input.charCodeAt(++e.position);
		if (t && 35 === n) do
			n = e.input.charCodeAt(++e.position);
		while (10 !== n && 13 !== n && 0 !== n);
		if (eoK(n)) for (ela(e), n = e.input.charCodeAt(e.position), i++, e.lineIndent = 0; 32 === n;) e.lineIndent++, n = e.input.charCodeAt(++e.position);
		else break;
	}
	return -1 !== r && 0 !== i && e.lineIndent < r && ele(e, "deficient indentation"), i;
}
function elo(e) {
	var t, r = e.position;
	return !!((45 === (t = e.input.charCodeAt(r)) || 46 === t) && t === e.input.charCodeAt(r + 1) && t === e.input.charCodeAt(r + 2) && (r += 3, 0 === (t = e.input.charCodeAt(r)) || eoQ(t)));
}
function ell(e, t) {
	1 === t ? e.result += " " : t > 1 && (e.result += esU(`
`, t - 1));
}
function elc(e, t, r) {
	var i, n, a, s, o, l, h, u, d = e.kind, p = e.result;
	if (eoQ(u = e.input.charCodeAt(e.position)) || eoJ(u) || 35 === u || 38 === u || 42 === u || 33 === u || 124 === u || 62 === u || 39 === u || 34 === u || 37 === u || 64 === u || 96 === u || (63 === u || 45 === u) && (eoQ(i = e.input.charCodeAt(e.position + 1)) || r && eoJ(i))) return !1;
	for (e.kind = "scalar", e.result = "", n = a = e.position, s = !1; 0 !== u;) {
		if (58 === u) {
			if (eoQ(i = e.input.charCodeAt(e.position + 1)) || r && eoJ(i)) break;
		} else if (35 === u) {
			if (eoQ(e.input.charCodeAt(e.position - 1))) break;
		} else {
			if (e.position === e.lineStart && elo(e) || r && eoJ(u)) break;
			if (eoK(u)) if (o = e.line, l = e.lineStart, h = e.lineIndent, els(e, !1, -1), e.lineIndent >= t) {
				s = !0, u = e.input.charCodeAt(e.position);
				continue;
			} else {
				e.position = a, e.line = o, e.lineStart = l, e.lineIndent = h;
				break;
			}
		}
		s && (elr(e, n, a, !1), ell(e, e.line - o), n = a = e.position, s = !1), eoZ(u) || (a = e.position + 1), u = e.input.charCodeAt(++e.position);
	}
	return elr(e, n, a, !1), !!e.result || (e.kind = d, e.result = p, !1);
}
function elh(e, t) {
	var r, i, n;
	if (39 !== (r = e.input.charCodeAt(e.position))) return !1;
	for (e.kind = "scalar", e.result = "", e.position++, i = n = e.position; 0 !== (r = e.input.charCodeAt(e.position));) if (39 === r) if (elr(e, i, e.position, !0), 39 !== (r = e.input.charCodeAt(++e.position))) return !0;
	else i = e.position, e.position++, n = e.position;
	else eoK(r) ? (elr(e, i, n, !0), ell(e, els(e, !1, t)), i = n = e.position) : e.position === e.lineStart && elo(e) ? eo9(e, "unexpected end of the document within a single quoted scalar") : (e.position++, n = e.position);
	eo9(e, "unexpected end of the stream within a single quoted scalar");
}
function elu(e, t) {
	var r, i, n, a, s, o;
	if (34 !== (o = e.input.charCodeAt(e.position))) return !1;
	for (e.kind = "scalar", e.result = "", e.position++, r = i = e.position; 0 !== (o = e.input.charCodeAt(e.position));) {
		if (34 === o) return elr(e, r, e.position, !0), e.position++, !0;
		if (92 === o) {
			if (elr(e, r, e.position, !0), eoK(o = e.input.charCodeAt(++e.position))) els(e, !1, t);
			else if (o < 256 && eo3[o]) e.result += eo6[o], e.position++;
			else if ((s = eo1(o)) > 0) {
				for (n = s, a = 0; n > 0; n--) (s = eo0(o = e.input.charCodeAt(++e.position))) >= 0 ? a = (a << 4) + s : eo9(e, "expected hexadecimal character");
				e.result += eo5(a), e.position++;
			} else eo9(e, "unknown escape sequence");
			r = i = e.position;
		} else eoK(o) ? (elr(e, r, i, !0), ell(e, els(e, !1, t)), r = i = e.position) : e.position === e.lineStart && elo(e) ? eo9(e, "unexpected end of the document within a double quoted scalar") : (e.position++, i = e.position);
	}
	eo9(e, "unexpected end of the stream within a double quoted scalar");
}
function eld(e, t) {
	var r, i, n, a, s, o, l, h, u, d, p, f, g = !0, m = e.tag, y = e.anchor, v = Object.create(null);
	if (91 === (f = e.input.charCodeAt(e.position))) s = 93, h = !1, a = [];
	else {
		if (123 !== f) return !1;
		s = 125, h = !0, a = {};
	}
	for (null !== e.anchor && (e.anchorMap[e.anchor] = a), f = e.input.charCodeAt(++e.position); 0 !== f;) {
		if (els(e, !0, t), (f = e.input.charCodeAt(e.position)) === s) return e.position++, e.tag = m, e.anchor = y, e.kind = h ? "mapping" : "sequence", e.result = a, !0;
		g ? 44 === f && eo9(e, "expected the node content, but found ','") : eo9(e, "missed comma between flow collection entries"), d = u = p = null, o = l = !1, 63 === f && eoQ(e.input.charCodeAt(e.position + 1)) && (o = l = !0, e.position++, els(e, !0, t)), r = e.line, i = e.lineStart, n = e.position, elx(e, t, 1, !1, !0), d = e.tag, u = e.result, els(e, !0, t), f = e.input.charCodeAt(e.position), (l || e.line === r) && 58 === f && (o = !0, f = e.input.charCodeAt(++e.position), els(e, !0, t), elx(e, t, 1, !1, !0), p = e.result), h ? eln(e, a, v, d, u, p, r, i, n) : o ? a.push(eln(e, null, v, d, u, p, r, i, n)) : a.push(u), els(e, !0, t), 44 === (f = e.input.charCodeAt(e.position)) ? (g = !0, f = e.input.charCodeAt(++e.position)) : g = !1;
	}
	eo9(e, "unexpected end of the stream within a flow collection");
}
function elp(e, t) {
	var r, i, n, a, s = 1, o = !1, l = !1, h = t, u = 0, d = !1;
	if (124 === (a = e.input.charCodeAt(e.position))) i = !1;
	else {
		if (62 !== a) return !1;
		i = !0;
	}
	for (e.kind = "scalar", e.result = ""; 0 !== a;) if (43 === (a = e.input.charCodeAt(++e.position)) || 45 === a) 1 === s ? s = 43 === a ? 3 : 2 : eo9(e, "repeat of a chomping mode identifier");
	else if ((n = eo2(a)) >= 0) 0 === n ? eo9(e, "bad explicit indentation width of a block scalar; it cannot be less than one") : l ? eo9(e, "repeat of an indentation width identifier") : (h = t + n - 1, l = !0);
	else break;
	if (eoZ(a)) {
		do
			a = e.input.charCodeAt(++e.position);
		while (eoZ(a));
		if (35 === a) do
			a = e.input.charCodeAt(++e.position);
		while (!eoK(a) && 0 !== a);
	}
	for (; 0 !== a;) {
		for (ela(e), e.lineIndent = 0, a = e.input.charCodeAt(e.position); (!l || e.lineIndent < h) && 32 === a;) e.lineIndent++, a = e.input.charCodeAt(++e.position);
		if (!l && e.lineIndent > h && (h = e.lineIndent), eoK(a)) {
			u++;
			continue;
		}
		if (e.lineIndent < h) {
			3 === s ? e.result += esU(`
`, o ? 1 + u : u) : 1 === s && o && (e.result += `
`);
			break;
		}
		for (i ? eoZ(a) ? (d = !0, e.result += esU(`
`, o ? 1 + u : u)) : d ? (d = !1, e.result += esU(`
`, u + 1)) : 0 === u ? o && (e.result += " ") : e.result += esU(`
`, u) : e.result += esU(`
`, o ? 1 + u : u), o = !0, l = !0, u = 0, r = e.position; !eoK(a) && 0 !== a;) a = e.input.charCodeAt(++e.position);
		elr(e, r, e.position, !1);
	}
	return !0;
}
function elf(e, t) {
	var r, i, n = e.tag, a = e.anchor, s = [], o = !1;
	if (-1 !== e.firstTabInLine) return !1;
	for (null !== e.anchor && (e.anchorMap[e.anchor] = s), i = e.input.charCodeAt(e.position); 0 !== i && (-1 !== e.firstTabInLine && (e.position = e.firstTabInLine, eo9(e, "tab characters must not be used in indentation")), !(45 !== i || !eoQ(e.input.charCodeAt(e.position + 1))));) {
		if (o = !0, e.position++, els(e, !0, -1) && e.lineIndent <= t) {
			s.push(null), i = e.input.charCodeAt(e.position);
			continue;
		}
		if (r = e.line, elx(e, t, 3, !1, !0), s.push(e.result), els(e, !0, -1), i = e.input.charCodeAt(e.position), (e.line === r || e.lineIndent > t) && 0 !== i) eo9(e, "bad indentation of a sequence entry");
		else if (e.lineIndent < t) break;
	}
	return !!o && (e.tag = n, e.anchor = a, e.kind = "sequence", e.result = s, !0);
}
function elg(e, t, r) {
	var i, n, a, s, o, l, h, u = e.tag, d = e.anchor, p = {}, f = Object.create(null), g = null, m = null, y = null, v = !1, x = !1;
	if (-1 !== e.firstTabInLine) return !1;
	for (null !== e.anchor && (e.anchorMap[e.anchor] = p), h = e.input.charCodeAt(e.position); 0 !== h;) {
		if (v || -1 === e.firstTabInLine || (e.position = e.firstTabInLine, eo9(e, "tab characters must not be used in indentation")), i = e.input.charCodeAt(e.position + 1), a = e.line, (63 === h || 58 === h) && eoQ(i)) 63 === h ? (v && (eln(e, p, f, g, m, null, s, o, l), g = m = y = null), x = !0, v = !0, n = !0) : v ? (v = !1, n = !0) : eo9(e, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), e.position += 1, h = i;
		else {
			if (s = e.line, o = e.lineStart, l = e.position, !elx(e, r, 2, !1, !0)) break;
			if (e.line === a) {
				for (h = e.input.charCodeAt(e.position); eoZ(h);) h = e.input.charCodeAt(++e.position);
				if (58 === h) eoQ(h = e.input.charCodeAt(++e.position)) || eo9(e, "a whitespace character is expected after the key-value separator within a block mapping"), v && (eln(e, p, f, g, m, null, s, o, l), g = m = y = null), x = !0, v = !1, n = !1, g = e.tag, m = e.result;
				else {
					if (!x) return e.tag = u, e.anchor = d, !0;
					eo9(e, "can not read an implicit mapping pair; a colon is missed");
				}
			} else {
				if (!x) return e.tag = u, e.anchor = d, !0;
				eo9(e, "can not read a block mapping entry; a multiline key may not be an implicit key");
			}
		}
		if ((e.line === a || e.lineIndent > t) && (v && (s = e.line, o = e.lineStart, l = e.position), elx(e, t, 4, !0, n) && (v ? m = e.result : y = e.result), v || (eln(e, p, f, g, m, y, s, o, l), g = m = y = null), els(e, !0, -1), h = e.input.charCodeAt(e.position)), (e.line === a || e.lineIndent > t) && 0 !== h) eo9(e, "bad indentation of a mapping entry");
		else if (e.lineIndent < t) break;
	}
	return v && eln(e, p, f, g, m, null, s, o, l), x && (e.tag = u, e.anchor = d, e.kind = "mapping", e.result = p), x;
}
function elm(e) {
	var t, r, i, n, a = !1, s = !1;
	if (33 !== (n = e.input.charCodeAt(e.position))) return !1;
	if (null !== e.tag && eo9(e, "duplication of a tag property"), 60 === (n = e.input.charCodeAt(++e.position)) ? (a = !0, n = e.input.charCodeAt(++e.position)) : 33 === n ? (s = !0, r = "!!", n = e.input.charCodeAt(++e.position)) : r = "!", t = e.position, a) {
		do
			n = e.input.charCodeAt(++e.position);
		while (0 !== n && 62 !== n);
		e.position < e.length ? (i = e.input.slice(t, e.position), n = e.input.charCodeAt(++e.position)) : eo9(e, "unexpected end of the stream within a verbatim tag");
	} else {
		for (; 0 !== n && !eoQ(n);) 33 === n && (s ? eo9(e, "tag suffix cannot contain exclamation marks") : (r = e.input.slice(t - 1, e.position + 1), eoV.test(r) || eo9(e, "named tag handle cannot contain such characters"), s = !0, t = e.position + 1)), n = e.input.charCodeAt(++e.position);
		i = e.input.slice(t, e.position), eoY.test(i) && eo9(e, "tag suffix cannot contain flow indicator characters");
	}
	i && !eoH.test(i) && eo9(e, "tag name cannot contain such characters: " + i);
	try {
		i = decodeURIComponent(i);
	} catch {
		eo9(e, "tag name is malformed: " + i);
	}
	return a ? e.tag = i : eoq.call(e.tagMap, r) ? e.tag = e.tagMap[r] + i : "!" === r ? e.tag = "!" + i : "!!" === r ? e.tag = "tag:yaml.org,2002:" + i : eo9(e, "undeclared tag handle \"" + r + "\""), !0;
}
function ely(e) {
	var t, r;
	if (38 !== (r = e.input.charCodeAt(e.position))) return !1;
	for (null !== e.anchor && eo9(e, "duplication of an anchor property"), r = e.input.charCodeAt(++e.position), t = e.position; 0 !== r && !eoQ(r) && !eoJ(r);) r = e.input.charCodeAt(++e.position);
	return e.position === t && eo9(e, "name of an anchor node must contain at least one character"), e.anchor = e.input.slice(t, e.position), !0;
}
function elv(e) {
	var t, r, i;
	if (42 !== (i = e.input.charCodeAt(e.position))) return !1;
	for (i = e.input.charCodeAt(++e.position), t = e.position; 0 !== i && !eoQ(i) && !eoJ(i);) i = e.input.charCodeAt(++e.position);
	return e.position === t && eo9(e, "name of an alias node must contain at least one character"), r = e.input.slice(t, e.position), eoq.call(e.anchorMap, r) || eo9(e, "unidentified alias \"" + r + "\""), e.result = e.anchorMap[r], els(e, !0, -1), !0;
}
function elx(e, t, r, i, n) {
	var a, s, o, l, h, u, d, p, f, g = 1, m = !1, y = !1;
	if (null !== e.listener && e.listener("open", e), e.tag = null, e.anchor = null, e.kind = null, e.result = null, a = s = o = 4 === r || 3 === r, i && els(e, !0, -1) && (m = !0, e.lineIndent > t ? g = 1 : e.lineIndent === t ? g = 0 : e.lineIndent < t && (g = -1)), 1 === g) for (; elm(e) || ely(e);) els(e, !0, -1) ? (m = !0, o = a, e.lineIndent > t ? g = 1 : e.lineIndent === t ? g = 0 : e.lineIndent < t && (g = -1)) : o = !1;
	if (o && (o = m || n), (1 === g || 4 === r) && (p = 1 === r || 2 === r ? t : t + 1, f = e.position - e.lineStart, 1 === g ? o && (elf(e, f) || elg(e, f, p)) || eld(e, p) ? y = !0 : (s && elp(e, p) || elh(e, p) || elu(e, p) ? y = !0 : elv(e) ? (y = !0, (null !== e.tag || null !== e.anchor) && eo9(e, "alias node should not have any properties")) : elc(e, p, 1 === r) && (y = !0, null === e.tag && (e.tag = "?")), null !== e.anchor && (e.anchorMap[e.anchor] = e.result)) : 0 === g && (y = o && elf(e, f))), null === e.tag) null !== e.anchor && (e.anchorMap[e.anchor] = e.result);
	else if ("?" === e.tag) {
		for (null !== e.result && "scalar" !== e.kind && eo9(e, "unacceptable node kind for !<?> tag; it should be \"scalar\", not \"" + e.kind + "\""), l = 0, h = e.implicitTypes.length; l < h; l += 1) if ((d = e.implicitTypes[l]).resolve(e.result)) {
			e.result = d.construct(e.result), e.tag = d.tag, null !== e.anchor && (e.anchorMap[e.anchor] = e.result);
			break;
		}
	} else if ("!" !== e.tag) {
		if (eoq.call(e.typeMap[e.kind || "fallback"], e.tag)) d = e.typeMap[e.kind || "fallback"][e.tag];
		else for (d = null, u = e.typeMap.multi[e.kind || "fallback"], l = 0, h = u.length; l < h; l += 1) if (e.tag.slice(0, u[l].tag.length) === u[l].tag) {
			d = u[l];
			break;
		}
		d || eo9(e, "unknown tag !<" + e.tag + ">"), null !== e.result && d.kind !== e.kind && eo9(e, "unacceptable node kind for !<" + e.tag + "> tag; it should be \"" + d.kind + "\", not \"" + e.kind + "\""), d.resolve(e.result, e.tag) ? (e.result = d.construct(e.result, e.tag), null !== e.anchor && (e.anchorMap[e.anchor] = e.result)) : eo9(e, "cannot resolve a node with !<" + e.tag + "> explicit tag");
	}
	return null !== e.listener && e.listener("close", e), null !== e.tag || null !== e.anchor || y;
}
function elb(e) {
	var t, r, i, n, a = e.position, s = !1;
	for (e.version = null, e.checkLineBreaks = e.legacy, e.tagMap = Object.create(null), e.anchorMap = Object.create(null); 0 !== (n = e.input.charCodeAt(e.position)) && (els(e, !0, -1), n = e.input.charCodeAt(e.position), !(e.lineIndent > 0 || 37 !== n));) {
		for (s = !0, n = e.input.charCodeAt(++e.position), t = e.position; 0 !== n && !eoQ(n);) n = e.input.charCodeAt(++e.position);
		for (r = e.input.slice(t, e.position), i = [], r.length < 1 && eo9(e, "directive name must not be less than one character in length"); 0 !== n;) {
			for (; eoZ(n);) n = e.input.charCodeAt(++e.position);
			if (35 === n) {
				do
					n = e.input.charCodeAt(++e.position);
				while (0 !== n && !eoK(n));
				break;
			}
			if (eoK(n)) break;
			for (t = e.position; 0 !== n && !eoQ(n);) n = e.input.charCodeAt(++e.position);
			i.push(e.input.slice(t, e.position));
		}
		0 !== n && ela(e), eoq.call(elt, r) ? elt[r](e, r, i) : ele(e, "unknown document directive \"" + r + "\"");
	}
	if (els(e, !0, -1), 0 === e.lineIndent && 45 === e.input.charCodeAt(e.position) && 45 === e.input.charCodeAt(e.position + 1) && 45 === e.input.charCodeAt(e.position + 2) ? (e.position += 3, els(e, !0, -1)) : s && eo9(e, "directives end mark is expected"), elx(e, e.lineIndent - 1, 4, !1, !0), els(e, !0, -1), e.checkLineBreaks && eoW.test(e.input.slice(a, e.position)) && ele(e, "non-ASCII line breaks are interpreted as content"), e.documents.push(e.result), e.position === e.lineStart && elo(e)) {
		46 === e.input.charCodeAt(e.position) && (e.position += 3, els(e, !0, -1));
		return;
	}
	e.position < e.length - 1 && eo9(e, "end of the stream or a document separator is expected");
}
function elw(e, t) {
	e = String(e), t = t || {}, 0 !== e.length && (10 !== e.charCodeAt(e.length - 1) && 13 !== e.charCodeAt(e.length - 1) && (e += `
`), 65279 === e.charCodeAt(0) && (e = e.slice(1)));
	var r = new eo7(e, t), i = e.indexOf("\0");
	for (-1 !== i && (r.position = i, eo9(r, "null byte is not allowed in input")), r.input += "\0"; 32 === r.input.charCodeAt(r.position);) r.lineIndent += 1, r.position += 1;
	for (; r.position < r.length - 1;) elb(r);
	return r.documents;
}
function elk(e, t, r) {
	null !== t && "object" == typeof t && typeof r > "u" && (r = t, t = null);
	var i = elw(e, r);
	if ("function" != typeof t) return i;
	for (var n = 0, a = i.length; n < a; n += 1) t(i[n]);
}
function elT(e, t) {
	var r = elw(e, t);
	if (0 !== r.length) {
		if (1 === r.length) return r[0];
		throw new esj("expected a single document in the stream, but found more");
	}
}
h(elr, "captureSegment"), h(eli, "mergeMappings"), h(eln, "storeMappingPair"), h(ela, "readLineBreak"), h(els, "skipSeparationSpace"), h(elo, "testDocumentSeparator"), h(ell, "writeFoldedLines"), h(elc, "readPlainScalar"), h(elh, "readSingleQuotedScalar"), h(elu, "readDoubleQuotedScalar"), h(eld, "readFlowCollection"), h(elp, "readBlockScalar"), h(elf, "readBlockSequence"), h(elg, "readBlockMapping"), h(elm, "readTagProperty"), h(ely, "readAnchorProperty"), h(elv, "readAlias"), h(elx, "composeNode"), h(elb, "readDocument"), h(elw, "loadDocuments"), h(elk, "loadAll$1"), h(elT, "load$1");
var el_ = Object.prototype.toString, elE = Object.prototype.hasOwnProperty, elC = {};
elC[0] = "\\0", elC[7] = "\\a", elC[8] = "\\b", elC[9] = "\\t", elC[10] = "\\n", elC[11] = "\\v", elC[12] = "\\f", elC[13] = "\\r", elC[27] = "\\e", elC[34] = "\\\"", elC[92] = "\\\\", elC[133] = "\\N", elC[160] = "\\_", elC[8232] = "\\L", elC[8233] = "\\P";
var elS = [
	"y",
	"Y",
	"yes",
	"Yes",
	"YES",
	"on",
	"On",
	"ON",
	"n",
	"N",
	"no",
	"No",
	"NO",
	"off",
	"Off",
	"OFF"
], elA = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function elL(e, t) {
	var r, i, n, a, s, o, l;
	if (null === t) return {};
	for (r = {}, i = Object.keys(t), n = 0, a = i.length; n < a; n += 1) o = String(t[s = i[n]]), "!!" === s.slice(0, 2) && (s = "tag:yaml.org,2002:" + s.slice(2)), (l = e.compiledTypeMap.fallback[s]) && elE.call(l.styleAliases, o) && (o = l.styleAliases[o]), r[s] = o;
	return r;
}
function elR(e) {
	var t, r, i;
	if (t = e.toString(16).toUpperCase(), e <= 255) r = "x", i = 2;
	else if (e <= 65535) r = "u", i = 4;
	else if (e <= 4294967295) r = "U", i = 8;
	else throw new esj("code point within a string may not be greater than 0xFFFFFFFF");
	return "\\" + r + esU("0", i - t.length) + t;
}
function elN(e) {
	this.schema = e.schema || eoG, this.indent = Math.max(1, e.indent || 2), this.noArrayIndent = e.noArrayIndent || !1, this.skipInvalid = e.skipInvalid || !1, this.flowLevel = esF(e.flowLevel) ? -1 : e.flowLevel, this.styleMap = elL(this.schema, e.styles || null), this.sortKeys = e.sortKeys || !1, this.lineWidth = e.lineWidth || 80, this.noRefs = e.noRefs || !1, this.noCompatMode = e.noCompatMode || !1, this.condenseFlow = e.condenseFlow || !1, this.quotingType = "\"" === e.quotingType ? 2 : 1, this.forceQuotes = e.forceQuotes || !1, this.replacer = "function" == typeof e.replacer ? e.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
}
function elI(e, t) {
	for (var r, i = esU(" ", t), n = 0, a = -1, s = "", o = e.length; n < o;) -1 === (a = e.indexOf(`
`, n)) ? (r = e.slice(n), n = o) : (r = e.slice(n, a + 1), n = a + 1), r.length && r !== `
` && (s += i), s += r;
	return s;
}
function elM(e, t) {
	return `
` + esU(" ", e.indent * t);
}
function elD(e, t) {
	var r, i;
	for (r = 0, i = e.implicitTypes.length; r < i; r += 1) if (e.implicitTypes[r].resolve(t)) return !0;
	return !1;
}
function elO(e) {
	return 32 === e || 9 === e;
}
function el$(e) {
	return 32 <= e && e <= 126 || 161 <= e && e <= 55295 && 8232 !== e && 8233 !== e || 57344 <= e && e <= 65533 && 65279 !== e || 65536 <= e && e <= 1114111;
}
function elP(e) {
	return el$(e) && 65279 !== e && 13 !== e && 10 !== e;
}
function elB(e, t, r) {
	var i = elP(e), n = i && !elO(e);
	return (r ? i : i && 44 !== e && 91 !== e && 93 !== e && 123 !== e && 125 !== e) && 35 !== e && !(58 === t && !n) || elP(t) && !elO(t) && 35 === e || 58 === t && n;
}
function elF(e) {
	return el$(e) && 65279 !== e && !elO(e) && 45 !== e && 63 !== e && 58 !== e && 44 !== e && 91 !== e && 93 !== e && 123 !== e && 125 !== e && 35 !== e && 38 !== e && 42 !== e && 33 !== e && 124 !== e && 61 !== e && 62 !== e && 39 !== e && 34 !== e && 37 !== e && 64 !== e && 96 !== e;
}
function elz(e) {
	return !elO(e) && 58 !== e;
}
function elU(e, t) {
	var r, i = e.charCodeAt(t);
	return i >= 55296 && i <= 56319 && t + 1 < e.length && (r = e.charCodeAt(t + 1)) >= 56320 && r <= 57343 ? (i - 55296) * 1024 + r - 56320 + 65536 : i;
}
function elG(e) {
	return /^\n* /.test(e);
}
function elq(e, t, r, i, n, a, s, o) {
	var l, h = 0, u = null, d = !1, p = !1, f = -1 !== i, g = -1, m = elF(elU(e, 0)) && elz(elU(e, e.length - 1));
	if (t || s) for (l = 0; l < e.length; h >= 65536 ? l += 2 : l++) {
		if (!el$(h = elU(e, l))) return 5;
		m = m && elB(h, u, o), u = h;
	}
	else {
		for (l = 0; l < e.length; h >= 65536 ? l += 2 : l++) {
			if (10 === (h = elU(e, l))) d = !0, f && (p = p || l - g - 1 > i && " " !== e[g + 1], g = l);
			else if (!el$(h)) return 5;
			m = m && elB(h, u, o), u = h;
		}
		p = p || f && l - g - 1 > i && " " !== e[g + 1];
	}
	return d || p ? r > 9 && elG(e) ? 5 : s ? 2 === a ? 5 : 2 : p ? 4 : 3 : !m || s || n(e) ? 2 === a ? 5 : 2 : 1;
}
function elj(e, t, r, i, n) {
	e.dump = function() {
		if (0 === t.length) return 2 === e.quotingType ? "\"\"" : "''";
		if (!e.noCompatMode && (-1 !== elS.indexOf(t) || elA.test(t))) return 2 === e.quotingType ? "\"" + t + "\"" : "'" + t + "'";
		var a = e.indent * Math.max(1, r), s = -1 === e.lineWidth ? -1 : Math.max(Math.min(e.lineWidth, 40), e.lineWidth - a), o = i || e.flowLevel > -1 && r >= e.flowLevel;
		function l(t) {
			return elD(e, t);
		}
		switch (h(l, "testAmbiguity"), elq(t, o, e.indent, s, l, e.quotingType, e.forceQuotes && !i, n)) {
			case 1: return t;
			case 2: return "'" + t.replace(/'/g, "''") + "'";
			case 3: return "|" + elW(t, e.indent) + elY(elI(t, a));
			case 4: return ">" + elW(t, e.indent) + elY(elI(elV(t, s), a));
			case 5: return "\"" + elX(t) + "\"";
			default: throw new esj("impossible error: invalid scalar style");
		}
	}();
}
function elW(e, t) {
	var r = elG(e) ? String(t) : "", i = e[e.length - 1] === `
`;
	return r + (i && (e[e.length - 2] === `
` || e === `
`) ? "+" : i ? "" : "-") + `
`;
}
function elY(e) {
	return e[e.length - 1] === `
` ? e.slice(0, -1) : e;
}
function elV(e, t) {
	for (var r, i, n, a = /(\n+)([^\n]*)/g, s = (a.lastIndex = r = -1 !== (r = e.indexOf(`
`)) ? r : e.length, elH(e.slice(0, r), t)), o = e[0] === `
` || " " === e[0]; n = a.exec(e);) {
		var l = n[1], h = n[2];
		i = " " === h[0], s += l + (o || i || "" === h ? "" : `
`) + elH(h, t), o = i;
	}
	return s;
}
function elH(e, t) {
	if ("" === e || " " === e[0]) return e;
	for (var r, i, n = / [^ ]/g, a = 0, s = 0, o = 0, l = ""; r = n.exec(e);) (o = r.index) - a > t && (i = s > a ? s : o, l += `
` + e.slice(a, i), a = i + 1), s = o;
	return l += `
`, e.length - a > t && s > a ? l += e.slice(a, s) + `
` + e.slice(s + 1) : l += e.slice(a), l.slice(1);
}
function elX(e) {
	for (var t, r = "", i = 0, n = 0; n < e.length; i >= 65536 ? n += 2 : n++) !(t = elC[i = elU(e, n)]) && el$(i) ? (r += e[n], i >= 65536 && (r += e[n + 1])) : r += t || elR(i);
	return r;
}
function elK(e, t, r) {
	var i, n, a, s = "", o = e.tag;
	for (i = 0, n = r.length; i < n; i += 1) a = r[i], e.replacer && (a = e.replacer.call(r, String(i), a)), (el1(e, t, a, !1, !1) || typeof a > "u" && el1(e, t, null, !1, !1)) && ("" !== s && (s += "," + (e.condenseFlow ? "" : " ")), s += e.dump);
	e.tag = o, e.dump = "[" + s + "]";
}
function elZ(e, t, r, i) {
	var n, a, s, o = "", l = e.tag;
	for (n = 0, a = r.length; n < a; n += 1) s = r[n], e.replacer && (s = e.replacer.call(r, String(n), s)), (el1(e, t + 1, s, !0, !0, !1, !0) || typeof s > "u" && el1(e, t + 1, null, !0, !0, !1, !0)) && (i && "" === o || (o += elM(e, t)), e.dump && 10 === e.dump.charCodeAt(0) ? o += "-" : o += "- ", o += e.dump);
	e.tag = l, e.dump = o || "[]";
}
function elQ(e, t, r) {
	var i, n, a, s, o, l = "", h = e.tag, u = Object.keys(r);
	for (i = 0, n = u.length; i < n; i += 1) o = "", "" !== l && (o += ", "), e.condenseFlow && (o += "\""), s = r[a = u[i]], e.replacer && (s = e.replacer.call(r, a, s)), el1(e, t, a, !1, !1) && (e.dump.length > 1024 && (o += "? "), o += e.dump + (e.condenseFlow ? "\"" : "") + ":" + (e.condenseFlow ? "" : " "), el1(e, t, s, !1, !1) && (o += e.dump, l += o));
	e.tag = h, e.dump = "{" + l + "}";
}
function elJ(e, t, r, i) {
	var n, a, s, o, l, h, u = "", d = e.tag, p = Object.keys(r);
	if (!0 === e.sortKeys) p.sort();
	else if ("function" == typeof e.sortKeys) p.sort(e.sortKeys);
	else if (e.sortKeys) throw new esj("sortKeys must be a boolean or a function");
	for (n = 0, a = p.length; n < a; n += 1) h = "", i && "" === u || (h += elM(e, t)), o = r[s = p[n]], e.replacer && (o = e.replacer.call(r, s, o)), el1(e, t + 1, s, !0, !0, !0) && ((l = null !== e.tag && "?" !== e.tag || e.dump && e.dump.length > 1024) && (e.dump && 10 === e.dump.charCodeAt(0) ? h += "?" : h += "? "), h += e.dump, l && (h += elM(e, t)), el1(e, t + 1, o, !0, l) && (e.dump && 10 === e.dump.charCodeAt(0) ? h += ":" : h += ": ", h += e.dump, u += h));
	e.tag = d, e.dump = u || "{}";
}
function el0(e, t, r) {
	var i, n, a, s, o, l;
	for (n = r ? e.explicitTypes : e.implicitTypes, a = 0, s = n.length; a < s; a += 1) if (((o = n[a]).instanceOf || o.predicate) && (!o.instanceOf || "object" == typeof t && t instanceof o.instanceOf) && (!o.predicate || o.predicate(t))) {
		if (r ? o.multi && o.representName ? e.tag = o.representName(t) : e.tag = o.tag : e.tag = "?", o.represent) {
			if (l = e.styleMap[o.tag] || o.defaultStyle, "[object Function]" === el_.call(o.represent)) i = o.represent(t, l);
			else if (elE.call(o.represent, l)) i = o.represent[l](t, l);
			else throw new esj("!<" + o.tag + "> tag resolver accepts not \"" + l + "\" style");
			e.dump = i;
		}
		return !0;
	}
	return !1;
}
function el1(e, t, r, i, n, a, s) {
	e.tag = null, e.dump = r, el0(e, r, !1) || el0(e, r, !0);
	var o, l = el_.call(e.dump), h = i;
	i && (i = e.flowLevel < 0 || e.flowLevel > t);
	var u, d, p = "[object Object]" === l || "[object Array]" === l;
	if (p && (d = -1 !== (u = e.duplicates.indexOf(r))), (null !== e.tag && "?" !== e.tag || d || 2 !== e.indent && t > 0) && (n = !1), d && e.usedDuplicates[u]) e.dump = "*ref_" + u;
	else {
		if (p && d && !e.usedDuplicates[u] && (e.usedDuplicates[u] = !0), "[object Object]" === l) i && 0 !== Object.keys(e.dump).length ? (elJ(e, t, e.dump, n), d && (e.dump = "&ref_" + u + e.dump)) : (elQ(e, t, e.dump), d && (e.dump = "&ref_" + u + " " + e.dump));
		else if ("[object Array]" === l) i && 0 !== e.dump.length ? (e.noArrayIndent && !s && t > 0 ? elZ(e, t - 1, e.dump, n) : elZ(e, t, e.dump, n), d && (e.dump = "&ref_" + u + e.dump)) : (elK(e, t, e.dump), d && (e.dump = "&ref_" + u + " " + e.dump));
		else if ("[object String]" === l) "?" !== e.tag && elj(e, e.dump, t, a, h);
		else {
			if ("[object Undefined]" === l || e.skipInvalid) return !1;
			throw new esj("unacceptable kind of an object to dump " + l);
		}
		null !== e.tag && "?" !== e.tag && (o = encodeURI("!" === e.tag[0] ? e.tag.slice(1) : e.tag).replace(/!/g, "%21"), o = "!" === e.tag[0] ? "!" + o : "tag:yaml.org,2002:" === o.slice(0, 18) ? "!!" + o.slice(18) : "!<" + o + ">", e.dump = o + " " + e.dump);
	}
	return !0;
}
function el2(e, t) {
	var r, i, n = [], a = [];
	for (el4(e, n, a), r = 0, i = a.length; r < i; r += 1) t.duplicates.push(n[a[r]]);
	t.usedDuplicates = Array(i);
}
function el4(e, t, r) {
	var i, n, a;
	if (null !== e && "object" == typeof e) if (-1 !== (n = t.indexOf(e))) -1 === r.indexOf(n) && r.push(n);
	else if (t.push(e), Array.isArray(e)) for (n = 0, a = e.length; n < a; n += 1) el4(e[n], t, r);
	else for (i = Object.keys(e), n = 0, a = i.length; n < a; n += 1) el4(e[i[n]], t, r);
}
h(elL, "compileStyleMap"), h(elR, "encodeHex"), h(elN, "State"), h(elI, "indentString"), h(elM, "generateNextLine"), h(elD, "testImplicitResolving"), h(elO, "isWhitespace"), h(el$, "isPrintable"), h(elP, "isNsCharOrWhitespace"), h(elB, "isPlainSafe"), h(elF, "isPlainSafeFirst"), h(elz, "isPlainSafeLast"), h(elU, "codePointAt"), h(elG, "needIndentIndicator");
function el5(e, t) {
	return function() {
		throw Error("Function yaml." + e + " is removed in js-yaml 4. Use yaml." + t + " instead, which is now safe by default.");
	};
}
h(elq, "chooseScalarStyle"), h(elj, "writeScalar"), h(elW, "blockHeader"), h(elY, "dropEndingNewline"), h(elV, "foldString"), h(elH, "foldLine"), h(elX, "escapeString"), h(elK, "writeFlowSequence"), h(elZ, "writeBlockSequence"), h(elQ, "writeFlowMapping"), h(elJ, "writeBlockMapping"), h(el0, "detectType"), h(el1, "writeNode"), h(el2, "getDuplicateReferences"), h(el4, "inspectNode"), h(function(e, t) {
	var r = new elN(t = t || {});
	r.noRefs || el2(e, r);
	var i = e;
	return r.replacer && (i = r.replacer.call({ "": i }, "", i)), el1(r, 0, i, !0, !0) ? r.dump + `
` : "";
}, "dump$1"), h(el5, "renamed");
el5("safeLoad", "load"), el5("safeLoadAll", "loadAll"), el5("safeDump", "dump");
var el3 = class {
	constructor() {
		this.vertexCounter = 0, this.config = IA(), this.vertices = /* @__PURE__ */ new Map(), this.edges = [], this.classes = /* @__PURE__ */ new Map(), this.subGraphs = [], this.subGraphLookup = /* @__PURE__ */ new Map(), this.tooltips = /* @__PURE__ */ new Map(), this.subCount = 0, this.firstGraphFlag = !0, this.secCount = -1, this.posCrossRef = [], this.funs = [], this.setAccTitle = Da, this.setAccDescription = Do, this.setDiagramTitle = Dc, this.getAccTitle = Ds, this.getAccDescription = Dl, this.getDiagramTitle = Dh, this.funs.push(this.setupToolTips.bind(this)), this.addVertex = this.addVertex.bind(this), this.firstGraph = this.firstGraph.bind(this), this.setDirection = this.setDirection.bind(this), this.addSubGraph = this.addSubGraph.bind(this), this.addLink = this.addLink.bind(this), this.setLink = this.setLink.bind(this), this.updateLink = this.updateLink.bind(this), this.addClass = this.addClass.bind(this), this.setClass = this.setClass.bind(this), this.destructLink = this.destructLink.bind(this), this.setClickEvent = this.setClickEvent.bind(this), this.setTooltip = this.setTooltip.bind(this), this.updateLinkInterpolate = this.updateLinkInterpolate.bind(this), this.setClickFun = this.setClickFun.bind(this), this.bindFunctions = this.bindFunctions.bind(this), this.lex = { firstGraph: this.firstGraph.bind(this) }, this.clear(), this.setGen("gen-2");
	}
	static {
		h(this, "FlowDB");
	}
	sanitizeText(e) {
		return M1.sanitizeText(e, this.config);
	}
	lookUpDomId(e) {
		for (let t of this.vertices.values()) if (t.id === e) return t.domId;
		return e;
	}
	addVertex(e, t, r, i, n, a, s = {}, o) {
		let l;
		if (!e || 0 === e.trim().length) return;
		void 0 !== o && (l = elT(o.includes(`
`) ? o + `
` : `{
` + o + `
}`, { schema: eof }));
		let h = this.edges.find((t) => t.id === e);
		if (h) {
			let e = l;
			e?.animate !== void 0 && (h.animate = e.animate), e?.animation !== void 0 && (h.animation = e.animation), e?.curve !== void 0 && (h.interpolate = e.curve);
			return;
		}
		let u, d = this.vertices.get(e);
		if (void 0 === d && (d = {
			id: e,
			labelType: "text",
			domId: "flowchart-" + e + "-" + this.vertexCounter,
			styles: [],
			classes: []
		}, this.vertices.set(e, d)), this.vertexCounter++, void 0 !== t ? (this.config = IA(), u = this.sanitizeText(t.text.trim()), d.labelType = t.type, u.startsWith("\"") && u.endsWith("\"") && (u = u.substring(1, u.length - 1)), d.text = u) : void 0 === d.text && (d.text = e), void 0 !== r && (d.type = r), i?.forEach((e) => {
			d.styles.push(e);
		}), n?.forEach((e) => {
			d.classes.push(e);
		}), void 0 !== a && (d.dir = a), void 0 === d.props ? d.props = s : void 0 !== s && Object.assign(d.props, s), void 0 !== l) {
			if (l.shape) {
				if (l.shape !== l.shape.toLowerCase() || l.shape.includes("_")) throw Error(`No such shape: ${l.shape}. Shape names should be lowercase.`);
				if (!erO(l.shape)) throw Error(`No such shape: ${l.shape}.`);
				d.type = l?.shape;
			}
			l?.label && (d.text = l?.label), l?.icon && (d.icon = l?.icon, l.label?.trim() || d.text !== e || (d.text = "")), l?.form && (d.form = l?.form), l?.pos && (d.pos = l?.pos), l?.img && (d.img = l?.img, l.label?.trim() || d.text !== e || (d.text = "")), l?.constraint && (d.constraint = l.constraint), l.w && (d.assetWidth = Number(l.w)), l.h && (d.assetHeight = Number(l.h));
		}
	}
	addSingleLink(e, t, r, i) {
		let n = {
			start: e,
			end: t,
			type: void 0,
			text: "",
			labelType: "text",
			classes: [],
			isUserDefinedId: !1,
			interpolate: this.edges.defaultInterpolate
		};
		wQ.info("abc78 Got edge...", n);
		let a = r.text;
		if (void 0 !== a && (n.text = this.sanitizeText(a.text.trim()), n.text.startsWith("\"") && n.text.endsWith("\"") && (n.text = n.text.substring(1, n.text.length - 1)), n.labelType = a.type), void 0 !== r && (n.type = r.type, n.stroke = r.stroke, n.length = r.length > 10 ? 10 : r.length), i && !this.edges.some((e) => e.id === i)) n.id = i, n.isUserDefinedId = !0;
		else {
			let e = this.edges.filter((e) => e.start === n.start && e.end === n.end);
			0 === e.length ? n.id = V7(n.start, n.end, {
				counter: 0,
				prefix: "L"
			}) : n.id = V7(n.start, n.end, {
				counter: e.length + 1,
				prefix: "L"
			});
		}
		if (this.edges.length < (this.config.maxEdges ?? 500)) wQ.info("Pushing edge..."), this.edges.push(n);
		else throw Error(`Edge limit exceeded. ${this.edges.length} edges found, but the limit is ${this.config.maxEdges}.

Initialize mermaid with maxEdges set to a higher number to allow more edges.
You cannot set this config via configuration inside the diagram as it is a secure config.
You have to call mermaid.initialize.`);
	}
	isLinkData(e) {
		return null !== e && "object" == typeof e && "id" in e && "string" == typeof e.id;
	}
	addLink(e, t, r) {
		let i = this.isLinkData(r) ? r.id.replace("@", "") : void 0;
		for (let n of (wQ.info("addLink", e, t, i), e)) for (let a of t) {
			let s = n === e[e.length - 1], o = a === t[0];
			s && o ? this.addSingleLink(n, a, r, i) : this.addSingleLink(n, a, r, void 0);
		}
	}
	updateLinkInterpolate(e, t) {
		e.forEach((e) => {
			"default" === e ? this.edges.defaultInterpolate = t : this.edges[e].interpolate = t;
		});
	}
	updateLink(e, t) {
		e.forEach((e) => {
			if ("number" == typeof e && e >= this.edges.length) throw Error(`The index ${e} for linkStyle is out of bounds. Valid indices for linkStyle are between 0 and ${this.edges.length - 1}. (Help: Ensure that the index is within the range of existing edges.)`);
			"default" === e ? this.edges.defaultStyle = t : (this.edges[e].style = t, (this.edges[e]?.style?.length ?? 0) > 0 && !this.edges[e]?.style?.some((e) => e?.startsWith("fill")) && this.edges[e]?.style?.push("fill:none"));
		});
	}
	addClass(e, t) {
		let r = t.join().replace(/\\,/g, "").replace(/,/g, ";").replace(//g, ",").split(";");
		e.split(",").forEach((e) => {
			let t = this.classes.get(e);
			void 0 === t && (t = {
				id: e,
				styles: [],
				textStyles: []
			}, this.classes.set(e, t)), r?.forEach((e) => {
				if (/color/.exec(e)) {
					let r = e.replace("fill", "bgFill");
					t.textStyles.push(r);
				}
				t.styles.push(e);
			});
		});
	}
	setDirection(e) {
		this.direction = e.trim(), /.*</.exec(this.direction) && (this.direction = "RL"), /.*\^/.exec(this.direction) && (this.direction = "BT"), /.*>/.exec(this.direction) && (this.direction = "LR"), /.*v/.exec(this.direction) && (this.direction = "TB"), "TD" === this.direction && (this.direction = "TB");
	}
	setClass(e, t) {
		for (let r of e.split(",")) {
			let e = this.vertices.get(r);
			e && e.classes.push(t);
			let i = this.edges.find((e) => e.id === r);
			i && i.classes.push(t);
			let n = this.subGraphLookup.get(r);
			n && n.classes.push(t);
		}
	}
	setTooltip(e, t) {
		if (void 0 !== t) for (let r of (t = this.sanitizeText(t), e.split(","))) this.tooltips.set("gen-1" === this.version ? this.lookUpDomId(r) : r, t);
	}
	setClickFun(e, t, r) {
		let i = this.lookUpDomId(e);
		if ("loose" !== IA().securityLevel || void 0 === t) return;
		let n = [];
		if ("string" == typeof r) {
			n = r.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
			for (let e = 0; e < n.length; e++) {
				let t = n[e].trim();
				t.startsWith("\"") && t.endsWith("\"") && (t = t.substr(1, t.length - 2)), n[e] = t;
			}
		}
		0 === n.length && n.push(e);
		let a = this.vertices.get(e);
		a && (a.haveCallback = !0, this.funs.push(() => {
			let e = document.querySelector(`[id="${i}"]`);
			null !== e && e.addEventListener("click", () => {
				VN(t, ...n);
			}, !1);
		}));
	}
	setLink(e, t, r) {
		e.split(",").forEach((e) => {
			let i = this.vertices.get(e);
			void 0 !== i && (i.link = VR(t, this.config), i.linkTarget = r);
		}), this.setClass(e, "clickable");
	}
	getTooltip(e) {
		return this.tooltips.get(e);
	}
	setClickEvent(e, t, r) {
		e.split(",").forEach((e) => {
			this.setClickFun(e, t, r);
		}), this.setClass(e, "clickable");
	}
	bindFunctions(e) {
		this.funs.forEach((t) => {
			t(e);
		});
	}
	getDirection() {
		return this.direction?.trim();
	}
	getVertices() {
		return this.vertices;
	}
	getEdges() {
		return this.edges;
	}
	getClasses() {
		return this.classes;
	}
	setupToolTips(e) {
		let t = _t(".mermaidTooltip");
		null === (t._groups || t)[0][0] && (t = _t("body").append("div").attr("class", "mermaidTooltip").style("opacity", 0)), _t(e).select("svg").selectAll("g.node").on("mouseover", (e) => {
			let r = _t(e.currentTarget);
			if (null === r.attr("title")) return;
			let i = e.currentTarget?.getBoundingClientRect();
			t.transition().duration(200).style("opacity", ".9"), t.text(r.attr("title")).style("left", window.scrollX + i.left + (i.right - i.left) / 2 + "px").style("top", window.scrollY + i.bottom + "px"), t.html(t.html().replace(/&lt;br\/&gt;/g, "<br/>")), r.classed("hover", !0);
		}).on("mouseout", (e) => {
			t.transition().duration(500).style("opacity", 0), _t(e.currentTarget).classed("hover", !1);
		});
	}
	clear(e = "gen-2") {
		this.vertices = /* @__PURE__ */ new Map(), this.classes = /* @__PURE__ */ new Map(), this.edges = [], this.funs = [this.setupToolTips.bind(this)], this.subGraphs = [], this.subGraphLookup = /* @__PURE__ */ new Map(), this.subCount = 0, this.tooltips = /* @__PURE__ */ new Map(), this.firstGraphFlag = !0, this.version = e, this.config = IA(), Dn();
	}
	setGen(e) {
		this.version = e || "gen-2";
	}
	defaultStyle() {
		return "fill:#ffa;stroke: #f66; stroke-width: 3px; stroke-dasharray: 5, 5;fill:#ffa;stroke: #666;";
	}
	addSubGraph(e, t, r) {
		let i = e.text.trim(), n = r.text;
		e === r && /\s/.exec(r.text) && (i = void 0);
		let a = h((e) => {
			let t = {
				boolean: {},
				number: {},
				string: {}
			}, r = [], i;
			return {
				nodeList: e.filter(function(e) {
					let n = typeof e;
					return e.stmt && "dir" === e.stmt ? (i = e.value, !1) : "" !== e.trim() && (n in t ? !t[n].hasOwnProperty(e) && (t[n][e] = !0) : !r.includes(e) && r.push(e));
				}),
				dir: i
			};
		}, "uniq")(t.flat()), s = a.nodeList, o = a.dir, l = IA().flowchart ?? {};
		if (o = o ?? (l.inheritDir ? this.getDirection() ?? IA().direction ?? void 0 : void 0), "gen-1" === this.version) for (let e = 0; e < s.length; e++) s[e] = this.lookUpDomId(s[e]);
		i = i ?? "subGraph" + this.subCount, n = n || "", n = this.sanitizeText(n), this.subCount = this.subCount + 1;
		let u = {
			id: i,
			nodes: s,
			title: n.trim(),
			classes: [],
			dir: o,
			labelType: r.type
		};
		return wQ.info("Adding", u.id, u.nodes, u.dir), u.nodes = this.makeUniq(u, this.subGraphs).nodes, this.subGraphs.push(u), this.subGraphLookup.set(i, u), i;
	}
	getPosForId(e) {
		for (let [t, r] of this.subGraphs.entries()) if (r.id === e) return t;
		return -1;
	}
	indexNodes2(e, t) {
		let r = this.subGraphs[t].nodes;
		if (this.secCount = this.secCount + 1, this.secCount > 2e3) return {
			result: !1,
			count: 0
		};
		if (this.posCrossRef[this.secCount] = t, this.subGraphs[t].id === e) return {
			result: !0,
			count: 0
		};
		let i = 0, n = 1;
		for (; i < r.length;) {
			let t = this.getPosForId(r[i]);
			if (t >= 0) {
				let r = this.indexNodes2(e, t);
				if (r.result) return {
					result: !0,
					count: n + r.count
				};
				n += r.count;
			}
			i += 1;
		}
		return {
			result: !1,
			count: n
		};
	}
	getDepthFirstPos(e) {
		return this.posCrossRef[e];
	}
	indexNodes() {
		this.secCount = -1, this.subGraphs.length > 0 && this.indexNodes2("none", this.subGraphs.length - 1);
	}
	getSubGraphs() {
		return this.subGraphs;
	}
	firstGraph() {
		return !!this.firstGraphFlag && (this.firstGraphFlag = !1, !0);
	}
	destructStartLink(e) {
		let t = e.trim(), r = "arrow_open";
		switch (t[0]) {
			case "<":
				r = "arrow_point", t = t.slice(1);
				break;
			case "x":
				r = "arrow_cross", t = t.slice(1);
				break;
			case "o": r = "arrow_circle", t = t.slice(1);
		}
		let i = "normal";
		return t.includes("=") && (i = "thick"), t.includes(".") && (i = "dotted"), {
			type: r,
			stroke: i
		};
	}
	countChar(e, t) {
		let r = t.length, i = 0;
		for (let n = 0; n < r; ++n) t[n] === e && ++i;
		return i;
	}
	destructEndLink(e) {
		let t = e.trim(), r = t.slice(0, -1), i = "arrow_open";
		switch (t.slice(-1)) {
			case "x":
				i = "arrow_cross", t.startsWith("x") && (i = "double_" + i, r = r.slice(1));
				break;
			case ">":
				i = "arrow_point", t.startsWith("<") && (i = "double_" + i, r = r.slice(1));
				break;
			case "o": i = "arrow_circle", t.startsWith("o") && (i = "double_" + i, r = r.slice(1));
		}
		let n = "normal", a = r.length - 1;
		r.startsWith("=") && (n = "thick"), r.startsWith("~") && (n = "invisible");
		let s = this.countChar(".", r);
		return s && (n = "dotted", a = s), {
			type: i,
			stroke: n,
			length: a
		};
	}
	destructLink(e, t) {
		let r = this.destructEndLink(e), i;
		if (t) {
			if ((i = this.destructStartLink(t)).stroke !== r.stroke) return {
				type: "INVALID",
				stroke: "INVALID"
			};
			if ("arrow_open" === i.type) i.type = r.type;
			else {
				if (i.type !== r.type) return {
					type: "INVALID",
					stroke: "INVALID"
				};
				i.type = "double_" + i.type;
			}
			return "double_arrow" === i.type && (i.type = "double_arrow_point"), i.length = r.length, i;
		}
		return r;
	}
	exists(e, t) {
		for (let r of e) if (r.nodes.includes(t)) return !0;
		return !1;
	}
	makeUniq(e, t) {
		let r = [];
		return e.nodes.forEach((i, n) => {
			this.exists(t, i) || r.push(e.nodes[n]);
		}), { nodes: r };
	}
	getTypeFromVertex(e) {
		if (e.img) return "imageSquare";
		if (e.icon) return "circle" === e.form ? "iconCircle" : "square" === e.form ? "iconSquare" : "rounded" === e.form ? "iconRounded" : "icon";
		switch (e.type) {
			case "square":
			case void 0: return "squareRect";
			case "round": return "roundedRect";
			case "ellipse": return "ellipse";
			default: return e.type;
		}
	}
	findNode(e, t) {
		return e.find((e) => e.id === t);
	}
	destructEdgeType(e) {
		let t = "none", r = "arrow_point";
		switch (e) {
			case "arrow_point":
			case "arrow_circle":
			case "arrow_cross":
				r = e;
				break;
			case "double_arrow_point":
			case "double_arrow_circle":
			case "double_arrow_cross": r = t = e.replace("double_", "");
		}
		return {
			arrowTypeStart: t,
			arrowTypeEnd: r
		};
	}
	addNodeFromVertex(e, t, r, i, n, a) {
		let s = r.get(e.id), o = i.get(e.id) ?? !1, l = this.findNode(t, e.id);
		if (l) l.cssStyles = e.styles, l.cssCompiledStyles = this.getCompiledStyles(e.classes), l.cssClasses = e.classes.join(" ");
		else {
			let r = {
				id: e.id,
				label: e.text,
				labelStyle: "",
				parentId: s,
				padding: n.flowchart?.padding || 8,
				cssStyles: e.styles,
				cssCompiledStyles: this.getCompiledStyles([
					"default",
					"node",
					...e.classes
				]),
				cssClasses: "default " + e.classes.join(" "),
				dir: e.dir,
				domId: e.domId,
				look: a,
				link: e.link,
				linkTarget: e.linkTarget,
				tooltip: this.getTooltip(e.id),
				icon: e.icon,
				pos: e.pos,
				img: e.img,
				assetWidth: e.assetWidth,
				assetHeight: e.assetHeight,
				constraint: e.constraint
			};
			o ? t.push({
				...r,
				isGroup: !0,
				shape: "rect"
			}) : t.push({
				...r,
				isGroup: !1,
				shape: this.getTypeFromVertex(e)
			});
		}
	}
	getCompiledStyles(e) {
		let t = [];
		for (let r of e) {
			let e = this.classes.get(r);
			e?.styles && (t = [...t, ...e.styles ?? []].map((e) => e.trim())), e?.textStyles && (t = [...t, ...e.textStyles ?? []].map((e) => e.trim()));
		}
		return t;
	}
	getData() {
		let e = IA(), t = [], r = [], i = this.getSubGraphs(), n = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map();
		for (let e = i.length - 1; e >= 0; e--) {
			let t = i[e];
			for (let e of (t.nodes.length > 0 && a.set(t.id, !0), t.nodes)) n.set(e, t.id);
		}
		for (let r = i.length - 1; r >= 0; r--) {
			let a = i[r];
			t.push({
				id: a.id,
				label: a.title,
				labelStyle: "",
				parentId: n.get(a.id),
				padding: 8,
				cssCompiledStyles: this.getCompiledStyles(a.classes),
				cssClasses: a.classes.join(" "),
				shape: "rect",
				dir: a.dir,
				isGroup: !0,
				look: e.look
			});
		}
		this.getVertices().forEach((r) => {
			this.addNodeFromVertex(r, t, n, a, e, e.look || "classic");
		});
		let s = this.getEdges();
		return s.forEach((t, i) => {
			let { arrowTypeStart: n, arrowTypeEnd: a } = this.destructEdgeType(t.type), o = [...s.defaultStyle ?? []];
			t.style && o.push(...t.style);
			let l = {
				id: V7(t.start, t.end, {
					counter: i,
					prefix: "L"
				}, t.id),
				isUserDefinedId: t.isUserDefinedId,
				start: t.start,
				end: t.end,
				type: t.type ?? "normal",
				label: t.text,
				labelpos: "c",
				thickness: t.stroke,
				minlen: t.length,
				classes: t?.stroke === "invisible" ? "" : "edge-thickness-normal edge-pattern-solid flowchart-link",
				arrowTypeStart: t?.stroke === "invisible" || t?.type === "arrow_open" ? "none" : n,
				arrowTypeEnd: t?.stroke === "invisible" || t?.type === "arrow_open" ? "none" : a,
				arrowheadStyle: "fill: #333",
				cssCompiledStyles: this.getCompiledStyles(t.classes),
				labelStyle: o,
				style: o,
				pattern: t.stroke,
				look: e.look,
				animate: t.animate,
				animation: t.animation,
				curve: t.interpolate || this.edges.defaultInterpolate || e.flowchart?.curve
			};
			r.push(l);
		}), {
			nodes: t,
			edges: r,
			other: {},
			config: e
		};
	}
	defaultConfig() {
		return Iv.flowchart;
	}
}, el6 = {
	getClasses: h(function(e, t) {
		return t.db.getClasses();
	}, "getClasses"),
	draw: h(async function(e, t, r, i) {
		wQ.info("REF0:"), wQ.info("Drawing state diagram (v2)", t);
		let { securityLevel: n, flowchart: a, layout: s } = IA(), o;
		"sandbox" === n && (o = _t("#i" + t));
		let l = "sandbox" === n ? o.nodes()[0].contentDocument : document;
		wQ.debug("Before getData: ");
		let h = i.db.getData();
		wQ.debug("Data: ", h);
		let u = JW(t, n), d = i.db.getDirection();
		h.type = i.type, h.layoutAlgorithm = ein(s), "dagre" === h.layoutAlgorithm && "elk" === s && wQ.warn("flowchart-elk was moved to an external package in Mermaid v11. Please refer [release notes](https://github.com/mermaid-js/mermaid/releases/tag/v11.0.0) for more details. This diagram will be rendered using `dagre` layout as a fallback."), h.direction = d, h.nodeSpacing = a?.nodeSpacing || 50, h.rankSpacing = a?.rankSpacing || 50, h.markers = [
			"point",
			"circle",
			"cross"
		], h.diagramId = t, wQ.debug("REF1:", h), await eii(h, u);
		let p = h.config.flowchart?.diagramPadding ?? 8;
		for (let e of (V2(u, "flowchartTitleText", a?.titleTopMargin || 0, i.db.getDiagramTitle()), JY(u, p, "flowchart", a?.useMaxWidth || !1), h.nodes)) {
			let r = _t(`#${t} [id="${e.id}"]`);
			if (!r || !e.link) continue;
			let i = l.createElementNS("http://www.w3.org/2000/svg", "a");
			i.setAttributeNS("http://www.w3.org/2000/svg", "class", e.cssClasses), i.setAttributeNS("http://www.w3.org/2000/svg", "rel", "noopener"), "sandbox" === n ? i.setAttributeNS("http://www.w3.org/2000/svg", "target", "_top") : e.linkTarget && i.setAttributeNS("http://www.w3.org/2000/svg", "target", e.linkTarget);
			let a = r.insert(function() {
				return i;
			}, ":first-child"), s = r.select(".label-container");
			s && a.append(function() {
				return s.node();
			});
			let o = r.select(".label");
			o && a.append(function() {
				return o.node();
			});
		}
	}, "draw")
}, el7 = function() {
	var e = h(function(e, t, r, i) {
		for (r = r || {}, i = e.length; i--; r[e[i]] = t);
		return r;
	}, "o"), t = [1, 4], r = [1, 3], i = [1, 5], n = [
		1,
		8,
		9,
		10,
		11,
		27,
		34,
		36,
		38,
		44,
		60,
		84,
		85,
		86,
		87,
		88,
		89,
		102,
		105,
		106,
		109,
		111,
		114,
		115,
		116,
		121,
		122,
		123,
		124
	], a = [2, 2], s = [1, 13], o = [1, 14], l = [1, 15], u = [1, 16], d = [1, 23], p = [1, 25], f = [1, 26], g = [1, 27], m = [1, 49], y = [1, 48], v = [1, 29], x = [1, 30], b = [1, 31], w = [1, 32], k = [1, 33], T = [1, 44], _ = [1, 46], E = [1, 42], C = [1, 47], S = [1, 43], A = [1, 50], L = [1, 45], R = [1, 51], N = [1, 52], I = [1, 34], M = [1, 35], D = [1, 36], O = [1, 37], $ = [1, 57], P = [
		1,
		8,
		9,
		10,
		11,
		27,
		32,
		34,
		36,
		38,
		44,
		60,
		84,
		85,
		86,
		87,
		88,
		89,
		102,
		105,
		106,
		109,
		111,
		114,
		115,
		116,
		121,
		122,
		123,
		124
	], B = [1, 61], F = [1, 60], z = [1, 62], U = [
		8,
		9,
		11,
		75,
		77,
		78
	], G = [1, 78], q = [1, 91], j = [1, 96], W = [1, 95], Y = [1, 92], V = [1, 88], H = [1, 94], X = [1, 90], K = [1, 97], Z = [1, 93], Q = [1, 98], J = [1, 89], ee = [
		8,
		9,
		10,
		11,
		40,
		75,
		77,
		78
	], et = [
		8,
		9,
		10,
		11,
		40,
		46,
		75,
		77,
		78
	], er = [
		8,
		9,
		10,
		11,
		29,
		40,
		44,
		46,
		48,
		50,
		52,
		54,
		56,
		58,
		60,
		63,
		65,
		67,
		68,
		70,
		75,
		77,
		78,
		89,
		102,
		105,
		106,
		109,
		111,
		114,
		115,
		116
	], ei = [
		8,
		9,
		11,
		44,
		60,
		75,
		77,
		78,
		89,
		102,
		105,
		106,
		109,
		111,
		114,
		115,
		116
	], en = [
		44,
		60,
		89,
		102,
		105,
		106,
		109,
		111,
		114,
		115,
		116
	], ea = [1, 121], es = [1, 122], eo = [1, 124], el = [1, 123], ec = [
		44,
		60,
		62,
		74,
		89,
		102,
		105,
		106,
		109,
		111,
		114,
		115,
		116
	], eh = [1, 133], eu = [1, 147], ed = [1, 148], ep = [1, 149], ef = [1, 150], eg = [1, 135], em = [1, 137], ey = [1, 141], ev = [1, 142], ex = [1, 143], eb = [1, 144], ew = [1, 145], ek = [1, 146], eT = [1, 151], e_ = [1, 152], eE = [1, 131], eC = [1, 132], eS = [1, 139], eA = [1, 134], eL = [1, 138], eR = [1, 136], eN = [
		8,
		9,
		10,
		11,
		27,
		32,
		34,
		36,
		38,
		44,
		60,
		84,
		85,
		86,
		87,
		88,
		89,
		102,
		105,
		106,
		109,
		111,
		114,
		115,
		116,
		121,
		122,
		123,
		124
	], eI = [1, 154], eM = [1, 156], eD = [
		8,
		9,
		11
	], eO = [
		8,
		9,
		10,
		11,
		14,
		44,
		60,
		89,
		105,
		106,
		109,
		111,
		114,
		115,
		116
	], e$ = [1, 176], eP = [1, 172], eB = [1, 173], eF = [1, 177], ez = [1, 174], eU = [1, 175], eG = [
		77,
		116,
		119
	], eq = [
		8,
		9,
		10,
		11,
		12,
		14,
		27,
		29,
		32,
		44,
		60,
		75,
		84,
		85,
		86,
		87,
		88,
		89,
		90,
		105,
		109,
		111,
		114,
		115,
		116
	], ej = [10, 106], eW = [
		31,
		49,
		51,
		53,
		55,
		57,
		62,
		64,
		66,
		67,
		69,
		71,
		116,
		117,
		118
	], eY = [1, 247], eV = [1, 245], eH = [1, 249], eX = [1, 243], eK = [1, 244], eZ = [1, 246], eQ = [1, 248], eJ = [1, 250], e0 = [1, 268], e1 = [
		8,
		9,
		11,
		106
	], e2 = [
		8,
		9,
		10,
		11,
		60,
		84,
		105,
		106,
		109,
		110,
		111,
		112
	], e4 = {
		trace: h(function() {}, "trace"),
		yy: {},
		symbols_: {
			error: 2,
			start: 3,
			graphConfig: 4,
			document: 5,
			line: 6,
			statement: 7,
			SEMI: 8,
			NEWLINE: 9,
			SPACE: 10,
			EOF: 11,
			GRAPH: 12,
			NODIR: 13,
			DIR: 14,
			FirstStmtSeparator: 15,
			ending: 16,
			endToken: 17,
			spaceList: 18,
			spaceListNewline: 19,
			vertexStatement: 20,
			separator: 21,
			styleStatement: 22,
			linkStyleStatement: 23,
			classDefStatement: 24,
			classStatement: 25,
			clickStatement: 26,
			subgraph: 27,
			textNoTags: 28,
			SQS: 29,
			text: 30,
			SQE: 31,
			end: 32,
			direction: 33,
			acc_title: 34,
			acc_title_value: 35,
			acc_descr: 36,
			acc_descr_value: 37,
			acc_descr_multiline_value: 38,
			shapeData: 39,
			SHAPE_DATA: 40,
			link: 41,
			node: 42,
			styledVertex: 43,
			AMP: 44,
			vertex: 45,
			STYLE_SEPARATOR: 46,
			idString: 47,
			DOUBLECIRCLESTART: 48,
			DOUBLECIRCLEEND: 49,
			PS: 50,
			PE: 51,
			"(-": 52,
			"-)": 53,
			STADIUMSTART: 54,
			STADIUMEND: 55,
			SUBROUTINESTART: 56,
			SUBROUTINEEND: 57,
			VERTEX_WITH_PROPS_START: 58,
			"NODE_STRING[field]": 59,
			COLON: 60,
			"NODE_STRING[value]": 61,
			PIPE: 62,
			CYLINDERSTART: 63,
			CYLINDEREND: 64,
			DIAMOND_START: 65,
			DIAMOND_STOP: 66,
			TAGEND: 67,
			TRAPSTART: 68,
			TRAPEND: 69,
			INVTRAPSTART: 70,
			INVTRAPEND: 71,
			linkStatement: 72,
			arrowText: 73,
			TESTSTR: 74,
			START_LINK: 75,
			edgeText: 76,
			LINK: 77,
			LINK_ID: 78,
			edgeTextToken: 79,
			STR: 80,
			MD_STR: 81,
			textToken: 82,
			keywords: 83,
			STYLE: 84,
			LINKSTYLE: 85,
			CLASSDEF: 86,
			CLASS: 87,
			CLICK: 88,
			DOWN: 89,
			UP: 90,
			textNoTagsToken: 91,
			stylesOpt: 92,
			"idString[vertex]": 93,
			"idString[class]": 94,
			CALLBACKNAME: 95,
			CALLBACKARGS: 96,
			HREF: 97,
			LINK_TARGET: 98,
			"STR[link]": 99,
			"STR[tooltip]": 100,
			alphaNum: 101,
			DEFAULT: 102,
			numList: 103,
			INTERPOLATE: 104,
			NUM: 105,
			COMMA: 106,
			style: 107,
			styleComponent: 108,
			NODE_STRING: 109,
			UNIT: 110,
			BRKT: 111,
			PCT: 112,
			idStringToken: 113,
			MINUS: 114,
			MULT: 115,
			UNICODE_TEXT: 116,
			TEXT: 117,
			TAGSTART: 118,
			EDGE_TEXT: 119,
			alphaNumToken: 120,
			direction_tb: 121,
			direction_bt: 122,
			direction_rl: 123,
			direction_lr: 124,
			$accept: 0,
			$end: 1
		},
		terminals_: {
			2: "error",
			8: "SEMI",
			9: "NEWLINE",
			10: "SPACE",
			11: "EOF",
			12: "GRAPH",
			13: "NODIR",
			14: "DIR",
			27: "subgraph",
			29: "SQS",
			31: "SQE",
			32: "end",
			34: "acc_title",
			35: "acc_title_value",
			36: "acc_descr",
			37: "acc_descr_value",
			38: "acc_descr_multiline_value",
			40: "SHAPE_DATA",
			44: "AMP",
			46: "STYLE_SEPARATOR",
			48: "DOUBLECIRCLESTART",
			49: "DOUBLECIRCLEEND",
			50: "PS",
			51: "PE",
			52: "(-",
			53: "-)",
			54: "STADIUMSTART",
			55: "STADIUMEND",
			56: "SUBROUTINESTART",
			57: "SUBROUTINEEND",
			58: "VERTEX_WITH_PROPS_START",
			59: "NODE_STRING[field]",
			60: "COLON",
			61: "NODE_STRING[value]",
			62: "PIPE",
			63: "CYLINDERSTART",
			64: "CYLINDEREND",
			65: "DIAMOND_START",
			66: "DIAMOND_STOP",
			67: "TAGEND",
			68: "TRAPSTART",
			69: "TRAPEND",
			70: "INVTRAPSTART",
			71: "INVTRAPEND",
			74: "TESTSTR",
			75: "START_LINK",
			77: "LINK",
			78: "LINK_ID",
			80: "STR",
			81: "MD_STR",
			84: "STYLE",
			85: "LINKSTYLE",
			86: "CLASSDEF",
			87: "CLASS",
			88: "CLICK",
			89: "DOWN",
			90: "UP",
			93: "idString[vertex]",
			94: "idString[class]",
			95: "CALLBACKNAME",
			96: "CALLBACKARGS",
			97: "HREF",
			98: "LINK_TARGET",
			99: "STR[link]",
			100: "STR[tooltip]",
			102: "DEFAULT",
			104: "INTERPOLATE",
			105: "NUM",
			106: "COMMA",
			109: "NODE_STRING",
			110: "UNIT",
			111: "BRKT",
			112: "PCT",
			114: "MINUS",
			115: "MULT",
			116: "UNICODE_TEXT",
			117: "TEXT",
			118: "TAGSTART",
			119: "EDGE_TEXT",
			121: "direction_tb",
			122: "direction_bt",
			123: "direction_rl",
			124: "direction_lr"
		},
		productions_: [
			0,
			[3, 2],
			[5, 0],
			[5, 2],
			[6, 1],
			[6, 1],
			[6, 1],
			[6, 1],
			[6, 1],
			[4, 2],
			[4, 2],
			[4, 2],
			[4, 3],
			[16, 2],
			[16, 1],
			[17, 1],
			[17, 1],
			[17, 1],
			[15, 1],
			[15, 1],
			[15, 2],
			[19, 2],
			[19, 2],
			[19, 1],
			[19, 1],
			[18, 2],
			[18, 1],
			[7, 2],
			[7, 2],
			[7, 2],
			[7, 2],
			[7, 2],
			[7, 2],
			[7, 9],
			[7, 6],
			[7, 4],
			[7, 1],
			[7, 2],
			[7, 2],
			[7, 1],
			[21, 1],
			[21, 1],
			[21, 1],
			[39, 2],
			[39, 1],
			[20, 4],
			[20, 3],
			[20, 4],
			[20, 2],
			[20, 2],
			[20, 1],
			[42, 1],
			[42, 6],
			[42, 5],
			[43, 1],
			[43, 3],
			[45, 4],
			[45, 4],
			[45, 6],
			[45, 4],
			[45, 4],
			[45, 4],
			[45, 8],
			[45, 4],
			[45, 4],
			[45, 4],
			[45, 6],
			[45, 4],
			[45, 4],
			[45, 4],
			[45, 4],
			[45, 4],
			[45, 1],
			[41, 2],
			[41, 3],
			[41, 3],
			[41, 1],
			[41, 3],
			[41, 4],
			[76, 1],
			[76, 2],
			[76, 1],
			[76, 1],
			[72, 1],
			[72, 2],
			[73, 3],
			[30, 1],
			[30, 2],
			[30, 1],
			[30, 1],
			[83, 1],
			[83, 1],
			[83, 1],
			[83, 1],
			[83, 1],
			[83, 1],
			[83, 1],
			[83, 1],
			[83, 1],
			[83, 1],
			[83, 1],
			[28, 1],
			[28, 2],
			[28, 1],
			[28, 1],
			[24, 5],
			[25, 5],
			[26, 2],
			[26, 4],
			[26, 3],
			[26, 5],
			[26, 3],
			[26, 5],
			[26, 5],
			[26, 7],
			[26, 2],
			[26, 4],
			[26, 2],
			[26, 4],
			[26, 4],
			[26, 6],
			[22, 5],
			[23, 5],
			[23, 5],
			[23, 9],
			[23, 9],
			[23, 7],
			[23, 7],
			[103, 1],
			[103, 3],
			[92, 1],
			[92, 3],
			[107, 1],
			[107, 2],
			[108, 1],
			[108, 1],
			[108, 1],
			[108, 1],
			[108, 1],
			[108, 1],
			[108, 1],
			[108, 1],
			[113, 1],
			[113, 1],
			[113, 1],
			[113, 1],
			[113, 1],
			[113, 1],
			[113, 1],
			[113, 1],
			[113, 1],
			[113, 1],
			[113, 1],
			[82, 1],
			[82, 1],
			[82, 1],
			[82, 1],
			[91, 1],
			[91, 1],
			[91, 1],
			[91, 1],
			[91, 1],
			[91, 1],
			[91, 1],
			[91, 1],
			[91, 1],
			[91, 1],
			[91, 1],
			[79, 1],
			[79, 1],
			[120, 1],
			[120, 1],
			[120, 1],
			[120, 1],
			[120, 1],
			[120, 1],
			[120, 1],
			[120, 1],
			[120, 1],
			[120, 1],
			[120, 1],
			[47, 1],
			[47, 2],
			[101, 1],
			[101, 2],
			[33, 1],
			[33, 1],
			[33, 1],
			[33, 1]
		],
		performAction: h(function(e, t, r, i, n, a, s) {
			var o = a.length - 1;
			switch (n) {
				case 2:
				case 28:
				case 29:
				case 30:
				case 31:
				case 32:
					this.$ = [];
					break;
				case 3:
					(!Array.isArray(a[o]) || a[o].length > 0) && a[o - 1].push(a[o]), this.$ = a[o - 1];
					break;
				case 4:
				case 183:
				case 44:
				case 54:
				case 76:
				case 181:
					this.$ = a[o];
					break;
				case 11:
					i.setDirection("TB"), this.$ = "TB";
					break;
				case 12:
					i.setDirection(a[o - 1]), this.$ = a[o - 1];
					break;
				case 27:
					this.$ = a[o - 1].nodes;
					break;
				case 33:
					this.$ = i.addSubGraph(a[o - 6], a[o - 1], a[o - 4]);
					break;
				case 34:
					this.$ = i.addSubGraph(a[o - 3], a[o - 1], a[o - 3]);
					break;
				case 35:
					this.$ = i.addSubGraph(void 0, a[o - 1], void 0);
					break;
				case 37:
					this.$ = a[o].trim(), i.setAccTitle(this.$);
					break;
				case 38:
				case 39:
					this.$ = a[o].trim(), i.setAccDescription(this.$);
					break;
				case 43:
				case 133:
					this.$ = a[o - 1] + a[o];
					break;
				case 45:
					i.addVertex(a[o - 1][a[o - 1].length - 1], void 0, void 0, void 0, void 0, void 0, void 0, a[o]), i.addLink(a[o - 3].stmt, a[o - 1], a[o - 2]), this.$ = {
						stmt: a[o - 1],
						nodes: a[o - 1].concat(a[o - 3].nodes)
					};
					break;
				case 46:
					i.addLink(a[o - 2].stmt, a[o], a[o - 1]), this.$ = {
						stmt: a[o],
						nodes: a[o].concat(a[o - 2].nodes)
					};
					break;
				case 47:
					i.addLink(a[o - 3].stmt, a[o - 1], a[o - 2]), this.$ = {
						stmt: a[o - 1],
						nodes: a[o - 1].concat(a[o - 3].nodes)
					};
					break;
				case 48:
					this.$ = {
						stmt: a[o - 1],
						nodes: a[o - 1]
					};
					break;
				case 49:
					i.addVertex(a[o - 1][a[o - 1].length - 1], void 0, void 0, void 0, void 0, void 0, void 0, a[o]), this.$ = {
						stmt: a[o - 1],
						nodes: a[o - 1],
						shapeData: a[o]
					};
					break;
				case 50:
					this.$ = {
						stmt: a[o],
						nodes: a[o]
					};
					break;
				case 51:
				case 128:
				case 130:
					this.$ = [a[o]];
					break;
				case 52:
					i.addVertex(a[o - 5][a[o - 5].length - 1], void 0, void 0, void 0, void 0, void 0, void 0, a[o - 4]), this.$ = a[o - 5].concat(a[o]);
					break;
				case 53:
					this.$ = a[o - 4].concat(a[o]);
					break;
				case 55:
					this.$ = a[o - 2], i.setClass(a[o - 2], a[o]);
					break;
				case 56:
					this.$ = a[o - 3], i.addVertex(a[o - 3], a[o - 1], "square");
					break;
				case 57:
					this.$ = a[o - 3], i.addVertex(a[o - 3], a[o - 1], "doublecircle");
					break;
				case 58:
					this.$ = a[o - 5], i.addVertex(a[o - 5], a[o - 2], "circle");
					break;
				case 59:
					this.$ = a[o - 3], i.addVertex(a[o - 3], a[o - 1], "ellipse");
					break;
				case 60:
					this.$ = a[o - 3], i.addVertex(a[o - 3], a[o - 1], "stadium");
					break;
				case 61:
					this.$ = a[o - 3], i.addVertex(a[o - 3], a[o - 1], "subroutine");
					break;
				case 62:
					this.$ = a[o - 7], i.addVertex(a[o - 7], a[o - 1], "rect", void 0, void 0, void 0, Object.fromEntries([[a[o - 5], a[o - 3]]]));
					break;
				case 63:
					this.$ = a[o - 3], i.addVertex(a[o - 3], a[o - 1], "cylinder");
					break;
				case 64:
					this.$ = a[o - 3], i.addVertex(a[o - 3], a[o - 1], "round");
					break;
				case 65:
					this.$ = a[o - 3], i.addVertex(a[o - 3], a[o - 1], "diamond");
					break;
				case 66:
					this.$ = a[o - 5], i.addVertex(a[o - 5], a[o - 2], "hexagon");
					break;
				case 67:
					this.$ = a[o - 3], i.addVertex(a[o - 3], a[o - 1], "odd");
					break;
				case 68:
					this.$ = a[o - 3], i.addVertex(a[o - 3], a[o - 1], "trapezoid");
					break;
				case 69:
					this.$ = a[o - 3], i.addVertex(a[o - 3], a[o - 1], "inv_trapezoid");
					break;
				case 70:
					this.$ = a[o - 3], i.addVertex(a[o - 3], a[o - 1], "lean_right");
					break;
				case 71:
					this.$ = a[o - 3], i.addVertex(a[o - 3], a[o - 1], "lean_left");
					break;
				case 72:
					this.$ = a[o], i.addVertex(a[o]);
					break;
				case 73:
					a[o - 1].text = a[o], this.$ = a[o - 1];
					break;
				case 74:
				case 75:
					a[o - 2].text = a[o - 1], this.$ = a[o - 2];
					break;
				case 77:
					var l = i.destructLink(a[o], a[o - 2]);
					this.$ = {
						type: l.type,
						stroke: l.stroke,
						length: l.length,
						text: a[o - 1]
					};
					break;
				case 78:
					var l = i.destructLink(a[o], a[o - 2]);
					this.$ = {
						type: l.type,
						stroke: l.stroke,
						length: l.length,
						text: a[o - 1],
						id: a[o - 3]
					};
					break;
				case 79:
				case 86:
				case 101:
				case 103:
					this.$ = {
						text: a[o],
						type: "text"
					};
					break;
				case 80:
				case 87:
				case 102:
					this.$ = {
						text: a[o - 1].text + "" + a[o],
						type: a[o - 1].type
					};
					break;
				case 81:
				case 88:
					this.$ = {
						text: a[o],
						type: "string"
					};
					break;
				case 82:
				case 89:
				case 104:
					this.$ = {
						text: a[o],
						type: "markdown"
					};
					break;
				case 83:
					var l = i.destructLink(a[o]);
					this.$ = {
						type: l.type,
						stroke: l.stroke,
						length: l.length
					};
					break;
				case 84:
					var l = i.destructLink(a[o]);
					this.$ = {
						type: l.type,
						stroke: l.stroke,
						length: l.length,
						id: a[o - 1]
					};
					break;
				case 85:
					this.$ = a[o - 1];
					break;
				case 105:
					this.$ = a[o - 4], i.addClass(a[o - 2], a[o]);
					break;
				case 106:
					this.$ = a[o - 4], i.setClass(a[o - 2], a[o]);
					break;
				case 107:
				case 115:
					this.$ = a[o - 1], i.setClickEvent(a[o - 1], a[o]);
					break;
				case 108:
				case 116:
					this.$ = a[o - 3], i.setClickEvent(a[o - 3], a[o - 2]), i.setTooltip(a[o - 3], a[o]);
					break;
				case 109:
					this.$ = a[o - 2], i.setClickEvent(a[o - 2], a[o - 1], a[o]);
					break;
				case 110:
					this.$ = a[o - 4], i.setClickEvent(a[o - 4], a[o - 3], a[o - 2]), i.setTooltip(a[o - 4], a[o]);
					break;
				case 111:
					this.$ = a[o - 2], i.setLink(a[o - 2], a[o]);
					break;
				case 112:
					this.$ = a[o - 4], i.setLink(a[o - 4], a[o - 2]), i.setTooltip(a[o - 4], a[o]);
					break;
				case 113:
					this.$ = a[o - 4], i.setLink(a[o - 4], a[o - 2], a[o]);
					break;
				case 114:
					this.$ = a[o - 6], i.setLink(a[o - 6], a[o - 4], a[o]), i.setTooltip(a[o - 6], a[o - 2]);
					break;
				case 117:
					this.$ = a[o - 1], i.setLink(a[o - 1], a[o]);
					break;
				case 118:
					this.$ = a[o - 3], i.setLink(a[o - 3], a[o - 2]), i.setTooltip(a[o - 3], a[o]);
					break;
				case 119:
					this.$ = a[o - 3], i.setLink(a[o - 3], a[o - 2], a[o]);
					break;
				case 120:
					this.$ = a[o - 5], i.setLink(a[o - 5], a[o - 4], a[o]), i.setTooltip(a[o - 5], a[o - 2]);
					break;
				case 121:
					this.$ = a[o - 4], i.addVertex(a[o - 2], void 0, void 0, a[o]);
					break;
				case 122:
					this.$ = a[o - 4], i.updateLink([a[o - 2]], a[o]);
					break;
				case 123:
					this.$ = a[o - 4], i.updateLink(a[o - 2], a[o]);
					break;
				case 124:
					this.$ = a[o - 8], i.updateLinkInterpolate([a[o - 6]], a[o - 2]), i.updateLink([a[o - 6]], a[o]);
					break;
				case 125:
					this.$ = a[o - 8], i.updateLinkInterpolate(a[o - 6], a[o - 2]), i.updateLink(a[o - 6], a[o]);
					break;
				case 126:
					this.$ = a[o - 6], i.updateLinkInterpolate([a[o - 4]], a[o]);
					break;
				case 127:
					this.$ = a[o - 6], i.updateLinkInterpolate(a[o - 4], a[o]);
					break;
				case 129:
				case 131:
					a[o - 2].push(a[o]), this.$ = a[o - 2];
					break;
				case 182:
				case 184:
					this.$ = a[o - 1] + "" + a[o];
					break;
				case 185:
					this.$ = {
						stmt: "dir",
						value: "TB"
					};
					break;
				case 186:
					this.$ = {
						stmt: "dir",
						value: "BT"
					};
					break;
				case 187:
					this.$ = {
						stmt: "dir",
						value: "RL"
					};
					break;
				case 188: this.$ = {
					stmt: "dir",
					value: "LR"
				};
			}
		}, "anonymous"),
		table: [
			{
				3: 1,
				4: 2,
				9: t,
				10: r,
				12: i
			},
			{ 1: [3] },
			e(n, a, { 5: 6 }),
			{
				4: 7,
				9: t,
				10: r,
				12: i
			},
			{
				4: 8,
				9: t,
				10: r,
				12: i
			},
			{
				13: [1, 9],
				14: [1, 10]
			},
			{
				1: [2, 1],
				6: 11,
				7: 12,
				8: s,
				9: o,
				10: l,
				11: u,
				20: 17,
				22: 18,
				23: 19,
				24: 20,
				25: 21,
				26: 22,
				27: d,
				33: 24,
				34: p,
				36: f,
				38: g,
				42: 28,
				43: 38,
				44: m,
				45: 39,
				47: 40,
				60: y,
				84: v,
				85: x,
				86: b,
				87: w,
				88: k,
				89: T,
				102: _,
				105: E,
				106: C,
				109: S,
				111: A,
				113: 41,
				114: L,
				115: R,
				116: N,
				121: I,
				122: M,
				123: D,
				124: O
			},
			e(n, [2, 9]),
			e(n, [2, 10]),
			e(n, [2, 11]),
			{
				8: [1, 54],
				9: [1, 55],
				10: $,
				15: 53,
				18: 56
			},
			e(P, [2, 3]),
			e(P, [2, 4]),
			e(P, [2, 5]),
			e(P, [2, 6]),
			e(P, [2, 7]),
			e(P, [2, 8]),
			{
				8: B,
				9: F,
				11: z,
				21: 58,
				41: 59,
				72: 63,
				75: [1, 64],
				77: [1, 66],
				78: [1, 65]
			},
			{
				8: B,
				9: F,
				11: z,
				21: 67
			},
			{
				8: B,
				9: F,
				11: z,
				21: 68
			},
			{
				8: B,
				9: F,
				11: z,
				21: 69
			},
			{
				8: B,
				9: F,
				11: z,
				21: 70
			},
			{
				8: B,
				9: F,
				11: z,
				21: 71
			},
			{
				8: B,
				9: F,
				10: [1, 72],
				11: z,
				21: 73
			},
			e(P, [2, 36]),
			{ 35: [1, 74] },
			{ 37: [1, 75] },
			e(P, [2, 39]),
			e(U, [2, 50], {
				18: 76,
				39: 77,
				10: $,
				40: G
			}),
			{ 10: [1, 79] },
			{ 10: [1, 80] },
			{ 10: [1, 81] },
			{ 10: [1, 82] },
			{
				14: q,
				44: j,
				60: W,
				80: [1, 86],
				89: Y,
				95: [1, 83],
				97: [1, 84],
				101: 85,
				105: V,
				106: H,
				109: X,
				111: K,
				114: Z,
				115: Q,
				116: J,
				120: 87
			},
			e(P, [2, 185]),
			e(P, [2, 186]),
			e(P, [2, 187]),
			e(P, [2, 188]),
			e(ee, [2, 51]),
			e(ee, [2, 54], { 46: [1, 99] }),
			e(et, [2, 72], {
				113: 112,
				29: [1, 100],
				44: m,
				48: [1, 101],
				50: [1, 102],
				52: [1, 103],
				54: [1, 104],
				56: [1, 105],
				58: [1, 106],
				60: y,
				63: [1, 107],
				65: [1, 108],
				67: [1, 109],
				68: [1, 110],
				70: [1, 111],
				89: T,
				102: _,
				105: E,
				106: C,
				109: S,
				111: A,
				114: L,
				115: R,
				116: N
			}),
			e(er, [2, 181]),
			e(er, [2, 142]),
			e(er, [2, 143]),
			e(er, [2, 144]),
			e(er, [2, 145]),
			e(er, [2, 146]),
			e(er, [2, 147]),
			e(er, [2, 148]),
			e(er, [2, 149]),
			e(er, [2, 150]),
			e(er, [2, 151]),
			e(er, [2, 152]),
			e(n, [2, 12]),
			e(n, [2, 18]),
			e(n, [2, 19]),
			{ 9: [1, 113] },
			e(ei, [2, 26], {
				18: 114,
				10: $
			}),
			e(P, [2, 27]),
			{
				42: 115,
				43: 38,
				44: m,
				45: 39,
				47: 40,
				60: y,
				89: T,
				102: _,
				105: E,
				106: C,
				109: S,
				111: A,
				113: 41,
				114: L,
				115: R,
				116: N
			},
			e(P, [2, 40]),
			e(P, [2, 41]),
			e(P, [2, 42]),
			e(en, [2, 76], {
				73: 116,
				62: [1, 118],
				74: [1, 117]
			}),
			{
				76: 119,
				79: 120,
				80: ea,
				81: es,
				116: eo,
				119: el
			},
			{
				75: [1, 125],
				77: [1, 126]
			},
			e(ec, [2, 83]),
			e(P, [2, 28]),
			e(P, [2, 29]),
			e(P, [2, 30]),
			e(P, [2, 31]),
			e(P, [2, 32]),
			{
				10: eh,
				12: eu,
				14: ed,
				27: ep,
				28: 127,
				32: ef,
				44: eg,
				60: em,
				75: ey,
				80: [1, 129],
				81: [1, 130],
				83: 140,
				84: ev,
				85: ex,
				86: eb,
				87: ew,
				88: ek,
				89: eT,
				90: e_,
				91: 128,
				105: eE,
				109: eC,
				111: eS,
				114: eA,
				115: eL,
				116: eR
			},
			e(eN, a, { 5: 153 }),
			e(P, [2, 37]),
			e(P, [2, 38]),
			e(U, [2, 48], { 44: eI }),
			e(U, [2, 49], {
				18: 155,
				10: $,
				40: eM
			}),
			e(ee, [2, 44]),
			{
				44: m,
				47: 157,
				60: y,
				89: T,
				102: _,
				105: E,
				106: C,
				109: S,
				111: A,
				113: 41,
				114: L,
				115: R,
				116: N
			},
			{
				102: [1, 158],
				103: 159,
				105: [1, 160]
			},
			{
				44: m,
				47: 161,
				60: y,
				89: T,
				102: _,
				105: E,
				106: C,
				109: S,
				111: A,
				113: 41,
				114: L,
				115: R,
				116: N
			},
			{
				44: m,
				47: 162,
				60: y,
				89: T,
				102: _,
				105: E,
				106: C,
				109: S,
				111: A,
				113: 41,
				114: L,
				115: R,
				116: N
			},
			e(eD, [2, 107], {
				10: [1, 163],
				96: [1, 164]
			}),
			{ 80: [1, 165] },
			e(eD, [2, 115], {
				120: 167,
				10: [1, 166],
				14: q,
				44: j,
				60: W,
				89: Y,
				105: V,
				106: H,
				109: X,
				111: K,
				114: Z,
				115: Q,
				116: J
			}),
			e(eD, [2, 117], { 10: [1, 168] }),
			e(eO, [2, 183]),
			e(eO, [2, 170]),
			e(eO, [2, 171]),
			e(eO, [2, 172]),
			e(eO, [2, 173]),
			e(eO, [2, 174]),
			e(eO, [2, 175]),
			e(eO, [2, 176]),
			e(eO, [2, 177]),
			e(eO, [2, 178]),
			e(eO, [2, 179]),
			e(eO, [2, 180]),
			{
				44: m,
				47: 169,
				60: y,
				89: T,
				102: _,
				105: E,
				106: C,
				109: S,
				111: A,
				113: 41,
				114: L,
				115: R,
				116: N
			},
			{
				30: 170,
				67: e$,
				80: eP,
				81: eB,
				82: 171,
				116: eF,
				117: ez,
				118: eU
			},
			{
				30: 178,
				67: e$,
				80: eP,
				81: eB,
				82: 171,
				116: eF,
				117: ez,
				118: eU
			},
			{
				30: 180,
				50: [1, 179],
				67: e$,
				80: eP,
				81: eB,
				82: 171,
				116: eF,
				117: ez,
				118: eU
			},
			{
				30: 181,
				67: e$,
				80: eP,
				81: eB,
				82: 171,
				116: eF,
				117: ez,
				118: eU
			},
			{
				30: 182,
				67: e$,
				80: eP,
				81: eB,
				82: 171,
				116: eF,
				117: ez,
				118: eU
			},
			{
				30: 183,
				67: e$,
				80: eP,
				81: eB,
				82: 171,
				116: eF,
				117: ez,
				118: eU
			},
			{ 109: [1, 184] },
			{
				30: 185,
				67: e$,
				80: eP,
				81: eB,
				82: 171,
				116: eF,
				117: ez,
				118: eU
			},
			{
				30: 186,
				65: [1, 187],
				67: e$,
				80: eP,
				81: eB,
				82: 171,
				116: eF,
				117: ez,
				118: eU
			},
			{
				30: 188,
				67: e$,
				80: eP,
				81: eB,
				82: 171,
				116: eF,
				117: ez,
				118: eU
			},
			{
				30: 189,
				67: e$,
				80: eP,
				81: eB,
				82: 171,
				116: eF,
				117: ez,
				118: eU
			},
			{
				30: 190,
				67: e$,
				80: eP,
				81: eB,
				82: 171,
				116: eF,
				117: ez,
				118: eU
			},
			e(er, [2, 182]),
			e(n, [2, 20]),
			e(ei, [2, 25]),
			e(U, [2, 46], {
				39: 191,
				18: 192,
				10: $,
				40: G
			}),
			e(en, [2, 73], { 10: [1, 193] }),
			{ 10: [1, 194] },
			{
				30: 195,
				67: e$,
				80: eP,
				81: eB,
				82: 171,
				116: eF,
				117: ez,
				118: eU
			},
			{
				77: [1, 196],
				79: 197,
				116: eo,
				119: el
			},
			e(eG, [2, 79]),
			e(eG, [2, 81]),
			e(eG, [2, 82]),
			e(eG, [2, 168]),
			e(eG, [2, 169]),
			{
				76: 198,
				79: 120,
				80: ea,
				81: es,
				116: eo,
				119: el
			},
			e(ec, [2, 84]),
			{
				8: B,
				9: F,
				10: eh,
				11: z,
				12: eu,
				14: ed,
				21: 200,
				27: ep,
				29: [1, 199],
				32: ef,
				44: eg,
				60: em,
				75: ey,
				83: 140,
				84: ev,
				85: ex,
				86: eb,
				87: ew,
				88: ek,
				89: eT,
				90: e_,
				91: 201,
				105: eE,
				109: eC,
				111: eS,
				114: eA,
				115: eL,
				116: eR
			},
			e(eq, [2, 101]),
			e(eq, [2, 103]),
			e(eq, [2, 104]),
			e(eq, [2, 157]),
			e(eq, [2, 158]),
			e(eq, [2, 159]),
			e(eq, [2, 160]),
			e(eq, [2, 161]),
			e(eq, [2, 162]),
			e(eq, [2, 163]),
			e(eq, [2, 164]),
			e(eq, [2, 165]),
			e(eq, [2, 166]),
			e(eq, [2, 167]),
			e(eq, [2, 90]),
			e(eq, [2, 91]),
			e(eq, [2, 92]),
			e(eq, [2, 93]),
			e(eq, [2, 94]),
			e(eq, [2, 95]),
			e(eq, [2, 96]),
			e(eq, [2, 97]),
			e(eq, [2, 98]),
			e(eq, [2, 99]),
			e(eq, [2, 100]),
			{
				6: 11,
				7: 12,
				8: s,
				9: o,
				10: l,
				11: u,
				20: 17,
				22: 18,
				23: 19,
				24: 20,
				25: 21,
				26: 22,
				27: d,
				32: [1, 202],
				33: 24,
				34: p,
				36: f,
				38: g,
				42: 28,
				43: 38,
				44: m,
				45: 39,
				47: 40,
				60: y,
				84: v,
				85: x,
				86: b,
				87: w,
				88: k,
				89: T,
				102: _,
				105: E,
				106: C,
				109: S,
				111: A,
				113: 41,
				114: L,
				115: R,
				116: N,
				121: I,
				122: M,
				123: D,
				124: O
			},
			{
				10: $,
				18: 203
			},
			{ 44: [1, 204] },
			e(ee, [2, 43]),
			{
				10: [1, 205],
				44: m,
				60: y,
				89: T,
				102: _,
				105: E,
				106: C,
				109: S,
				111: A,
				113: 112,
				114: L,
				115: R,
				116: N
			},
			{ 10: [1, 206] },
			{
				10: [1, 207],
				106: [1, 208]
			},
			e(ej, [2, 128]),
			{
				10: [1, 209],
				44: m,
				60: y,
				89: T,
				102: _,
				105: E,
				106: C,
				109: S,
				111: A,
				113: 112,
				114: L,
				115: R,
				116: N
			},
			{
				10: [1, 210],
				44: m,
				60: y,
				89: T,
				102: _,
				105: E,
				106: C,
				109: S,
				111: A,
				113: 112,
				114: L,
				115: R,
				116: N
			},
			{ 80: [1, 211] },
			e(eD, [2, 109], { 10: [1, 212] }),
			e(eD, [2, 111], { 10: [1, 213] }),
			{ 80: [1, 214] },
			e(eO, [2, 184]),
			{
				80: [1, 215],
				98: [1, 216]
			},
			e(ee, [2, 55], {
				113: 112,
				44: m,
				60: y,
				89: T,
				102: _,
				105: E,
				106: C,
				109: S,
				111: A,
				114: L,
				115: R,
				116: N
			}),
			{
				31: [1, 217],
				67: e$,
				82: 218,
				116: eF,
				117: ez,
				118: eU
			},
			e(eW, [2, 86]),
			e(eW, [2, 88]),
			e(eW, [2, 89]),
			e(eW, [2, 153]),
			e(eW, [2, 154]),
			e(eW, [2, 155]),
			e(eW, [2, 156]),
			{
				49: [1, 219],
				67: e$,
				82: 218,
				116: eF,
				117: ez,
				118: eU
			},
			{
				30: 220,
				67: e$,
				80: eP,
				81: eB,
				82: 171,
				116: eF,
				117: ez,
				118: eU
			},
			{
				51: [1, 221],
				67: e$,
				82: 218,
				116: eF,
				117: ez,
				118: eU
			},
			{
				53: [1, 222],
				67: e$,
				82: 218,
				116: eF,
				117: ez,
				118: eU
			},
			{
				55: [1, 223],
				67: e$,
				82: 218,
				116: eF,
				117: ez,
				118: eU
			},
			{
				57: [1, 224],
				67: e$,
				82: 218,
				116: eF,
				117: ez,
				118: eU
			},
			{ 60: [1, 225] },
			{
				64: [1, 226],
				67: e$,
				82: 218,
				116: eF,
				117: ez,
				118: eU
			},
			{
				66: [1, 227],
				67: e$,
				82: 218,
				116: eF,
				117: ez,
				118: eU
			},
			{
				30: 228,
				67: e$,
				80: eP,
				81: eB,
				82: 171,
				116: eF,
				117: ez,
				118: eU
			},
			{
				31: [1, 229],
				67: e$,
				82: 218,
				116: eF,
				117: ez,
				118: eU
			},
			{
				67: e$,
				69: [1, 230],
				71: [1, 231],
				82: 218,
				116: eF,
				117: ez,
				118: eU
			},
			{
				67: e$,
				69: [1, 233],
				71: [1, 232],
				82: 218,
				116: eF,
				117: ez,
				118: eU
			},
			e(U, [2, 45], {
				18: 155,
				10: $,
				40: eM
			}),
			e(U, [2, 47], { 44: eI }),
			e(en, [2, 75]),
			e(en, [2, 74]),
			{
				62: [1, 234],
				67: e$,
				82: 218,
				116: eF,
				117: ez,
				118: eU
			},
			e(en, [2, 77]),
			e(eG, [2, 80]),
			{
				77: [1, 235],
				79: 197,
				116: eo,
				119: el
			},
			{
				30: 236,
				67: e$,
				80: eP,
				81: eB,
				82: 171,
				116: eF,
				117: ez,
				118: eU
			},
			e(eN, a, { 5: 237 }),
			e(eq, [2, 102]),
			e(P, [2, 35]),
			{
				43: 238,
				44: m,
				45: 39,
				47: 40,
				60: y,
				89: T,
				102: _,
				105: E,
				106: C,
				109: S,
				111: A,
				113: 41,
				114: L,
				115: R,
				116: N
			},
			{
				10: $,
				18: 239
			},
			{
				10: eY,
				60: eV,
				84: eH,
				92: 240,
				105: eX,
				107: 241,
				108: 242,
				109: eK,
				110: eZ,
				111: eQ,
				112: eJ
			},
			{
				10: eY,
				60: eV,
				84: eH,
				92: 251,
				104: [1, 252],
				105: eX,
				107: 241,
				108: 242,
				109: eK,
				110: eZ,
				111: eQ,
				112: eJ
			},
			{
				10: eY,
				60: eV,
				84: eH,
				92: 253,
				104: [1, 254],
				105: eX,
				107: 241,
				108: 242,
				109: eK,
				110: eZ,
				111: eQ,
				112: eJ
			},
			{ 105: [1, 255] },
			{
				10: eY,
				60: eV,
				84: eH,
				92: 256,
				105: eX,
				107: 241,
				108: 242,
				109: eK,
				110: eZ,
				111: eQ,
				112: eJ
			},
			{
				44: m,
				47: 257,
				60: y,
				89: T,
				102: _,
				105: E,
				106: C,
				109: S,
				111: A,
				113: 41,
				114: L,
				115: R,
				116: N
			},
			e(eD, [2, 108]),
			{ 80: [1, 258] },
			{
				80: [1, 259],
				98: [1, 260]
			},
			e(eD, [2, 116]),
			e(eD, [2, 118], { 10: [1, 261] }),
			e(eD, [2, 119]),
			e(et, [2, 56]),
			e(eW, [2, 87]),
			e(et, [2, 57]),
			{
				51: [1, 262],
				67: e$,
				82: 218,
				116: eF,
				117: ez,
				118: eU
			},
			e(et, [2, 64]),
			e(et, [2, 59]),
			e(et, [2, 60]),
			e(et, [2, 61]),
			{ 109: [1, 263] },
			e(et, [2, 63]),
			e(et, [2, 65]),
			{
				66: [1, 264],
				67: e$,
				82: 218,
				116: eF,
				117: ez,
				118: eU
			},
			e(et, [2, 67]),
			e(et, [2, 68]),
			e(et, [2, 70]),
			e(et, [2, 69]),
			e(et, [2, 71]),
			e([
				10,
				44,
				60,
				89,
				102,
				105,
				106,
				109,
				111,
				114,
				115,
				116
			], [2, 85]),
			e(en, [2, 78]),
			{
				31: [1, 265],
				67: e$,
				82: 218,
				116: eF,
				117: ez,
				118: eU
			},
			{
				6: 11,
				7: 12,
				8: s,
				9: o,
				10: l,
				11: u,
				20: 17,
				22: 18,
				23: 19,
				24: 20,
				25: 21,
				26: 22,
				27: d,
				32: [1, 266],
				33: 24,
				34: p,
				36: f,
				38: g,
				42: 28,
				43: 38,
				44: m,
				45: 39,
				47: 40,
				60: y,
				84: v,
				85: x,
				86: b,
				87: w,
				88: k,
				89: T,
				102: _,
				105: E,
				106: C,
				109: S,
				111: A,
				113: 41,
				114: L,
				115: R,
				116: N,
				121: I,
				122: M,
				123: D,
				124: O
			},
			e(ee, [2, 53]),
			{
				43: 267,
				44: m,
				45: 39,
				47: 40,
				60: y,
				89: T,
				102: _,
				105: E,
				106: C,
				109: S,
				111: A,
				113: 41,
				114: L,
				115: R,
				116: N
			},
			e(eD, [2, 121], { 106: e0 }),
			e(e1, [2, 130], {
				108: 269,
				10: eY,
				60: eV,
				84: eH,
				105: eX,
				109: eK,
				110: eZ,
				111: eQ,
				112: eJ
			}),
			e(e2, [2, 132]),
			e(e2, [2, 134]),
			e(e2, [2, 135]),
			e(e2, [2, 136]),
			e(e2, [2, 137]),
			e(e2, [2, 138]),
			e(e2, [2, 139]),
			e(e2, [2, 140]),
			e(e2, [2, 141]),
			e(eD, [2, 122], { 106: e0 }),
			{ 10: [1, 270] },
			e(eD, [2, 123], { 106: e0 }),
			{ 10: [1, 271] },
			e(ej, [2, 129]),
			e(eD, [2, 105], { 106: e0 }),
			e(eD, [2, 106], {
				113: 112,
				44: m,
				60: y,
				89: T,
				102: _,
				105: E,
				106: C,
				109: S,
				111: A,
				114: L,
				115: R,
				116: N
			}),
			e(eD, [2, 110]),
			e(eD, [2, 112], { 10: [1, 272] }),
			e(eD, [2, 113]),
			{ 98: [1, 273] },
			{ 51: [1, 274] },
			{ 62: [1, 275] },
			{ 66: [1, 276] },
			{
				8: B,
				9: F,
				11: z,
				21: 277
			},
			e(P, [2, 34]),
			e(ee, [2, 52]),
			{
				10: eY,
				60: eV,
				84: eH,
				105: eX,
				107: 278,
				108: 242,
				109: eK,
				110: eZ,
				111: eQ,
				112: eJ
			},
			e(e2, [2, 133]),
			{
				14: q,
				44: j,
				60: W,
				89: Y,
				101: 279,
				105: V,
				106: H,
				109: X,
				111: K,
				114: Z,
				115: Q,
				116: J,
				120: 87
			},
			{
				14: q,
				44: j,
				60: W,
				89: Y,
				101: 280,
				105: V,
				106: H,
				109: X,
				111: K,
				114: Z,
				115: Q,
				116: J,
				120: 87
			},
			{ 98: [1, 281] },
			e(eD, [2, 120]),
			e(et, [2, 58]),
			{
				30: 282,
				67: e$,
				80: eP,
				81: eB,
				82: 171,
				116: eF,
				117: ez,
				118: eU
			},
			e(et, [2, 66]),
			e(eN, a, { 5: 283 }),
			e(e1, [2, 131], {
				108: 269,
				10: eY,
				60: eV,
				84: eH,
				105: eX,
				109: eK,
				110: eZ,
				111: eQ,
				112: eJ
			}),
			e(eD, [2, 126], {
				120: 167,
				10: [1, 284],
				14: q,
				44: j,
				60: W,
				89: Y,
				105: V,
				106: H,
				109: X,
				111: K,
				114: Z,
				115: Q,
				116: J
			}),
			e(eD, [2, 127], {
				120: 167,
				10: [1, 285],
				14: q,
				44: j,
				60: W,
				89: Y,
				105: V,
				106: H,
				109: X,
				111: K,
				114: Z,
				115: Q,
				116: J
			}),
			e(eD, [2, 114]),
			{
				31: [1, 286],
				67: e$,
				82: 218,
				116: eF,
				117: ez,
				118: eU
			},
			{
				6: 11,
				7: 12,
				8: s,
				9: o,
				10: l,
				11: u,
				20: 17,
				22: 18,
				23: 19,
				24: 20,
				25: 21,
				26: 22,
				27: d,
				32: [1, 287],
				33: 24,
				34: p,
				36: f,
				38: g,
				42: 28,
				43: 38,
				44: m,
				45: 39,
				47: 40,
				60: y,
				84: v,
				85: x,
				86: b,
				87: w,
				88: k,
				89: T,
				102: _,
				105: E,
				106: C,
				109: S,
				111: A,
				113: 41,
				114: L,
				115: R,
				116: N,
				121: I,
				122: M,
				123: D,
				124: O
			},
			{
				10: eY,
				60: eV,
				84: eH,
				92: 288,
				105: eX,
				107: 241,
				108: 242,
				109: eK,
				110: eZ,
				111: eQ,
				112: eJ
			},
			{
				10: eY,
				60: eV,
				84: eH,
				92: 289,
				105: eX,
				107: 241,
				108: 242,
				109: eK,
				110: eZ,
				111: eQ,
				112: eJ
			},
			e(et, [2, 62]),
			e(P, [2, 33]),
			e(eD, [2, 124], { 106: e0 }),
			e(eD, [2, 125], { 106: e0 })
		],
		defaultActions: {},
		parseError: h(function(e, t) {
			if (t.recoverable) this.trace(e);
			else {
				var r = Error(e);
				throw r.hash = t, r;
			}
		}, "parseError"),
		parse: h(function(e) {
			var t = this, r = [0], i = [], n = [null], a = [], s = this.table, o = "", l = 0, u = 0, d = 0, p = a.slice.call(arguments, 1), f = Object.create(this.lexer), g = {};
			for (var m in this.yy) Object.prototype.hasOwnProperty.call(this.yy, m) && (g[m] = this.yy[m]);
			f.setInput(e, g), g.lexer = f, g.parser = this, typeof f.yylloc > "u" && (f.yylloc = {});
			var y = f.yylloc;
			a.push(y);
			var v = f.options && f.options.ranges;
			function x() {
				var e;
				return "number" != typeof (e = i.pop() || f.lex() || 1) && (e instanceof Array && (e = (i = e).pop()), e = t.symbols_[e] || e), e;
			}
			"function" == typeof g.parseError ? this.parseError = g.parseError : this.parseError = Object.getPrototypeOf(this).parseError, h(function(e) {
				r.length = r.length - 2 * e, n.length = n.length - e, a.length = a.length - e;
			}, "popStack"), h(x, "lex");
			for (var b, w, k, T, _, E, C, S, A, L = {};;) {
				if (k = r[r.length - 1], this.defaultActions[k] ? T = this.defaultActions[k] : ((null === b || typeof b > "u") && (b = x()), T = s[k] && s[k][b]), typeof T > "u" || !T.length || !T[0]) {
					var R = "";
					for (E in A = [], s[k]) this.terminals_[E] && E > 2 && A.push("'" + this.terminals_[E] + "'");
					R = f.showPosition ? "Parse error on line " + (l + 1) + `:
` + f.showPosition() + `
Expecting ` + A.join(", ") + ", got '" + (this.terminals_[b] || b) + "'" : "Parse error on line " + (l + 1) + ": Unexpected " + (1 == b ? "end of input" : "'" + (this.terminals_[b] || b) + "'"), this.parseError(R, {
						text: f.match,
						token: this.terminals_[b] || b,
						line: f.yylineno,
						loc: y,
						expected: A
					});
				}
				if (T[0] instanceof Array && T.length > 1) throw Error("Parse Error: multiple actions possible at state: " + k + ", token: " + b);
				switch (T[0]) {
					case 1:
						r.push(b), n.push(f.yytext), a.push(f.yylloc), r.push(T[1]), b = null, w ? (b = w, w = null) : (u = f.yyleng, o = f.yytext, l = f.yylineno, y = f.yylloc, d > 0 && d--);
						break;
					case 2:
						if (C = this.productions_[T[1]][1], L.$ = n[n.length - C], L._$ = {
							first_line: a[a.length - (C || 1)].first_line,
							last_line: a[a.length - 1].last_line,
							first_column: a[a.length - (C || 1)].first_column,
							last_column: a[a.length - 1].last_column
						}, v && (L._$.range = [a[a.length - (C || 1)].range[0], a[a.length - 1].range[1]]), "u" > typeof (_ = this.performAction.apply(L, [
							o,
							u,
							l,
							g,
							T[1],
							n,
							a
						].concat(p)))) return _;
						C && (r = r.slice(0, -1 * C * 2), n = n.slice(0, -1 * C), a = a.slice(0, -1 * C)), r.push(this.productions_[T[1]][0]), n.push(L.$), a.push(L._$), S = s[r[r.length - 2]][r[r.length - 1]], r.push(S);
						break;
					case 3: return !0;
				}
			}
			return !0;
		}, "parse")
	};
	function e5() {
		this.yy = {};
	}
	return e4.lexer = {
		EOF: 1,
		parseError: h(function(e, t) {
			if (this.yy.parser) this.yy.parser.parseError(e, t);
			else throw Error(e);
		}, "parseError"),
		setInput: h(function(e, t) {
			return this.yy = t || this.yy || {}, this._input = e, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
				first_line: 1,
				first_column: 0,
				last_line: 1,
				last_column: 0
			}, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
		}, "setInput"),
		input: h(function() {
			var e = this._input[0];
			return this.yytext += e, this.yyleng++, this.offset++, this.match += e, this.matched += e, e.match(/(?:\r\n?|\n).*/g) ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), e;
		}, "input"),
		unput: h(function(e) {
			var t = e.length, r = e.split(/(?:\r\n?|\n)/g);
			this._input = e + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - t), this.offset -= t;
			var i = this.match.split(/(?:\r\n?|\n)/g);
			this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), r.length - 1 && (this.yylineno -= r.length - 1);
			var n = this.yylloc.range;
			return this.yylloc = {
				first_line: this.yylloc.first_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.first_column,
				last_column: r ? (r.length === i.length ? this.yylloc.first_column : 0) + i[i.length - r.length].length - r[0].length : this.yylloc.first_column - t
			}, this.options.ranges && (this.yylloc.range = [n[0], n[0] + this.yyleng - t]), this.yyleng = this.yytext.length, this;
		}, "unput"),
		more: h(function() {
			return this._more = !0, this;
		}, "more"),
		reject: h(function() {
			return this.options.backtrack_lexer ? (this._backtrack = !0, this) : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "reject"),
		less: h(function(e) {
			this.unput(this.match.slice(e));
		}, "less"),
		pastInput: h(function() {
			var e = this.matched.substr(0, this.matched.length - this.match.length);
			return (e.length > 20 ? "..." : "") + e.substr(-20).replace(/\n/g, "");
		}, "pastInput"),
		upcomingInput: h(function() {
			var e = this.match;
			return e.length < 20 && (e += this._input.substr(0, 20 - e.length)), (e.substr(0, 20) + (e.length > 20 ? "..." : "")).replace(/\n/g, "");
		}, "upcomingInput"),
		showPosition: h(function() {
			var e = this.pastInput(), t = Array(e.length + 1).join("-");
			return e + this.upcomingInput() + `
` + t + "^";
		}, "showPosition"),
		test_match: h(function(e, t) {
			var r, i, n;
			if (this.options.backtrack_lexer && (n = {
				yylineno: this.yylineno,
				yylloc: {
					first_line: this.yylloc.first_line,
					last_line: this.last_line,
					first_column: this.yylloc.first_column,
					last_column: this.yylloc.last_column
				},
				yytext: this.yytext,
				match: this.match,
				matches: this.matches,
				matched: this.matched,
				yyleng: this.yyleng,
				offset: this.offset,
				_more: this._more,
				_input: this._input,
				yy: this.yy,
				conditionStack: this.conditionStack.slice(0),
				done: this.done
			}, this.options.ranges && (n.yylloc.range = this.yylloc.range.slice(0))), (i = e[0].match(/(?:\r\n?|\n).*/g)) && (this.yylineno += i.length), this.yylloc = {
				first_line: this.yylloc.last_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.last_column,
				last_column: i ? i[i.length - 1].length - i[i.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + e[0].length
			}, this.yytext += e[0], this.match += e[0], this.matches = e, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(e[0].length), this.matched += e[0], r = this.performAction.call(this, this.yy, this, t, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), r) return r;
			if (this._backtrack) for (var a in n) this[a] = n[a];
			return !1;
		}, "test_match"),
		next: h(function() {
			if (this.done) return this.EOF;
			this._input || (this.done = !0), this._more || (this.yytext = "", this.match = "");
			for (var e, t, r, i, n = this._currentRules(), a = 0; a < n.length; a++) if ((r = this._input.match(this.rules[n[a]])) && (!t || r[0].length > t[0].length)) {
				if (t = r, i = a, this.options.backtrack_lexer) {
					if (!1 !== (e = this.test_match(r, n[a]))) return e;
					if (!this._backtrack) return !1;
					t = !1;
					continue;
				} else if (!this.options.flex) break;
			}
			return t ? !1 !== (e = this.test_match(t, n[i])) && e : "" === this._input ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "next"),
		lex: h(function() {
			return this.next() || this.lex();
		}, "lex"),
		begin: h(function(e) {
			this.conditionStack.push(e);
		}, "begin"),
		popState: h(function() {
			return this.conditionStack.length - 1 > 0 ? this.conditionStack.pop() : this.conditionStack[0];
		}, "popState"),
		_currentRules: h(function() {
			return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
		}, "_currentRules"),
		topState: h(function(e) {
			return (e = this.conditionStack.length - 1 - Math.abs(e || 0)) >= 0 ? this.conditionStack[e] : "INITIAL";
		}, "topState"),
		pushState: h(function(e) {
			this.begin(e);
		}, "pushState"),
		stateStackSize: h(function() {
			return this.conditionStack.length;
		}, "stateStackSize"),
		options: {},
		performAction: h(function(e, t, r, i) {
			switch (r) {
				case 0: return this.begin("acc_title"), 34;
				case 1: return this.popState(), "acc_title_value";
				case 2: return this.begin("acc_descr"), 36;
				case 3: return this.popState(), "acc_descr_value";
				case 4:
					this.begin("acc_descr_multiline");
					break;
				case 5:
				case 12:
				case 14:
				case 17:
				case 20:
				case 23:
				case 33:
					this.popState();
					break;
				case 6: return "acc_descr_multiline_value";
				case 7: return this.pushState("shapeData"), t.yytext = "", 40;
				case 8: return this.pushState("shapeDataStr"), 40;
				case 9: return this.popState(), 40;
				case 10: return t.yytext = t.yytext.replace(/\n\s*/g, "<br/>"), 40;
				case 11: return 40;
				case 13:
					this.begin("callbackname");
					break;
				case 15:
					this.popState(), this.begin("callbackargs");
					break;
				case 16: return 95;
				case 18: return 96;
				case 19: return "MD_STR";
				case 21:
					this.begin("md_string");
					break;
				case 22: return "STR";
				case 24:
					this.pushState("string");
					break;
				case 25: return 84;
				case 26: return 102;
				case 27: return 85;
				case 28: return 104;
				case 29: return 86;
				case 30: return 87;
				case 31: return 97;
				case 32:
					this.begin("click");
					break;
				case 34: return 88;
				case 35:
				case 36:
				case 37: return e.lex.firstGraph() && this.begin("dir"), 12;
				case 38: return 27;
				case 39: return 32;
				case 40:
				case 41:
				case 42:
				case 43: return 98;
				case 44: return this.popState(), 13;
				case 45:
				case 46:
				case 47:
				case 48:
				case 49:
				case 50:
				case 51:
				case 52:
				case 53:
				case 54: return this.popState(), 14;
				case 55: return 121;
				case 56: return 122;
				case 57: return 123;
				case 58: return 124;
				case 59: return 78;
				case 60: return 105;
				case 61:
				case 102: return 111;
				case 62: return 46;
				case 63: return 60;
				case 64:
				case 103: return 44;
				case 65: return 8;
				case 66: return 106;
				case 67:
				case 101: return 115;
				case 68:
				case 71:
				case 74: return this.popState(), 77;
				case 69: return this.pushState("edgeText"), 75;
				case 70:
				case 73:
				case 76: return 119;
				case 72: return this.pushState("thickEdgeText"), 75;
				case 75: return this.pushState("dottedEdgeText"), 75;
				case 77: return 77;
				case 78: return this.popState(), 53;
				case 79:
				case 115: return "TEXT";
				case 80: return this.pushState("ellipseText"), 52;
				case 81: return this.popState(), 55;
				case 82: return this.pushState("text"), 54;
				case 83: return this.popState(), 57;
				case 84: return this.pushState("text"), 56;
				case 85: return 58;
				case 86: return this.pushState("text"), 67;
				case 87: return this.popState(), 64;
				case 88: return this.pushState("text"), 63;
				case 89: return this.popState(), 49;
				case 90: return this.pushState("text"), 48;
				case 91: return this.popState(), 69;
				case 92: return this.popState(), 71;
				case 93: return 117;
				case 94: return this.pushState("trapText"), 68;
				case 95: return this.pushState("trapText"), 70;
				case 96: return 118;
				case 97: return 67;
				case 98: return 90;
				case 99: return "SEP";
				case 100: return 89;
				case 104: return 109;
				case 105: return 114;
				case 106: return 116;
				case 107: return this.popState(), 62;
				case 108: return this.pushState("text"), 62;
				case 109: return this.popState(), 51;
				case 110: return this.pushState("text"), 50;
				case 111: return this.popState(), 31;
				case 112: return this.pushState("text"), 29;
				case 113: return this.popState(), 66;
				case 114: return this.pushState("text"), 65;
				case 116: return "QUOTE";
				case 117: return 9;
				case 118: return 10;
				case 119: return 11;
			}
		}, "anonymous"),
		rules: [
			/^(?:accTitle\s*:\s*)/,
			/^(?:(?!\n||)*[^\n]*)/,
			/^(?:accDescr\s*:\s*)/,
			/^(?:(?!\n||)*[^\n]*)/,
			/^(?:accDescr\s*\{\s*)/,
			/^(?:[\}])/,
			/^(?:[^\}]*)/,
			/^(?:@\{)/,
			/^(?:["])/,
			/^(?:["])/,
			/^(?:[^\"]+)/,
			/^(?:[^}^"]+)/,
			/^(?:\})/,
			/^(?:call[\s]+)/,
			/^(?:\([\s]*\))/,
			/^(?:\()/,
			/^(?:[^(]*)/,
			/^(?:\))/,
			/^(?:[^)]*)/,
			/^(?:[^`"]+)/,
			/^(?:[`]["])/,
			/^(?:["][`])/,
			/^(?:[^"]+)/,
			/^(?:["])/,
			/^(?:["])/,
			/^(?:style\b)/,
			/^(?:default\b)/,
			/^(?:linkStyle\b)/,
			/^(?:interpolate\b)/,
			/^(?:classDef\b)/,
			/^(?:class\b)/,
			/^(?:href[\s])/,
			/^(?:click[\s]+)/,
			/^(?:[\s\n])/,
			/^(?:[^\s\n]*)/,
			/^(?:flowchart-elk\b)/,
			/^(?:graph\b)/,
			/^(?:flowchart\b)/,
			/^(?:subgraph\b)/,
			/^(?:end\b\s*)/,
			/^(?:_self\b)/,
			/^(?:_blank\b)/,
			/^(?:_parent\b)/,
			/^(?:_top\b)/,
			/^(?:(\r?\n)*\s*\n)/,
			/^(?:\s*LR\b)/,
			/^(?:\s*RL\b)/,
			/^(?:\s*TB\b)/,
			/^(?:\s*BT\b)/,
			/^(?:\s*TD\b)/,
			/^(?:\s*BR\b)/,
			/^(?:\s*<)/,
			/^(?:\s*>)/,
			/^(?:\s*\^)/,
			/^(?:\s*v\b)/,
			/^(?:.*direction\s+TB[^\n]*)/,
			/^(?:.*direction\s+BT[^\n]*)/,
			/^(?:.*direction\s+RL[^\n]*)/,
			/^(?:.*direction\s+LR[^\n]*)/,
			/^(?:[^\s\"]+@(?=[^\{\"]))/,
			/^(?:[0-9]+)/,
			/^(?:#)/,
			/^(?::::)/,
			/^(?::)/,
			/^(?:&)/,
			/^(?:;)/,
			/^(?:,)/,
			/^(?:\*)/,
			/^(?:\s*[xo<]?--+[-xo>]\s*)/,
			/^(?:\s*[xo<]?--\s*)/,
			/^(?:[^-]|-(?!-)+)/,
			/^(?:\s*[xo<]?==+[=xo>]\s*)/,
			/^(?:\s*[xo<]?==\s*)/,
			/^(?:[^=]|=(?!))/,
			/^(?:\s*[xo<]?-?\.+-[xo>]?\s*)/,
			/^(?:\s*[xo<]?-\.\s*)/,
			/^(?:[^\.]|\.(?!))/,
			/^(?:\s*~~[\~]+\s*)/,
			/^(?:[-/\)][\)])/,
			/^(?:[^\(\)\[\]\{\}]|!\)+)/,
			/^(?:\(-)/,
			/^(?:\]\))/,
			/^(?:\(\[)/,
			/^(?:\]\])/,
			/^(?:\[\[)/,
			/^(?:\[\|)/,
			/^(?:>)/,
			/^(?:\)\])/,
			/^(?:\[\()/,
			/^(?:\)\)\))/,
			/^(?:\(\(\()/,
			/^(?:[\\(?=\])][\]])/,
			/^(?:\/(?=\])\])/,
			/^(?:\/(?!\])|\\(?!\])|[^\\\[\]\(\)\{\}\/]+)/,
			/^(?:\[\/)/,
			/^(?:\[\\)/,
			/^(?:<)/,
			/^(?:>)/,
			/^(?:\^)/,
			/^(?:\\\|)/,
			/^(?:v\b)/,
			/^(?:\*)/,
			/^(?:#)/,
			/^(?:&)/,
			/^(?:([A-Za-z0-9!"\#$%&'*+\.`?\\_\/]|-(?=[^\>\-\.])|(?!))+)/,
			/^(?:-)/,
			/^(?:[\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6]|[\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377]|[\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5]|[\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA]|[\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE]|[\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA]|[\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0]|[\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977]|[\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2]|[\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A]|[\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39]|[\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8]|[\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C]|[\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C]|[\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99]|[\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0]|[\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D]|[\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3]|[\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10]|[\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1]|[\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81]|[\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3]|[\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6]|[\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A]|[\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081]|[\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D]|[\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0]|[\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310]|[\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C]|[\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711]|[\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7]|[\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C]|[\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16]|[\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF]|[\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC]|[\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D]|[\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D]|[\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3]|[\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F]|[\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128]|[\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184]|[\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3]|[\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6]|[\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE]|[\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C]|[\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D]|[\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC]|[\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B]|[\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788]|[\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805]|[\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB]|[\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28]|[\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5]|[\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4]|[\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E]|[\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D]|[\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36]|[\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D]|[\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC]|[\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF]|[\uFFD2-\uFFD7\uFFDA-\uFFDC])/,
			/^(?:\|)/,
			/^(?:\|)/,
			/^(?:\))/,
			/^(?:\()/,
			/^(?:\])/,
			/^(?:\[)/,
			/^(?:(\}))/,
			/^(?:\{)/,
			/^(?:[^\[\]\(\)\{\}\|\"]+)/,
			/^(?:")/,
			/^(?:(\r?\n)+)/,
			/^(?:\s)/,
			/^(?:$)/
		],
		conditions: {
			shapeDataEndBracket: {
				rules: [
					21,
					24,
					77,
					80,
					82,
					84,
					88,
					90,
					94,
					95,
					108,
					110,
					112,
					114
				],
				inclusive: !1
			},
			shapeDataStr: {
				rules: [
					9,
					10,
					21,
					24,
					77,
					80,
					82,
					84,
					88,
					90,
					94,
					95,
					108,
					110,
					112,
					114
				],
				inclusive: !1
			},
			shapeData: {
				rules: [
					8,
					11,
					12,
					21,
					24,
					77,
					80,
					82,
					84,
					88,
					90,
					94,
					95,
					108,
					110,
					112,
					114
				],
				inclusive: !1
			},
			callbackargs: {
				rules: [
					17,
					18,
					21,
					24,
					77,
					80,
					82,
					84,
					88,
					90,
					94,
					95,
					108,
					110,
					112,
					114
				],
				inclusive: !1
			},
			callbackname: {
				rules: [
					14,
					15,
					16,
					21,
					24,
					77,
					80,
					82,
					84,
					88,
					90,
					94,
					95,
					108,
					110,
					112,
					114
				],
				inclusive: !1
			},
			href: {
				rules: [
					21,
					24,
					77,
					80,
					82,
					84,
					88,
					90,
					94,
					95,
					108,
					110,
					112,
					114
				],
				inclusive: !1
			},
			click: {
				rules: [
					21,
					24,
					33,
					34,
					77,
					80,
					82,
					84,
					88,
					90,
					94,
					95,
					108,
					110,
					112,
					114
				],
				inclusive: !1
			},
			dottedEdgeText: {
				rules: [
					21,
					24,
					74,
					76,
					77,
					80,
					82,
					84,
					88,
					90,
					94,
					95,
					108,
					110,
					112,
					114
				],
				inclusive: !1
			},
			thickEdgeText: {
				rules: [
					21,
					24,
					71,
					73,
					77,
					80,
					82,
					84,
					88,
					90,
					94,
					95,
					108,
					110,
					112,
					114
				],
				inclusive: !1
			},
			edgeText: {
				rules: [
					21,
					24,
					68,
					70,
					77,
					80,
					82,
					84,
					88,
					90,
					94,
					95,
					108,
					110,
					112,
					114
				],
				inclusive: !1
			},
			trapText: {
				rules: [
					21,
					24,
					77,
					80,
					82,
					84,
					88,
					90,
					91,
					92,
					93,
					94,
					95,
					108,
					110,
					112,
					114
				],
				inclusive: !1
			},
			ellipseText: {
				rules: [
					21,
					24,
					77,
					78,
					79,
					80,
					82,
					84,
					88,
					90,
					94,
					95,
					108,
					110,
					112,
					114
				],
				inclusive: !1
			},
			text: {
				rules: [
					21,
					24,
					77,
					80,
					81,
					82,
					83,
					84,
					87,
					88,
					89,
					90,
					94,
					95,
					107,
					108,
					109,
					110,
					111,
					112,
					113,
					114,
					115
				],
				inclusive: !1
			},
			vertex: {
				rules: [
					21,
					24,
					77,
					80,
					82,
					84,
					88,
					90,
					94,
					95,
					108,
					110,
					112,
					114
				],
				inclusive: !1
			},
			dir: {
				rules: [
					21,
					24,
					44,
					45,
					46,
					47,
					48,
					49,
					50,
					51,
					52,
					53,
					54,
					77,
					80,
					82,
					84,
					88,
					90,
					94,
					95,
					108,
					110,
					112,
					114
				],
				inclusive: !1
			},
			acc_descr_multiline: {
				rules: [
					5,
					6,
					21,
					24,
					77,
					80,
					82,
					84,
					88,
					90,
					94,
					95,
					108,
					110,
					112,
					114
				],
				inclusive: !1
			},
			acc_descr: {
				rules: [
					3,
					21,
					24,
					77,
					80,
					82,
					84,
					88,
					90,
					94,
					95,
					108,
					110,
					112,
					114
				],
				inclusive: !1
			},
			acc_title: {
				rules: [
					1,
					21,
					24,
					77,
					80,
					82,
					84,
					88,
					90,
					94,
					95,
					108,
					110,
					112,
					114
				],
				inclusive: !1
			},
			md_string: {
				rules: [
					19,
					20,
					21,
					24,
					77,
					80,
					82,
					84,
					88,
					90,
					94,
					95,
					108,
					110,
					112,
					114
				],
				inclusive: !1
			},
			string: {
				rules: [
					21,
					22,
					23,
					24,
					77,
					80,
					82,
					84,
					88,
					90,
					94,
					95,
					108,
					110,
					112,
					114
				],
				inclusive: !1
			},
			INITIAL: {
				rules: [
					0,
					2,
					4,
					7,
					13,
					21,
					24,
					25,
					26,
					27,
					28,
					29,
					30,
					31,
					32,
					35,
					36,
					37,
					38,
					39,
					40,
					41,
					42,
					43,
					55,
					56,
					57,
					58,
					59,
					60,
					61,
					62,
					63,
					64,
					65,
					66,
					67,
					68,
					69,
					71,
					72,
					74,
					75,
					77,
					80,
					82,
					84,
					85,
					86,
					88,
					90,
					94,
					95,
					96,
					97,
					98,
					99,
					100,
					101,
					102,
					103,
					104,
					105,
					106,
					108,
					110,
					112,
					114,
					116,
					117,
					118,
					119
				],
				inclusive: !0
			}
		}
	}, h(e5, "Parser"), e5.prototype = e4, e4.Parser = e5, new e5();
}();
el7.parser = el7;
var el8 = Object.assign({}, el7);
el8.parse = (e) => {
	let t = e.replace(/}\s*\n/g, `}
`);
	return el7.parse(t);
};
var el9 = h((e, t) => NQ(NJ(e, "r"), NJ(e, "g"), NJ(e, "b"), t), "fade"), ece = {
	parser: el8,
	get db() {
		return new el3();
	},
	renderer: el6,
	styles: h((e) => `.label {
    font-family: ${e.fontFamily};
    color: ${e.nodeTextColor || e.textColor};
  }
  .cluster-label text {
    fill: ${e.titleColor};
  }
  .cluster-label span {
    color: ${e.titleColor};
  }
  .cluster-label span p {
    background-color: transparent;
  }

  .label text,span {
    fill: ${e.nodeTextColor || e.textColor};
    color: ${e.nodeTextColor || e.textColor};
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${e.mainBkg};
    stroke: ${e.nodeBorder};
    stroke-width: 1px;
  }
  .rough-node .label text , .node .label text, .image-shape .label, .icon-shape .label {
    text-anchor: middle;
  }
  // .flowchart-label .text-outer-tspan {
  //   text-anchor: middle;
  // }
  // .flowchart-label .text-inner-tspan {
  //   text-anchor: start;
  // }

  .node .katex path {
    fill: #000;
    stroke: #000;
    stroke-width: 1px;
  }

  .rough-node .label,.node .label, .image-shape .label, .icon-shape .label {
    text-align: center;
  }
  .node.clickable {
    cursor: pointer;
  }


  .root .anchor path {
    fill: ${e.lineColor} !important;
    stroke-width: 0;
    stroke: ${e.lineColor};
  }

  .arrowheadPath {
    fill: ${e.arrowheadColor};
  }

  .edgePath .path {
    stroke: ${e.lineColor};
    stroke-width: 2.0px;
  }

  .flowchart-link {
    stroke: ${e.lineColor};
    fill: none;
  }

  .edgeLabel {
    background-color: ${e.edgeLabelBackground};
    p {
      background-color: ${e.edgeLabelBackground};
    }
    rect {
      opacity: 0.5;
      background-color: ${e.edgeLabelBackground};
      fill: ${e.edgeLabelBackground};
    }
    text-align: center;
  }

  /* For html labels only */
  .labelBkg {
    background-color: ${el9(e.edgeLabelBackground, .5)};
    // background-color:
  }

  .cluster rect {
    fill: ${e.clusterBkg};
    stroke: ${e.clusterBorder};
    stroke-width: 1px;
  }

  .cluster text {
    fill: ${e.titleColor};
  }

  .cluster span {
    color: ${e.titleColor};
  }
  /* .cluster div {
    color: ${e.titleColor};
  } */

  div.mermaidTooltip {
    position: absolute;
    text-align: center;
    max-width: 200px;
    padding: 2px;
    font-family: ${e.fontFamily};
    font-size: 12px;
    background: ${e.tertiaryColor};
    border: 1px solid ${e.border2};
    border-radius: 2px;
    pointer-events: none;
    z-index: 100;
  }

  .flowchartTitleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${e.textColor};
  }

  rect.text {
    fill: none;
    stroke-width: 0;
  }

  .icon-shape, .image-shape {
    background-color: ${e.edgeLabelBackground};
    p {
      background-color: ${e.edgeLabelBackground};
      padding: 2px;
    }
    rect {
      opacity: 0.5;
      background-color: ${e.edgeLabelBackground};
      fill: ${e.edgeLabelBackground};
    }
    text-align: center;
  }
  ${Kz()}
`, "getStyles"),
	init: h((e) => {
		e.flowchart || (e.flowchart = {}), e.layout && IS({ layout: e.layout }), e.flowchart.arrowMarkerAbsolute = e.arrowMarkerAbsolute, IS({ flowchart: { arrowMarkerAbsolute: e.arrowMarkerAbsolute } });
	}, "init")
}, ect = u((e, t) => {
	var r = e, i = function() {
		return function(e, t, r) {
			var i = h(function(e) {
				return e.add(4 - e.isoWeekday(), "day");
			}, "a"), n = t.prototype;
			n.isoWeekYear = function() {
				return i(this).year();
			}, n.isoWeek = function(e) {
				if (!this.$utils().u(e)) return this.add(7 * (e - this.isoWeek()), "day");
				var t, n, a, s = i(this), o = (t = this.isoWeekYear(), a = 4 - (n = (this.$u ? r.utc : r)().year(t).startOf("year")).isoWeekday(), n.isoWeekday() > 4 && (a += 7), n.add(a, "day"));
				return s.diff(o, "week") + 1;
			}, n.isoWeekday = function(e) {
				return this.$utils().u(e) ? this.day() || 7 : this.day(this.day() % 7 ? e : e - 7);
			};
			var a = n.startOf;
			n.startOf = function(e, t) {
				var r = this.$utils(), i = !!r.u(t) || t;
				return "isoweek" === r.p(e) ? i ? this.date(this.date() - (this.isoWeekday() - 1)).startOf("day") : this.date(this.date() - 1 - (this.isoWeekday() - 1) + 7).endOf("day") : a.bind(this)(e, t);
			};
		};
	};
	"object" == typeof e && "u" > typeof t ? t.exports = i() : "function" == typeof define && define.amd ? define(i) : (r = "u" > typeof globalThis ? globalThis : r || self).dayjs_plugin_isoWeek = i();
}), ecr = u((e, t) => {
	var r = e, i = function() {
		var e = {
			LTS: "h:mm:ss A",
			LT: "h:mm A",
			L: "MM/DD/YYYY",
			LL: "MMMM D, YYYY",
			LLL: "MMMM D, YYYY h:mm A",
			LLLL: "dddd, MMMM D, YYYY h:mm A"
		}, t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, r = /\d/, i = /\d\d/, n = /\d\d?/, a = /\d*[^-_:/,()\s\d]+/, s = {}, o = h(function(e) {
			return (e *= 1) + (e > 68 ? 1900 : 2e3);
		}, "a"), l = h(function(e) {
			return function(t) {
				this[e] = +t;
			};
		}, "f"), u = [/[+-]\d\d:?(\d\d)?|Z/, function(e) {
			(this.zone || (this.zone = {})).offset = function(e) {
				if (!e || "Z" === e) return 0;
				var t = e.match(/([+-]|\d\d)/g), r = 60 * t[1] + (+t[2] || 0);
				return 0 === r ? 0 : "+" === t[0] ? -r : r;
			}(e);
		}], d = h(function(e) {
			var t = s[e];
			return t && (t.indexOf ? t : t.s.concat(t.f));
		}, "u"), p = h(function(e, t) {
			var r, i = s.meridiem;
			if (i) {
				for (var n = 1; n <= 24; n += 1) if (e.indexOf(i(n, 0, t)) > -1) {
					r = n > 12;
					break;
				}
			} else r = e === (t ? "pm" : "PM");
			return r;
		}, "d"), f = {
			A: [a, function(e) {
				this.afternoon = p(e, !1);
			}],
			a: [a, function(e) {
				this.afternoon = p(e, !0);
			}],
			Q: [r, function(e) {
				this.month = 3 * (e - 1) + 1;
			}],
			S: [r, function(e) {
				this.milliseconds = 100 * e;
			}],
			SS: [i, function(e) {
				this.milliseconds = 10 * e;
			}],
			SSS: [/\d{3}/, function(e) {
				this.milliseconds = +e;
			}],
			s: [n, l("seconds")],
			ss: [n, l("seconds")],
			m: [n, l("minutes")],
			mm: [n, l("minutes")],
			H: [n, l("hours")],
			h: [n, l("hours")],
			HH: [n, l("hours")],
			hh: [n, l("hours")],
			D: [n, l("day")],
			DD: [i, l("day")],
			Do: [a, function(e) {
				var t = s.ordinal;
				if (this.day = e.match(/\d+/)[0], t) for (var r = 1; r <= 31; r += 1) t(r).replace(/\[|\]/g, "") === e && (this.day = r);
			}],
			w: [n, l("week")],
			ww: [i, l("week")],
			M: [n, l("month")],
			MM: [i, l("month")],
			MMM: [a, function(e) {
				var t = d("months"), r = (d("monthsShort") || t.map(function(e) {
					return e.slice(0, 3);
				})).indexOf(e) + 1;
				if (r < 1) throw Error();
				this.month = r % 12 || r;
			}],
			MMMM: [a, function(e) {
				var t = d("months").indexOf(e) + 1;
				if (t < 1) throw Error();
				this.month = t % 12 || t;
			}],
			Y: [/[+-]?\d+/, l("year")],
			YY: [i, function(e) {
				this.year = o(e);
			}],
			YYYY: [/\d{4}/, l("year")],
			Z: u,
			ZZ: u
		};
		function g(r) {
			for (var i = r, n = s && s.formats, a = (r = i.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t, r, i) {
				var a = i && i.toUpperCase();
				return r || n[i] || e[i] || n[a].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e, t, r) {
					return t || r.slice(1);
				});
			})).match(t), o = a.length, l = 0; l < o; l += 1) {
				var h = a[l], u = f[h], d = u && u[0], p = u && u[1];
				a[l] = p ? {
					regex: d,
					parser: p
				} : h.replace(/^\[|\]$/g, "");
			}
			return function(e) {
				for (var t = {}, r = 0, i = 0; r < o; r += 1) {
					var n = a[r];
					if ("string" == typeof n) i += n.length;
					else {
						var s = n.regex, l = n.parser, h = e.slice(i), u = s.exec(h)[0];
						l.call(t, u), e = e.replace(u, "");
					}
				}
				return function(e) {
					var t = e.afternoon;
					if (void 0 !== t) {
						var r = e.hours;
						t ? r < 12 && (e.hours += 12) : 12 === r && (e.hours = 0), delete e.afternoon;
					}
				}(t), t;
			};
		}
		return h(g, "l"), function(e, t, r) {
			r.p.customParseFormat = !0, e && e.parseTwoDigitYear && (o = e.parseTwoDigitYear);
			var i = t.prototype, n = i.parse;
			i.parse = function(e) {
				var t = e.date, i = e.utc, a = e.args;
				this.$u = i;
				var o = a[1];
				if ("string" == typeof o) {
					var l = !0 === a[2], h = !0 === a[3], u = a[2];
					h && (u = a[2]), s = this.$locale(), !l && u && (s = r.Ls[u]), this.$d = function(e, t, r, i) {
						try {
							if (["x", "X"].indexOf(t) > -1) return /* @__PURE__ */ new Date(("X" === t ? 1e3 : 1) * e);
							var n = g(t)(e), a = n.year, s = n.month, o = n.day, l = n.hours, h = n.minutes, u = n.seconds, d = n.milliseconds, p = n.zone, f = n.week, m = /* @__PURE__ */ new Date(), y = o || (a || s ? 1 : m.getDate()), v = a || m.getFullYear(), x = 0;
							a && !s || (x = s > 0 ? s - 1 : m.getMonth());
							var b, w = l || 0, k = h || 0, T = u || 0, _ = d || 0;
							return p ? new Date(Date.UTC(v, x, y, w, k, T, _ + 60 * p.offset * 1e3)) : r ? new Date(Date.UTC(v, x, y, w, k, T, _)) : (b = new Date(v, x, y, w, k, T, _), f && (b = i(b).week(f).toDate()), b);
						} catch {
							return /* @__PURE__ */ new Date("");
						}
					}(t, o, i, r), this.init(), u && !0 !== u && (this.$L = this.locale(u).$L), (l || h) && t != this.format(o) && (this.$d = /* @__PURE__ */ new Date("")), s = {};
				} else if (o instanceof Array) for (var d = o.length, p = 1; p <= d; p += 1) {
					a[1] = o[p - 1];
					var f = r.apply(this, a);
					if (f.isValid()) {
						this.$d = f.$d, this.$L = f.$L, this.init();
						break;
					}
					p === d && (this.$d = /* @__PURE__ */ new Date(""));
				}
				else n.call(this, e);
			};
		};
	};
	"object" == typeof e && "u" > typeof t ? t.exports = i() : "function" == typeof define && define.amd ? define(i) : (r = "u" > typeof globalThis ? globalThis : r || self).dayjs_plugin_customParseFormat = i();
}), eci = u((e, t) => {
	var r = e, i = function() {
		return function(e, t) {
			var r = t.prototype, i = r.format;
			r.format = function(e) {
				var t = this, r = this.$locale();
				if (!this.isValid()) return i.bind(this)(e);
				var n = this.$utils(), a = (e || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e) {
					switch (e) {
						case "Q": return Math.ceil((t.$M + 1) / 3);
						case "Do": return r.ordinal(t.$D);
						case "gggg": return t.weekYear();
						case "GGGG": return t.isoWeekYear();
						case "wo": return r.ordinal(t.week(), "W");
						case "w":
						case "ww": return n.s(t.week(), "w" === e ? 1 : 2, "0");
						case "W":
						case "WW": return n.s(t.isoWeek(), "W" === e ? 1 : 2, "0");
						case "k":
						case "kk": return n.s(String(0 === t.$H ? 24 : t.$H), "k" === e ? 1 : 2, "0");
						case "X": return Math.floor(t.$d.getTime() / 1e3);
						case "x": return t.$d.getTime();
						case "z": return "[" + t.offsetName() + "]";
						case "zzz": return "[" + t.offsetName("long") + "]";
						default: return e;
					}
				});
				return i.bind(this)(a);
			};
		};
	};
	"object" == typeof e && "u" > typeof t ? t.exports = i() : "function" == typeof define && define.amd ? define(i) : (r = "u" > typeof globalThis ? globalThis : r || self).dayjs_plugin_advancedFormat = i();
}), ecn = function() {
	var e = h(function(e, t, r, i) {
		for (r = r || {}, i = e.length; i--; r[e[i]] = t);
		return r;
	}, "o"), t = [
		6,
		8,
		10,
		12,
		13,
		14,
		15,
		16,
		17,
		18,
		20,
		21,
		22,
		23,
		24,
		25,
		26,
		27,
		28,
		29,
		30,
		31,
		33,
		35,
		36,
		38,
		40
	], r = [1, 26], i = [1, 27], n = [1, 28], a = [1, 29], s = [1, 30], o = [1, 31], l = [1, 32], u = [1, 33], d = [1, 34], p = [1, 9], f = [1, 10], g = [1, 11], m = [1, 12], y = [1, 13], v = [1, 14], x = [1, 15], b = [1, 16], w = [1, 19], k = [1, 20], T = [1, 21], _ = [1, 22], E = [1, 23], C = [1, 25], S = [1, 35], A = {
		trace: h(function() {}, "trace"),
		yy: {},
		symbols_: {
			error: 2,
			start: 3,
			gantt: 4,
			document: 5,
			EOF: 6,
			line: 7,
			SPACE: 8,
			statement: 9,
			NL: 10,
			weekday: 11,
			weekday_monday: 12,
			weekday_tuesday: 13,
			weekday_wednesday: 14,
			weekday_thursday: 15,
			weekday_friday: 16,
			weekday_saturday: 17,
			weekday_sunday: 18,
			weekend: 19,
			weekend_friday: 20,
			weekend_saturday: 21,
			dateFormat: 22,
			inclusiveEndDates: 23,
			topAxis: 24,
			axisFormat: 25,
			tickInterval: 26,
			excludes: 27,
			includes: 28,
			todayMarker: 29,
			title: 30,
			acc_title: 31,
			acc_title_value: 32,
			acc_descr: 33,
			acc_descr_value: 34,
			acc_descr_multiline_value: 35,
			section: 36,
			clickStatement: 37,
			taskTxt: 38,
			taskData: 39,
			click: 40,
			callbackname: 41,
			callbackargs: 42,
			href: 43,
			clickStatementDebug: 44,
			$accept: 0,
			$end: 1
		},
		terminals_: {
			2: "error",
			4: "gantt",
			6: "EOF",
			8: "SPACE",
			10: "NL",
			12: "weekday_monday",
			13: "weekday_tuesday",
			14: "weekday_wednesday",
			15: "weekday_thursday",
			16: "weekday_friday",
			17: "weekday_saturday",
			18: "weekday_sunday",
			20: "weekend_friday",
			21: "weekend_saturday",
			22: "dateFormat",
			23: "inclusiveEndDates",
			24: "topAxis",
			25: "axisFormat",
			26: "tickInterval",
			27: "excludes",
			28: "includes",
			29: "todayMarker",
			30: "title",
			31: "acc_title",
			32: "acc_title_value",
			33: "acc_descr",
			34: "acc_descr_value",
			35: "acc_descr_multiline_value",
			36: "section",
			38: "taskTxt",
			39: "taskData",
			40: "click",
			41: "callbackname",
			42: "callbackargs",
			43: "href"
		},
		productions_: [
			0,
			[3, 3],
			[5, 0],
			[5, 2],
			[7, 2],
			[7, 1],
			[7, 1],
			[7, 1],
			[11, 1],
			[11, 1],
			[11, 1],
			[11, 1],
			[11, 1],
			[11, 1],
			[11, 1],
			[19, 1],
			[19, 1],
			[9, 1],
			[9, 1],
			[9, 1],
			[9, 1],
			[9, 1],
			[9, 1],
			[9, 1],
			[9, 1],
			[9, 1],
			[9, 1],
			[9, 1],
			[9, 2],
			[9, 2],
			[9, 1],
			[9, 1],
			[9, 1],
			[9, 2],
			[37, 2],
			[37, 3],
			[37, 3],
			[37, 4],
			[37, 3],
			[37, 4],
			[37, 2],
			[44, 2],
			[44, 3],
			[44, 3],
			[44, 4],
			[44, 3],
			[44, 4],
			[44, 2]
		],
		performAction: h(function(e, t, r, i, n, a, s) {
			var o = a.length - 1;
			switch (n) {
				case 1: return a[o - 1];
				case 2:
				case 6:
				case 7:
					this.$ = [];
					break;
				case 3:
					a[o - 1].push(a[o]), this.$ = a[o - 1];
					break;
				case 4:
				case 5:
					this.$ = a[o];
					break;
				case 8:
					i.setWeekday("monday");
					break;
				case 9:
					i.setWeekday("tuesday");
					break;
				case 10:
					i.setWeekday("wednesday");
					break;
				case 11:
					i.setWeekday("thursday");
					break;
				case 12:
					i.setWeekday("friday");
					break;
				case 13:
					i.setWeekday("saturday");
					break;
				case 14:
					i.setWeekday("sunday");
					break;
				case 15:
					i.setWeekend("friday");
					break;
				case 16:
					i.setWeekend("saturday");
					break;
				case 17:
					i.setDateFormat(a[o].substr(11)), this.$ = a[o].substr(11);
					break;
				case 18:
					i.enableInclusiveEndDates(), this.$ = a[o].substr(18);
					break;
				case 19:
					i.TopAxis(), this.$ = a[o].substr(8);
					break;
				case 20:
					i.setAxisFormat(a[o].substr(11)), this.$ = a[o].substr(11);
					break;
				case 21:
					i.setTickInterval(a[o].substr(13)), this.$ = a[o].substr(13);
					break;
				case 22:
					i.setExcludes(a[o].substr(9)), this.$ = a[o].substr(9);
					break;
				case 23:
					i.setIncludes(a[o].substr(9)), this.$ = a[o].substr(9);
					break;
				case 24:
					i.setTodayMarker(a[o].substr(12)), this.$ = a[o].substr(12);
					break;
				case 27:
					i.setDiagramTitle(a[o].substr(6)), this.$ = a[o].substr(6);
					break;
				case 28:
					this.$ = a[o].trim(), i.setAccTitle(this.$);
					break;
				case 29:
				case 30:
					this.$ = a[o].trim(), i.setAccDescription(this.$);
					break;
				case 31:
					i.addSection(a[o].substr(8)), this.$ = a[o].substr(8);
					break;
				case 33:
					i.addTask(a[o - 1], a[o]), this.$ = "task";
					break;
				case 34:
					this.$ = a[o - 1], i.setClickEvent(a[o - 1], a[o], null);
					break;
				case 35:
					this.$ = a[o - 2], i.setClickEvent(a[o - 2], a[o - 1], a[o]);
					break;
				case 36:
					this.$ = a[o - 2], i.setClickEvent(a[o - 2], a[o - 1], null), i.setLink(a[o - 2], a[o]);
					break;
				case 37:
					this.$ = a[o - 3], i.setClickEvent(a[o - 3], a[o - 2], a[o - 1]), i.setLink(a[o - 3], a[o]);
					break;
				case 38:
					this.$ = a[o - 2], i.setClickEvent(a[o - 2], a[o], null), i.setLink(a[o - 2], a[o - 1]);
					break;
				case 39:
					this.$ = a[o - 3], i.setClickEvent(a[o - 3], a[o - 1], a[o]), i.setLink(a[o - 3], a[o - 2]);
					break;
				case 40:
					this.$ = a[o - 1], i.setLink(a[o - 1], a[o]);
					break;
				case 41:
				case 47:
					this.$ = a[o - 1] + " " + a[o];
					break;
				case 42:
				case 43:
				case 45:
					this.$ = a[o - 2] + " " + a[o - 1] + " " + a[o];
					break;
				case 44:
				case 46: this.$ = a[o - 3] + " " + a[o - 2] + " " + a[o - 1] + " " + a[o];
			}
		}, "anonymous"),
		table: [
			{
				3: 1,
				4: [1, 2]
			},
			{ 1: [3] },
			e(t, [2, 2], { 5: 3 }),
			{
				6: [1, 4],
				7: 5,
				8: [1, 6],
				9: 7,
				10: [1, 8],
				11: 17,
				12: r,
				13: i,
				14: n,
				15: a,
				16: s,
				17: o,
				18: l,
				19: 18,
				20: u,
				21: d,
				22: p,
				23: f,
				24: g,
				25: m,
				26: y,
				27: v,
				28: x,
				29: b,
				30: w,
				31: k,
				33: T,
				35: _,
				36: E,
				37: 24,
				38: C,
				40: S
			},
			e(t, [2, 7], { 1: [2, 1] }),
			e(t, [2, 3]),
			{
				9: 36,
				11: 17,
				12: r,
				13: i,
				14: n,
				15: a,
				16: s,
				17: o,
				18: l,
				19: 18,
				20: u,
				21: d,
				22: p,
				23: f,
				24: g,
				25: m,
				26: y,
				27: v,
				28: x,
				29: b,
				30: w,
				31: k,
				33: T,
				35: _,
				36: E,
				37: 24,
				38: C,
				40: S
			},
			e(t, [2, 5]),
			e(t, [2, 6]),
			e(t, [2, 17]),
			e(t, [2, 18]),
			e(t, [2, 19]),
			e(t, [2, 20]),
			e(t, [2, 21]),
			e(t, [2, 22]),
			e(t, [2, 23]),
			e(t, [2, 24]),
			e(t, [2, 25]),
			e(t, [2, 26]),
			e(t, [2, 27]),
			{ 32: [1, 37] },
			{ 34: [1, 38] },
			e(t, [2, 30]),
			e(t, [2, 31]),
			e(t, [2, 32]),
			{ 39: [1, 39] },
			e(t, [2, 8]),
			e(t, [2, 9]),
			e(t, [2, 10]),
			e(t, [2, 11]),
			e(t, [2, 12]),
			e(t, [2, 13]),
			e(t, [2, 14]),
			e(t, [2, 15]),
			e(t, [2, 16]),
			{
				41: [1, 40],
				43: [1, 41]
			},
			e(t, [2, 4]),
			e(t, [2, 28]),
			e(t, [2, 29]),
			e(t, [2, 33]),
			e(t, [2, 34], {
				42: [1, 42],
				43: [1, 43]
			}),
			e(t, [2, 40], { 41: [1, 44] }),
			e(t, [2, 35], { 43: [1, 45] }),
			e(t, [2, 36]),
			e(t, [2, 38], { 42: [1, 46] }),
			e(t, [2, 37]),
			e(t, [2, 39])
		],
		defaultActions: {},
		parseError: h(function(e, t) {
			if (t.recoverable) this.trace(e);
			else {
				var r = Error(e);
				throw r.hash = t, r;
			}
		}, "parseError"),
		parse: h(function(e) {
			var t = this, r = [0], i = [], n = [null], a = [], s = this.table, o = "", l = 0, u = 0, d = 0, p = a.slice.call(arguments, 1), f = Object.create(this.lexer), g = {};
			for (var m in this.yy) Object.prototype.hasOwnProperty.call(this.yy, m) && (g[m] = this.yy[m]);
			f.setInput(e, g), g.lexer = f, g.parser = this, typeof f.yylloc > "u" && (f.yylloc = {});
			var y = f.yylloc;
			a.push(y);
			var v = f.options && f.options.ranges;
			function x() {
				var e;
				return "number" != typeof (e = i.pop() || f.lex() || 1) && (e instanceof Array && (e = (i = e).pop()), e = t.symbols_[e] || e), e;
			}
			"function" == typeof g.parseError ? this.parseError = g.parseError : this.parseError = Object.getPrototypeOf(this).parseError, h(function(e) {
				r.length = r.length - 2 * e, n.length = n.length - e, a.length = a.length - e;
			}, "popStack"), h(x, "lex");
			for (var b, w, k, T, _, E, C, S, A, L = {};;) {
				if (k = r[r.length - 1], this.defaultActions[k] ? T = this.defaultActions[k] : ((null === b || typeof b > "u") && (b = x()), T = s[k] && s[k][b]), typeof T > "u" || !T.length || !T[0]) {
					var R = "";
					for (E in A = [], s[k]) this.terminals_[E] && E > 2 && A.push("'" + this.terminals_[E] + "'");
					R = f.showPosition ? "Parse error on line " + (l + 1) + `:
` + f.showPosition() + `
Expecting ` + A.join(", ") + ", got '" + (this.terminals_[b] || b) + "'" : "Parse error on line " + (l + 1) + ": Unexpected " + (1 == b ? "end of input" : "'" + (this.terminals_[b] || b) + "'"), this.parseError(R, {
						text: f.match,
						token: this.terminals_[b] || b,
						line: f.yylineno,
						loc: y,
						expected: A
					});
				}
				if (T[0] instanceof Array && T.length > 1) throw Error("Parse Error: multiple actions possible at state: " + k + ", token: " + b);
				switch (T[0]) {
					case 1:
						r.push(b), n.push(f.yytext), a.push(f.yylloc), r.push(T[1]), b = null, w ? (b = w, w = null) : (u = f.yyleng, o = f.yytext, l = f.yylineno, y = f.yylloc, d > 0 && d--);
						break;
					case 2:
						if (C = this.productions_[T[1]][1], L.$ = n[n.length - C], L._$ = {
							first_line: a[a.length - (C || 1)].first_line,
							last_line: a[a.length - 1].last_line,
							first_column: a[a.length - (C || 1)].first_column,
							last_column: a[a.length - 1].last_column
						}, v && (L._$.range = [a[a.length - (C || 1)].range[0], a[a.length - 1].range[1]]), "u" > typeof (_ = this.performAction.apply(L, [
							o,
							u,
							l,
							g,
							T[1],
							n,
							a
						].concat(p)))) return _;
						C && (r = r.slice(0, -1 * C * 2), n = n.slice(0, -1 * C), a = a.slice(0, -1 * C)), r.push(this.productions_[T[1]][0]), n.push(L.$), a.push(L._$), S = s[r[r.length - 2]][r[r.length - 1]], r.push(S);
						break;
					case 3: return !0;
				}
			}
			return !0;
		}, "parse")
	};
	function L() {
		this.yy = {};
	}
	return A.lexer = {
		EOF: 1,
		parseError: h(function(e, t) {
			if (this.yy.parser) this.yy.parser.parseError(e, t);
			else throw Error(e);
		}, "parseError"),
		setInput: h(function(e, t) {
			return this.yy = t || this.yy || {}, this._input = e, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
				first_line: 1,
				first_column: 0,
				last_line: 1,
				last_column: 0
			}, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
		}, "setInput"),
		input: h(function() {
			var e = this._input[0];
			return this.yytext += e, this.yyleng++, this.offset++, this.match += e, this.matched += e, e.match(/(?:\r\n?|\n).*/g) ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), e;
		}, "input"),
		unput: h(function(e) {
			var t = e.length, r = e.split(/(?:\r\n?|\n)/g);
			this._input = e + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - t), this.offset -= t;
			var i = this.match.split(/(?:\r\n?|\n)/g);
			this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), r.length - 1 && (this.yylineno -= r.length - 1);
			var n = this.yylloc.range;
			return this.yylloc = {
				first_line: this.yylloc.first_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.first_column,
				last_column: r ? (r.length === i.length ? this.yylloc.first_column : 0) + i[i.length - r.length].length - r[0].length : this.yylloc.first_column - t
			}, this.options.ranges && (this.yylloc.range = [n[0], n[0] + this.yyleng - t]), this.yyleng = this.yytext.length, this;
		}, "unput"),
		more: h(function() {
			return this._more = !0, this;
		}, "more"),
		reject: h(function() {
			return this.options.backtrack_lexer ? (this._backtrack = !0, this) : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "reject"),
		less: h(function(e) {
			this.unput(this.match.slice(e));
		}, "less"),
		pastInput: h(function() {
			var e = this.matched.substr(0, this.matched.length - this.match.length);
			return (e.length > 20 ? "..." : "") + e.substr(-20).replace(/\n/g, "");
		}, "pastInput"),
		upcomingInput: h(function() {
			var e = this.match;
			return e.length < 20 && (e += this._input.substr(0, 20 - e.length)), (e.substr(0, 20) + (e.length > 20 ? "..." : "")).replace(/\n/g, "");
		}, "upcomingInput"),
		showPosition: h(function() {
			var e = this.pastInput(), t = Array(e.length + 1).join("-");
			return e + this.upcomingInput() + `
` + t + "^";
		}, "showPosition"),
		test_match: h(function(e, t) {
			var r, i, n;
			if (this.options.backtrack_lexer && (n = {
				yylineno: this.yylineno,
				yylloc: {
					first_line: this.yylloc.first_line,
					last_line: this.last_line,
					first_column: this.yylloc.first_column,
					last_column: this.yylloc.last_column
				},
				yytext: this.yytext,
				match: this.match,
				matches: this.matches,
				matched: this.matched,
				yyleng: this.yyleng,
				offset: this.offset,
				_more: this._more,
				_input: this._input,
				yy: this.yy,
				conditionStack: this.conditionStack.slice(0),
				done: this.done
			}, this.options.ranges && (n.yylloc.range = this.yylloc.range.slice(0))), (i = e[0].match(/(?:\r\n?|\n).*/g)) && (this.yylineno += i.length), this.yylloc = {
				first_line: this.yylloc.last_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.last_column,
				last_column: i ? i[i.length - 1].length - i[i.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + e[0].length
			}, this.yytext += e[0], this.match += e[0], this.matches = e, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(e[0].length), this.matched += e[0], r = this.performAction.call(this, this.yy, this, t, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), r) return r;
			if (this._backtrack) for (var a in n) this[a] = n[a];
			return !1;
		}, "test_match"),
		next: h(function() {
			if (this.done) return this.EOF;
			this._input || (this.done = !0), this._more || (this.yytext = "", this.match = "");
			for (var e, t, r, i, n = this._currentRules(), a = 0; a < n.length; a++) if ((r = this._input.match(this.rules[n[a]])) && (!t || r[0].length > t[0].length)) {
				if (t = r, i = a, this.options.backtrack_lexer) {
					if (!1 !== (e = this.test_match(r, n[a]))) return e;
					if (!this._backtrack) return !1;
					t = !1;
					continue;
				} else if (!this.options.flex) break;
			}
			return t ? !1 !== (e = this.test_match(t, n[i])) && e : "" === this._input ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "next"),
		lex: h(function() {
			return this.next() || this.lex();
		}, "lex"),
		begin: h(function(e) {
			this.conditionStack.push(e);
		}, "begin"),
		popState: h(function() {
			return this.conditionStack.length - 1 > 0 ? this.conditionStack.pop() : this.conditionStack[0];
		}, "popState"),
		_currentRules: h(function() {
			return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
		}, "_currentRules"),
		topState: h(function(e) {
			return (e = this.conditionStack.length - 1 - Math.abs(e || 0)) >= 0 ? this.conditionStack[e] : "INITIAL";
		}, "topState"),
		pushState: h(function(e) {
			this.begin(e);
		}, "pushState"),
		stateStackSize: h(function() {
			return this.conditionStack.length;
		}, "stateStackSize"),
		options: { "case-insensitive": !0 },
		performAction: h(function(e, t, r, i) {
			switch (r) {
				case 0: return this.begin("open_directive"), "open_directive";
				case 1: return this.begin("acc_title"), 31;
				case 2: return this.popState(), "acc_title_value";
				case 3: return this.begin("acc_descr"), 33;
				case 4: return this.popState(), "acc_descr_value";
				case 5:
					this.begin("acc_descr_multiline");
					break;
				case 6:
				case 15:
				case 18:
				case 21:
				case 24:
					this.popState();
					break;
				case 7: return "acc_descr_multiline_value";
				case 8:
				case 9:
				case 10:
				case 12:
				case 13: break;
				case 11: return 10;
				case 14:
					this.begin("href");
					break;
				case 16: return 43;
				case 17:
					this.begin("callbackname");
					break;
				case 19:
					this.popState(), this.begin("callbackargs");
					break;
				case 20: return 41;
				case 22: return 42;
				case 23:
					this.begin("click");
					break;
				case 25: return 40;
				case 26: return 4;
				case 27: return 22;
				case 28: return 23;
				case 29: return 24;
				case 30: return 25;
				case 31: return 26;
				case 32: return 28;
				case 33: return 27;
				case 34: return 29;
				case 35: return 12;
				case 36: return 13;
				case 37: return 14;
				case 38: return 15;
				case 39: return 16;
				case 40: return 17;
				case 41: return 18;
				case 42: return 20;
				case 43: return 21;
				case 44: return "date";
				case 45: return 30;
				case 46: return "accDescription";
				case 47: return 36;
				case 48: return 38;
				case 49: return 39;
				case 50: return ":";
				case 51: return 6;
				case 52: return "INVALID";
			}
		}, "anonymous"),
		rules: [
			/^(?:%%\{)/i,
			/^(?:accTitle\s*:\s*)/i,
			/^(?:(?!\n||)*[^\n]*)/i,
			/^(?:accDescr\s*:\s*)/i,
			/^(?:(?!\n||)*[^\n]*)/i,
			/^(?:accDescr\s*\{\s*)/i,
			/^(?:[\}])/i,
			/^(?:[^\}]*)/i,
			/^(?:%%(?!\{)*[^\n]*)/i,
			/^(?:[^\}]%%*[^\n]*)/i,
			/^(?:%%*[^\n]*[\n]*)/i,
			/^(?:[\n]+)/i,
			/^(?:\s+)/i,
			/^(?:%[^\n]*)/i,
			/^(?:href[\s]+["])/i,
			/^(?:["])/i,
			/^(?:[^"]*)/i,
			/^(?:call[\s]+)/i,
			/^(?:\([\s]*\))/i,
			/^(?:\()/i,
			/^(?:[^(]*)/i,
			/^(?:\))/i,
			/^(?:[^)]*)/i,
			/^(?:click[\s]+)/i,
			/^(?:[\s\n])/i,
			/^(?:[^\s\n]*)/i,
			/^(?:gantt\b)/i,
			/^(?:dateFormat\s[^#\n;]+)/i,
			/^(?:inclusiveEndDates\b)/i,
			/^(?:topAxis\b)/i,
			/^(?:axisFormat\s[^#\n;]+)/i,
			/^(?:tickInterval\s[^#\n;]+)/i,
			/^(?:includes\s[^#\n;]+)/i,
			/^(?:excludes\s[^#\n;]+)/i,
			/^(?:todayMarker\s[^\n;]+)/i,
			/^(?:weekday\s+monday\b)/i,
			/^(?:weekday\s+tuesday\b)/i,
			/^(?:weekday\s+wednesday\b)/i,
			/^(?:weekday\s+thursday\b)/i,
			/^(?:weekday\s+friday\b)/i,
			/^(?:weekday\s+saturday\b)/i,
			/^(?:weekday\s+sunday\b)/i,
			/^(?:weekend\s+friday\b)/i,
			/^(?:weekend\s+saturday\b)/i,
			/^(?:\d\d\d\d-\d\d-\d\d\b)/i,
			/^(?:title\s[^\n]+)/i,
			/^(?:accDescription\s[^#\n;]+)/i,
			/^(?:section\s[^\n]+)/i,
			/^(?:[^:\n]+)/i,
			/^(?::[^#\n;]+)/i,
			/^(?::)/i,
			/^(?:$)/i,
			/^(?:.)/i
		],
		conditions: {
			acc_descr_multiline: {
				rules: [6, 7],
				inclusive: !1
			},
			acc_descr: {
				rules: [4],
				inclusive: !1
			},
			acc_title: {
				rules: [2],
				inclusive: !1
			},
			callbackargs: {
				rules: [21, 22],
				inclusive: !1
			},
			callbackname: {
				rules: [
					18,
					19,
					20
				],
				inclusive: !1
			},
			href: {
				rules: [15, 16],
				inclusive: !1
			},
			click: {
				rules: [24, 25],
				inclusive: !1
			},
			INITIAL: {
				rules: [
					0,
					1,
					3,
					5,
					8,
					9,
					10,
					11,
					12,
					13,
					14,
					17,
					23,
					26,
					27,
					28,
					29,
					30,
					31,
					32,
					33,
					34,
					35,
					36,
					37,
					38,
					39,
					40,
					41,
					42,
					43,
					44,
					45,
					46,
					47,
					48,
					49,
					50,
					51,
					52
				],
				inclusive: !0
			}
		}
	}, h(L, "Parser"), L.prototype = A, A.Parser = L, new L();
}();
ecn.parser = ecn;
var eca = g(Vk(), 1), ecs = g(wX(), 1), eco = g(ect(), 1), ecl = g(ecr(), 1), ecc = g(eci(), 1);
ecs.default.extend(eco.default), ecs.default.extend(ecl.default), ecs.default.extend(ecc.default);
var ech, ecu, ecd, ecp, ecf = {
	friday: 5,
	saturday: 6
}, ecg = "", ecm = "", ecy = "", ecv = [], ecx = [], ecb = /* @__PURE__ */ new Map(), ecw = [], eck = [], ecT = "", ec_ = "", ecE = [
	"active",
	"done",
	"crit",
	"milestone",
	"vert"
], ecC = [], ecS = !1, ecA = !1, ecL = "sunday", ecR = "saturday", ecN = 0, ecI = h(function() {
	ecw = [], eck = [], ecT = "", ecC = [], ehe = 0, ecd = void 0, ecp = void 0, ehn = [], ecg = "", ecm = "", ec_ = "", ecu = void 0, ecy = "", ecv = [], ecx = [], ecS = !1, ecA = !1, ecN = 0, ecb = /* @__PURE__ */ new Map(), Dn(), ecL = "sunday", ecR = "saturday";
}, "clear"), ecM = h(function(e) {
	ecm = e;
}, "setAxisFormat"), ecD = h(function() {
	return ecm;
}, "getAxisFormat"), ecO = h(function(e) {
	ecu = e;
}, "setTickInterval"), ec$ = h(function() {
	return ecu;
}, "getTickInterval"), ecP = h(function(e) {
	ecy = e;
}, "setTodayMarker"), ecB = h(function() {
	return ecy;
}, "getTodayMarker"), ecF = h(function(e) {
	ecg = e;
}, "setDateFormat"), ecz = h(function() {
	ecS = !0;
}, "enableInclusiveEndDates"), ecU = h(function() {
	return ecS;
}, "endDatesAreInclusive"), ecG = h(function() {
	ecA = !0;
}, "enableTopAxis"), ecq = h(function() {
	return ecA;
}, "topAxisEnabled"), ecj = h(function(e) {
	ec_ = e;
}, "setDisplayMode"), ecW = h(function() {
	return ec_;
}, "getDisplayMode"), ecY = h(function() {
	return ecg;
}, "getDateFormat"), ecV = h(function(e) {
	ecv = e.toLowerCase().split(/[\s,]+/);
}, "setIncludes"), ecH = h(function() {
	return ecv;
}, "getIncludes"), ecX = h(function(e) {
	ecx = e.toLowerCase().split(/[\s,]+/);
}, "setExcludes"), ecK = h(function() {
	return ecx;
}, "getExcludes"), ecZ = h(function() {
	return ecb;
}, "getLinks"), ecQ = h(function(e) {
	ecT = e, ecw.push(e);
}, "addSection"), ecJ = h(function() {
	return ecw;
}, "getSections"), ec0 = h(function() {
	let e = ehc(), t = 0;
	for (; !e && t < 10;) e = ehc(), t++;
	return eck = ehn;
}, "getTasks"), ec1 = h(function(e, t, r, i) {
	let n = e.format(t.trim()), a = e.format("YYYY-MM-DD");
	return !(i.includes(n) || i.includes(a)) && (!!(r.includes("weekends") && (e.isoWeekday() === ecf[ecR] || e.isoWeekday() === ecf[ecR] + 1) || r.includes(e.format("dddd").toLowerCase())) || r.includes(n) || r.includes(a));
}, "isInvalidDate"), ec2 = h(function(e) {
	ecL = e;
}, "setWeekday"), ec4 = h(function() {
	return ecL;
}, "getWeekday"), ec5 = h(function(e) {
	ecR = e;
}, "setWeekend"), ec3 = h(function(e, t, r, i) {
	if (!r.length || e.manualEndTime) return;
	let [a, s] = ec6((e.startTime instanceof Date ? (0, ecs.default)(e.startTime) : (0, ecs.default)(e.startTime, t, !0)).add(1, "d"), e.endTime instanceof Date ? (0, ecs.default)(e.endTime) : (0, ecs.default)(e.endTime, t, !0), t, r, i);
	e.endTime = a.toDate(), e.renderEndTime = s;
}, "checkTaskDates"), ec6 = h(function(e, t, r, i, n) {
	let a = !1, s = null;
	for (; e <= t;) a || (s = t.toDate()), (a = ec1(e, r, i, n)) && (t = t.add(1, "d")), e = e.add(1, "d");
	return [t, s];
}, "fixTaskDates"), ec7 = h(function(e, t, r) {
	if (r = r.trim(), ("x" === t.trim() || "X" === t.trim()) && /^\d+$/.test(r)) return new Date(Number(r));
	let i = /^after\s+(?<ids>[\d\w- ]+)/.exec(r);
	if (null !== i) {
		let e = null;
		for (let t of i.groups.ids.split(" ")) {
			let r = eho(t);
			void 0 !== r && (!e || r.endTime > e.endTime) && (e = r);
		}
		if (e) return e.endTime;
		let t = /* @__PURE__ */ new Date();
		return t.setHours(0, 0, 0, 0), t;
	}
	let n = (0, ecs.default)(r, t.trim(), !0);
	if (n.isValid()) return n.toDate();
	{
		wQ.debug("Invalid date:" + r), wQ.debug("With date format:" + t.trim());
		let e = new Date(r);
		if (void 0 === e || isNaN(e.getTime()) || -1e4 > e.getFullYear() || e.getFullYear() > 1e4) throw Error("Invalid date:" + r);
		return e;
	}
}, "getStartDate"), ec8 = h(function(e) {
	let t = /^(\d+(?:\.\d+)?)([Mdhmswy]|ms)$/.exec(e.trim());
	return null !== t ? [Number.parseFloat(t[1]), t[2]] : [NaN, "ms"];
}, "parseDuration"), ec9 = h(function(e, t, r, i = !1) {
	r = r.trim();
	let n = /^until\s+(?<ids>[\d\w- ]+)/.exec(r);
	if (null !== n) {
		let e = null;
		for (let t of n.groups.ids.split(" ")) {
			let r = eho(t);
			void 0 !== r && (!e || r.startTime < e.startTime) && (e = r);
		}
		if (e) return e.startTime;
		let t = /* @__PURE__ */ new Date();
		return t.setHours(0, 0, 0, 0), t;
	}
	let a = (0, ecs.default)(r, t.trim(), !0);
	if (a.isValid()) return i && (a = a.add(1, "d")), a.toDate();
	let s = (0, ecs.default)(e), [o, l] = ec8(r);
	if (!Number.isNaN(o)) {
		let e = s.add(o, l);
		e.isValid() && (s = e);
	}
	return s.toDate();
}, "getEndDate"), ehe = 0, eht = h(function(e) {
	return void 0 === e ? "task" + (ehe += 1) : e;
}, "parseId"), ehr = h(function(e, t) {
	let r = (":" === t.substr(0, 1) ? t.substr(1, t.length) : t).split(","), i = {};
	ehy(r, i, ecE);
	for (let e = 0; e < r.length; e++) r[e] = r[e].trim();
	let n = "";
	switch (r.length) {
		case 1:
			i.id = eht(), i.startTime = e.endTime, n = r[0];
			break;
		case 2:
			i.id = eht(), i.startTime = ec7(void 0, ecg, r[0]), n = r[1];
			break;
		case 3: i.id = eht(r[0]), i.startTime = ec7(void 0, ecg, r[1]), n = r[2];
	}
	return n && (i.endTime = ec9(i.startTime, ecg, n, ecS), i.manualEndTime = (0, ecs.default)(n, "YYYY-MM-DD", !0).isValid(), ec3(i, ecg, ecx, ecv)), i;
}, "compileData"), ehi = h(function(e, t) {
	let r = (":" === t.substr(0, 1) ? t.substr(1, t.length) : t).split(","), i = {};
	ehy(r, i, ecE);
	for (let e = 0; e < r.length; e++) r[e] = r[e].trim();
	switch (r.length) {
		case 1:
			i.id = eht(), i.startTime = {
				type: "prevTaskEnd",
				id: e
			}, i.endTime = { data: r[0] };
			break;
		case 2:
			i.id = eht(), i.startTime = {
				type: "getStartDate",
				startData: r[0]
			}, i.endTime = { data: r[1] };
			break;
		case 3: i.id = eht(r[0]), i.startTime = {
			type: "getStartDate",
			startData: r[1]
		}, i.endTime = { data: r[2] };
	}
	return i;
}, "parseData"), ehn = [], eha = {}, ehs = h(function(e, t) {
	let r = {
		section: ecT,
		type: ecT,
		processed: !1,
		manualEndTime: !1,
		renderEndTime: null,
		raw: { data: t },
		task: e,
		classes: []
	}, i = ehi(ecp, t);
	r.raw.startTime = i.startTime, r.raw.endTime = i.endTime, r.id = i.id, r.prevTaskId = ecp, r.active = i.active, r.done = i.done, r.crit = i.crit, r.milestone = i.milestone, r.vert = i.vert, r.order = ecN, ecN++;
	let n = ehn.push(r);
	ecp = r.id, eha[r.id] = n - 1;
}, "addTask"), eho = h(function(e) {
	return ehn[eha[e]];
}, "findTaskById"), ehl = h(function(e, t) {
	let r = {
		section: ecT,
		type: ecT,
		description: e,
		task: e,
		classes: []
	}, i = ehr(ecd, t);
	r.startTime = i.startTime, r.endTime = i.endTime, r.id = i.id, r.active = i.active, r.done = i.done, r.crit = i.crit, r.milestone = i.milestone, r.vert = i.vert, ecd = r, eck.push(r);
}, "addTaskOrg"), ehc = h(function() {
	let e = h(function(e) {
		let t = ehn[e], r = "";
		switch (ehn[e].raw.startTime.type) {
			case "prevTaskEnd":
				t.startTime = eho(t.prevTaskId).endTime;
				break;
			case "getStartDate": (r = ec7(void 0, ecg, ehn[e].raw.startTime.startData)) && (ehn[e].startTime = r);
		}
		return ehn[e].startTime && (ehn[e].endTime = ec9(ehn[e].startTime, ecg, ehn[e].raw.endTime.data, ecS), ehn[e].endTime && (ehn[e].processed = !0, ehn[e].manualEndTime = (0, ecs.default)(ehn[e].raw.endTime.data, "YYYY-MM-DD", !0).isValid(), ec3(ehn[e], ecg, ecx, ecv))), ehn[e].processed;
	}, "compileTask"), t = !0;
	for (let [r, i] of ehn.entries()) e(r), t = t && i.processed;
	return t;
}, "compileTasks"), ehh = h(function(e, t) {
	let r = t;
	"loose" !== IA().securityLevel && (r = (0, eca.sanitizeUrl)(t)), e.split(",").forEach(function(e) {
		void 0 !== eho(e) && (ehp(e, () => {
			window.open(r, "_self");
		}), ecb.set(e, r));
	}), ehu(e, "clickable");
}, "setLink"), ehu = h(function(e, t) {
	e.split(",").forEach(function(e) {
		let r = eho(e);
		void 0 !== r && r.classes.push(t);
	});
}, "setClass"), ehd = h(function(e, t, r) {
	if ("loose" !== IA().securityLevel || void 0 === t) return;
	let i = [];
	if ("string" == typeof r) {
		i = r.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
		for (let e = 0; e < i.length; e++) {
			let t = i[e].trim();
			t.startsWith("\"") && t.endsWith("\"") && (t = t.substr(1, t.length - 2)), i[e] = t;
		}
	}
	0 === i.length && i.push(e), void 0 !== eho(e) && ehp(e, () => {
		VN(t, ...i);
	});
}, "setClickFun"), ehp = h(function(e, t) {
	ecC.push(function() {
		let r = document.querySelector(`[id="${e}"]`);
		null !== r && r.addEventListener("click", function() {
			t();
		});
	}, function() {
		let r = document.querySelector(`[id="${e}-text"]`);
		null !== r && r.addEventListener("click", function() {
			t();
		});
	});
}, "pushFun"), ehf = h(function(e, t, r) {
	e.split(",").forEach(function(e) {
		ehd(e, t, r);
	}), ehu(e, "clickable");
}, "setClickEvent"), ehg = h(function(e) {
	ecC.forEach(function(t) {
		t(e);
	});
}, "bindFunctions"), ehm = {
	getConfig: h(() => IA().gantt, "getConfig"),
	clear: ecI,
	setDateFormat: ecF,
	getDateFormat: ecY,
	enableInclusiveEndDates: ecz,
	endDatesAreInclusive: ecU,
	enableTopAxis: ecG,
	topAxisEnabled: ecq,
	setAxisFormat: ecM,
	getAxisFormat: ecD,
	setTickInterval: ecO,
	getTickInterval: ec$,
	setTodayMarker: ecP,
	getTodayMarker: ecB,
	setAccTitle: Da,
	getAccTitle: Ds,
	setDiagramTitle: Dc,
	getDiagramTitle: Dh,
	setDisplayMode: ecj,
	getDisplayMode: ecW,
	setAccDescription: Do,
	getAccDescription: Dl,
	addSection: ecQ,
	getSections: ecJ,
	getTasks: ec0,
	addTask: ehs,
	findTaskById: eho,
	addTaskOrg: ehl,
	setIncludes: ecV,
	getIncludes: ecH,
	setExcludes: ecX,
	getExcludes: ecK,
	setClickEvent: ehf,
	setLink: ehh,
	getLinks: ecZ,
	bindFunctions: ehg,
	parseDuration: ec8,
	isInvalidDate: ec1,
	setWeekday: ec2,
	getWeekday: ec4,
	setWeekend: ec5
};
function ehy(e, t, r) {
	let i = !0;
	for (; i;) i = !1, r.forEach(function(r) {
		let n = RegExp("^\\s*" + r + "\\s*$");
		e[0].match(n) && (t[r] = !0, e.shift(1), i = !0);
	});
}
h(ehy, "getTaskTags");
var ehv, ehx = g(wX(), 1), ehb = h(function() {
	wQ.debug("Something is calling, setConf, remove the call");
}, "setConf"), ehw = {
	monday: CW,
	tuesday: CY,
	wednesday: CV,
	thursday: CH,
	friday: CX,
	saturday: CK,
	sunday: Cj
}, ehk = h((e, t) => {
	let r = [...e].map(() => -Infinity), i = [...e].sort((e, t) => e.startTime - t.startTime || e.order - t.order), n = 0;
	for (let e of i) for (let i = 0; i < r.length; i++) if (e.startTime >= r[i]) {
		r[i] = e.endTime, e.order = i + t, i > n && (n = i);
		break;
	}
	return n;
}, "getMaxIntersections"), ehT = {
	parser: ecn,
	db: ehm,
	renderer: {
		setConf: ehb,
		draw: h(function(e, t, r, i) {
			let n = IA().gantt, a = IA().securityLevel, s;
			"sandbox" === a && (s = _t("#i" + t));
			let o = "sandbox" === a ? _t(s.nodes()[0].contentDocument.body) : _t("body"), l = "sandbox" === a ? s.nodes()[0].contentDocument : document, u = l.getElementById(t);
			void 0 === (ehv = u.parentElement.offsetWidth) && (ehv = 1200), void 0 !== n.useWidth && (ehv = n.useWidth);
			let d = i.db.getTasks(), p = [];
			for (let e of d) p.push(e.type);
			p = E(p);
			let f = {}, g = 2 * n.topPadding;
			if ("compact" === i.db.getDisplayMode() || "compact" === n.displayMode) {
				let e = {};
				for (let t of d) void 0 === e[t.section] ? e[t.section] = [t] : e[t.section].push(t);
				let t = 0;
				for (let r of Object.keys(e)) {
					let i = ehk(e[r], t) + 1;
					t += i, g += i * (n.barHeight + n.barGap), f[r] = i;
				}
			} else for (let e of (g += d.length * (n.barHeight + n.barGap), p)) f[e] = d.filter((t) => t.type === e).length;
			u.setAttribute("viewBox", "0 0 " + ehv + " " + g);
			let m = o.select(`[id="${t}"]`), y = Ab().domain([w2(d, function(e) {
				return e.startTime;
			}), w1(d, function(e) {
				return e.endTime;
			})]).rangeRound([0, ehv - n.leftPadding - n.rightPadding]);
			function v(e, t) {
				let r = e.startTime, i = t.startTime, n = 0;
				return r > i ? n = 1 : r < i && (n = -1), n;
			}
			function x(e, t, r) {
				let a = n.barHeight, s = a + n.barGap, o = n.topPadding, l = n.leftPadding, h = CR().domain([0, p.length]).range(["#00B9FA", "#F95002"]).interpolate(_9);
				w(s, o, l, t, r, e, i.db.getExcludes(), i.db.getIncludes()), k(l, o, t, r), b(e, s, o, l, a, h, t, r), T(s, o, l, a, h), _(l, o, t, r);
			}
			function b(e, r, a, s, o, l, h) {
				e.sort((e, t) => e.vert === t.vert ? 0 : e.vert ? 1 : -1);
				let u = [...new Set(e.map((e) => e.order))].map((t) => e.find((e) => e.order === t));
				m.append("g").selectAll("rect").data(u).enter().append("rect").attr("x", 0).attr("y", function(e, t) {
					return e.order * r + a - 2;
				}).attr("width", function() {
					return h - n.rightPadding / 2;
				}).attr("height", r).attr("class", function(e) {
					for (let [t, r] of p.entries()) if (e.type === r) return "section section" + t % n.numberSectionStyles;
					return "section section0";
				}).enter();
				let f = m.append("g").selectAll("rect").data(e).enter(), g = i.db.getLinks();
				if (f.append("rect").attr("id", function(e) {
					return e.id;
				}).attr("rx", 3).attr("ry", 3).attr("x", function(e) {
					return e.milestone ? y(e.startTime) + s + .5 * (y(e.endTime) - y(e.startTime)) - .5 * o : y(e.startTime) + s;
				}).attr("y", function(e, t) {
					return t = e.order, e.vert ? n.gridLineStartPadding : t * r + a;
				}).attr("width", function(e) {
					return e.milestone ? o : e.vert ? .08 * o : y(e.renderEndTime || e.endTime) - y(e.startTime);
				}).attr("height", function(e) {
					return e.vert ? d.length * (n.barHeight + n.barGap) + 2 * n.barHeight : o;
				}).attr("transform-origin", function(e, t) {
					return t = e.order, (y(e.startTime) + s + .5 * (y(e.endTime) - y(e.startTime))).toString() + "px " + (t * r + a + .5 * o).toString() + "px";
				}).attr("class", function(e) {
					let t = "";
					e.classes.length > 0 && (t = e.classes.join(" "));
					let r = 0;
					for (let [t, i] of p.entries()) e.type === i && (r = t % n.numberSectionStyles);
					let i = "";
					return e.active ? e.crit ? i += " activeCrit" : i = " active" : e.done ? i = e.crit ? " doneCrit" : " done" : e.crit && (i += " crit"), 0 === i.length && (i = " task"), e.milestone && (i = " milestone " + i), e.vert && (i = " vert " + i), i += r, "task" + (i += " " + t);
				}), f.append("text").attr("id", function(e) {
					return e.id + "-text";
				}).text(function(e) {
					return e.task;
				}).attr("font-size", n.fontSize).attr("x", function(e) {
					let t = y(e.startTime), r = y(e.renderEndTime || e.endTime);
					if (e.milestone && (t += .5 * (y(e.endTime) - y(e.startTime)) - .5 * o, r = t + o), e.vert) return y(e.startTime) + s;
					let i = this.getBBox().width;
					return i > r - t ? r + i + 1.5 * n.leftPadding > h ? t + s - 5 : r + s + 5 : (r - t) / 2 + t + s;
				}).attr("y", function(e, t) {
					return e.vert ? n.gridLineStartPadding + d.length * (n.barHeight + n.barGap) + 60 : e.order * r + n.barHeight / 2 + (n.fontSize / 2 - 2) + a;
				}).attr("text-height", o).attr("class", function(e) {
					let t = y(e.startTime), r = y(e.endTime);
					e.milestone && (r = t + o);
					let i = this.getBBox().width, a = "";
					e.classes.length > 0 && (a = e.classes.join(" "));
					let s = 0;
					for (let [t, r] of p.entries()) e.type === r && (s = t % n.numberSectionStyles);
					let l = "";
					return e.active && (l = e.crit ? "activeCritText" + s : "activeText" + s), e.done ? l = e.crit ? l + " doneCritText" + s : l + " doneText" + s : e.crit && (l = l + " critText" + s), e.milestone && (l += " milestoneText"), e.vert && (l += " vertText"), i > r - t ? r + i + 1.5 * n.leftPadding > h ? a + " taskTextOutsideLeft taskTextOutside" + s + " " + l : a + " taskTextOutsideRight taskTextOutside" + s + " " + l + " width-" + i : a + " taskText taskText" + s + " " + l + " width-" + i;
				}), "sandbox" === IA().securityLevel) {
					let e = _t("#i" + t).nodes()[0].contentDocument;
					f.filter(function(e) {
						return g.has(e.id);
					}).each(function(t) {
						var r = e.querySelector("#" + t.id), i = e.querySelector("#" + t.id + "-text");
						let n = r.parentNode;
						var a = e.createElement("a");
						a.setAttribute("xlink:href", g.get(t.id)), a.setAttribute("target", "_top"), n.appendChild(a), a.appendChild(r), a.appendChild(i);
					});
				}
			}
			function w(e, t, r, a, s, o, l, h) {
				let u, d;
				if (0 === l.length && 0 === h.length) return;
				for (let { startTime: e, endTime: t } of o) (void 0 === u || e < u) && (u = e), (void 0 === d || t > d) && (d = t);
				if (!u || !d) return;
				if ((0, ehx.default)(d).diff((0, ehx.default)(u), "year") > 5) return void wQ.warn("The difference between the min and max time is more than 5 years. This will cause performance issues. Skipping drawing exclude days.");
				let p = i.db.getDateFormat(), f = [], g = null, v = (0, ehx.default)(u);
				for (; v.valueOf() <= d;) i.db.isInvalidDate(v, p, l, h) ? g ? g.end = v : g = {
					start: v,
					end: v
				} : g && (f.push(g), g = null), v = v.add(1, "d");
				m.append("g").selectAll("rect").data(f).enter().append("rect").attr("id", (e) => "exclude-" + e.start.format("YYYY-MM-DD")).attr("x", (e) => y(e.start.startOf("day")) + r).attr("y", n.gridLineStartPadding).attr("width", (e) => y(e.end.endOf("day")) - y(e.start.startOf("day"))).attr("height", s - t - n.gridLineStartPadding).attr("transform-origin", function(t, i) {
					return (y(t.start) + r + .5 * (y(t.end) - y(t.start))).toString() + "px " + (i * e + .5 * s).toString() + "px";
				}).attr("class", "exclude-range");
			}
			function k(e, t, r, a) {
				let s = i.db.getDateFormat(), o = i.db.getAxisFormat(), l;
				l = o || ("D" === s ? "%d" : n.axisFormat ?? "%Y-%m-%d");
				let h = kw(y).tickSize(-a + t + n.gridLineStartPadding).tickFormat(L1(l)), u = /^([1-9]\d*)(millisecond|second|minute|hour|day|week|month)$/.exec(i.db.getTickInterval() || n.tickInterval);
				if (null !== u) {
					let e = u[1], t = u[2], r = i.db.getWeekday() || n.weekday;
					switch (t) {
						case "millisecond":
							h.ticks(CD.every(e));
							break;
						case "second":
							h.ticks(CO.every(e));
							break;
						case "minute":
							h.ticks(C$.every(e));
							break;
						case "hour":
							h.ticks(CB.every(e));
							break;
						case "day":
							h.ticks(Cz.every(e));
							break;
						case "week":
							h.ticks(ehw[r].every(e));
							break;
						case "month": h.ticks(C3.every(e));
					}
				}
				if (m.append("g").attr("class", "grid").attr("transform", "translate(" + e + ", " + (a - 50) + ")").call(h).selectAll("text").style("text-anchor", "middle").attr("fill", "#000").attr("stroke", "none").attr("font-size", 10).attr("dy", "1em"), i.db.topAxisEnabled() || n.topAxis) {
					let r = kb(y).tickSize(-a + t + n.gridLineStartPadding).tickFormat(L1(l));
					if (null !== u) {
						let e = u[1], t = u[2], a = i.db.getWeekday() || n.weekday;
						switch (t) {
							case "millisecond":
								r.ticks(CD.every(e));
								break;
							case "second":
								r.ticks(CO.every(e));
								break;
							case "minute":
								r.ticks(C$.every(e));
								break;
							case "hour":
								r.ticks(CB.every(e));
								break;
							case "day":
								r.ticks(Cz.every(e));
								break;
							case "week":
								r.ticks(ehw[a].every(e));
								break;
							case "month": r.ticks(C3.every(e));
						}
					}
					m.append("g").attr("class", "grid").attr("transform", "translate(" + e + ", " + t + ")").call(r).selectAll("text").style("text-anchor", "middle").attr("fill", "#000").attr("stroke", "none").attr("font-size", 10);
				}
			}
			function T(e, t) {
				let r = 0, i = Object.keys(f).map((e) => [e, f[e]]);
				m.append("g").selectAll("text").data(i).enter().append(function(e) {
					let t = e[0].split(M1.lineBreakRegex), r = -(t.length - 1) / 2, i = l.createElementNS("http://www.w3.org/2000/svg", "text");
					for (let [e, n] of (i.setAttribute("dy", r + "em"), t.entries())) {
						let t = l.createElementNS("http://www.w3.org/2000/svg", "tspan");
						t.setAttribute("alignment-baseline", "central"), t.setAttribute("x", "10"), e > 0 && t.setAttribute("dy", "1em"), t.textContent = n, i.appendChild(t);
					}
					return i;
				}).attr("x", 10).attr("y", function(n, a) {
					if (!(a > 0)) return n[1] * e / 2 + t;
					for (let s = 0; s < a; s++) return r += i[a - 1][1], n[1] * e / 2 + r * e + t;
				}).attr("font-size", n.sectionFontSize).attr("class", function(e) {
					for (let [t, r] of p.entries()) if (e[0] === r) return "sectionTitle sectionTitle" + t % n.numberSectionStyles;
					return "sectionTitle";
				});
			}
			function _(e, t, r, a) {
				let s = i.db.getTodayMarker();
				if ("off" === s) return;
				let o = m.append("g").attr("class", "today"), l = /* @__PURE__ */ new Date(), h = o.append("line");
				h.attr("x1", y(l) + e).attr("x2", y(l) + e).attr("y1", n.titleTopMargin).attr("y2", a - n.titleTopMargin).attr("class", "today"), "" !== s && h.attr("style", s.replace(/,/g, ";"));
			}
			function E(e) {
				let t = {}, r = [];
				for (let i = 0, n = e.length; i < n; ++i) Object.prototype.hasOwnProperty.call(t, e[i]) || (t[e[i]] = !0, r.push(e[i]));
				return r;
			}
			h(v, "taskCompare"), d.sort(v), x(d, ehv, g), M5(m, g, ehv, n.useMaxWidth), m.append("text").text(i.db.getDiagramTitle()).attr("x", ehv / 2).attr("y", n.titleTopMargin).attr("class", "titleText"), h(x, "makeGantt"), h(b, "drawRects"), h(w, "drawExcludeDays"), h(k, "makeGrid"), h(T, "vertLabels"), h(_, "drawToday"), h(E, "checkUnique");
		}, "draw")
	},
	styles: h((e) => `
  .mermaid-main-font {
        font-family: ${e.fontFamily};
  }

  .exclude-range {
    fill: ${e.excludeBkgColor};
  }

  .section {
    stroke: none;
    opacity: 0.2;
  }

  .section0 {
    fill: ${e.sectionBkgColor};
  }

  .section2 {
    fill: ${e.sectionBkgColor2};
  }

  .section1,
  .section3 {
    fill: ${e.altSectionBkgColor};
    opacity: 0.2;
  }

  .sectionTitle0 {
    fill: ${e.titleColor};
  }

  .sectionTitle1 {
    fill: ${e.titleColor};
  }

  .sectionTitle2 {
    fill: ${e.titleColor};
  }

  .sectionTitle3 {
    fill: ${e.titleColor};
  }

  .sectionTitle {
    text-anchor: start;
    font-family: ${e.fontFamily};
  }


  /* Grid and axis */

  .grid .tick {
    stroke: ${e.gridColor};
    opacity: 0.8;
    shape-rendering: crispEdges;
  }

  .grid .tick text {
    font-family: ${e.fontFamily};
    fill: ${e.textColor};
  }

  .grid path {
    stroke-width: 0;
  }


  /* Today line */

  .today {
    fill: none;
    stroke: ${e.todayLineColor};
    stroke-width: 2px;
  }


  /* Task styling */

  /* Default task */

  .task {
    stroke-width: 2;
  }

  .taskText {
    text-anchor: middle;
    font-family: ${e.fontFamily};
  }

  .taskTextOutsideRight {
    fill: ${e.taskTextDarkColor};
    text-anchor: start;
    font-family: ${e.fontFamily};
  }

  .taskTextOutsideLeft {
    fill: ${e.taskTextDarkColor};
    text-anchor: end;
  }


  /* Special case clickable */

  .task.clickable {
    cursor: pointer;
  }

  .taskText.clickable {
    cursor: pointer;
    fill: ${e.taskTextClickableColor} !important;
    font-weight: bold;
  }

  .taskTextOutsideLeft.clickable {
    cursor: pointer;
    fill: ${e.taskTextClickableColor} !important;
    font-weight: bold;
  }

  .taskTextOutsideRight.clickable {
    cursor: pointer;
    fill: ${e.taskTextClickableColor} !important;
    font-weight: bold;
  }


  /* Specific task settings for the sections*/

  .taskText0,
  .taskText1,
  .taskText2,
  .taskText3 {
    fill: ${e.taskTextColor};
  }

  .task0,
  .task1,
  .task2,
  .task3 {
    fill: ${e.taskBkgColor};
    stroke: ${e.taskBorderColor};
  }

  .taskTextOutside0,
  .taskTextOutside2
  {
    fill: ${e.taskTextOutsideColor};
  }

  .taskTextOutside1,
  .taskTextOutside3 {
    fill: ${e.taskTextOutsideColor};
  }


  /* Active task */

  .active0,
  .active1,
  .active2,
  .active3 {
    fill: ${e.activeTaskBkgColor};
    stroke: ${e.activeTaskBorderColor};
  }

  .activeText0,
  .activeText1,
  .activeText2,
  .activeText3 {
    fill: ${e.taskTextDarkColor} !important;
  }


  /* Completed task */

  .done0,
  .done1,
  .done2,
  .done3 {
    stroke: ${e.doneTaskBorderColor};
    fill: ${e.doneTaskBkgColor};
    stroke-width: 2;
  }

  .doneText0,
  .doneText1,
  .doneText2,
  .doneText3 {
    fill: ${e.taskTextDarkColor} !important;
  }


  /* Tasks on the critical line */

  .crit0,
  .crit1,
  .crit2,
  .crit3 {
    stroke: ${e.critBorderColor};
    fill: ${e.critBkgColor};
    stroke-width: 2;
  }

  .activeCrit0,
  .activeCrit1,
  .activeCrit2,
  .activeCrit3 {
    stroke: ${e.critBorderColor};
    fill: ${e.activeTaskBkgColor};
    stroke-width: 2;
  }

  .doneCrit0,
  .doneCrit1,
  .doneCrit2,
  .doneCrit3 {
    stroke: ${e.critBorderColor};
    fill: ${e.doneTaskBkgColor};
    stroke-width: 2;
    cursor: pointer;
    shape-rendering: crispEdges;
  }

  .milestone {
    transform: rotate(45deg) scale(0.8,0.8);
  }

  .milestoneText {
    font-style: italic;
  }
  .doneCritText0,
  .doneCritText1,
  .doneCritText2,
  .doneCritText3 {
    fill: ${e.taskTextDarkColor} !important;
  }

  .vert {
    stroke: ${e.vertLineColor};
  }

  .vertText {
    font-size: 15px;
    text-anchor: middle;
    fill: ${e.vertLineColor} !important;
  }

  .activeCritText0,
  .activeCritText1,
  .activeCritText2,
  .activeCritText3 {
    fill: ${e.taskTextDarkColor} !important;
  }

  .titleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${e.titleColor || e.textColor};
    font-family: ${e.fontFamily};
  }
`, "getStyles")
}, eh_ = class {
	constructor(e) {
		this.init = e, this.records = this.init();
	}
	static {
		h(this, "ImperativeState");
	}
	reset() {
		this.records = this.init();
	}
}, ehE = {
	NORMAL: 0,
	REVERSE: 1,
	HIGHLIGHT: 2,
	MERGE: 3,
	CHERRY_PICK: 4
}, ehC = Ip.gitGraph, ehS = h(() => V5({
	...ehC,
	...IA().gitGraph
}), "getConfig"), ehA = new eh_(() => {
	let e = ehS(), t = e.mainBranchName, r = e.mainBranchOrder;
	return {
		mainBranchName: t,
		commits: /* @__PURE__ */ new Map(),
		head: null,
		branchConfig: new Map([[t, {
			name: t,
			order: r
		}]]),
		branches: new Map([[t, null]]),
		currBranch: t,
		direction: "LR",
		seq: 0,
		options: {}
	};
});
function ehL() {
	return VG({ length: 7 });
}
function ehR(e, t) {
	let r = Object.create(null);
	return e.reduce((e, i) => {
		let n = t(i);
		return r[n] || (r[n] = !0, e.push(i)), e;
	}, []);
}
h(ehL, "getID"), h(ehR, "uniqBy");
var ehN = h(function(e) {
	ehA.records.direction = e;
}, "setDirection"), ehI = h(function(e) {
	wQ.debug("options str", e), e = (e = e?.trim()) || "{}";
	try {
		ehA.records.options = JSON.parse(e);
	} catch (e) {
		wQ.error("error while parsing gitGraph options", e.message);
	}
}, "setOptions"), ehM = h(function() {
	return ehA.records.options;
}, "getOptions"), ehD = h(function(e) {
	let t = e.msg, r = e.id, i = e.type, n = e.tags;
	wQ.info("commit", t, r, i, n), wQ.debug("Entering commit:", t, r, i, n);
	let a = ehS();
	r = M1.sanitizeText(r, a), t = M1.sanitizeText(t, a), n = n?.map((e) => M1.sanitizeText(e, a));
	let s = {
		id: r || ehA.records.seq + "-" + ehL(),
		message: t,
		seq: ehA.records.seq++,
		type: i ?? ehE.NORMAL,
		tags: n ?? [],
		parents: null == ehA.records.head ? [] : [ehA.records.head.id],
		branch: ehA.records.currBranch
	};
	ehA.records.head = s, wQ.info("main branch", a.mainBranchName), ehA.records.commits.has(s.id) && wQ.warn(`Commit ID ${s.id} already exists`), ehA.records.commits.set(s.id, s), ehA.records.branches.set(ehA.records.currBranch, s.id), wQ.debug("in pushCommit " + s.id);
}, "commit"), ehO = h(function(e) {
	let t = e.name, r = e.order;
	if (t = M1.sanitizeText(t, ehS()), ehA.records.branches.has(t)) throw Error(`Trying to create an existing branch. (Help: Either use a new name if you want create a new branch or try using "checkout ${t}")`);
	ehA.records.branches.set(t, null != ehA.records.head ? ehA.records.head.id : null), ehA.records.branchConfig.set(t, {
		name: t,
		order: r
	}), ehB(t), wQ.debug("in createBranch");
}, "branch"), eh$ = h((e) => {
	let t = e.branch, r = e.id, i = e.type, n = e.tags, a = ehS();
	t = M1.sanitizeText(t, a), r && (r = M1.sanitizeText(r, a));
	let s = ehA.records.branches.get(ehA.records.currBranch), o = ehA.records.branches.get(t), l = s ? ehA.records.commits.get(s) : void 0, h = o ? ehA.records.commits.get(o) : void 0;
	if (l && h && l.branch === t) throw Error(`Cannot merge branch '${t}' into itself.`);
	if (ehA.records.currBranch === t) {
		let e = Error("Incorrect usage of \"merge\". Cannot merge a branch to itself");
		throw e.hash = {
			text: `merge ${t}`,
			token: `merge ${t}`,
			expected: ["branch abc"]
		}, e;
	}
	if (void 0 === l || !l) {
		let e = Error(`Incorrect usage of "merge". Current branch (${ehA.records.currBranch})has no commits`);
		throw e.hash = {
			text: `merge ${t}`,
			token: `merge ${t}`,
			expected: ["commit"]
		}, e;
	}
	if (!ehA.records.branches.has(t)) {
		let e = Error("Incorrect usage of \"merge\". Branch to be merged (" + t + ") does not exist");
		throw e.hash = {
			text: `merge ${t}`,
			token: `merge ${t}`,
			expected: [`branch ${t}`]
		}, e;
	}
	if (void 0 === h || !h) {
		let e = Error("Incorrect usage of \"merge\". Branch to be merged (" + t + ") has no commits");
		throw e.hash = {
			text: `merge ${t}`,
			token: `merge ${t}`,
			expected: ["\"commit\""]
		}, e;
	}
	if (l === h) {
		let e = Error("Incorrect usage of \"merge\". Both branches have same head");
		throw e.hash = {
			text: `merge ${t}`,
			token: `merge ${t}`,
			expected: ["branch abc"]
		}, e;
	}
	if (r && ehA.records.commits.has(r)) {
		let e = Error("Incorrect usage of \"merge\". Commit with id:" + r + " already exists, use different custom id");
		throw e.hash = {
			text: `merge ${t} ${r} ${i} ${n?.join(" ")}`,
			token: `merge ${t} ${r} ${i} ${n?.join(" ")}`,
			expected: [`merge ${t} ${r}_UNIQUE ${i} ${n?.join(" ")}`]
		}, e;
	}
	let u = {
		id: r || `${ehA.records.seq}-${ehL()}`,
		message: `merged branch ${t} into ${ehA.records.currBranch}`,
		seq: ehA.records.seq++,
		parents: null == ehA.records.head ? [] : [ehA.records.head.id, o || ""],
		branch: ehA.records.currBranch,
		type: ehE.MERGE,
		customType: i,
		customId: !!r,
		tags: n ?? []
	};
	ehA.records.head = u, ehA.records.commits.set(u.id, u), ehA.records.branches.set(ehA.records.currBranch, u.id), wQ.debug(ehA.records.branches), wQ.debug("in mergeBranch");
}, "merge"), ehP = h(function(e) {
	let t = e.id, r = e.targetId, i = e.tags, n = e.parent;
	wQ.debug("Entering cherryPick:", t, r, i);
	let a = ehS();
	if (t = M1.sanitizeText(t, a), r = M1.sanitizeText(r, a), i = i?.map((e) => M1.sanitizeText(e, a)), n = M1.sanitizeText(n, a), !t || !ehA.records.commits.has(t)) {
		let e = Error("Incorrect usage of \"cherryPick\". Source commit id should exist and provided");
		throw e.hash = {
			text: `cherryPick ${t} ${r}`,
			token: `cherryPick ${t} ${r}`,
			expected: ["cherry-pick abc"]
		}, e;
	}
	let s = ehA.records.commits.get(t);
	if (void 0 === s || !s) throw Error("Incorrect usage of \"cherryPick\". Source commit id should exist and provided");
	if (n && !(Array.isArray(s.parents) && s.parents.includes(n))) throw Error("Invalid operation: The specified parent commit is not an immediate parent of the cherry-picked commit.");
	let o = s.branch;
	if (s.type === ehE.MERGE && !n) throw Error("Incorrect usage of cherry-pick: If the source commit is a merge commit, an immediate parent commit must be specified.");
	if (!r || !ehA.records.commits.has(r)) {
		if (o === ehA.records.currBranch) {
			let e = Error("Incorrect usage of \"cherryPick\". Source commit is already on current branch");
			throw e.hash = {
				text: `cherryPick ${t} ${r}`,
				token: `cherryPick ${t} ${r}`,
				expected: ["cherry-pick abc"]
			}, e;
		}
		let e = ehA.records.branches.get(ehA.records.currBranch);
		if (void 0 === e || !e) {
			let e = Error(`Incorrect usage of "cherry-pick". Current branch (${ehA.records.currBranch})has no commits`);
			throw e.hash = {
				text: `cherryPick ${t} ${r}`,
				token: `cherryPick ${t} ${r}`,
				expected: ["cherry-pick abc"]
			}, e;
		}
		let a = ehA.records.commits.get(e);
		if (void 0 === a || !a) {
			let e = Error(`Incorrect usage of "cherry-pick". Current branch (${ehA.records.currBranch})has no commits`);
			throw e.hash = {
				text: `cherryPick ${t} ${r}`,
				token: `cherryPick ${t} ${r}`,
				expected: ["cherry-pick abc"]
			}, e;
		}
		let l = {
			id: ehA.records.seq + "-" + ehL(),
			message: `cherry-picked ${s?.message} into ${ehA.records.currBranch}`,
			seq: ehA.records.seq++,
			parents: null == ehA.records.head ? [] : [ehA.records.head.id, s.id],
			branch: ehA.records.currBranch,
			type: ehE.CHERRY_PICK,
			tags: i ? i.filter(Boolean) : [`cherry-pick:${s.id}${s.type === ehE.MERGE ? `|parent:${n}` : ""}`]
		};
		ehA.records.head = l, ehA.records.commits.set(l.id, l), ehA.records.branches.set(ehA.records.currBranch, l.id), wQ.debug(ehA.records.branches), wQ.debug("in cherryPick");
	}
}, "cherryPick"), ehB = h(function(e) {
	if (e = M1.sanitizeText(e, ehS()), ehA.records.branches.has(e)) {
		ehA.records.currBranch = e;
		let t = ehA.records.branches.get(ehA.records.currBranch);
		void 0 !== t && t ? ehA.records.head = ehA.records.commits.get(t) ?? null : ehA.records.head = null;
	} else {
		let t = Error(`Trying to checkout branch which is not yet created. (Help try using "branch ${e}")`);
		throw t.hash = {
			text: `checkout ${e}`,
			token: `checkout ${e}`,
			expected: [`branch ${e}`]
		}, t;
	}
}, "checkout");
function ehF(e, t, r) {
	let i = e.indexOf(t);
	-1 === i ? e.push(r) : e.splice(i, 1, r);
}
function ehz(e) {
	let t = e.reduce((e, t) => e.seq > t.seq ? e : t, e[0]), r = "";
	e.forEach(function(e) {
		e === t ? r += "	*" : r += "	|";
	});
	let i = [
		r,
		t.id,
		t.seq
	];
	for (let e in ehA.records.branches) ehA.records.branches.get(e) === t.id && i.push(e);
	if (wQ.debug(i.join(" ")), t.parents && 2 == t.parents.length && t.parents[0] && t.parents[1]) {
		let r = ehA.records.commits.get(t.parents[0]);
		ehF(e, t, r), t.parents[1] && e.push(ehA.records.commits.get(t.parents[1]));
	} else {
		if (0 == t.parents.length) return;
		if (t.parents[0]) {
			let r = ehA.records.commits.get(t.parents[0]);
			ehF(e, t, r);
		}
	}
	ehz(e = ehR(e, (e) => e.id));
}
h(ehF, "upsert"), h(ehz, "prettyPrintCommitHistory");
var ehU = h(function() {
	wQ.debug(ehA.records.commits), ehz([ehY()[0]]);
}, "prettyPrint"), ehG = h(function() {
	ehA.reset(), Dn();
}, "clear"), ehq = h(function() {
	return [...ehA.records.branchConfig.values()].map((e, t) => null !== e.order && void 0 !== e.order ? e : {
		...e,
		order: parseFloat(`0.${t}`)
	}).sort((e, t) => (e.order ?? 0) - (t.order ?? 0)).map(({ name: e }) => ({ name: e }));
}, "getBranchesAsObjArray"), ehj = h(function() {
	return ehA.records.branches;
}, "getBranches"), ehW = h(function() {
	return ehA.records.commits;
}, "getCommits"), ehY = h(function() {
	let e = [...ehA.records.commits.values()];
	return e.forEach(function(e) {
		wQ.debug(e.id);
	}), e.sort((e, t) => e.seq - t.seq), e;
}, "getCommitsArray"), ehV = {
	commitType: ehE,
	getConfig: ehS,
	setDirection: ehN,
	setOptions: ehI,
	getOptions: ehM,
	commit: ehD,
	branch: ehO,
	merge: eh$,
	cherryPick: ehP,
	checkout: ehB,
	prettyPrint: ehU,
	clear: ehG,
	getBranchesAsObjArray: ehq,
	getBranches: ehj,
	getCommits: ehW,
	getCommitsArray: ehY,
	getCurrentBranch: h(function() {
		return ehA.records.currBranch;
	}, "getCurrentBranch"),
	getDirection: h(function() {
		return ehA.records.direction;
	}, "getDirection"),
	getHead: h(function() {
		return ehA.records.head;
	}, "getHead"),
	setAccTitle: Da,
	getAccTitle: Ds,
	getAccDescription: Dl,
	setAccDescription: Do,
	setDiagramTitle: Dc,
	getDiagramTitle: Dh
}, ehH = h((e, t) => {
	for (let r of (w_(e, t), e.dir && t.setDirection(e.dir), e.statements)) ehX(r, t);
}, "populate"), ehX = h((e, t) => {
	let r = {
		Commit: h((e) => t.commit(ehK(e)), "Commit"),
		Branch: h((e) => t.branch(ehZ(e)), "Branch"),
		Merge: h((e) => t.merge(ehQ(e)), "Merge"),
		Checkout: h((e) => t.checkout(ehJ(e)), "Checkout"),
		CherryPicking: h((e) => t.cherryPick(eh0(e)), "CherryPicking")
	}[e.$type];
	r ? r(e) : wQ.error(`Unknown statement type: ${e.$type}`);
}, "parseStatement"), ehK = h((e) => ({
	id: e.id,
	msg: e.message ?? "",
	type: void 0 !== e.type ? ehE[e.type] : ehE.NORMAL,
	tags: e.tags ?? void 0
}), "parseCommit"), ehZ = h((e) => ({
	name: e.name,
	order: e.order ?? 0
}), "parseBranch"), ehQ = h((e) => ({
	branch: e.branch,
	id: e.id ?? "",
	type: void 0 !== e.type ? ehE[e.type] : void 0,
	tags: e.tags ?? void 0
}), "parseMerge"), ehJ = h((e) => e.branch, "parseCheckout"), eh0 = h((e) => ({
	id: e.id,
	targetId: "",
	tags: e.tags?.length === 0 ? void 0 : e.tags,
	parent: e.parent
}), "parseCherryPicking"), eh1 = { parse: h(async (e) => {
	let t = await wS("gitGraph", e);
	wQ.debug(t), ehH(t, ehV);
}, "parse") }, eh2 = IA()?.gitGraph, eh4 = /* @__PURE__ */ new Map(), eh5 = /* @__PURE__ */ new Map(), eh3 = /* @__PURE__ */ new Map(), eh6 = [], eh7 = 0, eh8 = "LR", eh9 = h(() => {
	eh4.clear(), eh5.clear(), eh3.clear(), eh7 = 0, eh6 = [], eh8 = "LR";
}, "clear"), eue = h((e) => {
	let t = document.createElementNS("http://www.w3.org/2000/svg", "text");
	return ("string" == typeof e ? e.split(/\\n|\n|<br\s*\/?>/gi) : e).forEach((e) => {
		let r = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
		r.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), r.setAttribute("dy", "1em"), r.setAttribute("x", "0"), r.setAttribute("class", "row"), r.textContent = e.trim(), t.appendChild(r);
	}), t;
}, "drawText"), eut = h((e) => {
	let t, r, i;
	return "BT" === eh8 ? (r = h((e, t) => e <= t, "comparisonFunc"), i = Infinity) : (r = h((e, t) => e >= t, "comparisonFunc"), i = 0), e.forEach((e) => {
		let n = "TB" === eh8 || "BT" == eh8 ? eh5.get(e)?.y : eh5.get(e)?.x;
		void 0 !== n && r(n, i) && (t = e, i = n);
	}), t;
}, "findClosestParent"), eur = h((e) => {
	let t = "", r = Infinity;
	return e.forEach((e) => {
		let i = eh5.get(e).y;
		i <= r && (t = e, r = i);
	}), t || void 0;
}, "findClosestParentBT"), eui = h((e, t, r) => {
	let i = r, n = r, a = [];
	e.forEach((e) => {
		let r = t.get(e);
		if (!r) throw Error(`Commit not found for key ${e}`);
		r.parents.length ? n = Math.max(i = eua(r), n) : a.push(r), eus(r, i);
	}), i = n, a.forEach((e) => {
		euo(e, i, r);
	}), e.forEach((e) => {
		let r = t.get(e);
		if (r?.parents.length) {
			let e = eur(r.parents);
			(i = eh5.get(e).y - 40) <= n && (n = i);
			let t = eh4.get(r.branch).pos, a = i - 10;
			eh5.set(r.id, {
				x: t,
				y: a
			});
		}
	});
}, "setParallelBTPos"), eun = h((e) => {
	let t = eut(e.parents.filter((e) => null !== e));
	if (!t) throw Error(`Closest parent not found for commit ${e.id}`);
	let r = eh5.get(t)?.y;
	if (void 0 === r) throw Error(`Closest parent position not found for commit ${e.id}`);
	return r;
}, "findClosestParentPos"), eua = h((e) => eun(e) + 40, "calculateCommitPosition"), eus = h((e, t) => {
	let r = eh4.get(e.branch);
	if (!r) throw Error(`Branch not found for commit ${e.id}`);
	let i = r.pos, n = t + 10;
	return eh5.set(e.id, {
		x: i,
		y: n
	}), {
		x: i,
		y: n
	};
}, "setCommitPosition"), euo = h((e, t, r) => {
	let i = eh4.get(e.branch);
	if (!i) throw Error(`Branch not found for commit ${e.id}`);
	let n = i.pos;
	eh5.set(e.id, {
		x: n,
		y: t + r
	});
}, "setRootPosition"), eul = h((e, t, r, i, n, a) => {
	if (a === ehE.HIGHLIGHT) e.append("rect").attr("x", r.x - 10).attr("y", r.y - 10).attr("width", 20).attr("height", 20).attr("class", `commit ${t.id} commit-highlight${n % 8} ${i}-outer`), e.append("rect").attr("x", r.x - 6).attr("y", r.y - 6).attr("width", 12).attr("height", 12).attr("class", `commit ${t.id} commit${n % 8} ${i}-inner`);
	else if (a === ehE.CHERRY_PICK) e.append("circle").attr("cx", r.x).attr("cy", r.y).attr("r", 10).attr("class", `commit ${t.id} ${i}`), e.append("circle").attr("cx", r.x - 3).attr("cy", r.y + 2).attr("r", 2.75).attr("fill", "#fff").attr("class", `commit ${t.id} ${i}`), e.append("circle").attr("cx", r.x + 3).attr("cy", r.y + 2).attr("r", 2.75).attr("fill", "#fff").attr("class", `commit ${t.id} ${i}`), e.append("line").attr("x1", r.x + 3).attr("y1", r.y + 1).attr("x2", r.x).attr("y2", r.y - 5).attr("stroke", "#fff").attr("class", `commit ${t.id} ${i}`), e.append("line").attr("x1", r.x - 3).attr("y1", r.y + 1).attr("x2", r.x).attr("y2", r.y - 5).attr("stroke", "#fff").attr("class", `commit ${t.id} ${i}`);
	else {
		let s = e.append("circle");
		if (s.attr("cx", r.x), s.attr("cy", r.y), s.attr("r", t.type === ehE.MERGE ? 9 : 10), s.attr("class", `commit ${t.id} commit${n % 8}`), a === ehE.MERGE) {
			let a = e.append("circle");
			a.attr("cx", r.x), a.attr("cy", r.y), a.attr("r", 6), a.attr("class", `commit ${i} ${t.id} commit${n % 8}`);
		}
		a === ehE.REVERSE && e.append("path").attr("d", `M ${r.x - 5},${r.y - 5}L${r.x + 5},${r.y + 5}M${r.x - 5},${r.y + 5}L${r.x + 5},${r.y - 5}`).attr("class", `commit ${i} ${t.id} commit${n % 8}`);
	}
}, "drawCommitBullet"), euc = h((e, t, r, i) => {
	if (t.type !== ehE.CHERRY_PICK && (t.customId && t.type === ehE.MERGE || t.type !== ehE.MERGE) && eh2?.showCommitLabel) {
		let n = e.append("g"), a = n.insert("rect").attr("class", "commit-label-bkg"), s = n.append("text").attr("x", i).attr("y", r.y + 25).attr("class", "commit-label").text(t.id), o = s.node()?.getBBox();
		if (o && (a.attr("x", r.posWithOffset - o.width / 2 - 2).attr("y", r.y + 13.5).attr("width", o.width + 4).attr("height", o.height + 4), "TB" === eh8 || "BT" === eh8 ? (a.attr("x", r.x - (o.width + 16 + 5)).attr("y", r.y - 12), s.attr("x", r.x - (o.width + 16)).attr("y", r.y + o.height - 12)) : s.attr("x", r.posWithOffset - o.width / 2), eh2.rotateCommitLabel)) if ("TB" === eh8 || "BT" === eh8) s.attr("transform", "rotate(-45, " + r.x + ", " + r.y + ")"), a.attr("transform", "rotate(-45, " + r.x + ", " + r.y + ")");
		else {
			let e = -7.5 - (o.width + 10) / 25 * 9.5, t = 10 + o.width / 25 * 8.5;
			n.attr("transform", "translate(" + e + ", " + t + ") rotate(-45, " + i + ", " + r.y + ")");
		}
	}
}, "drawCommitLabel"), euh = h((e, t, r, i) => {
	if (t.tags.length > 0) {
		let n = 0, a = 0, s = 0, o = [];
		for (let i of t.tags.reverse()) {
			let t = e.insert("polygon"), l = e.append("circle"), h = e.append("text").attr("y", r.y - 16 - n).attr("class", "tag-label").text(i), u = h.node()?.getBBox();
			if (!u) throw Error("Tag bbox not found");
			a = Math.max(a, u.width), s = Math.max(s, u.height), h.attr("x", r.posWithOffset - u.width / 2), o.push({
				tag: h,
				hole: l,
				rect: t,
				yOffset: n
			}), n += 20;
		}
		for (let { tag: e, hole: t, rect: n, yOffset: l } of o) {
			let o = s / 2, h = r.y - 19.2 - l;
			if (n.attr("class", "tag-label-bkg").attr("points", `
      ${i - a / 2 - 2},${h + 2}  
      ${i - a / 2 - 2},${h - 2}
      ${r.posWithOffset - a / 2 - 4},${h - o - 2}
      ${r.posWithOffset + a / 2 + 4},${h - o - 2}
      ${r.posWithOffset + a / 2 + 4},${h + o + 2}
      ${r.posWithOffset - a / 2 - 4},${h + o + 2}`), t.attr("cy", h).attr("cx", i - a / 2 + 2).attr("r", 1.5).attr("class", "tag-hole"), "TB" === eh8 || "BT" === eh8) {
				let s = i + l;
				n.attr("class", "tag-label-bkg").attr("points", `
        ${r.x},${s + 2}
        ${r.x},${s - 2}
        ${r.x + 10},${s - o - 2}
        ${r.x + 10 + a + 4},${s - o - 2}
        ${r.x + 10 + a + 4},${s + o + 2}
        ${r.x + 10},${s + o + 2}`).attr("transform", "translate(12,12) rotate(45, " + r.x + "," + i + ")"), t.attr("cx", r.x + 2).attr("cy", s).attr("transform", "translate(12,12) rotate(45, " + r.x + "," + i + ")"), e.attr("x", r.x + 5).attr("y", s + 3).attr("transform", "translate(14,14) rotate(45, " + r.x + "," + i + ")");
			}
		}
	}
}, "drawCommitTags"), euu = h((e) => {
	switch (e.customType ?? e.type) {
		case ehE.NORMAL: return "commit-normal";
		case ehE.REVERSE: return "commit-reverse";
		case ehE.HIGHLIGHT: return "commit-highlight";
		case ehE.MERGE: return "commit-merge";
		case ehE.CHERRY_PICK: return "commit-cherry-pick";
		default: return "commit-normal";
	}
}, "getCommitClassType"), eud = h((e, t, r, i) => {
	let n = {
		x: 0,
		y: 0
	};
	if (!(e.parents.length > 0)) return "TB" === t ? 30 : "BT" === t ? (i.get(e.id) ?? n).y - 40 : 0;
	{
		let r = eut(e.parents);
		if (r) {
			let a = i.get(r) ?? n;
			return "TB" === t ? a.y + 40 : "BT" === t ? (i.get(e.id) ?? n).y - 40 : a.x + 40;
		}
	}
	return 0;
}, "calculatePosition"), eup = h((e, t, r) => {
	let i = "BT" === eh8 && r ? t : t + 10, n = "TB" === eh8 || "BT" === eh8 ? i : eh4.get(e.branch)?.pos, a = "TB" === eh8 || "BT" === eh8 ? eh4.get(e.branch)?.pos : i;
	if (void 0 === a || void 0 === n) throw Error(`Position were undefined for commit ${e.id}`);
	return {
		x: a,
		y: n,
		posWithOffset: i
	};
}, "getCommitPosition"), euf = h((e, t, r) => {
	if (!eh2) throw Error("GitGraph config not found");
	let i = e.append("g").attr("class", "commit-bullets"), n = e.append("g").attr("class", "commit-labels"), a = 30 * ("TB" === eh8 || "BT" === eh8), s = [...t.keys()], o = eh2?.parallelCommits ?? !1, l = s.sort(h((e, r) => {
		let i = t.get(e)?.seq, n = t.get(r)?.seq;
		return void 0 !== i && void 0 !== n ? i - n : 0;
	}, "sortKeys"));
	"BT" === eh8 && (o && eui(l, t, a), l = l.reverse()), l.forEach((e) => {
		let s = t.get(e);
		if (!s) throw Error(`Commit not found for key ${e}`);
		o && (a = eud(s, eh8, a, eh5));
		let l = eup(s, a, o);
		if (r) {
			let e = euu(s), t = s.customType ?? s.type;
			eul(i, s, l, e, eh4.get(s.branch)?.index ?? 0, t), euc(n, s, l, a), euh(n, s, l, a);
		}
		"TB" === eh8 || "BT" === eh8 ? eh5.set(s.id, {
			x: l.x,
			y: l.posWithOffset
		}) : eh5.set(s.id, {
			x: l.posWithOffset,
			y: l.y
		}), (a = "BT" === eh8 && o ? a + 40 : a + 40 + 10) > eh7 && (eh7 = a);
	});
}, "drawCommits"), eug = h((e, t, r, i, n) => {
	let a = ("TB" === eh8 || "BT" === eh8 ? r.x < i.x : r.y < i.y) ? t.branch : e.branch, s = h((e) => e.branch === a, "isOnBranchToGetCurve"), o = h((r) => r.seq > e.seq && r.seq < t.seq, "isBetweenCommits");
	return [...n.values()].some((e) => o(e) && s(e));
}, "shouldRerouteArrow"), eum = h((e, t, r = 0) => {
	let i = e + Math.abs(e - t) / 2;
	return r > 5 ? i : eh6.every((e) => Math.abs(e - i) >= 10) ? (eh6.push(i), i) : eum(e, t - Math.abs(e - t) / 5, r + 1);
}, "findLane"), euy = h((e, t, r, i) => {
	let n, a = eh5.get(t.id), s = eh5.get(r.id);
	if (void 0 === a || void 0 === s) throw Error(`Commit positions not found for commits ${t.id} and ${r.id}`);
	let o = eug(t, r, a, s, i), l = "", h = "", u = 0, d = 0, p = eh4.get(r.branch)?.index;
	if (r.type === ehE.MERGE && t.id !== r.parents[0] && (p = eh4.get(t.branch)?.index), o) {
		l = "A 10 10, 0, 0, 0,", h = "A 10 10, 0, 0, 1,", u = 10, d = 10;
		let e = a.y < s.y ? eum(a.y, s.y) : eum(s.y, a.y), r = a.x < s.x ? eum(a.x, s.x) : eum(s.x, a.x);
		"TB" === eh8 ? a.x < s.x ? n = `M ${a.x} ${a.y} L ${r - u} ${a.y} ${h} ${r} ${a.y + d} L ${r} ${s.y - u} ${l} ${r + d} ${s.y} L ${s.x} ${s.y}` : (p = eh4.get(t.branch)?.index, n = `M ${a.x} ${a.y} L ${r + u} ${a.y} ${l} ${r} ${a.y + d} L ${r} ${s.y - u} ${h} ${r - d} ${s.y} L ${s.x} ${s.y}`) : "BT" === eh8 ? a.x < s.x ? n = `M ${a.x} ${a.y} L ${r - u} ${a.y} ${l} ${r} ${a.y - d} L ${r} ${s.y + u} ${h} ${r + d} ${s.y} L ${s.x} ${s.y}` : (p = eh4.get(t.branch)?.index, n = `M ${a.x} ${a.y} L ${r + u} ${a.y} ${h} ${r} ${a.y - d} L ${r} ${s.y + u} ${l} ${r - d} ${s.y} L ${s.x} ${s.y}`) : a.y < s.y ? n = `M ${a.x} ${a.y} L ${a.x} ${e - u} ${l} ${a.x + d} ${e} L ${s.x - u} ${e} ${h} ${s.x} ${e + d} L ${s.x} ${s.y}` : (p = eh4.get(t.branch)?.index, n = `M ${a.x} ${a.y} L ${a.x} ${e + u} ${h} ${a.x + d} ${e} L ${s.x - u} ${e} ${l} ${s.x} ${e - d} L ${s.x} ${s.y}`);
	} else l = "A 20 20, 0, 0, 0,", h = "A 20 20, 0, 0, 1,", u = 20, d = 20, "TB" === eh8 ? (a.x < s.x && (n = r.type === ehE.MERGE && t.id !== r.parents[0] ? `M ${a.x} ${a.y} L ${a.x} ${s.y - u} ${l} ${a.x + d} ${s.y} L ${s.x} ${s.y}` : `M ${a.x} ${a.y} L ${s.x - u} ${a.y} ${h} ${s.x} ${a.y + d} L ${s.x} ${s.y}`), a.x > s.x && (l = "A 20 20, 0, 0, 0,", h = "A 20 20, 0, 0, 1,", u = 20, d = 20, n = r.type === ehE.MERGE && t.id !== r.parents[0] ? `M ${a.x} ${a.y} L ${a.x} ${s.y - u} ${h} ${a.x - d} ${s.y} L ${s.x} ${s.y}` : `M ${a.x} ${a.y} L ${s.x + u} ${a.y} ${l} ${s.x} ${a.y + d} L ${s.x} ${s.y}`), a.x === s.x && (n = `M ${a.x} ${a.y} L ${s.x} ${s.y}`)) : "BT" === eh8 ? (a.x < s.x && (n = r.type === ehE.MERGE && t.id !== r.parents[0] ? `M ${a.x} ${a.y} L ${a.x} ${s.y + u} ${h} ${a.x + d} ${s.y} L ${s.x} ${s.y}` : `M ${a.x} ${a.y} L ${s.x - u} ${a.y} ${l} ${s.x} ${a.y - d} L ${s.x} ${s.y}`), a.x > s.x && (l = "A 20 20, 0, 0, 0,", h = "A 20 20, 0, 0, 1,", u = 20, d = 20, n = r.type === ehE.MERGE && t.id !== r.parents[0] ? `M ${a.x} ${a.y} L ${a.x} ${s.y + u} ${l} ${a.x - d} ${s.y} L ${s.x} ${s.y}` : `M ${a.x} ${a.y} L ${s.x - u} ${a.y} ${l} ${s.x} ${a.y - d} L ${s.x} ${s.y}`), a.x === s.x && (n = `M ${a.x} ${a.y} L ${s.x} ${s.y}`)) : (a.y < s.y && (n = r.type === ehE.MERGE && t.id !== r.parents[0] ? `M ${a.x} ${a.y} L ${s.x - u} ${a.y} ${h} ${s.x} ${a.y + d} L ${s.x} ${s.y}` : `M ${a.x} ${a.y} L ${a.x} ${s.y - u} ${l} ${a.x + d} ${s.y} L ${s.x} ${s.y}`), a.y > s.y && (n = r.type === ehE.MERGE && t.id !== r.parents[0] ? `M ${a.x} ${a.y} L ${s.x - u} ${a.y} ${l} ${s.x} ${a.y - d} L ${s.x} ${s.y}` : `M ${a.x} ${a.y} L ${a.x} ${s.y + u} ${h} ${a.x + d} ${s.y} L ${s.x} ${s.y}`), a.y === s.y && (n = `M ${a.x} ${a.y} L ${s.x} ${s.y}`));
	if (void 0 === n) throw Error("Line definition not found");
	e.append("path").attr("d", n).attr("class", "arrow arrow" + p % 8);
}, "drawArrow"), euv = h((e, t) => {
	let r = e.append("g").attr("class", "commit-arrows");
	[...t.keys()].forEach((e) => {
		let i = t.get(e);
		i.parents && i.parents.length > 0 && i.parents.forEach((e) => {
			euy(r, t.get(e), i, t);
		});
	});
}, "drawArrows"), eux = h((e, t) => {
	let r = e.append("g");
	t.forEach((e, t) => {
		let i = t % 8, n = eh4.get(e.name)?.pos;
		if (void 0 === n) throw Error(`Position not found for branch ${e.name}`);
		let a = r.append("line");
		a.attr("x1", 0), a.attr("y1", n), a.attr("x2", eh7), a.attr("y2", n), a.attr("class", "branch branch" + i), "TB" === eh8 ? (a.attr("y1", 30), a.attr("x1", n), a.attr("y2", eh7), a.attr("x2", n)) : "BT" === eh8 && (a.attr("y1", eh7), a.attr("x1", n), a.attr("y2", 30), a.attr("x2", n)), eh6.push(n);
		let s = eue(e.name), o = r.insert("rect"), l = r.insert("g").attr("class", "branchLabel").insert("g").attr("class", "label branch-label" + i);
		l.node().appendChild(s);
		let h = s.getBBox();
		o.attr("class", "branchLabelBkg label" + i).attr("rx", 4).attr("ry", 4).attr("x", -h.width - 4 - 30 * (eh2?.rotateCommitLabel === !0)).attr("y", -h.height / 2 + 8).attr("width", h.width + 18).attr("height", h.height + 4), l.attr("transform", "translate(" + (-h.width - 14 - 30 * (eh2?.rotateCommitLabel === !0)) + ", " + (n - h.height / 2 - 1) + ")"), "TB" === eh8 ? (o.attr("x", n - h.width / 2 - 10).attr("y", 0), l.attr("transform", "translate(" + (n - h.width / 2 - 5) + ", 0)")) : "BT" === eh8 ? (o.attr("x", n - h.width / 2 - 10).attr("y", eh7), l.attr("transform", "translate(" + (n - h.width / 2 - 5) + ", " + eh7 + ")")) : o.attr("transform", "translate(-19, " + (n - h.height / 2) + ")");
	});
}, "drawBranches"), eub = h(function(e, t, r, i, n) {
	return eh4.set(e, {
		pos: t,
		index: r
	}), t += 50 + 40 * !!n + ("TB" === eh8 || "BT" === eh8 ? i.width / 2 : 0);
}, "setBranchPosition"), euw = {
	parser: eh1,
	db: ehV,
	renderer: { draw: h(function(e, t, r, i) {
		if (eh9(), wQ.debug("in gitgraph renderer", e + `
`, "id:", t, r), !eh2) throw Error("GitGraph config not found");
		let n = eh2.rotateCommitLabel ?? !1, a = i.db;
		eh3 = a.getCommits();
		let s = a.getBranchesAsObjArray();
		eh8 = a.getDirection();
		let o = _t(`[id="${t}"]`), l = 0;
		s.forEach((e, t) => {
			let r = eue(e.name), i = o.append("g"), a = i.insert("g").attr("class", "branchLabel"), s = a.insert("g").attr("class", "label branch-label");
			s.node()?.appendChild(r);
			let h = r.getBBox();
			l = eub(e.name, l, t, h, n), s.remove(), a.remove(), i.remove();
		}), euf(o, eh3, !1), eh2.showBranches && eux(o, s), euv(o, eh3), euf(o, eh3, !0), V2(o, "gitTitleText", eh2.titleTopMargin ?? 0, a.getDiagramTitle()), M3(void 0, o, eh2.diagramPadding, eh2.useMaxWidth);
	}, "draw") },
	styles: h((e) => `
  .commit-id,
  .commit-msg,
  .branch-label {
    fill: lightgrey;
    color: lightgrey;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
  }
  ${[
		0,
		1,
		2,
		3,
		4,
		5,
		6,
		7
	].map((t) => `
        .branch-label${t} { fill: ${e["gitBranchLabel" + t]}; }
        .commit${t} { stroke: ${e["git" + t]}; fill: ${e["git" + t]}; }
        .commit-highlight${t} { stroke: ${e["gitInv" + t]}; fill: ${e["gitInv" + t]}; }
        .label${t}  { fill: ${e["git" + t]}; }
        .arrow${t} { stroke: ${e["git" + t]}; }
        `).join(`
`)}

  .branch {
    stroke-width: 1;
    stroke: ${e.lineColor};
    stroke-dasharray: 2;
  }
  .commit-label { font-size: ${e.commitLabelFontSize}; fill: ${e.commitLabelColor};}
  .commit-label-bkg { font-size: ${e.commitLabelFontSize}; fill: ${e.commitLabelBackground}; opacity: 0.5; }
  .tag-label { font-size: ${e.tagLabelFontSize}; fill: ${e.tagLabelColor};}
  .tag-label-bkg { fill: ${e.tagLabelBackground}; stroke: ${e.tagLabelBorder}; }
  .tag-hole { fill: ${e.textColor}; }

  .commit-merge {
    stroke: ${e.primaryColor};
    fill: ${e.primaryColor};
  }
  .commit-reverse {
    stroke: ${e.primaryColor};
    fill: ${e.primaryColor};
    stroke-width: 3;
  }
  .commit-highlight-outer {
  }
  .commit-highlight-inner {
    stroke: ${e.primaryColor};
    fill: ${e.primaryColor};
  }

  .arrow { stroke-width: 8; stroke-linecap: round; fill: none}
  .gitTitleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${e.textColor};
  }
`, "getStyles")
}, euk = "11.12.1", euT = { parse: h(async (e) => {
	let t = await wS("info", e);
	wQ.debug(t);
}, "parse") }, eu_ = { version: euk + "" }, euE = {
	parser: euT,
	db: { getVersion: h(() => eu_.version, "getVersion") },
	renderer: { draw: h((e, t, r) => {
		wQ.debug(`rendering info diagram
` + e);
		let i = Dy(t);
		M5(i, 100, 400, !0), i.append("g").append("text").attr("x", 100).attr("y", 40).attr("class", "version").attr("font-size", 32).style("text-anchor", "middle").text(`v${r}`);
	}, "draw") }
}, euC = function() {
	var e = h(function(e, t, r, i) {
		for (r = r || {}, i = e.length; i--; r[e[i]] = t);
		return r;
	}, "o"), t = [
		6,
		8,
		10,
		11,
		12,
		14,
		16,
		17,
		18
	], r = [1, 9], i = [1, 10], n = [1, 11], a = [1, 12], s = [1, 13], o = [1, 14], l = {
		trace: h(function() {}, "trace"),
		yy: {},
		symbols_: {
			error: 2,
			start: 3,
			journey: 4,
			document: 5,
			EOF: 6,
			line: 7,
			SPACE: 8,
			statement: 9,
			NEWLINE: 10,
			title: 11,
			acc_title: 12,
			acc_title_value: 13,
			acc_descr: 14,
			acc_descr_value: 15,
			acc_descr_multiline_value: 16,
			section: 17,
			taskName: 18,
			taskData: 19,
			$accept: 0,
			$end: 1
		},
		terminals_: {
			2: "error",
			4: "journey",
			6: "EOF",
			8: "SPACE",
			10: "NEWLINE",
			11: "title",
			12: "acc_title",
			13: "acc_title_value",
			14: "acc_descr",
			15: "acc_descr_value",
			16: "acc_descr_multiline_value",
			17: "section",
			18: "taskName",
			19: "taskData"
		},
		productions_: [
			0,
			[3, 3],
			[5, 0],
			[5, 2],
			[7, 2],
			[7, 1],
			[7, 1],
			[7, 1],
			[9, 1],
			[9, 2],
			[9, 2],
			[9, 1],
			[9, 1],
			[9, 2]
		],
		performAction: h(function(e, t, r, i, n, a, s) {
			var o = a.length - 1;
			switch (n) {
				case 1: return a[o - 1];
				case 2:
				case 6:
				case 7:
					this.$ = [];
					break;
				case 3:
					a[o - 1].push(a[o]), this.$ = a[o - 1];
					break;
				case 4:
				case 5:
					this.$ = a[o];
					break;
				case 8:
					i.setDiagramTitle(a[o].substr(6)), this.$ = a[o].substr(6);
					break;
				case 9:
					this.$ = a[o].trim(), i.setAccTitle(this.$);
					break;
				case 10:
				case 11:
					this.$ = a[o].trim(), i.setAccDescription(this.$);
					break;
				case 12:
					i.addSection(a[o].substr(8)), this.$ = a[o].substr(8);
					break;
				case 13: i.addTask(a[o - 1], a[o]), this.$ = "task";
			}
		}, "anonymous"),
		table: [
			{
				3: 1,
				4: [1, 2]
			},
			{ 1: [3] },
			e(t, [2, 2], { 5: 3 }),
			{
				6: [1, 4],
				7: 5,
				8: [1, 6],
				9: 7,
				10: [1, 8],
				11: r,
				12: i,
				14: n,
				16: a,
				17: s,
				18: o
			},
			e(t, [2, 7], { 1: [2, 1] }),
			e(t, [2, 3]),
			{
				9: 15,
				11: r,
				12: i,
				14: n,
				16: a,
				17: s,
				18: o
			},
			e(t, [2, 5]),
			e(t, [2, 6]),
			e(t, [2, 8]),
			{ 13: [1, 16] },
			{ 15: [1, 17] },
			e(t, [2, 11]),
			e(t, [2, 12]),
			{ 19: [1, 18] },
			e(t, [2, 4]),
			e(t, [2, 9]),
			e(t, [2, 10]),
			e(t, [2, 13])
		],
		defaultActions: {},
		parseError: h(function(e, t) {
			if (t.recoverable) this.trace(e);
			else {
				var r = Error(e);
				throw r.hash = t, r;
			}
		}, "parseError"),
		parse: h(function(e) {
			var t = this, r = [0], i = [], n = [null], a = [], s = this.table, o = "", l = 0, u = 0, d = 0, p = a.slice.call(arguments, 1), f = Object.create(this.lexer), g = {};
			for (var m in this.yy) Object.prototype.hasOwnProperty.call(this.yy, m) && (g[m] = this.yy[m]);
			f.setInput(e, g), g.lexer = f, g.parser = this, typeof f.yylloc > "u" && (f.yylloc = {});
			var y = f.yylloc;
			a.push(y);
			var v = f.options && f.options.ranges;
			function x() {
				var e;
				return "number" != typeof (e = i.pop() || f.lex() || 1) && (e instanceof Array && (e = (i = e).pop()), e = t.symbols_[e] || e), e;
			}
			"function" == typeof g.parseError ? this.parseError = g.parseError : this.parseError = Object.getPrototypeOf(this).parseError, h(function(e) {
				r.length = r.length - 2 * e, n.length = n.length - e, a.length = a.length - e;
			}, "popStack"), h(x, "lex");
			for (var b, w, k, T, _, E, C, S, A, L = {};;) {
				if (k = r[r.length - 1], this.defaultActions[k] ? T = this.defaultActions[k] : ((null === b || typeof b > "u") && (b = x()), T = s[k] && s[k][b]), typeof T > "u" || !T.length || !T[0]) {
					var R = "";
					for (E in A = [], s[k]) this.terminals_[E] && E > 2 && A.push("'" + this.terminals_[E] + "'");
					R = f.showPosition ? "Parse error on line " + (l + 1) + `:
` + f.showPosition() + `
Expecting ` + A.join(", ") + ", got '" + (this.terminals_[b] || b) + "'" : "Parse error on line " + (l + 1) + ": Unexpected " + (1 == b ? "end of input" : "'" + (this.terminals_[b] || b) + "'"), this.parseError(R, {
						text: f.match,
						token: this.terminals_[b] || b,
						line: f.yylineno,
						loc: y,
						expected: A
					});
				}
				if (T[0] instanceof Array && T.length > 1) throw Error("Parse Error: multiple actions possible at state: " + k + ", token: " + b);
				switch (T[0]) {
					case 1:
						r.push(b), n.push(f.yytext), a.push(f.yylloc), r.push(T[1]), b = null, w ? (b = w, w = null) : (u = f.yyleng, o = f.yytext, l = f.yylineno, y = f.yylloc, d > 0 && d--);
						break;
					case 2:
						if (C = this.productions_[T[1]][1], L.$ = n[n.length - C], L._$ = {
							first_line: a[a.length - (C || 1)].first_line,
							last_line: a[a.length - 1].last_line,
							first_column: a[a.length - (C || 1)].first_column,
							last_column: a[a.length - 1].last_column
						}, v && (L._$.range = [a[a.length - (C || 1)].range[0], a[a.length - 1].range[1]]), "u" > typeof (_ = this.performAction.apply(L, [
							o,
							u,
							l,
							g,
							T[1],
							n,
							a
						].concat(p)))) return _;
						C && (r = r.slice(0, -1 * C * 2), n = n.slice(0, -1 * C), a = a.slice(0, -1 * C)), r.push(this.productions_[T[1]][0]), n.push(L.$), a.push(L._$), S = s[r[r.length - 2]][r[r.length - 1]], r.push(S);
						break;
					case 3: return !0;
				}
			}
			return !0;
		}, "parse")
	};
	function u() {
		this.yy = {};
	}
	return l.lexer = {
		EOF: 1,
		parseError: h(function(e, t) {
			if (this.yy.parser) this.yy.parser.parseError(e, t);
			else throw Error(e);
		}, "parseError"),
		setInput: h(function(e, t) {
			return this.yy = t || this.yy || {}, this._input = e, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
				first_line: 1,
				first_column: 0,
				last_line: 1,
				last_column: 0
			}, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
		}, "setInput"),
		input: h(function() {
			var e = this._input[0];
			return this.yytext += e, this.yyleng++, this.offset++, this.match += e, this.matched += e, e.match(/(?:\r\n?|\n).*/g) ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), e;
		}, "input"),
		unput: h(function(e) {
			var t = e.length, r = e.split(/(?:\r\n?|\n)/g);
			this._input = e + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - t), this.offset -= t;
			var i = this.match.split(/(?:\r\n?|\n)/g);
			this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), r.length - 1 && (this.yylineno -= r.length - 1);
			var n = this.yylloc.range;
			return this.yylloc = {
				first_line: this.yylloc.first_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.first_column,
				last_column: r ? (r.length === i.length ? this.yylloc.first_column : 0) + i[i.length - r.length].length - r[0].length : this.yylloc.first_column - t
			}, this.options.ranges && (this.yylloc.range = [n[0], n[0] + this.yyleng - t]), this.yyleng = this.yytext.length, this;
		}, "unput"),
		more: h(function() {
			return this._more = !0, this;
		}, "more"),
		reject: h(function() {
			return this.options.backtrack_lexer ? (this._backtrack = !0, this) : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "reject"),
		less: h(function(e) {
			this.unput(this.match.slice(e));
		}, "less"),
		pastInput: h(function() {
			var e = this.matched.substr(0, this.matched.length - this.match.length);
			return (e.length > 20 ? "..." : "") + e.substr(-20).replace(/\n/g, "");
		}, "pastInput"),
		upcomingInput: h(function() {
			var e = this.match;
			return e.length < 20 && (e += this._input.substr(0, 20 - e.length)), (e.substr(0, 20) + (e.length > 20 ? "..." : "")).replace(/\n/g, "");
		}, "upcomingInput"),
		showPosition: h(function() {
			var e = this.pastInput(), t = Array(e.length + 1).join("-");
			return e + this.upcomingInput() + `
` + t + "^";
		}, "showPosition"),
		test_match: h(function(e, t) {
			var r, i, n;
			if (this.options.backtrack_lexer && (n = {
				yylineno: this.yylineno,
				yylloc: {
					first_line: this.yylloc.first_line,
					last_line: this.last_line,
					first_column: this.yylloc.first_column,
					last_column: this.yylloc.last_column
				},
				yytext: this.yytext,
				match: this.match,
				matches: this.matches,
				matched: this.matched,
				yyleng: this.yyleng,
				offset: this.offset,
				_more: this._more,
				_input: this._input,
				yy: this.yy,
				conditionStack: this.conditionStack.slice(0),
				done: this.done
			}, this.options.ranges && (n.yylloc.range = this.yylloc.range.slice(0))), (i = e[0].match(/(?:\r\n?|\n).*/g)) && (this.yylineno += i.length), this.yylloc = {
				first_line: this.yylloc.last_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.last_column,
				last_column: i ? i[i.length - 1].length - i[i.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + e[0].length
			}, this.yytext += e[0], this.match += e[0], this.matches = e, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(e[0].length), this.matched += e[0], r = this.performAction.call(this, this.yy, this, t, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), r) return r;
			if (this._backtrack) for (var a in n) this[a] = n[a];
			return !1;
		}, "test_match"),
		next: h(function() {
			if (this.done) return this.EOF;
			this._input || (this.done = !0), this._more || (this.yytext = "", this.match = "");
			for (var e, t, r, i, n = this._currentRules(), a = 0; a < n.length; a++) if ((r = this._input.match(this.rules[n[a]])) && (!t || r[0].length > t[0].length)) {
				if (t = r, i = a, this.options.backtrack_lexer) {
					if (!1 !== (e = this.test_match(r, n[a]))) return e;
					if (!this._backtrack) return !1;
					t = !1;
					continue;
				} else if (!this.options.flex) break;
			}
			return t ? !1 !== (e = this.test_match(t, n[i])) && e : "" === this._input ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "next"),
		lex: h(function() {
			return this.next() || this.lex();
		}, "lex"),
		begin: h(function(e) {
			this.conditionStack.push(e);
		}, "begin"),
		popState: h(function() {
			return this.conditionStack.length - 1 > 0 ? this.conditionStack.pop() : this.conditionStack[0];
		}, "popState"),
		_currentRules: h(function() {
			return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
		}, "_currentRules"),
		topState: h(function(e) {
			return (e = this.conditionStack.length - 1 - Math.abs(e || 0)) >= 0 ? this.conditionStack[e] : "INITIAL";
		}, "topState"),
		pushState: h(function(e) {
			this.begin(e);
		}, "pushState"),
		stateStackSize: h(function() {
			return this.conditionStack.length;
		}, "stateStackSize"),
		options: { "case-insensitive": !0 },
		performAction: h(function(e, t, r, i) {
			switch (r) {
				case 0:
				case 1:
				case 3:
				case 4: break;
				case 2: return 10;
				case 5: return 4;
				case 6: return 11;
				case 7: return this.begin("acc_title"), 12;
				case 8: return this.popState(), "acc_title_value";
				case 9: return this.begin("acc_descr"), 14;
				case 10: return this.popState(), "acc_descr_value";
				case 11:
					this.begin("acc_descr_multiline");
					break;
				case 12:
					this.popState();
					break;
				case 13: return "acc_descr_multiline_value";
				case 14: return 17;
				case 15: return 18;
				case 16: return 19;
				case 17: return ":";
				case 18: return 6;
				case 19: return "INVALID";
			}
		}, "anonymous"),
		rules: [
			/^(?:%(?!\{)[^\n]*)/i,
			/^(?:[^\}]%%[^\n]*)/i,
			/^(?:[\n]+)/i,
			/^(?:\s+)/i,
			/^(?:#[^\n]*)/i,
			/^(?:journey\b)/i,
			/^(?:title\s[^#\n;]+)/i,
			/^(?:accTitle\s*:\s*)/i,
			/^(?:(?!\n||)*[^\n]*)/i,
			/^(?:accDescr\s*:\s*)/i,
			/^(?:(?!\n||)*[^\n]*)/i,
			/^(?:accDescr\s*\{\s*)/i,
			/^(?:[\}])/i,
			/^(?:[^\}]*)/i,
			/^(?:section\s[^#:\n;]+)/i,
			/^(?:[^#:\n;]+)/i,
			/^(?::[^#\n;]+)/i,
			/^(?::)/i,
			/^(?:$)/i,
			/^(?:.)/i
		],
		conditions: {
			acc_descr_multiline: {
				rules: [12, 13],
				inclusive: !1
			},
			acc_descr: {
				rules: [10],
				inclusive: !1
			},
			acc_title: {
				rules: [8],
				inclusive: !1
			},
			INITIAL: {
				rules: [
					0,
					1,
					2,
					3,
					4,
					5,
					6,
					7,
					9,
					11,
					14,
					15,
					16,
					17,
					18,
					19
				],
				inclusive: !0
			}
		}
	}, h(u, "Parser"), u.prototype = l, l.Parser = u, new u();
}();
euC.parser = euC;
var euS = "", euA = [], euL = [], euR = [], euN = h(function() {
	euA.length = 0, euL.length = 0, euS = "", euR.length = 0, Dn();
}, "clear"), euI = h(function(e) {
	euS = e, euA.push(e);
}, "addSection"), euM = h(function() {
	return euA;
}, "getSections"), euD = h(function() {
	let e = euB(), t = 0;
	for (; !e && t < 100;) e = euB(), t++;
	return euL.push(...euR), euL;
}, "getTasks"), euO = h(function() {
	let e = [];
	return euL.forEach((t) => {
		t.people && e.push(...t.people);
	}), [...new Set(e)].sort();
}, "updateActors"), eu$ = h(function(e, t) {
	let r = t.substr(1).split(":"), i = 0, n = [];
	1 === r.length ? (i = Number(r[0]), n = []) : (i = Number(r[0]), n = r[1].split(","));
	let a = n.map((e) => e.trim()), s = {
		section: euS,
		type: euS,
		people: a,
		task: e,
		score: i
	};
	euR.push(s);
}, "addTask"), euP = h(function(e) {
	let t = {
		section: euS,
		type: euS,
		description: e,
		task: e,
		classes: []
	};
	euL.push(t);
}, "addTaskOrg"), euB = h(function() {
	let e = h(function(e) {
		return euR[e].processed;
	}, "compileTask"), t = !0;
	for (let [r, i] of euR.entries()) e(r), t = t && i.processed;
	return t;
}, "compileTasks"), euF = h(function() {
	return euO();
}, "getActors"), euz = {
	getConfig: h(() => IA().journey, "getConfig"),
	clear: euN,
	setDiagramTitle: Dc,
	getDiagramTitle: Dh,
	setAccTitle: Da,
	getAccTitle: Ds,
	setAccDescription: Do,
	getAccDescription: Dl,
	addSection: euI,
	getSections: euM,
	getTasks: euD,
	addTask: eu$,
	addTaskOrg: euP,
	getActors: euF
}, euU = h((e) => `.label {
    font-family: ${e.fontFamily};
    color: ${e.textColor};
  }
  .mouth {
    stroke: #666;
  }

  line {
    stroke: ${e.textColor}
  }

  .legend {
    fill: ${e.textColor};
    font-family: ${e.fontFamily};
  }

  .label text {
    fill: #333;
  }
  .label {
    color: ${e.textColor}
  }

  .face {
    ${e.faceColor ? `fill: ${e.faceColor}` : "fill: #FFF8DC"};
    stroke: #999;
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${e.mainBkg};
    stroke: ${e.nodeBorder};
    stroke-width: 1px;
  }

  .node .label {
    text-align: center;
  }
  .node.clickable {
    cursor: pointer;
  }

  .arrowheadPath {
    fill: ${e.arrowheadColor};
  }

  .edgePath .path {
    stroke: ${e.lineColor};
    stroke-width: 1.5px;
  }

  .flowchart-link {
    stroke: ${e.lineColor};
    fill: none;
  }

  .edgeLabel {
    background-color: ${e.edgeLabelBackground};
    rect {
      opacity: 0.5;
    }
    text-align: center;
  }

  .cluster rect {
  }

  .cluster text {
    fill: ${e.titleColor};
  }

  div.mermaidTooltip {
    position: absolute;
    text-align: center;
    max-width: 200px;
    padding: 2px;
    font-family: ${e.fontFamily};
    font-size: 12px;
    background: ${e.tertiaryColor};
    border: 1px solid ${e.border2};
    border-radius: 2px;
    pointer-events: none;
    z-index: 100;
  }

  .task-type-0, .section-type-0  {
    ${e.fillType0 ? `fill: ${e.fillType0}` : ""};
  }
  .task-type-1, .section-type-1  {
    ${e.fillType0 ? `fill: ${e.fillType1}` : ""};
  }
  .task-type-2, .section-type-2  {
    ${e.fillType0 ? `fill: ${e.fillType2}` : ""};
  }
  .task-type-3, .section-type-3  {
    ${e.fillType0 ? `fill: ${e.fillType3}` : ""};
  }
  .task-type-4, .section-type-4  {
    ${e.fillType0 ? `fill: ${e.fillType4}` : ""};
  }
  .task-type-5, .section-type-5  {
    ${e.fillType0 ? `fill: ${e.fillType5}` : ""};
  }
  .task-type-6, .section-type-6  {
    ${e.fillType0 ? `fill: ${e.fillType6}` : ""};
  }
  .task-type-7, .section-type-7  {
    ${e.fillType0 ? `fill: ${e.fillType7}` : ""};
  }

  .actor-0 {
    ${e.actor0 ? `fill: ${e.actor0}` : ""};
  }
  .actor-1 {
    ${e.actor1 ? `fill: ${e.actor1}` : ""};
  }
  .actor-2 {
    ${e.actor2 ? `fill: ${e.actor2}` : ""};
  }
  .actor-3 {
    ${e.actor3 ? `fill: ${e.actor3}` : ""};
  }
  .actor-4 {
    ${e.actor4 ? `fill: ${e.actor4}` : ""};
  }
  .actor-5 {
    ${e.actor5 ? `fill: ${e.actor5}` : ""};
  }
  ${Kz()}
`, "getStyles"), euG = h(function(e, t) {
	return QS(e, t);
}, "drawRect"), euq = h(function(e, t) {
	let r = e.append("circle").attr("cx", t.cx).attr("cy", t.cy).attr("class", "face").attr("r", 15).attr("stroke-width", 2).attr("overflow", "visible"), i = e.append("g");
	function n(e) {
		let r = AQ().startAngle(Math.PI / 2).endAngle(Math.PI / 2 * 3).innerRadius(7.5).outerRadius(6.8181818181818175);
		e.append("path").attr("class", "mouth").attr("d", r).attr("transform", "translate(" + t.cx + "," + (t.cy + 2) + ")");
	}
	function a(e) {
		let r = AQ().startAngle(3 * Math.PI / 2).endAngle(Math.PI / 2 * 5).innerRadius(7.5).outerRadius(6.8181818181818175);
		e.append("path").attr("class", "mouth").attr("d", r).attr("transform", "translate(" + t.cx + "," + (t.cy + 7) + ")");
	}
	function s(e) {
		e.append("line").attr("class", "mouth").attr("stroke", 2).attr("x1", t.cx - 5).attr("y1", t.cy + 7).attr("x2", t.cx + 5).attr("y2", t.cy + 7).attr("class", "mouth").attr("stroke-width", "1px").attr("stroke", "#666");
	}
	return i.append("circle").attr("cx", t.cx - 5).attr("cy", t.cy - 5).attr("r", 1.5).attr("stroke-width", 2).attr("fill", "#666").attr("stroke", "#666"), i.append("circle").attr("cx", t.cx + 5).attr("cy", t.cy - 5).attr("r", 1.5).attr("stroke-width", 2).attr("fill", "#666").attr("stroke", "#666"), h(n, "smile"), h(a, "sad"), h(s, "ambivalent"), t.score > 3 ? n(i) : t.score < 3 ? a(i) : s(i), r;
}, "drawFace"), euj = h(function(e, t) {
	let r = e.append("circle");
	return r.attr("cx", t.cx), r.attr("cy", t.cy), r.attr("class", "actor-" + t.pos), r.attr("fill", t.fill), r.attr("stroke", t.stroke), r.attr("r", t.r), void 0 !== r.class && r.attr("class", r.class), void 0 !== t.title && r.append("title").text(t.title), r;
}, "drawCircle"), euW = h(function(e, t) {
	return QL(e, t);
}, "drawText"), euY = h(function(e, t) {
	function r(e, t, r, i, n) {
		return e + "," + t + " " + (e + r) + "," + t + " " + (e + r) + "," + (t + i - n) + " " + (e + r - 1.2 * n) + "," + (t + i) + " " + e + "," + (t + i);
	}
	h(r, "genPoints");
	let i = e.append("polygon");
	i.attr("points", r(t.x, t.y, 50, 20, 7)), i.attr("class", "labelBox"), t.y = t.y + t.labelMargin, t.x = t.x + .5 * t.labelMargin, euW(e, t);
}, "drawLabel"), euV = h(function(e, t, r) {
	let i = e.append("g"), n = QI();
	n.x = t.x, n.y = t.y, n.fill = t.fill, n.width = r.width * t.taskCount + r.diagramMarginX * (t.taskCount - 1), n.height = r.height, n.class = "journey-section section-type-" + t.num, n.rx = 3, n.ry = 3, euG(i, n), euZ(r)(t.text, i, n.x, n.y, n.width, n.height, { class: "journey-section section-type-" + t.num }, r, t.colour);
}, "drawSection"), euH = -1, euX = h(function(e, t, r) {
	let i = t.x + r.width / 2, n = e.append("g");
	euH++, n.append("line").attr("id", "task" + euH).attr("x1", i).attr("y1", t.y).attr("x2", i).attr("y2", 450).attr("class", "task-line").attr("stroke-width", "1px").attr("stroke-dasharray", "4 2").attr("stroke", "#666"), euq(n, {
		cx: i,
		cy: 300 + (5 - t.score) * 30,
		score: t.score
	});
	let a = QI();
	a.x = t.x, a.y = t.y, a.fill = t.fill, a.width = r.width, a.height = r.height, a.class = "task task-type-" + t.num, a.rx = 3, a.ry = 3, euG(n, a);
	let s = t.x + 14;
	t.people.forEach((e) => {
		let r = t.actors[e].color;
		euj(n, {
			cx: s,
			cy: t.y,
			r: 7,
			fill: r,
			stroke: "#000",
			title: e,
			pos: t.actors[e].position
		}), s += 10;
	}), euZ(r)(t.task, n, a.x, a.y, a.width, a.height, { class: "task" }, r, t.colour);
}, "drawTask"), euK = h(function(e, t) {
	QA(e, t);
}, "drawBackgroundRect"), euZ = function() {
	function e(e, t, r, n, a, s, o, l) {
		i(t.append("text").attr("x", r + a / 2).attr("y", n + s / 2 + 5).style("font-color", l).style("text-anchor", "middle").text(e), o);
	}
	function t(e, t, r, n, a, s, o, l, h) {
		let { taskFontSize: u, taskFontFamily: d } = l, p = e.split(/<br\s*\/?>/gi);
		for (let e = 0; e < p.length; e++) {
			let l = e * u - u * (p.length - 1) / 2, f = t.append("text").attr("x", r + a / 2).attr("y", n).attr("fill", h).style("text-anchor", "middle").style("font-size", u).style("font-family", d);
			f.append("tspan").attr("x", r + a / 2).attr("dy", l).text(p[e]), f.attr("y", n + s / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central"), i(f, o);
		}
	}
	function r(e, r, n, a, s, o, l, h) {
		let u = r.append("switch"), d = u.append("foreignObject").attr("x", n).attr("y", a).attr("width", s).attr("height", o).attr("position", "fixed").append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
		d.append("div").attr("class", "label").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(e), t(e, u, n, a, s, o, l, h), i(d, l);
	}
	function i(e, t) {
		for (let r in t) r in t && e.attr(r, t[r]);
	}
	return h(e, "byText"), h(t, "byTspan"), h(r, "byFo"), h(i, "_setTextAttrs"), function(i) {
		return "fo" === i.textPlacement ? r : "old" === i.textPlacement ? e : t;
	};
}(), euQ = {
	drawRect: euG,
	drawCircle: euj,
	drawSection: euV,
	drawText: euW,
	drawLabel: euY,
	drawTask: euX,
	drawBackgroundRect: euK,
	initGraphics: h(function(e) {
		e.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 5).attr("refY", 2).attr("markerWidth", 6).attr("markerHeight", 4).attr("orient", "auto").append("path").attr("d", "M 0,0 V 4 L6,2 Z");
	}, "initGraphics")
}, euJ = h(function(e) {
	Object.keys(e).forEach(function(t) {
		eu4[t] = e[t];
	});
}, "setConf"), eu0 = {}, eu1 = 0;
function eu2(e) {
	let t = IA().journey, r = t.maxLabelWidth;
	eu1 = 0;
	let i = 60;
	Object.keys(eu0).forEach((n) => {
		let a = eu0[n].color, s = {
			cx: 20,
			cy: i,
			r: 7,
			fill: a,
			stroke: "#000",
			pos: eu0[n].position
		};
		euQ.drawCircle(e, s);
		let o = e.append("text").attr("visibility", "hidden").text(n), l = o.node().getBoundingClientRect().width;
		o.remove();
		let h = [];
		if (l <= r) h = [n];
		else {
			let t = n.split(" "), i = "";
			o = e.append("text").attr("visibility", "hidden"), t.forEach((e) => {
				let t = i ? `${i} ${e}` : e;
				if (o.text(t), o.node().getBoundingClientRect().width > r) {
					if (i && h.push(i), i = e, o.text(e), o.node().getBoundingClientRect().width > r) {
						let t = "";
						for (let i of e) t += i, o.text(t + "-"), o.node().getBoundingClientRect().width > r && (h.push(t.slice(0, -1) + "-"), t = i);
						i = t;
					}
				} else i = t;
			}), i && h.push(i), o.remove();
		}
		h.forEach((r, n) => {
			let a = {
				x: 40,
				y: i + 7 + 20 * n,
				fill: "#666",
				text: r,
				textMargin: t.boxTextMargin ?? 5
			}, s = euQ.drawText(e, a).node().getBoundingClientRect().width;
			s > eu1 && s > t.leftMargin - s && (eu1 = s);
		}), i += Math.max(20, 20 * h.length);
	});
}
h(eu2, "drawActorLegend");
var eu4 = IA().journey, eu5 = 0, eu3 = h(function(e, t, r, i) {
	let n = IA(), a = n.journey.titleColor, s = n.journey.titleFontSize, o = n.journey.titleFontFamily, l = n.securityLevel, h;
	"sandbox" === l && (h = _t("#i" + t));
	let u = "sandbox" === l ? _t(h.nodes()[0].contentDocument.body) : _t("body");
	eu6.init();
	let d = u.select("#" + t);
	euQ.initGraphics(d);
	let p = i.db.getTasks(), f = i.db.getDiagramTitle(), g = i.db.getActors();
	for (let e in eu0) delete eu0[e];
	let m = 0;
	g.forEach((e) => {
		eu0[e] = {
			color: eu4.actorColours[m % eu4.actorColours.length],
			position: m
		}, m++;
	}), eu2(d), eu5 = eu4.leftMargin + eu1, eu6.insert(0, 0, eu5, 50 * Object.keys(eu0).length), eu9(d, p, 0);
	let y = eu6.getBounds();
	f && d.append("text").text(f).attr("x", eu5).attr("font-size", s).attr("font-weight", "bold").attr("y", 25).attr("fill", a).attr("font-family", o);
	let v = y.stopy - y.starty + 2 * eu4.diagramMarginY, x = eu5 + y.stopx + 2 * eu4.diagramMarginX;
	M5(d, v, x, eu4.useMaxWidth), d.append("line").attr("x1", eu5).attr("y1", 4 * eu4.height).attr("x2", x - eu5 - 4).attr("y2", 4 * eu4.height).attr("stroke-width", 4).attr("stroke", "black").attr("marker-end", "url(#arrowhead)");
	let b = 70 * !!f;
	d.attr("viewBox", `${y.startx} -25 ${x} ${v + b}`), d.attr("preserveAspectRatio", "xMinYMin meet"), d.attr("height", v + b + 25);
}, "draw"), eu6 = {
	data: {
		startx: void 0,
		stopx: void 0,
		starty: void 0,
		stopy: void 0
	},
	verticalPos: 0,
	sequenceItems: [],
	init: h(function() {
		this.sequenceItems = [], this.data = {
			startx: void 0,
			stopx: void 0,
			starty: void 0,
			stopy: void 0
		}, this.verticalPos = 0;
	}, "init"),
	updateVal: h(function(e, t, r, i) {
		void 0 === e[t] ? e[t] = r : e[t] = i(r, e[t]);
	}, "updateVal"),
	updateBounds: h(function(e, t, r, i) {
		let n = IA().journey, a = this, s = 0;
		function o(o) {
			return h(function(l) {
				s++;
				let h = a.sequenceItems.length - s + 1;
				a.updateVal(l, "starty", t - h * n.boxMargin, Math.min), a.updateVal(l, "stopy", i + h * n.boxMargin, Math.max), a.updateVal(eu6.data, "startx", e - h * n.boxMargin, Math.min), a.updateVal(eu6.data, "stopx", r + h * n.boxMargin, Math.max), "activation" !== o && (a.updateVal(l, "startx", e - h * n.boxMargin, Math.min), a.updateVal(l, "stopx", r + h * n.boxMargin, Math.max), a.updateVal(eu6.data, "starty", t - h * n.boxMargin, Math.min), a.updateVal(eu6.data, "stopy", i + h * n.boxMargin, Math.max));
			}, "updateItemBounds");
		}
		h(o, "updateFn"), this.sequenceItems.forEach(o());
	}, "updateBounds"),
	insert: h(function(e, t, r, i) {
		let n = Math.min(e, r), a = Math.max(e, r), s = Math.min(t, i), o = Math.max(t, i);
		this.updateVal(eu6.data, "startx", n, Math.min), this.updateVal(eu6.data, "starty", s, Math.min), this.updateVal(eu6.data, "stopx", a, Math.max), this.updateVal(eu6.data, "stopy", o, Math.max), this.updateBounds(n, s, a, o);
	}, "insert"),
	bumpVerticalPos: h(function(e) {
		this.verticalPos = this.verticalPos + e, this.data.stopy = this.verticalPos;
	}, "bumpVerticalPos"),
	getVerticalPos: h(function() {
		return this.verticalPos;
	}, "getVerticalPos"),
	getBounds: h(function() {
		return this.data;
	}, "getBounds")
}, eu7 = eu4.sectionFills, eu8 = eu4.sectionColours, eu9 = h(function(e, t, r) {
	let i = IA().journey, n = "", a = r + (2 * i.height + i.diagramMarginY), s = 0, o = "#CCC", l = "black", h = 0;
	for (let [r, u] of t.entries()) {
		if (n !== u.section) {
			o = eu7[s % eu7.length], h = s % eu7.length, l = eu8[s % eu8.length];
			let a = 0, d = u.section;
			for (let e = r; e < t.length && t[e].section == d; e++) a += 1;
			let p = {
				x: r * i.taskMargin + r * i.width + eu5,
				y: 50,
				text: u.section,
				fill: o,
				num: h,
				colour: l,
				taskCount: a
			};
			euQ.drawSection(e, p, i), n = u.section, s++;
		}
		let d = u.people.reduce((e, t) => (eu0[t] && (e[t] = eu0[t]), e), {});
		u.x = r * i.taskMargin + r * i.width + eu5, u.y = a, u.width = i.diagramMarginX, u.height = i.diagramMarginY, u.colour = l, u.fill = o, u.num = h, u.actors = d, euQ.drawTask(e, u, i), eu6.insert(u.x, u.y, u.x + u.width + i.taskMargin, 450);
	}
}, "drawTasks"), ede = {
	setConf: euJ,
	draw: eu3
}, edt = {
	parser: euC,
	db: euz,
	renderer: ede,
	styles: euU,
	init: h((e) => {
		ede.setConf(e.journey), euz.clear();
	}, "init")
}, edr = function() {
	var e = h(function(e, t, r, i) {
		for (r = r || {}, i = e.length; i--; r[e[i]] = t);
		return r;
	}, "o"), t = [1, 4], r = [1, 13], i = [1, 12], n = [1, 15], a = [1, 16], s = [1, 20], o = [1, 19], l = [
		6,
		7,
		8
	], u = [1, 26], d = [1, 24], p = [1, 25], f = [
		6,
		7,
		11
	], g = [1, 31], m = [
		6,
		7,
		11,
		24
	], y = [
		1,
		6,
		13,
		16,
		17,
		20,
		23
	], v = [1, 35], x = [1, 36], b = [
		1,
		6,
		7,
		11,
		13,
		16,
		17,
		20,
		23
	], w = [1, 38], k = {
		trace: h(function() {}, "trace"),
		yy: {},
		symbols_: {
			error: 2,
			start: 3,
			mindMap: 4,
			spaceLines: 5,
			SPACELINE: 6,
			NL: 7,
			KANBAN: 8,
			document: 9,
			stop: 10,
			EOF: 11,
			statement: 12,
			SPACELIST: 13,
			node: 14,
			shapeData: 15,
			ICON: 16,
			CLASS: 17,
			nodeWithId: 18,
			nodeWithoutId: 19,
			NODE_DSTART: 20,
			NODE_DESCR: 21,
			NODE_DEND: 22,
			NODE_ID: 23,
			SHAPE_DATA: 24,
			$accept: 0,
			$end: 1
		},
		terminals_: {
			2: "error",
			6: "SPACELINE",
			7: "NL",
			8: "KANBAN",
			11: "EOF",
			13: "SPACELIST",
			16: "ICON",
			17: "CLASS",
			20: "NODE_DSTART",
			21: "NODE_DESCR",
			22: "NODE_DEND",
			23: "NODE_ID",
			24: "SHAPE_DATA"
		},
		productions_: [
			0,
			[3, 1],
			[3, 2],
			[5, 1],
			[5, 2],
			[5, 2],
			[4, 2],
			[4, 3],
			[10, 1],
			[10, 1],
			[10, 1],
			[10, 2],
			[10, 2],
			[9, 3],
			[9, 2],
			[12, 3],
			[12, 2],
			[12, 2],
			[12, 2],
			[12, 1],
			[12, 2],
			[12, 1],
			[12, 1],
			[12, 1],
			[12, 1],
			[14, 1],
			[14, 1],
			[19, 3],
			[18, 1],
			[18, 4],
			[15, 2],
			[15, 1]
		],
		performAction: h(function(e, t, r, i, n, a, s) {
			var o = a.length - 1;
			switch (n) {
				case 6:
				case 7: return i;
				case 8:
					i.getLogger().trace("Stop NL ");
					break;
				case 9:
					i.getLogger().trace("Stop EOF ");
					break;
				case 11:
					i.getLogger().trace("Stop NL2 ");
					break;
				case 12:
					i.getLogger().trace("Stop EOF2 ");
					break;
				case 15:
					i.getLogger().info("Node: ", a[o - 1].id), i.addNode(a[o - 2].length, a[o - 1].id, a[o - 1].descr, a[o - 1].type, a[o]);
					break;
				case 16:
					i.getLogger().info("Node: ", a[o].id), i.addNode(a[o - 1].length, a[o].id, a[o].descr, a[o].type);
					break;
				case 17:
					i.getLogger().trace("Icon: ", a[o]), i.decorateNode({ icon: a[o] });
					break;
				case 18:
				case 23:
					i.decorateNode({ class: a[o] });
					break;
				case 19:
					i.getLogger().trace("SPACELIST");
					break;
				case 20:
					i.getLogger().trace("Node: ", a[o - 1].id), i.addNode(0, a[o - 1].id, a[o - 1].descr, a[o - 1].type, a[o]);
					break;
				case 21:
					i.getLogger().trace("Node: ", a[o].id), i.addNode(0, a[o].id, a[o].descr, a[o].type);
					break;
				case 22:
					i.decorateNode({ icon: a[o] });
					break;
				case 27:
					i.getLogger().trace("node found ..", a[o - 2]), this.$ = {
						id: a[o - 1],
						descr: a[o - 1],
						type: i.getType(a[o - 2], a[o])
					};
					break;
				case 28:
					this.$ = {
						id: a[o],
						descr: a[o],
						type: 0
					};
					break;
				case 29:
					i.getLogger().trace("node found ..", a[o - 3]), this.$ = {
						id: a[o - 3],
						descr: a[o - 1],
						type: i.getType(a[o - 2], a[o])
					};
					break;
				case 30:
					this.$ = a[o - 1] + a[o];
					break;
				case 31: this.$ = a[o];
			}
		}, "anonymous"),
		table: [
			{
				3: 1,
				4: 2,
				5: 3,
				6: [1, 5],
				8: t
			},
			{ 1: [3] },
			{ 1: [2, 1] },
			{
				4: 6,
				6: [1, 7],
				7: [1, 8],
				8: t
			},
			{
				6: r,
				7: [1, 10],
				9: 9,
				12: 11,
				13: i,
				14: 14,
				16: n,
				17: a,
				18: 17,
				19: 18,
				20: s,
				23: o
			},
			e(l, [2, 3]),
			{ 1: [2, 2] },
			e(l, [2, 4]),
			e(l, [2, 5]),
			{
				1: [2, 6],
				6: r,
				12: 21,
				13: i,
				14: 14,
				16: n,
				17: a,
				18: 17,
				19: 18,
				20: s,
				23: o
			},
			{
				6: r,
				9: 22,
				12: 11,
				13: i,
				14: 14,
				16: n,
				17: a,
				18: 17,
				19: 18,
				20: s,
				23: o
			},
			{
				6: u,
				7: d,
				10: 23,
				11: p
			},
			e(f, [2, 24], {
				18: 17,
				19: 18,
				14: 27,
				16: [1, 28],
				17: [1, 29],
				20: s,
				23: o
			}),
			e(f, [2, 19]),
			e(f, [2, 21], {
				15: 30,
				24: g
			}),
			e(f, [2, 22]),
			e(f, [2, 23]),
			e(m, [2, 25]),
			e(m, [2, 26]),
			e(m, [2, 28], { 20: [1, 32] }),
			{ 21: [1, 33] },
			{
				6: u,
				7: d,
				10: 34,
				11: p
			},
			{
				1: [2, 7],
				6: r,
				12: 21,
				13: i,
				14: 14,
				16: n,
				17: a,
				18: 17,
				19: 18,
				20: s,
				23: o
			},
			e(y, [2, 14], {
				7: v,
				11: x
			}),
			e(b, [2, 8]),
			e(b, [2, 9]),
			e(b, [2, 10]),
			e(f, [2, 16], {
				15: 37,
				24: g
			}),
			e(f, [2, 17]),
			e(f, [2, 18]),
			e(f, [2, 20], { 24: w }),
			e(m, [2, 31]),
			{ 21: [1, 39] },
			{ 22: [1, 40] },
			e(y, [2, 13], {
				7: v,
				11: x
			}),
			e(b, [2, 11]),
			e(b, [2, 12]),
			e(f, [2, 15], { 24: w }),
			e(m, [2, 30]),
			{ 22: [1, 41] },
			e(m, [2, 27]),
			e(m, [2, 29])
		],
		defaultActions: {
			2: [2, 1],
			6: [2, 2]
		},
		parseError: h(function(e, t) {
			if (t.recoverable) this.trace(e);
			else {
				var r = Error(e);
				throw r.hash = t, r;
			}
		}, "parseError"),
		parse: h(function(e) {
			var t = this, r = [0], i = [], n = [null], a = [], s = this.table, o = "", l = 0, u = 0, d = 0, p = a.slice.call(arguments, 1), f = Object.create(this.lexer), g = {};
			for (var m in this.yy) Object.prototype.hasOwnProperty.call(this.yy, m) && (g[m] = this.yy[m]);
			f.setInput(e, g), g.lexer = f, g.parser = this, typeof f.yylloc > "u" && (f.yylloc = {});
			var y = f.yylloc;
			a.push(y);
			var v = f.options && f.options.ranges;
			function x() {
				var e;
				return "number" != typeof (e = i.pop() || f.lex() || 1) && (e instanceof Array && (e = (i = e).pop()), e = t.symbols_[e] || e), e;
			}
			"function" == typeof g.parseError ? this.parseError = g.parseError : this.parseError = Object.getPrototypeOf(this).parseError, h(function(e) {
				r.length = r.length - 2 * e, n.length = n.length - e, a.length = a.length - e;
			}, "popStack"), h(x, "lex");
			for (var b, w, k, T, _, E, C, S, A, L = {};;) {
				if (k = r[r.length - 1], this.defaultActions[k] ? T = this.defaultActions[k] : ((null === b || typeof b > "u") && (b = x()), T = s[k] && s[k][b]), typeof T > "u" || !T.length || !T[0]) {
					var R = "";
					for (E in A = [], s[k]) this.terminals_[E] && E > 2 && A.push("'" + this.terminals_[E] + "'");
					R = f.showPosition ? "Parse error on line " + (l + 1) + `:
` + f.showPosition() + `
Expecting ` + A.join(", ") + ", got '" + (this.terminals_[b] || b) + "'" : "Parse error on line " + (l + 1) + ": Unexpected " + (1 == b ? "end of input" : "'" + (this.terminals_[b] || b) + "'"), this.parseError(R, {
						text: f.match,
						token: this.terminals_[b] || b,
						line: f.yylineno,
						loc: y,
						expected: A
					});
				}
				if (T[0] instanceof Array && T.length > 1) throw Error("Parse Error: multiple actions possible at state: " + k + ", token: " + b);
				switch (T[0]) {
					case 1:
						r.push(b), n.push(f.yytext), a.push(f.yylloc), r.push(T[1]), b = null, w ? (b = w, w = null) : (u = f.yyleng, o = f.yytext, l = f.yylineno, y = f.yylloc, d > 0 && d--);
						break;
					case 2:
						if (C = this.productions_[T[1]][1], L.$ = n[n.length - C], L._$ = {
							first_line: a[a.length - (C || 1)].first_line,
							last_line: a[a.length - 1].last_line,
							first_column: a[a.length - (C || 1)].first_column,
							last_column: a[a.length - 1].last_column
						}, v && (L._$.range = [a[a.length - (C || 1)].range[0], a[a.length - 1].range[1]]), "u" > typeof (_ = this.performAction.apply(L, [
							o,
							u,
							l,
							g,
							T[1],
							n,
							a
						].concat(p)))) return _;
						C && (r = r.slice(0, -1 * C * 2), n = n.slice(0, -1 * C), a = a.slice(0, -1 * C)), r.push(this.productions_[T[1]][0]), n.push(L.$), a.push(L._$), S = s[r[r.length - 2]][r[r.length - 1]], r.push(S);
						break;
					case 3: return !0;
				}
			}
			return !0;
		}, "parse")
	};
	function T() {
		this.yy = {};
	}
	return k.lexer = {
		EOF: 1,
		parseError: h(function(e, t) {
			if (this.yy.parser) this.yy.parser.parseError(e, t);
			else throw Error(e);
		}, "parseError"),
		setInput: h(function(e, t) {
			return this.yy = t || this.yy || {}, this._input = e, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
				first_line: 1,
				first_column: 0,
				last_line: 1,
				last_column: 0
			}, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
		}, "setInput"),
		input: h(function() {
			var e = this._input[0];
			return this.yytext += e, this.yyleng++, this.offset++, this.match += e, this.matched += e, e.match(/(?:\r\n?|\n).*/g) ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), e;
		}, "input"),
		unput: h(function(e) {
			var t = e.length, r = e.split(/(?:\r\n?|\n)/g);
			this._input = e + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - t), this.offset -= t;
			var i = this.match.split(/(?:\r\n?|\n)/g);
			this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), r.length - 1 && (this.yylineno -= r.length - 1);
			var n = this.yylloc.range;
			return this.yylloc = {
				first_line: this.yylloc.first_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.first_column,
				last_column: r ? (r.length === i.length ? this.yylloc.first_column : 0) + i[i.length - r.length].length - r[0].length : this.yylloc.first_column - t
			}, this.options.ranges && (this.yylloc.range = [n[0], n[0] + this.yyleng - t]), this.yyleng = this.yytext.length, this;
		}, "unput"),
		more: h(function() {
			return this._more = !0, this;
		}, "more"),
		reject: h(function() {
			return this.options.backtrack_lexer ? (this._backtrack = !0, this) : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "reject"),
		less: h(function(e) {
			this.unput(this.match.slice(e));
		}, "less"),
		pastInput: h(function() {
			var e = this.matched.substr(0, this.matched.length - this.match.length);
			return (e.length > 20 ? "..." : "") + e.substr(-20).replace(/\n/g, "");
		}, "pastInput"),
		upcomingInput: h(function() {
			var e = this.match;
			return e.length < 20 && (e += this._input.substr(0, 20 - e.length)), (e.substr(0, 20) + (e.length > 20 ? "..." : "")).replace(/\n/g, "");
		}, "upcomingInput"),
		showPosition: h(function() {
			var e = this.pastInput(), t = Array(e.length + 1).join("-");
			return e + this.upcomingInput() + `
` + t + "^";
		}, "showPosition"),
		test_match: h(function(e, t) {
			var r, i, n;
			if (this.options.backtrack_lexer && (n = {
				yylineno: this.yylineno,
				yylloc: {
					first_line: this.yylloc.first_line,
					last_line: this.last_line,
					first_column: this.yylloc.first_column,
					last_column: this.yylloc.last_column
				},
				yytext: this.yytext,
				match: this.match,
				matches: this.matches,
				matched: this.matched,
				yyleng: this.yyleng,
				offset: this.offset,
				_more: this._more,
				_input: this._input,
				yy: this.yy,
				conditionStack: this.conditionStack.slice(0),
				done: this.done
			}, this.options.ranges && (n.yylloc.range = this.yylloc.range.slice(0))), (i = e[0].match(/(?:\r\n?|\n).*/g)) && (this.yylineno += i.length), this.yylloc = {
				first_line: this.yylloc.last_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.last_column,
				last_column: i ? i[i.length - 1].length - i[i.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + e[0].length
			}, this.yytext += e[0], this.match += e[0], this.matches = e, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(e[0].length), this.matched += e[0], r = this.performAction.call(this, this.yy, this, t, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), r) return r;
			if (this._backtrack) for (var a in n) this[a] = n[a];
			return !1;
		}, "test_match"),
		next: h(function() {
			if (this.done) return this.EOF;
			this._input || (this.done = !0), this._more || (this.yytext = "", this.match = "");
			for (var e, t, r, i, n = this._currentRules(), a = 0; a < n.length; a++) if ((r = this._input.match(this.rules[n[a]])) && (!t || r[0].length > t[0].length)) {
				if (t = r, i = a, this.options.backtrack_lexer) {
					if (!1 !== (e = this.test_match(r, n[a]))) return e;
					if (!this._backtrack) return !1;
					t = !1;
					continue;
				} else if (!this.options.flex) break;
			}
			return t ? !1 !== (e = this.test_match(t, n[i])) && e : "" === this._input ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "next"),
		lex: h(function() {
			return this.next() || this.lex();
		}, "lex"),
		begin: h(function(e) {
			this.conditionStack.push(e);
		}, "begin"),
		popState: h(function() {
			return this.conditionStack.length - 1 > 0 ? this.conditionStack.pop() : this.conditionStack[0];
		}, "popState"),
		_currentRules: h(function() {
			return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
		}, "_currentRules"),
		topState: h(function(e) {
			return (e = this.conditionStack.length - 1 - Math.abs(e || 0)) >= 0 ? this.conditionStack[e] : "INITIAL";
		}, "topState"),
		pushState: h(function(e) {
			this.begin(e);
		}, "pushState"),
		stateStackSize: h(function() {
			return this.conditionStack.length;
		}, "stateStackSize"),
		options: { "case-insensitive": !0 },
		performAction: h(function(e, t, r, i) {
			switch (r) {
				case 0: return this.pushState("shapeData"), t.yytext = "", 24;
				case 1: return this.pushState("shapeDataStr"), 24;
				case 2: return this.popState(), 24;
				case 3: return t.yytext = t.yytext.replace(/\n\s*/g, "<br/>"), 24;
				case 4: return 24;
				case 5:
				case 10:
				case 29:
				case 32:
					this.popState();
					break;
				case 6: return e.getLogger().trace("Found comment", t.yytext), 6;
				case 7: return 8;
				case 8:
					this.begin("CLASS");
					break;
				case 9: return this.popState(), 17;
				case 11:
					e.getLogger().trace("Begin icon"), this.begin("ICON");
					break;
				case 12: return e.getLogger().trace("SPACELINE"), 6;
				case 13: return 7;
				case 14: return 16;
				case 15:
					e.getLogger().trace("end icon"), this.popState();
					break;
				case 16: return e.getLogger().trace("Exploding node"), this.begin("NODE"), 20;
				case 17: return e.getLogger().trace("Cloud"), this.begin("NODE"), 20;
				case 18: return e.getLogger().trace("Explosion Bang"), this.begin("NODE"), 20;
				case 19: return e.getLogger().trace("Cloud Bang"), this.begin("NODE"), 20;
				case 20:
				case 21:
				case 22:
				case 23: return this.begin("NODE"), 20;
				case 24: return 13;
				case 25: return 23;
				case 26: return 11;
				case 27:
					this.begin("NSTR2");
					break;
				case 28: return "NODE_DESCR";
				case 30:
					e.getLogger().trace("Starting NSTR"), this.begin("NSTR");
					break;
				case 31: return e.getLogger().trace("description:", t.yytext), "NODE_DESCR";
				case 33: return this.popState(), e.getLogger().trace("node end ))"), "NODE_DEND";
				case 34: return this.popState(), e.getLogger().trace("node end )"), "NODE_DEND";
				case 35: return this.popState(), e.getLogger().trace("node end ...", t.yytext), "NODE_DEND";
				case 36:
				case 39:
				case 40: return this.popState(), e.getLogger().trace("node end (("), "NODE_DEND";
				case 37:
				case 38: return this.popState(), e.getLogger().trace("node end (-"), "NODE_DEND";
				case 41:
				case 42: return e.getLogger().trace("Long description:", t.yytext), 21;
			}
		}, "anonymous"),
		rules: [
			/^(?:@\{)/i,
			/^(?:["])/i,
			/^(?:["])/i,
			/^(?:[^\"]+)/i,
			/^(?:[^}^"]+)/i,
			/^(?:\})/i,
			/^(?:\s*%%.*)/i,
			/^(?:kanban\b)/i,
			/^(?::::)/i,
			/^(?:.+)/i,
			/^(?:\n)/i,
			/^(?:::icon\()/i,
			/^(?:[\s]+[\n])/i,
			/^(?:[\n]+)/i,
			/^(?:[^\)]+)/i,
			/^(?:\))/i,
			/^(?:-\))/i,
			/^(?:\(-)/i,
			/^(?:\)\))/i,
			/^(?:\))/i,
			/^(?:\(\()/i,
			/^(?:\{\{)/i,
			/^(?:\()/i,
			/^(?:\[)/i,
			/^(?:[\s]+)/i,
			/^(?:[^\(\[\n\)\{\}@]+)/i,
			/^(?:$)/i,
			/^(?:["][`])/i,
			/^(?:[^`"]+)/i,
			/^(?:[`]["])/i,
			/^(?:["])/i,
			/^(?:[^"]+)/i,
			/^(?:["])/i,
			/^(?:[\)]\))/i,
			/^(?:[\)])/i,
			/^(?:[\]])/i,
			/^(?:\}\})/i,
			/^(?:\(-)/i,
			/^(?:-\))/i,
			/^(?:\(\()/i,
			/^(?:\()/i,
			/^(?:[^\)\]\(\}]+)/i,
			/^(?:.+(?!\(\())/i
		],
		conditions: {
			shapeDataEndBracket: {
				rules: [],
				inclusive: !1
			},
			shapeDataStr: {
				rules: [2, 3],
				inclusive: !1
			},
			shapeData: {
				rules: [
					1,
					4,
					5
				],
				inclusive: !1
			},
			CLASS: {
				rules: [9, 10],
				inclusive: !1
			},
			ICON: {
				rules: [14, 15],
				inclusive: !1
			},
			NSTR2: {
				rules: [28, 29],
				inclusive: !1
			},
			NSTR: {
				rules: [31, 32],
				inclusive: !1
			},
			NODE: {
				rules: [
					27,
					30,
					33,
					34,
					35,
					36,
					37,
					38,
					39,
					40,
					41,
					42
				],
				inclusive: !1
			},
			INITIAL: {
				rules: [
					0,
					6,
					7,
					8,
					11,
					12,
					13,
					16,
					17,
					18,
					19,
					20,
					21,
					22,
					23,
					24,
					25,
					26
				],
				inclusive: !0
			}
		}
	}, h(T, "Parser"), T.prototype = k, k.Parser = T, new T();
}();
edr.parser = edr;
var edi = [], edn = [], eda = 0, eds = {}, edo = h(() => {
	edi = [], edn = [], eda = 0, eds = {};
}, "clear"), edl = h((e) => {
	if (0 === edi.length) return null;
	let t = edi[0].level, r = null;
	for (let e = edi.length - 1; e >= 0; e--) if (edi[e].level !== t || r || (r = edi[e]), edi[e].level < t) throw Error("Items without section detected, found section (\"" + edi[e].label + "\")");
	return e === r?.level ? null : r;
}, "getSection"), edc = h(function() {
	return edn;
}, "getSections"), edh = h(function() {
	let e = [], t = edc(), r = IA();
	for (let i of t) {
		let t = {
			id: i.id,
			label: MO(i.label ?? "", r),
			isGroup: !0,
			ticket: i.ticket,
			shape: "kanbanSection",
			level: i.level,
			look: r.look
		};
		for (let n of (e.push(t), edi.filter((e) => e.parentId === i.id))) {
			let t = {
				id: n.id,
				parentId: i.id,
				label: MO(n.label ?? "", r),
				isGroup: !1,
				ticket: n?.ticket,
				priority: n?.priority,
				assigned: n?.assigned,
				icon: n?.icon,
				shape: "kanbanItem",
				level: n.level,
				rx: 5,
				ry: 5,
				cssStyles: ["text-align: left"]
			};
			e.push(t);
		}
	}
	return {
		nodes: e,
		edges: [],
		other: {},
		config: IA()
	};
}, "getData"), edu = h((e, t, r, i, n) => {
	let a = IA(), s = a.mindmap?.padding ?? Ip.mindmap.padding;
	switch (i) {
		case edd.ROUNDED_RECT:
		case edd.RECT:
		case edd.HEXAGON: s *= 2;
	}
	let o = {
		id: MO(t, a) || "kbn" + eda++,
		level: e,
		label: MO(r, a),
		width: a.mindmap?.maxNodeWidth ?? Ip.mindmap.maxNodeWidth,
		padding: s,
		isGroup: !1
	};
	if (void 0 !== n) {
		let e = elT(n.includes(`
`) ? n + `
` : `{
` + n + `
}`, { schema: eof });
		if (e.shape && (e.shape !== e.shape.toLowerCase() || e.shape.includes("_"))) throw Error(`No such shape: ${e.shape}. Shape names should be lowercase.`);
		e?.shape && "kanbanItem" === e.shape && (o.shape = e?.shape), e?.label && (o.label = e?.label), e?.icon && (o.icon = e?.icon.toString()), e?.assigned && (o.assigned = e?.assigned.toString()), e?.ticket && (o.ticket = e?.ticket.toString()), e?.priority && (o.priority = e?.priority);
	}
	let l = edl(e);
	l ? o.parentId = l.id || "kbn" + eda++ : edn.push(o), edi.push(o);
}, "addNode"), edd = {
	DEFAULT: 0,
	NO_BORDER: 0,
	ROUNDED_RECT: 1,
	RECT: 2,
	CIRCLE: 3,
	CLOUD: 4,
	BANG: 5,
	HEXAGON: 6
}, edp = {
	clear: edo,
	addNode: edu,
	getSections: edc,
	getData: edh,
	nodeType: edd,
	getType: h((e, t) => {
		switch (wQ.debug("In get type", e, t), e) {
			case "[": return edd.RECT;
			case "(": return ")" === t ? edd.ROUNDED_RECT : edd.CLOUD;
			case "((": return edd.CIRCLE;
			case ")": return edd.CLOUD;
			case "))": return edd.BANG;
			case "{{": return edd.HEXAGON;
			default: return edd.DEFAULT;
		}
	}, "getType"),
	setElementForId: h((e, t) => {
		eds[e] = t;
	}, "setElementForId"),
	decorateNode: h((e) => {
		if (!e) return;
		let t = IA(), r = edi[edi.length - 1];
		e.icon && (r.icon = MO(e.icon, t)), e.class && (r.cssClasses = MO(e.class, t));
	}, "decorateNode"),
	type2Str: h((e) => {
		switch (e) {
			case edd.DEFAULT: return "no-border";
			case edd.RECT: return "rect";
			case edd.ROUNDED_RECT: return "rounded-rect";
			case edd.CIRCLE: return "circle";
			case edd.CLOUD: return "cloud";
			case edd.BANG: return "bang";
			case edd.HEXAGON: return "hexgon";
			default: return "no-border";
		}
	}, "type2Str"),
	getLogger: h(() => wQ, "getLogger"),
	getElementById: h((e) => eds[e], "getElementById")
}, edf = { draw: h(async (e, t, r, i) => {
	wQ.debug(`Rendering kanban diagram
` + e);
	let n = i.db.getData(), a = IA();
	a.htmlLabels = !1;
	let s = Dy(t), o = s.append("g");
	o.attr("class", "sections");
	let l = s.append("g");
	l.attr("class", "items");
	let h = n.nodes.filter((e) => e.isGroup), u = 0, d = [], p = 25;
	for (let e of h) {
		let t = a?.kanban?.sectionWidth || 200;
		e.x = t * (u += 1) + (u - 1) * 10 / 2, e.width = t, e.y = 0, e.height = 3 * t, e.rx = 5, e.ry = 5, e.cssClasses = e.cssClasses + " section-" + u;
		let r = await eti(o, e);
		p = Math.max(p, r?.labelBBox?.height), d.push(r);
	}
	let f = 0;
	for (let e of h) {
		let t = d[f];
		f += 1;
		let r = a?.kanban?.sectionWidth || 200, i = -(3 * r) / 2 + p, s = i;
		for (let t of n.nodes.filter((t) => t.parentId === e.id)) {
			if (t.isGroup) throw Error("Groups within groups are not allowed in Kanban diagrams");
			t.x = e.x, t.width = r - 15;
			let i = (await erP(l, t, { config: a })).node().getBBox();
			t.y = s + i.height / 2, await erz(t), s = t.y + i.height / 2 + 5;
		}
		let o = t.cluster.select("rect"), h = Math.max(s - i + 30, 50) + (p - 25);
		o.attr("height", h);
	}
	M3(void 0, s, a.mindmap?.padding ?? Ip.kanban.padding, a.mindmap?.useMaxWidth ?? Ip.kanban.useMaxWidth);
}, "draw") }, edg = h((e) => {
	let t = "";
	for (let t = 0; t < e.THEME_COLOR_LIMIT; t++) e["lineColor" + t] = e["lineColor" + t] || e["cScaleInv" + t], N2(e["lineColor" + t]) ? e["lineColor" + t] = N5(e["lineColor" + t], 20) : e["lineColor" + t] = N3(e["lineColor" + t], 20);
	let r = h((t, r) => e.darkMode ? N3(t, r) : N5(t, r), "adjuster");
	for (let i = 0; i < e.THEME_COLOR_LIMIT; i++) {
		let n = "" + (17 - 3 * i);
		t += `
    .section-${i - 1} rect, .section-${i - 1} path, .section-${i - 1} circle, .section-${i - 1} polygon, .section-${i - 1} path  {
      fill: ${r(e["cScale" + i], 10)};
      stroke: ${r(e["cScale" + i], 10)};

    }
    .section-${i - 1} text {
     fill: ${e["cScaleLabel" + i]};
    }
    .node-icon-${i - 1} {
      font-size: 40px;
      color: ${e["cScaleLabel" + i]};
    }
    .section-edge-${i - 1}{
      stroke: ${e["cScale" + i]};
    }
    .edge-depth-${i - 1}{
      stroke-width: ${n};
    }
    .section-${i - 1} line {
      stroke: ${e["cScaleInv" + i]} ;
      stroke-width: 3;
    }

    .disabled, .disabled circle, .disabled text {
      fill: lightgray;
    }
    .disabled text {
      fill: #efefef;
    }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${e.background};
    stroke: ${e.nodeBorder};
    stroke-width: 1px;
  }

  .kanban-ticket-link {
    fill: ${e.background};
    stroke: ${e.nodeBorder};
    text-decoration: underline;
  }
    `;
	}
	return t;
}, "genSections"), edm = {
	db: edp,
	renderer: edf,
	parser: edr,
	styles: h((e) => `
  .edge {
    stroke-width: 3;
  }
  ${edg(e)}
  .section-root rect, .section-root path, .section-root circle, .section-root polygon  {
    fill: ${e.git0};
  }
  .section-root text {
    fill: ${e.gitBranchLabel0};
  }
  .icon-container {
    height:100%;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .edge {
    fill: none;
  }
  .cluster-label, .label {
    color: ${e.textColor};
    fill: ${e.textColor};
    }
  .kanban-label {
    dy: 1em;
    alignment-baseline: middle;
    text-anchor: middle;
    dominant-baseline: middle;
    text-align: center;
  }
    ${Kz()}
`, "getStyles")
}, edy = class e {
	static {
		h(this, "SourceLocation");
	}
	constructor(e, t, r) {
		this.lexer = void 0, this.start = void 0, this.end = void 0, this.lexer = e, this.start = t, this.end = r;
	}
	static range(t, r) {
		return r ? t && t.loc && r.loc && t.loc.lexer === r.loc.lexer ? new e(t.loc.lexer, t.loc.start, r.loc.end) : null : t && t.loc;
	}
}, edv = class e {
	static {
		h(this, "Token");
	}
	constructor(e, t) {
		this.text = void 0, this.loc = void 0, this.noexpand = void 0, this.treatAsRelax = void 0, this.text = e, this.loc = t;
	}
	range(t, r) {
		return new e(r, edy.range(this, t));
	}
}, edx = class e {
	static {
		h(this, "ParseError");
	}
	constructor(t, r) {
		this.name = void 0, this.position = void 0, this.length = void 0, this.rawMessage = void 0;
		var i, n, a = "KaTeX parse error: " + t, s = r && r.loc;
		if (s && s.start <= s.end) {
			var o = s.lexer.input;
			i = s.start, n = s.end, i === o.length ? a += " at end of input: " : a += " at position " + (i + 1) + ": ";
			var l = o.slice(i, n).replace(/[^]/g, "$&");
			a += (i > 15 ? "" + o.slice(i - 15, i) : o.slice(0, i)) + l + (n + 15 < o.length ? o.slice(n, n + 15) + "" : o.slice(n));
		}
		var h = Error(a);
		return h.name = "ParseError", h.__proto__ = e.prototype, h.position = i, null != i && null != n && (h.length = n - i), h.rawMessage = t, h;
	}
};
edx.prototype.__proto__ = Error.prototype;
var edb = h(function(e, t) {
	return -1 !== e.indexOf(t);
}, "contains"), edw = h(function(e, t) {
	return void 0 === e ? t : e;
}, "deflt"), edk = /([A-Z])/g, edT = h(function(e) {
	return e.replace(edk, "-$1").toLowerCase();
}, "hyphenate"), ed_ = {
	"&": "&amp;",
	">": "&gt;",
	"<": "&lt;",
	"\"": "&quot;",
	"'": "&#x27;"
}, edE = /[&><"']/g;
function edC(e) {
	return String(e).replace(edE, (e) => ed_[e]);
}
h(edC, "escape");
var edS = h(function e(t) {
	return "ordgroup" === t.type || "color" === t.type ? 1 === t.body.length ? e(t.body[0]) : t : "font" === t.type ? e(t.body) : t;
}, "getBaseElem"), edA = h(function(e) {
	var t = edS(e);
	return "mathord" === t.type || "textord" === t.type || "atom" === t.type;
}, "isCharacterBox"), edL = h(function(e) {
	if (!e) throw Error("Expected non-null, but got " + String(e));
	return e;
}, "assert"), edR = {
	contains: edb,
	deflt: edw,
	escape: edC,
	hyphenate: edT,
	getBaseElem: edS,
	isCharacterBox: edA,
	protocolFromUrl: h(function(e) {
		var t = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(e);
		return t ? ":" === t[2] && /^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(t[1]) ? t[1].toLowerCase() : null : "_relative";
	}, "protocolFromUrl")
}, edN = {
	displayMode: {
		type: "boolean",
		description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
		cli: "-d, --display-mode"
	},
	output: {
		type: { enum: [
			"htmlAndMathml",
			"html",
			"mathml"
		] },
		description: "Determines the markup language of the output.",
		cli: "-F, --format <type>"
	},
	leqno: {
		type: "boolean",
		description: "Render display math in leqno style (left-justified tags)."
	},
	fleqn: {
		type: "boolean",
		description: "Render display math flush left."
	},
	throwOnError: {
		type: "boolean",
		default: !0,
		cli: "-t, --no-throw-on-error",
		cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
	},
	errorColor: {
		type: "string",
		default: "#cc0000",
		cli: "-c, --error-color <color>",
		cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
		cliProcessor: h((e) => "#" + e, "cliProcessor")
	},
	macros: {
		type: "object",
		cli: "-m, --macro <def>",
		cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
		cliDefault: [],
		cliProcessor: h((e, t) => (t.push(e), t), "cliProcessor")
	},
	minRuleThickness: {
		type: "number",
		description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
		processor: h((e) => Math.max(0, e), "processor"),
		cli: "--min-rule-thickness <size>",
		cliProcessor: parseFloat
	},
	colorIsTextColor: {
		type: "boolean",
		description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
		cli: "-b, --color-is-text-color"
	},
	strict: {
		type: [
			{ enum: [
				"warn",
				"ignore",
				"error"
			] },
			"boolean",
			"function"
		],
		description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
		cli: "-S, --strict",
		cliDefault: !1
	},
	trust: {
		type: ["boolean", "function"],
		description: "Trust the input, enabling all HTML features such as \\url.",
		cli: "-T, --trust"
	},
	maxSize: {
		type: "number",
		default: Infinity,
		description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
		processor: h((e) => Math.max(0, e), "processor"),
		cli: "-s, --max-size <n>",
		cliProcessor: parseInt
	},
	maxExpand: {
		type: "number",
		default: 1e3,
		description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
		processor: h((e) => Math.max(0, e), "processor"),
		cli: "-e, --max-expand <n>",
		cliProcessor: h((e) => "Infinity" === e ? Infinity : parseInt(e), "cliProcessor")
	},
	globalGroup: {
		type: "boolean",
		cli: !1
	}
};
function edI(e) {
	if (e.default) return e.default;
	var t = e.type, r = Array.isArray(t) ? t[0] : t;
	if ("string" != typeof r) return r.enum[0];
	switch (r) {
		case "boolean": return !1;
		case "string": return "";
		case "number": return 0;
		case "object": return {};
	}
}
h(edI, "getDefaultValue");
var edM = class {
	static {
		h(this, "Settings");
	}
	constructor(e) {
		for (var t in this.displayMode = void 0, this.output = void 0, this.leqno = void 0, this.fleqn = void 0, this.throwOnError = void 0, this.errorColor = void 0, this.macros = void 0, this.minRuleThickness = void 0, this.colorIsTextColor = void 0, this.strict = void 0, this.trust = void 0, this.maxSize = void 0, this.maxExpand = void 0, this.globalGroup = void 0, e = e || {}, edN) if (edN.hasOwnProperty(t)) {
			var r = edN[t];
			this[t] = void 0 !== e[t] ? r.processor ? r.processor(e[t]) : e[t] : edI(r);
		}
	}
	reportNonstrict(e, t, r) {
		var i = this.strict;
		if ("function" == typeof i && (i = i(e, t, r)), !(!i || "ignore" === i)) {
			if (!0 === i || "error" === i) throw new edx("LaTeX-incompatible input and strict mode is set to 'error': " + (t + " [") + e + "]", r);
			"warn" === i ? "u" > typeof console && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (t + " [") + e + "]") : "u" > typeof console && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + i + "': " + t + " [") + e + "]");
		}
	}
	useStrictBehavior(e, t, r) {
		var i = this.strict;
		if ("function" == typeof i) try {
			i = i(e, t, r);
		} catch {
			i = "error";
		}
		return !!i && "ignore" !== i && (!0 === i || "error" === i || ("warn" === i ? "u" > typeof console && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (t + " [") + e + "]") : "u" > typeof console && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + i + "': " + t + " [") + e + "]"), !1));
	}
	isTrusted(e) {
		if (e.url && !e.protocol) {
			var t = edR.protocolFromUrl(e.url);
			if (null == t) return !1;
			e.protocol = t;
		}
		return !!("function" == typeof this.trust ? this.trust(e) : this.trust);
	}
}, edD = class {
	static {
		h(this, "Style");
	}
	constructor(e, t, r) {
		this.id = void 0, this.size = void 0, this.cramped = void 0, this.id = e, this.size = t, this.cramped = r;
	}
	sup() {
		return edO[ed$[this.id]];
	}
	sub() {
		return edO[edP[this.id]];
	}
	fracNum() {
		return edO[edB[this.id]];
	}
	fracDen() {
		return edO[edF[this.id]];
	}
	cramp() {
		return edO[edz[this.id]];
	}
	text() {
		return edO[edU[this.id]];
	}
	isTight() {
		return this.size >= 2;
	}
}, edO = [
	new edD(0, 0, !1),
	new edD(1, 0, !0),
	new edD(2, 1, !1),
	new edD(3, 1, !0),
	new edD(4, 2, !1),
	new edD(5, 2, !0),
	new edD(6, 3, !1),
	new edD(7, 3, !0)
], ed$ = [
	4,
	5,
	4,
	5,
	6,
	7,
	6,
	7
], edP = [
	5,
	5,
	5,
	5,
	7,
	7,
	7,
	7
], edB = [
	2,
	3,
	4,
	5,
	6,
	7,
	6,
	7
], edF = [
	3,
	3,
	5,
	5,
	7,
	7,
	7,
	7
], edz = [
	1,
	1,
	3,
	3,
	5,
	5,
	7,
	7
], edU = [
	0,
	1,
	2,
	3,
	2,
	3,
	2,
	3
], edG = {
	DISPLAY: edO[0],
	TEXT: edO[2],
	SCRIPT: edO[4],
	SCRIPTSCRIPT: edO[6]
}, edq = [
	{
		name: "latin",
		blocks: [[256, 591], [768, 879]]
	},
	{
		name: "cyrillic",
		blocks: [[1024, 1279]]
	},
	{
		name: "armenian",
		blocks: [[1328, 1423]]
	},
	{
		name: "brahmic",
		blocks: [[2304, 4255]]
	},
	{
		name: "georgian",
		blocks: [[4256, 4351]]
	},
	{
		name: "cjk",
		blocks: [
			[12288, 12543],
			[19968, 40879],
			[65280, 65376]
		]
	},
	{
		name: "hangul",
		blocks: [[44032, 55215]]
	}
];
function edj(e) {
	for (var t = 0; t < edq.length; t++) for (var r = edq[t], i = 0; i < r.blocks.length; i++) {
		var n = r.blocks[i];
		if (e >= n[0] && e <= n[1]) return r.name;
	}
	return null;
}
h(edj, "scriptFromCodepoint");
var edW = [];
function edY(e) {
	for (var t = 0; t < edW.length; t += 2) if (e >= edW[t] && e <= edW[t + 1]) return !0;
	return !1;
}
edq.forEach((e) => e.blocks.forEach((e) => edW.push(...e))), h(edY, "supportedCodepoint");
var edV = h(function(e, t) {
	return "M95," + (622 + e + t) + `
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l` + e / 2.075 + " -" + e + `
c5.3,-9.3,12,-14,20,-14
H400000v` + (40 + e) + `H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M` + (834 + e) + " " + t + "h400000v" + (40 + e) + "h-400000z";
}, "sqrtMain"), edH = h(function(e, t) {
	return "M263," + (601 + e + t) + `c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l` + e / 2.084 + " -" + e + `
c4.7,-7.3,11,-11,19,-11
H40000v` + (40 + e) + `H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M` + (1001 + e) + " " + t + "h400000v" + (40 + e) + "h-400000z";
}, "sqrtSize1"), edX = h(function(e, t) {
	return "M983 " + (10 + e + t) + `
l` + e / 3.13 + " -" + e + `
c4,-6.7,10,-10,18,-10 H400000v` + (40 + e) + `
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M` + (1001 + e) + " " + t + "h400000v" + (40 + e) + "h-400000z";
}, "sqrtSize2"), edK = h(function(e, t) {
	return "M424," + (2398 + e + t) + `
c-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514
c0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20
s-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121
s209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081
l` + e / 4.223 + " -" + e + `c4,-6.7,10,-10,18,-10 H400000
v` + (40 + e) + `H1014.6
s-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185
c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2z M` + (1001 + e) + " " + t + `
h400000v` + (40 + e) + "h-400000z";
}, "sqrtSize3"), edZ = h(function(e, t) {
	return "M473," + (2713 + e + t) + `
c339.3,-1799.3,509.3,-2700,510,-2702 l` + e / 5.298 + " -" + e + `
c3.3,-7.3,9.3,-11,18,-11 H400000v` + (40 + e) + `H1017.7
s-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9
c-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200
c0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26
s76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,
606zM` + (1001 + e) + " " + t + "h400000v" + (40 + e) + "H1017.7z";
}, "sqrtSize4"), edQ = h(function(e) {
	return "M400000 " + e + " H0 L" + e / 2 + " 0 l65 45 L145 " + (e - 80) + " H400000z";
}, "phasePath"), edJ = h(function(e, t, r) {
	return "M702 " + (e + t) + "H400000" + (40 + e) + `
H742v` + (r - 54 - t - e) + `l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1
h-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170
c-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667
219 661 l218 661zM702 ` + t + "H400000v" + (40 + e) + "H742z";
}, "sqrtTall"), ed0 = h(function(e, t, r) {
	t *= 1e3;
	var i = "";
	switch (e) {
		case "sqrtMain":
			i = edV(t, 80);
			break;
		case "sqrtSize1":
			i = edH(t, 80);
			break;
		case "sqrtSize2":
			i = edX(t, 80);
			break;
		case "sqrtSize3":
			i = edK(t, 80);
			break;
		case "sqrtSize4":
			i = edZ(t, 80);
			break;
		case "sqrtTall": i = edJ(t, 80, r);
	}
	return i;
}, "sqrtPath"), ed1 = h(function(e, t) {
	switch (e) {
		case "": return "M291 0 H417 V" + t + " H291z M291 0 H417 V" + t + " H291z";
		case "": return "M145 0 H188 V" + t + " H145z M145 0 H188 V" + t + " H145z";
		case "": return "M145 0 H188 V" + t + " H145z M145 0 H188 V" + t + " H145z" + ("M367 0 H410 V" + t + " H367z M367 0 H410 V") + t + " H367z";
		case "": return "M457 0 H583 V" + t + " H457z M457 0 H583 V" + t + " H457z";
		case "": return "M319 0 H403 V" + t + " H319z M319 0 H403 V" + t + " H319z";
		case "": return "M263 0 H347 V" + t + " H263z M263 0 H347 V" + t + " H263z";
		case "": return "M384 0 H504 V" + t + " H384z M384 0 H504 V" + t + " H384z";
		case "": return "M312 0 H355 V" + t + " H312z M312 0 H355 V" + t + " H312z";
		case "": return "M257 0 H300 V" + t + " H257z M257 0 H300 V" + t + " H257z" + ("M478 0 H521 V" + t + " H478z M478 0 H521 V") + t + " H478z";
		default: return "";
	}
}, "innerPath"), ed2 = {
	doubleleftarrow: `M262 157
l10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3
 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28
 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5
c2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5
 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87
-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7
-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z
m8 0v40h399730v-40zm0 194v40h399730v-40z`,
	doublerightarrow: `M399738 392l
-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5
 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88
-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68
-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18
-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782
c-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3
-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z`,
	leftarrow: `M400000 241H110l3-3c68.7-52.7 113.7-120
 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8
-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247
c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208
 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3
 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202
 l-3-3h399890zM100 241v40h399900v-40z`,
	leftbrace: `M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117
-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7
 5-6 9-10 13-.7 1-7.3 1-20 1H6z`,
	leftbraceunder: `M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z`,
	leftgroup: `M400000 80
H435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0
 435 0h399565z`,
	leftgroupunder: `M400000 262
H435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219
 435 219h399565z`,
	leftharpoon: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3
-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5
-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7
-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z`,
	leftharpoonplus: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5
 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3
-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7
-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z
m0 0v40h400000v-40z`,
	leftharpoondown: `M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333
 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5
 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667
-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z`,
	leftharpoondownplus: `M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12
 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7
-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0
v40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z`,
	lefthook: `M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z`,
	leftlinesegment: `M40 281 V428 H0 V94 H40 V241 H400000 v40z
M40 281 V428 H0 V94 H40 V241 H400000 v40z`,
	leftmapsto: `M40 281 V448H0V74H40V241H400000v40z
M40 281 V448H0V74H40V241H400000v40z`,
	leftToFrom: `M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23
-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8
c28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3
 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z`,
	longequal: `M0 50 h400000 v40H0z m0 194h40000v40H0z
M0 50 h400000 v40H0z m0 194h40000v40H0z`,
	midbrace: `M200428 334
c-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14
-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7
 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11
 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z`,
	midbraceunder: `M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z`,
	oiintSize1: `M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6
-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z
m368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8
60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z`,
	oiintSize2: `M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8
-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z
m502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2
c0 110 84 276 504 276s502.4-166 502.4-276z`,
	oiiintSize1: `M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6
-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z
m525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0
85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z`,
	oiiintSize2: `M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8
-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z
m770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1
c0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z`,
	rightarrow: `M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z`,
	rightbrace: `M400000 542l
-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5
s-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1
c124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z`,
	rightbraceunder: `M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z`,
	rightgroup: `M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0
 3-1 3-3v-38c-76-158-257-219-435-219H0z`,
	rightgroupunder: `M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18
 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z`,
	rightharpoon: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z`,
	rightharpoonplus: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11
-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7
 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z
m0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z`,
	rightharpoondown: `M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8
 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5
-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95
-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z`,
	rightharpoondownplus: `M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8
 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3
 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3
-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z
m0-194v40h400000v-40zm0 0v40h400000v-40z`,
	righthook: `M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3
 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0
-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21
 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z`,
	rightlinesegment: `M399960 241 V94 h40 V428 h-40 V281 H0 v-40z
M399960 241 V94 h40 V428 h-40 V281 H0 v-40z`,
	rightToFrom: `M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23
 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32
-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142
-167z M100 147v40h399900v-40zM0 341v40h399900v-40z`,
	twoheadleftarrow: `M0 167c68 40
 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69
-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3
-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19
-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101
 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z`,
	twoheadrightarrow: `M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z`,
	tilde1: `M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`,
	tilde2: `M344 55.266c-142 0-300.638 81.316-311.5 86.418
-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9
 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114
c1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751
 181.476 676 181.476c-149 0-189-126.21-332-126.21z`,
	tilde3: `M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457
-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0
 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697
 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696
 -338 0-409-156.573-744-156.573z`,
	tilde4: `M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345
-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409
 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9
 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409
 -175.236-744-175.236z`,
	vec: `M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z`,
	widehat1: `M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z`,
	widehat2: `M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
	widehat3: `M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
	widehat4: `M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
	widecheck1: `M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,
-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z`,
	widecheck2: `M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
	widecheck3: `M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
	widecheck4: `M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
	baraboveleftarrow: `M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202
c4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5
c-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130
s-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47
121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6
s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11
c0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z
M100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z`,
	rightarrowabovebar: `M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32
-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0
13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39
-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5
-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z`,
	baraboveshortleftharpoon: `M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17
c2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21
c-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40
c-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z
M0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z`,
	rightharpoonaboveshortbar: `M0,241 l0,40c399126,0,399993,0,399993,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z`,
	shortbaraboveleftharpoon: `M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,
1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,
-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z
M93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z`,
	shortrightharpoonabovebar: `M53,241l0,40c398570,0,399437,0,399437,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z`
}, ed4 = h(function(e, t) {
	switch (e) {
		case "lbrack": return "M403 1759 V84 H666 V0 H319 V1759 v" + t + ` v1759 h347 v-84
H403z M403 1759 V0 H319 V1759 v` + t + " v1759 h84z";
		case "rbrack": return "M347 1759 V0 H0 V84 H263 V1759 v" + t + ` v1759 H0 v84 H347z
M347 1759 V0 H263 V1759 v` + t + " v1759 h84z";
		case "vert": return "M145 15 v585 v" + t + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -t + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + t + " v585 h43z";
		case "doublevert": return "M145 15 v585 v" + t + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -t + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M188 15 H145 v585 v` + t + ` v585 h43z
M367 15 v585 v` + t + ` v585 c2.667,10,9.667,15,21,15
c10,0,16.667,-5,20,-15 v-585 v` + -t + ` v-585 c-2.667,-10,-9.667,-15,-21,-15
c-10,0,-16.667,5,-20,15z M410 15 H367 v585 v` + t + " v585 h43z";
		case "lfloor": return "M319 602 V0 H403 V602 v" + t + ` v1715 h263 v84 H319z
MM319 602 V0 H403 V602 v` + t + " v1715 H319z";
		case "rfloor": return "M319 602 V0 H403 V602 v" + t + ` v1799 H0 v-84 H319z
MM319 602 V0 H403 V602 v` + t + " v1715 H319z";
		case "lceil": return "M403 1759 V84 H666 V0 H319 V1759 v" + t + ` v602 h84z
M403 1759 V0 H319 V1759 v` + t + " v602 h84z";
		case "rceil": return "M347 1759 V0 H0 V84 H263 V1759 v" + t + ` v602 h84z
M347 1759 V0 h-84 V1759 v` + t + " v602 h84z";
		case "lparen": return `M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1
c-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,
-36,557 l0,` + (t + 84) + `c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,
949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9
c0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,
-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189
l0,-` + (t + 92) + `c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,
-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z`;
		case "rparen": return `M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,
63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5
c11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0,` + (t + 9) + `
c-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664
c-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11
c0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17
c242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558
l0,-` + (t + 144) + `c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,
-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z`;
		default: throw Error("Unknown stretchy delimiter.");
	}
}, "tallDelim"), ed5 = class {
	static {
		h(this, "DocumentFragment");
	}
	constructor(e) {
		this.children = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.children = e, this.classes = [], this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = {};
	}
	hasClass(e) {
		return edR.contains(this.classes, e);
	}
	toNode() {
		for (var e = document.createDocumentFragment(), t = 0; t < this.children.length; t++) e.appendChild(this.children[t].toNode());
		return e;
	}
	toMarkup() {
		for (var e = "", t = 0; t < this.children.length; t++) e += this.children[t].toMarkup();
		return e;
	}
	toText() {
		var e = h((e) => e.toText(), "toText");
		return this.children.map(e).join("");
	}
}, ed3 = {
	"AMS-Regular": {
		32: [
			0,
			0,
			0,
			0,
			.25
		],
		65: [
			0,
			.68889,
			0,
			0,
			.72222
		],
		66: [
			0,
			.68889,
			0,
			0,
			.66667
		],
		67: [
			0,
			.68889,
			0,
			0,
			.72222
		],
		68: [
			0,
			.68889,
			0,
			0,
			.72222
		],
		69: [
			0,
			.68889,
			0,
			0,
			.66667
		],
		70: [
			0,
			.68889,
			0,
			0,
			.61111
		],
		71: [
			0,
			.68889,
			0,
			0,
			.77778
		],
		72: [
			0,
			.68889,
			0,
			0,
			.77778
		],
		73: [
			0,
			.68889,
			0,
			0,
			.38889
		],
		74: [
			.16667,
			.68889,
			0,
			0,
			.5
		],
		75: [
			0,
			.68889,
			0,
			0,
			.77778
		],
		76: [
			0,
			.68889,
			0,
			0,
			.66667
		],
		77: [
			0,
			.68889,
			0,
			0,
			.94445
		],
		78: [
			0,
			.68889,
			0,
			0,
			.72222
		],
		79: [
			.16667,
			.68889,
			0,
			0,
			.77778
		],
		80: [
			0,
			.68889,
			0,
			0,
			.61111
		],
		81: [
			.16667,
			.68889,
			0,
			0,
			.77778
		],
		82: [
			0,
			.68889,
			0,
			0,
			.72222
		],
		83: [
			0,
			.68889,
			0,
			0,
			.55556
		],
		84: [
			0,
			.68889,
			0,
			0,
			.66667
		],
		85: [
			0,
			.68889,
			0,
			0,
			.72222
		],
		86: [
			0,
			.68889,
			0,
			0,
			.72222
		],
		87: [
			0,
			.68889,
			0,
			0,
			1
		],
		88: [
			0,
			.68889,
			0,
			0,
			.72222
		],
		89: [
			0,
			.68889,
			0,
			0,
			.72222
		],
		90: [
			0,
			.68889,
			0,
			0,
			.66667
		],
		107: [
			0,
			.68889,
			0,
			0,
			.55556
		],
		160: [
			0,
			0,
			0,
			0,
			.25
		],
		165: [
			0,
			.675,
			.025,
			0,
			.75
		],
		174: [
			.15559,
			.69224,
			0,
			0,
			.94666
		],
		240: [
			0,
			.68889,
			0,
			0,
			.55556
		],
		295: [
			0,
			.68889,
			0,
			0,
			.54028
		],
		710: [
			0,
			.825,
			0,
			0,
			2.33334
		],
		732: [
			0,
			.9,
			0,
			0,
			2.33334
		],
		770: [
			0,
			.825,
			0,
			0,
			2.33334
		],
		771: [
			0,
			.9,
			0,
			0,
			2.33334
		],
		989: [
			.08167,
			.58167,
			0,
			0,
			.77778
		],
		1008: [
			0,
			.43056,
			.04028,
			0,
			.66667
		],
		8245: [
			0,
			.54986,
			0,
			0,
			.275
		],
		8463: [
			0,
			.68889,
			0,
			0,
			.54028
		],
		8487: [
			0,
			.68889,
			0,
			0,
			.72222
		],
		8498: [
			0,
			.68889,
			0,
			0,
			.55556
		],
		8502: [
			0,
			.68889,
			0,
			0,
			.66667
		],
		8503: [
			0,
			.68889,
			0,
			0,
			.44445
		],
		8504: [
			0,
			.68889,
			0,
			0,
			.66667
		],
		8513: [
			0,
			.68889,
			0,
			0,
			.63889
		],
		8592: [
			-.03598,
			.46402,
			0,
			0,
			.5
		],
		8594: [
			-.03598,
			.46402,
			0,
			0,
			.5
		],
		8602: [
			-.13313,
			.36687,
			0,
			0,
			1
		],
		8603: [
			-.13313,
			.36687,
			0,
			0,
			1
		],
		8606: [
			.01354,
			.52239,
			0,
			0,
			1
		],
		8608: [
			.01354,
			.52239,
			0,
			0,
			1
		],
		8610: [
			.01354,
			.52239,
			0,
			0,
			1.11111
		],
		8611: [
			.01354,
			.52239,
			0,
			0,
			1.11111
		],
		8619: [
			0,
			.54986,
			0,
			0,
			1
		],
		8620: [
			0,
			.54986,
			0,
			0,
			1
		],
		8621: [
			-.13313,
			.37788,
			0,
			0,
			1.38889
		],
		8622: [
			-.13313,
			.36687,
			0,
			0,
			1
		],
		8624: [
			0,
			.69224,
			0,
			0,
			.5
		],
		8625: [
			0,
			.69224,
			0,
			0,
			.5
		],
		8630: [
			0,
			.43056,
			0,
			0,
			1
		],
		8631: [
			0,
			.43056,
			0,
			0,
			1
		],
		8634: [
			.08198,
			.58198,
			0,
			0,
			.77778
		],
		8635: [
			.08198,
			.58198,
			0,
			0,
			.77778
		],
		8638: [
			.19444,
			.69224,
			0,
			0,
			.41667
		],
		8639: [
			.19444,
			.69224,
			0,
			0,
			.41667
		],
		8642: [
			.19444,
			.69224,
			0,
			0,
			.41667
		],
		8643: [
			.19444,
			.69224,
			0,
			0,
			.41667
		],
		8644: [
			.1808,
			.675,
			0,
			0,
			1
		],
		8646: [
			.1808,
			.675,
			0,
			0,
			1
		],
		8647: [
			.1808,
			.675,
			0,
			0,
			1
		],
		8648: [
			.19444,
			.69224,
			0,
			0,
			.83334
		],
		8649: [
			.1808,
			.675,
			0,
			0,
			1
		],
		8650: [
			.19444,
			.69224,
			0,
			0,
			.83334
		],
		8651: [
			.01354,
			.52239,
			0,
			0,
			1
		],
		8652: [
			.01354,
			.52239,
			0,
			0,
			1
		],
		8653: [
			-.13313,
			.36687,
			0,
			0,
			1
		],
		8654: [
			-.13313,
			.36687,
			0,
			0,
			1
		],
		8655: [
			-.13313,
			.36687,
			0,
			0,
			1
		],
		8666: [
			.13667,
			.63667,
			0,
			0,
			1
		],
		8667: [
			.13667,
			.63667,
			0,
			0,
			1
		],
		8669: [
			-.13313,
			.37788,
			0,
			0,
			1
		],
		8672: [
			-.064,
			.437,
			0,
			0,
			1.334
		],
		8674: [
			-.064,
			.437,
			0,
			0,
			1.334
		],
		8705: [
			0,
			.825,
			0,
			0,
			.5
		],
		8708: [
			0,
			.68889,
			0,
			0,
			.55556
		],
		8709: [
			.08167,
			.58167,
			0,
			0,
			.77778
		],
		8717: [
			0,
			.43056,
			0,
			0,
			.42917
		],
		8722: [
			-.03598,
			.46402,
			0,
			0,
			.5
		],
		8724: [
			.08198,
			.69224,
			0,
			0,
			.77778
		],
		8726: [
			.08167,
			.58167,
			0,
			0,
			.77778
		],
		8733: [
			0,
			.69224,
			0,
			0,
			.77778
		],
		8736: [
			0,
			.69224,
			0,
			0,
			.72222
		],
		8737: [
			0,
			.69224,
			0,
			0,
			.72222
		],
		8738: [
			.03517,
			.52239,
			0,
			0,
			.72222
		],
		8739: [
			.08167,
			.58167,
			0,
			0,
			.22222
		],
		8740: [
			.25142,
			.74111,
			0,
			0,
			.27778
		],
		8741: [
			.08167,
			.58167,
			0,
			0,
			.38889
		],
		8742: [
			.25142,
			.74111,
			0,
			0,
			.5
		],
		8756: [
			0,
			.69224,
			0,
			0,
			.66667
		],
		8757: [
			0,
			.69224,
			0,
			0,
			.66667
		],
		8764: [
			-.13313,
			.36687,
			0,
			0,
			.77778
		],
		8765: [
			-.13313,
			.37788,
			0,
			0,
			.77778
		],
		8769: [
			-.13313,
			.36687,
			0,
			0,
			.77778
		],
		8770: [
			-.03625,
			.46375,
			0,
			0,
			.77778
		],
		8774: [
			.30274,
			.79383,
			0,
			0,
			.77778
		],
		8776: [
			-.01688,
			.48312,
			0,
			0,
			.77778
		],
		8778: [
			.08167,
			.58167,
			0,
			0,
			.77778
		],
		8782: [
			.06062,
			.54986,
			0,
			0,
			.77778
		],
		8783: [
			.06062,
			.54986,
			0,
			0,
			.77778
		],
		8785: [
			.08198,
			.58198,
			0,
			0,
			.77778
		],
		8786: [
			.08198,
			.58198,
			0,
			0,
			.77778
		],
		8787: [
			.08198,
			.58198,
			0,
			0,
			.77778
		],
		8790: [
			0,
			.69224,
			0,
			0,
			.77778
		],
		8791: [
			.22958,
			.72958,
			0,
			0,
			.77778
		],
		8796: [
			.08198,
			.91667,
			0,
			0,
			.77778
		],
		8806: [
			.25583,
			.75583,
			0,
			0,
			.77778
		],
		8807: [
			.25583,
			.75583,
			0,
			0,
			.77778
		],
		8808: [
			.25142,
			.75726,
			0,
			0,
			.77778
		],
		8809: [
			.25142,
			.75726,
			0,
			0,
			.77778
		],
		8812: [
			.25583,
			.75583,
			0,
			0,
			.5
		],
		8814: [
			.20576,
			.70576,
			0,
			0,
			.77778
		],
		8815: [
			.20576,
			.70576,
			0,
			0,
			.77778
		],
		8816: [
			.30274,
			.79383,
			0,
			0,
			.77778
		],
		8817: [
			.30274,
			.79383,
			0,
			0,
			.77778
		],
		8818: [
			.22958,
			.72958,
			0,
			0,
			.77778
		],
		8819: [
			.22958,
			.72958,
			0,
			0,
			.77778
		],
		8822: [
			.1808,
			.675,
			0,
			0,
			.77778
		],
		8823: [
			.1808,
			.675,
			0,
			0,
			.77778
		],
		8828: [
			.13667,
			.63667,
			0,
			0,
			.77778
		],
		8829: [
			.13667,
			.63667,
			0,
			0,
			.77778
		],
		8830: [
			.22958,
			.72958,
			0,
			0,
			.77778
		],
		8831: [
			.22958,
			.72958,
			0,
			0,
			.77778
		],
		8832: [
			.20576,
			.70576,
			0,
			0,
			.77778
		],
		8833: [
			.20576,
			.70576,
			0,
			0,
			.77778
		],
		8840: [
			.30274,
			.79383,
			0,
			0,
			.77778
		],
		8841: [
			.30274,
			.79383,
			0,
			0,
			.77778
		],
		8842: [
			.13597,
			.63597,
			0,
			0,
			.77778
		],
		8843: [
			.13597,
			.63597,
			0,
			0,
			.77778
		],
		8847: [
			.03517,
			.54986,
			0,
			0,
			.77778
		],
		8848: [
			.03517,
			.54986,
			0,
			0,
			.77778
		],
		8858: [
			.08198,
			.58198,
			0,
			0,
			.77778
		],
		8859: [
			.08198,
			.58198,
			0,
			0,
			.77778
		],
		8861: [
			.08198,
			.58198,
			0,
			0,
			.77778
		],
		8862: [
			0,
			.675,
			0,
			0,
			.77778
		],
		8863: [
			0,
			.675,
			0,
			0,
			.77778
		],
		8864: [
			0,
			.675,
			0,
			0,
			.77778
		],
		8865: [
			0,
			.675,
			0,
			0,
			.77778
		],
		8872: [
			0,
			.69224,
			0,
			0,
			.61111
		],
		8873: [
			0,
			.69224,
			0,
			0,
			.72222
		],
		8874: [
			0,
			.69224,
			0,
			0,
			.88889
		],
		8876: [
			0,
			.68889,
			0,
			0,
			.61111
		],
		8877: [
			0,
			.68889,
			0,
			0,
			.61111
		],
		8878: [
			0,
			.68889,
			0,
			0,
			.72222
		],
		8879: [
			0,
			.68889,
			0,
			0,
			.72222
		],
		8882: [
			.03517,
			.54986,
			0,
			0,
			.77778
		],
		8883: [
			.03517,
			.54986,
			0,
			0,
			.77778
		],
		8884: [
			.13667,
			.63667,
			0,
			0,
			.77778
		],
		8885: [
			.13667,
			.63667,
			0,
			0,
			.77778
		],
		8888: [
			0,
			.54986,
			0,
			0,
			1.11111
		],
		8890: [
			.19444,
			.43056,
			0,
			0,
			.55556
		],
		8891: [
			.19444,
			.69224,
			0,
			0,
			.61111
		],
		8892: [
			.19444,
			.69224,
			0,
			0,
			.61111
		],
		8901: [
			0,
			.54986,
			0,
			0,
			.27778
		],
		8903: [
			.08167,
			.58167,
			0,
			0,
			.77778
		],
		8905: [
			.08167,
			.58167,
			0,
			0,
			.77778
		],
		8906: [
			.08167,
			.58167,
			0,
			0,
			.77778
		],
		8907: [
			0,
			.69224,
			0,
			0,
			.77778
		],
		8908: [
			0,
			.69224,
			0,
			0,
			.77778
		],
		8909: [
			-.03598,
			.46402,
			0,
			0,
			.77778
		],
		8910: [
			0,
			.54986,
			0,
			0,
			.76042
		],
		8911: [
			0,
			.54986,
			0,
			0,
			.76042
		],
		8912: [
			.03517,
			.54986,
			0,
			0,
			.77778
		],
		8913: [
			.03517,
			.54986,
			0,
			0,
			.77778
		],
		8914: [
			0,
			.54986,
			0,
			0,
			.66667
		],
		8915: [
			0,
			.54986,
			0,
			0,
			.66667
		],
		8916: [
			0,
			.69224,
			0,
			0,
			.66667
		],
		8918: [
			.0391,
			.5391,
			0,
			0,
			.77778
		],
		8919: [
			.0391,
			.5391,
			0,
			0,
			.77778
		],
		8920: [
			.03517,
			.54986,
			0,
			0,
			1.33334
		],
		8921: [
			.03517,
			.54986,
			0,
			0,
			1.33334
		],
		8922: [
			.38569,
			.88569,
			0,
			0,
			.77778
		],
		8923: [
			.38569,
			.88569,
			0,
			0,
			.77778
		],
		8926: [
			.13667,
			.63667,
			0,
			0,
			.77778
		],
		8927: [
			.13667,
			.63667,
			0,
			0,
			.77778
		],
		8928: [
			.30274,
			.79383,
			0,
			0,
			.77778
		],
		8929: [
			.30274,
			.79383,
			0,
			0,
			.77778
		],
		8934: [
			.23222,
			.74111,
			0,
			0,
			.77778
		],
		8935: [
			.23222,
			.74111,
			0,
			0,
			.77778
		],
		8936: [
			.23222,
			.74111,
			0,
			0,
			.77778
		],
		8937: [
			.23222,
			.74111,
			0,
			0,
			.77778
		],
		8938: [
			.20576,
			.70576,
			0,
			0,
			.77778
		],
		8939: [
			.20576,
			.70576,
			0,
			0,
			.77778
		],
		8940: [
			.30274,
			.79383,
			0,
			0,
			.77778
		],
		8941: [
			.30274,
			.79383,
			0,
			0,
			.77778
		],
		8994: [
			.19444,
			.69224,
			0,
			0,
			.77778
		],
		8995: [
			.19444,
			.69224,
			0,
			0,
			.77778
		],
		9416: [
			.15559,
			.69224,
			0,
			0,
			.90222
		],
		9484: [
			0,
			.69224,
			0,
			0,
			.5
		],
		9488: [
			0,
			.69224,
			0,
			0,
			.5
		],
		9492: [
			0,
			.37788,
			0,
			0,
			.5
		],
		9496: [
			0,
			.37788,
			0,
			0,
			.5
		],
		9585: [
			.19444,
			.68889,
			0,
			0,
			.88889
		],
		9586: [
			.19444,
			.74111,
			0,
			0,
			.88889
		],
		9632: [
			0,
			.675,
			0,
			0,
			.77778
		],
		9633: [
			0,
			.675,
			0,
			0,
			.77778
		],
		9650: [
			0,
			.54986,
			0,
			0,
			.72222
		],
		9651: [
			0,
			.54986,
			0,
			0,
			.72222
		],
		9654: [
			.03517,
			.54986,
			0,
			0,
			.77778
		],
		9660: [
			0,
			.54986,
			0,
			0,
			.72222
		],
		9661: [
			0,
			.54986,
			0,
			0,
			.72222
		],
		9664: [
			.03517,
			.54986,
			0,
			0,
			.77778
		],
		9674: [
			.11111,
			.69224,
			0,
			0,
			.66667
		],
		9733: [
			.19444,
			.69224,
			0,
			0,
			.94445
		],
		10003: [
			0,
			.69224,
			0,
			0,
			.83334
		],
		10016: [
			0,
			.69224,
			0,
			0,
			.83334
		],
		10731: [
			.11111,
			.69224,
			0,
			0,
			.66667
		],
		10846: [
			.19444,
			.75583,
			0,
			0,
			.61111
		],
		10877: [
			.13667,
			.63667,
			0,
			0,
			.77778
		],
		10878: [
			.13667,
			.63667,
			0,
			0,
			.77778
		],
		10885: [
			.25583,
			.75583,
			0,
			0,
			.77778
		],
		10886: [
			.25583,
			.75583,
			0,
			0,
			.77778
		],
		10887: [
			.13597,
			.63597,
			0,
			0,
			.77778
		],
		10888: [
			.13597,
			.63597,
			0,
			0,
			.77778
		],
		10889: [
			.26167,
			.75726,
			0,
			0,
			.77778
		],
		10890: [
			.26167,
			.75726,
			0,
			0,
			.77778
		],
		10891: [
			.48256,
			.98256,
			0,
			0,
			.77778
		],
		10892: [
			.48256,
			.98256,
			0,
			0,
			.77778
		],
		10901: [
			.13667,
			.63667,
			0,
			0,
			.77778
		],
		10902: [
			.13667,
			.63667,
			0,
			0,
			.77778
		],
		10933: [
			.25142,
			.75726,
			0,
			0,
			.77778
		],
		10934: [
			.25142,
			.75726,
			0,
			0,
			.77778
		],
		10935: [
			.26167,
			.75726,
			0,
			0,
			.77778
		],
		10936: [
			.26167,
			.75726,
			0,
			0,
			.77778
		],
		10937: [
			.26167,
			.75726,
			0,
			0,
			.77778
		],
		10938: [
			.26167,
			.75726,
			0,
			0,
			.77778
		],
		10949: [
			.25583,
			.75583,
			0,
			0,
			.77778
		],
		10950: [
			.25583,
			.75583,
			0,
			0,
			.77778
		],
		10955: [
			.28481,
			.79383,
			0,
			0,
			.77778
		],
		10956: [
			.28481,
			.79383,
			0,
			0,
			.77778
		],
		57350: [
			.08167,
			.58167,
			0,
			0,
			.22222
		],
		57351: [
			.08167,
			.58167,
			0,
			0,
			.38889
		],
		57352: [
			.08167,
			.58167,
			0,
			0,
			.77778
		],
		57353: [
			0,
			.43056,
			.04028,
			0,
			.66667
		],
		57356: [
			.25142,
			.75726,
			0,
			0,
			.77778
		],
		57357: [
			.25142,
			.75726,
			0,
			0,
			.77778
		],
		57358: [
			.41951,
			.91951,
			0,
			0,
			.77778
		],
		57359: [
			.30274,
			.79383,
			0,
			0,
			.77778
		],
		57360: [
			.30274,
			.79383,
			0,
			0,
			.77778
		],
		57361: [
			.41951,
			.91951,
			0,
			0,
			.77778
		],
		57366: [
			.25142,
			.75726,
			0,
			0,
			.77778
		],
		57367: [
			.25142,
			.75726,
			0,
			0,
			.77778
		],
		57368: [
			.25142,
			.75726,
			0,
			0,
			.77778
		],
		57369: [
			.25142,
			.75726,
			0,
			0,
			.77778
		],
		57370: [
			.13597,
			.63597,
			0,
			0,
			.77778
		],
		57371: [
			.13597,
			.63597,
			0,
			0,
			.77778
		]
	},
	"Caligraphic-Regular": {
		32: [
			0,
			0,
			0,
			0,
			.25
		],
		65: [
			0,
			.68333,
			0,
			.19445,
			.79847
		],
		66: [
			0,
			.68333,
			.03041,
			.13889,
			.65681
		],
		67: [
			0,
			.68333,
			.05834,
			.13889,
			.52653
		],
		68: [
			0,
			.68333,
			.02778,
			.08334,
			.77139
		],
		69: [
			0,
			.68333,
			.08944,
			.11111,
			.52778
		],
		70: [
			0,
			.68333,
			.09931,
			.11111,
			.71875
		],
		71: [
			.09722,
			.68333,
			.0593,
			.11111,
			.59487
		],
		72: [
			0,
			.68333,
			.00965,
			.11111,
			.84452
		],
		73: [
			0,
			.68333,
			.07382,
			0,
			.54452
		],
		74: [
			.09722,
			.68333,
			.18472,
			.16667,
			.67778
		],
		75: [
			0,
			.68333,
			.01445,
			.05556,
			.76195
		],
		76: [
			0,
			.68333,
			0,
			.13889,
			.68972
		],
		77: [
			0,
			.68333,
			0,
			.13889,
			1.2009
		],
		78: [
			0,
			.68333,
			.14736,
			.08334,
			.82049
		],
		79: [
			0,
			.68333,
			.02778,
			.11111,
			.79611
		],
		80: [
			0,
			.68333,
			.08222,
			.08334,
			.69556
		],
		81: [
			.09722,
			.68333,
			0,
			.11111,
			.81667
		],
		82: [
			0,
			.68333,
			0,
			.08334,
			.8475
		],
		83: [
			0,
			.68333,
			.075,
			.13889,
			.60556
		],
		84: [
			0,
			.68333,
			.25417,
			0,
			.54464
		],
		85: [
			0,
			.68333,
			.09931,
			.08334,
			.62583
		],
		86: [
			0,
			.68333,
			.08222,
			0,
			.61278
		],
		87: [
			0,
			.68333,
			.08222,
			.08334,
			.98778
		],
		88: [
			0,
			.68333,
			.14643,
			.13889,
			.7133
		],
		89: [
			.09722,
			.68333,
			.08222,
			.08334,
			.66834
		],
		90: [
			0,
			.68333,
			.07944,
			.13889,
			.72473
		],
		160: [
			0,
			0,
			0,
			0,
			.25
		]
	},
	"Fraktur-Regular": {
		32: [
			0,
			0,
			0,
			0,
			.25
		],
		33: [
			0,
			.69141,
			0,
			0,
			.29574
		],
		34: [
			0,
			.69141,
			0,
			0,
			.21471
		],
		38: [
			0,
			.69141,
			0,
			0,
			.73786
		],
		39: [
			0,
			.69141,
			0,
			0,
			.21201
		],
		40: [
			.24982,
			.74947,
			0,
			0,
			.38865
		],
		41: [
			.24982,
			.74947,
			0,
			0,
			.38865
		],
		42: [
			0,
			.62119,
			0,
			0,
			.27764
		],
		43: [
			.08319,
			.58283,
			0,
			0,
			.75623
		],
		44: [
			0,
			.10803,
			0,
			0,
			.27764
		],
		45: [
			.08319,
			.58283,
			0,
			0,
			.75623
		],
		46: [
			0,
			.10803,
			0,
			0,
			.27764
		],
		47: [
			.24982,
			.74947,
			0,
			0,
			.50181
		],
		48: [
			0,
			.47534,
			0,
			0,
			.50181
		],
		49: [
			0,
			.47534,
			0,
			0,
			.50181
		],
		50: [
			0,
			.47534,
			0,
			0,
			.50181
		],
		51: [
			.18906,
			.47534,
			0,
			0,
			.50181
		],
		52: [
			.18906,
			.47534,
			0,
			0,
			.50181
		],
		53: [
			.18906,
			.47534,
			0,
			0,
			.50181
		],
		54: [
			0,
			.69141,
			0,
			0,
			.50181
		],
		55: [
			.18906,
			.47534,
			0,
			0,
			.50181
		],
		56: [
			0,
			.69141,
			0,
			0,
			.50181
		],
		57: [
			.18906,
			.47534,
			0,
			0,
			.50181
		],
		58: [
			0,
			.47534,
			0,
			0,
			.21606
		],
		59: [
			.12604,
			.47534,
			0,
			0,
			.21606
		],
		61: [
			-.13099,
			.36866,
			0,
			0,
			.75623
		],
		63: [
			0,
			.69141,
			0,
			0,
			.36245
		],
		65: [
			0,
			.69141,
			0,
			0,
			.7176
		],
		66: [
			0,
			.69141,
			0,
			0,
			.88397
		],
		67: [
			0,
			.69141,
			0,
			0,
			.61254
		],
		68: [
			0,
			.69141,
			0,
			0,
			.83158
		],
		69: [
			0,
			.69141,
			0,
			0,
			.66278
		],
		70: [
			.12604,
			.69141,
			0,
			0,
			.61119
		],
		71: [
			0,
			.69141,
			0,
			0,
			.78539
		],
		72: [
			.06302,
			.69141,
			0,
			0,
			.7203
		],
		73: [
			0,
			.69141,
			0,
			0,
			.55448
		],
		74: [
			.12604,
			.69141,
			0,
			0,
			.55231
		],
		75: [
			0,
			.69141,
			0,
			0,
			.66845
		],
		76: [
			0,
			.69141,
			0,
			0,
			.66602
		],
		77: [
			0,
			.69141,
			0,
			0,
			1.04953
		],
		78: [
			0,
			.69141,
			0,
			0,
			.83212
		],
		79: [
			0,
			.69141,
			0,
			0,
			.82699
		],
		80: [
			.18906,
			.69141,
			0,
			0,
			.82753
		],
		81: [
			.03781,
			.69141,
			0,
			0,
			.82699
		],
		82: [
			0,
			.69141,
			0,
			0,
			.82807
		],
		83: [
			0,
			.69141,
			0,
			0,
			.82861
		],
		84: [
			0,
			.69141,
			0,
			0,
			.66899
		],
		85: [
			0,
			.69141,
			0,
			0,
			.64576
		],
		86: [
			0,
			.69141,
			0,
			0,
			.83131
		],
		87: [
			0,
			.69141,
			0,
			0,
			1.04602
		],
		88: [
			0,
			.69141,
			0,
			0,
			.71922
		],
		89: [
			.18906,
			.69141,
			0,
			0,
			.83293
		],
		90: [
			.12604,
			.69141,
			0,
			0,
			.60201
		],
		91: [
			.24982,
			.74947,
			0,
			0,
			.27764
		],
		93: [
			.24982,
			.74947,
			0,
			0,
			.27764
		],
		94: [
			0,
			.69141,
			0,
			0,
			.49965
		],
		97: [
			0,
			.47534,
			0,
			0,
			.50046
		],
		98: [
			0,
			.69141,
			0,
			0,
			.51315
		],
		99: [
			0,
			.47534,
			0,
			0,
			.38946
		],
		100: [
			0,
			.62119,
			0,
			0,
			.49857
		],
		101: [
			0,
			.47534,
			0,
			0,
			.40053
		],
		102: [
			.18906,
			.69141,
			0,
			0,
			.32626
		],
		103: [
			.18906,
			.47534,
			0,
			0,
			.5037
		],
		104: [
			.18906,
			.69141,
			0,
			0,
			.52126
		],
		105: [
			0,
			.69141,
			0,
			0,
			.27899
		],
		106: [
			0,
			.69141,
			0,
			0,
			.28088
		],
		107: [
			0,
			.69141,
			0,
			0,
			.38946
		],
		108: [
			0,
			.69141,
			0,
			0,
			.27953
		],
		109: [
			0,
			.47534,
			0,
			0,
			.76676
		],
		110: [
			0,
			.47534,
			0,
			0,
			.52666
		],
		111: [
			0,
			.47534,
			0,
			0,
			.48885
		],
		112: [
			.18906,
			.52396,
			0,
			0,
			.50046
		],
		113: [
			.18906,
			.47534,
			0,
			0,
			.48912
		],
		114: [
			0,
			.47534,
			0,
			0,
			.38919
		],
		115: [
			0,
			.47534,
			0,
			0,
			.44266
		],
		116: [
			0,
			.62119,
			0,
			0,
			.33301
		],
		117: [
			0,
			.47534,
			0,
			0,
			.5172
		],
		118: [
			0,
			.52396,
			0,
			0,
			.5118
		],
		119: [
			0,
			.52396,
			0,
			0,
			.77351
		],
		120: [
			.18906,
			.47534,
			0,
			0,
			.38865
		],
		121: [
			.18906,
			.47534,
			0,
			0,
			.49884
		],
		122: [
			.18906,
			.47534,
			0,
			0,
			.39054
		],
		160: [
			0,
			0,
			0,
			0,
			.25
		],
		8216: [
			0,
			.69141,
			0,
			0,
			.21471
		],
		8217: [
			0,
			.69141,
			0,
			0,
			.21471
		],
		58112: [
			0,
			.62119,
			0,
			0,
			.49749
		],
		58113: [
			0,
			.62119,
			0,
			0,
			.4983
		],
		58114: [
			.18906,
			.69141,
			0,
			0,
			.33328
		],
		58115: [
			.18906,
			.69141,
			0,
			0,
			.32923
		],
		58116: [
			.18906,
			.47534,
			0,
			0,
			.50343
		],
		58117: [
			0,
			.69141,
			0,
			0,
			.33301
		],
		58118: [
			0,
			.62119,
			0,
			0,
			.33409
		],
		58119: [
			0,
			.47534,
			0,
			0,
			.50073
		]
	},
	"Main-Bold": {
		32: [
			0,
			0,
			0,
			0,
			.25
		],
		33: [
			0,
			.69444,
			0,
			0,
			.35
		],
		34: [
			0,
			.69444,
			0,
			0,
			.60278
		],
		35: [
			.19444,
			.69444,
			0,
			0,
			.95833
		],
		36: [
			.05556,
			.75,
			0,
			0,
			.575
		],
		37: [
			.05556,
			.75,
			0,
			0,
			.95833
		],
		38: [
			0,
			.69444,
			0,
			0,
			.89444
		],
		39: [
			0,
			.69444,
			0,
			0,
			.31944
		],
		40: [
			.25,
			.75,
			0,
			0,
			.44722
		],
		41: [
			.25,
			.75,
			0,
			0,
			.44722
		],
		42: [
			0,
			.75,
			0,
			0,
			.575
		],
		43: [
			.13333,
			.63333,
			0,
			0,
			.89444
		],
		44: [
			.19444,
			.15556,
			0,
			0,
			.31944
		],
		45: [
			0,
			.44444,
			0,
			0,
			.38333
		],
		46: [
			0,
			.15556,
			0,
			0,
			.31944
		],
		47: [
			.25,
			.75,
			0,
			0,
			.575
		],
		48: [
			0,
			.64444,
			0,
			0,
			.575
		],
		49: [
			0,
			.64444,
			0,
			0,
			.575
		],
		50: [
			0,
			.64444,
			0,
			0,
			.575
		],
		51: [
			0,
			.64444,
			0,
			0,
			.575
		],
		52: [
			0,
			.64444,
			0,
			0,
			.575
		],
		53: [
			0,
			.64444,
			0,
			0,
			.575
		],
		54: [
			0,
			.64444,
			0,
			0,
			.575
		],
		55: [
			0,
			.64444,
			0,
			0,
			.575
		],
		56: [
			0,
			.64444,
			0,
			0,
			.575
		],
		57: [
			0,
			.64444,
			0,
			0,
			.575
		],
		58: [
			0,
			.44444,
			0,
			0,
			.31944
		],
		59: [
			.19444,
			.44444,
			0,
			0,
			.31944
		],
		60: [
			.08556,
			.58556,
			0,
			0,
			.89444
		],
		61: [
			-.10889,
			.39111,
			0,
			0,
			.89444
		],
		62: [
			.08556,
			.58556,
			0,
			0,
			.89444
		],
		63: [
			0,
			.69444,
			0,
			0,
			.54305
		],
		64: [
			0,
			.69444,
			0,
			0,
			.89444
		],
		65: [
			0,
			.68611,
			0,
			0,
			.86944
		],
		66: [
			0,
			.68611,
			0,
			0,
			.81805
		],
		67: [
			0,
			.68611,
			0,
			0,
			.83055
		],
		68: [
			0,
			.68611,
			0,
			0,
			.88194
		],
		69: [
			0,
			.68611,
			0,
			0,
			.75555
		],
		70: [
			0,
			.68611,
			0,
			0,
			.72361
		],
		71: [
			0,
			.68611,
			0,
			0,
			.90416
		],
		72: [
			0,
			.68611,
			0,
			0,
			.9
		],
		73: [
			0,
			.68611,
			0,
			0,
			.43611
		],
		74: [
			0,
			.68611,
			0,
			0,
			.59444
		],
		75: [
			0,
			.68611,
			0,
			0,
			.90138
		],
		76: [
			0,
			.68611,
			0,
			0,
			.69166
		],
		77: [
			0,
			.68611,
			0,
			0,
			1.09166
		],
		78: [
			0,
			.68611,
			0,
			0,
			.9
		],
		79: [
			0,
			.68611,
			0,
			0,
			.86388
		],
		80: [
			0,
			.68611,
			0,
			0,
			.78611
		],
		81: [
			.19444,
			.68611,
			0,
			0,
			.86388
		],
		82: [
			0,
			.68611,
			0,
			0,
			.8625
		],
		83: [
			0,
			.68611,
			0,
			0,
			.63889
		],
		84: [
			0,
			.68611,
			0,
			0,
			.8
		],
		85: [
			0,
			.68611,
			0,
			0,
			.88472
		],
		86: [
			0,
			.68611,
			.01597,
			0,
			.86944
		],
		87: [
			0,
			.68611,
			.01597,
			0,
			1.18888
		],
		88: [
			0,
			.68611,
			0,
			0,
			.86944
		],
		89: [
			0,
			.68611,
			.02875,
			0,
			.86944
		],
		90: [
			0,
			.68611,
			0,
			0,
			.70277
		],
		91: [
			.25,
			.75,
			0,
			0,
			.31944
		],
		92: [
			.25,
			.75,
			0,
			0,
			.575
		],
		93: [
			.25,
			.75,
			0,
			0,
			.31944
		],
		94: [
			0,
			.69444,
			0,
			0,
			.575
		],
		95: [
			.31,
			.13444,
			.03194,
			0,
			.575
		],
		97: [
			0,
			.44444,
			0,
			0,
			.55902
		],
		98: [
			0,
			.69444,
			0,
			0,
			.63889
		],
		99: [
			0,
			.44444,
			0,
			0,
			.51111
		],
		100: [
			0,
			.69444,
			0,
			0,
			.63889
		],
		101: [
			0,
			.44444,
			0,
			0,
			.52708
		],
		102: [
			0,
			.69444,
			.10903,
			0,
			.35139
		],
		103: [
			.19444,
			.44444,
			.01597,
			0,
			.575
		],
		104: [
			0,
			.69444,
			0,
			0,
			.63889
		],
		105: [
			0,
			.69444,
			0,
			0,
			.31944
		],
		106: [
			.19444,
			.69444,
			0,
			0,
			.35139
		],
		107: [
			0,
			.69444,
			0,
			0,
			.60694
		],
		108: [
			0,
			.69444,
			0,
			0,
			.31944
		],
		109: [
			0,
			.44444,
			0,
			0,
			.95833
		],
		110: [
			0,
			.44444,
			0,
			0,
			.63889
		],
		111: [
			0,
			.44444,
			0,
			0,
			.575
		],
		112: [
			.19444,
			.44444,
			0,
			0,
			.63889
		],
		113: [
			.19444,
			.44444,
			0,
			0,
			.60694
		],
		114: [
			0,
			.44444,
			0,
			0,
			.47361
		],
		115: [
			0,
			.44444,
			0,
			0,
			.45361
		],
		116: [
			0,
			.63492,
			0,
			0,
			.44722
		],
		117: [
			0,
			.44444,
			0,
			0,
			.63889
		],
		118: [
			0,
			.44444,
			.01597,
			0,
			.60694
		],
		119: [
			0,
			.44444,
			.01597,
			0,
			.83055
		],
		120: [
			0,
			.44444,
			0,
			0,
			.60694
		],
		121: [
			.19444,
			.44444,
			.01597,
			0,
			.60694
		],
		122: [
			0,
			.44444,
			0,
			0,
			.51111
		],
		123: [
			.25,
			.75,
			0,
			0,
			.575
		],
		124: [
			.25,
			.75,
			0,
			0,
			.31944
		],
		125: [
			.25,
			.75,
			0,
			0,
			.575
		],
		126: [
			.35,
			.34444,
			0,
			0,
			.575
		],
		160: [
			0,
			0,
			0,
			0,
			.25
		],
		163: [
			0,
			.69444,
			0,
			0,
			.86853
		],
		168: [
			0,
			.69444,
			0,
			0,
			.575
		],
		172: [
			0,
			.44444,
			0,
			0,
			.76666
		],
		176: [
			0,
			.69444,
			0,
			0,
			.86944
		],
		177: [
			.13333,
			.63333,
			0,
			0,
			.89444
		],
		184: [
			.17014,
			0,
			0,
			0,
			.51111
		],
		198: [
			0,
			.68611,
			0,
			0,
			1.04166
		],
		215: [
			.13333,
			.63333,
			0,
			0,
			.89444
		],
		216: [
			.04861,
			.73472,
			0,
			0,
			.89444
		],
		223: [
			0,
			.69444,
			0,
			0,
			.59722
		],
		230: [
			0,
			.44444,
			0,
			0,
			.83055
		],
		247: [
			.13333,
			.63333,
			0,
			0,
			.89444
		],
		248: [
			.09722,
			.54167,
			0,
			0,
			.575
		],
		305: [
			0,
			.44444,
			0,
			0,
			.31944
		],
		338: [
			0,
			.68611,
			0,
			0,
			1.16944
		],
		339: [
			0,
			.44444,
			0,
			0,
			.89444
		],
		567: [
			.19444,
			.44444,
			0,
			0,
			.35139
		],
		710: [
			0,
			.69444,
			0,
			0,
			.575
		],
		711: [
			0,
			.63194,
			0,
			0,
			.575
		],
		713: [
			0,
			.59611,
			0,
			0,
			.575
		],
		714: [
			0,
			.69444,
			0,
			0,
			.575
		],
		715: [
			0,
			.69444,
			0,
			0,
			.575
		],
		728: [
			0,
			.69444,
			0,
			0,
			.575
		],
		729: [
			0,
			.69444,
			0,
			0,
			.31944
		],
		730: [
			0,
			.69444,
			0,
			0,
			.86944
		],
		732: [
			0,
			.69444,
			0,
			0,
			.575
		],
		733: [
			0,
			.69444,
			0,
			0,
			.575
		],
		915: [
			0,
			.68611,
			0,
			0,
			.69166
		],
		916: [
			0,
			.68611,
			0,
			0,
			.95833
		],
		920: [
			0,
			.68611,
			0,
			0,
			.89444
		],
		923: [
			0,
			.68611,
			0,
			0,
			.80555
		],
		926: [
			0,
			.68611,
			0,
			0,
			.76666
		],
		928: [
			0,
			.68611,
			0,
			0,
			.9
		],
		931: [
			0,
			.68611,
			0,
			0,
			.83055
		],
		933: [
			0,
			.68611,
			0,
			0,
			.89444
		],
		934: [
			0,
			.68611,
			0,
			0,
			.83055
		],
		936: [
			0,
			.68611,
			0,
			0,
			.89444
		],
		937: [
			0,
			.68611,
			0,
			0,
			.83055
		],
		8211: [
			0,
			.44444,
			.03194,
			0,
			.575
		],
		8212: [
			0,
			.44444,
			.03194,
			0,
			1.14999
		],
		8216: [
			0,
			.69444,
			0,
			0,
			.31944
		],
		8217: [
			0,
			.69444,
			0,
			0,
			.31944
		],
		8220: [
			0,
			.69444,
			0,
			0,
			.60278
		],
		8221: [
			0,
			.69444,
			0,
			0,
			.60278
		],
		8224: [
			.19444,
			.69444,
			0,
			0,
			.51111
		],
		8225: [
			.19444,
			.69444,
			0,
			0,
			.51111
		],
		8242: [
			0,
			.55556,
			0,
			0,
			.34444
		],
		8407: [
			0,
			.72444,
			.15486,
			0,
			.575
		],
		8463: [
			0,
			.69444,
			0,
			0,
			.66759
		],
		8465: [
			0,
			.69444,
			0,
			0,
			.83055
		],
		8467: [
			0,
			.69444,
			0,
			0,
			.47361
		],
		8472: [
			.19444,
			.44444,
			0,
			0,
			.74027
		],
		8476: [
			0,
			.69444,
			0,
			0,
			.83055
		],
		8501: [
			0,
			.69444,
			0,
			0,
			.70277
		],
		8592: [
			-.10889,
			.39111,
			0,
			0,
			1.14999
		],
		8593: [
			.19444,
			.69444,
			0,
			0,
			.575
		],
		8594: [
			-.10889,
			.39111,
			0,
			0,
			1.14999
		],
		8595: [
			.19444,
			.69444,
			0,
			0,
			.575
		],
		8596: [
			-.10889,
			.39111,
			0,
			0,
			1.14999
		],
		8597: [
			.25,
			.75,
			0,
			0,
			.575
		],
		8598: [
			.19444,
			.69444,
			0,
			0,
			1.14999
		],
		8599: [
			.19444,
			.69444,
			0,
			0,
			1.14999
		],
		8600: [
			.19444,
			.69444,
			0,
			0,
			1.14999
		],
		8601: [
			.19444,
			.69444,
			0,
			0,
			1.14999
		],
		8636: [
			-.10889,
			.39111,
			0,
			0,
			1.14999
		],
		8637: [
			-.10889,
			.39111,
			0,
			0,
			1.14999
		],
		8640: [
			-.10889,
			.39111,
			0,
			0,
			1.14999
		],
		8641: [
			-.10889,
			.39111,
			0,
			0,
			1.14999
		],
		8656: [
			-.10889,
			.39111,
			0,
			0,
			1.14999
		],
		8657: [
			.19444,
			.69444,
			0,
			0,
			.70277
		],
		8658: [
			-.10889,
			.39111,
			0,
			0,
			1.14999
		],
		8659: [
			.19444,
			.69444,
			0,
			0,
			.70277
		],
		8660: [
			-.10889,
			.39111,
			0,
			0,
			1.14999
		],
		8661: [
			.25,
			.75,
			0,
			0,
			.70277
		],
		8704: [
			0,
			.69444,
			0,
			0,
			.63889
		],
		8706: [
			0,
			.69444,
			.06389,
			0,
			.62847
		],
		8707: [
			0,
			.69444,
			0,
			0,
			.63889
		],
		8709: [
			.05556,
			.75,
			0,
			0,
			.575
		],
		8711: [
			0,
			.68611,
			0,
			0,
			.95833
		],
		8712: [
			.08556,
			.58556,
			0,
			0,
			.76666
		],
		8715: [
			.08556,
			.58556,
			0,
			0,
			.76666
		],
		8722: [
			.13333,
			.63333,
			0,
			0,
			.89444
		],
		8723: [
			.13333,
			.63333,
			0,
			0,
			.89444
		],
		8725: [
			.25,
			.75,
			0,
			0,
			.575
		],
		8726: [
			.25,
			.75,
			0,
			0,
			.575
		],
		8727: [
			-.02778,
			.47222,
			0,
			0,
			.575
		],
		8728: [
			-.02639,
			.47361,
			0,
			0,
			.575
		],
		8729: [
			-.02639,
			.47361,
			0,
			0,
			.575
		],
		8730: [
			.18,
			.82,
			0,
			0,
			.95833
		],
		8733: [
			0,
			.44444,
			0,
			0,
			.89444
		],
		8734: [
			0,
			.44444,
			0,
			0,
			1.14999
		],
		8736: [
			0,
			.69224,
			0,
			0,
			.72222
		],
		8739: [
			.25,
			.75,
			0,
			0,
			.31944
		],
		8741: [
			.25,
			.75,
			0,
			0,
			.575
		],
		8743: [
			0,
			.55556,
			0,
			0,
			.76666
		],
		8744: [
			0,
			.55556,
			0,
			0,
			.76666
		],
		8745: [
			0,
			.55556,
			0,
			0,
			.76666
		],
		8746: [
			0,
			.55556,
			0,
			0,
			.76666
		],
		8747: [
			.19444,
			.69444,
			.12778,
			0,
			.56875
		],
		8764: [
			-.10889,
			.39111,
			0,
			0,
			.89444
		],
		8768: [
			.19444,
			.69444,
			0,
			0,
			.31944
		],
		8771: [
			.00222,
			.50222,
			0,
			0,
			.89444
		],
		8773: [
			.027,
			.638,
			0,
			0,
			.894
		],
		8776: [
			.02444,
			.52444,
			0,
			0,
			.89444
		],
		8781: [
			.00222,
			.50222,
			0,
			0,
			.89444
		],
		8801: [
			.00222,
			.50222,
			0,
			0,
			.89444
		],
		8804: [
			.19667,
			.69667,
			0,
			0,
			.89444
		],
		8805: [
			.19667,
			.69667,
			0,
			0,
			.89444
		],
		8810: [
			.08556,
			.58556,
			0,
			0,
			1.14999
		],
		8811: [
			.08556,
			.58556,
			0,
			0,
			1.14999
		],
		8826: [
			.08556,
			.58556,
			0,
			0,
			.89444
		],
		8827: [
			.08556,
			.58556,
			0,
			0,
			.89444
		],
		8834: [
			.08556,
			.58556,
			0,
			0,
			.89444
		],
		8835: [
			.08556,
			.58556,
			0,
			0,
			.89444
		],
		8838: [
			.19667,
			.69667,
			0,
			0,
			.89444
		],
		8839: [
			.19667,
			.69667,
			0,
			0,
			.89444
		],
		8846: [
			0,
			.55556,
			0,
			0,
			.76666
		],
		8849: [
			.19667,
			.69667,
			0,
			0,
			.89444
		],
		8850: [
			.19667,
			.69667,
			0,
			0,
			.89444
		],
		8851: [
			0,
			.55556,
			0,
			0,
			.76666
		],
		8852: [
			0,
			.55556,
			0,
			0,
			.76666
		],
		8853: [
			.13333,
			.63333,
			0,
			0,
			.89444
		],
		8854: [
			.13333,
			.63333,
			0,
			0,
			.89444
		],
		8855: [
			.13333,
			.63333,
			0,
			0,
			.89444
		],
		8856: [
			.13333,
			.63333,
			0,
			0,
			.89444
		],
		8857: [
			.13333,
			.63333,
			0,
			0,
			.89444
		],
		8866: [
			0,
			.69444,
			0,
			0,
			.70277
		],
		8867: [
			0,
			.69444,
			0,
			0,
			.70277
		],
		8868: [
			0,
			.69444,
			0,
			0,
			.89444
		],
		8869: [
			0,
			.69444,
			0,
			0,
			.89444
		],
		8900: [
			-.02639,
			.47361,
			0,
			0,
			.575
		],
		8901: [
			-.02639,
			.47361,
			0,
			0,
			.31944
		],
		8902: [
			-.02778,
			.47222,
			0,
			0,
			.575
		],
		8968: [
			.25,
			.75,
			0,
			0,
			.51111
		],
		8969: [
			.25,
			.75,
			0,
			0,
			.51111
		],
		8970: [
			.25,
			.75,
			0,
			0,
			.51111
		],
		8971: [
			.25,
			.75,
			0,
			0,
			.51111
		],
		8994: [
			-.13889,
			.36111,
			0,
			0,
			1.14999
		],
		8995: [
			-.13889,
			.36111,
			0,
			0,
			1.14999
		],
		9651: [
			.19444,
			.69444,
			0,
			0,
			1.02222
		],
		9657: [
			-.02778,
			.47222,
			0,
			0,
			.575
		],
		9661: [
			.19444,
			.69444,
			0,
			0,
			1.02222
		],
		9667: [
			-.02778,
			.47222,
			0,
			0,
			.575
		],
		9711: [
			.19444,
			.69444,
			0,
			0,
			1.14999
		],
		9824: [
			.12963,
			.69444,
			0,
			0,
			.89444
		],
		9825: [
			.12963,
			.69444,
			0,
			0,
			.89444
		],
		9826: [
			.12963,
			.69444,
			0,
			0,
			.89444
		],
		9827: [
			.12963,
			.69444,
			0,
			0,
			.89444
		],
		9837: [
			0,
			.75,
			0,
			0,
			.44722
		],
		9838: [
			.19444,
			.69444,
			0,
			0,
			.44722
		],
		9839: [
			.19444,
			.69444,
			0,
			0,
			.44722
		],
		10216: [
			.25,
			.75,
			0,
			0,
			.44722
		],
		10217: [
			.25,
			.75,
			0,
			0,
			.44722
		],
		10815: [
			0,
			.68611,
			0,
			0,
			.9
		],
		10927: [
			.19667,
			.69667,
			0,
			0,
			.89444
		],
		10928: [
			.19667,
			.69667,
			0,
			0,
			.89444
		],
		57376: [
			.19444,
			.69444,
			0,
			0,
			0
		]
	},
	"Main-BoldItalic": {
		32: [
			0,
			0,
			0,
			0,
			.25
		],
		33: [
			0,
			.69444,
			.11417,
			0,
			.38611
		],
		34: [
			0,
			.69444,
			.07939,
			0,
			.62055
		],
		35: [
			.19444,
			.69444,
			.06833,
			0,
			.94444
		],
		37: [
			.05556,
			.75,
			.12861,
			0,
			.94444
		],
		38: [
			0,
			.69444,
			.08528,
			0,
			.88555
		],
		39: [
			0,
			.69444,
			.12945,
			0,
			.35555
		],
		40: [
			.25,
			.75,
			.15806,
			0,
			.47333
		],
		41: [
			.25,
			.75,
			.03306,
			0,
			.47333
		],
		42: [
			0,
			.75,
			.14333,
			0,
			.59111
		],
		43: [
			.10333,
			.60333,
			.03306,
			0,
			.88555
		],
		44: [
			.19444,
			.14722,
			0,
			0,
			.35555
		],
		45: [
			0,
			.44444,
			.02611,
			0,
			.41444
		],
		46: [
			0,
			.14722,
			0,
			0,
			.35555
		],
		47: [
			.25,
			.75,
			.15806,
			0,
			.59111
		],
		48: [
			0,
			.64444,
			.13167,
			0,
			.59111
		],
		49: [
			0,
			.64444,
			.13167,
			0,
			.59111
		],
		50: [
			0,
			.64444,
			.13167,
			0,
			.59111
		],
		51: [
			0,
			.64444,
			.13167,
			0,
			.59111
		],
		52: [
			.19444,
			.64444,
			.13167,
			0,
			.59111
		],
		53: [
			0,
			.64444,
			.13167,
			0,
			.59111
		],
		54: [
			0,
			.64444,
			.13167,
			0,
			.59111
		],
		55: [
			.19444,
			.64444,
			.13167,
			0,
			.59111
		],
		56: [
			0,
			.64444,
			.13167,
			0,
			.59111
		],
		57: [
			0,
			.64444,
			.13167,
			0,
			.59111
		],
		58: [
			0,
			.44444,
			.06695,
			0,
			.35555
		],
		59: [
			.19444,
			.44444,
			.06695,
			0,
			.35555
		],
		61: [
			-.10889,
			.39111,
			.06833,
			0,
			.88555
		],
		63: [
			0,
			.69444,
			.11472,
			0,
			.59111
		],
		64: [
			0,
			.69444,
			.09208,
			0,
			.88555
		],
		65: [
			0,
			.68611,
			0,
			0,
			.86555
		],
		66: [
			0,
			.68611,
			.0992,
			0,
			.81666
		],
		67: [
			0,
			.68611,
			.14208,
			0,
			.82666
		],
		68: [
			0,
			.68611,
			.09062,
			0,
			.87555
		],
		69: [
			0,
			.68611,
			.11431,
			0,
			.75666
		],
		70: [
			0,
			.68611,
			.12903,
			0,
			.72722
		],
		71: [
			0,
			.68611,
			.07347,
			0,
			.89527
		],
		72: [
			0,
			.68611,
			.17208,
			0,
			.8961
		],
		73: [
			0,
			.68611,
			.15681,
			0,
			.47166
		],
		74: [
			0,
			.68611,
			.145,
			0,
			.61055
		],
		75: [
			0,
			.68611,
			.14208,
			0,
			.89499
		],
		76: [
			0,
			.68611,
			0,
			0,
			.69777
		],
		77: [
			0,
			.68611,
			.17208,
			0,
			1.07277
		],
		78: [
			0,
			.68611,
			.17208,
			0,
			.8961
		],
		79: [
			0,
			.68611,
			.09062,
			0,
			.85499
		],
		80: [
			0,
			.68611,
			.0992,
			0,
			.78721
		],
		81: [
			.19444,
			.68611,
			.09062,
			0,
			.85499
		],
		82: [
			0,
			.68611,
			.02559,
			0,
			.85944
		],
		83: [
			0,
			.68611,
			.11264,
			0,
			.64999
		],
		84: [
			0,
			.68611,
			.12903,
			0,
			.7961
		],
		85: [
			0,
			.68611,
			.17208,
			0,
			.88083
		],
		86: [
			0,
			.68611,
			.18625,
			0,
			.86555
		],
		87: [
			0,
			.68611,
			.18625,
			0,
			1.15999
		],
		88: [
			0,
			.68611,
			.15681,
			0,
			.86555
		],
		89: [
			0,
			.68611,
			.19803,
			0,
			.86555
		],
		90: [
			0,
			.68611,
			.14208,
			0,
			.70888
		],
		91: [
			.25,
			.75,
			.1875,
			0,
			.35611
		],
		93: [
			.25,
			.75,
			.09972,
			0,
			.35611
		],
		94: [
			0,
			.69444,
			.06709,
			0,
			.59111
		],
		95: [
			.31,
			.13444,
			.09811,
			0,
			.59111
		],
		97: [
			0,
			.44444,
			.09426,
			0,
			.59111
		],
		98: [
			0,
			.69444,
			.07861,
			0,
			.53222
		],
		99: [
			0,
			.44444,
			.05222,
			0,
			.53222
		],
		100: [
			0,
			.69444,
			.10861,
			0,
			.59111
		],
		101: [
			0,
			.44444,
			.085,
			0,
			.53222
		],
		102: [
			.19444,
			.69444,
			.21778,
			0,
			.4
		],
		103: [
			.19444,
			.44444,
			.105,
			0,
			.53222
		],
		104: [
			0,
			.69444,
			.09426,
			0,
			.59111
		],
		105: [
			0,
			.69326,
			.11387,
			0,
			.35555
		],
		106: [
			.19444,
			.69326,
			.1672,
			0,
			.35555
		],
		107: [
			0,
			.69444,
			.11111,
			0,
			.53222
		],
		108: [
			0,
			.69444,
			.10861,
			0,
			.29666
		],
		109: [
			0,
			.44444,
			.09426,
			0,
			.94444
		],
		110: [
			0,
			.44444,
			.09426,
			0,
			.64999
		],
		111: [
			0,
			.44444,
			.07861,
			0,
			.59111
		],
		112: [
			.19444,
			.44444,
			.07861,
			0,
			.59111
		],
		113: [
			.19444,
			.44444,
			.105,
			0,
			.53222
		],
		114: [
			0,
			.44444,
			.11111,
			0,
			.50167
		],
		115: [
			0,
			.44444,
			.08167,
			0,
			.48694
		],
		116: [
			0,
			.63492,
			.09639,
			0,
			.385
		],
		117: [
			0,
			.44444,
			.09426,
			0,
			.62055
		],
		118: [
			0,
			.44444,
			.11111,
			0,
			.53222
		],
		119: [
			0,
			.44444,
			.11111,
			0,
			.76777
		],
		120: [
			0,
			.44444,
			.12583,
			0,
			.56055
		],
		121: [
			.19444,
			.44444,
			.105,
			0,
			.56166
		],
		122: [
			0,
			.44444,
			.13889,
			0,
			.49055
		],
		126: [
			.35,
			.34444,
			.11472,
			0,
			.59111
		],
		160: [
			0,
			0,
			0,
			0,
			.25
		],
		168: [
			0,
			.69444,
			.11473,
			0,
			.59111
		],
		176: [
			0,
			.69444,
			0,
			0,
			.94888
		],
		184: [
			.17014,
			0,
			0,
			0,
			.53222
		],
		198: [
			0,
			.68611,
			.11431,
			0,
			1.02277
		],
		216: [
			.04861,
			.73472,
			.09062,
			0,
			.88555
		],
		223: [
			.19444,
			.69444,
			.09736,
			0,
			.665
		],
		230: [
			0,
			.44444,
			.085,
			0,
			.82666
		],
		248: [
			.09722,
			.54167,
			.09458,
			0,
			.59111
		],
		305: [
			0,
			.44444,
			.09426,
			0,
			.35555
		],
		338: [
			0,
			.68611,
			.11431,
			0,
			1.14054
		],
		339: [
			0,
			.44444,
			.085,
			0,
			.82666
		],
		567: [
			.19444,
			.44444,
			.04611,
			0,
			.385
		],
		710: [
			0,
			.69444,
			.06709,
			0,
			.59111
		],
		711: [
			0,
			.63194,
			.08271,
			0,
			.59111
		],
		713: [
			0,
			.59444,
			.10444,
			0,
			.59111
		],
		714: [
			0,
			.69444,
			.08528,
			0,
			.59111
		],
		715: [
			0,
			.69444,
			0,
			0,
			.59111
		],
		728: [
			0,
			.69444,
			.10333,
			0,
			.59111
		],
		729: [
			0,
			.69444,
			.12945,
			0,
			.35555
		],
		730: [
			0,
			.69444,
			0,
			0,
			.94888
		],
		732: [
			0,
			.69444,
			.11472,
			0,
			.59111
		],
		733: [
			0,
			.69444,
			.11472,
			0,
			.59111
		],
		915: [
			0,
			.68611,
			.12903,
			0,
			.69777
		],
		916: [
			0,
			.68611,
			0,
			0,
			.94444
		],
		920: [
			0,
			.68611,
			.09062,
			0,
			.88555
		],
		923: [
			0,
			.68611,
			0,
			0,
			.80666
		],
		926: [
			0,
			.68611,
			.15092,
			0,
			.76777
		],
		928: [
			0,
			.68611,
			.17208,
			0,
			.8961
		],
		931: [
			0,
			.68611,
			.11431,
			0,
			.82666
		],
		933: [
			0,
			.68611,
			.10778,
			0,
			.88555
		],
		934: [
			0,
			.68611,
			.05632,
			0,
			.82666
		],
		936: [
			0,
			.68611,
			.10778,
			0,
			.88555
		],
		937: [
			0,
			.68611,
			.0992,
			0,
			.82666
		],
		8211: [
			0,
			.44444,
			.09811,
			0,
			.59111
		],
		8212: [
			0,
			.44444,
			.09811,
			0,
			1.18221
		],
		8216: [
			0,
			.69444,
			.12945,
			0,
			.35555
		],
		8217: [
			0,
			.69444,
			.12945,
			0,
			.35555
		],
		8220: [
			0,
			.69444,
			.16772,
			0,
			.62055
		],
		8221: [
			0,
			.69444,
			.07939,
			0,
			.62055
		]
	},
	"Main-Italic": {
		32: [
			0,
			0,
			0,
			0,
			.25
		],
		33: [
			0,
			.69444,
			.12417,
			0,
			.30667
		],
		34: [
			0,
			.69444,
			.06961,
			0,
			.51444
		],
		35: [
			.19444,
			.69444,
			.06616,
			0,
			.81777
		],
		37: [
			.05556,
			.75,
			.13639,
			0,
			.81777
		],
		38: [
			0,
			.69444,
			.09694,
			0,
			.76666
		],
		39: [
			0,
			.69444,
			.12417,
			0,
			.30667
		],
		40: [
			.25,
			.75,
			.16194,
			0,
			.40889
		],
		41: [
			.25,
			.75,
			.03694,
			0,
			.40889
		],
		42: [
			0,
			.75,
			.14917,
			0,
			.51111
		],
		43: [
			.05667,
			.56167,
			.03694,
			0,
			.76666
		],
		44: [
			.19444,
			.10556,
			0,
			0,
			.30667
		],
		45: [
			0,
			.43056,
			.02826,
			0,
			.35778
		],
		46: [
			0,
			.10556,
			0,
			0,
			.30667
		],
		47: [
			.25,
			.75,
			.16194,
			0,
			.51111
		],
		48: [
			0,
			.64444,
			.13556,
			0,
			.51111
		],
		49: [
			0,
			.64444,
			.13556,
			0,
			.51111
		],
		50: [
			0,
			.64444,
			.13556,
			0,
			.51111
		],
		51: [
			0,
			.64444,
			.13556,
			0,
			.51111
		],
		52: [
			.19444,
			.64444,
			.13556,
			0,
			.51111
		],
		53: [
			0,
			.64444,
			.13556,
			0,
			.51111
		],
		54: [
			0,
			.64444,
			.13556,
			0,
			.51111
		],
		55: [
			.19444,
			.64444,
			.13556,
			0,
			.51111
		],
		56: [
			0,
			.64444,
			.13556,
			0,
			.51111
		],
		57: [
			0,
			.64444,
			.13556,
			0,
			.51111
		],
		58: [
			0,
			.43056,
			.0582,
			0,
			.30667
		],
		59: [
			.19444,
			.43056,
			.0582,
			0,
			.30667
		],
		61: [
			-.13313,
			.36687,
			.06616,
			0,
			.76666
		],
		63: [
			0,
			.69444,
			.1225,
			0,
			.51111
		],
		64: [
			0,
			.69444,
			.09597,
			0,
			.76666
		],
		65: [
			0,
			.68333,
			0,
			0,
			.74333
		],
		66: [
			0,
			.68333,
			.10257,
			0,
			.70389
		],
		67: [
			0,
			.68333,
			.14528,
			0,
			.71555
		],
		68: [
			0,
			.68333,
			.09403,
			0,
			.755
		],
		69: [
			0,
			.68333,
			.12028,
			0,
			.67833
		],
		70: [
			0,
			.68333,
			.13305,
			0,
			.65277
		],
		71: [
			0,
			.68333,
			.08722,
			0,
			.77361
		],
		72: [
			0,
			.68333,
			.16389,
			0,
			.74333
		],
		73: [
			0,
			.68333,
			.15806,
			0,
			.38555
		],
		74: [
			0,
			.68333,
			.14028,
			0,
			.525
		],
		75: [
			0,
			.68333,
			.14528,
			0,
			.76888
		],
		76: [
			0,
			.68333,
			0,
			0,
			.62722
		],
		77: [
			0,
			.68333,
			.16389,
			0,
			.89666
		],
		78: [
			0,
			.68333,
			.16389,
			0,
			.74333
		],
		79: [
			0,
			.68333,
			.09403,
			0,
			.76666
		],
		80: [
			0,
			.68333,
			.10257,
			0,
			.67833
		],
		81: [
			.19444,
			.68333,
			.09403,
			0,
			.76666
		],
		82: [
			0,
			.68333,
			.03868,
			0,
			.72944
		],
		83: [
			0,
			.68333,
			.11972,
			0,
			.56222
		],
		84: [
			0,
			.68333,
			.13305,
			0,
			.71555
		],
		85: [
			0,
			.68333,
			.16389,
			0,
			.74333
		],
		86: [
			0,
			.68333,
			.18361,
			0,
			.74333
		],
		87: [
			0,
			.68333,
			.18361,
			0,
			.99888
		],
		88: [
			0,
			.68333,
			.15806,
			0,
			.74333
		],
		89: [
			0,
			.68333,
			.19383,
			0,
			.74333
		],
		90: [
			0,
			.68333,
			.14528,
			0,
			.61333
		],
		91: [
			.25,
			.75,
			.1875,
			0,
			.30667
		],
		93: [
			.25,
			.75,
			.10528,
			0,
			.30667
		],
		94: [
			0,
			.69444,
			.06646,
			0,
			.51111
		],
		95: [
			.31,
			.12056,
			.09208,
			0,
			.51111
		],
		97: [
			0,
			.43056,
			.07671,
			0,
			.51111
		],
		98: [
			0,
			.69444,
			.06312,
			0,
			.46
		],
		99: [
			0,
			.43056,
			.05653,
			0,
			.46
		],
		100: [
			0,
			.69444,
			.10333,
			0,
			.51111
		],
		101: [
			0,
			.43056,
			.07514,
			0,
			.46
		],
		102: [
			.19444,
			.69444,
			.21194,
			0,
			.30667
		],
		103: [
			.19444,
			.43056,
			.08847,
			0,
			.46
		],
		104: [
			0,
			.69444,
			.07671,
			0,
			.51111
		],
		105: [
			0,
			.65536,
			.1019,
			0,
			.30667
		],
		106: [
			.19444,
			.65536,
			.14467,
			0,
			.30667
		],
		107: [
			0,
			.69444,
			.10764,
			0,
			.46
		],
		108: [
			0,
			.69444,
			.10333,
			0,
			.25555
		],
		109: [
			0,
			.43056,
			.07671,
			0,
			.81777
		],
		110: [
			0,
			.43056,
			.07671,
			0,
			.56222
		],
		111: [
			0,
			.43056,
			.06312,
			0,
			.51111
		],
		112: [
			.19444,
			.43056,
			.06312,
			0,
			.51111
		],
		113: [
			.19444,
			.43056,
			.08847,
			0,
			.46
		],
		114: [
			0,
			.43056,
			.10764,
			0,
			.42166
		],
		115: [
			0,
			.43056,
			.08208,
			0,
			.40889
		],
		116: [
			0,
			.61508,
			.09486,
			0,
			.33222
		],
		117: [
			0,
			.43056,
			.07671,
			0,
			.53666
		],
		118: [
			0,
			.43056,
			.10764,
			0,
			.46
		],
		119: [
			0,
			.43056,
			.10764,
			0,
			.66444
		],
		120: [
			0,
			.43056,
			.12042,
			0,
			.46389
		],
		121: [
			.19444,
			.43056,
			.08847,
			0,
			.48555
		],
		122: [
			0,
			.43056,
			.12292,
			0,
			.40889
		],
		126: [
			.35,
			.31786,
			.11585,
			0,
			.51111
		],
		160: [
			0,
			0,
			0,
			0,
			.25
		],
		168: [
			0,
			.66786,
			.10474,
			0,
			.51111
		],
		176: [
			0,
			.69444,
			0,
			0,
			.83129
		],
		184: [
			.17014,
			0,
			0,
			0,
			.46
		],
		198: [
			0,
			.68333,
			.12028,
			0,
			.88277
		],
		216: [
			.04861,
			.73194,
			.09403,
			0,
			.76666
		],
		223: [
			.19444,
			.69444,
			.10514,
			0,
			.53666
		],
		230: [
			0,
			.43056,
			.07514,
			0,
			.71555
		],
		248: [
			.09722,
			.52778,
			.09194,
			0,
			.51111
		],
		338: [
			0,
			.68333,
			.12028,
			0,
			.98499
		],
		339: [
			0,
			.43056,
			.07514,
			0,
			.71555
		],
		710: [
			0,
			.69444,
			.06646,
			0,
			.51111
		],
		711: [
			0,
			.62847,
			.08295,
			0,
			.51111
		],
		713: [
			0,
			.56167,
			.10333,
			0,
			.51111
		],
		714: [
			0,
			.69444,
			.09694,
			0,
			.51111
		],
		715: [
			0,
			.69444,
			0,
			0,
			.51111
		],
		728: [
			0,
			.69444,
			.10806,
			0,
			.51111
		],
		729: [
			0,
			.66786,
			.11752,
			0,
			.30667
		],
		730: [
			0,
			.69444,
			0,
			0,
			.83129
		],
		732: [
			0,
			.66786,
			.11585,
			0,
			.51111
		],
		733: [
			0,
			.69444,
			.1225,
			0,
			.51111
		],
		915: [
			0,
			.68333,
			.13305,
			0,
			.62722
		],
		916: [
			0,
			.68333,
			0,
			0,
			.81777
		],
		920: [
			0,
			.68333,
			.09403,
			0,
			.76666
		],
		923: [
			0,
			.68333,
			0,
			0,
			.69222
		],
		926: [
			0,
			.68333,
			.15294,
			0,
			.66444
		],
		928: [
			0,
			.68333,
			.16389,
			0,
			.74333
		],
		931: [
			0,
			.68333,
			.12028,
			0,
			.71555
		],
		933: [
			0,
			.68333,
			.11111,
			0,
			.76666
		],
		934: [
			0,
			.68333,
			.05986,
			0,
			.71555
		],
		936: [
			0,
			.68333,
			.11111,
			0,
			.76666
		],
		937: [
			0,
			.68333,
			.10257,
			0,
			.71555
		],
		8211: [
			0,
			.43056,
			.09208,
			0,
			.51111
		],
		8212: [
			0,
			.43056,
			.09208,
			0,
			1.02222
		],
		8216: [
			0,
			.69444,
			.12417,
			0,
			.30667
		],
		8217: [
			0,
			.69444,
			.12417,
			0,
			.30667
		],
		8220: [
			0,
			.69444,
			.1685,
			0,
			.51444
		],
		8221: [
			0,
			.69444,
			.06961,
			0,
			.51444
		],
		8463: [
			0,
			.68889,
			0,
			0,
			.54028
		]
	},
	"Main-Regular": {
		32: [
			0,
			0,
			0,
			0,
			.25
		],
		33: [
			0,
			.69444,
			0,
			0,
			.27778
		],
		34: [
			0,
			.69444,
			0,
			0,
			.5
		],
		35: [
			.19444,
			.69444,
			0,
			0,
			.83334
		],
		36: [
			.05556,
			.75,
			0,
			0,
			.5
		],
		37: [
			.05556,
			.75,
			0,
			0,
			.83334
		],
		38: [
			0,
			.69444,
			0,
			0,
			.77778
		],
		39: [
			0,
			.69444,
			0,
			0,
			.27778
		],
		40: [
			.25,
			.75,
			0,
			0,
			.38889
		],
		41: [
			.25,
			.75,
			0,
			0,
			.38889
		],
		42: [
			0,
			.75,
			0,
			0,
			.5
		],
		43: [
			.08333,
			.58333,
			0,
			0,
			.77778
		],
		44: [
			.19444,
			.10556,
			0,
			0,
			.27778
		],
		45: [
			0,
			.43056,
			0,
			0,
			.33333
		],
		46: [
			0,
			.10556,
			0,
			0,
			.27778
		],
		47: [
			.25,
			.75,
			0,
			0,
			.5
		],
		48: [
			0,
			.64444,
			0,
			0,
			.5
		],
		49: [
			0,
			.64444,
			0,
			0,
			.5
		],
		50: [
			0,
			.64444,
			0,
			0,
			.5
		],
		51: [
			0,
			.64444,
			0,
			0,
			.5
		],
		52: [
			0,
			.64444,
			0,
			0,
			.5
		],
		53: [
			0,
			.64444,
			0,
			0,
			.5
		],
		54: [
			0,
			.64444,
			0,
			0,
			.5
		],
		55: [
			0,
			.64444,
			0,
			0,
			.5
		],
		56: [
			0,
			.64444,
			0,
			0,
			.5
		],
		57: [
			0,
			.64444,
			0,
			0,
			.5
		],
		58: [
			0,
			.43056,
			0,
			0,
			.27778
		],
		59: [
			.19444,
			.43056,
			0,
			0,
			.27778
		],
		60: [
			.0391,
			.5391,
			0,
			0,
			.77778
		],
		61: [
			-.13313,
			.36687,
			0,
			0,
			.77778
		],
		62: [
			.0391,
			.5391,
			0,
			0,
			.77778
		],
		63: [
			0,
			.69444,
			0,
			0,
			.47222
		],
		64: [
			0,
			.69444,
			0,
			0,
			.77778
		],
		65: [
			0,
			.68333,
			0,
			0,
			.75
		],
		66: [
			0,
			.68333,
			0,
			0,
			.70834
		],
		67: [
			0,
			.68333,
			0,
			0,
			.72222
		],
		68: [
			0,
			.68333,
			0,
			0,
			.76389
		],
		69: [
			0,
			.68333,
			0,
			0,
			.68056
		],
		70: [
			0,
			.68333,
			0,
			0,
			.65278
		],
		71: [
			0,
			.68333,
			0,
			0,
			.78472
		],
		72: [
			0,
			.68333,
			0,
			0,
			.75
		],
		73: [
			0,
			.68333,
			0,
			0,
			.36111
		],
		74: [
			0,
			.68333,
			0,
			0,
			.51389
		],
		75: [
			0,
			.68333,
			0,
			0,
			.77778
		],
		76: [
			0,
			.68333,
			0,
			0,
			.625
		],
		77: [
			0,
			.68333,
			0,
			0,
			.91667
		],
		78: [
			0,
			.68333,
			0,
			0,
			.75
		],
		79: [
			0,
			.68333,
			0,
			0,
			.77778
		],
		80: [
			0,
			.68333,
			0,
			0,
			.68056
		],
		81: [
			.19444,
			.68333,
			0,
			0,
			.77778
		],
		82: [
			0,
			.68333,
			0,
			0,
			.73611
		],
		83: [
			0,
			.68333,
			0,
			0,
			.55556
		],
		84: [
			0,
			.68333,
			0,
			0,
			.72222
		],
		85: [
			0,
			.68333,
			0,
			0,
			.75
		],
		86: [
			0,
			.68333,
			.01389,
			0,
			.75
		],
		87: [
			0,
			.68333,
			.01389,
			0,
			1.02778
		],
		88: [
			0,
			.68333,
			0,
			0,
			.75
		],
		89: [
			0,
			.68333,
			.025,
			0,
			.75
		],
		90: [
			0,
			.68333,
			0,
			0,
			.61111
		],
		91: [
			.25,
			.75,
			0,
			0,
			.27778
		],
		92: [
			.25,
			.75,
			0,
			0,
			.5
		],
		93: [
			.25,
			.75,
			0,
			0,
			.27778
		],
		94: [
			0,
			.69444,
			0,
			0,
			.5
		],
		95: [
			.31,
			.12056,
			.02778,
			0,
			.5
		],
		97: [
			0,
			.43056,
			0,
			0,
			.5
		],
		98: [
			0,
			.69444,
			0,
			0,
			.55556
		],
		99: [
			0,
			.43056,
			0,
			0,
			.44445
		],
		100: [
			0,
			.69444,
			0,
			0,
			.55556
		],
		101: [
			0,
			.43056,
			0,
			0,
			.44445
		],
		102: [
			0,
			.69444,
			.07778,
			0,
			.30556
		],
		103: [
			.19444,
			.43056,
			.01389,
			0,
			.5
		],
		104: [
			0,
			.69444,
			0,
			0,
			.55556
		],
		105: [
			0,
			.66786,
			0,
			0,
			.27778
		],
		106: [
			.19444,
			.66786,
			0,
			0,
			.30556
		],
		107: [
			0,
			.69444,
			0,
			0,
			.52778
		],
		108: [
			0,
			.69444,
			0,
			0,
			.27778
		],
		109: [
			0,
			.43056,
			0,
			0,
			.83334
		],
		110: [
			0,
			.43056,
			0,
			0,
			.55556
		],
		111: [
			0,
			.43056,
			0,
			0,
			.5
		],
		112: [
			.19444,
			.43056,
			0,
			0,
			.55556
		],
		113: [
			.19444,
			.43056,
			0,
			0,
			.52778
		],
		114: [
			0,
			.43056,
			0,
			0,
			.39167
		],
		115: [
			0,
			.43056,
			0,
			0,
			.39445
		],
		116: [
			0,
			.61508,
			0,
			0,
			.38889
		],
		117: [
			0,
			.43056,
			0,
			0,
			.55556
		],
		118: [
			0,
			.43056,
			.01389,
			0,
			.52778
		],
		119: [
			0,
			.43056,
			.01389,
			0,
			.72222
		],
		120: [
			0,
			.43056,
			0,
			0,
			.52778
		],
		121: [
			.19444,
			.43056,
			.01389,
			0,
			.52778
		],
		122: [
			0,
			.43056,
			0,
			0,
			.44445
		],
		123: [
			.25,
			.75,
			0,
			0,
			.5
		],
		124: [
			.25,
			.75,
			0,
			0,
			.27778
		],
		125: [
			.25,
			.75,
			0,
			0,
			.5
		],
		126: [
			.35,
			.31786,
			0,
			0,
			.5
		],
		160: [
			0,
			0,
			0,
			0,
			.25
		],
		163: [
			0,
			.69444,
			0,
			0,
			.76909
		],
		167: [
			.19444,
			.69444,
			0,
			0,
			.44445
		],
		168: [
			0,
			.66786,
			0,
			0,
			.5
		],
		172: [
			0,
			.43056,
			0,
			0,
			.66667
		],
		176: [
			0,
			.69444,
			0,
			0,
			.75
		],
		177: [
			.08333,
			.58333,
			0,
			0,
			.77778
		],
		182: [
			.19444,
			.69444,
			0,
			0,
			.61111
		],
		184: [
			.17014,
			0,
			0,
			0,
			.44445
		],
		198: [
			0,
			.68333,
			0,
			0,
			.90278
		],
		215: [
			.08333,
			.58333,
			0,
			0,
			.77778
		],
		216: [
			.04861,
			.73194,
			0,
			0,
			.77778
		],
		223: [
			0,
			.69444,
			0,
			0,
			.5
		],
		230: [
			0,
			.43056,
			0,
			0,
			.72222
		],
		247: [
			.08333,
			.58333,
			0,
			0,
			.77778
		],
		248: [
			.09722,
			.52778,
			0,
			0,
			.5
		],
		305: [
			0,
			.43056,
			0,
			0,
			.27778
		],
		338: [
			0,
			.68333,
			0,
			0,
			1.01389
		],
		339: [
			0,
			.43056,
			0,
			0,
			.77778
		],
		567: [
			.19444,
			.43056,
			0,
			0,
			.30556
		],
		710: [
			0,
			.69444,
			0,
			0,
			.5
		],
		711: [
			0,
			.62847,
			0,
			0,
			.5
		],
		713: [
			0,
			.56778,
			0,
			0,
			.5
		],
		714: [
			0,
			.69444,
			0,
			0,
			.5
		],
		715: [
			0,
			.69444,
			0,
			0,
			.5
		],
		728: [
			0,
			.69444,
			0,
			0,
			.5
		],
		729: [
			0,
			.66786,
			0,
			0,
			.27778
		],
		730: [
			0,
			.69444,
			0,
			0,
			.75
		],
		732: [
			0,
			.66786,
			0,
			0,
			.5
		],
		733: [
			0,
			.69444,
			0,
			0,
			.5
		],
		915: [
			0,
			.68333,
			0,
			0,
			.625
		],
		916: [
			0,
			.68333,
			0,
			0,
			.83334
		],
		920: [
			0,
			.68333,
			0,
			0,
			.77778
		],
		923: [
			0,
			.68333,
			0,
			0,
			.69445
		],
		926: [
			0,
			.68333,
			0,
			0,
			.66667
		],
		928: [
			0,
			.68333,
			0,
			0,
			.75
		],
		931: [
			0,
			.68333,
			0,
			0,
			.72222
		],
		933: [
			0,
			.68333,
			0,
			0,
			.77778
		],
		934: [
			0,
			.68333,
			0,
			0,
			.72222
		],
		936: [
			0,
			.68333,
			0,
			0,
			.77778
		],
		937: [
			0,
			.68333,
			0,
			0,
			.72222
		],
		8211: [
			0,
			.43056,
			.02778,
			0,
			.5
		],
		8212: [
			0,
			.43056,
			.02778,
			0,
			1
		],
		8216: [
			0,
			.69444,
			0,
			0,
			.27778
		],
		8217: [
			0,
			.69444,
			0,
			0,
			.27778
		],
		8220: [
			0,
			.69444,
			0,
			0,
			.5
		],
		8221: [
			0,
			.69444,
			0,
			0,
			.5
		],
		8224: [
			.19444,
			.69444,
			0,
			0,
			.44445
		],
		8225: [
			.19444,
			.69444,
			0,
			0,
			.44445
		],
		8230: [
			0,
			.123,
			0,
			0,
			1.172
		],
		8242: [
			0,
			.55556,
			0,
			0,
			.275
		],
		8407: [
			0,
			.71444,
			.15382,
			0,
			.5
		],
		8463: [
			0,
			.68889,
			0,
			0,
			.54028
		],
		8465: [
			0,
			.69444,
			0,
			0,
			.72222
		],
		8467: [
			0,
			.69444,
			0,
			.11111,
			.41667
		],
		8472: [
			.19444,
			.43056,
			0,
			.11111,
			.63646
		],
		8476: [
			0,
			.69444,
			0,
			0,
			.72222
		],
		8501: [
			0,
			.69444,
			0,
			0,
			.61111
		],
		8592: [
			-.13313,
			.36687,
			0,
			0,
			1
		],
		8593: [
			.19444,
			.69444,
			0,
			0,
			.5
		],
		8594: [
			-.13313,
			.36687,
			0,
			0,
			1
		],
		8595: [
			.19444,
			.69444,
			0,
			0,
			.5
		],
		8596: [
			-.13313,
			.36687,
			0,
			0,
			1
		],
		8597: [
			.25,
			.75,
			0,
			0,
			.5
		],
		8598: [
			.19444,
			.69444,
			0,
			0,
			1
		],
		8599: [
			.19444,
			.69444,
			0,
			0,
			1
		],
		8600: [
			.19444,
			.69444,
			0,
			0,
			1
		],
		8601: [
			.19444,
			.69444,
			0,
			0,
			1
		],
		8614: [
			.011,
			.511,
			0,
			0,
			1
		],
		8617: [
			.011,
			.511,
			0,
			0,
			1.126
		],
		8618: [
			.011,
			.511,
			0,
			0,
			1.126
		],
		8636: [
			-.13313,
			.36687,
			0,
			0,
			1
		],
		8637: [
			-.13313,
			.36687,
			0,
			0,
			1
		],
		8640: [
			-.13313,
			.36687,
			0,
			0,
			1
		],
		8641: [
			-.13313,
			.36687,
			0,
			0,
			1
		],
		8652: [
			.011,
			.671,
			0,
			0,
			1
		],
		8656: [
			-.13313,
			.36687,
			0,
			0,
			1
		],
		8657: [
			.19444,
			.69444,
			0,
			0,
			.61111
		],
		8658: [
			-.13313,
			.36687,
			0,
			0,
			1
		],
		8659: [
			.19444,
			.69444,
			0,
			0,
			.61111
		],
		8660: [
			-.13313,
			.36687,
			0,
			0,
			1
		],
		8661: [
			.25,
			.75,
			0,
			0,
			.61111
		],
		8704: [
			0,
			.69444,
			0,
			0,
			.55556
		],
		8706: [
			0,
			.69444,
			.05556,
			.08334,
			.5309
		],
		8707: [
			0,
			.69444,
			0,
			0,
			.55556
		],
		8709: [
			.05556,
			.75,
			0,
			0,
			.5
		],
		8711: [
			0,
			.68333,
			0,
			0,
			.83334
		],
		8712: [
			.0391,
			.5391,
			0,
			0,
			.66667
		],
		8715: [
			.0391,
			.5391,
			0,
			0,
			.66667
		],
		8722: [
			.08333,
			.58333,
			0,
			0,
			.77778
		],
		8723: [
			.08333,
			.58333,
			0,
			0,
			.77778
		],
		8725: [
			.25,
			.75,
			0,
			0,
			.5
		],
		8726: [
			.25,
			.75,
			0,
			0,
			.5
		],
		8727: [
			-.03472,
			.46528,
			0,
			0,
			.5
		],
		8728: [
			-.05555,
			.44445,
			0,
			0,
			.5
		],
		8729: [
			-.05555,
			.44445,
			0,
			0,
			.5
		],
		8730: [
			.2,
			.8,
			0,
			0,
			.83334
		],
		8733: [
			0,
			.43056,
			0,
			0,
			.77778
		],
		8734: [
			0,
			.43056,
			0,
			0,
			1
		],
		8736: [
			0,
			.69224,
			0,
			0,
			.72222
		],
		8739: [
			.25,
			.75,
			0,
			0,
			.27778
		],
		8741: [
			.25,
			.75,
			0,
			0,
			.5
		],
		8743: [
			0,
			.55556,
			0,
			0,
			.66667
		],
		8744: [
			0,
			.55556,
			0,
			0,
			.66667
		],
		8745: [
			0,
			.55556,
			0,
			0,
			.66667
		],
		8746: [
			0,
			.55556,
			0,
			0,
			.66667
		],
		8747: [
			.19444,
			.69444,
			.11111,
			0,
			.41667
		],
		8764: [
			-.13313,
			.36687,
			0,
			0,
			.77778
		],
		8768: [
			.19444,
			.69444,
			0,
			0,
			.27778
		],
		8771: [
			-.03625,
			.46375,
			0,
			0,
			.77778
		],
		8773: [
			-.022,
			.589,
			0,
			0,
			.778
		],
		8776: [
			-.01688,
			.48312,
			0,
			0,
			.77778
		],
		8781: [
			-.03625,
			.46375,
			0,
			0,
			.77778
		],
		8784: [
			-.133,
			.673,
			0,
			0,
			.778
		],
		8801: [
			-.03625,
			.46375,
			0,
			0,
			.77778
		],
		8804: [
			.13597,
			.63597,
			0,
			0,
			.77778
		],
		8805: [
			.13597,
			.63597,
			0,
			0,
			.77778
		],
		8810: [
			.0391,
			.5391,
			0,
			0,
			1
		],
		8811: [
			.0391,
			.5391,
			0,
			0,
			1
		],
		8826: [
			.0391,
			.5391,
			0,
			0,
			.77778
		],
		8827: [
			.0391,
			.5391,
			0,
			0,
			.77778
		],
		8834: [
			.0391,
			.5391,
			0,
			0,
			.77778
		],
		8835: [
			.0391,
			.5391,
			0,
			0,
			.77778
		],
		8838: [
			.13597,
			.63597,
			0,
			0,
			.77778
		],
		8839: [
			.13597,
			.63597,
			0,
			0,
			.77778
		],
		8846: [
			0,
			.55556,
			0,
			0,
			.66667
		],
		8849: [
			.13597,
			.63597,
			0,
			0,
			.77778
		],
		8850: [
			.13597,
			.63597,
			0,
			0,
			.77778
		],
		8851: [
			0,
			.55556,
			0,
			0,
			.66667
		],
		8852: [
			0,
			.55556,
			0,
			0,
			.66667
		],
		8853: [
			.08333,
			.58333,
			0,
			0,
			.77778
		],
		8854: [
			.08333,
			.58333,
			0,
			0,
			.77778
		],
		8855: [
			.08333,
			.58333,
			0,
			0,
			.77778
		],
		8856: [
			.08333,
			.58333,
			0,
			0,
			.77778
		],
		8857: [
			.08333,
			.58333,
			0,
			0,
			.77778
		],
		8866: [
			0,
			.69444,
			0,
			0,
			.61111
		],
		8867: [
			0,
			.69444,
			0,
			0,
			.61111
		],
		8868: [
			0,
			.69444,
			0,
			0,
			.77778
		],
		8869: [
			0,
			.69444,
			0,
			0,
			.77778
		],
		8872: [
			.249,
			.75,
			0,
			0,
			.867
		],
		8900: [
			-.05555,
			.44445,
			0,
			0,
			.5
		],
		8901: [
			-.05555,
			.44445,
			0,
			0,
			.27778
		],
		8902: [
			-.03472,
			.46528,
			0,
			0,
			.5
		],
		8904: [
			.005,
			.505,
			0,
			0,
			.9
		],
		8942: [
			.03,
			.903,
			0,
			0,
			.278
		],
		8943: [
			-.19,
			.313,
			0,
			0,
			1.172
		],
		8945: [
			-.1,
			.823,
			0,
			0,
			1.282
		],
		8968: [
			.25,
			.75,
			0,
			0,
			.44445
		],
		8969: [
			.25,
			.75,
			0,
			0,
			.44445
		],
		8970: [
			.25,
			.75,
			0,
			0,
			.44445
		],
		8971: [
			.25,
			.75,
			0,
			0,
			.44445
		],
		8994: [
			-.14236,
			.35764,
			0,
			0,
			1
		],
		8995: [
			-.14236,
			.35764,
			0,
			0,
			1
		],
		9136: [
			.244,
			.744,
			0,
			0,
			.412
		],
		9137: [
			.244,
			.745,
			0,
			0,
			.412
		],
		9651: [
			.19444,
			.69444,
			0,
			0,
			.88889
		],
		9657: [
			-.03472,
			.46528,
			0,
			0,
			.5
		],
		9661: [
			.19444,
			.69444,
			0,
			0,
			.88889
		],
		9667: [
			-.03472,
			.46528,
			0,
			0,
			.5
		],
		9711: [
			.19444,
			.69444,
			0,
			0,
			1
		],
		9824: [
			.12963,
			.69444,
			0,
			0,
			.77778
		],
		9825: [
			.12963,
			.69444,
			0,
			0,
			.77778
		],
		9826: [
			.12963,
			.69444,
			0,
			0,
			.77778
		],
		9827: [
			.12963,
			.69444,
			0,
			0,
			.77778
		],
		9837: [
			0,
			.75,
			0,
			0,
			.38889
		],
		9838: [
			.19444,
			.69444,
			0,
			0,
			.38889
		],
		9839: [
			.19444,
			.69444,
			0,
			0,
			.38889
		],
		10216: [
			.25,
			.75,
			0,
			0,
			.38889
		],
		10217: [
			.25,
			.75,
			0,
			0,
			.38889
		],
		10222: [
			.244,
			.744,
			0,
			0,
			.412
		],
		10223: [
			.244,
			.745,
			0,
			0,
			.412
		],
		10229: [
			.011,
			.511,
			0,
			0,
			1.609
		],
		10230: [
			.011,
			.511,
			0,
			0,
			1.638
		],
		10231: [
			.011,
			.511,
			0,
			0,
			1.859
		],
		10232: [
			.024,
			.525,
			0,
			0,
			1.609
		],
		10233: [
			.024,
			.525,
			0,
			0,
			1.638
		],
		10234: [
			.024,
			.525,
			0,
			0,
			1.858
		],
		10236: [
			.011,
			.511,
			0,
			0,
			1.638
		],
		10815: [
			0,
			.68333,
			0,
			0,
			.75
		],
		10927: [
			.13597,
			.63597,
			0,
			0,
			.77778
		],
		10928: [
			.13597,
			.63597,
			0,
			0,
			.77778
		],
		57376: [
			.19444,
			.69444,
			0,
			0,
			0
		]
	},
	"Math-BoldItalic": {
		32: [
			0,
			0,
			0,
			0,
			.25
		],
		48: [
			0,
			.44444,
			0,
			0,
			.575
		],
		49: [
			0,
			.44444,
			0,
			0,
			.575
		],
		50: [
			0,
			.44444,
			0,
			0,
			.575
		],
		51: [
			.19444,
			.44444,
			0,
			0,
			.575
		],
		52: [
			.19444,
			.44444,
			0,
			0,
			.575
		],
		53: [
			.19444,
			.44444,
			0,
			0,
			.575
		],
		54: [
			0,
			.64444,
			0,
			0,
			.575
		],
		55: [
			.19444,
			.44444,
			0,
			0,
			.575
		],
		56: [
			0,
			.64444,
			0,
			0,
			.575
		],
		57: [
			.19444,
			.44444,
			0,
			0,
			.575
		],
		65: [
			0,
			.68611,
			0,
			0,
			.86944
		],
		66: [
			0,
			.68611,
			.04835,
			0,
			.8664
		],
		67: [
			0,
			.68611,
			.06979,
			0,
			.81694
		],
		68: [
			0,
			.68611,
			.03194,
			0,
			.93812
		],
		69: [
			0,
			.68611,
			.05451,
			0,
			.81007
		],
		70: [
			0,
			.68611,
			.15972,
			0,
			.68889
		],
		71: [
			0,
			.68611,
			0,
			0,
			.88673
		],
		72: [
			0,
			.68611,
			.08229,
			0,
			.98229
		],
		73: [
			0,
			.68611,
			.07778,
			0,
			.51111
		],
		74: [
			0,
			.68611,
			.10069,
			0,
			.63125
		],
		75: [
			0,
			.68611,
			.06979,
			0,
			.97118
		],
		76: [
			0,
			.68611,
			0,
			0,
			.75555
		],
		77: [
			0,
			.68611,
			.11424,
			0,
			1.14201
		],
		78: [
			0,
			.68611,
			.11424,
			0,
			.95034
		],
		79: [
			0,
			.68611,
			.03194,
			0,
			.83666
		],
		80: [
			0,
			.68611,
			.15972,
			0,
			.72309
		],
		81: [
			.19444,
			.68611,
			0,
			0,
			.86861
		],
		82: [
			0,
			.68611,
			.00421,
			0,
			.87235
		],
		83: [
			0,
			.68611,
			.05382,
			0,
			.69271
		],
		84: [
			0,
			.68611,
			.15972,
			0,
			.63663
		],
		85: [
			0,
			.68611,
			.11424,
			0,
			.80027
		],
		86: [
			0,
			.68611,
			.25555,
			0,
			.67778
		],
		87: [
			0,
			.68611,
			.15972,
			0,
			1.09305
		],
		88: [
			0,
			.68611,
			.07778,
			0,
			.94722
		],
		89: [
			0,
			.68611,
			.25555,
			0,
			.67458
		],
		90: [
			0,
			.68611,
			.06979,
			0,
			.77257
		],
		97: [
			0,
			.44444,
			0,
			0,
			.63287
		],
		98: [
			0,
			.69444,
			0,
			0,
			.52083
		],
		99: [
			0,
			.44444,
			0,
			0,
			.51342
		],
		100: [
			0,
			.69444,
			0,
			0,
			.60972
		],
		101: [
			0,
			.44444,
			0,
			0,
			.55361
		],
		102: [
			.19444,
			.69444,
			.11042,
			0,
			.56806
		],
		103: [
			.19444,
			.44444,
			.03704,
			0,
			.5449
		],
		104: [
			0,
			.69444,
			0,
			0,
			.66759
		],
		105: [
			0,
			.69326,
			0,
			0,
			.4048
		],
		106: [
			.19444,
			.69326,
			.0622,
			0,
			.47083
		],
		107: [
			0,
			.69444,
			.01852,
			0,
			.6037
		],
		108: [
			0,
			.69444,
			.0088,
			0,
			.34815
		],
		109: [
			0,
			.44444,
			0,
			0,
			1.0324
		],
		110: [
			0,
			.44444,
			0,
			0,
			.71296
		],
		111: [
			0,
			.44444,
			0,
			0,
			.58472
		],
		112: [
			.19444,
			.44444,
			0,
			0,
			.60092
		],
		113: [
			.19444,
			.44444,
			.03704,
			0,
			.54213
		],
		114: [
			0,
			.44444,
			.03194,
			0,
			.5287
		],
		115: [
			0,
			.44444,
			0,
			0,
			.53125
		],
		116: [
			0,
			.63492,
			0,
			0,
			.41528
		],
		117: [
			0,
			.44444,
			0,
			0,
			.68102
		],
		118: [
			0,
			.44444,
			.03704,
			0,
			.56666
		],
		119: [
			0,
			.44444,
			.02778,
			0,
			.83148
		],
		120: [
			0,
			.44444,
			0,
			0,
			.65903
		],
		121: [
			.19444,
			.44444,
			.03704,
			0,
			.59028
		],
		122: [
			0,
			.44444,
			.04213,
			0,
			.55509
		],
		160: [
			0,
			0,
			0,
			0,
			.25
		],
		915: [
			0,
			.68611,
			.15972,
			0,
			.65694
		],
		916: [
			0,
			.68611,
			0,
			0,
			.95833
		],
		920: [
			0,
			.68611,
			.03194,
			0,
			.86722
		],
		923: [
			0,
			.68611,
			0,
			0,
			.80555
		],
		926: [
			0,
			.68611,
			.07458,
			0,
			.84125
		],
		928: [
			0,
			.68611,
			.08229,
			0,
			.98229
		],
		931: [
			0,
			.68611,
			.05451,
			0,
			.88507
		],
		933: [
			0,
			.68611,
			.15972,
			0,
			.67083
		],
		934: [
			0,
			.68611,
			0,
			0,
			.76666
		],
		936: [
			0,
			.68611,
			.11653,
			0,
			.71402
		],
		937: [
			0,
			.68611,
			.04835,
			0,
			.8789
		],
		945: [
			0,
			.44444,
			0,
			0,
			.76064
		],
		946: [
			.19444,
			.69444,
			.03403,
			0,
			.65972
		],
		947: [
			.19444,
			.44444,
			.06389,
			0,
			.59003
		],
		948: [
			0,
			.69444,
			.03819,
			0,
			.52222
		],
		949: [
			0,
			.44444,
			0,
			0,
			.52882
		],
		950: [
			.19444,
			.69444,
			.06215,
			0,
			.50833
		],
		951: [
			.19444,
			.44444,
			.03704,
			0,
			.6
		],
		952: [
			0,
			.69444,
			.03194,
			0,
			.5618
		],
		953: [
			0,
			.44444,
			0,
			0,
			.41204
		],
		954: [
			0,
			.44444,
			0,
			0,
			.66759
		],
		955: [
			0,
			.69444,
			0,
			0,
			.67083
		],
		956: [
			.19444,
			.44444,
			0,
			0,
			.70787
		],
		957: [
			0,
			.44444,
			.06898,
			0,
			.57685
		],
		958: [
			.19444,
			.69444,
			.03021,
			0,
			.50833
		],
		959: [
			0,
			.44444,
			0,
			0,
			.58472
		],
		960: [
			0,
			.44444,
			.03704,
			0,
			.68241
		],
		961: [
			.19444,
			.44444,
			0,
			0,
			.6118
		],
		962: [
			.09722,
			.44444,
			.07917,
			0,
			.42361
		],
		963: [
			0,
			.44444,
			.03704,
			0,
			.68588
		],
		964: [
			0,
			.44444,
			.13472,
			0,
			.52083
		],
		965: [
			0,
			.44444,
			.03704,
			0,
			.63055
		],
		966: [
			.19444,
			.44444,
			0,
			0,
			.74722
		],
		967: [
			.19444,
			.44444,
			0,
			0,
			.71805
		],
		968: [
			.19444,
			.69444,
			.03704,
			0,
			.75833
		],
		969: [
			0,
			.44444,
			.03704,
			0,
			.71782
		],
		977: [
			0,
			.69444,
			0,
			0,
			.69155
		],
		981: [
			.19444,
			.69444,
			0,
			0,
			.7125
		],
		982: [
			0,
			.44444,
			.03194,
			0,
			.975
		],
		1009: [
			.19444,
			.44444,
			0,
			0,
			.6118
		],
		1013: [
			0,
			.44444,
			0,
			0,
			.48333
		],
		57649: [
			0,
			.44444,
			0,
			0,
			.39352
		],
		57911: [
			.19444,
			.44444,
			0,
			0,
			.43889
		]
	},
	"Math-Italic": {
		32: [
			0,
			0,
			0,
			0,
			.25
		],
		48: [
			0,
			.43056,
			0,
			0,
			.5
		],
		49: [
			0,
			.43056,
			0,
			0,
			.5
		],
		50: [
			0,
			.43056,
			0,
			0,
			.5
		],
		51: [
			.19444,
			.43056,
			0,
			0,
			.5
		],
		52: [
			.19444,
			.43056,
			0,
			0,
			.5
		],
		53: [
			.19444,
			.43056,
			0,
			0,
			.5
		],
		54: [
			0,
			.64444,
			0,
			0,
			.5
		],
		55: [
			.19444,
			.43056,
			0,
			0,
			.5
		],
		56: [
			0,
			.64444,
			0,
			0,
			.5
		],
		57: [
			.19444,
			.43056,
			0,
			0,
			.5
		],
		65: [
			0,
			.68333,
			0,
			.13889,
			.75
		],
		66: [
			0,
			.68333,
			.05017,
			.08334,
			.75851
		],
		67: [
			0,
			.68333,
			.07153,
			.08334,
			.71472
		],
		68: [
			0,
			.68333,
			.02778,
			.05556,
			.82792
		],
		69: [
			0,
			.68333,
			.05764,
			.08334,
			.7382
		],
		70: [
			0,
			.68333,
			.13889,
			.08334,
			.64306
		],
		71: [
			0,
			.68333,
			0,
			.08334,
			.78625
		],
		72: [
			0,
			.68333,
			.08125,
			.05556,
			.83125
		],
		73: [
			0,
			.68333,
			.07847,
			.11111,
			.43958
		],
		74: [
			0,
			.68333,
			.09618,
			.16667,
			.55451
		],
		75: [
			0,
			.68333,
			.07153,
			.05556,
			.84931
		],
		76: [
			0,
			.68333,
			0,
			.02778,
			.68056
		],
		77: [
			0,
			.68333,
			.10903,
			.08334,
			.97014
		],
		78: [
			0,
			.68333,
			.10903,
			.08334,
			.80347
		],
		79: [
			0,
			.68333,
			.02778,
			.08334,
			.76278
		],
		80: [
			0,
			.68333,
			.13889,
			.08334,
			.64201
		],
		81: [
			.19444,
			.68333,
			0,
			.08334,
			.79056
		],
		82: [
			0,
			.68333,
			.00773,
			.08334,
			.75929
		],
		83: [
			0,
			.68333,
			.05764,
			.08334,
			.6132
		],
		84: [
			0,
			.68333,
			.13889,
			.08334,
			.58438
		],
		85: [
			0,
			.68333,
			.10903,
			.02778,
			.68278
		],
		86: [
			0,
			.68333,
			.22222,
			0,
			.58333
		],
		87: [
			0,
			.68333,
			.13889,
			0,
			.94445
		],
		88: [
			0,
			.68333,
			.07847,
			.08334,
			.82847
		],
		89: [
			0,
			.68333,
			.22222,
			0,
			.58056
		],
		90: [
			0,
			.68333,
			.07153,
			.08334,
			.68264
		],
		97: [
			0,
			.43056,
			0,
			0,
			.52859
		],
		98: [
			0,
			.69444,
			0,
			0,
			.42917
		],
		99: [
			0,
			.43056,
			0,
			.05556,
			.43276
		],
		100: [
			0,
			.69444,
			0,
			.16667,
			.52049
		],
		101: [
			0,
			.43056,
			0,
			.05556,
			.46563
		],
		102: [
			.19444,
			.69444,
			.10764,
			.16667,
			.48959
		],
		103: [
			.19444,
			.43056,
			.03588,
			.02778,
			.47697
		],
		104: [
			0,
			.69444,
			0,
			0,
			.57616
		],
		105: [
			0,
			.65952,
			0,
			0,
			.34451
		],
		106: [
			.19444,
			.65952,
			.05724,
			0,
			.41181
		],
		107: [
			0,
			.69444,
			.03148,
			0,
			.5206
		],
		108: [
			0,
			.69444,
			.01968,
			.08334,
			.29838
		],
		109: [
			0,
			.43056,
			0,
			0,
			.87801
		],
		110: [
			0,
			.43056,
			0,
			0,
			.60023
		],
		111: [
			0,
			.43056,
			0,
			.05556,
			.48472
		],
		112: [
			.19444,
			.43056,
			0,
			.08334,
			.50313
		],
		113: [
			.19444,
			.43056,
			.03588,
			.08334,
			.44641
		],
		114: [
			0,
			.43056,
			.02778,
			.05556,
			.45116
		],
		115: [
			0,
			.43056,
			0,
			.05556,
			.46875
		],
		116: [
			0,
			.61508,
			0,
			.08334,
			.36111
		],
		117: [
			0,
			.43056,
			0,
			.02778,
			.57246
		],
		118: [
			0,
			.43056,
			.03588,
			.02778,
			.48472
		],
		119: [
			0,
			.43056,
			.02691,
			.08334,
			.71592
		],
		120: [
			0,
			.43056,
			0,
			.02778,
			.57153
		],
		121: [
			.19444,
			.43056,
			.03588,
			.05556,
			.49028
		],
		122: [
			0,
			.43056,
			.04398,
			.05556,
			.46505
		],
		160: [
			0,
			0,
			0,
			0,
			.25
		],
		915: [
			0,
			.68333,
			.13889,
			.08334,
			.61528
		],
		916: [
			0,
			.68333,
			0,
			.16667,
			.83334
		],
		920: [
			0,
			.68333,
			.02778,
			.08334,
			.76278
		],
		923: [
			0,
			.68333,
			0,
			.16667,
			.69445
		],
		926: [
			0,
			.68333,
			.07569,
			.08334,
			.74236
		],
		928: [
			0,
			.68333,
			.08125,
			.05556,
			.83125
		],
		931: [
			0,
			.68333,
			.05764,
			.08334,
			.77986
		],
		933: [
			0,
			.68333,
			.13889,
			.05556,
			.58333
		],
		934: [
			0,
			.68333,
			0,
			.08334,
			.66667
		],
		936: [
			0,
			.68333,
			.11,
			.05556,
			.61222
		],
		937: [
			0,
			.68333,
			.05017,
			.08334,
			.7724
		],
		945: [
			0,
			.43056,
			.0037,
			.02778,
			.6397
		],
		946: [
			.19444,
			.69444,
			.05278,
			.08334,
			.56563
		],
		947: [
			.19444,
			.43056,
			.05556,
			0,
			.51773
		],
		948: [
			0,
			.69444,
			.03785,
			.05556,
			.44444
		],
		949: [
			0,
			.43056,
			0,
			.08334,
			.46632
		],
		950: [
			.19444,
			.69444,
			.07378,
			.08334,
			.4375
		],
		951: [
			.19444,
			.43056,
			.03588,
			.05556,
			.49653
		],
		952: [
			0,
			.69444,
			.02778,
			.08334,
			.46944
		],
		953: [
			0,
			.43056,
			0,
			.05556,
			.35394
		],
		954: [
			0,
			.43056,
			0,
			0,
			.57616
		],
		955: [
			0,
			.69444,
			0,
			0,
			.58334
		],
		956: [
			.19444,
			.43056,
			0,
			.02778,
			.60255
		],
		957: [
			0,
			.43056,
			.06366,
			.02778,
			.49398
		],
		958: [
			.19444,
			.69444,
			.04601,
			.11111,
			.4375
		],
		959: [
			0,
			.43056,
			0,
			.05556,
			.48472
		],
		960: [
			0,
			.43056,
			.03588,
			0,
			.57003
		],
		961: [
			.19444,
			.43056,
			0,
			.08334,
			.51702
		],
		962: [
			.09722,
			.43056,
			.07986,
			.08334,
			.36285
		],
		963: [
			0,
			.43056,
			.03588,
			0,
			.57141
		],
		964: [
			0,
			.43056,
			.1132,
			.02778,
			.43715
		],
		965: [
			0,
			.43056,
			.03588,
			.02778,
			.54028
		],
		966: [
			.19444,
			.43056,
			0,
			.08334,
			.65417
		],
		967: [
			.19444,
			.43056,
			0,
			.05556,
			.62569
		],
		968: [
			.19444,
			.69444,
			.03588,
			.11111,
			.65139
		],
		969: [
			0,
			.43056,
			.03588,
			0,
			.62245
		],
		977: [
			0,
			.69444,
			0,
			.08334,
			.59144
		],
		981: [
			.19444,
			.69444,
			0,
			.08334,
			.59583
		],
		982: [
			0,
			.43056,
			.02778,
			0,
			.82813
		],
		1009: [
			.19444,
			.43056,
			0,
			.08334,
			.51702
		],
		1013: [
			0,
			.43056,
			0,
			.05556,
			.4059
		],
		57649: [
			0,
			.43056,
			0,
			.02778,
			.32246
		],
		57911: [
			.19444,
			.43056,
			0,
			.08334,
			.38403
		]
	},
	"SansSerif-Bold": {
		32: [
			0,
			0,
			0,
			0,
			.25
		],
		33: [
			0,
			.69444,
			0,
			0,
			.36667
		],
		34: [
			0,
			.69444,
			0,
			0,
			.55834
		],
		35: [
			.19444,
			.69444,
			0,
			0,
			.91667
		],
		36: [
			.05556,
			.75,
			0,
			0,
			.55
		],
		37: [
			.05556,
			.75,
			0,
			0,
			1.02912
		],
		38: [
			0,
			.69444,
			0,
			0,
			.83056
		],
		39: [
			0,
			.69444,
			0,
			0,
			.30556
		],
		40: [
			.25,
			.75,
			0,
			0,
			.42778
		],
		41: [
			.25,
			.75,
			0,
			0,
			.42778
		],
		42: [
			0,
			.75,
			0,
			0,
			.55
		],
		43: [
			.11667,
			.61667,
			0,
			0,
			.85556
		],
		44: [
			.10556,
			.13056,
			0,
			0,
			.30556
		],
		45: [
			0,
			.45833,
			0,
			0,
			.36667
		],
		46: [
			0,
			.13056,
			0,
			0,
			.30556
		],
		47: [
			.25,
			.75,
			0,
			0,
			.55
		],
		48: [
			0,
			.69444,
			0,
			0,
			.55
		],
		49: [
			0,
			.69444,
			0,
			0,
			.55
		],
		50: [
			0,
			.69444,
			0,
			0,
			.55
		],
		51: [
			0,
			.69444,
			0,
			0,
			.55
		],
		52: [
			0,
			.69444,
			0,
			0,
			.55
		],
		53: [
			0,
			.69444,
			0,
			0,
			.55
		],
		54: [
			0,
			.69444,
			0,
			0,
			.55
		],
		55: [
			0,
			.69444,
			0,
			0,
			.55
		],
		56: [
			0,
			.69444,
			0,
			0,
			.55
		],
		57: [
			0,
			.69444,
			0,
			0,
			.55
		],
		58: [
			0,
			.45833,
			0,
			0,
			.30556
		],
		59: [
			.10556,
			.45833,
			0,
			0,
			.30556
		],
		61: [
			-.09375,
			.40625,
			0,
			0,
			.85556
		],
		63: [
			0,
			.69444,
			0,
			0,
			.51945
		],
		64: [
			0,
			.69444,
			0,
			0,
			.73334
		],
		65: [
			0,
			.69444,
			0,
			0,
			.73334
		],
		66: [
			0,
			.69444,
			0,
			0,
			.73334
		],
		67: [
			0,
			.69444,
			0,
			0,
			.70278
		],
		68: [
			0,
			.69444,
			0,
			0,
			.79445
		],
		69: [
			0,
			.69444,
			0,
			0,
			.64167
		],
		70: [
			0,
			.69444,
			0,
			0,
			.61111
		],
		71: [
			0,
			.69444,
			0,
			0,
			.73334
		],
		72: [
			0,
			.69444,
			0,
			0,
			.79445
		],
		73: [
			0,
			.69444,
			0,
			0,
			.33056
		],
		74: [
			0,
			.69444,
			0,
			0,
			.51945
		],
		75: [
			0,
			.69444,
			0,
			0,
			.76389
		],
		76: [
			0,
			.69444,
			0,
			0,
			.58056
		],
		77: [
			0,
			.69444,
			0,
			0,
			.97778
		],
		78: [
			0,
			.69444,
			0,
			0,
			.79445
		],
		79: [
			0,
			.69444,
			0,
			0,
			.79445
		],
		80: [
			0,
			.69444,
			0,
			0,
			.70278
		],
		81: [
			.10556,
			.69444,
			0,
			0,
			.79445
		],
		82: [
			0,
			.69444,
			0,
			0,
			.70278
		],
		83: [
			0,
			.69444,
			0,
			0,
			.61111
		],
		84: [
			0,
			.69444,
			0,
			0,
			.73334
		],
		85: [
			0,
			.69444,
			0,
			0,
			.76389
		],
		86: [
			0,
			.69444,
			.01528,
			0,
			.73334
		],
		87: [
			0,
			.69444,
			.01528,
			0,
			1.03889
		],
		88: [
			0,
			.69444,
			0,
			0,
			.73334
		],
		89: [
			0,
			.69444,
			.0275,
			0,
			.73334
		],
		90: [
			0,
			.69444,
			0,
			0,
			.67223
		],
		91: [
			.25,
			.75,
			0,
			0,
			.34306
		],
		93: [
			.25,
			.75,
			0,
			0,
			.34306
		],
		94: [
			0,
			.69444,
			0,
			0,
			.55
		],
		95: [
			.35,
			.10833,
			.03056,
			0,
			.55
		],
		97: [
			0,
			.45833,
			0,
			0,
			.525
		],
		98: [
			0,
			.69444,
			0,
			0,
			.56111
		],
		99: [
			0,
			.45833,
			0,
			0,
			.48889
		],
		100: [
			0,
			.69444,
			0,
			0,
			.56111
		],
		101: [
			0,
			.45833,
			0,
			0,
			.51111
		],
		102: [
			0,
			.69444,
			.07639,
			0,
			.33611
		],
		103: [
			.19444,
			.45833,
			.01528,
			0,
			.55
		],
		104: [
			0,
			.69444,
			0,
			0,
			.56111
		],
		105: [
			0,
			.69444,
			0,
			0,
			.25556
		],
		106: [
			.19444,
			.69444,
			0,
			0,
			.28611
		],
		107: [
			0,
			.69444,
			0,
			0,
			.53056
		],
		108: [
			0,
			.69444,
			0,
			0,
			.25556
		],
		109: [
			0,
			.45833,
			0,
			0,
			.86667
		],
		110: [
			0,
			.45833,
			0,
			0,
			.56111
		],
		111: [
			0,
			.45833,
			0,
			0,
			.55
		],
		112: [
			.19444,
			.45833,
			0,
			0,
			.56111
		],
		113: [
			.19444,
			.45833,
			0,
			0,
			.56111
		],
		114: [
			0,
			.45833,
			.01528,
			0,
			.37222
		],
		115: [
			0,
			.45833,
			0,
			0,
			.42167
		],
		116: [
			0,
			.58929,
			0,
			0,
			.40417
		],
		117: [
			0,
			.45833,
			0,
			0,
			.56111
		],
		118: [
			0,
			.45833,
			.01528,
			0,
			.5
		],
		119: [
			0,
			.45833,
			.01528,
			0,
			.74445
		],
		120: [
			0,
			.45833,
			0,
			0,
			.5
		],
		121: [
			.19444,
			.45833,
			.01528,
			0,
			.5
		],
		122: [
			0,
			.45833,
			0,
			0,
			.47639
		],
		126: [
			.35,
			.34444,
			0,
			0,
			.55
		],
		160: [
			0,
			0,
			0,
			0,
			.25
		],
		168: [
			0,
			.69444,
			0,
			0,
			.55
		],
		176: [
			0,
			.69444,
			0,
			0,
			.73334
		],
		180: [
			0,
			.69444,
			0,
			0,
			.55
		],
		184: [
			.17014,
			0,
			0,
			0,
			.48889
		],
		305: [
			0,
			.45833,
			0,
			0,
			.25556
		],
		567: [
			.19444,
			.45833,
			0,
			0,
			.28611
		],
		710: [
			0,
			.69444,
			0,
			0,
			.55
		],
		711: [
			0,
			.63542,
			0,
			0,
			.55
		],
		713: [
			0,
			.63778,
			0,
			0,
			.55
		],
		728: [
			0,
			.69444,
			0,
			0,
			.55
		],
		729: [
			0,
			.69444,
			0,
			0,
			.30556
		],
		730: [
			0,
			.69444,
			0,
			0,
			.73334
		],
		732: [
			0,
			.69444,
			0,
			0,
			.55
		],
		733: [
			0,
			.69444,
			0,
			0,
			.55
		],
		915: [
			0,
			.69444,
			0,
			0,
			.58056
		],
		916: [
			0,
			.69444,
			0,
			0,
			.91667
		],
		920: [
			0,
			.69444,
			0,
			0,
			.85556
		],
		923: [
			0,
			.69444,
			0,
			0,
			.67223
		],
		926: [
			0,
			.69444,
			0,
			0,
			.73334
		],
		928: [
			0,
			.69444,
			0,
			0,
			.79445
		],
		931: [
			0,
			.69444,
			0,
			0,
			.79445
		],
		933: [
			0,
			.69444,
			0,
			0,
			.85556
		],
		934: [
			0,
			.69444,
			0,
			0,
			.79445
		],
		936: [
			0,
			.69444,
			0,
			0,
			.85556
		],
		937: [
			0,
			.69444,
			0,
			0,
			.79445
		],
		8211: [
			0,
			.45833,
			.03056,
			0,
			.55
		],
		8212: [
			0,
			.45833,
			.03056,
			0,
			1.10001
		],
		8216: [
			0,
			.69444,
			0,
			0,
			.30556
		],
		8217: [
			0,
			.69444,
			0,
			0,
			.30556
		],
		8220: [
			0,
			.69444,
			0,
			0,
			.55834
		],
		8221: [
			0,
			.69444,
			0,
			0,
			.55834
		]
	},
	"SansSerif-Italic": {
		32: [
			0,
			0,
			0,
			0,
			.25
		],
		33: [
			0,
			.69444,
			.05733,
			0,
			.31945
		],
		34: [
			0,
			.69444,
			.00316,
			0,
			.5
		],
		35: [
			.19444,
			.69444,
			.05087,
			0,
			.83334
		],
		36: [
			.05556,
			.75,
			.11156,
			0,
			.5
		],
		37: [
			.05556,
			.75,
			.03126,
			0,
			.83334
		],
		38: [
			0,
			.69444,
			.03058,
			0,
			.75834
		],
		39: [
			0,
			.69444,
			.07816,
			0,
			.27778
		],
		40: [
			.25,
			.75,
			.13164,
			0,
			.38889
		],
		41: [
			.25,
			.75,
			.02536,
			0,
			.38889
		],
		42: [
			0,
			.75,
			.11775,
			0,
			.5
		],
		43: [
			.08333,
			.58333,
			.02536,
			0,
			.77778
		],
		44: [
			.125,
			.08333,
			0,
			0,
			.27778
		],
		45: [
			0,
			.44444,
			.01946,
			0,
			.33333
		],
		46: [
			0,
			.08333,
			0,
			0,
			.27778
		],
		47: [
			.25,
			.75,
			.13164,
			0,
			.5
		],
		48: [
			0,
			.65556,
			.11156,
			0,
			.5
		],
		49: [
			0,
			.65556,
			.11156,
			0,
			.5
		],
		50: [
			0,
			.65556,
			.11156,
			0,
			.5
		],
		51: [
			0,
			.65556,
			.11156,
			0,
			.5
		],
		52: [
			0,
			.65556,
			.11156,
			0,
			.5
		],
		53: [
			0,
			.65556,
			.11156,
			0,
			.5
		],
		54: [
			0,
			.65556,
			.11156,
			0,
			.5
		],
		55: [
			0,
			.65556,
			.11156,
			0,
			.5
		],
		56: [
			0,
			.65556,
			.11156,
			0,
			.5
		],
		57: [
			0,
			.65556,
			.11156,
			0,
			.5
		],
		58: [
			0,
			.44444,
			.02502,
			0,
			.27778
		],
		59: [
			.125,
			.44444,
			.02502,
			0,
			.27778
		],
		61: [
			-.13,
			.37,
			.05087,
			0,
			.77778
		],
		63: [
			0,
			.69444,
			.11809,
			0,
			.47222
		],
		64: [
			0,
			.69444,
			.07555,
			0,
			.66667
		],
		65: [
			0,
			.69444,
			0,
			0,
			.66667
		],
		66: [
			0,
			.69444,
			.08293,
			0,
			.66667
		],
		67: [
			0,
			.69444,
			.11983,
			0,
			.63889
		],
		68: [
			0,
			.69444,
			.07555,
			0,
			.72223
		],
		69: [
			0,
			.69444,
			.11983,
			0,
			.59722
		],
		70: [
			0,
			.69444,
			.13372,
			0,
			.56945
		],
		71: [
			0,
			.69444,
			.11983,
			0,
			.66667
		],
		72: [
			0,
			.69444,
			.08094,
			0,
			.70834
		],
		73: [
			0,
			.69444,
			.13372,
			0,
			.27778
		],
		74: [
			0,
			.69444,
			.08094,
			0,
			.47222
		],
		75: [
			0,
			.69444,
			.11983,
			0,
			.69445
		],
		76: [
			0,
			.69444,
			0,
			0,
			.54167
		],
		77: [
			0,
			.69444,
			.08094,
			0,
			.875
		],
		78: [
			0,
			.69444,
			.08094,
			0,
			.70834
		],
		79: [
			0,
			.69444,
			.07555,
			0,
			.73611
		],
		80: [
			0,
			.69444,
			.08293,
			0,
			.63889
		],
		81: [
			.125,
			.69444,
			.07555,
			0,
			.73611
		],
		82: [
			0,
			.69444,
			.08293,
			0,
			.64584
		],
		83: [
			0,
			.69444,
			.09205,
			0,
			.55556
		],
		84: [
			0,
			.69444,
			.13372,
			0,
			.68056
		],
		85: [
			0,
			.69444,
			.08094,
			0,
			.6875
		],
		86: [
			0,
			.69444,
			.1615,
			0,
			.66667
		],
		87: [
			0,
			.69444,
			.1615,
			0,
			.94445
		],
		88: [
			0,
			.69444,
			.13372,
			0,
			.66667
		],
		89: [
			0,
			.69444,
			.17261,
			0,
			.66667
		],
		90: [
			0,
			.69444,
			.11983,
			0,
			.61111
		],
		91: [
			.25,
			.75,
			.15942,
			0,
			.28889
		],
		93: [
			.25,
			.75,
			.08719,
			0,
			.28889
		],
		94: [
			0,
			.69444,
			.0799,
			0,
			.5
		],
		95: [
			.35,
			.09444,
			.08616,
			0,
			.5
		],
		97: [
			0,
			.44444,
			.00981,
			0,
			.48056
		],
		98: [
			0,
			.69444,
			.03057,
			0,
			.51667
		],
		99: [
			0,
			.44444,
			.08336,
			0,
			.44445
		],
		100: [
			0,
			.69444,
			.09483,
			0,
			.51667
		],
		101: [
			0,
			.44444,
			.06778,
			0,
			.44445
		],
		102: [
			0,
			.69444,
			.21705,
			0,
			.30556
		],
		103: [
			.19444,
			.44444,
			.10836,
			0,
			.5
		],
		104: [
			0,
			.69444,
			.01778,
			0,
			.51667
		],
		105: [
			0,
			.67937,
			.09718,
			0,
			.23889
		],
		106: [
			.19444,
			.67937,
			.09162,
			0,
			.26667
		],
		107: [
			0,
			.69444,
			.08336,
			0,
			.48889
		],
		108: [
			0,
			.69444,
			.09483,
			0,
			.23889
		],
		109: [
			0,
			.44444,
			.01778,
			0,
			.79445
		],
		110: [
			0,
			.44444,
			.01778,
			0,
			.51667
		],
		111: [
			0,
			.44444,
			.06613,
			0,
			.5
		],
		112: [
			.19444,
			.44444,
			.0389,
			0,
			.51667
		],
		113: [
			.19444,
			.44444,
			.04169,
			0,
			.51667
		],
		114: [
			0,
			.44444,
			.10836,
			0,
			.34167
		],
		115: [
			0,
			.44444,
			.0778,
			0,
			.38333
		],
		116: [
			0,
			.57143,
			.07225,
			0,
			.36111
		],
		117: [
			0,
			.44444,
			.04169,
			0,
			.51667
		],
		118: [
			0,
			.44444,
			.10836,
			0,
			.46111
		],
		119: [
			0,
			.44444,
			.10836,
			0,
			.68334
		],
		120: [
			0,
			.44444,
			.09169,
			0,
			.46111
		],
		121: [
			.19444,
			.44444,
			.10836,
			0,
			.46111
		],
		122: [
			0,
			.44444,
			.08752,
			0,
			.43472
		],
		126: [
			.35,
			.32659,
			.08826,
			0,
			.5
		],
		160: [
			0,
			0,
			0,
			0,
			.25
		],
		168: [
			0,
			.67937,
			.06385,
			0,
			.5
		],
		176: [
			0,
			.69444,
			0,
			0,
			.73752
		],
		184: [
			.17014,
			0,
			0,
			0,
			.44445
		],
		305: [
			0,
			.44444,
			.04169,
			0,
			.23889
		],
		567: [
			.19444,
			.44444,
			.04169,
			0,
			.26667
		],
		710: [
			0,
			.69444,
			.0799,
			0,
			.5
		],
		711: [
			0,
			.63194,
			.08432,
			0,
			.5
		],
		713: [
			0,
			.60889,
			.08776,
			0,
			.5
		],
		714: [
			0,
			.69444,
			.09205,
			0,
			.5
		],
		715: [
			0,
			.69444,
			0,
			0,
			.5
		],
		728: [
			0,
			.69444,
			.09483,
			0,
			.5
		],
		729: [
			0,
			.67937,
			.07774,
			0,
			.27778
		],
		730: [
			0,
			.69444,
			0,
			0,
			.73752
		],
		732: [
			0,
			.67659,
			.08826,
			0,
			.5
		],
		733: [
			0,
			.69444,
			.09205,
			0,
			.5
		],
		915: [
			0,
			.69444,
			.13372,
			0,
			.54167
		],
		916: [
			0,
			.69444,
			0,
			0,
			.83334
		],
		920: [
			0,
			.69444,
			.07555,
			0,
			.77778
		],
		923: [
			0,
			.69444,
			0,
			0,
			.61111
		],
		926: [
			0,
			.69444,
			.12816,
			0,
			.66667
		],
		928: [
			0,
			.69444,
			.08094,
			0,
			.70834
		],
		931: [
			0,
			.69444,
			.11983,
			0,
			.72222
		],
		933: [
			0,
			.69444,
			.09031,
			0,
			.77778
		],
		934: [
			0,
			.69444,
			.04603,
			0,
			.72222
		],
		936: [
			0,
			.69444,
			.09031,
			0,
			.77778
		],
		937: [
			0,
			.69444,
			.08293,
			0,
			.72222
		],
		8211: [
			0,
			.44444,
			.08616,
			0,
			.5
		],
		8212: [
			0,
			.44444,
			.08616,
			0,
			1
		],
		8216: [
			0,
			.69444,
			.07816,
			0,
			.27778
		],
		8217: [
			0,
			.69444,
			.07816,
			0,
			.27778
		],
		8220: [
			0,
			.69444,
			.14205,
			0,
			.5
		],
		8221: [
			0,
			.69444,
			.00316,
			0,
			.5
		]
	},
	"SansSerif-Regular": {
		32: [
			0,
			0,
			0,
			0,
			.25
		],
		33: [
			0,
			.69444,
			0,
			0,
			.31945
		],
		34: [
			0,
			.69444,
			0,
			0,
			.5
		],
		35: [
			.19444,
			.69444,
			0,
			0,
			.83334
		],
		36: [
			.05556,
			.75,
			0,
			0,
			.5
		],
		37: [
			.05556,
			.75,
			0,
			0,
			.83334
		],
		38: [
			0,
			.69444,
			0,
			0,
			.75834
		],
		39: [
			0,
			.69444,
			0,
			0,
			.27778
		],
		40: [
			.25,
			.75,
			0,
			0,
			.38889
		],
		41: [
			.25,
			.75,
			0,
			0,
			.38889
		],
		42: [
			0,
			.75,
			0,
			0,
			.5
		],
		43: [
			.08333,
			.58333,
			0,
			0,
			.77778
		],
		44: [
			.125,
			.08333,
			0,
			0,
			.27778
		],
		45: [
			0,
			.44444,
			0,
			0,
			.33333
		],
		46: [
			0,
			.08333,
			0,
			0,
			.27778
		],
		47: [
			.25,
			.75,
			0,
			0,
			.5
		],
		48: [
			0,
			.65556,
			0,
			0,
			.5
		],
		49: [
			0,
			.65556,
			0,
			0,
			.5
		],
		50: [
			0,
			.65556,
			0,
			0,
			.5
		],
		51: [
			0,
			.65556,
			0,
			0,
			.5
		],
		52: [
			0,
			.65556,
			0,
			0,
			.5
		],
		53: [
			0,
			.65556,
			0,
			0,
			.5
		],
		54: [
			0,
			.65556,
			0,
			0,
			.5
		],
		55: [
			0,
			.65556,
			0,
			0,
			.5
		],
		56: [
			0,
			.65556,
			0,
			0,
			.5
		],
		57: [
			0,
			.65556,
			0,
			0,
			.5
		],
		58: [
			0,
			.44444,
			0,
			0,
			.27778
		],
		59: [
			.125,
			.44444,
			0,
			0,
			.27778
		],
		61: [
			-.13,
			.37,
			0,
			0,
			.77778
		],
		63: [
			0,
			.69444,
			0,
			0,
			.47222
		],
		64: [
			0,
			.69444,
			0,
			0,
			.66667
		],
		65: [
			0,
			.69444,
			0,
			0,
			.66667
		],
		66: [
			0,
			.69444,
			0,
			0,
			.66667
		],
		67: [
			0,
			.69444,
			0,
			0,
			.63889
		],
		68: [
			0,
			.69444,
			0,
			0,
			.72223
		],
		69: [
			0,
			.69444,
			0,
			0,
			.59722
		],
		70: [
			0,
			.69444,
			0,
			0,
			.56945
		],
		71: [
			0,
			.69444,
			0,
			0,
			.66667
		],
		72: [
			0,
			.69444,
			0,
			0,
			.70834
		],
		73: [
			0,
			.69444,
			0,
			0,
			.27778
		],
		74: [
			0,
			.69444,
			0,
			0,
			.47222
		],
		75: [
			0,
			.69444,
			0,
			0,
			.69445
		],
		76: [
			0,
			.69444,
			0,
			0,
			.54167
		],
		77: [
			0,
			.69444,
			0,
			0,
			.875
		],
		78: [
			0,
			.69444,
			0,
			0,
			.70834
		],
		79: [
			0,
			.69444,
			0,
			0,
			.73611
		],
		80: [
			0,
			.69444,
			0,
			0,
			.63889
		],
		81: [
			.125,
			.69444,
			0,
			0,
			.73611
		],
		82: [
			0,
			.69444,
			0,
			0,
			.64584
		],
		83: [
			0,
			.69444,
			0,
			0,
			.55556
		],
		84: [
			0,
			.69444,
			0,
			0,
			.68056
		],
		85: [
			0,
			.69444,
			0,
			0,
			.6875
		],
		86: [
			0,
			.69444,
			.01389,
			0,
			.66667
		],
		87: [
			0,
			.69444,
			.01389,
			0,
			.94445
		],
		88: [
			0,
			.69444,
			0,
			0,
			.66667
		],
		89: [
			0,
			.69444,
			.025,
			0,
			.66667
		],
		90: [
			0,
			.69444,
			0,
			0,
			.61111
		],
		91: [
			.25,
			.75,
			0,
			0,
			.28889
		],
		93: [
			.25,
			.75,
			0,
			0,
			.28889
		],
		94: [
			0,
			.69444,
			0,
			0,
			.5
		],
		95: [
			.35,
			.09444,
			.02778,
			0,
			.5
		],
		97: [
			0,
			.44444,
			0,
			0,
			.48056
		],
		98: [
			0,
			.69444,
			0,
			0,
			.51667
		],
		99: [
			0,
			.44444,
			0,
			0,
			.44445
		],
		100: [
			0,
			.69444,
			0,
			0,
			.51667
		],
		101: [
			0,
			.44444,
			0,
			0,
			.44445
		],
		102: [
			0,
			.69444,
			.06944,
			0,
			.30556
		],
		103: [
			.19444,
			.44444,
			.01389,
			0,
			.5
		],
		104: [
			0,
			.69444,
			0,
			0,
			.51667
		],
		105: [
			0,
			.67937,
			0,
			0,
			.23889
		],
		106: [
			.19444,
			.67937,
			0,
			0,
			.26667
		],
		107: [
			0,
			.69444,
			0,
			0,
			.48889
		],
		108: [
			0,
			.69444,
			0,
			0,
			.23889
		],
		109: [
			0,
			.44444,
			0,
			0,
			.79445
		],
		110: [
			0,
			.44444,
			0,
			0,
			.51667
		],
		111: [
			0,
			.44444,
			0,
			0,
			.5
		],
		112: [
			.19444,
			.44444,
			0,
			0,
			.51667
		],
		113: [
			.19444,
			.44444,
			0,
			0,
			.51667
		],
		114: [
			0,
			.44444,
			.01389,
			0,
			.34167
		],
		115: [
			0,
			.44444,
			0,
			0,
			.38333
		],
		116: [
			0,
			.57143,
			0,
			0,
			.36111
		],
		117: [
			0,
			.44444,
			0,
			0,
			.51667
		],
		118: [
			0,
			.44444,
			.01389,
			0,
			.46111
		],
		119: [
			0,
			.44444,
			.01389,
			0,
			.68334
		],
		120: [
			0,
			.44444,
			0,
			0,
			.46111
		],
		121: [
			.19444,
			.44444,
			.01389,
			0,
			.46111
		],
		122: [
			0,
			.44444,
			0,
			0,
			.43472
		],
		126: [
			.35,
			.32659,
			0,
			0,
			.5
		],
		160: [
			0,
			0,
			0,
			0,
			.25
		],
		168: [
			0,
			.67937,
			0,
			0,
			.5
		],
		176: [
			0,
			.69444,
			0,
			0,
			.66667
		],
		184: [
			.17014,
			0,
			0,
			0,
			.44445
		],
		305: [
			0,
			.44444,
			0,
			0,
			.23889
		],
		567: [
			.19444,
			.44444,
			0,
			0,
			.26667
		],
		710: [
			0,
			.69444,
			0,
			0,
			.5
		],
		711: [
			0,
			.63194,
			0,
			0,
			.5
		],
		713: [
			0,
			.60889,
			0,
			0,
			.5
		],
		714: [
			0,
			.69444,
			0,
			0,
			.5
		],
		715: [
			0,
			.69444,
			0,
			0,
			.5
		],
		728: [
			0,
			.69444,
			0,
			0,
			.5
		],
		729: [
			0,
			.67937,
			0,
			0,
			.27778
		],
		730: [
			0,
			.69444,
			0,
			0,
			.66667
		],
		732: [
			0,
			.67659,
			0,
			0,
			.5
		],
		733: [
			0,
			.69444,
			0,
			0,
			.5
		],
		915: [
			0,
			.69444,
			0,
			0,
			.54167
		],
		916: [
			0,
			.69444,
			0,
			0,
			.83334
		],
		920: [
			0,
			.69444,
			0,
			0,
			.77778
		],
		923: [
			0,
			.69444,
			0,
			0,
			.61111
		],
		926: [
			0,
			.69444,
			0,
			0,
			.66667
		],
		928: [
			0,
			.69444,
			0,
			0,
			.70834
		],
		931: [
			0,
			.69444,
			0,
			0,
			.72222
		],
		933: [
			0,
			.69444,
			0,
			0,
			.77778
		],
		934: [
			0,
			.69444,
			0,
			0,
			.72222
		],
		936: [
			0,
			.69444,
			0,
			0,
			.77778
		],
		937: [
			0,
			.69444,
			0,
			0,
			.72222
		],
		8211: [
			0,
			.44444,
			.02778,
			0,
			.5
		],
		8212: [
			0,
			.44444,
			.02778,
			0,
			1
		],
		8216: [
			0,
			.69444,
			0,
			0,
			.27778
		],
		8217: [
			0,
			.69444,
			0,
			0,
			.27778
		],
		8220: [
			0,
			.69444,
			0,
			0,
			.5
		],
		8221: [
			0,
			.69444,
			0,
			0,
			.5
		]
	},
	"Script-Regular": {
		32: [
			0,
			0,
			0,
			0,
			.25
		],
		65: [
			0,
			.7,
			.22925,
			0,
			.80253
		],
		66: [
			0,
			.7,
			.04087,
			0,
			.90757
		],
		67: [
			0,
			.7,
			.1689,
			0,
			.66619
		],
		68: [
			0,
			.7,
			.09371,
			0,
			.77443
		],
		69: [
			0,
			.7,
			.18583,
			0,
			.56162
		],
		70: [
			0,
			.7,
			.13634,
			0,
			.89544
		],
		71: [
			0,
			.7,
			.17322,
			0,
			.60961
		],
		72: [
			0,
			.7,
			.29694,
			0,
			.96919
		],
		73: [
			0,
			.7,
			.19189,
			0,
			.80907
		],
		74: [
			.27778,
			.7,
			.19189,
			0,
			1.05159
		],
		75: [
			0,
			.7,
			.31259,
			0,
			.91364
		],
		76: [
			0,
			.7,
			.19189,
			0,
			.87373
		],
		77: [
			0,
			.7,
			.15981,
			0,
			1.08031
		],
		78: [
			0,
			.7,
			.3525,
			0,
			.9015
		],
		79: [
			0,
			.7,
			.08078,
			0,
			.73787
		],
		80: [
			0,
			.7,
			.08078,
			0,
			1.01262
		],
		81: [
			0,
			.7,
			.03305,
			0,
			.88282
		],
		82: [
			0,
			.7,
			.06259,
			0,
			.85
		],
		83: [
			0,
			.7,
			.19189,
			0,
			.86767
		],
		84: [
			0,
			.7,
			.29087,
			0,
			.74697
		],
		85: [
			0,
			.7,
			.25815,
			0,
			.79996
		],
		86: [
			0,
			.7,
			.27523,
			0,
			.62204
		],
		87: [
			0,
			.7,
			.27523,
			0,
			.80532
		],
		88: [
			0,
			.7,
			.26006,
			0,
			.94445
		],
		89: [
			0,
			.7,
			.2939,
			0,
			.70961
		],
		90: [
			0,
			.7,
			.24037,
			0,
			.8212
		],
		160: [
			0,
			0,
			0,
			0,
			.25
		]
	},
	"Size1-Regular": {
		32: [
			0,
			0,
			0,
			0,
			.25
		],
		40: [
			.35001,
			.85,
			0,
			0,
			.45834
		],
		41: [
			.35001,
			.85,
			0,
			0,
			.45834
		],
		47: [
			.35001,
			.85,
			0,
			0,
			.57778
		],
		91: [
			.35001,
			.85,
			0,
			0,
			.41667
		],
		92: [
			.35001,
			.85,
			0,
			0,
			.57778
		],
		93: [
			.35001,
			.85,
			0,
			0,
			.41667
		],
		123: [
			.35001,
			.85,
			0,
			0,
			.58334
		],
		125: [
			.35001,
			.85,
			0,
			0,
			.58334
		],
		160: [
			0,
			0,
			0,
			0,
			.25
		],
		710: [
			0,
			.72222,
			0,
			0,
			.55556
		],
		732: [
			0,
			.72222,
			0,
			0,
			.55556
		],
		770: [
			0,
			.72222,
			0,
			0,
			.55556
		],
		771: [
			0,
			.72222,
			0,
			0,
			.55556
		],
		8214: [
			-99e-5,
			.601,
			0,
			0,
			.77778
		],
		8593: [
			1e-5,
			.6,
			0,
			0,
			.66667
		],
		8595: [
			1e-5,
			.6,
			0,
			0,
			.66667
		],
		8657: [
			1e-5,
			.6,
			0,
			0,
			.77778
		],
		8659: [
			1e-5,
			.6,
			0,
			0,
			.77778
		],
		8719: [
			.25001,
			.75,
			0,
			0,
			.94445
		],
		8720: [
			.25001,
			.75,
			0,
			0,
			.94445
		],
		8721: [
			.25001,
			.75,
			0,
			0,
			1.05556
		],
		8730: [
			.35001,
			.85,
			0,
			0,
			1
		],
		8739: [
			-.00599,
			.606,
			0,
			0,
			.33333
		],
		8741: [
			-.00599,
			.606,
			0,
			0,
			.55556
		],
		8747: [
			.30612,
			.805,
			.19445,
			0,
			.47222
		],
		8748: [
			.306,
			.805,
			.19445,
			0,
			.47222
		],
		8749: [
			.306,
			.805,
			.19445,
			0,
			.47222
		],
		8750: [
			.30612,
			.805,
			.19445,
			0,
			.47222
		],
		8896: [
			.25001,
			.75,
			0,
			0,
			.83334
		],
		8897: [
			.25001,
			.75,
			0,
			0,
			.83334
		],
		8898: [
			.25001,
			.75,
			0,
			0,
			.83334
		],
		8899: [
			.25001,
			.75,
			0,
			0,
			.83334
		],
		8968: [
			.35001,
			.85,
			0,
			0,
			.47222
		],
		8969: [
			.35001,
			.85,
			0,
			0,
			.47222
		],
		8970: [
			.35001,
			.85,
			0,
			0,
			.47222
		],
		8971: [
			.35001,
			.85,
			0,
			0,
			.47222
		],
		9168: [
			-99e-5,
			.601,
			0,
			0,
			.66667
		],
		10216: [
			.35001,
			.85,
			0,
			0,
			.47222
		],
		10217: [
			.35001,
			.85,
			0,
			0,
			.47222
		],
		10752: [
			.25001,
			.75,
			0,
			0,
			1.11111
		],
		10753: [
			.25001,
			.75,
			0,
			0,
			1.11111
		],
		10754: [
			.25001,
			.75,
			0,
			0,
			1.11111
		],
		10756: [
			.25001,
			.75,
			0,
			0,
			.83334
		],
		10758: [
			.25001,
			.75,
			0,
			0,
			.83334
		]
	},
	"Size2-Regular": {
		32: [
			0,
			0,
			0,
			0,
			.25
		],
		40: [
			.65002,
			1.15,
			0,
			0,
			.59722
		],
		41: [
			.65002,
			1.15,
			0,
			0,
			.59722
		],
		47: [
			.65002,
			1.15,
			0,
			0,
			.81111
		],
		91: [
			.65002,
			1.15,
			0,
			0,
			.47222
		],
		92: [
			.65002,
			1.15,
			0,
			0,
			.81111
		],
		93: [
			.65002,
			1.15,
			0,
			0,
			.47222
		],
		123: [
			.65002,
			1.15,
			0,
			0,
			.66667
		],
		125: [
			.65002,
			1.15,
			0,
			0,
			.66667
		],
		160: [
			0,
			0,
			0,
			0,
			.25
		],
		710: [
			0,
			.75,
			0,
			0,
			1
		],
		732: [
			0,
			.75,
			0,
			0,
			1
		],
		770: [
			0,
			.75,
			0,
			0,
			1
		],
		771: [
			0,
			.75,
			0,
			0,
			1
		],
		8719: [
			.55001,
			1.05,
			0,
			0,
			1.27778
		],
		8720: [
			.55001,
			1.05,
			0,
			0,
			1.27778
		],
		8721: [
			.55001,
			1.05,
			0,
			0,
			1.44445
		],
		8730: [
			.65002,
			1.15,
			0,
			0,
			1
		],
		8747: [
			.86225,
			1.36,
			.44445,
			0,
			.55556
		],
		8748: [
			.862,
			1.36,
			.44445,
			0,
			.55556
		],
		8749: [
			.862,
			1.36,
			.44445,
			0,
			.55556
		],
		8750: [
			.86225,
			1.36,
			.44445,
			0,
			.55556
		],
		8896: [
			.55001,
			1.05,
			0,
			0,
			1.11111
		],
		8897: [
			.55001,
			1.05,
			0,
			0,
			1.11111
		],
		8898: [
			.55001,
			1.05,
			0,
			0,
			1.11111
		],
		8899: [
			.55001,
			1.05,
			0,
			0,
			1.11111
		],
		8968: [
			.65002,
			1.15,
			0,
			0,
			.52778
		],
		8969: [
			.65002,
			1.15,
			0,
			0,
			.52778
		],
		8970: [
			.65002,
			1.15,
			0,
			0,
			.52778
		],
		8971: [
			.65002,
			1.15,
			0,
			0,
			.52778
		],
		10216: [
			.65002,
			1.15,
			0,
			0,
			.61111
		],
		10217: [
			.65002,
			1.15,
			0,
			0,
			.61111
		],
		10752: [
			.55001,
			1.05,
			0,
			0,
			1.51112
		],
		10753: [
			.55001,
			1.05,
			0,
			0,
			1.51112
		],
		10754: [
			.55001,
			1.05,
			0,
			0,
			1.51112
		],
		10756: [
			.55001,
			1.05,
			0,
			0,
			1.11111
		],
		10758: [
			.55001,
			1.05,
			0,
			0,
			1.11111
		]
	},
	"Size3-Regular": {
		32: [
			0,
			0,
			0,
			0,
			.25
		],
		40: [
			.95003,
			1.45,
			0,
			0,
			.73611
		],
		41: [
			.95003,
			1.45,
			0,
			0,
			.73611
		],
		47: [
			.95003,
			1.45,
			0,
			0,
			1.04445
		],
		91: [
			.95003,
			1.45,
			0,
			0,
			.52778
		],
		92: [
			.95003,
			1.45,
			0,
			0,
			1.04445
		],
		93: [
			.95003,
			1.45,
			0,
			0,
			.52778
		],
		123: [
			.95003,
			1.45,
			0,
			0,
			.75
		],
		125: [
			.95003,
			1.45,
			0,
			0,
			.75
		],
		160: [
			0,
			0,
			0,
			0,
			.25
		],
		710: [
			0,
			.75,
			0,
			0,
			1.44445
		],
		732: [
			0,
			.75,
			0,
			0,
			1.44445
		],
		770: [
			0,
			.75,
			0,
			0,
			1.44445
		],
		771: [
			0,
			.75,
			0,
			0,
			1.44445
		],
		8730: [
			.95003,
			1.45,
			0,
			0,
			1
		],
		8968: [
			.95003,
			1.45,
			0,
			0,
			.58334
		],
		8969: [
			.95003,
			1.45,
			0,
			0,
			.58334
		],
		8970: [
			.95003,
			1.45,
			0,
			0,
			.58334
		],
		8971: [
			.95003,
			1.45,
			0,
			0,
			.58334
		],
		10216: [
			.95003,
			1.45,
			0,
			0,
			.75
		],
		10217: [
			.95003,
			1.45,
			0,
			0,
			.75
		]
	},
	"Size4-Regular": {
		32: [
			0,
			0,
			0,
			0,
			.25
		],
		40: [
			1.25003,
			1.75,
			0,
			0,
			.79167
		],
		41: [
			1.25003,
			1.75,
			0,
			0,
			.79167
		],
		47: [
			1.25003,
			1.75,
			0,
			0,
			1.27778
		],
		91: [
			1.25003,
			1.75,
			0,
			0,
			.58334
		],
		92: [
			1.25003,
			1.75,
			0,
			0,
			1.27778
		],
		93: [
			1.25003,
			1.75,
			0,
			0,
			.58334
		],
		123: [
			1.25003,
			1.75,
			0,
			0,
			.80556
		],
		125: [
			1.25003,
			1.75,
			0,
			0,
			.80556
		],
		160: [
			0,
			0,
			0,
			0,
			.25
		],
		710: [
			0,
			.825,
			0,
			0,
			1.8889
		],
		732: [
			0,
			.825,
			0,
			0,
			1.8889
		],
		770: [
			0,
			.825,
			0,
			0,
			1.8889
		],
		771: [
			0,
			.825,
			0,
			0,
			1.8889
		],
		8730: [
			1.25003,
			1.75,
			0,
			0,
			1
		],
		8968: [
			1.25003,
			1.75,
			0,
			0,
			.63889
		],
		8969: [
			1.25003,
			1.75,
			0,
			0,
			.63889
		],
		8970: [
			1.25003,
			1.75,
			0,
			0,
			.63889
		],
		8971: [
			1.25003,
			1.75,
			0,
			0,
			.63889
		],
		9115: [
			.64502,
			1.155,
			0,
			0,
			.875
		],
		9116: [
			1e-5,
			.6,
			0,
			0,
			.875
		],
		9117: [
			.64502,
			1.155,
			0,
			0,
			.875
		],
		9118: [
			.64502,
			1.155,
			0,
			0,
			.875
		],
		9119: [
			1e-5,
			.6,
			0,
			0,
			.875
		],
		9120: [
			.64502,
			1.155,
			0,
			0,
			.875
		],
		9121: [
			.64502,
			1.155,
			0,
			0,
			.66667
		],
		9122: [
			-99e-5,
			.601,
			0,
			0,
			.66667
		],
		9123: [
			.64502,
			1.155,
			0,
			0,
			.66667
		],
		9124: [
			.64502,
			1.155,
			0,
			0,
			.66667
		],
		9125: [
			-99e-5,
			.601,
			0,
			0,
			.66667
		],
		9126: [
			.64502,
			1.155,
			0,
			0,
			.66667
		],
		9127: [
			1e-5,
			.9,
			0,
			0,
			.88889
		],
		9128: [
			.65002,
			1.15,
			0,
			0,
			.88889
		],
		9129: [
			.90001,
			0,
			0,
			0,
			.88889
		],
		9130: [
			0,
			.3,
			0,
			0,
			.88889
		],
		9131: [
			1e-5,
			.9,
			0,
			0,
			.88889
		],
		9132: [
			.65002,
			1.15,
			0,
			0,
			.88889
		],
		9133: [
			.90001,
			0,
			0,
			0,
			.88889
		],
		9143: [
			.88502,
			.915,
			0,
			0,
			1.05556
		],
		10216: [
			1.25003,
			1.75,
			0,
			0,
			.80556
		],
		10217: [
			1.25003,
			1.75,
			0,
			0,
			.80556
		],
		57344: [
			-.00499,
			.605,
			0,
			0,
			1.05556
		],
		57345: [
			-.00499,
			.605,
			0,
			0,
			1.05556
		],
		57680: [
			0,
			.12,
			0,
			0,
			.45
		],
		57681: [
			0,
			.12,
			0,
			0,
			.45
		],
		57682: [
			0,
			.12,
			0,
			0,
			.45
		],
		57683: [
			0,
			.12,
			0,
			0,
			.45
		]
	},
	"Typewriter-Regular": {
		32: [
			0,
			0,
			0,
			0,
			.525
		],
		33: [
			0,
			.61111,
			0,
			0,
			.525
		],
		34: [
			0,
			.61111,
			0,
			0,
			.525
		],
		35: [
			0,
			.61111,
			0,
			0,
			.525
		],
		36: [
			.08333,
			.69444,
			0,
			0,
			.525
		],
		37: [
			.08333,
			.69444,
			0,
			0,
			.525
		],
		38: [
			0,
			.61111,
			0,
			0,
			.525
		],
		39: [
			0,
			.61111,
			0,
			0,
			.525
		],
		40: [
			.08333,
			.69444,
			0,
			0,
			.525
		],
		41: [
			.08333,
			.69444,
			0,
			0,
			.525
		],
		42: [
			0,
			.52083,
			0,
			0,
			.525
		],
		43: [
			-.08056,
			.53055,
			0,
			0,
			.525
		],
		44: [
			.13889,
			.125,
			0,
			0,
			.525
		],
		45: [
			-.08056,
			.53055,
			0,
			0,
			.525
		],
		46: [
			0,
			.125,
			0,
			0,
			.525
		],
		47: [
			.08333,
			.69444,
			0,
			0,
			.525
		],
		48: [
			0,
			.61111,
			0,
			0,
			.525
		],
		49: [
			0,
			.61111,
			0,
			0,
			.525
		],
		50: [
			0,
			.61111,
			0,
			0,
			.525
		],
		51: [
			0,
			.61111,
			0,
			0,
			.525
		],
		52: [
			0,
			.61111,
			0,
			0,
			.525
		],
		53: [
			0,
			.61111,
			0,
			0,
			.525
		],
		54: [
			0,
			.61111,
			0,
			0,
			.525
		],
		55: [
			0,
			.61111,
			0,
			0,
			.525
		],
		56: [
			0,
			.61111,
			0,
			0,
			.525
		],
		57: [
			0,
			.61111,
			0,
			0,
			.525
		],
		58: [
			0,
			.43056,
			0,
			0,
			.525
		],
		59: [
			.13889,
			.43056,
			0,
			0,
			.525
		],
		60: [
			-.05556,
			.55556,
			0,
			0,
			.525
		],
		61: [
			-.19549,
			.41562,
			0,
			0,
			.525
		],
		62: [
			-.05556,
			.55556,
			0,
			0,
			.525
		],
		63: [
			0,
			.61111,
			0,
			0,
			.525
		],
		64: [
			0,
			.61111,
			0,
			0,
			.525
		],
		65: [
			0,
			.61111,
			0,
			0,
			.525
		],
		66: [
			0,
			.61111,
			0,
			0,
			.525
		],
		67: [
			0,
			.61111,
			0,
			0,
			.525
		],
		68: [
			0,
			.61111,
			0,
			0,
			.525
		],
		69: [
			0,
			.61111,
			0,
			0,
			.525
		],
		70: [
			0,
			.61111,
			0,
			0,
			.525
		],
		71: [
			0,
			.61111,
			0,
			0,
			.525
		],
		72: [
			0,
			.61111,
			0,
			0,
			.525
		],
		73: [
			0,
			.61111,
			0,
			0,
			.525
		],
		74: [
			0,
			.61111,
			0,
			0,
			.525
		],
		75: [
			0,
			.61111,
			0,
			0,
			.525
		],
		76: [
			0,
			.61111,
			0,
			0,
			.525
		],
		77: [
			0,
			.61111,
			0,
			0,
			.525
		],
		78: [
			0,
			.61111,
			0,
			0,
			.525
		],
		79: [
			0,
			.61111,
			0,
			0,
			.525
		],
		80: [
			0,
			.61111,
			0,
			0,
			.525
		],
		81: [
			.13889,
			.61111,
			0,
			0,
			.525
		],
		82: [
			0,
			.61111,
			0,
			0,
			.525
		],
		83: [
			0,
			.61111,
			0,
			0,
			.525
		],
		84: [
			0,
			.61111,
			0,
			0,
			.525
		],
		85: [
			0,
			.61111,
			0,
			0,
			.525
		],
		86: [
			0,
			.61111,
			0,
			0,
			.525
		],
		87: [
			0,
			.61111,
			0,
			0,
			.525
		],
		88: [
			0,
			.61111,
			0,
			0,
			.525
		],
		89: [
			0,
			.61111,
			0,
			0,
			.525
		],
		90: [
			0,
			.61111,
			0,
			0,
			.525
		],
		91: [
			.08333,
			.69444,
			0,
			0,
			.525
		],
		92: [
			.08333,
			.69444,
			0,
			0,
			.525
		],
		93: [
			.08333,
			.69444,
			0,
			0,
			.525
		],
		94: [
			0,
			.61111,
			0,
			0,
			.525
		],
		95: [
			.09514,
			0,
			0,
			0,
			.525
		],
		96: [
			0,
			.61111,
			0,
			0,
			.525
		],
		97: [
			0,
			.43056,
			0,
			0,
			.525
		],
		98: [
			0,
			.61111,
			0,
			0,
			.525
		],
		99: [
			0,
			.43056,
			0,
			0,
			.525
		],
		100: [
			0,
			.61111,
			0,
			0,
			.525
		],
		101: [
			0,
			.43056,
			0,
			0,
			.525
		],
		102: [
			0,
			.61111,
			0,
			0,
			.525
		],
		103: [
			.22222,
			.43056,
			0,
			0,
			.525
		],
		104: [
			0,
			.61111,
			0,
			0,
			.525
		],
		105: [
			0,
			.61111,
			0,
			0,
			.525
		],
		106: [
			.22222,
			.61111,
			0,
			0,
			.525
		],
		107: [
			0,
			.61111,
			0,
			0,
			.525
		],
		108: [
			0,
			.61111,
			0,
			0,
			.525
		],
		109: [
			0,
			.43056,
			0,
			0,
			.525
		],
		110: [
			0,
			.43056,
			0,
			0,
			.525
		],
		111: [
			0,
			.43056,
			0,
			0,
			.525
		],
		112: [
			.22222,
			.43056,
			0,
			0,
			.525
		],
		113: [
			.22222,
			.43056,
			0,
			0,
			.525
		],
		114: [
			0,
			.43056,
			0,
			0,
			.525
		],
		115: [
			0,
			.43056,
			0,
			0,
			.525
		],
		116: [
			0,
			.55358,
			0,
			0,
			.525
		],
		117: [
			0,
			.43056,
			0,
			0,
			.525
		],
		118: [
			0,
			.43056,
			0,
			0,
			.525
		],
		119: [
			0,
			.43056,
			0,
			0,
			.525
		],
		120: [
			0,
			.43056,
			0,
			0,
			.525
		],
		121: [
			.22222,
			.43056,
			0,
			0,
			.525
		],
		122: [
			0,
			.43056,
			0,
			0,
			.525
		],
		123: [
			.08333,
			.69444,
			0,
			0,
			.525
		],
		124: [
			.08333,
			.69444,
			0,
			0,
			.525
		],
		125: [
			.08333,
			.69444,
			0,
			0,
			.525
		],
		126: [
			0,
			.61111,
			0,
			0,
			.525
		],
		127: [
			0,
			.61111,
			0,
			0,
			.525
		],
		160: [
			0,
			0,
			0,
			0,
			.525
		],
		176: [
			0,
			.61111,
			0,
			0,
			.525
		],
		184: [
			.19445,
			0,
			0,
			0,
			.525
		],
		305: [
			0,
			.43056,
			0,
			0,
			.525
		],
		567: [
			.22222,
			.43056,
			0,
			0,
			.525
		],
		711: [
			0,
			.56597,
			0,
			0,
			.525
		],
		713: [
			0,
			.56555,
			0,
			0,
			.525
		],
		714: [
			0,
			.61111,
			0,
			0,
			.525
		],
		715: [
			0,
			.61111,
			0,
			0,
			.525
		],
		728: [
			0,
			.61111,
			0,
			0,
			.525
		],
		730: [
			0,
			.61111,
			0,
			0,
			.525
		],
		770: [
			0,
			.61111,
			0,
			0,
			.525
		],
		771: [
			0,
			.61111,
			0,
			0,
			.525
		],
		776: [
			0,
			.61111,
			0,
			0,
			.525
		],
		915: [
			0,
			.61111,
			0,
			0,
			.525
		],
		916: [
			0,
			.61111,
			0,
			0,
			.525
		],
		920: [
			0,
			.61111,
			0,
			0,
			.525
		],
		923: [
			0,
			.61111,
			0,
			0,
			.525
		],
		926: [
			0,
			.61111,
			0,
			0,
			.525
		],
		928: [
			0,
			.61111,
			0,
			0,
			.525
		],
		931: [
			0,
			.61111,
			0,
			0,
			.525
		],
		933: [
			0,
			.61111,
			0,
			0,
			.525
		],
		934: [
			0,
			.61111,
			0,
			0,
			.525
		],
		936: [
			0,
			.61111,
			0,
			0,
			.525
		],
		937: [
			0,
			.61111,
			0,
			0,
			.525
		],
		8216: [
			0,
			.61111,
			0,
			0,
			.525
		],
		8217: [
			0,
			.61111,
			0,
			0,
			.525
		],
		8242: [
			0,
			.61111,
			0,
			0,
			.525
		],
		9251: [
			.11111,
			.21944,
			0,
			0,
			.525
		]
	}
}, ed6 = {
	slant: [
		.25,
		.25,
		.25
	],
	space: [
		0,
		0,
		0
	],
	stretch: [
		0,
		0,
		0
	],
	shrink: [
		0,
		0,
		0
	],
	xHeight: [
		.431,
		.431,
		.431
	],
	quad: [
		1,
		1.171,
		1.472
	],
	extraSpace: [
		0,
		0,
		0
	],
	num1: [
		.677,
		.732,
		.925
	],
	num2: [
		.394,
		.384,
		.387
	],
	num3: [
		.444,
		.471,
		.504
	],
	denom1: [
		.686,
		.752,
		1.025
	],
	denom2: [
		.345,
		.344,
		.532
	],
	sup1: [
		.413,
		.503,
		.504
	],
	sup2: [
		.363,
		.431,
		.404
	],
	sup3: [
		.289,
		.286,
		.294
	],
	sub1: [
		.15,
		.143,
		.2
	],
	sub2: [
		.247,
		.286,
		.4
	],
	supDrop: [
		.386,
		.353,
		.494
	],
	subDrop: [
		.05,
		.071,
		.1
	],
	delim1: [
		2.39,
		1.7,
		1.98
	],
	delim2: [
		1.01,
		1.157,
		1.42
	],
	axisHeight: [
		.25,
		.25,
		.25
	],
	defaultRuleThickness: [
		.04,
		.049,
		.049
	],
	bigOpSpacing1: [
		.111,
		.111,
		.111
	],
	bigOpSpacing2: [
		.166,
		.166,
		.166
	],
	bigOpSpacing3: [
		.2,
		.2,
		.2
	],
	bigOpSpacing4: [
		.6,
		.611,
		.611
	],
	bigOpSpacing5: [
		.1,
		.143,
		.143
	],
	sqrtRuleThickness: [
		.04,
		.04,
		.04
	],
	ptPerEm: [
		10,
		10,
		10
	],
	doubleRuleSep: [
		.2,
		.2,
		.2
	],
	arrayRuleWidth: [
		.04,
		.04,
		.04
	],
	fboxsep: [
		.3,
		.3,
		.3
	],
	fboxrule: [
		.04,
		.04,
		.04
	]
}, ed7 = {
	: "A",
	: "D",
	: "o",
	: "a",
	: "d",
	: "o",
	: "A",
	: "B",
	: "B",
	: "F",
	: "A",
	: "E",
	: "K",
	: "3",
	: "N",
	: "N",
	: "K",
	: "N",
	: "M",
	: "H",
	: "O",
	: "N",
	: "P",
	: "C",
	: "T",
	: "y",
	: "O",
	: "X",
	: "U",
	: "h",
	: "W",
	: "W",
	: "B",
	: "X",
	: "B",
	: "3",
	: "X",
	: "R",
	: "a",
	: "b",
	: "a",
	: "r",
	: "y",
	: "e",
	: "m",
	: "e",
	: "n",
	: "n",
	: "n",
	: "n",
	: "m",
	: "n",
	: "o",
	: "n",
	: "p",
	: "c",
	: "o",
	: "y",
	: "b",
	: "x",
	: "n",
	: "n",
	: "w",
	: "w",
	: "a",
	: "m",
	: "a",
	: "e",
	: "m",
	: "r"
};
function ed8(e, t) {
	ed3[e] = t;
}
function ed9(e, t, r) {
	if (!ed3[t]) throw Error("Font metrics not found for font: " + t + ".");
	var i = e.charCodeAt(0), n = ed3[t][i];
	if (!n && e[0] in ed7 && (i = ed7[e[0]].charCodeAt(0), n = ed3[t][i]), !n && "text" === r && edY(i) && (n = ed3[t][77]), n) return {
		depth: n[0],
		height: n[1],
		italic: n[2],
		skew: n[3],
		width: n[4]
	};
}
h(ed8, "setFontMetrics"), h(ed9, "getCharacterMetrics");
var epe = {};
function ept(e) {
	var t;
	if (!epe[t = e >= 5 ? 0 : e >= 3 ? 1 : 2]) {
		var r = epe[t] = { cssEmPerMu: ed6.quad[t] / 18 };
		for (var i in ed6) ed6.hasOwnProperty(i) && (r[i] = ed6[i][t]);
	}
	return epe[t];
}
h(ept, "getGlobalMetrics");
var epr = [
	[
		1,
		1,
		1
	],
	[
		2,
		1,
		1
	],
	[
		3,
		1,
		1
	],
	[
		4,
		2,
		1
	],
	[
		5,
		2,
		1
	],
	[
		6,
		3,
		1
	],
	[
		7,
		4,
		2
	],
	[
		8,
		6,
		3
	],
	[
		9,
		7,
		6
	],
	[
		10,
		8,
		7
	],
	[
		11,
		10,
		9
	]
], epi = [
	.5,
	.6,
	.7,
	.8,
	.9,
	1,
	1.2,
	1.44,
	1.728,
	2.074,
	2.488
], epn = h(function(e, t) {
	return t.size < 2 ? e : epr[e - 1][t.size - 1];
}, "sizeAtStyle"), epa = class e {
	static {
		h(this, "Options");
	}
	constructor(t) {
		this.style = void 0, this.color = void 0, this.size = void 0, this.textSize = void 0, this.phantom = void 0, this.font = void 0, this.fontFamily = void 0, this.fontWeight = void 0, this.fontShape = void 0, this.sizeMultiplier = void 0, this.maxSize = void 0, this.minRuleThickness = void 0, this._fontMetrics = void 0, this.style = t.style, this.color = t.color, this.size = t.size || e.BASESIZE, this.textSize = t.textSize || this.size, this.phantom = !!t.phantom, this.font = t.font || "", this.fontFamily = t.fontFamily || "", this.fontWeight = t.fontWeight || "", this.fontShape = t.fontShape || "", this.sizeMultiplier = epi[this.size - 1], this.maxSize = t.maxSize, this.minRuleThickness = t.minRuleThickness, this._fontMetrics = void 0;
	}
	extend(t) {
		var r = {
			style: this.style,
			size: this.size,
			textSize: this.textSize,
			color: this.color,
			phantom: this.phantom,
			font: this.font,
			fontFamily: this.fontFamily,
			fontWeight: this.fontWeight,
			fontShape: this.fontShape,
			maxSize: this.maxSize,
			minRuleThickness: this.minRuleThickness
		};
		for (var i in t) t.hasOwnProperty(i) && (r[i] = t[i]);
		return new e(r);
	}
	havingStyle(e) {
		return this.style === e ? this : this.extend({
			style: e,
			size: epn(this.textSize, e)
		});
	}
	havingCrampedStyle() {
		return this.havingStyle(this.style.cramp());
	}
	havingSize(e) {
		return this.size === e && this.textSize === e ? this : this.extend({
			style: this.style.text(),
			size: e,
			textSize: e,
			sizeMultiplier: epi[e - 1]
		});
	}
	havingBaseStyle(t) {
		t = t || this.style.text();
		var r = epn(e.BASESIZE, t);
		return this.size === r && this.textSize === e.BASESIZE && this.style === t ? this : this.extend({
			style: t,
			size: r
		});
	}
	havingBaseSizing() {
		var e;
		switch (this.style.id) {
			case 4:
			case 5:
				e = 3;
				break;
			case 6:
			case 7:
				e = 1;
				break;
			default: e = 6;
		}
		return this.extend({
			style: this.style.text(),
			size: e
		});
	}
	withColor(e) {
		return this.extend({ color: e });
	}
	withPhantom() {
		return this.extend({ phantom: !0 });
	}
	withFont(e) {
		return this.extend({ font: e });
	}
	withTextFontFamily(e) {
		return this.extend({
			fontFamily: e,
			font: ""
		});
	}
	withTextFontWeight(e) {
		return this.extend({
			fontWeight: e,
			font: ""
		});
	}
	withTextFontShape(e) {
		return this.extend({
			fontShape: e,
			font: ""
		});
	}
	sizingClasses(e) {
		return e.size !== this.size ? [
			"sizing",
			"reset-size" + e.size,
			"size" + this.size
		] : [];
	}
	baseSizingClasses() {
		return this.size !== e.BASESIZE ? [
			"sizing",
			"reset-size" + this.size,
			"size" + e.BASESIZE
		] : [];
	}
	fontMetrics() {
		return this._fontMetrics || (this._fontMetrics = ept(this.size)), this._fontMetrics;
	}
	getColor() {
		return this.phantom ? "transparent" : this.color;
	}
};
epa.BASESIZE = 6;
var eps = {
	pt: 1,
	mm: 7227 / 2540,
	cm: 7227 / 254,
	in: 72.27,
	bp: 1.00375,
	pc: 12,
	dd: 1238 / 1157,
	cc: 14856 / 1157,
	nd: 685 / 642,
	nc: 1370 / 107,
	sp: 1 / 65536,
	px: 1.00375
}, epo = {
	ex: !0,
	em: !0,
	mu: !0
}, epl = h(function(e) {
	return "string" != typeof e && (e = e.unit), e in eps || e in epo || "ex" === e;
}, "validUnit"), epc = h(function(e, t) {
	var r, i;
	if (e.unit in eps) r = eps[e.unit] / t.fontMetrics().ptPerEm / t.sizeMultiplier;
	else if ("mu" === e.unit) r = t.fontMetrics().cssEmPerMu;
	else {
		if (i = t.style.isTight() ? t.havingStyle(t.style.text()) : t, "ex" === e.unit) r = i.fontMetrics().xHeight;
		else if ("em" === e.unit) r = i.fontMetrics().quad;
		else throw new edx("Invalid unit: '" + e.unit + "'");
		i !== t && (r *= i.sizeMultiplier / t.sizeMultiplier);
	}
	return Math.min(e.number * r, t.maxSize);
}, "calculateSize"), eph = h(function(e) {
	return +e.toFixed(4) + "em";
}, "makeEm"), epu = h(function(e) {
	return e.filter((e) => e).join(" ");
}, "createClass"), epd = h(function(e, t, r) {
	if (this.classes = e || [], this.attributes = {}, this.height = 0, this.depth = 0, this.maxFontSize = 0, this.style = r || {}, t) {
		t.style.isTight() && this.classes.push("mtight");
		var i = t.getColor();
		i && (this.style.color = i);
	}
}, "initNode"), epp = h(function(e) {
	var t = document.createElement(e);
	for (var r in t.className = epu(this.classes), this.style) this.style.hasOwnProperty(r) && (t.style[r] = this.style[r]);
	for (var i in this.attributes) this.attributes.hasOwnProperty(i) && t.setAttribute(i, this.attributes[i]);
	for (var n = 0; n < this.children.length; n++) t.appendChild(this.children[n].toNode());
	return t;
}, "toNode"), epf = /[\s"'>/=\x00-\x1f]/, epg = h(function(e) {
	var t = "<" + e;
	this.classes.length && (t += " class=\"" + edR.escape(epu(this.classes)) + "\"");
	var r = "";
	for (var i in this.style) this.style.hasOwnProperty(i) && (r += edR.hyphenate(i) + ":" + this.style[i] + ";");
	for (var n in r && (t += " style=\"" + edR.escape(r) + "\""), this.attributes) if (this.attributes.hasOwnProperty(n)) {
		if (epf.test(n)) throw new edx("Invalid attribute name '" + n + "'");
		t += " " + n + "=\"" + edR.escape(this.attributes[n]) + "\"";
	}
	t += ">";
	for (var a = 0; a < this.children.length; a++) t += this.children[a].toMarkup();
	return t + ("</" + e) + ">";
}, "toMarkup"), epm = class {
	static {
		h(this, "Span");
	}
	constructor(e, t, r, i) {
		this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.width = void 0, this.maxFontSize = void 0, this.style = void 0, epd.call(this, e, r, i), this.children = t || [];
	}
	setAttribute(e, t) {
		this.attributes[e] = t;
	}
	hasClass(e) {
		return edR.contains(this.classes, e);
	}
	toNode() {
		return epp.call(this, "span");
	}
	toMarkup() {
		return epg.call(this, "span");
	}
}, epy = class {
	static {
		h(this, "Anchor");
	}
	constructor(e, t, r, i) {
		this.children = void 0, this.attributes = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, epd.call(this, t, i), this.children = r || [], this.setAttribute("href", e);
	}
	setAttribute(e, t) {
		this.attributes[e] = t;
	}
	hasClass(e) {
		return edR.contains(this.classes, e);
	}
	toNode() {
		return epp.call(this, "a");
	}
	toMarkup() {
		return epg.call(this, "a");
	}
}, epv = class {
	static {
		h(this, "Img");
	}
	constructor(e, t, r) {
		this.src = void 0, this.alt = void 0, this.classes = void 0, this.height = void 0, this.depth = void 0, this.maxFontSize = void 0, this.style = void 0, this.alt = t, this.src = e, this.classes = ["mord"], this.style = r;
	}
	hasClass(e) {
		return edR.contains(this.classes, e);
	}
	toNode() {
		var e = document.createElement("img");
		for (var t in e.src = this.src, e.alt = this.alt, e.className = "mord", this.style) this.style.hasOwnProperty(t) && (e.style[t] = this.style[t]);
		return e;
	}
	toMarkup() {
		var e = "<img src=\"" + edR.escape(this.src) + "\" alt=\"" + edR.escape(this.alt) + "\"", t = "";
		for (var r in this.style) this.style.hasOwnProperty(r) && (t += edR.hyphenate(r) + ":" + this.style[r] + ";");
		return t && (e += " style=\"" + edR.escape(t) + "\""), e += "'/>";
	}
}, epx = {
	: "",
	: "",
	: "",
	: ""
}, epb = class {
	static {
		h(this, "SymbolNode");
	}
	constructor(e, t, r, i, n, a, s, o) {
		this.text = void 0, this.height = void 0, this.depth = void 0, this.italic = void 0, this.skew = void 0, this.width = void 0, this.maxFontSize = void 0, this.classes = void 0, this.style = void 0, this.text = e, this.height = t || 0, this.depth = r || 0, this.italic = i || 0, this.skew = n || 0, this.width = a || 0, this.classes = s || [], this.style = o || {}, this.maxFontSize = 0;
		var l = edj(this.text.charCodeAt(0));
		l && this.classes.push(l + "_fallback"), /[]/.test(this.text) && (this.text = epx[this.text]);
	}
	hasClass(e) {
		return edR.contains(this.classes, e);
	}
	toNode() {
		var e = document.createTextNode(this.text), t = null;
		for (var r in this.italic > 0 && ((t = document.createElement("span")).style.marginRight = eph(this.italic)), this.classes.length > 0 && ((t = t || document.createElement("span")).className = epu(this.classes)), this.style) this.style.hasOwnProperty(r) && ((t = t || document.createElement("span")).style[r] = this.style[r]);
		return t ? (t.appendChild(e), t) : e;
	}
	toMarkup() {
		var e = !1, t = "<span";
		this.classes.length && (e = !0, t += " class=\"", t += edR.escape(epu(this.classes)), t += "\"");
		var r = "";
		for (var i in this.italic > 0 && (r += "margin-right:" + this.italic + "em;"), this.style) this.style.hasOwnProperty(i) && (r += edR.hyphenate(i) + ":" + this.style[i] + ";");
		r && (e = !0, t += " style=\"" + edR.escape(r) + "\"");
		var n = edR.escape(this.text);
		return e ? (t += ">", t += n, t += "</span>") : n;
	}
}, epw = class {
	static {
		h(this, "SvgNode");
	}
	constructor(e, t) {
		this.children = void 0, this.attributes = void 0, this.children = e || [], this.attributes = t || {};
	}
	toNode() {
		var e = document.createElementNS("http://www.w3.org/2000/svg", "svg");
		for (var t in this.attributes) Object.prototype.hasOwnProperty.call(this.attributes, t) && e.setAttribute(t, this.attributes[t]);
		for (var r = 0; r < this.children.length; r++) e.appendChild(this.children[r].toNode());
		return e;
	}
	toMarkup() {
		var e = "<svg xmlns=\"http://www.w3.org/2000/svg\"";
		for (var t in this.attributes) Object.prototype.hasOwnProperty.call(this.attributes, t) && (e += " " + t + "=\"" + edR.escape(this.attributes[t]) + "\"");
		e += ">";
		for (var r = 0; r < this.children.length; r++) e += this.children[r].toMarkup();
		return e + "</svg>";
	}
}, epk = class {
	static {
		h(this, "PathNode");
	}
	constructor(e, t) {
		this.pathName = void 0, this.alternate = void 0, this.pathName = e, this.alternate = t;
	}
	toNode() {
		var e = document.createElementNS("http://www.w3.org/2000/svg", "path");
		return this.alternate ? e.setAttribute("d", this.alternate) : e.setAttribute("d", ed2[this.pathName]), e;
	}
	toMarkup() {
		return this.alternate ? "<path d=\"" + edR.escape(this.alternate) + "\"/>" : "<path d=\"" + edR.escape(ed2[this.pathName]) + "\"/>";
	}
}, epT = class {
	static {
		h(this, "LineNode");
	}
	constructor(e) {
		this.attributes = void 0, this.attributes = e || {};
	}
	toNode() {
		var e = document.createElementNS("http://www.w3.org/2000/svg", "line");
		for (var t in this.attributes) Object.prototype.hasOwnProperty.call(this.attributes, t) && e.setAttribute(t, this.attributes[t]);
		return e;
	}
	toMarkup() {
		var e = "<line";
		for (var t in this.attributes) Object.prototype.hasOwnProperty.call(this.attributes, t) && (e += " " + t + "=\"" + edR.escape(this.attributes[t]) + "\"");
		return e + "/>";
	}
};
function ep_(e) {
	if (e instanceof epb) return e;
	throw Error("Expected symbolNode but got " + String(e) + ".");
}
function epE(e) {
	if (e instanceof epm) return e;
	throw Error("Expected span<HtmlDomNode> but got " + String(e) + ".");
}
h(ep_, "assertSymbolDomNode"), h(epE, "assertSpan");
var epC = {
	bin: 1,
	close: 1,
	inner: 1,
	open: 1,
	punct: 1,
	rel: 1
}, epS = {
	"accent-token": 1,
	mathord: 1,
	"op-token": 1,
	spacing: 1,
	textord: 1
}, epA = {
	math: {},
	text: {}
};
function epL(e, t, r, i, n, a) {
	epA[e][n] = {
		font: t,
		group: r,
		replace: i
	}, a && i && (epA[e][i] = epA[e][n]);
}
h(epL, "defineSymbol");
var epR = "math", epN = "text", epI = "main", epM = "accent-token", epD = "close", epO = "inner", ep$ = "mathord", epP = "op-token", epB = "open", epF = "punct", epz = "spacing", epU = "textord";
epL(epR, epI, "rel", "", "\\equiv", !0), epL(epR, epI, "rel", "", "\\prec", !0), epL(epR, epI, "rel", "", "\\succ", !0), epL(epR, epI, "rel", "", "\\sim", !0), epL(epR, epI, "rel", "", "\\perp"), epL(epR, epI, "rel", "", "\\preceq", !0), epL(epR, epI, "rel", "", "\\succeq", !0), epL(epR, epI, "rel", "", "\\simeq", !0), epL(epR, epI, "rel", "", "\\mid", !0), epL(epR, epI, "rel", "", "\\ll", !0), epL(epR, epI, "rel", "", "\\gg", !0), epL(epR, epI, "rel", "", "\\asymp", !0), epL(epR, epI, "rel", "", "\\parallel"), epL(epR, epI, "rel", "", "\\bowtie", !0), epL(epR, epI, "rel", "", "\\smile", !0), epL(epR, epI, "rel", "", "\\sqsubseteq", !0), epL(epR, epI, "rel", "", "\\sqsupseteq", !0), epL(epR, epI, "rel", "", "\\doteq", !0), epL(epR, epI, "rel", "", "\\frown", !0), epL(epR, epI, "rel", "", "\\ni", !0), epL(epR, epI, "rel", "", "\\propto", !0), epL(epR, epI, "rel", "", "\\vdash", !0), epL(epR, epI, "rel", "", "\\dashv", !0), epL(epR, epI, "rel", "", "\\owns"), epL(epR, epI, epF, ".", "\\ldotp"), epL(epR, epI, epF, "", "\\cdotp"), epL(epR, epI, epU, "#", "\\#"), epL(epN, epI, epU, "#", "\\#"), epL(epR, epI, epU, "&", "\\&"), epL(epN, epI, epU, "&", "\\&"), epL(epR, epI, epU, "", "\\aleph", !0), epL(epR, epI, epU, "", "\\forall", !0), epL(epR, epI, epU, "", "\\hbar", !0), epL(epR, epI, epU, "", "\\exists", !0), epL(epR, epI, epU, "", "\\nabla", !0), epL(epR, epI, epU, "", "\\flat", !0), epL(epR, epI, epU, "", "\\ell", !0), epL(epR, epI, epU, "", "\\natural", !0), epL(epR, epI, epU, "", "\\clubsuit", !0), epL(epR, epI, epU, "", "\\wp", !0), epL(epR, epI, epU, "", "\\sharp", !0), epL(epR, epI, epU, "", "\\diamondsuit", !0), epL(epR, epI, epU, "", "\\Re", !0), epL(epR, epI, epU, "", "\\heartsuit", !0), epL(epR, epI, epU, "", "\\Im", !0), epL(epR, epI, epU, "", "\\spadesuit", !0), epL(epR, epI, epU, "", "\\S", !0), epL(epN, epI, epU, "", "\\S"), epL(epR, epI, epU, "", "\\P", !0), epL(epN, epI, epU, "", "\\P"), epL(epR, epI, epU, "", "\\dag"), epL(epN, epI, epU, "", "\\dag"), epL(epN, epI, epU, "", "\\textdagger"), epL(epR, epI, epU, "", "\\ddag"), epL(epN, epI, epU, "", "\\ddag"), epL(epN, epI, epU, "", "\\textdaggerdbl"), epL(epR, epI, epD, "", "\\rmoustache", !0), epL(epR, epI, epB, "", "\\lmoustache", !0), epL(epR, epI, epD, "", "\\rgroup", !0), epL(epR, epI, epB, "", "\\lgroup", !0), epL(epR, epI, "bin", "", "\\mp", !0), epL(epR, epI, "bin", "", "\\ominus", !0), epL(epR, epI, "bin", "", "\\uplus", !0), epL(epR, epI, "bin", "", "\\sqcap", !0), epL(epR, epI, "bin", "", "\\ast"), epL(epR, epI, "bin", "", "\\sqcup", !0), epL(epR, epI, "bin", "", "\\bigcirc", !0), epL(epR, epI, "bin", "", "\\bullet", !0), epL(epR, epI, "bin", "", "\\ddagger"), epL(epR, epI, "bin", "", "\\wr", !0), epL(epR, epI, "bin", "", "\\amalg"), epL(epR, epI, "bin", "&", "\\And"), epL(epR, epI, "rel", "", "\\longleftarrow", !0), epL(epR, epI, "rel", "", "\\Leftarrow", !0), epL(epR, epI, "rel", "", "\\Longleftarrow", !0), epL(epR, epI, "rel", "", "\\longrightarrow", !0), epL(epR, epI, "rel", "", "\\Rightarrow", !0), epL(epR, epI, "rel", "", "\\Longrightarrow", !0), epL(epR, epI, "rel", "", "\\leftrightarrow", !0), epL(epR, epI, "rel", "", "\\longleftrightarrow", !0), epL(epR, epI, "rel", "", "\\Leftrightarrow", !0), epL(epR, epI, "rel", "", "\\Longleftrightarrow", !0), epL(epR, epI, "rel", "", "\\mapsto", !0), epL(epR, epI, "rel", "", "\\longmapsto", !0), epL(epR, epI, "rel", "", "\\nearrow", !0), epL(epR, epI, "rel", "", "\\hookleftarrow", !0), epL(epR, epI, "rel", "", "\\hookrightarrow", !0), epL(epR, epI, "rel", "", "\\searrow", !0), epL(epR, epI, "rel", "", "\\leftharpoonup", !0), epL(epR, epI, "rel", "", "\\rightharpoonup", !0), epL(epR, epI, "rel", "", "\\swarrow", !0), epL(epR, epI, "rel", "", "\\leftharpoondown", !0), epL(epR, epI, "rel", "", "\\rightharpoondown", !0), epL(epR, epI, "rel", "", "\\nwarrow", !0), epL(epR, epI, "rel", "", "\\rightleftharpoons", !0), epL(epR, "ams", "rel", "", "\\nless", !0), epL(epR, "ams", "rel", "", "\\@nleqslant"), epL(epR, "ams", "rel", "", "\\@nleqq"), epL(epR, "ams", "rel", "", "\\lneq", !0), epL(epR, "ams", "rel", "", "\\lneqq", !0), epL(epR, "ams", "rel", "", "\\@lvertneqq"), epL(epR, "ams", "rel", "", "\\lnsim", !0), epL(epR, "ams", "rel", "", "\\lnapprox", !0), epL(epR, "ams", "rel", "", "\\nprec", !0), epL(epR, "ams", "rel", "", "\\npreceq", !0), epL(epR, "ams", "rel", "", "\\precnsim", !0), epL(epR, "ams", "rel", "", "\\precnapprox", !0), epL(epR, "ams", "rel", "", "\\nsim", !0), epL(epR, "ams", "rel", "", "\\@nshortmid"), epL(epR, "ams", "rel", "", "\\nmid", !0), epL(epR, "ams", "rel", "", "\\nvdash", !0), epL(epR, "ams", "rel", "", "\\nvDash", !0), epL(epR, "ams", "rel", "", "\\ntriangleleft"), epL(epR, "ams", "rel", "", "\\ntrianglelefteq", !0), epL(epR, "ams", "rel", "", "\\subsetneq", !0), epL(epR, "ams", "rel", "", "\\@varsubsetneq"), epL(epR, "ams", "rel", "", "\\subsetneqq", !0), epL(epR, "ams", "rel", "", "\\@varsubsetneqq"), epL(epR, "ams", "rel", "", "\\ngtr", !0), epL(epR, "ams", "rel", "", "\\@ngeqslant"), epL(epR, "ams", "rel", "", "\\@ngeqq"), epL(epR, "ams", "rel", "", "\\gneq", !0), epL(epR, "ams", "rel", "", "\\gneqq", !0), epL(epR, "ams", "rel", "", "\\@gvertneqq"), epL(epR, "ams", "rel", "", "\\gnsim", !0), epL(epR, "ams", "rel", "", "\\gnapprox", !0), epL(epR, "ams", "rel", "", "\\nsucc", !0), epL(epR, "ams", "rel", "", "\\nsucceq", !0), epL(epR, "ams", "rel", "", "\\succnsim", !0), epL(epR, "ams", "rel", "", "\\succnapprox", !0), epL(epR, "ams", "rel", "", "\\ncong", !0), epL(epR, "ams", "rel", "", "\\@nshortparallel"), epL(epR, "ams", "rel", "", "\\nparallel", !0), epL(epR, "ams", "rel", "", "\\nVDash", !0), epL(epR, "ams", "rel", "", "\\ntriangleright"), epL(epR, "ams", "rel", "", "\\ntrianglerighteq", !0), epL(epR, "ams", "rel", "", "\\@nsupseteqq"), epL(epR, "ams", "rel", "", "\\supsetneq", !0), epL(epR, "ams", "rel", "", "\\@varsupsetneq"), epL(epR, "ams", "rel", "", "\\supsetneqq", !0), epL(epR, "ams", "rel", "", "\\@varsupsetneqq"), epL(epR, "ams", "rel", "", "\\nVdash", !0), epL(epR, "ams", "rel", "", "\\precneqq", !0), epL(epR, "ams", "rel", "", "\\succneqq", !0), epL(epR, "ams", "rel", "", "\\@nsubseteqq"), epL(epR, "ams", "bin", "", "\\unlhd"), epL(epR, "ams", "bin", "", "\\unrhd"), epL(epR, "ams", "rel", "", "\\nleftarrow", !0), epL(epR, "ams", "rel", "", "\\nrightarrow", !0), epL(epR, "ams", "rel", "", "\\nLeftarrow", !0), epL(epR, "ams", "rel", "", "\\nRightarrow", !0), epL(epR, "ams", "rel", "", "\\nleftrightarrow", !0), epL(epR, "ams", "rel", "", "\\nLeftrightarrow", !0), epL(epR, "ams", "rel", "", "\\vartriangle"), epL(epR, "ams", epU, "", "\\hslash"), epL(epR, "ams", epU, "", "\\triangledown"), epL(epR, "ams", epU, "", "\\lozenge"), epL(epR, "ams", epU, "", "\\circledS"), epL(epR, "ams", epU, "", "\\circledR"), epL(epN, "ams", epU, "", "\\circledR"), epL(epR, "ams", epU, "", "\\measuredangle", !0), epL(epR, "ams", epU, "", "\\nexists"), epL(epR, "ams", epU, "", "\\mho"), epL(epR, "ams", epU, "", "\\Finv", !0), epL(epR, "ams", epU, "", "\\Game", !0), epL(epR, "ams", epU, "", "\\backprime"), epL(epR, "ams", epU, "", "\\blacktriangle"), epL(epR, "ams", epU, "", "\\blacktriangledown"), epL(epR, "ams", epU, "", "\\blacksquare"), epL(epR, "ams", epU, "", "\\blacklozenge"), epL(epR, "ams", epU, "", "\\bigstar"), epL(epR, "ams", epU, "", "\\sphericalangle", !0), epL(epR, "ams", epU, "", "\\complement", !0), epL(epR, "ams", epU, "", "\\eth", !0), epL(epN, epI, epU, "", ""), epL(epR, "ams", epU, "", "\\diagup"), epL(epR, "ams", epU, "", "\\diagdown"), epL(epR, "ams", epU, "", "\\square"), epL(epR, "ams", epU, "", "\\Box"), epL(epR, "ams", epU, "", "\\Diamond"), epL(epR, "ams", epU, "", "\\yen", !0), epL(epN, "ams", epU, "", "\\yen", !0), epL(epR, "ams", epU, "", "\\checkmark", !0), epL(epN, "ams", epU, "", "\\checkmark"), epL(epR, "ams", epU, "", "\\beth", !0), epL(epR, "ams", epU, "", "\\daleth", !0), epL(epR, "ams", epU, "", "\\gimel", !0), epL(epR, "ams", epU, "", "\\digamma", !0), epL(epR, "ams", epU, "", "\\varkappa"), epL(epR, "ams", epB, "", "\\@ulcorner", !0), epL(epR, "ams", epD, "", "\\@urcorner", !0), epL(epR, "ams", epB, "", "\\@llcorner", !0), epL(epR, "ams", epD, "", "\\@lrcorner", !0), epL(epR, "ams", "rel", "", "\\leqq", !0), epL(epR, "ams", "rel", "", "\\leqslant", !0), epL(epR, "ams", "rel", "", "\\eqslantless", !0), epL(epR, "ams", "rel", "", "\\lesssim", !0), epL(epR, "ams", "rel", "", "\\lessapprox", !0), epL(epR, "ams", "rel", "", "\\approxeq", !0), epL(epR, "ams", "bin", "", "\\lessdot"), epL(epR, "ams", "rel", "", "\\lll", !0), epL(epR, "ams", "rel", "", "\\lessgtr", !0), epL(epR, "ams", "rel", "", "\\lesseqgtr", !0), epL(epR, "ams", "rel", "", "\\lesseqqgtr", !0), epL(epR, "ams", "rel", "", "\\doteqdot"), epL(epR, "ams", "rel", "", "\\risingdotseq", !0), epL(epR, "ams", "rel", "", "\\fallingdotseq", !0), epL(epR, "ams", "rel", "", "\\backsim", !0), epL(epR, "ams", "rel", "", "\\backsimeq", !0), epL(epR, "ams", "rel", "", "\\subseteqq", !0), epL(epR, "ams", "rel", "", "\\Subset", !0), epL(epR, "ams", "rel", "", "\\sqsubset", !0), epL(epR, "ams", "rel", "", "\\preccurlyeq", !0), epL(epR, "ams", "rel", "", "\\curlyeqprec", !0), epL(epR, "ams", "rel", "", "\\precsim", !0), epL(epR, "ams", "rel", "", "\\precapprox", !0), epL(epR, "ams", "rel", "", "\\vartriangleleft"), epL(epR, "ams", "rel", "", "\\trianglelefteq"), epL(epR, "ams", "rel", "", "\\vDash", !0), epL(epR, "ams", "rel", "", "\\Vvdash", !0), epL(epR, "ams", "rel", "", "\\smallsmile"), epL(epR, "ams", "rel", "", "\\smallfrown"), epL(epR, "ams", "rel", "", "\\bumpeq", !0), epL(epR, "ams", "rel", "", "\\Bumpeq", !0), epL(epR, "ams", "rel", "", "\\geqq", !0), epL(epR, "ams", "rel", "", "\\geqslant", !0), epL(epR, "ams", "rel", "", "\\eqslantgtr", !0), epL(epR, "ams", "rel", "", "\\gtrsim", !0), epL(epR, "ams", "rel", "", "\\gtrapprox", !0), epL(epR, "ams", "bin", "", "\\gtrdot"), epL(epR, "ams", "rel", "", "\\ggg", !0), epL(epR, "ams", "rel", "", "\\gtrless", !0), epL(epR, "ams", "rel", "", "\\gtreqless", !0), epL(epR, "ams", "rel", "", "\\gtreqqless", !0), epL(epR, "ams", "rel", "", "\\eqcirc", !0), epL(epR, "ams", "rel", "", "\\circeq", !0), epL(epR, "ams", "rel", "", "\\triangleq", !0), epL(epR, "ams", "rel", "", "\\thicksim"), epL(epR, "ams", "rel", "", "\\thickapprox"), epL(epR, "ams", "rel", "", "\\supseteqq", !0), epL(epR, "ams", "rel", "", "\\Supset", !0), epL(epR, "ams", "rel", "", "\\sqsupset", !0), epL(epR, "ams", "rel", "", "\\succcurlyeq", !0), epL(epR, "ams", "rel", "", "\\curlyeqsucc", !0), epL(epR, "ams", "rel", "", "\\succsim", !0), epL(epR, "ams", "rel", "", "\\succapprox", !0), epL(epR, "ams", "rel", "", "\\vartriangleright"), epL(epR, "ams", "rel", "", "\\trianglerighteq"), epL(epR, "ams", "rel", "", "\\Vdash", !0), epL(epR, "ams", "rel", "", "\\shortmid"), epL(epR, "ams", "rel", "", "\\shortparallel"), epL(epR, "ams", "rel", "", "\\between", !0), epL(epR, "ams", "rel", "", "\\pitchfork", !0), epL(epR, "ams", "rel", "", "\\varpropto"), epL(epR, "ams", "rel", "", "\\blacktriangleleft"), epL(epR, "ams", "rel", "", "\\therefore", !0), epL(epR, "ams", "rel", "", "\\backepsilon"), epL(epR, "ams", "rel", "", "\\blacktriangleright"), epL(epR, "ams", "rel", "", "\\because", !0), epL(epR, "ams", "rel", "", "\\llless"), epL(epR, "ams", "rel", "", "\\gggtr"), epL(epR, "ams", "bin", "", "\\lhd"), epL(epR, "ams", "bin", "", "\\rhd"), epL(epR, "ams", "rel", "", "\\eqsim", !0), epL(epR, epI, "rel", "", "\\Join"), epL(epR, "ams", "rel", "", "\\Doteq", !0), epL(epR, "ams", "bin", "", "\\dotplus", !0), epL(epR, "ams", "bin", "", "\\smallsetminus"), epL(epR, "ams", "bin", "", "\\Cap", !0), epL(epR, "ams", "bin", "", "\\Cup", !0), epL(epR, "ams", "bin", "", "\\doublebarwedge", !0), epL(epR, "ams", "bin", "", "\\boxminus", !0), epL(epR, "ams", "bin", "", "\\boxplus", !0), epL(epR, "ams", "bin", "", "\\divideontimes", !0), epL(epR, "ams", "bin", "", "\\ltimes", !0), epL(epR, "ams", "bin", "", "\\rtimes", !0), epL(epR, "ams", "bin", "", "\\leftthreetimes", !0), epL(epR, "ams", "bin", "", "\\rightthreetimes", !0), epL(epR, "ams", "bin", "", "\\curlywedge", !0), epL(epR, "ams", "bin", "", "\\curlyvee", !0), epL(epR, "ams", "bin", "", "\\circleddash", !0), epL(epR, "ams", "bin", "", "\\circledast", !0), epL(epR, "ams", "bin", "", "\\centerdot"), epL(epR, "ams", "bin", "", "\\intercal", !0), epL(epR, "ams", "bin", "", "\\doublecap"), epL(epR, "ams", "bin", "", "\\doublecup"), epL(epR, "ams", "bin", "", "\\boxtimes", !0), epL(epR, "ams", "rel", "", "\\dashrightarrow", !0), epL(epR, "ams", "rel", "", "\\dashleftarrow", !0), epL(epR, "ams", "rel", "", "\\leftleftarrows", !0), epL(epR, "ams", "rel", "", "\\leftrightarrows", !0), epL(epR, "ams", "rel", "", "\\Lleftarrow", !0), epL(epR, "ams", "rel", "", "\\twoheadleftarrow", !0), epL(epR, "ams", "rel", "", "\\leftarrowtail", !0), epL(epR, "ams", "rel", "", "\\looparrowleft", !0), epL(epR, "ams", "rel", "", "\\leftrightharpoons", !0), epL(epR, "ams", "rel", "", "\\curvearrowleft", !0), epL(epR, "ams", "rel", "", "\\circlearrowleft", !0), epL(epR, "ams", "rel", "", "\\Lsh", !0), epL(epR, "ams", "rel", "", "\\upuparrows", !0), epL(epR, "ams", "rel", "", "\\upharpoonleft", !0), epL(epR, "ams", "rel", "", "\\downharpoonleft", !0), epL(epR, epI, "rel", "", "\\origof", !0), epL(epR, epI, "rel", "", "\\imageof", !0), epL(epR, "ams", "rel", "", "\\multimap", !0), epL(epR, "ams", "rel", "", "\\leftrightsquigarrow", !0), epL(epR, "ams", "rel", "", "\\rightrightarrows", !0), epL(epR, "ams", "rel", "", "\\rightleftarrows", !0), epL(epR, "ams", "rel", "", "\\twoheadrightarrow", !0), epL(epR, "ams", "rel", "", "\\rightarrowtail", !0), epL(epR, "ams", "rel", "", "\\looparrowright", !0), epL(epR, "ams", "rel", "", "\\curvearrowright", !0), epL(epR, "ams", "rel", "", "\\circlearrowright", !0), epL(epR, "ams", "rel", "", "\\Rsh", !0), epL(epR, "ams", "rel", "", "\\downdownarrows", !0), epL(epR, "ams", "rel", "", "\\upharpoonright", !0), epL(epR, "ams", "rel", "", "\\downharpoonright", !0), epL(epR, "ams", "rel", "", "\\rightsquigarrow", !0), epL(epR, "ams", "rel", "", "\\leadsto"), epL(epR, "ams", "rel", "", "\\Rrightarrow", !0), epL(epR, "ams", "rel", "", "\\restriction"), epL(epR, epI, epU, "", "`"), epL(epR, epI, epU, "$", "\\$"), epL(epN, epI, epU, "$", "\\$"), epL(epN, epI, epU, "$", "\\textdollar"), epL(epR, epI, epU, "%", "\\%"), epL(epN, epI, epU, "%", "\\%"), epL(epR, epI, epU, "_", "\\_"), epL(epN, epI, epU, "_", "\\_"), epL(epN, epI, epU, "_", "\\textunderscore"), epL(epR, epI, epU, "", "\\angle", !0), epL(epR, epI, epU, "", "\\infty", !0), epL(epR, epI, epU, "", "\\prime"), epL(epR, epI, epU, "", "\\triangle"), epL(epR, epI, epU, "", "\\Gamma", !0), epL(epR, epI, epU, "", "\\Delta", !0), epL(epR, epI, epU, "", "\\Theta", !0), epL(epR, epI, epU, "", "\\Lambda", !0), epL(epR, epI, epU, "", "\\Xi", !0), epL(epR, epI, epU, "", "\\Pi", !0), epL(epR, epI, epU, "", "\\Sigma", !0), epL(epR, epI, epU, "", "\\Upsilon", !0), epL(epR, epI, epU, "", "\\Phi", !0), epL(epR, epI, epU, "", "\\Psi", !0), epL(epR, epI, epU, "", "\\Omega", !0), epL(epR, epI, epU, "A", ""), epL(epR, epI, epU, "B", ""), epL(epR, epI, epU, "E", ""), epL(epR, epI, epU, "Z", ""), epL(epR, epI, epU, "H", ""), epL(epR, epI, epU, "I", ""), epL(epR, epI, epU, "K", ""), epL(epR, epI, epU, "M", ""), epL(epR, epI, epU, "N", ""), epL(epR, epI, epU, "O", ""), epL(epR, epI, epU, "P", ""), epL(epR, epI, epU, "T", ""), epL(epR, epI, epU, "X", ""), epL(epR, epI, epU, "", "\\neg", !0), epL(epR, epI, epU, "", "\\lnot"), epL(epR, epI, epU, "", "\\top"), epL(epR, epI, epU, "", "\\bot"), epL(epR, epI, epU, "", "\\emptyset"), epL(epR, "ams", epU, "", "\\varnothing"), epL(epR, epI, ep$, "", "\\alpha", !0), epL(epR, epI, ep$, "", "\\beta", !0), epL(epR, epI, ep$, "", "\\gamma", !0), epL(epR, epI, ep$, "", "\\delta", !0), epL(epR, epI, ep$, "", "\\epsilon", !0), epL(epR, epI, ep$, "", "\\zeta", !0), epL(epR, epI, ep$, "", "\\eta", !0), epL(epR, epI, ep$, "", "\\theta", !0), epL(epR, epI, ep$, "", "\\iota", !0), epL(epR, epI, ep$, "", "\\kappa", !0), epL(epR, epI, ep$, "", "\\lambda", !0), epL(epR, epI, ep$, "", "\\mu", !0), epL(epR, epI, ep$, "", "\\nu", !0), epL(epR, epI, ep$, "", "\\xi", !0), epL(epR, epI, ep$, "", "\\omicron", !0), epL(epR, epI, ep$, "", "\\pi", !0), epL(epR, epI, ep$, "", "\\rho", !0), epL(epR, epI, ep$, "", "\\sigma", !0), epL(epR, epI, ep$, "", "\\tau", !0), epL(epR, epI, ep$, "", "\\upsilon", !0), epL(epR, epI, ep$, "", "\\phi", !0), epL(epR, epI, ep$, "", "\\chi", !0), epL(epR, epI, ep$, "", "\\psi", !0), epL(epR, epI, ep$, "", "\\omega", !0), epL(epR, epI, ep$, "", "\\varepsilon", !0), epL(epR, epI, ep$, "", "\\vartheta", !0), epL(epR, epI, ep$, "", "\\varpi", !0), epL(epR, epI, ep$, "", "\\varrho", !0), epL(epR, epI, ep$, "", "\\varsigma", !0), epL(epR, epI, ep$, "", "\\varphi", !0), epL(epR, epI, "bin", "", "*", !0), epL(epR, epI, "bin", "+", "+"), epL(epR, epI, "bin", "", "-", !0), epL(epR, epI, "bin", "", "\\cdot", !0), epL(epR, epI, "bin", "", "\\circ", !0), epL(epR, epI, "bin", "", "\\div", !0), epL(epR, epI, "bin", "", "\\pm", !0), epL(epR, epI, "bin", "", "\\times", !0), epL(epR, epI, "bin", "", "\\cap", !0), epL(epR, epI, "bin", "", "\\cup", !0), epL(epR, epI, "bin", "", "\\setminus", !0), epL(epR, epI, "bin", "", "\\land"), epL(epR, epI, "bin", "", "\\lor"), epL(epR, epI, "bin", "", "\\wedge", !0), epL(epR, epI, "bin", "", "\\vee", !0), epL(epR, epI, epU, "", "\\surd"), epL(epR, epI, epB, "", "\\langle", !0), epL(epR, epI, epB, "", "\\lvert"), epL(epR, epI, epB, "", "\\lVert"), epL(epR, epI, epD, "?", "?"), epL(epR, epI, epD, "!", "!"), epL(epR, epI, epD, "", "\\rangle", !0), epL(epR, epI, epD, "", "\\rvert"), epL(epR, epI, epD, "", "\\rVert"), epL(epR, epI, "rel", "=", "="), epL(epR, epI, "rel", ":", ":"), epL(epR, epI, "rel", "", "\\approx", !0), epL(epR, epI, "rel", "", "\\cong", !0), epL(epR, epI, "rel", "", "\\ge"), epL(epR, epI, "rel", "", "\\geq", !0), epL(epR, epI, "rel", "", "\\gets"), epL(epR, epI, "rel", ">", "\\gt", !0), epL(epR, epI, "rel", "", "\\in", !0), epL(epR, epI, "rel", "", "\\@not"), epL(epR, epI, "rel", "", "\\subset", !0), epL(epR, epI, "rel", "", "\\supset", !0), epL(epR, epI, "rel", "", "\\subseteq", !0), epL(epR, epI, "rel", "", "\\supseteq", !0), epL(epR, "ams", "rel", "", "\\nsubseteq", !0), epL(epR, "ams", "rel", "", "\\nsupseteq", !0), epL(epR, epI, "rel", "", "\\models"), epL(epR, epI, "rel", "", "\\leftarrow", !0), epL(epR, epI, "rel", "", "\\le"), epL(epR, epI, "rel", "", "\\leq", !0), epL(epR, epI, "rel", "<", "\\lt", !0), epL(epR, epI, "rel", "", "\\rightarrow", !0), epL(epR, epI, "rel", "", "\\to"), epL(epR, "ams", "rel", "", "\\ngeq", !0), epL(epR, "ams", "rel", "", "\\nleq", !0), epL(epR, epI, epz, "\xA0", "\\ "), epL(epR, epI, epz, "\xA0", "\\space"), epL(epR, epI, epz, "\xA0", "\\nobreakspace"), epL(epN, epI, epz, "\xA0", "\\ "), epL(epN, epI, epz, "\xA0", " "), epL(epN, epI, epz, "\xA0", "\\space"), epL(epN, epI, epz, "\xA0", "\\nobreakspace"), epL(epR, epI, epz, null, "\\nobreak"), epL(epR, epI, epz, null, "\\allowbreak"), epL(epR, epI, epF, ",", ","), epL(epR, epI, epF, ";", ";"), epL(epR, "ams", "bin", "", "\\barwedge", !0), epL(epR, "ams", "bin", "", "\\veebar", !0), epL(epR, epI, "bin", "", "\\odot", !0), epL(epR, epI, "bin", "", "\\oplus", !0), epL(epR, epI, "bin", "", "\\otimes", !0), epL(epR, epI, epU, "", "\\partial", !0), epL(epR, epI, "bin", "", "\\oslash", !0), epL(epR, "ams", "bin", "", "\\circledcirc", !0), epL(epR, "ams", "bin", "", "\\boxdot", !0), epL(epR, epI, "bin", "", "\\bigtriangleup"), epL(epR, epI, "bin", "", "\\bigtriangledown"), epL(epR, epI, "bin", "", "\\dagger"), epL(epR, epI, "bin", "", "\\diamond"), epL(epR, epI, "bin", "", "\\star"), epL(epR, epI, "bin", "", "\\triangleleft"), epL(epR, epI, "bin", "", "\\triangleright"), epL(epR, epI, epB, "{", "\\{"), epL(epN, epI, epU, "{", "\\{"), epL(epN, epI, epU, "{", "\\textbraceleft"), epL(epR, epI, epD, "}", "\\}"), epL(epN, epI, epU, "}", "\\}"), epL(epN, epI, epU, "}", "\\textbraceright"), epL(epR, epI, epB, "{", "\\lbrace"), epL(epR, epI, epD, "}", "\\rbrace"), epL(epR, epI, epB, "[", "\\lbrack", !0), epL(epN, epI, epU, "[", "\\lbrack", !0), epL(epR, epI, epD, "]", "\\rbrack", !0), epL(epN, epI, epU, "]", "\\rbrack", !0), epL(epR, epI, epB, "(", "\\lparen", !0), epL(epR, epI, epD, ")", "\\rparen", !0), epL(epN, epI, epU, "<", "\\textless", !0), epL(epN, epI, epU, ">", "\\textgreater", !0), epL(epR, epI, epB, "", "\\lfloor", !0), epL(epR, epI, epD, "", "\\rfloor", !0), epL(epR, epI, epB, "", "\\lceil", !0), epL(epR, epI, epD, "", "\\rceil", !0), epL(epR, epI, epU, "\\", "\\backslash"), epL(epR, epI, epU, "", "|"), epL(epR, epI, epU, "", "\\vert"), epL(epN, epI, epU, "|", "\\textbar", !0), epL(epR, epI, epU, "", "\\|"), epL(epR, epI, epU, "", "\\Vert"), epL(epN, epI, epU, "", "\\textbardbl"), epL(epN, epI, epU, "~", "\\textasciitilde"), epL(epN, epI, epU, "\\", "\\textbackslash"), epL(epN, epI, epU, "^", "\\textasciicircum"), epL(epR, epI, "rel", "", "\\uparrow", !0), epL(epR, epI, "rel", "", "\\Uparrow", !0), epL(epR, epI, "rel", "", "\\downarrow", !0), epL(epR, epI, "rel", "", "\\Downarrow", !0), epL(epR, epI, "rel", "", "\\updownarrow", !0), epL(epR, epI, "rel", "", "\\Updownarrow", !0), epL(epR, epI, epP, "", "\\coprod"), epL(epR, epI, epP, "", "\\bigvee"), epL(epR, epI, epP, "", "\\bigwedge"), epL(epR, epI, epP, "", "\\biguplus"), epL(epR, epI, epP, "", "\\bigcap"), epL(epR, epI, epP, "", "\\bigcup"), epL(epR, epI, epP, "", "\\int"), epL(epR, epI, epP, "", "\\intop"), epL(epR, epI, epP, "", "\\iint"), epL(epR, epI, epP, "", "\\iiint"), epL(epR, epI, epP, "", "\\prod"), epL(epR, epI, epP, "", "\\sum"), epL(epR, epI, epP, "", "\\bigotimes"), epL(epR, epI, epP, "", "\\bigoplus"), epL(epR, epI, epP, "", "\\bigodot"), epL(epR, epI, epP, "", "\\oint"), epL(epR, epI, epP, "", "\\oiint"), epL(epR, epI, epP, "", "\\oiiint"), epL(epR, epI, epP, "", "\\bigsqcup"), epL(epR, epI, epP, "", "\\smallint"), epL(epN, epI, epO, "", "\\textellipsis"), epL(epR, epI, epO, "", "\\mathellipsis"), epL(epN, epI, epO, "", "\\ldots", !0), epL(epR, epI, epO, "", "\\ldots", !0), epL(epR, epI, epO, "", "\\@cdots", !0), epL(epR, epI, epO, "", "\\ddots", !0), epL(epR, epI, epU, "", "\\varvdots"), epL(epN, epI, epU, "", "\\varvdots"), epL(epR, epI, epM, "", "\\acute"), epL(epR, epI, epM, "", "\\grave"), epL(epR, epI, epM, "", "\\ddot"), epL(epR, epI, epM, "~", "\\tilde"), epL(epR, epI, epM, "", "\\bar"), epL(epR, epI, epM, "", "\\breve"), epL(epR, epI, epM, "", "\\check"), epL(epR, epI, epM, "^", "\\hat"), epL(epR, epI, epM, "", "\\vec"), epL(epR, epI, epM, "", "\\dot"), epL(epR, epI, epM, "", "\\mathring"), epL(epR, epI, ep$, "", "\\@imath"), epL(epR, epI, ep$, "", "\\@jmath"), epL(epR, epI, epU, "", ""), epL(epR, epI, epU, "", ""), epL(epN, epI, epU, "", "\\i", !0), epL(epN, epI, epU, "", "\\j", !0), epL(epN, epI, epU, "", "\\ss", !0), epL(epN, epI, epU, "", "\\ae", !0), epL(epN, epI, epU, "", "\\oe", !0), epL(epN, epI, epU, "", "\\o", !0), epL(epN, epI, epU, "", "\\AE", !0), epL(epN, epI, epU, "", "\\OE", !0), epL(epN, epI, epU, "", "\\O", !0), epL(epN, epI, epM, "", "\\'"), epL(epN, epI, epM, "", "\\`"), epL(epN, epI, epM, "", "\\^"), epL(epN, epI, epM, "", "\\~"), epL(epN, epI, epM, "", "\\="), epL(epN, epI, epM, "", "\\u"), epL(epN, epI, epM, "", "\\."), epL(epN, epI, epM, "", "\\c"), epL(epN, epI, epM, "", "\\r"), epL(epN, epI, epM, "", "\\v"), epL(epN, epI, epM, "", "\\\""), epL(epN, epI, epM, "", "\\H"), epL(epN, epI, epM, "", "\\textcircled");
var epG = {
	"--": !0,
	"---": !0,
	"``": !0,
	"''": !0
};
epL(epN, epI, epU, "", "--", !0), epL(epN, epI, epU, "", "\\textendash"), epL(epN, epI, epU, "", "---", !0), epL(epN, epI, epU, "", "\\textemdash"), epL(epN, epI, epU, "", "`", !0), epL(epN, epI, epU, "", "\\textquoteleft"), epL(epN, epI, epU, "", "'", !0), epL(epN, epI, epU, "", "\\textquoteright"), epL(epN, epI, epU, "", "``", !0), epL(epN, epI, epU, "", "\\textquotedblleft"), epL(epN, epI, epU, "", "''", !0), epL(epN, epI, epU, "", "\\textquotedblright"), epL(epR, epI, epU, "", "\\degree", !0), epL(epN, epI, epU, "", "\\degree"), epL(epN, epI, epU, "", "\\textdegree", !0), epL(epR, epI, epU, "", "\\pounds"), epL(epR, epI, epU, "", "\\mathsterling", !0), epL(epN, epI, epU, "", "\\pounds"), epL(epN, epI, epU, "", "\\textsterling", !0), epL(epR, "ams", epU, "", "\\maltese"), epL(epN, "ams", epU, "", "\\maltese");
var epq = "0123456789/@.\"";
for (epW = 0; epW < epq.length; epW++) epL(epR, epI, epU, epj = epq.charAt(epW), epj);
var epj, epW, epY = "0123456789!@*()-=+\";:?/.,";
for (epH = 0; epH < epY.length; epH++) epL(epN, epI, epU, epV = epY.charAt(epH), epV);
var epV, epH, epX = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
for (epQ = 0; epQ < epX.length; epQ++) epL(epR, epI, ep$, epZ = epX.charAt(epQ), epZ), epL(epN, epI, epU, epZ, epZ);
epL(epR, "ams", epU, "C", ""), epL(epN, "ams", epU, "C", ""), epL(epR, "ams", epU, "H", ""), epL(epN, "ams", epU, "H", ""), epL(epR, "ams", epU, "N", ""), epL(epN, "ams", epU, "N", ""), epL(epR, "ams", epU, "P", ""), epL(epN, "ams", epU, "P", ""), epL(epR, "ams", epU, "Q", ""), epL(epN, "ams", epU, "Q", ""), epL(epR, "ams", epU, "R", ""), epL(epN, "ams", epU, "R", ""), epL(epR, "ams", epU, "Z", ""), epL(epN, "ams", epU, "Z", ""), epL(epR, epI, ep$, "h", ""), epL(epN, epI, ep$, "h", "");
var epK = "";
for (ep0 = 0; ep0 < epX.length; ep0++) epL(epR, epI, ep$, epJ = epX.charAt(ep0), epK = String.fromCharCode(55349, 56320 + ep0)), epL(epN, epI, epU, epJ, epK), epL(epR, epI, ep$, epJ, epK = String.fromCharCode(55349, 56372 + ep0)), epL(epN, epI, epU, epJ, epK), epL(epR, epI, ep$, epJ, epK = String.fromCharCode(55349, 56424 + ep0)), epL(epN, epI, epU, epJ, epK), epL(epR, epI, ep$, epJ, epK = String.fromCharCode(55349, 56580 + ep0)), epL(epN, epI, epU, epJ, epK), epL(epR, epI, ep$, epJ, epK = String.fromCharCode(55349, 56684 + ep0)), epL(epN, epI, epU, epJ, epK), epL(epR, epI, ep$, epJ, epK = String.fromCharCode(55349, 56736 + ep0)), epL(epN, epI, epU, epJ, epK), epL(epR, epI, ep$, epJ, epK = String.fromCharCode(55349, 56788 + ep0)), epL(epN, epI, epU, epJ, epK), epL(epR, epI, ep$, epJ, epK = String.fromCharCode(55349, 56840 + ep0)), epL(epN, epI, epU, epJ, epK), epL(epR, epI, ep$, epJ, epK = String.fromCharCode(55349, 56944 + ep0)), epL(epN, epI, epU, epJ, epK), ep0 < 26 && (epL(epR, epI, ep$, epJ, epK = String.fromCharCode(55349, 56632 + ep0)), epL(epN, epI, epU, epJ, epK), epL(epR, epI, ep$, epJ, epK = String.fromCharCode(55349, 56476 + ep0)), epL(epN, epI, epU, epJ, epK));
for (epL(epR, epI, ep$, "k", epK = ""), epL(epN, epI, epU, "k", epK), ep2 = 0; ep2 < 10; ep2++) epL(epR, epI, ep$, ep1 = ep2.toString(), epK = String.fromCharCode(55349, 57294 + ep2)), epL(epN, epI, epU, ep1, epK), epL(epR, epI, ep$, ep1, epK = String.fromCharCode(55349, 57314 + ep2)), epL(epN, epI, epU, ep1, epK), epL(epR, epI, ep$, ep1, epK = String.fromCharCode(55349, 57324 + ep2)), epL(epN, epI, epU, ep1, epK), epL(epR, epI, ep$, ep1, epK = String.fromCharCode(55349, 57334 + ep2)), epL(epN, epI, epU, ep1, epK);
var epZ, epQ, epJ, ep0, ep1, ep2, ep4 = "";
for (ep3 = 0; ep3 < ep4.length; ep3++) epL(epR, epI, ep$, ep5 = ep4.charAt(ep3), ep5), epL(epN, epI, epU, ep5, ep5);
var ep5, ep3, ep6 = [
	[
		"mathbf",
		"textbf",
		"Main-Bold"
	],
	[
		"mathbf",
		"textbf",
		"Main-Bold"
	],
	[
		"mathnormal",
		"textit",
		"Math-Italic"
	],
	[
		"mathnormal",
		"textit",
		"Math-Italic"
	],
	[
		"boldsymbol",
		"boldsymbol",
		"Main-BoldItalic"
	],
	[
		"boldsymbol",
		"boldsymbol",
		"Main-BoldItalic"
	],
	[
		"mathscr",
		"textscr",
		"Script-Regular"
	],
	[
		"",
		"",
		""
	],
	[
		"",
		"",
		""
	],
	[
		"",
		"",
		""
	],
	[
		"mathfrak",
		"textfrak",
		"Fraktur-Regular"
	],
	[
		"mathfrak",
		"textfrak",
		"Fraktur-Regular"
	],
	[
		"mathbb",
		"textbb",
		"AMS-Regular"
	],
	[
		"mathbb",
		"textbb",
		"AMS-Regular"
	],
	[
		"mathboldfrak",
		"textboldfrak",
		"Fraktur-Regular"
	],
	[
		"mathboldfrak",
		"textboldfrak",
		"Fraktur-Regular"
	],
	[
		"mathsf",
		"textsf",
		"SansSerif-Regular"
	],
	[
		"mathsf",
		"textsf",
		"SansSerif-Regular"
	],
	[
		"mathboldsf",
		"textboldsf",
		"SansSerif-Bold"
	],
	[
		"mathboldsf",
		"textboldsf",
		"SansSerif-Bold"
	],
	[
		"mathitsf",
		"textitsf",
		"SansSerif-Italic"
	],
	[
		"mathitsf",
		"textitsf",
		"SansSerif-Italic"
	],
	[
		"",
		"",
		""
	],
	[
		"",
		"",
		""
	],
	[
		"mathtt",
		"texttt",
		"Typewriter-Regular"
	],
	[
		"mathtt",
		"texttt",
		"Typewriter-Regular"
	]
], ep7 = [
	[
		"mathbf",
		"textbf",
		"Main-Bold"
	],
	[
		"",
		"",
		""
	],
	[
		"mathsf",
		"textsf",
		"SansSerif-Regular"
	],
	[
		"mathboldsf",
		"textboldsf",
		"SansSerif-Bold"
	],
	[
		"mathtt",
		"texttt",
		"Typewriter-Regular"
	]
], ep8 = h(function(e, t) {
	var r = (e.charCodeAt(0) - 55296) * 1024 + (e.charCodeAt(1) - 56320) + 65536, i = +("math" !== t);
	if (119808 <= r && r < 120484) {
		var n = Math.floor((r - 119808) / 26);
		return [ep6[n][2], ep6[n][i]];
	}
	if (120782 <= r && r <= 120831) {
		var a = Math.floor((r - 120782) / 10);
		return [ep7[a][2], ep7[a][i]];
	}
	if (120485 === r || 120486 === r) return [ep6[0][2], ep6[0][i]];
	if (120486 < r && r < 120782) return ["", ""];
	throw new edx("Unsupported character: " + e);
}, "wideCharacterFont"), ep9 = h(function(e, t, r) {
	return epA[r][e] && epA[r][e].replace && (e = epA[r][e].replace), {
		value: e,
		metrics: ed9(e, t, r)
	};
}, "lookupSymbol"), efe = h(function(e, t, r, i, n) {
	var a, s = ep9(e, t, r), o = s.metrics;
	if (e = s.value, o) {
		var l = o.italic;
		("text" === r || i && "mathit" === i.font) && (l = 0), a = new epb(e, o.height, o.depth, l, o.skew, o.width, n);
	} else "u" > typeof console && console.warn("No character metrics " + ("for '" + e + "' in style '" + t + "' and mode '") + r + "'"), a = new epb(e, 0, 0, 0, 0, 0, n);
	if (i) {
		a.maxFontSize = i.sizeMultiplier, i.style.isTight() && a.classes.push("mtight");
		var h = i.getColor();
		h && (a.style.color = h);
	}
	return a;
}, "makeSymbol"), eft = h(function(e, t, r, i) {
	return void 0 === i && (i = []), "boldsymbol" === r.font && ep9(e, "Main-Bold", t).metrics ? efe(e, "Main-Bold", t, r, i.concat(["mathbf"])) : "\\" === e || "main" === epA[t][e].font ? efe(e, "Main-Regular", t, r, i) : efe(e, "AMS-Regular", t, r, i.concat(["amsrm"]));
}, "mathsym"), efr = h(function(e, t, r, i, n) {
	return "textord" !== n && ep9(e, "Math-BoldItalic", t).metrics ? {
		fontName: "Math-BoldItalic",
		fontClass: "boldsymbol"
	} : {
		fontName: "Main-Bold",
		fontClass: "mathbf"
	};
}, "boldsymbol"), efi = h(function(e, t, r) {
	var i, n, a = e.mode, s = e.text, o = ["mord"], l = "math" === a || "text" === a && t.font, h = l ? t.font : t.fontFamily, u = "", d = "";
	if (55349 === s.charCodeAt(0) && ([u, d] = ep8(s, a)), u.length > 0) return efe(s, u, a, t, o.concat(d));
	if (h) {
		if ("boldsymbol" === h) {
			var p = efr(s, a, t, o, r);
			i = p.fontName, n = [p.fontClass];
		} else l ? (i = efy[h].fontName, n = [h]) : (i = efm(h, t.fontWeight, t.fontShape), n = [
			h,
			t.fontWeight,
			t.fontShape
		]);
		if (ep9(s, i, a).metrics) return efe(s, i, a, t, o.concat(n));
		if (epG.hasOwnProperty(s) && "Typewriter" === i.slice(0, 10)) {
			for (var f = [], g = 0; g < s.length; g++) f.push(efe(s[g], i, a, t, o.concat(n)));
			return efu(f);
		}
	}
	if ("mathord" === r) return efe(s, "Math-Italic", a, t, o.concat(["mathnormal"]));
	if ("textord" === r) {
		var m = epA[a][s] && epA[a][s].font;
		if ("ams" === m) return efe(s, efm("amsrm", t.fontWeight, t.fontShape), a, t, o.concat("amsrm", t.fontWeight, t.fontShape));
		if ("main" === m || !m) return efe(s, efm("textrm", t.fontWeight, t.fontShape), a, t, o.concat(t.fontWeight, t.fontShape));
		var y = efm(m, t.fontWeight, t.fontShape);
		return efe(s, y, a, t, o.concat(y, t.fontWeight, t.fontShape));
	}
	throw Error("unexpected type: " + r + " in makeOrd");
}, "makeOrd"), efn = h((e, t) => {
	if (epu(e.classes) !== epu(t.classes) || e.skew !== t.skew || e.maxFontSize !== t.maxFontSize) return !1;
	if (1 === e.classes.length) {
		var r = e.classes[0];
		if ("mbin" === r || "mord" === r) return !1;
	}
	for (var i in e.style) if (e.style.hasOwnProperty(i) && e.style[i] !== t.style[i]) return !1;
	for (var n in t.style) if (t.style.hasOwnProperty(n) && e.style[n] !== t.style[n]) return !1;
	return !0;
}, "canCombine"), efa = h((e) => {
	for (var t = 0; t < e.length - 1; t++) {
		var r = e[t], i = e[t + 1];
		r instanceof epb && i instanceof epb && efn(r, i) && (r.text += i.text, r.height = Math.max(r.height, i.height), r.depth = Math.max(r.depth, i.depth), r.italic = i.italic, e.splice(t + 1, 1), t--);
	}
	return e;
}, "tryCombineChars"), efs = h(function(e) {
	for (var t = 0, r = 0, i = 0, n = 0; n < e.children.length; n++) {
		var a = e.children[n];
		a.height > t && (t = a.height), a.depth > r && (r = a.depth), a.maxFontSize > i && (i = a.maxFontSize);
	}
	e.height = t, e.depth = r, e.maxFontSize = i;
}, "sizeElementFromChildren"), efo = h(function(e, t, r, i) {
	var n = new epm(e, t, r, i);
	return efs(n), n;
}, "makeSpan"), efl = h((e, t, r, i) => new epm(e, t, r, i), "makeSvgSpan"), efc = h(function(e, t, r) {
	var i = efo([e], [], t);
	return i.height = Math.max(r || t.fontMetrics().defaultRuleThickness, t.minRuleThickness), i.style.borderBottomWidth = eph(i.height), i.maxFontSize = 1, i;
}, "makeLineSpan"), efh = h(function(e, t, r, i) {
	var n = new epy(e, t, r, i);
	return efs(n), n;
}, "makeAnchor"), efu = h(function(e) {
	var t = new ed5(e);
	return efs(t), t;
}, "makeFragment"), efd = h(function(e, t) {
	return e instanceof ed5 ? efo([], [e], t) : e;
}, "wrapFragment"), efp = h(function(e) {
	if ("individualShift" === e.positionType) {
		for (var t, r = e.children, i = [r[0]], n = -r[0].shift - r[0].elem.depth, a = n, s = 1; s < r.length; s++) {
			var o = -r[s].shift - a - r[s].elem.depth, l = o - (r[s - 1].elem.height + r[s - 1].elem.depth);
			a += o, i.push({
				type: "kern",
				size: l
			}), i.push(r[s]);
		}
		return {
			children: i,
			depth: n
		};
	}
	if ("top" === e.positionType) {
		for (var h = e.positionData, u = 0; u < e.children.length; u++) {
			var d = e.children[u];
			h -= "kern" === d.type ? d.size : d.elem.height + d.elem.depth;
		}
		t = h;
	} else if ("bottom" === e.positionType) t = -e.positionData;
	else {
		var p = e.children[0];
		if ("elem" !== p.type) throw Error("First child must have type \"elem\".");
		if ("shift" === e.positionType) t = -p.elem.depth - e.positionData;
		else if ("firstBaseline" === e.positionType) t = -p.elem.depth;
		else throw Error("Invalid positionType " + e.positionType + ".");
	}
	return {
		children: e.children,
		depth: t
	};
}, "getVListChildrenAndDepth"), eff = h(function(e, t) {
	for (var r, { children: i, depth: n } = efp(e), a = 0, s = 0; s < i.length; s++) {
		var o = i[s];
		if ("elem" === o.type) {
			var l = o.elem;
			a = Math.max(a, l.maxFontSize, l.height);
		}
	}
	a += 2;
	var h = efo(["pstrut"], []);
	h.style.height = eph(a);
	for (var u = [], d = n, p = n, f = n, g = 0; g < i.length; g++) {
		var m = i[g];
		if ("kern" === m.type) f += m.size;
		else {
			var y = m.elem, v = efo(m.wrapperClasses || [], [h, y], void 0, m.wrapperStyle || {});
			v.style.top = eph(-a - f - y.depth), m.marginLeft && (v.style.marginLeft = m.marginLeft), m.marginRight && (v.style.marginRight = m.marginRight), u.push(v), f += y.height + y.depth;
		}
		d = Math.min(d, f), p = Math.max(p, f);
	}
	var x = efo(["vlist"], u);
	if (x.style.height = eph(p), d < 0) {
		var b = efo(["vlist"], [efo([], [])]);
		b.style.height = eph(-d), r = [efo(["vlist-r"], [x, efo(["vlist-s"], [new epb("")])]), efo(["vlist-r"], [b])];
	} else r = [efo(["vlist-r"], [x])];
	var w = efo(["vlist-t"], r);
	return 2 === r.length && w.classes.push("vlist-t2"), w.height = p, w.depth = -d, w;
}, "makeVList"), efg = h((e, t) => {
	var r = efo(["mspace"], [], t), i = epc(e, t);
	return r.style.marginRight = eph(i), r;
}, "makeGlue"), efm = h(function(e, t, r) {
	var i = "";
	switch (e) {
		case "amsrm":
			i = "AMS";
			break;
		case "textrm":
			i = "Main";
			break;
		case "textsf":
			i = "SansSerif";
			break;
		case "texttt":
			i = "Typewriter";
			break;
		default: i = e;
	}
	return i + "-" + ("textbf" === t && "textit" === r ? "BoldItalic" : "textbf" === t ? "Bold" : "textit" === t ? "Italic" : "Regular");
}, "retrieveTextFontName"), efy = {
	mathbf: {
		variant: "bold",
		fontName: "Main-Bold"
	},
	mathrm: {
		variant: "normal",
		fontName: "Main-Regular"
	},
	textit: {
		variant: "italic",
		fontName: "Main-Italic"
	},
	mathit: {
		variant: "italic",
		fontName: "Main-Italic"
	},
	mathnormal: {
		variant: "italic",
		fontName: "Math-Italic"
	},
	mathsfit: {
		variant: "sans-serif-italic",
		fontName: "SansSerif-Italic"
	},
	mathbb: {
		variant: "double-struck",
		fontName: "AMS-Regular"
	},
	mathcal: {
		variant: "script",
		fontName: "Caligraphic-Regular"
	},
	mathfrak: {
		variant: "fraktur",
		fontName: "Fraktur-Regular"
	},
	mathscr: {
		variant: "script",
		fontName: "Script-Regular"
	},
	mathsf: {
		variant: "sans-serif",
		fontName: "SansSerif-Regular"
	},
	mathtt: {
		variant: "monospace",
		fontName: "Typewriter-Regular"
	}
}, efv = {
	vec: [
		"vec",
		.471,
		.714
	],
	oiintSize1: [
		"oiintSize1",
		.957,
		.499
	],
	oiintSize2: [
		"oiintSize2",
		1.472,
		.659
	],
	oiiintSize1: [
		"oiiintSize1",
		1.304,
		.499
	],
	oiiintSize2: [
		"oiiintSize2",
		1.98,
		.659
	]
}, efx = {
	fontMap: efy,
	makeSymbol: efe,
	mathsym: eft,
	makeSpan: efo,
	makeSvgSpan: efl,
	makeLineSpan: efc,
	makeAnchor: efh,
	makeFragment: efu,
	wrapFragment: efd,
	makeVList: eff,
	makeOrd: efi,
	makeGlue: efg,
	staticSvg: h(function(e, t) {
		var [r, i, n] = efv[e], a = efl(["overlay"], [new epw([new epk(r)], {
			width: eph(i),
			height: eph(n),
			style: "width:" + eph(i),
			viewBox: "0 0 " + 1e3 * i + " " + 1e3 * n,
			preserveAspectRatio: "xMinYMin"
		})], t);
		return a.height = n, a.style.height = eph(n), a.style.width = eph(i), a;
	}, "staticSvg"),
	svgData: efv,
	tryCombineChars: efa
}, efb = {
	number: 3,
	unit: "mu"
}, efw = {
	number: 4,
	unit: "mu"
}, efk = {
	number: 5,
	unit: "mu"
}, efT = {
	mord: {
		mop: efb,
		mbin: efw,
		mrel: efk,
		minner: efb
	},
	mop: {
		mord: efb,
		mop: efb,
		mrel: efk,
		minner: efb
	},
	mbin: {
		mord: efw,
		mop: efw,
		mopen: efw,
		minner: efw
	},
	mrel: {
		mord: efk,
		mop: efk,
		mopen: efk,
		minner: efk
	},
	mopen: {},
	mclose: {
		mop: efb,
		mbin: efw,
		mrel: efk,
		minner: efb
	},
	mpunct: {
		mord: efb,
		mop: efb,
		mrel: efk,
		mopen: efb,
		mclose: efb,
		mpunct: efb,
		minner: efb
	},
	minner: {
		mord: efb,
		mop: efb,
		mbin: efw,
		mrel: efk,
		mopen: efb,
		mpunct: efb,
		minner: efb
	}
}, ef_ = {
	mord: { mop: efb },
	mop: {
		mord: efb,
		mop: efb
	},
	mbin: {},
	mrel: {},
	mopen: {},
	mclose: { mop: efb },
	mpunct: {},
	minner: { mop: efb }
}, efE = {}, efC = {}, efS = {};
function efA(e) {
	for (var { type: t, names: r, props: i, handler: n, htmlBuilder: a, mathmlBuilder: s } = e, o = {
		type: t,
		numArgs: i.numArgs,
		argTypes: i.argTypes,
		allowedInArgument: !!i.allowedInArgument,
		allowedInText: !!i.allowedInText,
		allowedInMath: void 0 === i.allowedInMath || i.allowedInMath,
		numOptionalArgs: i.numOptionalArgs || 0,
		infix: !!i.infix,
		primitive: !!i.primitive,
		handler: n
	}, l = 0; l < r.length; ++l) efE[r[l]] = o;
	t && (a && (efC[t] = a), s && (efS[t] = s));
}
function efL(e) {
	var { type: t, htmlBuilder: r, mathmlBuilder: i } = e;
	efA({
		type: t,
		names: [],
		props: { numArgs: 0 },
		handler() {
			throw Error("Should never be called.");
		},
		htmlBuilder: r,
		mathmlBuilder: i
	});
}
h(efA, "defineFunction"), h(efL, "defineFunctionBuilders");
var efR = h(function(e) {
	return "ordgroup" === e.type && 1 === e.body.length ? e.body[0] : e;
}, "normalizeArgument"), efN = h(function(e) {
	return "ordgroup" === e.type ? e.body : [e];
}, "ordargument"), efI = efx.makeSpan, efM = [
	"leftmost",
	"mbin",
	"mopen",
	"mrel",
	"mop",
	"mpunct"
], efD = [
	"rightmost",
	"mrel",
	"mclose",
	"mpunct"
], efO = {
	display: edG.DISPLAY,
	text: edG.TEXT,
	script: edG.SCRIPT,
	scriptscript: edG.SCRIPTSCRIPT
}, ef$ = {
	mord: "mord",
	mop: "mop",
	mbin: "mbin",
	mrel: "mrel",
	mopen: "mopen",
	mclose: "mclose",
	mpunct: "mpunct",
	minner: "minner"
}, efP = h(function(e, t, r, i) {
	void 0 === i && (i = [null, null]);
	for (var n = [], a = 0; a < e.length; a++) {
		var s = efq(e[a], t);
		if (s instanceof ed5) {
			var o = s.children;
			n.push(...o);
		} else n.push(s);
	}
	if (efx.tryCombineChars(n), !r) return n;
	var l = t;
	if (1 === e.length) {
		var h = e[0];
		"sizing" === h.type ? l = t.havingSize(h.size) : "styling" === h.type && (l = t.havingStyle(efO[h.style]));
	}
	var u = efI([i[0] || "leftmost"], [], t), d = efI([i[1] || "rightmost"], [], t), p = "root" === r;
	return efB(n, (e, t) => {
		var r = t.classes[0], i = e.classes[0];
		"mbin" === r && edR.contains(efD, i) ? t.classes[0] = "mord" : "mbin" === i && edR.contains(efM, r) && (e.classes[0] = "mord");
	}, { node: u }, d, p), efB(n, (e, t) => {
		var r = efU(t), i = efU(e), n = r && i ? e.hasClass("mtight") ? ef_[r][i] : efT[r][i] : null;
		if (n) return efx.makeGlue(n, l);
	}, { node: u }, d, p), n;
}, "buildExpression"), efB = h(function e(t, r, i, n, a) {
	n && t.push(n);
	for (var s = 0; s < t.length; s++) {
		let n;
		var o = t[s], l = efF(o);
		if (l) {
			e(l.children, r, i, null, a);
			continue;
		}
		var h = !o.hasClass("mspace");
		if (h) {
			var u = r(o, i.node);
			u && (i.insertAfter ? i.insertAfter(u) : (t.unshift(u), s++));
		}
		h ? i.node = o : a && o.hasClass("newline") && (i.node = efI(["leftmost"])), n = s, i.insertAfter = (e) => {
			t.splice(n + 1, 0, e), s++;
		};
	}
	n && t.pop();
}, "traverseNonSpaceNodes"), efF = h(function(e) {
	return e instanceof ed5 || e instanceof epy || e instanceof epm && e.hasClass("enclosing") ? e : null;
}, "checkPartialGroup"), efz = h(function e(t, r) {
	var i = efF(t);
	if (i) {
		var n = i.children;
		if (n.length) {
			if ("right" === r) return e(n[n.length - 1], "right");
			if ("left" === r) return e(n[0], "left");
		}
	}
	return t;
}, "getOutermostNode"), efU = h(function(e, t) {
	return e ? (t && (e = efz(e, t)), ef$[e.classes[0]] || null) : null;
}, "getTypeOfDomTree"), efG = h(function(e, t) {
	var r = ["nulldelimiter"].concat(e.baseSizingClasses());
	return efI(t.concat(r));
}, "makeNullDelimiter"), efq = h(function(e, t, r) {
	if (!e) return efI();
	if (efC[e.type]) {
		var i = efC[e.type](e, t);
		if (r && t.size !== r.size) {
			i = efI(t.sizingClasses(r), [i], t);
			var n = t.sizeMultiplier / r.sizeMultiplier;
			i.height *= n, i.depth *= n;
		}
		return i;
	}
	throw new edx("Got group of unknown type: '" + e.type + "'");
}, "buildGroup");
function efj(e, t) {
	var r = efI(["base"], e, t), i = efI(["strut"]);
	return i.style.height = eph(r.height + r.depth), r.depth && (i.style.verticalAlign = eph(-r.depth)), r.children.unshift(i), r;
}
function efW(e, t) {
	var r, i = null;
	1 === e.length && "tag" === e[0].type && (i = e[0].tag, e = e[0].body);
	var n, a = efP(e, t, "root");
	2 === a.length && a[1].hasClass("tag") && (n = a.pop());
	for (var s = [], o = [], l = 0; l < a.length; l++) if (o.push(a[l]), a[l].hasClass("mbin") || a[l].hasClass("mrel") || a[l].hasClass("allowbreak")) {
		for (var h = !1; l < a.length - 1 && a[l + 1].hasClass("mspace") && !a[l + 1].hasClass("newline");) l++, o.push(a[l]), a[l].hasClass("nobreak") && (h = !0);
		h || (s.push(efj(o, t)), o = []);
	} else a[l].hasClass("newline") && (o.pop(), o.length > 0 && (s.push(efj(o, t)), o = []), s.push(a[l]));
	o.length > 0 && s.push(efj(o, t)), i ? ((r = efj(efP(i, t, !0))).classes = ["tag"], s.push(r)) : n && s.push(n);
	var u = efI(["katex-html"], s);
	if (u.setAttribute("aria-hidden", "true"), r) {
		var d = r.children[0];
		d.style.height = eph(u.height + u.depth), u.depth && (d.style.verticalAlign = eph(-u.depth));
	}
	return u;
}
function efY(e) {
	return new ed5(e);
}
h(efj, "buildHTMLUnbreakable"), h(efW, "buildHTML"), h(efY, "newDocumentFragment");
var efV = class {
	static {
		h(this, "MathNode");
	}
	constructor(e, t, r) {
		this.type = void 0, this.attributes = void 0, this.children = void 0, this.classes = void 0, this.type = e, this.attributes = {}, this.children = t || [], this.classes = r || [];
	}
	setAttribute(e, t) {
		this.attributes[e] = t;
	}
	getAttribute(e) {
		return this.attributes[e];
	}
	toNode() {
		var e = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
		for (var t in this.attributes) Object.prototype.hasOwnProperty.call(this.attributes, t) && e.setAttribute(t, this.attributes[t]);
		this.classes.length > 0 && (e.className = epu(this.classes));
		for (var r = 0; r < this.children.length; r++) if (this.children[r] instanceof efH && this.children[r + 1] instanceof efH) {
			for (var i = this.children[r].toText() + this.children[++r].toText(); this.children[r + 1] instanceof efH;) i += this.children[++r].toText();
			e.appendChild(new efH(i).toNode());
		} else e.appendChild(this.children[r].toNode());
		return e;
	}
	toMarkup() {
		var e = "<" + this.type;
		for (var t in this.attributes) Object.prototype.hasOwnProperty.call(this.attributes, t) && (e += " " + t + "=\"", e += edR.escape(this.attributes[t]), e += "\"");
		this.classes.length > 0 && (e += " class =\"" + edR.escape(epu(this.classes)) + "\""), e += ">";
		for (var r = 0; r < this.children.length; r++) e += this.children[r].toMarkup();
		return e + ("</" + this.type) + ">";
	}
	toText() {
		return this.children.map((e) => e.toText()).join("");
	}
}, efH = class {
	static {
		h(this, "TextNode");
	}
	constructor(e) {
		this.text = void 0, this.text = e;
	}
	toNode() {
		return document.createTextNode(this.text);
	}
	toMarkup() {
		return edR.escape(this.toText());
	}
	toText() {
		return this.text;
	}
}, efX = class {
	static {
		h(this, "SpaceNode");
	}
	constructor(e) {
		this.width = void 0, this.character = void 0, this.width = e, e >= .05555 && e <= .05556 ? this.character = "" : e >= .1666 && e <= .1667 ? this.character = "" : e >= .2222 && e <= .2223 ? this.character = "" : e >= .2777 && e <= .2778 ? this.character = "" : e >= -.05556 && e <= -.05555 ? this.character = "" : e >= -.1667 && e <= -.1666 ? this.character = "" : e >= -.2223 && e <= -.2222 ? this.character = "" : e >= -.2778 && e <= -.2777 ? this.character = "" : this.character = null;
	}
	toNode() {
		if (this.character) return document.createTextNode(this.character);
		var e = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
		return e.setAttribute("width", eph(this.width)), e;
	}
	toMarkup() {
		return this.character ? "<mtext>" + this.character + "</mtext>" : "<mspace width=\"" + eph(this.width) + "\"/>";
	}
	toText() {
		return this.character ? this.character : " ";
	}
}, efK = h(function(e, t, r) {
	return epA[t][e] && epA[t][e].replace && 55349 !== e.charCodeAt(0) && !(epG.hasOwnProperty(e) && r && (r.fontFamily && "tt" === r.fontFamily.slice(4, 6) || r.font && "tt" === r.font.slice(4, 6))) && (e = epA[t][e].replace), new efH(e);
}, "makeText"), efZ = h(function(e) {
	return 1 === e.length ? e[0] : new efV("mrow", e);
}, "makeRow"), efQ = h(function(e, t) {
	if ("texttt" === t.fontFamily) return "monospace";
	if ("textsf" === t.fontFamily) return "textit" === t.fontShape && "textbf" === t.fontWeight ? "sans-serif-bold-italic" : "textit" === t.fontShape ? "sans-serif-italic" : "textbf" === t.fontWeight ? "bold-sans-serif" : "sans-serif";
	if ("textit" === t.fontShape && "textbf" === t.fontWeight) return "bold-italic";
	if ("textit" === t.fontShape) return "italic";
	if ("textbf" === t.fontWeight) return "bold";
	var r = t.font;
	if (!r || "mathnormal" === r) return null;
	var i = e.mode;
	if ("mathit" === r) return "italic";
	if ("boldsymbol" === r) return "textord" === e.type ? "bold" : "bold-italic";
	if ("mathbf" === r) return "bold";
	if ("mathbb" === r) return "double-struck";
	if ("mathsfit" === r) return "sans-serif-italic";
	if ("mathfrak" === r) return "fraktur";
	if ("mathscr" === r || "mathcal" === r) return "script";
	if ("mathsf" === r) return "sans-serif";
	if ("mathtt" === r) return "monospace";
	var n = e.text;
	return edR.contains(["\\imath", "\\jmath"], n) ? null : (epA[i][n] && epA[i][n].replace && (n = epA[i][n].replace), ed9(n, efx.fontMap[r].fontName, i) ? efx.fontMap[r].variant : null);
}, "getVariant");
function efJ(e) {
	if (!e) return !1;
	if ("mi" === e.type && 1 === e.children.length) {
		var t = e.children[0];
		return t instanceof efH && "." === t.text;
	}
	if ("mo" !== e.type || 1 !== e.children.length || "true" !== e.getAttribute("separator") || "0em" !== e.getAttribute("lspace") || "0em" !== e.getAttribute("rspace")) return !1;
	var r = e.children[0];
	return r instanceof efH && "," === r.text;
}
h(efJ, "isNumberPunctuation");
var ef0 = h(function(e, t, r) {
	if (1 === e.length) {
		var i = ef2(e[0], t);
		return r && i instanceof efV && "mo" === i.type && (i.setAttribute("lspace", "0em"), i.setAttribute("rspace", "0em")), [i];
	}
	for (var n, a = [], s = 0; s < e.length; s++) {
		var o = ef2(e[s], t);
		if (o instanceof efV && n instanceof efV) {
			if ("mtext" === o.type && "mtext" === n.type && o.getAttribute("mathvariant") === n.getAttribute("mathvariant")) {
				n.children.push(...o.children);
				continue;
			} else if ("mn" === o.type && "mn" === n.type) {
				n.children.push(...o.children);
				continue;
			} else if (efJ(o) && "mn" === n.type) {
				n.children.push(...o.children);
				continue;
			} else if ("mn" === o.type && efJ(n)) o.children = [...n.children, ...o.children], a.pop();
			else if (("msup" === o.type || "msub" === o.type) && o.children.length >= 1 && ("mn" === n.type || efJ(n))) {
				var l = o.children[0];
				l instanceof efV && "mn" === l.type && (l.children = [...n.children, ...l.children], a.pop());
			} else if ("mi" === n.type && 1 === n.children.length) {
				var h = n.children[0];
				if (h instanceof efH && "" === h.text && ("mo" === o.type || "mi" === o.type || "mn" === o.type)) {
					var u = o.children[0];
					u instanceof efH && u.text.length > 0 && (u.text = u.text.slice(0, 1) + "" + u.text.slice(1), a.pop());
				}
			}
		}
		a.push(o), n = o;
	}
	return a;
}, "buildExpression"), ef1 = h(function(e, t, r) {
	return efZ(ef0(e, t, r));
}, "buildExpressionRow"), ef2 = h(function(e, t) {
	if (!e) return new efV("mrow");
	if (efS[e.type]) return efS[e.type](e, t);
	throw new edx("Got group of unknown type: '" + e.type + "'");
}, "buildGroup");
function ef4(e, t, r, i, n) {
	var a, s = ef0(e, r);
	a = 1 === s.length && s[0] instanceof efV && edR.contains(["mrow", "mtable"], s[0].type) ? s[0] : new efV("mrow", s);
	var o = new efV("annotation", [new efH(t)]);
	o.setAttribute("encoding", "application/x-tex");
	var h = new efV("math", [new efV("semantics", [a, o])]);
	return h.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML"), i && h.setAttribute("display", "block"), efx.makeSpan([n ? "katex" : "katex-mathml"], [h]);
}
h(ef4, "buildMathML");
var ef5 = h(function(e) {
	return new epa({
		style: e.displayMode ? edG.DISPLAY : edG.TEXT,
		maxSize: e.maxSize,
		minRuleThickness: e.minRuleThickness
	});
}, "optionsFromSettings"), ef3 = h(function(e, t) {
	if (t.displayMode) {
		var r = ["katex-display"];
		t.leqno && r.push("leqno"), t.fleqn && r.push("fleqn"), e = efx.makeSpan(r, [e]);
	}
	return e;
}, "displayWrap"), ef6 = h(function(e, t, r) {
	var i, n = ef5(r);
	if ("mathml" === r.output) return ef4(e, t, n, r.displayMode, !0);
	if ("html" === r.output) {
		var a = efW(e, n);
		i = efx.makeSpan(["katex"], [a]);
	} else {
		var s = ef4(e, t, n, r.displayMode, !1), o = efW(e, n);
		i = efx.makeSpan(["katex"], [s, o]);
	}
	return ef3(i, r);
}, "buildTree"), ef7 = h(function(e, t, r) {
	var i = efW(e, ef5(r));
	return ef3(efx.makeSpan(["katex"], [i]), r);
}, "buildHTMLTree"), ef8 = {
	widehat: "^",
	widecheck: "",
	widetilde: "~",
	utilde: "~",
	overleftarrow: "",
	underleftarrow: "",
	xleftarrow: "",
	overrightarrow: "",
	underrightarrow: "",
	xrightarrow: "",
	underbrace: "",
	overbrace: "",
	overgroup: "",
	undergroup: "",
	overleftrightarrow: "",
	underleftrightarrow: "",
	xleftrightarrow: "",
	Overrightarrow: "",
	xRightarrow: "",
	overleftharpoon: "",
	xleftharpoonup: "",
	overrightharpoon: "",
	xrightharpoonup: "",
	xLeftarrow: "",
	xLeftrightarrow: "",
	xhookleftarrow: "",
	xhookrightarrow: "",
	xmapsto: "",
	xrightharpoondown: "",
	xleftharpoondown: "",
	xrightleftharpoons: "",
	xleftrightharpoons: "",
	xtwoheadleftarrow: "",
	xtwoheadrightarrow: "",
	xlongequal: "=",
	xtofrom: "",
	xrightleftarrows: "",
	xrightequilibrium: "",
	xleftequilibrium: "",
	"\\cdrightarrow": "",
	"\\cdleftarrow": "",
	"\\cdlongequal": "="
}, ef9 = h(function(e) {
	var t = new efV("mo", [new efH(ef8[e.replace(/^\\/, "")])]);
	return t.setAttribute("stretchy", "true"), t;
}, "mathMLnode"), ege = {
	overrightarrow: [
		["rightarrow"],
		.888,
		522,
		"xMaxYMin"
	],
	overleftarrow: [
		["leftarrow"],
		.888,
		522,
		"xMinYMin"
	],
	underrightarrow: [
		["rightarrow"],
		.888,
		522,
		"xMaxYMin"
	],
	underleftarrow: [
		["leftarrow"],
		.888,
		522,
		"xMinYMin"
	],
	xrightarrow: [
		["rightarrow"],
		1.469,
		522,
		"xMaxYMin"
	],
	"\\cdrightarrow": [
		["rightarrow"],
		3,
		522,
		"xMaxYMin"
	],
	xleftarrow: [
		["leftarrow"],
		1.469,
		522,
		"xMinYMin"
	],
	"\\cdleftarrow": [
		["leftarrow"],
		3,
		522,
		"xMinYMin"
	],
	Overrightarrow: [
		["doublerightarrow"],
		.888,
		560,
		"xMaxYMin"
	],
	xRightarrow: [
		["doublerightarrow"],
		1.526,
		560,
		"xMaxYMin"
	],
	xLeftarrow: [
		["doubleleftarrow"],
		1.526,
		560,
		"xMinYMin"
	],
	overleftharpoon: [
		["leftharpoon"],
		.888,
		522,
		"xMinYMin"
	],
	xleftharpoonup: [
		["leftharpoon"],
		.888,
		522,
		"xMinYMin"
	],
	xleftharpoondown: [
		["leftharpoondown"],
		.888,
		522,
		"xMinYMin"
	],
	overrightharpoon: [
		["rightharpoon"],
		.888,
		522,
		"xMaxYMin"
	],
	xrightharpoonup: [
		["rightharpoon"],
		.888,
		522,
		"xMaxYMin"
	],
	xrightharpoondown: [
		["rightharpoondown"],
		.888,
		522,
		"xMaxYMin"
	],
	xlongequal: [
		["longequal"],
		.888,
		334,
		"xMinYMin"
	],
	"\\cdlongequal": [
		["longequal"],
		3,
		334,
		"xMinYMin"
	],
	xtwoheadleftarrow: [
		["twoheadleftarrow"],
		.888,
		334,
		"xMinYMin"
	],
	xtwoheadrightarrow: [
		["twoheadrightarrow"],
		.888,
		334,
		"xMaxYMin"
	],
	overleftrightarrow: [
		["leftarrow", "rightarrow"],
		.888,
		522
	],
	overbrace: [
		[
			"leftbrace",
			"midbrace",
			"rightbrace"
		],
		1.6,
		548
	],
	underbrace: [
		[
			"leftbraceunder",
			"midbraceunder",
			"rightbraceunder"
		],
		1.6,
		548
	],
	underleftrightarrow: [
		["leftarrow", "rightarrow"],
		.888,
		522
	],
	xleftrightarrow: [
		["leftarrow", "rightarrow"],
		1.75,
		522
	],
	xLeftrightarrow: [
		["doubleleftarrow", "doublerightarrow"],
		1.75,
		560
	],
	xrightleftharpoons: [
		["leftharpoondownplus", "rightharpoonplus"],
		1.75,
		716
	],
	xleftrightharpoons: [
		["leftharpoonplus", "rightharpoondownplus"],
		1.75,
		716
	],
	xhookleftarrow: [
		["leftarrow", "righthook"],
		1.08,
		522
	],
	xhookrightarrow: [
		["lefthook", "rightarrow"],
		1.08,
		522
	],
	overlinesegment: [
		["leftlinesegment", "rightlinesegment"],
		.888,
		522
	],
	underlinesegment: [
		["leftlinesegment", "rightlinesegment"],
		.888,
		522
	],
	overgroup: [
		["leftgroup", "rightgroup"],
		.888,
		342
	],
	undergroup: [
		["leftgroupunder", "rightgroupunder"],
		.888,
		342
	],
	xmapsto: [
		["leftmapsto", "rightarrow"],
		1.5,
		522
	],
	xtofrom: [
		["leftToFrom", "rightToFrom"],
		1.75,
		528
	],
	xrightleftarrows: [
		["baraboveleftarrow", "rightarrowabovebar"],
		1.75,
		901
	],
	xrightequilibrium: [
		["baraboveshortleftharpoon", "rightharpoonaboveshortbar"],
		1.75,
		716
	],
	xleftequilibrium: [
		["shortbaraboveleftharpoon", "shortrightharpoonabovebar"],
		1.75,
		716
	]
}, egt = h(function(e) {
	return "ordgroup" === e.type ? e.body.length : 1;
}, "groupLength"), egr = h(function(e, t) {
	function r() {
		var r = 4e5, i = e.label.slice(1);
		if (edR.contains([
			"widehat",
			"widecheck",
			"widetilde",
			"utilde"
		], i)) {
			var n, a, s, o = egt(e.base);
			if (o > 5) "widehat" === i || "widecheck" === i ? (n = 420, r = 2364, s = .42, a = i + "4") : (n = 312, r = 2340, s = .34, a = "tilde4");
			else {
				var l = [
					1,
					1,
					2,
					2,
					3,
					3
				][o];
				"widehat" === i || "widecheck" === i ? (r = [
					0,
					1062,
					2364,
					2364,
					2364
				][l], n = [
					0,
					239,
					300,
					360,
					420
				][l], s = [
					0,
					.24,
					.3,
					.3,
					.36,
					.42
				][l], a = i + l) : (r = [
					0,
					600,
					1033,
					2339,
					2340
				][l], n = [
					0,
					260,
					286,
					306,
					312
				][l], s = [
					0,
					.26,
					.286,
					.3,
					.306,
					.34
				][l], a = "tilde" + l);
			}
			var h = new epw([new epk(a)], {
				width: "100%",
				height: eph(s),
				viewBox: "0 0 " + r + " " + n,
				preserveAspectRatio: "none"
			});
			return {
				span: efx.makeSvgSpan([], [h], t),
				minWidth: 0,
				height: s
			};
		}
		var u, d, p = [], f = ege[i], [g, m, y] = f, v = y / 1e3, x = g.length;
		if (1 === x) u = ["hide-tail"], d = [f[3]];
		else if (2 === x) u = ["halfarrow-left", "halfarrow-right"], d = ["xMinYMin", "xMaxYMin"];
		else if (3 === x) u = [
			"brace-left",
			"brace-center",
			"brace-right"
		], d = [
			"xMinYMin",
			"xMidYMin",
			"xMaxYMin"
		];
		else throw Error(`Correct katexImagesData or update code here to support
                    ` + x + " children.");
		for (var b = 0; b < x; b++) {
			var w = new epw([new epk(g[b])], {
				width: "400em",
				height: eph(v),
				viewBox: "0 0 " + r + " " + y,
				preserveAspectRatio: d[b] + " slice"
			}), k = efx.makeSvgSpan([u[b]], [w], t);
			if (1 === x) return {
				span: k,
				minWidth: m,
				height: v
			};
			k.style.height = eph(v), p.push(k);
		}
		return {
			span: efx.makeSpan(["stretchy"], p, t),
			minWidth: m,
			height: v
		};
	}
	h(r, "buildSvgSpan_");
	var { span: i, minWidth: n, height: a } = r();
	return i.height = a, i.style.height = eph(a), n > 0 && (i.style.minWidth = eph(n)), i;
}, "svgSpan"), egi = {
	encloseSpan: h(function(e, t, r, i, n) {
		var a, s = e.height + e.depth + r + i;
		if (/fbox|color|angl/.test(t)) {
			if (a = efx.makeSpan(["stretchy", t], [], n), "fbox" === t) {
				var o = n.color && n.getColor();
				o && (a.style.borderColor = o);
			}
		} else {
			var l = [];
			/^[bx]cancel$/.test(t) && l.push(new epT({
				x1: "0",
				y1: "0",
				x2: "100%",
				y2: "100%",
				"stroke-width": "0.046em"
			})), /^x?cancel$/.test(t) && l.push(new epT({
				x1: "0",
				y1: "100%",
				x2: "100%",
				y2: "0",
				"stroke-width": "0.046em"
			}));
			var h = new epw(l, {
				width: "100%",
				height: eph(s)
			});
			a = efx.makeSvgSpan([], [h], n);
		}
		return a.height = s, a.style.height = eph(s), a;
	}, "encloseSpan"),
	mathMLnode: ef9,
	svgSpan: egr
};
function egn(e, t) {
	if (!e || e.type !== t) throw Error("Expected node of type " + t + ", but got " + (e ? "node of type " + e.type : String(e)));
	return e;
}
function ega(e) {
	var t = egs(e);
	if (!t) throw Error("Expected node of symbol group type, but got " + (e ? "node of type " + e.type : String(e)));
	return t;
}
function egs(e) {
	return e && ("atom" === e.type || epS.hasOwnProperty(e.type)) ? e : null;
}
h(egn, "assertNodeType"), h(ega, "assertSymbolNodeType"), h(egs, "checkSymbolNodeType");
var ego = h((e, t) => {
	e && "supsub" === e.type ? (a = (s = egn(e.base, "accent")).base, e.base = a, o = epE(efq(e, t)), e.base = s) : a = (s = egn(e, "accent")).base;
	var r = efq(a, t.havingCrampedStyle()), i = s.isShifty && edR.isCharacterBox(a), n = 0;
	i && (n = ep_(efq(edR.getBaseElem(a), t.havingCrampedStyle())).skew);
	var a, s, o, l, h = "\\c" === s.label, u = h ? r.height + r.depth : Math.min(r.height, t.fontMetrics().xHeight);
	if (s.isStretchy) l = egi.svgSpan(s, t), l = efx.makeVList({
		positionType: "firstBaseline",
		children: [{
			type: "elem",
			elem: r
		}, {
			type: "elem",
			elem: l,
			wrapperClasses: ["svg-align"],
			wrapperStyle: n > 0 ? {
				width: "calc(100% - " + eph(2 * n) + ")",
				marginLeft: eph(2 * n)
			} : void 0
		}]
	}, t);
	else {
		"\\vec" === s.label ? (d = efx.staticSvg("vec", t), p = efx.svgData.vec[1]) : ((d = ep_(d = efx.makeOrd({
			mode: s.mode,
			text: s.label
		}, t, "textord"))).italic = 0, p = d.width, h && (u += d.depth)), l = efx.makeSpan(["accent-body"], [d]);
		var d, p, f = "\\textcircled" === s.label;
		f && (l.classes.push("accent-full"), u = r.height);
		var g = n;
		f || (g -= p / 2), l.style.left = eph(g), "\\textcircled" === s.label && (l.style.top = ".2em"), l = efx.makeVList({
			positionType: "firstBaseline",
			children: [
				{
					type: "elem",
					elem: r
				},
				{
					type: "kern",
					size: -u
				},
				{
					type: "elem",
					elem: l
				}
			]
		}, t);
	}
	var m = efx.makeSpan(["mord", "accent"], [l], t);
	return o ? (o.children[0] = m, o.height = Math.max(m.height, o.height), o.classes[0] = "mord", o) : m;
}, "htmlBuilder$a"), egl = h((e, t) => {
	var r = e.isStretchy ? egi.mathMLnode(e.label) : new efV("mo", [efK(e.label, e.mode)]), i = new efV("mover", [ef2(e.base, t), r]);
	return i.setAttribute("accent", "true"), i;
}, "mathmlBuilder$9"), egc = new RegExp([
	"\\acute",
	"\\grave",
	"\\ddot",
	"\\tilde",
	"\\bar",
	"\\breve",
	"\\check",
	"\\hat",
	"\\vec",
	"\\dot",
	"\\mathring"
].map((e) => "\\" + e).join("|"));
efA({
	type: "accent",
	names: [
		"\\acute",
		"\\grave",
		"\\ddot",
		"\\tilde",
		"\\bar",
		"\\breve",
		"\\check",
		"\\hat",
		"\\vec",
		"\\dot",
		"\\mathring",
		"\\widecheck",
		"\\widehat",
		"\\widetilde",
		"\\overrightarrow",
		"\\overleftarrow",
		"\\Overrightarrow",
		"\\overleftrightarrow",
		"\\overgroup",
		"\\overlinesegment",
		"\\overleftharpoon",
		"\\overrightharpoon"
	],
	props: { numArgs: 1 },
	handler: h((e, t) => {
		var r = efR(t[0]), i = !egc.test(e.funcName), n = !i || "\\widehat" === e.funcName || "\\widetilde" === e.funcName || "\\widecheck" === e.funcName;
		return {
			type: "accent",
			mode: e.parser.mode,
			label: e.funcName,
			isStretchy: i,
			isShifty: n,
			base: r
		};
	}, "handler"),
	htmlBuilder: ego,
	mathmlBuilder: egl
}), efA({
	type: "accent",
	names: [
		"\\'",
		"\\`",
		"\\^",
		"\\~",
		"\\=",
		"\\u",
		"\\.",
		"\\\"",
		"\\c",
		"\\r",
		"\\H",
		"\\v",
		"\\textcircled"
	],
	props: {
		numArgs: 1,
		allowedInText: !0,
		allowedInMath: !0,
		argTypes: ["primitive"]
	},
	handler: h((e, t) => {
		var r = t[0], i = e.parser.mode;
		return "math" === i && (e.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + e.funcName + " works only in text mode"), i = "text"), {
			type: "accent",
			mode: i,
			label: e.funcName,
			isStretchy: !1,
			isShifty: !0,
			base: r
		};
	}, "handler"),
	htmlBuilder: ego,
	mathmlBuilder: egl
}), efA({
	type: "accentUnder",
	names: [
		"\\underleftarrow",
		"\\underrightarrow",
		"\\underleftrightarrow",
		"\\undergroup",
		"\\underlinesegment",
		"\\utilde"
	],
	props: { numArgs: 1 },
	handler: h((e, t) => {
		var { parser: r, funcName: i } = e, n = t[0];
		return {
			type: "accentUnder",
			mode: r.mode,
			label: i,
			base: n
		};
	}, "handler"),
	htmlBuilder: h((e, t) => {
		var r = efq(e.base, t), i = egi.svgSpan(e, t), n = .12 * ("\\utilde" === e.label), a = efx.makeVList({
			positionType: "top",
			positionData: r.height,
			children: [
				{
					type: "elem",
					elem: i,
					wrapperClasses: ["svg-align"]
				},
				{
					type: "kern",
					size: n
				},
				{
					type: "elem",
					elem: r
				}
			]
		}, t);
		return efx.makeSpan(["mord", "accentunder"], [a], t);
	}, "htmlBuilder"),
	mathmlBuilder: h((e, t) => {
		var r = egi.mathMLnode(e.label), i = new efV("munder", [ef2(e.base, t), r]);
		return i.setAttribute("accentunder", "true"), i;
	}, "mathmlBuilder")
});
var egh = h((e) => {
	var t = new efV("mpadded", e ? [e] : []);
	return t.setAttribute("width", "+0.6em"), t.setAttribute("lspace", "0.3em"), t;
}, "paddedNode");
efA({
	type: "xArrow",
	names: [
		"\\xleftarrow",
		"\\xrightarrow",
		"\\xLeftarrow",
		"\\xRightarrow",
		"\\xleftrightarrow",
		"\\xLeftrightarrow",
		"\\xhookleftarrow",
		"\\xhookrightarrow",
		"\\xmapsto",
		"\\xrightharpoondown",
		"\\xrightharpoonup",
		"\\xleftharpoondown",
		"\\xleftharpoonup",
		"\\xrightleftharpoons",
		"\\xleftrightharpoons",
		"\\xlongequal",
		"\\xtwoheadrightarrow",
		"\\xtwoheadleftarrow",
		"\\xtofrom",
		"\\xrightleftarrows",
		"\\xrightequilibrium",
		"\\xleftequilibrium",
		"\\\\cdrightarrow",
		"\\\\cdleftarrow",
		"\\\\cdlongequal"
	],
	props: {
		numArgs: 1,
		numOptionalArgs: 1
	},
	handler(e, t, r) {
		var { parser: i, funcName: n } = e;
		return {
			type: "xArrow",
			mode: i.mode,
			label: n,
			body: t[0],
			below: r[0]
		};
	},
	htmlBuilder(e, t) {
		var r, i, n = t.style, a = t.havingStyle(n.sup()), s = efx.wrapFragment(efq(e.body, a, t), t), o = "\\x" === e.label.slice(0, 2) ? "x" : "cd";
		s.classes.push(o + "-arrow-pad"), e.below && (a = t.havingStyle(n.sub()), (r = efx.wrapFragment(efq(e.below, a, t), t)).classes.push(o + "-arrow-pad"));
		var l = egi.svgSpan(e, t), h = -t.fontMetrics().axisHeight + .5 * l.height, u = -t.fontMetrics().axisHeight - .5 * l.height - .111;
		if ((s.depth > .25 || "\\xleftequilibrium" === e.label) && (u -= s.depth), r) {
			var d = -t.fontMetrics().axisHeight + r.height + .5 * l.height + .111;
			i = efx.makeVList({
				positionType: "individualShift",
				children: [
					{
						type: "elem",
						elem: s,
						shift: u
					},
					{
						type: "elem",
						elem: l,
						shift: h
					},
					{
						type: "elem",
						elem: r,
						shift: d
					}
				]
			}, t);
		} else i = efx.makeVList({
			positionType: "individualShift",
			children: [{
				type: "elem",
				elem: s,
				shift: u
			}, {
				type: "elem",
				elem: l,
				shift: h
			}]
		}, t);
		return i.children[0].children[0].children[1].classes.push("svg-align"), efx.makeSpan(["mrel", "x-arrow"], [i], t);
	},
	mathmlBuilder(e, t) {
		var r, i = egi.mathMLnode(e.label);
		if (i.setAttribute("minsize", "x" === e.label.charAt(0) ? "1.75em" : "3.0em"), e.body) {
			var n = egh(ef2(e.body, t));
			r = e.below ? new efV("munderover", [
				i,
				egh(ef2(e.below, t)),
				n
			]) : new efV("mover", [i, n]);
		} else r = e.below ? new efV("munder", [i, egh(ef2(e.below, t))]) : new efV("mover", [i, r = egh()]);
		return r;
	}
});
var egu = efx.makeSpan;
function egd(e, t) {
	var r = efP(e.body, t, !0);
	return egu([e.mclass], r, t);
}
function egp(e, t) {
	var r, i = ef0(e.body, t);
	return "minner" === e.mclass ? r = new efV("mpadded", i) : "mord" === e.mclass ? e.isCharacterBox ? (r = i[0]).type = "mi" : r = new efV("mi", i) : (e.isCharacterBox ? (r = i[0]).type = "mo" : r = new efV("mo", i), "mbin" === e.mclass ? (r.attributes.lspace = "0.22em", r.attributes.rspace = "0.22em") : "mpunct" === e.mclass ? (r.attributes.lspace = "0em", r.attributes.rspace = "0.17em") : "mopen" === e.mclass || "mclose" === e.mclass ? (r.attributes.lspace = "0em", r.attributes.rspace = "0em") : "minner" === e.mclass && (r.attributes.lspace = "0.0556em", r.attributes.width = "+0.1111em")), r;
}
h(egd, "htmlBuilder$9"), h(egp, "mathmlBuilder$8"), efA({
	type: "mclass",
	names: [
		"\\mathord",
		"\\mathbin",
		"\\mathrel",
		"\\mathopen",
		"\\mathclose",
		"\\mathpunct",
		"\\mathinner"
	],
	props: {
		numArgs: 1,
		primitive: !0
	},
	handler(e, t) {
		var { parser: r, funcName: i } = e, n = t[0];
		return {
			type: "mclass",
			mode: r.mode,
			mclass: "m" + i.slice(5),
			body: efN(n),
			isCharacterBox: edR.isCharacterBox(n)
		};
	},
	htmlBuilder: egd,
	mathmlBuilder: egp
});
var egf = h((e) => {
	var t = "ordgroup" === e.type && e.body.length ? e.body[0] : e;
	return "atom" === t.type && ("bin" === t.family || "rel" === t.family) ? "m" + t.family : "mord";
}, "binrelClass");
efA({
	type: "mclass",
	names: ["\\@binrel"],
	props: { numArgs: 2 },
	handler(e, t) {
		var { parser: r } = e;
		return {
			type: "mclass",
			mode: r.mode,
			mclass: egf(t[0]),
			body: efN(t[1]),
			isCharacterBox: edR.isCharacterBox(t[1])
		};
	}
}), efA({
	type: "mclass",
	names: [
		"\\stackrel",
		"\\overset",
		"\\underset"
	],
	props: { numArgs: 2 },
	handler(e, t) {
		var r, { parser: i, funcName: n } = e, a = t[1], s = t[0];
		r = "\\stackrel" !== n ? egf(a) : "mrel";
		var o = {
			type: "op",
			mode: a.mode,
			limits: !0,
			alwaysHandleSupSub: !0,
			parentIsSupSub: !1,
			symbol: !1,
			suppressBaseShift: "\\stackrel" !== n,
			body: efN(a)
		}, l = {
			type: "supsub",
			mode: s.mode,
			base: o,
			sup: "\\underset" === n ? null : s,
			sub: "\\underset" === n ? s : null
		};
		return {
			type: "mclass",
			mode: i.mode,
			mclass: r,
			body: [l],
			isCharacterBox: edR.isCharacterBox(l)
		};
	},
	htmlBuilder: egd,
	mathmlBuilder: egp
}), efA({
	type: "pmb",
	names: ["\\pmb"],
	props: {
		numArgs: 1,
		allowedInText: !0
	},
	handler(e, t) {
		var { parser: r } = e;
		return {
			type: "pmb",
			mode: r.mode,
			mclass: egf(t[0]),
			body: efN(t[0])
		};
	},
	htmlBuilder(e, t) {
		var r = efP(e.body, t, !0), i = efx.makeSpan([e.mclass], r, t);
		return i.style.textShadow = "0.02em 0.01em 0.04px", i;
	},
	mathmlBuilder(e, t) {
		var r = new efV("mstyle", ef0(e.body, t));
		return r.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px"), r;
	}
});
var egg = {
	">": "\\\\cdrightarrow",
	"<": "\\\\cdleftarrow",
	"=": "\\\\cdlongequal",
	A: "\\uparrow",
	V: "\\downarrow",
	"|": "\\Vert",
	".": "no arrow"
}, egm = h(() => ({
	type: "styling",
	body: [],
	mode: "math",
	style: "display"
}), "newCell"), egy = h((e) => "textord" === e.type && "@" === e.text, "isStartOfArrow"), egv = h((e, t) => ("mathord" === e.type || "atom" === e.type) && e.text === t, "isLabelEnd");
function egx(e, t, r) {
	var i = egg[e];
	switch (i) {
		case "\\\\cdrightarrow":
		case "\\\\cdleftarrow": return r.callFunction(i, [t[0]], [t[1]]);
		case "\\uparrow":
		case "\\downarrow":
			var n = {
				type: "ordgroup",
				mode: "math",
				body: [
					r.callFunction("\\\\cdleft", [t[0]], []),
					r.callFunction("\\Big", [{
						type: "atom",
						text: i,
						mode: "math",
						family: "rel"
					}], []),
					r.callFunction("\\\\cdright", [t[1]], [])
				]
			};
			return r.callFunction("\\\\cdparent", [n], []);
		case "\\\\cdlongequal": return r.callFunction("\\\\cdlongequal", [], []);
		case "\\Vert": return r.callFunction("\\Big", [{
			type: "textord",
			text: "\\Vert",
			mode: "math"
		}], []);
		default: return {
			type: "textord",
			text: " ",
			mode: "math"
		};
	}
}
function egb(e) {
	var t = [];
	for (e.gullet.beginGroup(), e.gullet.macros.set("\\cr", "\\\\\\relax"), e.gullet.beginGroup();;) {
		t.push(e.parseExpression(!1, "\\\\")), e.gullet.endGroup(), e.gullet.beginGroup();
		var r = e.fetch().text;
		if ("&" === r || "\\\\" === r) e.consume();
		else if ("\\end" === r) {
			0 === t[t.length - 1].length && t.pop();
			break;
		} else throw new edx("Expected \\\\ or \\cr or \\end", e.nextToken);
	}
	for (var i = [], n = [i], a = 0; a < t.length; a++) {
		for (var s = t[a], o = egm(), l = 0; l < s.length; l++) if (egy(s[l])) {
			i.push(o);
			var h = ega(s[l += 1]).text, u = [, ,];
			if (u[0] = {
				type: "ordgroup",
				mode: "math",
				body: []
			}, u[1] = {
				type: "ordgroup",
				mode: "math",
				body: []
			}, !("=|.".indexOf(h) > -1)) if ("<>AV".indexOf(h) > -1) for (var d = 0; d < 2; d++) {
				for (var p = !0, f = l + 1; f < s.length; f++) {
					if (egv(s[f], h)) {
						p = !1, l = f;
						break;
					}
					if (egy(s[f])) throw new edx("Missing a " + h + " character to complete a CD arrow.", s[f]);
					u[d].body.push(s[f]);
				}
				if (p) throw new edx("Missing a " + h + " character to complete a CD arrow.", s[l]);
			}
			else throw new edx("Expected one of \"<>AV=|.\" after @", s[l]);
			var g = {
				type: "styling",
				body: [egx(h, u, e)],
				mode: "math",
				style: "display"
			};
			i.push(g), o = egm();
		} else o.body.push(s[l]);
		a % 2 == 0 ? i.push(o) : i.shift(), i = [], n.push(i);
	}
	return e.gullet.endGroup(), e.gullet.endGroup(), {
		type: "array",
		mode: "math",
		body: n,
		arraystretch: 1,
		addJot: !0,
		rowGaps: [null],
		cols: Array(n[0].length).fill({
			type: "align",
			align: "c",
			pregap: .25,
			postgap: .25
		}),
		colSeparationType: "CD",
		hLinesBeforeRow: Array(n.length + 1).fill([])
	};
}
h(egx, "cdArrow"), h(egb, "parseCD"), efA({
	type: "cdlabel",
	names: ["\\\\cdleft", "\\\\cdright"],
	props: { numArgs: 1 },
	handler(e, t) {
		var { parser: r, funcName: i } = e;
		return {
			type: "cdlabel",
			mode: r.mode,
			side: i.slice(4),
			label: t[0]
		};
	},
	htmlBuilder(e, t) {
		var r = t.havingStyle(t.style.sup()), i = efx.wrapFragment(efq(e.label, r, t), t);
		return i.classes.push("cd-label-" + e.side), i.style.bottom = eph(.8 - i.depth), i.height = 0, i.depth = 0, i;
	},
	mathmlBuilder(e, t) {
		var r = new efV("mrow", [ef2(e.label, t)]);
		return (r = new efV("mpadded", [r])).setAttribute("width", "0"), "left" === e.side && r.setAttribute("lspace", "-1width"), r.setAttribute("voffset", "0.7em"), (r = new efV("mstyle", [r])).setAttribute("displaystyle", "false"), r.setAttribute("scriptlevel", "1"), r;
	}
}), efA({
	type: "cdlabelparent",
	names: ["\\\\cdparent"],
	props: { numArgs: 1 },
	handler(e, t) {
		var { parser: r } = e;
		return {
			type: "cdlabelparent",
			mode: r.mode,
			fragment: t[0]
		};
	},
	htmlBuilder(e, t) {
		var r = efx.wrapFragment(efq(e.fragment, t), t);
		return r.classes.push("cd-vert-arrow"), r;
	},
	mathmlBuilder: (e, t) => new efV("mrow", [ef2(e.fragment, t)])
}), efA({
	type: "textord",
	names: ["\\@char"],
	props: {
		numArgs: 1,
		allowedInText: !0
	},
	handler(e, t) {
		for (var { parser: r } = e, i = egn(t[0], "ordgroup").body, n = "", a = 0; a < i.length; a++) n += egn(i[a], "textord").text;
		var s, o = parseInt(n);
		if (isNaN(o)) throw new edx("\\@char has non-numeric argument " + n);
		if (o < 0 || o >= 1114111) throw new edx("\\@char with invalid code point " + n);
		return o <= 65535 ? s = String.fromCharCode(o) : (o -= 65536, s = String.fromCharCode((o >> 10) + 55296, (1023 & o) + 56320)), {
			type: "textord",
			mode: r.mode,
			text: s
		};
	}
});
var egw = h((e, t) => {
	var r = efP(e.body, t.withColor(e.color), !1);
	return efx.makeFragment(r);
}, "htmlBuilder$8"), egk = h((e, t) => {
	var r = new efV("mstyle", ef0(e.body, t.withColor(e.color)));
	return r.setAttribute("mathcolor", e.color), r;
}, "mathmlBuilder$7");
efA({
	type: "color",
	names: ["\\textcolor"],
	props: {
		numArgs: 2,
		allowedInText: !0,
		argTypes: ["color", "original"]
	},
	handler(e, t) {
		var { parser: r } = e, i = egn(t[0], "color-token").color, n = t[1];
		return {
			type: "color",
			mode: r.mode,
			color: i,
			body: efN(n)
		};
	},
	htmlBuilder: egw,
	mathmlBuilder: egk
}), efA({
	type: "color",
	names: ["\\color"],
	props: {
		numArgs: 1,
		allowedInText: !0,
		argTypes: ["color"]
	},
	handler(e, t) {
		var { parser: r, breakOnTokenText: i } = e, n = egn(t[0], "color-token").color;
		r.gullet.macros.set("\\current@color", n);
		var a = r.parseExpression(!0, i);
		return {
			type: "color",
			mode: r.mode,
			color: n,
			body: a
		};
	},
	htmlBuilder: egw,
	mathmlBuilder: egk
}), efA({
	type: "cr",
	names: ["\\\\"],
	props: {
		numArgs: 0,
		numOptionalArgs: 0,
		allowedInText: !0
	},
	handler(e, t, r) {
		var { parser: i } = e, n = "[" === i.gullet.future().text ? i.parseSizeGroup(!0) : null, a = !i.settings.displayMode || !i.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
		return {
			type: "cr",
			mode: i.mode,
			newLine: a,
			size: n && egn(n, "size").value
		};
	},
	htmlBuilder(e, t) {
		var r = efx.makeSpan(["mspace"], [], t);
		return e.newLine && (r.classes.push("newline"), e.size && (r.style.marginTop = eph(epc(e.size, t)))), r;
	},
	mathmlBuilder(e, t) {
		var r = new efV("mspace");
		return e.newLine && (r.setAttribute("linebreak", "newline"), e.size && r.setAttribute("height", eph(epc(e.size, t)))), r;
	}
});
var egT = {
	"\\global": "\\global",
	"\\long": "\\\\globallong",
	"\\\\globallong": "\\\\globallong",
	"\\def": "\\gdef",
	"\\gdef": "\\gdef",
	"\\edef": "\\xdef",
	"\\xdef": "\\xdef",
	"\\let": "\\\\globallet",
	"\\futurelet": "\\\\globalfuture"
}, eg_ = h((e) => {
	var t = e.text;
	if (/^(?:[\\{}$&#^_]|EOF)$/.test(t)) throw new edx("Expected a control sequence", e);
	return t;
}, "checkControlSequence"), egE = h((e) => {
	var t = e.gullet.popToken();
	return "=" === t.text && " " === (t = e.gullet.popToken()).text && (t = e.gullet.popToken()), t;
}, "getRHS"), egC = h((e, t, r, i) => {
	var n = e.gullet.macros.get(r.text);
	n ?? (r.noexpand = !0, n = {
		tokens: [r],
		numArgs: 0,
		unexpandable: !e.gullet.isExpandable(r.text)
	}), e.gullet.macros.set(t, n, i);
}, "letCommand");
efA({
	type: "internal",
	names: [
		"\\global",
		"\\long",
		"\\\\globallong"
	],
	props: {
		numArgs: 0,
		allowedInText: !0
	},
	handler(e) {
		var { parser: t, funcName: r } = e;
		t.consumeSpaces();
		var i = t.fetch();
		if (egT[i.text]) return ("\\global" === r || "\\\\globallong" === r) && (i.text = egT[i.text]), egn(t.parseFunction(), "internal");
		throw new edx("Invalid token after macro prefix", i);
	}
}), efA({
	type: "internal",
	names: [
		"\\def",
		"\\gdef",
		"\\edef",
		"\\xdef"
	],
	props: {
		numArgs: 0,
		allowedInText: !0,
		primitive: !0
	},
	handler(e) {
		var { parser: t, funcName: r } = e, i = t.gullet.popToken(), n = i.text;
		if (/^(?:[\\{}$&#^_]|EOF)$/.test(n)) throw new edx("Expected a control sequence", i);
		for (var a, s = 0, o = [[]]; "{" !== t.gullet.future().text;) if ("#" === (i = t.gullet.popToken()).text) {
			if ("{" === t.gullet.future().text) {
				a = t.gullet.future(), o[s].push("{");
				break;
			}
			if (i = t.gullet.popToken(), !/^[1-9]$/.test(i.text)) throw new edx("Invalid argument number \"" + i.text + "\"");
			if (parseInt(i.text) !== s + 1) throw new edx("Argument number \"" + i.text + "\" out of order");
			s++, o.push([]);
		} else {
			if ("EOF" === i.text) throw new edx("Expected a macro definition");
			o[s].push(i.text);
		}
		var { tokens: l } = t.gullet.consumeArg();
		return a && l.unshift(a), ("\\edef" === r || "\\xdef" === r) && (l = t.gullet.expandTokens(l)).reverse(), t.gullet.macros.set(n, {
			tokens: l,
			numArgs: s,
			delimiters: o
		}, r === egT[r]), {
			type: "internal",
			mode: t.mode
		};
	}
}), efA({
	type: "internal",
	names: ["\\let", "\\\\globallet"],
	props: {
		numArgs: 0,
		allowedInText: !0,
		primitive: !0
	},
	handler(e) {
		var { parser: t, funcName: r } = e, i = eg_(t.gullet.popToken());
		return t.gullet.consumeSpaces(), egC(t, i, egE(t), "\\\\globallet" === r), {
			type: "internal",
			mode: t.mode
		};
	}
}), efA({
	type: "internal",
	names: ["\\futurelet", "\\\\globalfuture"],
	props: {
		numArgs: 0,
		allowedInText: !0,
		primitive: !0
	},
	handler(e) {
		var { parser: t, funcName: r } = e, i = eg_(t.gullet.popToken()), n = t.gullet.popToken(), a = t.gullet.popToken();
		return egC(t, i, a, "\\\\globalfuture" === r), t.gullet.pushToken(a), t.gullet.pushToken(n), {
			type: "internal",
			mode: t.mode
		};
	}
});
var egS = h(function(e, t, r) {
	var i = ed9(epA.math[e] && epA.math[e].replace || e, t, r);
	if (!i) throw Error("Unsupported symbol " + e + " and font size " + t + ".");
	return i;
}, "getMetrics"), egA = h(function(e, t, r, i) {
	var n = r.havingBaseStyle(t), a = efx.makeSpan(i.concat(n.sizingClasses(r)), [e], r), s = n.sizeMultiplier / r.sizeMultiplier;
	return a.height *= s, a.depth *= s, a.maxFontSize = n.sizeMultiplier, a;
}, "styleWrap"), egL = h(function(e, t, r) {
	var i = t.havingBaseStyle(r), n = (1 - t.sizeMultiplier / i.sizeMultiplier) * t.fontMetrics().axisHeight;
	e.classes.push("delimcenter"), e.style.top = eph(n), e.height -= n, e.depth += n;
}, "centerSpan"), egR = h(function(e, t, r, i, n, a) {
	var s = egA(efx.makeSymbol(e, "Main-Regular", n, i), t, i, a);
	return r && egL(s, i, t), s;
}, "makeSmallDelim"), egN = h(function(e, t, r, i) {
	return efx.makeSymbol(e, "Size" + t + "-Regular", r, i);
}, "mathrmSize"), egI = h(function(e, t, r, i, n, a) {
	var s = egN(e, t, n, i), o = egA(efx.makeSpan(["delimsizing", "size" + t], [s], i), edG.TEXT, i, a);
	return r && egL(o, i, edG.TEXT), o;
}, "makeLargeDelim"), egM = h(function(e, t, r) {
	var i;
	return i = "Size1-Regular" === t ? "delim-size1" : "delim-size4", {
		type: "elem",
		elem: efx.makeSpan(["delimsizinginner", i], [efx.makeSpan([], [efx.makeSymbol(e, t, r)])])
	};
}, "makeGlyphSpan"), egD = h(function(e, t, r) {
	var i = ed3["Size4-Regular"][e.charCodeAt(0)] ? ed3["Size4-Regular"][e.charCodeAt(0)][4] : ed3["Size1-Regular"][e.charCodeAt(0)][4], n = new epw([new epk("inner", ed1(e, Math.round(1e3 * t)))], {
		width: eph(i),
		height: eph(t),
		style: "width:" + eph(i),
		viewBox: "0 0 " + 1e3 * i + " " + Math.round(1e3 * t),
		preserveAspectRatio: "xMinYMin"
	}), a = efx.makeSvgSpan([], [n], r);
	return a.height = t, a.style.height = eph(t), a.style.width = eph(i), {
		type: "elem",
		elem: a
	};
}, "makeInner"), egO = {
	type: "kern",
	size: -.008
}, eg$ = [
	"|",
	"\\lvert",
	"\\rvert",
	"\\vert"
], egP = [
	"\\|",
	"\\lVert",
	"\\rVert",
	"\\Vert"
], egB = h(function(e, t, r, i, n, a) {
	var s, o, l, h, u = "", d = 0;
	s = l = h = e, o = null;
	var p = "Size1-Regular";
	"\\uparrow" === e ? l = h = "" : "\\Uparrow" === e ? l = h = "" : "\\downarrow" === e ? s = l = "" : "\\Downarrow" === e ? s = l = "" : "\\updownarrow" === e ? (s = "\\uparrow", l = "", h = "\\downarrow") : "\\Updownarrow" === e ? (s = "\\Uparrow", l = "", h = "\\Downarrow") : edR.contains(eg$, e) ? (l = "", u = "vert", d = 333) : edR.contains(egP, e) ? (l = "", u = "doublevert", d = 556) : "[" === e || "\\lbrack" === e ? (s = "", l = "", h = "", p = "Size4-Regular", u = "lbrack", d = 667) : "]" === e || "\\rbrack" === e ? (s = "", l = "", h = "", p = "Size4-Regular", u = "rbrack", d = 667) : "\\lfloor" === e || "" === e ? (l = s = "", h = "", p = "Size4-Regular", u = "lfloor", d = 667) : "\\lceil" === e || "" === e ? (s = "", l = h = "", p = "Size4-Regular", u = "lceil", d = 667) : "\\rfloor" === e || "" === e ? (l = s = "", h = "", p = "Size4-Regular", u = "rfloor", d = 667) : "\\rceil" === e || "" === e ? (s = "", l = h = "", p = "Size4-Regular", u = "rceil", d = 667) : "(" === e || "\\lparen" === e ? (s = "", l = "", h = "", p = "Size4-Regular", u = "lparen", d = 875) : ")" === e || "\\rparen" === e ? (s = "", l = "", h = "", p = "Size4-Regular", u = "rparen", d = 875) : "\\{" === e || "\\lbrace" === e ? (s = "", o = "", h = "", l = "", p = "Size4-Regular") : "\\}" === e || "\\rbrace" === e ? (s = "", o = "", h = "", l = "", p = "Size4-Regular") : "\\lgroup" === e || "" === e ? (s = "", h = "", l = "", p = "Size4-Regular") : "\\rgroup" === e || "" === e ? (s = "", h = "", l = "", p = "Size4-Regular") : "\\lmoustache" === e || "" === e ? (s = "", h = "", l = "", p = "Size4-Regular") : ("\\rmoustache" === e || "" === e) && (s = "", h = "", l = "", p = "Size4-Regular");
	var f = egS(s, p, n), g = f.height + f.depth, m = egS(l, p, n), y = m.height + m.depth, v = egS(h, p, n), x = v.height + v.depth, b = 0, w = 1;
	if (null !== o) {
		var k = egS(o, p, n);
		b = k.height + k.depth, w = 2;
	}
	var T = g + x + b, _ = T + Math.max(0, Math.ceil((t - T) / (w * y))) * w * y, E = i.fontMetrics().axisHeight;
	r && (E *= i.sizeMultiplier);
	var C = _ / 2 - E, S = [];
	if (u.length > 0) {
		var A = Math.round(1e3 * _), L = ed4(u, Math.round(1e3 * (_ - g - x))), R = new epk(u, L), N = (d / 1e3).toFixed(3) + "em", I = (A / 1e3).toFixed(3) + "em", M = new epw([R], {
			width: N,
			height: I,
			viewBox: "0 0 " + d + " " + A
		}), D = efx.makeSvgSpan([], [M], i);
		D.height = A / 1e3, D.style.width = N, D.style.height = I, S.push({
			type: "elem",
			elem: D
		});
	} else {
		if (S.push(egM(h, p, n)), S.push(egO), null === o) S.push(egD(l, _ - g - x + .016, i));
		else {
			var O = (_ - g - x - b) / 2 + .016;
			S.push(egD(l, O, i)), S.push(egO), S.push(egM(o, p, n)), S.push(egO), S.push(egD(l, O, i));
		}
		S.push(egO), S.push(egM(s, p, n));
	}
	var $ = i.havingBaseStyle(edG.TEXT), P = efx.makeVList({
		positionType: "bottom",
		positionData: C,
		children: S
	}, $);
	return egA(efx.makeSpan(["delimsizing", "mult"], [P], $), edG.TEXT, i, a);
}, "makeStackedDelim"), egF = h(function(e, t, r, i, n) {
	var a = new epw([new epk(e, ed0(e, i, r))], {
		width: "400em",
		height: eph(t),
		viewBox: "0 0 400000 " + r,
		preserveAspectRatio: "xMinYMin slice"
	});
	return efx.makeSvgSpan(["hide-tail"], [a], n);
}, "sqrtSvg"), egz = h(function(e, t) {
	var r, i, n = t.havingBaseSizing(), a = egK("\\surd", e * n.sizeMultiplier, egH, n), s = n.sizeMultiplier, o = Math.max(0, t.minRuleThickness - t.fontMetrics().sqrtRuleThickness), l = 0, h = 0, u = 0;
	return "small" === a.type ? (u = 1e3 + 1e3 * o + 80, e < 1 ? s = 1 : e < 1.4 && (s = .7), l = (1 + o + .08) / s, h = (1 + o) / s, (r = egF("sqrtMain", l, u, o, t)).style.minWidth = "0.853em", i = .833 / s) : "large" === a.type ? (u = 1080 * egj[a.size], h = (egj[a.size] + o) / s, l = (egj[a.size] + o + .08) / s, (r = egF("sqrtSize" + a.size, l, u, o, t)).style.minWidth = "1.02em", i = 1 / s) : (l = e + o + .08, h = e + o, (r = egF("sqrtTall", l, u = Math.floor(1e3 * e + o) + 80, o, t)).style.minWidth = "0.742em", i = 1.056), r.height = h, r.style.height = eph(l), {
		span: r,
		advanceWidth: i,
		ruleWidth: (t.fontMetrics().sqrtRuleThickness + o) * s
	};
}, "makeSqrtImage"), egU = [
	"(",
	"\\lparen",
	")",
	"\\rparen",
	"[",
	"\\lbrack",
	"]",
	"\\rbrack",
	"\\{",
	"\\lbrace",
	"\\}",
	"\\rbrace",
	"\\lfloor",
	"\\rfloor",
	"",
	"",
	"\\lceil",
	"\\rceil",
	"",
	"",
	"\\surd"
], egG = [
	"\\uparrow",
	"\\downarrow",
	"\\updownarrow",
	"\\Uparrow",
	"\\Downarrow",
	"\\Updownarrow",
	"|",
	"\\|",
	"\\vert",
	"\\Vert",
	"\\lvert",
	"\\rvert",
	"\\lVert",
	"\\rVert",
	"\\lgroup",
	"\\rgroup",
	"",
	"",
	"\\lmoustache",
	"\\rmoustache",
	"",
	""
], egq = [
	"<",
	">",
	"\\langle",
	"\\rangle",
	"/",
	"\\backslash",
	"\\lt",
	"\\gt"
], egj = [
	0,
	1.2,
	1.8,
	2.4,
	3
], egW = h(function(e, t, r, i, n) {
	if ("<" === e || "\\lt" === e || "" === e ? e = "\\langle" : (">" === e || "\\gt" === e || "" === e) && (e = "\\rangle"), edR.contains(egU, e) || edR.contains(egq, e)) return egI(e, t, !1, r, i, n);
	if (edR.contains(egG, e)) return egB(e, egj[t], !1, r, i, n);
	throw new edx("Illegal delimiter: '" + e + "'");
}, "makeSizedDelim"), egY = [
	{
		type: "small",
		style: edG.SCRIPTSCRIPT
	},
	{
		type: "small",
		style: edG.SCRIPT
	},
	{
		type: "small",
		style: edG.TEXT
	},
	{
		type: "large",
		size: 1
	},
	{
		type: "large",
		size: 2
	},
	{
		type: "large",
		size: 3
	},
	{
		type: "large",
		size: 4
	}
], egV = [
	{
		type: "small",
		style: edG.SCRIPTSCRIPT
	},
	{
		type: "small",
		style: edG.SCRIPT
	},
	{
		type: "small",
		style: edG.TEXT
	},
	{ type: "stack" }
], egH = [
	{
		type: "small",
		style: edG.SCRIPTSCRIPT
	},
	{
		type: "small",
		style: edG.SCRIPT
	},
	{
		type: "small",
		style: edG.TEXT
	},
	{
		type: "large",
		size: 1
	},
	{
		type: "large",
		size: 2
	},
	{
		type: "large",
		size: 3
	},
	{
		type: "large",
		size: 4
	},
	{ type: "stack" }
], egX = h(function(e) {
	if ("small" === e.type) return "Main-Regular";
	if ("large" === e.type) return "Size" + e.size + "-Regular";
	if ("stack" === e.type) return "Size4-Regular";
	throw Error("Add support for delim type '" + e.type + "' here.");
}, "delimTypeToFont"), egK = h(function(e, t, r, i) {
	for (var n = Math.min(2, 3 - i.style.size); n < r.length && "stack" !== r[n].type; n++) {
		var a = egS(e, egX(r[n]), "math"), s = a.height + a.depth;
		if ("small" === r[n].type && (s *= i.havingBaseStyle(r[n].style).sizeMultiplier), s > t) return r[n];
	}
	return r[r.length - 1];
}, "traverseSequence"), egZ = h(function(e, t, r, i, n, a) {
	"<" === e || "\\lt" === e || "" === e ? e = "\\langle" : (">" === e || "\\gt" === e || "" === e) && (e = "\\rangle");
	var s = edR.contains(egq, e) ? egY : edR.contains(egU, e) ? egH : egV, o = egK(e, t, s, i);
	return "small" === o.type ? egR(e, o.style, r, i, n, a) : "large" === o.type ? egI(e, o.size, r, i, n, a) : egB(e, t, r, i, n, a);
}, "makeCustomSizedDelim"), egQ = {
	sqrtImage: egz,
	sizedDelim: egW,
	sizeToMaxHeight: egj,
	customSizedDelim: egZ,
	leftRightDelim: h(function(e, t, r, i, n, a) {
		var s = i.fontMetrics().axisHeight * i.sizeMultiplier, o = 5 / i.fontMetrics().ptPerEm, l = Math.max(t - s, r + s);
		return egZ(e, Math.max(l / 500 * 901, 2 * l - o), !0, i, n, a);
	}, "makeLeftRightDelim")
}, egJ = {
	"\\bigl": {
		mclass: "mopen",
		size: 1
	},
	"\\Bigl": {
		mclass: "mopen",
		size: 2
	},
	"\\biggl": {
		mclass: "mopen",
		size: 3
	},
	"\\Biggl": {
		mclass: "mopen",
		size: 4
	},
	"\\bigr": {
		mclass: "mclose",
		size: 1
	},
	"\\Bigr": {
		mclass: "mclose",
		size: 2
	},
	"\\biggr": {
		mclass: "mclose",
		size: 3
	},
	"\\Biggr": {
		mclass: "mclose",
		size: 4
	},
	"\\bigm": {
		mclass: "mrel",
		size: 1
	},
	"\\Bigm": {
		mclass: "mrel",
		size: 2
	},
	"\\biggm": {
		mclass: "mrel",
		size: 3
	},
	"\\Biggm": {
		mclass: "mrel",
		size: 4
	},
	"\\big": {
		mclass: "mord",
		size: 1
	},
	"\\Big": {
		mclass: "mord",
		size: 2
	},
	"\\bigg": {
		mclass: "mord",
		size: 3
	},
	"\\Bigg": {
		mclass: "mord",
		size: 4
	}
}, eg0 = [
	"(",
	"\\lparen",
	")",
	"\\rparen",
	"[",
	"\\lbrack",
	"]",
	"\\rbrack",
	"\\{",
	"\\lbrace",
	"\\}",
	"\\rbrace",
	"\\lfloor",
	"\\rfloor",
	"",
	"",
	"\\lceil",
	"\\rceil",
	"",
	"",
	"<",
	">",
	"\\langle",
	"",
	"\\rangle",
	"",
	"\\lt",
	"\\gt",
	"\\lvert",
	"\\rvert",
	"\\lVert",
	"\\rVert",
	"\\lgroup",
	"\\rgroup",
	"",
	"",
	"\\lmoustache",
	"\\rmoustache",
	"",
	"",
	"/",
	"\\backslash",
	"|",
	"\\vert",
	"\\|",
	"\\Vert",
	"\\uparrow",
	"\\Uparrow",
	"\\downarrow",
	"\\Downarrow",
	"\\updownarrow",
	"\\Updownarrow",
	"."
];
function eg1(e, t) {
	var r = egs(e);
	if (r && edR.contains(eg0, r.text)) return r;
	throw r ? new edx("Invalid delimiter '" + r.text + "' after '" + t.funcName + "'", e) : new edx("Invalid delimiter type '" + e.type + "'", e);
}
function eg2(e) {
	if (!e.body) throw Error("Bug: The leftright ParseNode wasn't fully parsed.");
}
h(eg1, "checkDelimiter"), efA({
	type: "delimsizing",
	names: [
		"\\bigl",
		"\\Bigl",
		"\\biggl",
		"\\Biggl",
		"\\bigr",
		"\\Bigr",
		"\\biggr",
		"\\Biggr",
		"\\bigm",
		"\\Bigm",
		"\\biggm",
		"\\Biggm",
		"\\big",
		"\\Big",
		"\\bigg",
		"\\Bigg"
	],
	props: {
		numArgs: 1,
		argTypes: ["primitive"]
	},
	handler: h((e, t) => {
		var r = eg1(t[0], e);
		return {
			type: "delimsizing",
			mode: e.parser.mode,
			size: egJ[e.funcName].size,
			mclass: egJ[e.funcName].mclass,
			delim: r.text
		};
	}, "handler"),
	htmlBuilder: h((e, t) => "." === e.delim ? efx.makeSpan([e.mclass]) : egQ.sizedDelim(e.delim, e.size, t, e.mode, [e.mclass]), "htmlBuilder"),
	mathmlBuilder: h((e) => {
		var t = [];
		"." !== e.delim && t.push(efK(e.delim, e.mode));
		var r = new efV("mo", t);
		"mopen" === e.mclass || "mclose" === e.mclass ? r.setAttribute("fence", "true") : r.setAttribute("fence", "false"), r.setAttribute("stretchy", "true");
		var i = eph(egQ.sizeToMaxHeight[e.size]);
		return r.setAttribute("minsize", i), r.setAttribute("maxsize", i), r;
	}, "mathmlBuilder")
}), h(eg2, "assertParsed"), efA({
	type: "leftright-right",
	names: ["\\right"],
	props: {
		numArgs: 1,
		primitive: !0
	},
	handler: h((e, t) => {
		var r = e.parser.gullet.macros.get("\\current@color");
		if (r && "string" != typeof r) throw new edx("\\current@color set to non-string in \\right");
		return {
			type: "leftright-right",
			mode: e.parser.mode,
			delim: eg1(t[0], e).text,
			color: r
		};
	}, "handler")
}), efA({
	type: "leftright",
	names: ["\\left"],
	props: {
		numArgs: 1,
		primitive: !0
	},
	handler: h((e, t) => {
		var r = eg1(t[0], e), i = e.parser;
		++i.leftrightDepth;
		var n = i.parseExpression(!1);
		--i.leftrightDepth, i.expect("\\right", !1);
		var a = egn(i.parseFunction(), "leftright-right");
		return {
			type: "leftright",
			mode: i.mode,
			body: n,
			left: r.text,
			right: a.delim,
			rightColor: a.color
		};
	}, "handler"),
	htmlBuilder: h((e, t) => {
		eg2(e);
		for (var r, i, n = efP(e.body, t, !0, ["mopen", "mclose"]), a = 0, s = 0, o = !1, l = 0; l < n.length; l++) n[l].isMiddle ? o = !0 : (a = Math.max(n[l].height, a), s = Math.max(n[l].depth, s));
		if (a *= t.sizeMultiplier, s *= t.sizeMultiplier, r = "." === e.left ? efG(t, ["mopen"]) : egQ.leftRightDelim(e.left, a, s, t, e.mode, ["mopen"]), n.unshift(r), o) for (var h = 1; h < n.length; h++) {
			var u = n[h].isMiddle;
			u && (n[h] = egQ.leftRightDelim(u.delim, a, s, u.options, e.mode, []));
		}
		if ("." === e.right) i = efG(t, ["mclose"]);
		else {
			var d = e.rightColor ? t.withColor(e.rightColor) : t;
			i = egQ.leftRightDelim(e.right, a, s, d, e.mode, ["mclose"]);
		}
		return n.push(i), efx.makeSpan(["minner"], n, t);
	}, "htmlBuilder"),
	mathmlBuilder: h((e, t) => {
		eg2(e);
		var r = ef0(e.body, t);
		if ("." !== e.left) {
			var i = new efV("mo", [efK(e.left, e.mode)]);
			i.setAttribute("fence", "true"), r.unshift(i);
		}
		if ("." !== e.right) {
			var n = new efV("mo", [efK(e.right, e.mode)]);
			n.setAttribute("fence", "true"), e.rightColor && n.setAttribute("mathcolor", e.rightColor), r.push(n);
		}
		return efZ(r);
	}, "mathmlBuilder")
}), efA({
	type: "middle",
	names: ["\\middle"],
	props: {
		numArgs: 1,
		primitive: !0
	},
	handler: h((e, t) => {
		var r = eg1(t[0], e);
		if (!e.parser.leftrightDepth) throw new edx("\\middle without preceding \\left", r);
		return {
			type: "middle",
			mode: e.parser.mode,
			delim: r.text
		};
	}, "handler"),
	htmlBuilder: h((e, t) => {
		var r;
		return "." === e.delim ? r = efG(t, []) : (r = egQ.sizedDelim(e.delim, 1, t, e.mode, [])).isMiddle = {
			delim: e.delim,
			options: t
		}, r;
	}, "htmlBuilder"),
	mathmlBuilder: h((e, t) => {
		var r = new efV("mo", ["\\vert" === e.delim || "|" === e.delim ? efK("|", "text") : efK(e.delim, e.mode)]);
		return r.setAttribute("fence", "true"), r.setAttribute("lspace", "0.05em"), r.setAttribute("rspace", "0.05em"), r;
	}, "mathmlBuilder")
});
var eg4 = h((e, t) => {
	var r, i, n = efx.wrapFragment(efq(e.body, t), t), a = e.label.slice(1), s = t.sizeMultiplier, o = 0, l = edR.isCharacterBox(e.body);
	if ("sout" === a) (i = efx.makeSpan(["stretchy", "sout"])).height = t.fontMetrics().defaultRuleThickness / s, o = -.5 * t.fontMetrics().xHeight;
	else if ("phase" === a) {
		var h = epc({
			number: .6,
			unit: "pt"
		}, t), u = epc({
			number: .35,
			unit: "ex"
		}, t);
		s /= t.havingBaseSizing().sizeMultiplier;
		var d = n.height + n.depth + h + u;
		n.style.paddingLeft = eph(d / 2 + h);
		var p = Math.floor(1e3 * d * s), f = new epw([new epk("phase", edQ(p))], {
			width: "400em",
			height: eph(p / 1e3),
			viewBox: "0 0 400000 " + p,
			preserveAspectRatio: "xMinYMin slice"
		});
		(i = efx.makeSvgSpan(["hide-tail"], [f], t)).style.height = eph(d), o = n.depth + h + u;
	} else {
		/cancel/.test(a) ? l || n.classes.push("cancel-pad") : "angl" === a ? n.classes.push("anglpad") : n.classes.push("boxpad");
		var g = 0, m = 0, y = 0;
		/box/.test(a) ? (y = Math.max(t.fontMetrics().fboxrule, t.minRuleThickness), m = g = t.fontMetrics().fboxsep + ("colorbox" === a ? 0 : y)) : "angl" === a ? (g = 4 * (y = Math.max(t.fontMetrics().defaultRuleThickness, t.minRuleThickness)), m = Math.max(0, .25 - n.depth)) : m = g = .2 * !!l, i = egi.encloseSpan(n, a, g, m, t), /fbox|boxed|fcolorbox/.test(a) ? (i.style.borderStyle = "solid", i.style.borderWidth = eph(y)) : "angl" === a && .049 !== y && (i.style.borderTopWidth = eph(y), i.style.borderRightWidth = eph(y)), o = n.depth + m, e.backgroundColor && (i.style.backgroundColor = e.backgroundColor, e.borderColor && (i.style.borderColor = e.borderColor));
	}
	if (e.backgroundColor) r = efx.makeVList({
		positionType: "individualShift",
		children: [{
			type: "elem",
			elem: i,
			shift: o
		}, {
			type: "elem",
			elem: n,
			shift: 0
		}]
	}, t);
	else {
		var v = /cancel|phase/.test(a) ? ["svg-align"] : [];
		r = efx.makeVList({
			positionType: "individualShift",
			children: [{
				type: "elem",
				elem: n,
				shift: 0
			}, {
				type: "elem",
				elem: i,
				shift: o,
				wrapperClasses: v
			}]
		}, t);
	}
	return /cancel/.test(a) && (r.height = n.height, r.depth = n.depth), /cancel/.test(a) && !l ? efx.makeSpan(["mord", "cancel-lap"], [r], t) : efx.makeSpan(["mord"], [r], t);
}, "htmlBuilder$7"), eg5 = h((e, t) => {
	var r = 0, i = new efV(e.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [ef2(e.body, t)]);
	switch (e.label) {
		case "\\cancel":
			i.setAttribute("notation", "updiagonalstrike");
			break;
		case "\\bcancel":
			i.setAttribute("notation", "downdiagonalstrike");
			break;
		case "\\phase":
			i.setAttribute("notation", "phasorangle");
			break;
		case "\\sout":
			i.setAttribute("notation", "horizontalstrike");
			break;
		case "\\fbox":
			i.setAttribute("notation", "box");
			break;
		case "\\angl":
			i.setAttribute("notation", "actuarial");
			break;
		case "\\fcolorbox":
		case "\\colorbox":
			if (r = t.fontMetrics().fboxsep * t.fontMetrics().ptPerEm, i.setAttribute("width", "+" + 2 * r + "pt"), i.setAttribute("height", "+" + 2 * r + "pt"), i.setAttribute("lspace", r + "pt"), i.setAttribute("voffset", r + "pt"), "\\fcolorbox" === e.label) {
				var n = Math.max(t.fontMetrics().fboxrule, t.minRuleThickness);
				i.setAttribute("style", "border: " + n + "em solid " + String(e.borderColor));
			}
			break;
		case "\\xcancel": i.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
	}
	return e.backgroundColor && i.setAttribute("mathbackground", e.backgroundColor), i;
}, "mathmlBuilder$6");
efA({
	type: "enclose",
	names: ["\\colorbox"],
	props: {
		numArgs: 2,
		allowedInText: !0,
		argTypes: ["color", "text"]
	},
	handler(e, t, r) {
		var { parser: i, funcName: n } = e, a = egn(t[0], "color-token").color, s = t[1];
		return {
			type: "enclose",
			mode: i.mode,
			label: n,
			backgroundColor: a,
			body: s
		};
	},
	htmlBuilder: eg4,
	mathmlBuilder: eg5
}), efA({
	type: "enclose",
	names: ["\\fcolorbox"],
	props: {
		numArgs: 3,
		allowedInText: !0,
		argTypes: [
			"color",
			"color",
			"text"
		]
	},
	handler(e, t, r) {
		var { parser: i, funcName: n } = e, a = egn(t[0], "color-token").color, s = egn(t[1], "color-token").color, o = t[2];
		return {
			type: "enclose",
			mode: i.mode,
			label: n,
			backgroundColor: s,
			borderColor: a,
			body: o
		};
	},
	htmlBuilder: eg4,
	mathmlBuilder: eg5
}), efA({
	type: "enclose",
	names: ["\\fbox"],
	props: {
		numArgs: 1,
		argTypes: ["hbox"],
		allowedInText: !0
	},
	handler(e, t) {
		var { parser: r } = e;
		return {
			type: "enclose",
			mode: r.mode,
			label: "\\fbox",
			body: t[0]
		};
	}
}), efA({
	type: "enclose",
	names: [
		"\\cancel",
		"\\bcancel",
		"\\xcancel",
		"\\sout",
		"\\phase"
	],
	props: { numArgs: 1 },
	handler(e, t) {
		var { parser: r, funcName: i } = e, n = t[0];
		return {
			type: "enclose",
			mode: r.mode,
			label: i,
			body: n
		};
	},
	htmlBuilder: eg4,
	mathmlBuilder: eg5
}), efA({
	type: "enclose",
	names: ["\\angl"],
	props: {
		numArgs: 1,
		argTypes: ["hbox"],
		allowedInText: !1
	},
	handler(e, t) {
		var { parser: r } = e;
		return {
			type: "enclose",
			mode: r.mode,
			label: "\\angl",
			body: t[0]
		};
	}
});
var eg3 = {};
function eg6(e) {
	for (var { type: t, names: r, props: i, handler: n, htmlBuilder: a, mathmlBuilder: s } = e, o = {
		type: t,
		numArgs: i.numArgs || 0,
		allowedInText: !1,
		numOptionalArgs: 0,
		handler: n
	}, l = 0; l < r.length; ++l) eg3[r[l]] = o;
	a && (efC[t] = a), s && (efS[t] = s);
}
h(eg6, "defineEnvironment");
var eg7 = {};
function eg8(e, t) {
	eg7[e] = t;
}
function eg9(e) {
	var t = [];
	e.consumeSpaces();
	var r = e.fetch().text;
	for ("\\relax" === r && (e.consume(), e.consumeSpaces(), r = e.fetch().text); "\\hline" === r || "\\hdashline" === r;) e.consume(), t.push("\\hdashline" === r), e.consumeSpaces(), r = e.fetch().text;
	return t;
}
h(eg8, "defineMacro"), h(eg9, "getHLines");
var eme = h((e) => {
	if (!e.parser.settings.displayMode) throw new edx("{" + e.envName + "} can be used only in display mode.");
}, "validateAmsEnvironmentContext");
function emt(e) {
	if (-1 === e.indexOf("ed")) return -1 === e.indexOf("*");
}
function emr(e, t, r) {
	var { hskipBeforeAndAfter: i, addJot: n, cols: a, arraystretch: s, colSeparationType: o, autoTag: l, singleRow: u, emptySingleRow: d, maxNumCols: p, leqno: f } = t;
	if (e.gullet.beginGroup(), u || e.gullet.macros.set("\\cr", "\\\\\\relax"), !s) {
		var g = e.gullet.expandMacroAsText("\\arraystretch");
		if (null == g) s = 1;
		else if (!(s = parseFloat(g)) || s < 0) throw new edx("Invalid \\arraystretch: " + g);
	}
	e.gullet.beginGroup();
	var m = [], y = [m], v = [], x = [], b = null != l ? [] : void 0;
	function w() {
		l && e.gullet.macros.set("\\@eqnsw", "1", !0);
	}
	function k() {
		b && (e.gullet.macros.get("\\df@tag") ? (b.push(e.subparse([new edv("\\df@tag")])), e.gullet.macros.set("\\df@tag", void 0, !0)) : b.push(!!l && "1" === e.gullet.macros.get("\\@eqnsw")));
	}
	for (h(w, "beginRow"), h(k, "endRow"), w(), x.push(eg9(e));;) {
		var T = e.parseExpression(!1, u ? "\\end" : "\\\\");
		e.gullet.endGroup(), e.gullet.beginGroup(), T = {
			type: "ordgroup",
			mode: e.mode,
			body: T
		}, r && (T = {
			type: "styling",
			mode: e.mode,
			style: r,
			body: [T]
		}), m.push(T);
		var _ = e.fetch().text;
		if ("&" === _) {
			if (p && m.length === p) {
				if (u || o) throw new edx("Too many tab characters: &", e.nextToken);
				e.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
			}
			e.consume();
		} else if ("\\end" === _) {
			k(), 1 === m.length && "styling" === T.type && 0 === T.body[0].body.length && (y.length > 1 || !d) && y.pop(), x.length < y.length + 1 && x.push([]);
			break;
		} else if ("\\\\" === _) {
			e.consume();
			var E = void 0;
			" " !== e.gullet.future().text && (E = e.parseSizeGroup(!0)), v.push(E ? E.value : null), k(), x.push(eg9(e)), m = [], y.push(m), w();
		} else throw new edx("Expected & or \\\\ or \\cr or \\end", e.nextToken);
	}
	return e.gullet.endGroup(), e.gullet.endGroup(), {
		type: "array",
		mode: e.mode,
		addJot: n,
		arraystretch: s,
		body: y,
		cols: a,
		rowGaps: v,
		hskipBeforeAndAfter: i,
		hLinesBeforeRow: x,
		colSeparationType: o,
		tags: b,
		leqno: f
	};
}
function emi(e) {
	return "d" === e.slice(0, 1) ? "display" : "text";
}
h(emt, "getAutoTag"), h(emr, "parseArray"), h(emi, "dCellStyle");
var emn = h(function(e, t) {
	var r, i, n = e.body.length, a = e.hLinesBeforeRow, s = 0, o = Array(n), l = [], u = Math.max(t.fontMetrics().arrayRuleWidth, t.minRuleThickness), d = 1 / t.fontMetrics().ptPerEm, p = 5 * d;
	e.colSeparationType && "small" === e.colSeparationType && (p = .2778 * (t.havingStyle(edG.SCRIPT).sizeMultiplier / t.sizeMultiplier));
	var f = "CD" === e.colSeparationType ? epc({
		number: 3,
		unit: "ex"
	}, t) : 12 * d, g = 3 * d, m = e.arraystretch * f, y = .7 * m, v = .3 * m, x = 0;
	function b(e) {
		for (var t = 0; t < e.length; ++t) t > 0 && (x += .25), l.push({
			pos: x,
			isDashed: e[t]
		});
	}
	for (h(b, "setHLinePos"), b(a[0]), r = 0; r < e.body.length; ++r) {
		var w = e.body[r], k = y, T = v;
		s < w.length && (s = w.length);
		var _ = Array(w.length);
		for (i = 0; i < w.length; ++i) {
			var E = efq(w[i], t);
			T < E.depth && (T = E.depth), k < E.height && (k = E.height), _[i] = E;
		}
		var C = e.rowGaps[r], S = 0;
		C && (S = epc(C, t)) > 0 && (T < (S += v) && (T = S), S = 0), e.addJot && (T += g), _.height = k, _.depth = T, _.pos = x += k, x += T + S, o[r] = _, b(a[r + 1]);
	}
	var A, L, R = x / 2 + t.fontMetrics().axisHeight, N = e.cols || [], I = [], M = [];
	if (e.tags && e.tags.some((e) => e)) for (r = 0; r < n; ++r) {
		var D = o[r], O = D.pos - R, $ = e.tags[r], P = void 0;
		(P = !0 === $ ? efx.makeSpan(["eqn-num"], [], t) : !1 === $ ? efx.makeSpan([], [], t) : efx.makeSpan([], efP($, t, !0), t)).depth = D.depth, P.height = D.height, M.push({
			type: "elem",
			elem: P,
			shift: O
		});
	}
	for (i = 0, L = 0; i < s || L < N.length; ++i, ++L) {
		for (var B = N[L] || {}, F = !0; "separator" === B.type;) {
			if (F || ((A = efx.makeSpan(["arraycolsep"], [])).style.width = eph(t.fontMetrics().doubleRuleSep), I.push(A)), "|" === B.separator || ":" === B.separator) {
				var z = "|" === B.separator ? "solid" : "dashed", U = efx.makeSpan(["vertical-separator"], [], t);
				U.style.height = eph(x), U.style.borderRightWidth = eph(u), U.style.borderRightStyle = z, U.style.margin = "0 " + eph(-u / 2);
				var G = x - R;
				G && (U.style.verticalAlign = eph(-G)), I.push(U);
			} else throw new edx("Invalid separator type: " + B.separator);
			B = N[++L] || {}, F = !1;
		}
		if (!(i >= s)) {
			var q = void 0;
			(i > 0 || e.hskipBeforeAndAfter) && 0 !== (q = edR.deflt(B.pregap, p)) && ((A = efx.makeSpan(["arraycolsep"], [])).style.width = eph(q), I.push(A));
			var j = [];
			for (r = 0; r < n; ++r) {
				var W = o[r], Y = W[i];
				if (Y) {
					var V = W.pos - R;
					Y.depth = W.depth, Y.height = W.height, j.push({
						type: "elem",
						elem: Y,
						shift: V
					});
				}
			}
			j = efx.makeVList({
				positionType: "individualShift",
				children: j
			}, t), j = efx.makeSpan(["col-align-" + (B.align || "c")], [j]), I.push(j), (i < s - 1 || e.hskipBeforeAndAfter) && 0 !== (q = edR.deflt(B.postgap, p)) && ((A = efx.makeSpan(["arraycolsep"], [])).style.width = eph(q), I.push(A));
		}
	}
	if (o = efx.makeSpan(["mtable"], I), l.length > 0) {
		for (var H = efx.makeLineSpan("hline", t, u), X = efx.makeLineSpan("hdashline", t, u), K = [{
			type: "elem",
			elem: o,
			shift: 0
		}]; l.length > 0;) {
			var Z = l.pop(), Q = Z.pos - R;
			Z.isDashed ? K.push({
				type: "elem",
				elem: X,
				shift: Q
			}) : K.push({
				type: "elem",
				elem: H,
				shift: Q
			});
		}
		o = efx.makeVList({
			positionType: "individualShift",
			children: K
		}, t);
	}
	if (0 === M.length) return efx.makeSpan(["mord"], [o], t);
	var J = efx.makeVList({
		positionType: "individualShift",
		children: M
	}, t);
	return J = efx.makeSpan(["tag"], [J], t), efx.makeFragment([o, J]);
}, "htmlBuilder"), ema = {
	c: "center ",
	l: "left ",
	r: "right "
}, ems = h(function(e, t) {
	for (var r = [], i = new efV("mtd", [], ["mtr-glue"]), n = new efV("mtd", [], ["mml-eqn-num"]), a = 0; a < e.body.length; a++) {
		for (var s = e.body[a], o = [], l = 0; l < s.length; l++) o.push(new efV("mtd", [ef2(s[l], t)]));
		e.tags && e.tags[a] && (o.unshift(i), o.push(i), e.leqno ? o.unshift(n) : o.push(n)), r.push(new efV("mtr", o));
	}
	var h = new efV("mtable", r), u = .5 === e.arraystretch ? .1 : .16 + e.arraystretch - 1 + .09 * !!e.addJot;
	h.setAttribute("rowspacing", eph(u));
	var d = "", p = "";
	if (e.cols && e.cols.length > 0) {
		var f = e.cols, g = "", m = !1, y = 0, v = f.length;
		"separator" === f[0].type && (d += "top ", y = 1), "separator" === f[f.length - 1].type && (d += "bottom ", v -= 1);
		for (var x = y; x < v; x++) "align" === f[x].type ? (p += ema[f[x].align], m && (g += "none "), m = !0) : "separator" === f[x].type && m && (g += "|" === f[x].separator ? "solid " : "dashed ", m = !1);
		h.setAttribute("columnalign", p.trim()), /[sd]/.test(g) && h.setAttribute("columnlines", g.trim());
	}
	if ("align" === e.colSeparationType) {
		for (var b = e.cols || [], w = "", k = 1; k < b.length; k++) w += k % 2 ? "0em " : "1em ";
		h.setAttribute("columnspacing", w.trim());
	} else "alignat" === e.colSeparationType || "gather" === e.colSeparationType ? h.setAttribute("columnspacing", "0em") : "small" === e.colSeparationType ? h.setAttribute("columnspacing", "0.2778em") : "CD" === e.colSeparationType ? h.setAttribute("columnspacing", "0.5em") : h.setAttribute("columnspacing", "1em");
	var T = "", _ = e.hLinesBeforeRow;
	d += (_[0].length > 0 ? "left " : "") + (_[_.length - 1].length > 0 ? "right " : "");
	for (var E = 1; E < _.length - 1; E++) T += 0 === _[E].length ? "none " : _[E][0] ? "dashed " : "solid ";
	return /[sd]/.test(T) && h.setAttribute("rowlines", T.trim()), "" !== d && (h = new efV("menclose", [h])).setAttribute("notation", d.trim()), e.arraystretch && e.arraystretch < 1 && (h = new efV("mstyle", [h])).setAttribute("scriptlevel", "1"), h;
}, "mathmlBuilder"), emo = h(function(e, t) {
	-1 === e.envName.indexOf("ed") && eme(e);
	var r, i = [], n = e.envName.indexOf("at") > -1 ? "alignat" : "align", a = "split" === e.envName, s = emr(e.parser, {
		cols: i,
		addJot: !0,
		autoTag: a ? void 0 : emt(e.envName),
		emptySingleRow: !0,
		colSeparationType: n,
		maxNumCols: a ? 2 : void 0,
		leqno: e.parser.settings.leqno
	}, "display"), o = 0, l = {
		type: "ordgroup",
		mode: e.mode,
		body: []
	};
	if (t[0] && "ordgroup" === t[0].type) {
		for (var h = "", u = 0; u < t[0].body.length; u++) h += egn(t[0].body[u], "textord").text;
		o = 2 * (r = Number(h));
	}
	var d = !o;
	s.body.forEach(function(e) {
		for (var t = 1; t < e.length; t += 2) egn(egn(e[t], "styling").body[0], "ordgroup").body.unshift(l);
		if (d) o < e.length && (o = e.length);
		else {
			var i = e.length / 2;
			if (r < i) throw new edx("Too many math in a row: expected " + r + ", but got " + i, e[0]);
		}
	});
	for (var p = 0; p < o; ++p) {
		var f = "r", g = 0;
		p % 2 == 1 ? f = "l" : p > 0 && d && (g = 1), i[p] = {
			type: "align",
			align: f,
			pregap: g,
			postgap: 0
		};
	}
	return s.colSeparationType = d ? "align" : "alignat", s;
}, "alignedHandler");
eg6({
	type: "array",
	names: ["array", "darray"],
	props: { numArgs: 1 },
	handler(e, t) {
		var r = (egs(t[0]) ? [t[0]] : egn(t[0], "ordgroup").body).map(function(e) {
			var t = ega(e).text;
			if (-1 !== "lcr".indexOf(t)) return {
				type: "align",
				align: t
			};
			if ("|" === t) return {
				type: "separator",
				separator: "|"
			};
			if (":" === t) return {
				type: "separator",
				separator: ":"
			};
			throw new edx("Unknown column alignment: " + t, e);
		}), i = {
			cols: r,
			hskipBeforeAndAfter: !0,
			maxNumCols: r.length
		};
		return emr(e.parser, i, emi(e.envName));
	},
	htmlBuilder: emn,
	mathmlBuilder: ems
}), eg6({
	type: "array",
	names: [
		"matrix",
		"pmatrix",
		"bmatrix",
		"Bmatrix",
		"vmatrix",
		"Vmatrix",
		"matrix*",
		"pmatrix*",
		"bmatrix*",
		"Bmatrix*",
		"vmatrix*",
		"Vmatrix*"
	],
	props: { numArgs: 0 },
	handler(e) {
		var t = {
			matrix: null,
			pmatrix: ["(", ")"],
			bmatrix: ["[", "]"],
			Bmatrix: ["\\{", "\\}"],
			vmatrix: ["|", "|"],
			Vmatrix: ["\\Vert", "\\Vert"]
		}[e.envName.replace("*", "")], r = "c", i = {
			hskipBeforeAndAfter: !1,
			cols: [{
				type: "align",
				align: r
			}]
		};
		if ("*" === e.envName.charAt(e.envName.length - 1)) {
			var n = e.parser;
			if (n.consumeSpaces(), "[" === n.fetch().text) {
				if (n.consume(), n.consumeSpaces(), r = n.fetch().text, -1 === "lcr".indexOf(r)) throw new edx("Expected l or c or r", n.nextToken);
				n.consume(), n.consumeSpaces(), n.expect("]"), n.consume(), i.cols = [{
					type: "align",
					align: r
				}];
			}
		}
		var a = emr(e.parser, i, emi(e.envName)), s = Math.max(0, ...a.body.map((e) => e.length));
		return a.cols = Array(s).fill({
			type: "align",
			align: r
		}), t ? {
			type: "leftright",
			mode: e.mode,
			body: [a],
			left: t[0],
			right: t[1],
			rightColor: void 0
		} : a;
	},
	htmlBuilder: emn,
	mathmlBuilder: ems
}), eg6({
	type: "array",
	names: ["smallmatrix"],
	props: { numArgs: 0 },
	handler(e) {
		var t = emr(e.parser, { arraystretch: .5 }, "script");
		return t.colSeparationType = "small", t;
	},
	htmlBuilder: emn,
	mathmlBuilder: ems
}), eg6({
	type: "array",
	names: ["subarray"],
	props: { numArgs: 1 },
	handler(e, t) {
		var r = (egs(t[0]) ? [t[0]] : egn(t[0], "ordgroup").body).map(function(e) {
			var t = ega(e).text;
			if (-1 !== "lc".indexOf(t)) return {
				type: "align",
				align: t
			};
			throw new edx("Unknown column alignment: " + t, e);
		});
		if (r.length > 1) throw new edx("{subarray} can contain only one column");
		var i = {
			cols: r,
			hskipBeforeAndAfter: !1,
			arraystretch: .5
		};
		if ((i = emr(e.parser, i, "script")).body.length > 0 && i.body[0].length > 1) throw new edx("{subarray} can contain only one column");
		return i;
	},
	htmlBuilder: emn,
	mathmlBuilder: ems
}), eg6({
	type: "array",
	names: [
		"cases",
		"dcases",
		"rcases",
		"drcases"
	],
	props: { numArgs: 0 },
	handler(e) {
		var t = emr(e.parser, {
			arraystretch: 1.2,
			cols: [{
				type: "align",
				align: "l",
				pregap: 0,
				postgap: 1
			}, {
				type: "align",
				align: "l",
				pregap: 0,
				postgap: 0
			}]
		}, emi(e.envName));
		return {
			type: "leftright",
			mode: e.mode,
			body: [t],
			left: e.envName.indexOf("r") > -1 ? "." : "\\{",
			right: e.envName.indexOf("r") > -1 ? "\\}" : ".",
			rightColor: void 0
		};
	},
	htmlBuilder: emn,
	mathmlBuilder: ems
}), eg6({
	type: "array",
	names: [
		"align",
		"align*",
		"aligned",
		"split"
	],
	props: { numArgs: 0 },
	handler: emo,
	htmlBuilder: emn,
	mathmlBuilder: ems
}), eg6({
	type: "array",
	names: [
		"gathered",
		"gather",
		"gather*"
	],
	props: { numArgs: 0 },
	handler(e) {
		edR.contains(["gather", "gather*"], e.envName) && eme(e);
		var t = {
			cols: [{
				type: "align",
				align: "c"
			}],
			addJot: !0,
			colSeparationType: "gather",
			autoTag: emt(e.envName),
			emptySingleRow: !0,
			leqno: e.parser.settings.leqno
		};
		return emr(e.parser, t, "display");
	},
	htmlBuilder: emn,
	mathmlBuilder: ems
}), eg6({
	type: "array",
	names: [
		"alignat",
		"alignat*",
		"alignedat"
	],
	props: { numArgs: 1 },
	handler: emo,
	htmlBuilder: emn,
	mathmlBuilder: ems
}), eg6({
	type: "array",
	names: ["equation", "equation*"],
	props: { numArgs: 0 },
	handler(e) {
		eme(e);
		var t = {
			autoTag: emt(e.envName),
			emptySingleRow: !0,
			singleRow: !0,
			maxNumCols: 1,
			leqno: e.parser.settings.leqno
		};
		return emr(e.parser, t, "display");
	},
	htmlBuilder: emn,
	mathmlBuilder: ems
}), eg6({
	type: "array",
	names: ["CD"],
	props: { numArgs: 0 },
	handler: (e) => (eme(e), egb(e.parser)),
	htmlBuilder: emn,
	mathmlBuilder: ems
}), eg8("\\nonumber", "\\gdef\\@eqnsw{0}"), eg8("\\notag", "\\nonumber"), efA({
	type: "text",
	names: ["\\hline", "\\hdashline"],
	props: {
		numArgs: 0,
		allowedInText: !0,
		allowedInMath: !0
	},
	handler(e, t) {
		throw new edx(e.funcName + " valid only within array environment");
	}
}), efA({
	type: "environment",
	names: ["\\begin", "\\end"],
	props: {
		numArgs: 1,
		argTypes: ["text"]
	},
	handler(e, t) {
		var { parser: r, funcName: i } = e, n = t[0];
		if ("ordgroup" !== n.type) throw new edx("Invalid environment name", n);
		for (var a = "", s = 0; s < n.body.length; ++s) a += egn(n.body[s], "textord").text;
		if ("\\begin" === i) {
			if (!eg3.hasOwnProperty(a)) throw new edx("No such environment: " + a, n);
			var o = eg3[a], { args: l, optArgs: h } = r.parseArguments("\\begin{" + a + "}", o), u = {
				mode: r.mode,
				envName: a,
				parser: r
			}, d = o.handler(u, l, h);
			r.expect("\\end", !1);
			var p = r.nextToken, f = egn(r.parseFunction(), "environment");
			if (f.name !== a) throw new edx("Mismatch: \\begin{" + a + "} matched by \\end{" + f.name + "}", p);
			return d;
		}
		return {
			type: "environment",
			mode: r.mode,
			name: a,
			nameGroup: n
		};
	}
});
var eml = h((e, t) => {
	var r = e.font, i = t.withFont(r);
	return efq(e.body, i);
}, "htmlBuilder$5"), emc = h((e, t) => {
	var r = e.font, i = t.withFont(r);
	return ef2(e.body, i);
}, "mathmlBuilder$4"), emh = {
	"\\Bbb": "\\mathbb",
	"\\bold": "\\mathbf",
	"\\frak": "\\mathfrak",
	"\\bm": "\\boldsymbol"
};
efA({
	type: "font",
	names: [
		"\\mathrm",
		"\\mathit",
		"\\mathbf",
		"\\mathnormal",
		"\\mathsfit",
		"\\mathbb",
		"\\mathcal",
		"\\mathfrak",
		"\\mathscr",
		"\\mathsf",
		"\\mathtt",
		"\\Bbb",
		"\\bold",
		"\\frak"
	],
	props: {
		numArgs: 1,
		allowedInArgument: !0
	},
	handler: h((e, t) => {
		var { parser: r, funcName: i } = e, n = efR(t[0]), a = i;
		return a in emh && (a = emh[a]), {
			type: "font",
			mode: r.mode,
			font: a.slice(1),
			body: n
		};
	}, "handler"),
	htmlBuilder: eml,
	mathmlBuilder: emc
}), efA({
	type: "mclass",
	names: ["\\boldsymbol", "\\bm"],
	props: { numArgs: 1 },
	handler: h((e, t) => {
		var { parser: r } = e, i = t[0], n = edR.isCharacterBox(i);
		return {
			type: "mclass",
			mode: r.mode,
			mclass: egf(i),
			body: [{
				type: "font",
				mode: r.mode,
				font: "boldsymbol",
				body: i
			}],
			isCharacterBox: n
		};
	}, "handler")
}), efA({
	type: "font",
	names: [
		"\\rm",
		"\\sf",
		"\\tt",
		"\\bf",
		"\\it",
		"\\cal"
	],
	props: {
		numArgs: 0,
		allowedInText: !0
	},
	handler: h((e, t) => {
		var { parser: r, funcName: i, breakOnTokenText: n } = e, { mode: a } = r, s = r.parseExpression(!0, n);
		return {
			type: "font",
			mode: a,
			font: "math" + i.slice(1),
			body: {
				type: "ordgroup",
				mode: r.mode,
				body: s
			}
		};
	}, "handler"),
	htmlBuilder: eml,
	mathmlBuilder: emc
});
var emu = h((e, t) => {
	var r = t;
	return "display" === e ? r = r.id >= edG.SCRIPT.id ? r.text() : edG.DISPLAY : "text" === e && r.size === edG.DISPLAY.size ? r = edG.TEXT : "script" === e ? r = edG.SCRIPT : "scriptscript" === e && (r = edG.SCRIPTSCRIPT), r;
}, "adjustStyle"), emd = h((e, t) => {
	var r, i, n, a, s, o, l, h = emu(e.size, t.style), u = h.fracNum(), d = h.fracDen(), p = t.havingStyle(u), f = efq(e.numer, p, t);
	if (e.continued) {
		var g = 8.5 / t.fontMetrics().ptPerEm, m = 3.5 / t.fontMetrics().ptPerEm;
		f.height = f.height < g ? g : f.height, f.depth = f.depth < m ? m : f.depth;
	}
	p = t.havingStyle(d);
	var y, v, x, b = efq(e.denom, p, t);
	if (e.hasBarLine ? (e.barSize ? (v = epc(e.barSize, t), y = efx.makeLineSpan("frac-line", t, v)) : y = efx.makeLineSpan("frac-line", t), v = y.height, x = y.height) : (y = null, v = 0, x = t.fontMetrics().defaultRuleThickness), h.size === edG.DISPLAY.size || "display" === e.size ? (r = t.fontMetrics().num1, i = v > 0 ? 3 * x : 7 * x, n = t.fontMetrics().denom1) : (v > 0 ? (r = t.fontMetrics().num2, i = x) : (r = t.fontMetrics().num3, i = 3 * x), n = t.fontMetrics().denom2), y) {
		var w = t.fontMetrics().axisHeight;
		r - f.depth - (w + .5 * v) < i && (r += i - (r - f.depth - (w + .5 * v))), w - .5 * v - (b.height - n) < i && (n += i - (w - .5 * v - (b.height - n)));
		var k = -(w - .5 * v);
		a = efx.makeVList({
			positionType: "individualShift",
			children: [
				{
					type: "elem",
					elem: b,
					shift: n
				},
				{
					type: "elem",
					elem: y,
					shift: k
				},
				{
					type: "elem",
					elem: f,
					shift: -r
				}
			]
		}, t);
	} else {
		var T = r - f.depth - (b.height - n);
		T < i && (r += .5 * (i - T), n += .5 * (i - T)), a = efx.makeVList({
			positionType: "individualShift",
			children: [{
				type: "elem",
				elem: b,
				shift: n
			}, {
				type: "elem",
				elem: f,
				shift: -r
			}]
		}, t);
	}
	return p = t.havingStyle(h), a.height *= p.sizeMultiplier / t.sizeMultiplier, a.depth *= p.sizeMultiplier / t.sizeMultiplier, s = h.size === edG.DISPLAY.size ? t.fontMetrics().delim1 : h.size === edG.SCRIPTSCRIPT.size ? t.havingStyle(edG.SCRIPT).fontMetrics().delim2 : t.fontMetrics().delim2, o = null == e.leftDelim ? efG(t, ["mopen"]) : egQ.customSizedDelim(e.leftDelim, s, !0, t.havingStyle(h), e.mode, ["mopen"]), l = e.continued ? efx.makeSpan([]) : null == e.rightDelim ? efG(t, ["mclose"]) : egQ.customSizedDelim(e.rightDelim, s, !0, t.havingStyle(h), e.mode, ["mclose"]), efx.makeSpan(["mord"].concat(p.sizingClasses(t)), [
		o,
		efx.makeSpan(["mfrac"], [a]),
		l
	], t);
}, "htmlBuilder$4"), emp = h((e, t) => {
	var r = new efV("mfrac", [ef2(e.numer, t), ef2(e.denom, t)]);
	if (e.hasBarLine) {
		if (e.barSize) {
			var i = epc(e.barSize, t);
			r.setAttribute("linethickness", eph(i));
		}
	} else r.setAttribute("linethickness", "0px");
	var n = emu(e.size, t.style);
	if (n.size !== t.style.size) {
		r = new efV("mstyle", [r]);
		var a = n.size === edG.DISPLAY.size ? "true" : "false";
		r.setAttribute("displaystyle", a), r.setAttribute("scriptlevel", "0");
	}
	if (null != e.leftDelim || null != e.rightDelim) {
		var s = [];
		if (null != e.leftDelim) {
			var o = new efV("mo", [new efH(e.leftDelim.replace("\\", ""))]);
			o.setAttribute("fence", "true"), s.push(o);
		}
		if (s.push(r), null != e.rightDelim) {
			var l = new efV("mo", [new efH(e.rightDelim.replace("\\", ""))]);
			l.setAttribute("fence", "true"), s.push(l);
		}
		return efZ(s);
	}
	return r;
}, "mathmlBuilder$3");
efA({
	type: "genfrac",
	names: [
		"\\dfrac",
		"\\frac",
		"\\tfrac",
		"\\dbinom",
		"\\binom",
		"\\tbinom",
		"\\\\atopfrac",
		"\\\\bracefrac",
		"\\\\brackfrac"
	],
	props: {
		numArgs: 2,
		allowedInArgument: !0
	},
	handler: h((e, t) => {
		var r, { parser: i, funcName: n } = e, a = t[0], s = t[1], o = null, l = null, h = "auto";
		switch (n) {
			case "\\dfrac":
			case "\\frac":
			case "\\tfrac":
				r = !0;
				break;
			case "\\\\atopfrac":
				r = !1;
				break;
			case "\\dbinom":
			case "\\binom":
			case "\\tbinom":
				r = !1, o = "(", l = ")";
				break;
			case "\\\\bracefrac":
				r = !1, o = "\\{", l = "\\}";
				break;
			case "\\\\brackfrac":
				r = !1, o = "[", l = "]";
				break;
			default: throw Error("Unrecognized genfrac command");
		}
		switch (n) {
			case "\\dfrac":
			case "\\dbinom":
				h = "display";
				break;
			case "\\tfrac":
			case "\\tbinom": h = "text";
		}
		return {
			type: "genfrac",
			mode: i.mode,
			continued: !1,
			numer: a,
			denom: s,
			hasBarLine: r,
			leftDelim: o,
			rightDelim: l,
			size: h,
			barSize: null
		};
	}, "handler"),
	htmlBuilder: emd,
	mathmlBuilder: emp
}), efA({
	type: "genfrac",
	names: ["\\cfrac"],
	props: { numArgs: 2 },
	handler: h((e, t) => {
		var { parser: r, funcName: i } = e, n = t[0], a = t[1];
		return {
			type: "genfrac",
			mode: r.mode,
			continued: !0,
			numer: n,
			denom: a,
			hasBarLine: !0,
			leftDelim: null,
			rightDelim: null,
			size: "display",
			barSize: null
		};
	}, "handler")
}), efA({
	type: "infix",
	names: [
		"\\over",
		"\\choose",
		"\\atop",
		"\\brace",
		"\\brack"
	],
	props: {
		numArgs: 0,
		infix: !0
	},
	handler(e) {
		var t, { parser: r, funcName: i, token: n } = e;
		switch (i) {
			case "\\over":
				t = "\\frac";
				break;
			case "\\choose":
				t = "\\binom";
				break;
			case "\\atop":
				t = "\\\\atopfrac";
				break;
			case "\\brace":
				t = "\\\\bracefrac";
				break;
			case "\\brack":
				t = "\\\\brackfrac";
				break;
			default: throw Error("Unrecognized infix genfrac command");
		}
		return {
			type: "infix",
			mode: r.mode,
			replaceWith: t,
			token: n
		};
	}
});
var emf = [
	"display",
	"text",
	"script",
	"scriptscript"
], emg = h(function(e) {
	var t = null;
	return e.length > 0 && (t = "." === (t = e) ? null : t), t;
}, "delimFromValue");
efA({
	type: "genfrac",
	names: ["\\genfrac"],
	props: {
		numArgs: 6,
		allowedInArgument: !0,
		argTypes: [
			"math",
			"math",
			"size",
			"text",
			"math",
			"math"
		]
	},
	handler(e, t) {
		var r, { parser: i } = e, n = t[4], a = t[5], s = efR(t[0]), o = "atom" === s.type && "open" === s.family ? emg(s.text) : null, l = efR(t[1]), h = "atom" === l.type && "close" === l.family ? emg(l.text) : null, u = egn(t[2], "size"), d = null;
		r = !!u.isBlank || (d = u.value).number > 0;
		var p = "auto", f = t[3];
		return "ordgroup" === f.type ? f.body.length > 0 && (p = emf[Number(egn(f.body[0], "textord").text)]) : p = emf[Number((f = egn(f, "textord")).text)], {
			type: "genfrac",
			mode: i.mode,
			numer: n,
			denom: a,
			continued: !1,
			hasBarLine: r,
			barSize: d,
			leftDelim: o,
			rightDelim: h,
			size: p
		};
	},
	htmlBuilder: emd,
	mathmlBuilder: emp
}), efA({
	type: "infix",
	names: ["\\above"],
	props: {
		numArgs: 1,
		argTypes: ["size"],
		infix: !0
	},
	handler(e, t) {
		var { parser: r, funcName: i, token: n } = e;
		return {
			type: "infix",
			mode: r.mode,
			replaceWith: "\\\\abovefrac",
			size: egn(t[0], "size").value,
			token: n
		};
	}
}), efA({
	type: "genfrac",
	names: ["\\\\abovefrac"],
	props: {
		numArgs: 3,
		argTypes: [
			"math",
			"size",
			"math"
		]
	},
	handler: h((e, t) => {
		var { parser: r, funcName: i } = e, n = t[0], a = edL(egn(t[1], "infix").size), s = t[2], o = a.number > 0;
		return {
			type: "genfrac",
			mode: r.mode,
			numer: n,
			denom: s,
			continued: !1,
			hasBarLine: o,
			barSize: a,
			leftDelim: null,
			rightDelim: null,
			size: "auto"
		};
	}, "handler"),
	htmlBuilder: emd,
	mathmlBuilder: emp
});
var emm = h((e, t) => {
	var r, i, n = t.style;
	"supsub" === e.type ? (r = e.sup ? efq(e.sup, t.havingStyle(n.sup()), t) : efq(e.sub, t.havingStyle(n.sub()), t), i = egn(e.base, "horizBrace")) : i = egn(e, "horizBrace");
	var a, s = efq(i.base, t.havingBaseStyle(edG.DISPLAY)), o = egi.svgSpan(i, t);
	if (i.isOver ? (a = efx.makeVList({
		positionType: "firstBaseline",
		children: [
			{
				type: "elem",
				elem: s
			},
			{
				type: "kern",
				size: .1
			},
			{
				type: "elem",
				elem: o
			}
		]
	}, t)).children[0].children[0].children[1].classes.push("svg-align") : (a = efx.makeVList({
		positionType: "bottom",
		positionData: s.depth + .1 + o.height,
		children: [
			{
				type: "elem",
				elem: o
			},
			{
				type: "kern",
				size: .1
			},
			{
				type: "elem",
				elem: s
			}
		]
	}, t)).children[0].children[0].children[0].classes.push("svg-align"), r) {
		var l = efx.makeSpan(["mord", i.isOver ? "mover" : "munder"], [a], t);
		a = i.isOver ? efx.makeVList({
			positionType: "firstBaseline",
			children: [
				{
					type: "elem",
					elem: l
				},
				{
					type: "kern",
					size: .2
				},
				{
					type: "elem",
					elem: r
				}
			]
		}, t) : efx.makeVList({
			positionType: "bottom",
			positionData: l.depth + .2 + r.height + r.depth,
			children: [
				{
					type: "elem",
					elem: r
				},
				{
					type: "kern",
					size: .2
				},
				{
					type: "elem",
					elem: l
				}
			]
		}, t);
	}
	return efx.makeSpan(["mord", i.isOver ? "mover" : "munder"], [a], t);
}, "htmlBuilder$3");
efA({
	type: "horizBrace",
	names: ["\\overbrace", "\\underbrace"],
	props: { numArgs: 1 },
	handler(e, t) {
		var { parser: r, funcName: i } = e;
		return {
			type: "horizBrace",
			mode: r.mode,
			label: i,
			isOver: /^\\over/.test(i),
			base: t[0]
		};
	},
	htmlBuilder: emm,
	mathmlBuilder: h((e, t) => {
		var r = egi.mathMLnode(e.label);
		return new efV(e.isOver ? "mover" : "munder", [ef2(e.base, t), r]);
	}, "mathmlBuilder$2")
}), efA({
	type: "href",
	names: ["\\href"],
	props: {
		numArgs: 2,
		argTypes: ["url", "original"],
		allowedInText: !0
	},
	handler: h((e, t) => {
		var { parser: r } = e, i = t[1], n = egn(t[0], "url").url;
		return r.settings.isTrusted({
			command: "\\href",
			url: n
		}) ? {
			type: "href",
			mode: r.mode,
			href: n,
			body: efN(i)
		} : r.formatUnsupportedCmd("\\href");
	}, "handler"),
	htmlBuilder: h((e, t) => {
		var r = efP(e.body, t, !1);
		return efx.makeAnchor(e.href, [], r, t);
	}, "htmlBuilder"),
	mathmlBuilder: h((e, t) => {
		var r = ef1(e.body, t);
		return r instanceof efV || (r = new efV("mrow", [r])), r.setAttribute("href", e.href), r;
	}, "mathmlBuilder")
}), efA({
	type: "href",
	names: ["\\url"],
	props: {
		numArgs: 1,
		argTypes: ["url"],
		allowedInText: !0
	},
	handler: h((e, t) => {
		var { parser: r } = e, i = egn(t[0], "url").url;
		if (!r.settings.isTrusted({
			command: "\\url",
			url: i
		})) return r.formatUnsupportedCmd("\\url");
		for (var n = [], a = 0; a < i.length; a++) {
			var s = i[a];
			"~" === s && (s = "\\textasciitilde"), n.push({
				type: "textord",
				mode: "text",
				text: s
			});
		}
		var o = {
			type: "text",
			mode: r.mode,
			font: "\\texttt",
			body: n
		};
		return {
			type: "href",
			mode: r.mode,
			href: i,
			body: efN(o)
		};
	}, "handler")
}), efA({
	type: "hbox",
	names: ["\\hbox"],
	props: {
		numArgs: 1,
		argTypes: ["text"],
		allowedInText: !0,
		primitive: !0
	},
	handler(e, t) {
		var { parser: r } = e;
		return {
			type: "hbox",
			mode: r.mode,
			body: efN(t[0])
		};
	},
	htmlBuilder(e, t) {
		var r = efP(e.body, t, !1);
		return efx.makeFragment(r);
	},
	mathmlBuilder: (e, t) => new efV("mrow", ef0(e.body, t))
}), efA({
	type: "html",
	names: [
		"\\htmlClass",
		"\\htmlId",
		"\\htmlStyle",
		"\\htmlData"
	],
	props: {
		numArgs: 2,
		argTypes: ["raw", "original"],
		allowedInText: !0
	},
	handler: h((e, t) => {
		var { parser: r, funcName: i, token: n } = e, a = egn(t[0], "raw").string, s = t[1];
		r.settings.strict && r.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
		var o, l = {};
		switch (i) {
			case "\\htmlClass":
				l.class = a, o = {
					command: "\\htmlClass",
					class: a
				};
				break;
			case "\\htmlId":
				l.id = a, o = {
					command: "\\htmlId",
					id: a
				};
				break;
			case "\\htmlStyle":
				l.style = a, o = {
					command: "\\htmlStyle",
					style: a
				};
				break;
			case "\\htmlData":
				for (var h = a.split(","), u = 0; u < h.length; u++) {
					var d = h[u].split("=");
					if (2 !== d.length) throw new edx("Error parsing key-value for \\htmlData");
					l["data-" + d[0].trim()] = d[1].trim();
				}
				o = {
					command: "\\htmlData",
					attributes: l
				};
				break;
			default: throw Error("Unrecognized html command");
		}
		return r.settings.isTrusted(o) ? {
			type: "html",
			mode: r.mode,
			attributes: l,
			body: efN(s)
		} : r.formatUnsupportedCmd(i);
	}, "handler"),
	htmlBuilder: h((e, t) => {
		var r = efP(e.body, t, !1), i = ["enclosing"];
		e.attributes.class && i.push(...e.attributes.class.trim().split(/\s+/));
		var n = efx.makeSpan(i, r, t);
		for (var a in e.attributes) "class" !== a && e.attributes.hasOwnProperty(a) && n.setAttribute(a, e.attributes[a]);
		return n;
	}, "htmlBuilder"),
	mathmlBuilder: h((e, t) => ef1(e.body, t), "mathmlBuilder")
}), efA({
	type: "htmlmathml",
	names: ["\\html@mathml"],
	props: {
		numArgs: 2,
		allowedInText: !0
	},
	handler: h((e, t) => {
		var { parser: r } = e;
		return {
			type: "htmlmathml",
			mode: r.mode,
			html: efN(t[0]),
			mathml: efN(t[1])
		};
	}, "handler"),
	htmlBuilder: h((e, t) => {
		var r = efP(e.html, t, !1);
		return efx.makeFragment(r);
	}, "htmlBuilder"),
	mathmlBuilder: h((e, t) => ef1(e.mathml, t), "mathmlBuilder")
});
var emy = h(function(e) {
	if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(e)) return {
		number: +e,
		unit: "bp"
	};
	var t = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(e);
	if (!t) throw new edx("Invalid size: '" + e + "' in \\includegraphics");
	var r = {
		number: +(t[1] + t[2]),
		unit: t[3]
	};
	if (!epl(r)) throw new edx("Invalid unit: '" + r.unit + "' in \\includegraphics.");
	return r;
}, "sizeData");
efA({
	type: "includegraphics",
	names: ["\\includegraphics"],
	props: {
		numArgs: 1,
		numOptionalArgs: 1,
		argTypes: ["raw", "url"],
		allowedInText: !1
	},
	handler: h((e, t, r) => {
		var { parser: i } = e, n = {
			number: 0,
			unit: "em"
		}, a = {
			number: .9,
			unit: "em"
		}, s = {
			number: 0,
			unit: "em"
		}, o = "";
		if (r[0]) for (var l = egn(r[0], "raw").string, h = l.split(","), u = 0; u < h.length; u++) {
			var d = h[u].split("=");
			if (2 === d.length) {
				var p = d[1].trim();
				switch (d[0].trim()) {
					case "alt":
						o = p;
						break;
					case "width":
						n = emy(p);
						break;
					case "height":
						a = emy(p);
						break;
					case "totalheight":
						s = emy(p);
						break;
					default: throw new edx("Invalid key: '" + d[0] + "' in \\includegraphics.");
				}
			}
		}
		var f = egn(t[0], "url").url;
		return "" === o && (o = (o = (o = f).replace(/^.*[\\/]/, "")).substring(0, o.lastIndexOf("."))), i.settings.isTrusted({
			command: "\\includegraphics",
			url: f
		}) ? {
			type: "includegraphics",
			mode: i.mode,
			alt: o,
			width: n,
			height: a,
			totalheight: s,
			src: f
		} : i.formatUnsupportedCmd("\\includegraphics");
	}, "handler"),
	htmlBuilder: h((e, t) => {
		var r = epc(e.height, t), i = 0;
		e.totalheight.number > 0 && (i = epc(e.totalheight, t) - r);
		var n = 0;
		e.width.number > 0 && (n = epc(e.width, t));
		var a = { height: eph(r + i) };
		n > 0 && (a.width = eph(n)), i > 0 && (a.verticalAlign = eph(-i));
		var s = new epv(e.src, e.alt, a);
		return s.height = r, s.depth = i, s;
	}, "htmlBuilder"),
	mathmlBuilder: h((e, t) => {
		var r = new efV("mglyph", []);
		r.setAttribute("alt", e.alt);
		var i = epc(e.height, t), n = 0;
		if (e.totalheight.number > 0 && (n = epc(e.totalheight, t) - i, r.setAttribute("valign", eph(-n))), r.setAttribute("height", eph(i + n)), e.width.number > 0) {
			var a = epc(e.width, t);
			r.setAttribute("width", eph(a));
		}
		return r.setAttribute("src", e.src), r;
	}, "mathmlBuilder")
}), efA({
	type: "kern",
	names: [
		"\\kern",
		"\\mkern",
		"\\hskip",
		"\\mskip"
	],
	props: {
		numArgs: 1,
		argTypes: ["size"],
		primitive: !0,
		allowedInText: !0
	},
	handler(e, t) {
		var { parser: r, funcName: i } = e, n = egn(t[0], "size");
		if (r.settings.strict) {
			var a = "m" === i[1], s = "mu" === n.value.unit;
			a ? (s || r.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + i + " supports only mu units, not " + n.value.unit + " units"), "math" !== r.mode && r.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + i + " works only in math mode")) : s && r.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + i + " doesn't support mu units");
		}
		return {
			type: "kern",
			mode: r.mode,
			dimension: n.value
		};
	},
	htmlBuilder: (e, t) => efx.makeGlue(e.dimension, t),
	mathmlBuilder: (e, t) => new efX(epc(e.dimension, t))
}), efA({
	type: "lap",
	names: [
		"\\mathllap",
		"\\mathrlap",
		"\\mathclap"
	],
	props: {
		numArgs: 1,
		allowedInText: !0
	},
	handler: h((e, t) => {
		var { parser: r, funcName: i } = e, n = t[0];
		return {
			type: "lap",
			mode: r.mode,
			alignment: i.slice(5),
			body: n
		};
	}, "handler"),
	htmlBuilder: h((e, t) => {
		"clap" === e.alignment ? (r = efx.makeSpan([], [efq(e.body, t)]), r = efx.makeSpan(["inner"], [r], t)) : r = efx.makeSpan(["inner"], [efq(e.body, t)]);
		var r, i = efx.makeSpan(["fix"], []), n = efx.makeSpan([e.alignment], [r, i], t), a = efx.makeSpan(["strut"]);
		return a.style.height = eph(n.height + n.depth), n.depth && (a.style.verticalAlign = eph(-n.depth)), n.children.unshift(a), n = efx.makeSpan(["thinbox"], [n], t), efx.makeSpan(["mord", "vbox"], [n], t);
	}, "htmlBuilder"),
	mathmlBuilder: h((e, t) => {
		var r = new efV("mpadded", [ef2(e.body, t)]);
		if ("rlap" !== e.alignment) {
			var i = "llap" === e.alignment ? "-1" : "-0.5";
			r.setAttribute("lspace", i + "width");
		}
		return r.setAttribute("width", "0px"), r;
	}, "mathmlBuilder")
}), efA({
	type: "styling",
	names: ["\\(", "$"],
	props: {
		numArgs: 0,
		allowedInText: !0,
		allowedInMath: !1
	},
	handler(e, t) {
		var { funcName: r, parser: i } = e, n = i.mode;
		i.switchMode("math");
		var a = "\\(" === r ? "\\)" : "$", s = i.parseExpression(!1, a);
		return i.expect(a), i.switchMode(n), {
			type: "styling",
			mode: i.mode,
			style: "text",
			body: s
		};
	}
}), efA({
	type: "text",
	names: ["\\)", "\\]"],
	props: {
		numArgs: 0,
		allowedInText: !0,
		allowedInMath: !1
	},
	handler(e, t) {
		throw new edx("Mismatched " + e.funcName);
	}
});
var emv = h((e, t) => {
	switch (t.style.size) {
		case edG.DISPLAY.size: return e.display;
		case edG.TEXT.size: return e.text;
		case edG.SCRIPT.size: return e.script;
		case edG.SCRIPTSCRIPT.size: return e.scriptscript;
		default: return e.text;
	}
}, "chooseMathStyle");
efA({
	type: "mathchoice",
	names: ["\\mathchoice"],
	props: {
		numArgs: 4,
		primitive: !0
	},
	handler: h((e, t) => {
		var { parser: r } = e;
		return {
			type: "mathchoice",
			mode: r.mode,
			display: efN(t[0]),
			text: efN(t[1]),
			script: efN(t[2]),
			scriptscript: efN(t[3])
		};
	}, "handler"),
	htmlBuilder: h((e, t) => {
		var r = efP(emv(e, t), t, !1);
		return efx.makeFragment(r);
	}, "htmlBuilder"),
	mathmlBuilder: h((e, t) => ef1(emv(e, t), t), "mathmlBuilder")
});
var emx = h((e, t, r, i, n, a, s) => {
	e = efx.makeSpan([], [e]);
	var o, l, h, u = r && edR.isCharacterBox(r);
	if (t) {
		var d = efq(t, i.havingStyle(n.sup()), i);
		h = {
			elem: d,
			kern: Math.max(i.fontMetrics().bigOpSpacing1, i.fontMetrics().bigOpSpacing3 - d.depth)
		};
	}
	if (r) {
		var p = efq(r, i.havingStyle(n.sub()), i);
		l = {
			elem: p,
			kern: Math.max(i.fontMetrics().bigOpSpacing2, i.fontMetrics().bigOpSpacing4 - p.height)
		};
	}
	if (h && l) {
		var f = i.fontMetrics().bigOpSpacing5 + l.elem.height + l.elem.depth + l.kern + e.depth + s;
		o = efx.makeVList({
			positionType: "bottom",
			positionData: f,
			children: [
				{
					type: "kern",
					size: i.fontMetrics().bigOpSpacing5
				},
				{
					type: "elem",
					elem: l.elem,
					marginLeft: eph(-a)
				},
				{
					type: "kern",
					size: l.kern
				},
				{
					type: "elem",
					elem: e
				},
				{
					type: "kern",
					size: h.kern
				},
				{
					type: "elem",
					elem: h.elem,
					marginLeft: eph(a)
				},
				{
					type: "kern",
					size: i.fontMetrics().bigOpSpacing5
				}
			]
		}, i);
	} else if (l) {
		var g = e.height - s;
		o = efx.makeVList({
			positionType: "top",
			positionData: g,
			children: [
				{
					type: "kern",
					size: i.fontMetrics().bigOpSpacing5
				},
				{
					type: "elem",
					elem: l.elem,
					marginLeft: eph(-a)
				},
				{
					type: "kern",
					size: l.kern
				},
				{
					type: "elem",
					elem: e
				}
			]
		}, i);
	} else {
		if (!h) return e;
		var m = e.depth + s;
		o = efx.makeVList({
			positionType: "bottom",
			positionData: m,
			children: [
				{
					type: "elem",
					elem: e
				},
				{
					type: "kern",
					size: h.kern
				},
				{
					type: "elem",
					elem: h.elem,
					marginLeft: eph(a)
				},
				{
					type: "kern",
					size: i.fontMetrics().bigOpSpacing5
				}
			]
		}, i);
	}
	var y = [o];
	if (l && 0 !== a && !u) {
		var v = efx.makeSpan(["mspace"], [], i);
		v.style.marginRight = eph(a), y.unshift(v);
	}
	return efx.makeSpan(["mop", "op-limits"], y, i);
}, "assembleSupSub"), emb = ["\\smallint"], emw = h((e, t) => {
	var r, i, n, a, s = !1;
	"supsub" === e.type ? (i = e.sup, n = e.sub, a = egn(e.base, "op"), s = !0) : a = egn(e, "op");
	var o = t.style, l = !1;
	if (o.size === edG.DISPLAY.size && a.symbol && !edR.contains(emb, a.name) && (l = !0), a.symbol) {
		var h = l ? "Size2-Regular" : "Size1-Regular", u = "";
		if (("\\oiint" === a.name || "\\oiiint" === a.name) && (u = a.name.slice(1), a.name = "oiint" === u ? "\\iint" : "\\iiint"), r = efx.makeSymbol(a.name, h, "math", t, [
			"mop",
			"op-symbol",
			l ? "large-op" : "small-op"
		]), u.length > 0) {
			var d = r.italic, p = efx.staticSvg(u + "Size" + (l ? "2" : "1"), t);
			r = efx.makeVList({
				positionType: "individualShift",
				children: [{
					type: "elem",
					elem: r,
					shift: 0
				}, {
					type: "elem",
					elem: p,
					shift: .08 * !!l
				}]
			}, t), a.name = "\\" + u, r.classes.unshift("mop"), r.italic = d;
		}
	} else if (a.body) {
		var f = efP(a.body, t, !0);
		1 === f.length && f[0] instanceof epb ? (r = f[0]).classes[0] = "mop" : r = efx.makeSpan(["mop"], f, t);
	} else {
		for (var g = [], m = 1; m < a.name.length; m++) g.push(efx.mathsym(a.name[m], a.mode, t));
		r = efx.makeSpan(["mop"], g, t);
	}
	var y = 0, v = 0;
	return (r instanceof epb || "\\oiint" === a.name || "\\oiiint" === a.name) && !a.suppressBaseShift && (y = (r.height - r.depth) / 2 - t.fontMetrics().axisHeight, v = r.italic), s ? emx(r, i, n, t, o, v, y) : (y && (r.style.position = "relative", r.style.top = eph(y)), r);
}, "htmlBuilder$2"), emk = h((e, t) => {
	var r;
	if (e.symbol) r = new efV("mo", [efK(e.name, e.mode)]), edR.contains(emb, e.name) && r.setAttribute("largeop", "false");
	else if (e.body) r = new efV("mo", ef0(e.body, t));
	else {
		r = new efV("mi", [new efH(e.name.slice(1))]);
		var i = new efV("mo", [efK("", "text")]);
		r = e.parentIsSupSub ? new efV("mrow", [r, i]) : efY([r, i]);
	}
	return r;
}, "mathmlBuilder$1"), emT = {
	"": "\\prod",
	"": "\\coprod",
	"": "\\sum",
	"": "\\bigwedge",
	"": "\\bigvee",
	"": "\\bigcap",
	"": "\\bigcup",
	"": "\\bigodot",
	"": "\\bigoplus",
	"": "\\bigotimes",
	"": "\\biguplus",
	"": "\\bigsqcup"
};
efA({
	type: "op",
	names: [
		"\\coprod",
		"\\bigvee",
		"\\bigwedge",
		"\\biguplus",
		"\\bigcap",
		"\\bigcup",
		"\\intop",
		"\\prod",
		"\\sum",
		"\\bigotimes",
		"\\bigoplus",
		"\\bigodot",
		"\\bigsqcup",
		"\\smallint",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		"",
		""
	],
	props: { numArgs: 0 },
	handler: h((e, t) => {
		var { parser: r, funcName: i } = e, n = i;
		return 1 === n.length && (n = emT[n]), {
			type: "op",
			mode: r.mode,
			limits: !0,
			parentIsSupSub: !1,
			symbol: !0,
			name: n
		};
	}, "handler"),
	htmlBuilder: emw,
	mathmlBuilder: emk
}), efA({
	type: "op",
	names: ["\\mathop"],
	props: {
		numArgs: 1,
		primitive: !0
	},
	handler: h((e, t) => {
		var { parser: r } = e, i = t[0];
		return {
			type: "op",
			mode: r.mode,
			limits: !1,
			parentIsSupSub: !1,
			symbol: !1,
			body: efN(i)
		};
	}, "handler"),
	htmlBuilder: emw,
	mathmlBuilder: emk
});
var em_ = {
	"": "\\int",
	"": "\\iint",
	"": "\\iiint",
	"": "\\oint",
	"": "\\oiint",
	"": "\\oiiint"
};
efA({
	type: "op",
	names: [
		"\\arcsin",
		"\\arccos",
		"\\arctan",
		"\\arctg",
		"\\arcctg",
		"\\arg",
		"\\ch",
		"\\cos",
		"\\cosec",
		"\\cosh",
		"\\cot",
		"\\cotg",
		"\\coth",
		"\\csc",
		"\\ctg",
		"\\cth",
		"\\deg",
		"\\dim",
		"\\exp",
		"\\hom",
		"\\ker",
		"\\lg",
		"\\ln",
		"\\log",
		"\\sec",
		"\\sin",
		"\\sinh",
		"\\sh",
		"\\tan",
		"\\tanh",
		"\\tg",
		"\\th"
	],
	props: { numArgs: 0 },
	handler(e) {
		var { parser: t, funcName: r } = e;
		return {
			type: "op",
			mode: t.mode,
			limits: !1,
			parentIsSupSub: !1,
			symbol: !1,
			name: r
		};
	},
	htmlBuilder: emw,
	mathmlBuilder: emk
}), efA({
	type: "op",
	names: [
		"\\det",
		"\\gcd",
		"\\inf",
		"\\lim",
		"\\max",
		"\\min",
		"\\Pr",
		"\\sup"
	],
	props: { numArgs: 0 },
	handler(e) {
		var { parser: t, funcName: r } = e;
		return {
			type: "op",
			mode: t.mode,
			limits: !0,
			parentIsSupSub: !1,
			symbol: !1,
			name: r
		};
	},
	htmlBuilder: emw,
	mathmlBuilder: emk
}), efA({
	type: "op",
	names: [
		"\\int",
		"\\iint",
		"\\iiint",
		"\\oint",
		"\\oiint",
		"\\oiiint",
		"",
		"",
		"",
		"",
		"",
		""
	],
	props: { numArgs: 0 },
	handler(e) {
		var { parser: t, funcName: r } = e, i = r;
		return 1 === i.length && (i = em_[i]), {
			type: "op",
			mode: t.mode,
			limits: !1,
			parentIsSupSub: !1,
			symbol: !0,
			name: i
		};
	},
	htmlBuilder: emw,
	mathmlBuilder: emk
});
var emE = h((e, t) => {
	var r, i, n, a, s = !1;
	if ("supsub" === e.type ? (i = e.sup, n = e.sub, a = egn(e.base, "operatorname"), s = !0) : a = egn(e, "operatorname"), a.body.length > 0) {
		for (var o = efP(a.body.map((e) => {
			var t = e.text;
			return "string" == typeof t ? {
				type: "textord",
				mode: e.mode,
				text: t
			} : e;
		}), t.withFont("mathrm"), !0), l = 0; l < o.length; l++) {
			var h = o[l];
			h instanceof epb && (h.text = h.text.replace(/\u2212/, "-").replace(/\u2217/, "*"));
		}
		r = efx.makeSpan(["mop"], o, t);
	} else r = efx.makeSpan(["mop"], [], t);
	return s ? emx(r, i, n, t, t.style, 0, 0) : r;
}, "htmlBuilder$1"), emC = h((e, t) => {
	for (var r = ef0(e.body, t.withFont("mathrm")), i = !0, n = 0; n < r.length; n++) {
		var a = r[n];
		if (!(a instanceof efX)) if (a instanceof efV) switch (a.type) {
			case "mi":
			case "mn":
			case "ms":
			case "mspace":
			case "mtext": break;
			case "mo":
				var s = a.children[0];
				1 === a.children.length && s instanceof efH ? s.text = s.text.replace(/\u2212/, "-").replace(/\u2217/, "*") : i = !1;
				break;
			default: i = !1;
		}
		else i = !1;
	}
	i && (r = [new efH(r.map((e) => e.toText()).join(""))]);
	var o = new efV("mi", r);
	o.setAttribute("mathvariant", "normal");
	var l = new efV("mo", [efK("", "text")]);
	return e.parentIsSupSub ? new efV("mrow", [o, l]) : efY([o, l]);
}, "mathmlBuilder");
function emS(e, t, r) {
	for (var i = efP(e, t, !1), n = t.sizeMultiplier / r.sizeMultiplier, a = 0; a < i.length; a++) {
		var s = i[a].classes.indexOf("sizing");
		s < 0 ? Array.prototype.push.apply(i[a].classes, t.sizingClasses(r)) : i[a].classes[s + 1] === "reset-size" + t.size && (i[a].classes[s + 1] = "reset-size" + r.size), i[a].height *= n, i[a].depth *= n;
	}
	return efx.makeFragment(i);
}
efA({
	type: "operatorname",
	names: ["\\operatorname@", "\\operatornamewithlimits"],
	props: { numArgs: 1 },
	handler: h((e, t) => {
		var { parser: r, funcName: i } = e, n = t[0];
		return {
			type: "operatorname",
			mode: r.mode,
			body: efN(n),
			alwaysHandleSupSub: "\\operatornamewithlimits" === i,
			limits: !1,
			parentIsSupSub: !1
		};
	}, "handler"),
	htmlBuilder: emE,
	mathmlBuilder: emC
}), eg8("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@"), efL({
	type: "ordgroup",
	htmlBuilder: (e, t) => e.semisimple ? efx.makeFragment(efP(e.body, t, !1)) : efx.makeSpan(["mord"], efP(e.body, t, !0), t),
	mathmlBuilder: (e, t) => ef1(e.body, t, !0)
}), efA({
	type: "overline",
	names: ["\\overline"],
	props: { numArgs: 1 },
	handler(e, t) {
		var { parser: r } = e, i = t[0];
		return {
			type: "overline",
			mode: r.mode,
			body: i
		};
	},
	htmlBuilder(e, t) {
		var r = efq(e.body, t.havingCrampedStyle()), i = efx.makeLineSpan("overline-line", t), n = t.fontMetrics().defaultRuleThickness, a = efx.makeVList({
			positionType: "firstBaseline",
			children: [
				{
					type: "elem",
					elem: r
				},
				{
					type: "kern",
					size: 3 * n
				},
				{
					type: "elem",
					elem: i
				},
				{
					type: "kern",
					size: n
				}
			]
		}, t);
		return efx.makeSpan(["mord", "overline"], [a], t);
	},
	mathmlBuilder(e, t) {
		var r = new efV("mo", [new efH("")]);
		r.setAttribute("stretchy", "true");
		var i = new efV("mover", [ef2(e.body, t), r]);
		return i.setAttribute("accent", "true"), i;
	}
}), efA({
	type: "phantom",
	names: ["\\phantom"],
	props: {
		numArgs: 1,
		allowedInText: !0
	},
	handler: h((e, t) => {
		var { parser: r } = e, i = t[0];
		return {
			type: "phantom",
			mode: r.mode,
			body: efN(i)
		};
	}, "handler"),
	htmlBuilder: h((e, t) => {
		var r = efP(e.body, t.withPhantom(), !1);
		return efx.makeFragment(r);
	}, "htmlBuilder"),
	mathmlBuilder: h((e, t) => new efV("mphantom", ef0(e.body, t)), "mathmlBuilder")
}), efA({
	type: "hphantom",
	names: ["\\hphantom"],
	props: {
		numArgs: 1,
		allowedInText: !0
	},
	handler: h((e, t) => {
		var { parser: r } = e, i = t[0];
		return {
			type: "hphantom",
			mode: r.mode,
			body: i
		};
	}, "handler"),
	htmlBuilder: h((e, t) => {
		var r = efx.makeSpan([], [efq(e.body, t.withPhantom())]);
		if (r.height = 0, r.depth = 0, r.children) for (var i = 0; i < r.children.length; i++) r.children[i].height = 0, r.children[i].depth = 0;
		return r = efx.makeVList({
			positionType: "firstBaseline",
			children: [{
				type: "elem",
				elem: r
			}]
		}, t), efx.makeSpan(["mord"], [r], t);
	}, "htmlBuilder"),
	mathmlBuilder: h((e, t) => {
		var i = new efV("mpadded", [new efV("mphantom", ef0(efN(e.body), t))]);
		return i.setAttribute("height", "0px"), i.setAttribute("depth", "0px"), i;
	}, "mathmlBuilder")
}), efA({
	type: "vphantom",
	names: ["\\vphantom"],
	props: {
		numArgs: 1,
		allowedInText: !0
	},
	handler: h((e, t) => {
		var { parser: r } = e, i = t[0];
		return {
			type: "vphantom",
			mode: r.mode,
			body: i
		};
	}, "handler"),
	htmlBuilder: h((e, t) => {
		var r = efx.makeSpan(["inner"], [efq(e.body, t.withPhantom())]), i = efx.makeSpan(["fix"], []);
		return efx.makeSpan(["mord", "rlap"], [r, i], t);
	}, "htmlBuilder"),
	mathmlBuilder: h((e, t) => {
		var i = new efV("mpadded", [new efV("mphantom", ef0(efN(e.body), t))]);
		return i.setAttribute("width", "0px"), i;
	}, "mathmlBuilder")
}), efA({
	type: "raisebox",
	names: ["\\raisebox"],
	props: {
		numArgs: 2,
		argTypes: ["size", "hbox"],
		allowedInText: !0
	},
	handler(e, t) {
		var { parser: r } = e, i = egn(t[0], "size").value, n = t[1];
		return {
			type: "raisebox",
			mode: r.mode,
			dy: i,
			body: n
		};
	},
	htmlBuilder(e, t) {
		var r = efq(e.body, t), i = epc(e.dy, t);
		return efx.makeVList({
			positionType: "shift",
			positionData: -i,
			children: [{
				type: "elem",
				elem: r
			}]
		}, t);
	},
	mathmlBuilder(e, t) {
		var r = new efV("mpadded", [ef2(e.body, t)]), i = e.dy.number + e.dy.unit;
		return r.setAttribute("voffset", i), r;
	}
}), efA({
	type: "internal",
	names: ["\\relax"],
	props: {
		numArgs: 0,
		allowedInText: !0,
		allowedInArgument: !0
	},
	handler(e) {
		var { parser: t } = e;
		return {
			type: "internal",
			mode: t.mode
		};
	}
}), efA({
	type: "rule",
	names: ["\\rule"],
	props: {
		numArgs: 2,
		numOptionalArgs: 1,
		allowedInText: !0,
		allowedInMath: !0,
		argTypes: [
			"size",
			"size",
			"size"
		]
	},
	handler(e, t, r) {
		var { parser: i } = e, n = r[0], a = egn(t[0], "size"), s = egn(t[1], "size");
		return {
			type: "rule",
			mode: i.mode,
			shift: n && egn(n, "size").value,
			width: a.value,
			height: s.value
		};
	},
	htmlBuilder(e, t) {
		var r = efx.makeSpan(["mord", "rule"], [], t), i = epc(e.width, t), n = epc(e.height, t), a = e.shift ? epc(e.shift, t) : 0;
		return r.style.borderRightWidth = eph(i), r.style.borderTopWidth = eph(n), r.style.bottom = eph(a), r.width = i, r.height = n + a, r.depth = -a, r.maxFontSize = 1.125 * n * t.sizeMultiplier, r;
	},
	mathmlBuilder(e, t) {
		var r = epc(e.width, t), i = epc(e.height, t), n = e.shift ? epc(e.shift, t) : 0, a = t.color && t.getColor() || "black", s = new efV("mspace");
		s.setAttribute("mathbackground", a), s.setAttribute("width", eph(r)), s.setAttribute("height", eph(i));
		var o = new efV("mpadded", [s]);
		return n >= 0 ? o.setAttribute("height", eph(n)) : (o.setAttribute("height", eph(n)), o.setAttribute("depth", eph(-n))), o.setAttribute("voffset", eph(n)), o;
	}
}), h(emS, "sizingGroup");
var emA = [
	"\\tiny",
	"\\sixptsize",
	"\\scriptsize",
	"\\footnotesize",
	"\\small",
	"\\normalsize",
	"\\large",
	"\\Large",
	"\\LARGE",
	"\\huge",
	"\\Huge"
], emL = h((e, t) => {
	var r = t.havingSize(e.size);
	return emS(e.body, r, t);
}, "htmlBuilder");
efA({
	type: "sizing",
	names: emA,
	props: {
		numArgs: 0,
		allowedInText: !0
	},
	handler: h((e, t) => {
		var { breakOnTokenText: r, funcName: i, parser: n } = e, a = n.parseExpression(!1, r);
		return {
			type: "sizing",
			mode: n.mode,
			size: emA.indexOf(i) + 1,
			body: a
		};
	}, "handler"),
	htmlBuilder: emL,
	mathmlBuilder: h((e, t) => {
		var r = t.havingSize(e.size), i = new efV("mstyle", ef0(e.body, r));
		return i.setAttribute("mathsize", eph(r.sizeMultiplier)), i;
	}, "mathmlBuilder")
}), efA({
	type: "smash",
	names: ["\\smash"],
	props: {
		numArgs: 1,
		numOptionalArgs: 1,
		allowedInText: !0
	},
	handler: h((e, t, r) => {
		var { parser: i } = e, n = !1, a = !1, s = r[0] && egn(r[0], "ordgroup");
		if (s) for (var o = "", l = 0; l < s.body.length; ++l) if ("t" === (o = s.body[l].text)) n = !0;
		else if ("b" === o) a = !0;
		else {
			n = !1, a = !1;
			break;
		}
		else n = !0, a = !0;
		var h = t[0];
		return {
			type: "smash",
			mode: i.mode,
			body: h,
			smashHeight: n,
			smashDepth: a
		};
	}, "handler"),
	htmlBuilder: h((e, t) => {
		var r = efx.makeSpan([], [efq(e.body, t)]);
		if (!e.smashHeight && !e.smashDepth) return r;
		if (e.smashHeight && (r.height = 0, r.children)) for (var i = 0; i < r.children.length; i++) r.children[i].height = 0;
		if (e.smashDepth && (r.depth = 0, r.children)) for (var n = 0; n < r.children.length; n++) r.children[n].depth = 0;
		var a = efx.makeVList({
			positionType: "firstBaseline",
			children: [{
				type: "elem",
				elem: r
			}]
		}, t);
		return efx.makeSpan(["mord"], [a], t);
	}, "htmlBuilder"),
	mathmlBuilder: h((e, t) => {
		var r = new efV("mpadded", [ef2(e.body, t)]);
		return e.smashHeight && r.setAttribute("height", "0px"), e.smashDepth && r.setAttribute("depth", "0px"), r;
	}, "mathmlBuilder")
}), efA({
	type: "sqrt",
	names: ["\\sqrt"],
	props: {
		numArgs: 1,
		numOptionalArgs: 1
	},
	handler(e, t, r) {
		var { parser: i } = e, n = r[0], a = t[0];
		return {
			type: "sqrt",
			mode: i.mode,
			body: a,
			index: n
		};
	},
	htmlBuilder(e, t) {
		var r = efq(e.body, t.havingCrampedStyle());
		0 === r.height && (r.height = t.fontMetrics().xHeight), r = efx.wrapFragment(r, t);
		var i = t.fontMetrics().defaultRuleThickness, n = i;
		t.style.id < edG.TEXT.id && (n = t.fontMetrics().xHeight);
		var a = i + n / 4, s = r.height + r.depth + a + i, { span: o, ruleWidth: l, advanceWidth: h } = egQ.sqrtImage(s, t), u = o.height - l;
		u > r.height + r.depth + a && (a = (a + u - r.height - r.depth) / 2);
		var d = o.height - r.height - a - l;
		r.style.paddingLeft = eph(h);
		var p = efx.makeVList({
			positionType: "firstBaseline",
			children: [
				{
					type: "elem",
					elem: r,
					wrapperClasses: ["svg-align"]
				},
				{
					type: "kern",
					size: -(r.height + d)
				},
				{
					type: "elem",
					elem: o
				},
				{
					type: "kern",
					size: l
				}
			]
		}, t);
		if (!e.index) return efx.makeSpan(["mord", "sqrt"], [p], t);
		var f = t.havingStyle(edG.SCRIPTSCRIPT), g = efq(e.index, f, t), m = .6 * (p.height - p.depth), y = efx.makeVList({
			positionType: "shift",
			positionData: -m,
			children: [{
				type: "elem",
				elem: g
			}]
		}, t), v = efx.makeSpan(["root"], [y]);
		return efx.makeSpan(["mord", "sqrt"], [v, p], t);
	},
	mathmlBuilder(e, t) {
		var { body: r, index: i } = e;
		return i ? new efV("mroot", [ef2(r, t), ef2(i, t)]) : new efV("msqrt", [ef2(r, t)]);
	}
});
var emR = {
	display: edG.DISPLAY,
	text: edG.TEXT,
	script: edG.SCRIPT,
	scriptscript: edG.SCRIPTSCRIPT
};
efA({
	type: "styling",
	names: [
		"\\displaystyle",
		"\\textstyle",
		"\\scriptstyle",
		"\\scriptscriptstyle"
	],
	props: {
		numArgs: 0,
		allowedInText: !0,
		primitive: !0
	},
	handler(e, t) {
		var { breakOnTokenText: r, funcName: i, parser: n } = e, a = n.parseExpression(!0, r), s = i.slice(1, i.length - 5);
		return {
			type: "styling",
			mode: n.mode,
			style: s,
			body: a
		};
	},
	htmlBuilder(e, t) {
		var r = emR[e.style], i = t.havingStyle(r).withFont("");
		return emS(e.body, i, t);
	},
	mathmlBuilder(e, t) {
		var r = emR[e.style], i = t.havingStyle(r), n = new efV("mstyle", ef0(e.body, i)), a = {
			display: ["0", "true"],
			text: ["0", "false"],
			script: ["1", "false"],
			scriptscript: ["2", "false"]
		}[e.style];
		return n.setAttribute("scriptlevel", a[0]), n.setAttribute("displaystyle", a[1]), n;
	}
});
var emN = h(function(e, t) {
	var r = e.base;
	return r ? "op" === r.type ? r.limits && (t.style.size === edG.DISPLAY.size || r.alwaysHandleSupSub) ? emw : null : "operatorname" === r.type ? r.alwaysHandleSupSub && (t.style.size === edG.DISPLAY.size || r.limits) ? emE : null : "accent" === r.type ? edR.isCharacterBox(r.base) ? ego : null : "horizBrace" === r.type && !e.sub === r.isOver ? emm : null : null;
}, "htmlBuilderDelegate");
efL({
	type: "supsub",
	htmlBuilder(e, t) {
		var r, i, n = emN(e, t);
		if (n) return n(e, t);
		var a, s, { base: o, sup: l, sub: h } = e, u = efq(o, t), d = t.fontMetrics(), p = 0, f = 0, g = o && edR.isCharacterBox(o);
		if (l) {
			var m = t.havingStyle(t.style.sup());
			a = efq(l, m, t), g || (p = u.height - m.fontMetrics().supDrop * m.sizeMultiplier / t.sizeMultiplier);
		}
		if (h) {
			var y = t.havingStyle(t.style.sub());
			s = efq(h, y, t), g || (f = u.depth + y.fontMetrics().subDrop * y.sizeMultiplier / t.sizeMultiplier);
		}
		r = t.style === edG.DISPLAY ? d.sup1 : t.style.cramped ? d.sup3 : d.sup2;
		var v = t.sizeMultiplier, x = eph(.5 / d.ptPerEm / v), b = null;
		if (s) {
			var w = e.base && "op" === e.base.type && e.base.name && ("\\oiint" === e.base.name || "\\oiiint" === e.base.name);
			(u instanceof epb || w) && (b = eph(-u.italic));
		}
		if (a && s) {
			p = Math.max(p, r, a.depth + .25 * d.xHeight), f = Math.max(f, d.sub2);
			var k = 4 * d.defaultRuleThickness;
			if (p - a.depth - (s.height - f) < k) {
				f = k - (p - a.depth) + s.height;
				var T = .8 * d.xHeight - (p - a.depth);
				T > 0 && (p += T, f -= T);
			}
			var _ = [{
				type: "elem",
				elem: s,
				shift: f,
				marginRight: x,
				marginLeft: b
			}, {
				type: "elem",
				elem: a,
				shift: -p,
				marginRight: x
			}];
			i = efx.makeVList({
				positionType: "individualShift",
				children: _
			}, t);
		} else if (s) {
			f = Math.max(f, d.sub1, s.height - .8 * d.xHeight);
			var E = [{
				type: "elem",
				elem: s,
				marginLeft: b,
				marginRight: x
			}];
			i = efx.makeVList({
				positionType: "shift",
				positionData: f,
				children: E
			}, t);
		} else if (a) p = Math.max(p, r, a.depth + .25 * d.xHeight), i = efx.makeVList({
			positionType: "shift",
			positionData: -p,
			children: [{
				type: "elem",
				elem: a,
				marginRight: x
			}]
		}, t);
		else throw Error("supsub must have either sup or sub.");
		var C = efU(u, "right") || "mord";
		return efx.makeSpan([C], [u, efx.makeSpan(["msupsub"], [i])], t);
	},
	mathmlBuilder(e, t) {
		var r, i, n = !1;
		e.base && "horizBrace" === e.base.type && !!e.sup === e.base.isOver && (n = !0, i = e.base.isOver), e.base && ("op" === e.base.type || "operatorname" === e.base.type) && (e.base.parentIsSupSub = !0);
		var a = [ef2(e.base, t)];
		if (e.sub && a.push(ef2(e.sub, t)), e.sup && a.push(ef2(e.sup, t)), n) r = i ? "mover" : "munder";
		else if (e.sub) if (e.sup) {
			var s = e.base;
			r = s && "op" === s.type && s.limits && t.style === edG.DISPLAY || s && "operatorname" === s.type && s.alwaysHandleSupSub && (t.style === edG.DISPLAY || s.limits) ? "munderover" : "msubsup";
		} else {
			var o = e.base;
			r = o && "op" === o.type && o.limits && (t.style === edG.DISPLAY || o.alwaysHandleSupSub) || o && "operatorname" === o.type && o.alwaysHandleSupSub && (o.limits || t.style === edG.DISPLAY) ? "munder" : "msub";
		}
		else {
			var l = e.base;
			r = l && "op" === l.type && l.limits && (t.style === edG.DISPLAY || l.alwaysHandleSupSub) || l && "operatorname" === l.type && l.alwaysHandleSupSub && (l.limits || t.style === edG.DISPLAY) ? "mover" : "msup";
		}
		return new efV(r, a);
	}
}), efL({
	type: "atom",
	htmlBuilder: (e, t) => efx.mathsym(e.text, e.mode, t, ["m" + e.family]),
	mathmlBuilder(e, t) {
		var r = new efV("mo", [efK(e.text, e.mode)]);
		if ("bin" === e.family) {
			var i = efQ(e, t);
			"bold-italic" === i && r.setAttribute("mathvariant", i);
		} else "punct" === e.family ? r.setAttribute("separator", "true") : ("open" === e.family || "close" === e.family) && r.setAttribute("stretchy", "false");
		return r;
	}
});
var emI = {
	mi: "italic",
	mn: "normal",
	mtext: "normal"
};
efL({
	type: "mathord",
	htmlBuilder: (e, t) => efx.makeOrd(e, t, "mathord"),
	mathmlBuilder(e, t) {
		var r = new efV("mi", [efK(e.text, e.mode, t)]), i = efQ(e, t) || "italic";
		return i !== emI[r.type] && r.setAttribute("mathvariant", i), r;
	}
}), efL({
	type: "textord",
	htmlBuilder: (e, t) => efx.makeOrd(e, t, "textord"),
	mathmlBuilder(e, t) {
		var r, i = efK(e.text, e.mode, t), n = efQ(e, t) || "normal";
		return n !== emI[(r = "text" === e.mode ? new efV("mtext", [i]) : /[0-9]/.test(e.text) ? new efV("mn", [i]) : "\\prime" === e.text ? new efV("mo", [i]) : new efV("mi", [i])).type] && r.setAttribute("mathvariant", n), r;
	}
});
var emM = {
	"\\nobreak": "nobreak",
	"\\allowbreak": "allowbreak"
}, emD = {
	" ": {},
	"\\ ": {},
	"~": { className: "nobreak" },
	"\\space": {},
	"\\nobreakspace": { className: "nobreak" }
};
efL({
	type: "spacing",
	htmlBuilder(e, t) {
		if (emD.hasOwnProperty(e.text)) {
			var r = emD[e.text].className || "";
			if ("text" !== e.mode) return efx.makeSpan(["mspace", r], [efx.mathsym(e.text, e.mode, t)], t);
			var i = efx.makeOrd(e, t, "textord");
			return i.classes.push(r), i;
		}
		if (emM.hasOwnProperty(e.text)) return efx.makeSpan(["mspace", emM[e.text]], [], t);
		throw new edx("Unknown type of space \"" + e.text + "\"");
	},
	mathmlBuilder(e, t) {
		var r;
		if (emD.hasOwnProperty(e.text)) r = new efV("mtext", [new efH("\xA0")]);
		else {
			if (emM.hasOwnProperty(e.text)) return new efV("mspace");
			throw new edx("Unknown type of space \"" + e.text + "\"");
		}
		return r;
	}
});
var emO = h(() => {
	var e = new efV("mtd", []);
	return e.setAttribute("width", "50%"), e;
}, "pad");
efL({
	type: "tag",
	mathmlBuilder(e, t) {
		var r = new efV("mtable", [new efV("mtr", [
			emO(),
			new efV("mtd", [ef1(e.body, t)]),
			emO(),
			new efV("mtd", [ef1(e.tag, t)])
		])]);
		return r.setAttribute("width", "100%"), r;
	}
});
var em$ = {
	"\\text": void 0,
	"\\textrm": "textrm",
	"\\textsf": "textsf",
	"\\texttt": "texttt",
	"\\textnormal": "textrm"
}, emP = {
	"\\textbf": "textbf",
	"\\textmd": "textmd"
}, emB = {
	"\\textit": "textit",
	"\\textup": "textup"
}, emF = h((e, t) => {
	var r = e.font;
	return r ? em$[r] ? t.withTextFontFamily(em$[r]) : emP[r] ? t.withTextFontWeight(emP[r]) : "\\emph" === r ? "textit" === t.fontShape ? t.withTextFontShape("textup") : t.withTextFontShape("textit") : t.withTextFontShape(emB[r]) : t;
}, "optionsWithFont");
efA({
	type: "text",
	names: [
		"\\text",
		"\\textrm",
		"\\textsf",
		"\\texttt",
		"\\textnormal",
		"\\textbf",
		"\\textmd",
		"\\textit",
		"\\textup",
		"\\emph"
	],
	props: {
		numArgs: 1,
		argTypes: ["text"],
		allowedInArgument: !0,
		allowedInText: !0
	},
	handler(e, t) {
		var { parser: r, funcName: i } = e, n = t[0];
		return {
			type: "text",
			mode: r.mode,
			body: efN(n),
			font: i
		};
	},
	htmlBuilder(e, t) {
		var r = emF(e, t), i = efP(e.body, r, !0);
		return efx.makeSpan(["mord", "text"], i, r);
	},
	mathmlBuilder(e, t) {
		var r = emF(e, t);
		return ef1(e.body, r);
	}
}), efA({
	type: "underline",
	names: ["\\underline"],
	props: {
		numArgs: 1,
		allowedInText: !0
	},
	handler(e, t) {
		var { parser: r } = e;
		return {
			type: "underline",
			mode: r.mode,
			body: t[0]
		};
	},
	htmlBuilder(e, t) {
		var r = efq(e.body, t), i = efx.makeLineSpan("underline-line", t), n = t.fontMetrics().defaultRuleThickness, a = efx.makeVList({
			positionType: "top",
			positionData: r.height,
			children: [
				{
					type: "kern",
					size: n
				},
				{
					type: "elem",
					elem: i
				},
				{
					type: "kern",
					size: 3 * n
				},
				{
					type: "elem",
					elem: r
				}
			]
		}, t);
		return efx.makeSpan(["mord", "underline"], [a], t);
	},
	mathmlBuilder(e, t) {
		var r = new efV("mo", [new efH("")]);
		r.setAttribute("stretchy", "true");
		var i = new efV("munder", [ef2(e.body, t), r]);
		return i.setAttribute("accentunder", "true"), i;
	}
}), efA({
	type: "vcenter",
	names: ["\\vcenter"],
	props: {
		numArgs: 1,
		argTypes: ["original"],
		allowedInText: !1
	},
	handler(e, t) {
		var { parser: r } = e;
		return {
			type: "vcenter",
			mode: r.mode,
			body: t[0]
		};
	},
	htmlBuilder(e, t) {
		var r = efq(e.body, t), i = t.fontMetrics().axisHeight, n = .5 * (r.height - i - (r.depth + i));
		return efx.makeVList({
			positionType: "shift",
			positionData: n,
			children: [{
				type: "elem",
				elem: r
			}]
		}, t);
	},
	mathmlBuilder: (e, t) => new efV("mpadded", [ef2(e.body, t)], ["vcenter"])
}), efA({
	type: "verb",
	names: ["\\verb"],
	props: {
		numArgs: 0,
		allowedInText: !0
	},
	handler(e, t, r) {
		throw new edx("\\verb ended by end of line instead of matching delimiter");
	},
	htmlBuilder(e, t) {
		for (var r = emz(e), i = [], n = t.havingStyle(t.style.text()), a = 0; a < r.length; a++) {
			var s = r[a];
			"~" === s && (s = "\\textasciitilde"), i.push(efx.makeSymbol(s, "Typewriter-Regular", e.mode, n, ["mord", "texttt"]));
		}
		return efx.makeSpan(["mord", "text"].concat(n.sizingClasses(t)), efx.tryCombineChars(i), n);
	},
	mathmlBuilder(e, t) {
		var r = new efV("mtext", [new efH(emz(e))]);
		return r.setAttribute("mathvariant", "monospace"), r;
	}
});
var emz = h((e) => e.body.replace(/ /g, e.star ? "" : "\xA0"), "makeVerb"), emU = `[ \r
	]`, emG = `\\\\(
|[ \r	]+
?)[ \r	]*`, emq = "[-]", emj = RegExp(emq + "+$"), emW = "(" + emU + "+)|" + emG + "|([!-\\[\\]---]" + emq + "*|[\ud800-\udbff][\udc00-\udfff]" + emq + "*|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5|(\\\\[a-zA-Z@]+)" + emU + "*|\\\\[^\ud800-\udfff])", emY = class {
	static {
		h(this, "Lexer");
	}
	constructor(e, t) {
		this.input = void 0, this.settings = void 0, this.tokenRegex = void 0, this.catcodes = void 0, this.input = e, this.settings = t, this.tokenRegex = RegExp(emW, "g"), this.catcodes = {
			"%": 14,
			"~": 13
		};
	}
	setCatcode(e, t) {
		this.catcodes[e] = t;
	}
	lex() {
		var e = this.input, t = this.tokenRegex.lastIndex;
		if (t === e.length) return new edv("EOF", new edy(this, t, t));
		var r = this.tokenRegex.exec(e);
		if (null === r || r.index !== t) throw new edx("Unexpected character: '" + e[t] + "'", new edv(e[t], new edy(this, t, t + 1)));
		var i = r[6] || r[3] || (r[2] ? "\\ " : " ");
		if (14 === this.catcodes[i]) {
			var n = e.indexOf(`
`, this.tokenRegex.lastIndex);
			return -1 === n ? (this.tokenRegex.lastIndex = e.length, this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)")) : this.tokenRegex.lastIndex = n + 1, this.lex();
		}
		return new edv(i, new edy(this, t, this.tokenRegex.lastIndex));
	}
}, emV = class {
	static {
		h(this, "Namespace");
	}
	constructor(e, t) {
		void 0 === e && (e = {}), void 0 === t && (t = {}), this.current = void 0, this.builtins = void 0, this.undefStack = void 0, this.current = t, this.builtins = e, this.undefStack = [];
	}
	beginGroup() {
		this.undefStack.push({});
	}
	endGroup() {
		if (0 === this.undefStack.length) throw new edx("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
		var e = this.undefStack.pop();
		for (var t in e) e.hasOwnProperty(t) && (null == e[t] ? delete this.current[t] : this.current[t] = e[t]);
	}
	endGroups() {
		for (; this.undefStack.length > 0;) this.endGroup();
	}
	has(e) {
		return this.current.hasOwnProperty(e) || this.builtins.hasOwnProperty(e);
	}
	get(e) {
		return this.current.hasOwnProperty(e) ? this.current[e] : this.builtins[e];
	}
	set(e, t, r) {
		if (void 0 === r && (r = !1), r) {
			for (var i = 0; i < this.undefStack.length; i++) delete this.undefStack[i][e];
			this.undefStack.length > 0 && (this.undefStack[this.undefStack.length - 1][e] = t);
		} else {
			var n = this.undefStack[this.undefStack.length - 1];
			n && !n.hasOwnProperty(e) && (n[e] = this.current[e]);
		}
		null == t ? delete this.current[e] : this.current[e] = t;
	}
};
eg8("\\noexpand", function(e) {
	var t = e.popToken();
	return e.isExpandable(t.text) && (t.noexpand = !0, t.treatAsRelax = !0), {
		tokens: [t],
		numArgs: 0
	};
}), eg8("\\expandafter", function(e) {
	var t = e.popToken();
	return e.expandOnce(!0), {
		tokens: [t],
		numArgs: 0
	};
}), eg8("\\@firstoftwo", function(e) {
	return {
		tokens: e.consumeArgs(2)[0],
		numArgs: 0
	};
}), eg8("\\@secondoftwo", function(e) {
	return {
		tokens: e.consumeArgs(2)[1],
		numArgs: 0
	};
}), eg8("\\@ifnextchar", function(e) {
	var t = e.consumeArgs(3);
	e.consumeSpaces();
	var r = e.future();
	return 1 === t[0].length && t[0][0].text === r.text ? {
		tokens: t[1],
		numArgs: 0
	} : {
		tokens: t[2],
		numArgs: 0
	};
}), eg8("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}"), eg8("\\TextOrMath", function(e) {
	var t = e.consumeArgs(2);
	return "text" === e.mode ? {
		tokens: t[0],
		numArgs: 0
	} : {
		tokens: t[1],
		numArgs: 0
	};
});
var emH = {
	0: 0,
	1: 1,
	2: 2,
	3: 3,
	4: 4,
	5: 5,
	6: 6,
	7: 7,
	8: 8,
	9: 9,
	a: 10,
	A: 10,
	b: 11,
	B: 11,
	c: 12,
	C: 12,
	d: 13,
	D: 13,
	e: 14,
	E: 14,
	f: 15,
	F: 15
};
eg8("\\char", function(e) {
	var t, r, i = e.popToken(), n = "";
	if ("'" === i.text) r = 8, i = e.popToken();
	else if ("\"" === i.text) r = 16, i = e.popToken();
	else if ("`" === i.text) if ("\\" === (i = e.popToken()).text[0]) n = i.text.charCodeAt(1);
	else {
		if ("EOF" === i.text) throw new edx("\\char` missing argument");
		n = i.text.charCodeAt(0);
	}
	else r = 10;
	if (r) {
		if (null == (n = emH[i.text]) || n >= r) throw new edx("Invalid base-" + r + " digit " + i.text);
		for (; null != (t = emH[e.future().text]) && t < r;) n *= r, n += t, e.popToken();
	}
	return "\\@char{" + n + "}";
});
var emX = h((e, t, r, i) => {
	var n = e.consumeArg().tokens;
	if (1 !== n.length) throw new edx("\\newcommand's first argument must be a macro name");
	var a = n[0].text, s = e.isDefined(a);
	if (s && !t) throw new edx("\\newcommand{" + a + "} attempting to redefine " + a + "; use \\renewcommand");
	if (!s && !r) throw new edx("\\renewcommand{" + a + "} when command " + a + " does not yet exist; use \\newcommand");
	var o = 0;
	if (1 === (n = e.consumeArg().tokens).length && "[" === n[0].text) {
		for (var l = "", h = e.expandNextToken(); "]" !== h.text && "EOF" !== h.text;) l += h.text, h = e.expandNextToken();
		if (!l.match(/^\s*[0-9]+\s*$/)) throw new edx("Invalid number of arguments: " + l);
		o = parseInt(l), n = e.consumeArg().tokens;
	}
	return s && i || e.macros.set(a, {
		tokens: n,
		numArgs: o
	}), "";
}, "newcommand");
eg8("\\newcommand", (e) => emX(e, !1, !0, !1)), eg8("\\renewcommand", (e) => emX(e, !0, !1, !1)), eg8("\\providecommand", (e) => emX(e, !0, !0, !0)), eg8("\\message", (e) => (console.log(e.consumeArgs(1)[0].reverse().map((e) => e.text).join("")), "")), eg8("\\errmessage", (e) => (console.error(e.consumeArgs(1)[0].reverse().map((e) => e.text).join("")), "")), eg8("\\show", (e) => {
	var t = e.popToken(), r = t.text;
	return console.log(t, e.macros.get(r), efE[r], epA.math[r], epA.text[r]), "";
}), eg8("\\bgroup", "{"), eg8("\\egroup", "}"), eg8("~", "\\nobreakspace"), eg8("\\lq", "`"), eg8("\\rq", "'"), eg8("\\aa", "\\r a"), eg8("\\AA", "\\r A"), eg8("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`}"), eg8("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}"), eg8("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`}"), eg8("", "\\mathscr{B}"), eg8("", "\\mathscr{E}"), eg8("", "\\mathscr{F}"), eg8("", "\\mathscr{H}"), eg8("", "\\mathscr{I}"), eg8("", "\\mathscr{L}"), eg8("", "\\mathscr{M}"), eg8("", "\\mathscr{R}"), eg8("", "\\mathfrak{C}"), eg8("", "\\mathfrak{H}"), eg8("", "\\mathfrak{Z}"), eg8("\\Bbbk", "\\Bbb{k}"), eg8("", "\\cdotp"), eg8("\\llap", "\\mathllap{\\textrm{#1}}"), eg8("\\rlap", "\\mathrlap{\\textrm{#1}}"), eg8("\\clap", "\\mathclap{\\textrm{#1}}"), eg8("\\mathstrut", "\\vphantom{(}"), eg8("\\underbar", "\\underline{\\text{#1}}"), eg8("\\not", "\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char\"338}"), eg8("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`}}"), eg8("\\ne", "\\neq"), eg8("", "\\neq"), eg8("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`}}"), eg8("", "\\notin"), eg8("", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`}}"), eg8("", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`}}"), eg8("", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`}}"), eg8("", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`}}"), eg8("", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`}}"), eg8("", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`}}"), eg8("", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`}}"), eg8("", "\\perp"), eg8("", "\\mathclose{!\\mkern-0.8mu!}"), eg8("", "\\notni"), eg8("", "\\ulcorner"), eg8("", "\\urcorner"), eg8("", "\\llcorner"), eg8("", "\\lrcorner"), eg8("", "\\copyright"), eg8("", "\\textregistered"), eg8("", "\\textregistered"), eg8("\\ulcorner", "\\html@mathml{\\@ulcorner}{\\mathop{\\char\"231c}}"), eg8("\\urcorner", "\\html@mathml{\\@urcorner}{\\mathop{\\char\"231d}}"), eg8("\\llcorner", "\\html@mathml{\\@llcorner}{\\mathop{\\char\"231e}}"), eg8("\\lrcorner", "\\html@mathml{\\@lrcorner}{\\mathop{\\char\"231f}}"), eg8("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}"), eg8("", "\\vdots"), eg8("\\varGamma", "\\mathit{\\Gamma}"), eg8("\\varDelta", "\\mathit{\\Delta}"), eg8("\\varTheta", "\\mathit{\\Theta}"), eg8("\\varLambda", "\\mathit{\\Lambda}"), eg8("\\varXi", "\\mathit{\\Xi}"), eg8("\\varPi", "\\mathit{\\Pi}"), eg8("\\varSigma", "\\mathit{\\Sigma}"), eg8("\\varUpsilon", "\\mathit{\\Upsilon}"), eg8("\\varPhi", "\\mathit{\\Phi}"), eg8("\\varPsi", "\\mathit{\\Psi}"), eg8("\\varOmega", "\\mathit{\\Omega}"), eg8("\\substack", "\\begin{subarray}{c}#1\\end{subarray}"), eg8("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax"), eg8("\\boxed", "\\fbox{$\\displaystyle{#1}$}"), eg8("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;"), eg8("\\implies", "\\DOTSB\\;\\Longrightarrow\\;"), eg8("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;"), eg8("\\dddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ...}}{#1}}"), eg8("\\ddddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ....}}{#1}}");
var emK = {
	",": "\\dotsc",
	"\\not": "\\dotsb",
	"+": "\\dotsb",
	"=": "\\dotsb",
	"<": "\\dotsb",
	">": "\\dotsb",
	"-": "\\dotsb",
	"*": "\\dotsb",
	":": "\\dotsb",
	"\\DOTSB": "\\dotsb",
	"\\coprod": "\\dotsb",
	"\\bigvee": "\\dotsb",
	"\\bigwedge": "\\dotsb",
	"\\biguplus": "\\dotsb",
	"\\bigcap": "\\dotsb",
	"\\bigcup": "\\dotsb",
	"\\prod": "\\dotsb",
	"\\sum": "\\dotsb",
	"\\bigotimes": "\\dotsb",
	"\\bigoplus": "\\dotsb",
	"\\bigodot": "\\dotsb",
	"\\bigsqcup": "\\dotsb",
	"\\And": "\\dotsb",
	"\\longrightarrow": "\\dotsb",
	"\\Longrightarrow": "\\dotsb",
	"\\longleftarrow": "\\dotsb",
	"\\Longleftarrow": "\\dotsb",
	"\\longleftrightarrow": "\\dotsb",
	"\\Longleftrightarrow": "\\dotsb",
	"\\mapsto": "\\dotsb",
	"\\longmapsto": "\\dotsb",
	"\\hookrightarrow": "\\dotsb",
	"\\doteq": "\\dotsb",
	"\\mathbin": "\\dotsb",
	"\\mathrel": "\\dotsb",
	"\\relbar": "\\dotsb",
	"\\Relbar": "\\dotsb",
	"\\xrightarrow": "\\dotsb",
	"\\xleftarrow": "\\dotsb",
	"\\DOTSI": "\\dotsi",
	"\\int": "\\dotsi",
	"\\oint": "\\dotsi",
	"\\iint": "\\dotsi",
	"\\iiint": "\\dotsi",
	"\\iiiint": "\\dotsi",
	"\\idotsint": "\\dotsi",
	"\\DOTSX": "\\dotsx"
};
eg8("\\dots", function(e) {
	var t = "\\dotso", r = e.expandAfterFuture().text;
	return r in emK ? t = emK[r] : ("\\not" === r.slice(0, 4) || r in epA.math && edR.contains(["bin", "rel"], epA.math[r].group)) && (t = "\\dotsb"), t;
});
var emZ = {
	")": !0,
	"]": !0,
	"\\rbrack": !0,
	"\\}": !0,
	"\\rbrace": !0,
	"\\rangle": !0,
	"\\rceil": !0,
	"\\rfloor": !0,
	"\\rgroup": !0,
	"\\rmoustache": !0,
	"\\right": !0,
	"\\bigr": !0,
	"\\biggr": !0,
	"\\Bigr": !0,
	"\\Biggr": !0,
	$: !0,
	";": !0,
	".": !0,
	",": !0
};
eg8("\\dotso", function(e) {
	return e.future().text in emZ ? "\\ldots\\," : "\\ldots";
}), eg8("\\dotsc", function(e) {
	var t = e.future().text;
	return t in emZ && "," !== t ? "\\ldots\\," : "\\ldots";
}), eg8("\\cdots", function(e) {
	return e.future().text in emZ ? "\\@cdots\\," : "\\@cdots";
}), eg8("\\dotsb", "\\cdots"), eg8("\\dotsm", "\\cdots"), eg8("\\dotsi", "\\!\\cdots"), eg8("\\dotsx", "\\ldots\\,"), eg8("\\DOTSI", "\\relax"), eg8("\\DOTSB", "\\relax"), eg8("\\DOTSX", "\\relax"), eg8("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax"), eg8("\\,", "\\tmspace+{3mu}{.1667em}"), eg8("\\thinspace", "\\,"), eg8("\\>", "\\mskip{4mu}"), eg8("\\:", "\\tmspace+{4mu}{.2222em}"), eg8("\\medspace", "\\:"), eg8("\\;", "\\tmspace+{5mu}{.2777em}"), eg8("\\thickspace", "\\;"), eg8("\\!", "\\tmspace-{3mu}{.1667em}"), eg8("\\negthinspace", "\\!"), eg8("\\negmedspace", "\\tmspace-{4mu}{.2222em}"), eg8("\\negthickspace", "\\tmspace-{5mu}{.277em}"), eg8("\\enspace", "\\kern.5em "), eg8("\\enskip", "\\hskip.5em\\relax"), eg8("\\quad", "\\hskip1em\\relax"), eg8("\\qquad", "\\hskip2em\\relax"), eg8("\\tag", "\\@ifstar\\tag@literal\\tag@paren"), eg8("\\tag@paren", "\\tag@literal{({#1})}"), eg8("\\tag@literal", (e) => {
	if (e.macros.get("\\df@tag")) throw new edx("Multiple \\tag");
	return "\\gdef\\df@tag{\\text{#1}}";
}), eg8("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}"), eg8("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)"), eg8("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}"), eg8("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1"), eg8("\\newline", "\\\\\\relax"), eg8("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
var emQ = eph(ed3["Main-Regular"][84][1] - .7 * ed3["Main-Regular"][65][1]);
eg8("\\LaTeX", "\\textrm{\\html@mathml{L\\kern-.36em\\raisebox{" + emQ + "}{\\scriptstyle A}\\kern-.15em\\TeX}{LaTeX}}"), eg8("\\KaTeX", "\\textrm{\\html@mathml{K\\kern-.17em\\raisebox{" + emQ + "}{\\scriptstyle A}\\kern-.15em\\TeX}{KaTeX}}"), eg8("\\hspace", "\\@ifstar\\@hspacer\\@hspace"), eg8("\\@hspace", "\\hskip #1\\relax"), eg8("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax"), eg8("\\ordinarycolon", ":"), eg8("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}"), eg8("\\dblcolon", "\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char\"2237}}"), eg8("\\coloneqq", "\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char\"2254}}"), eg8("\\Coloneqq", "\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char\"2237\\char\"3d}}"), eg8("\\coloneq", "\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char\"3a\\char\"2212}}"), eg8("\\Coloneq", "\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char\"2237\\char\"2212}}"), eg8("\\eqqcolon", "\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char\"2255}}"), eg8("\\Eqqcolon", "\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char\"3d\\char\"2237}}"), eg8("\\eqcolon", "\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char\"2239}}"), eg8("\\Eqcolon", "\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char\"2212\\char\"2237}}"), eg8("\\colonapprox", "\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char\"3a\\char\"2248}}"), eg8("\\Colonapprox", "\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char\"2237\\char\"2248}}"), eg8("\\colonsim", "\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char\"3a\\char\"223c}}"), eg8("\\Colonsim", "\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char\"2237\\char\"223c}}"), eg8("", "\\dblcolon"), eg8("", "\\eqcolon"), eg8("", "\\coloneqq"), eg8("", "\\eqqcolon"), eg8("", "\\Coloneqq"), eg8("\\ratio", "\\vcentcolon"), eg8("\\coloncolon", "\\dblcolon"), eg8("\\colonequals", "\\coloneqq"), eg8("\\coloncolonequals", "\\Coloneqq"), eg8("\\equalscolon", "\\eqqcolon"), eg8("\\equalscoloncolon", "\\Eqqcolon"), eg8("\\colonminus", "\\coloneq"), eg8("\\coloncolonminus", "\\Coloneq"), eg8("\\minuscolon", "\\eqcolon"), eg8("\\minuscoloncolon", "\\Eqcolon"), eg8("\\coloncolonapprox", "\\Colonapprox"), eg8("\\coloncolonsim", "\\Colonsim"), eg8("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}"), eg8("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}"), eg8("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}"), eg8("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}"), eg8("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`}}"), eg8("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}"), eg8("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}"), eg8("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}"), eg8("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}"), eg8("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}"), eg8("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}"), eg8("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}"), eg8("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}"), eg8("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{}"), eg8("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{}"), eg8("\\ngeqq", "\\html@mathml{\\@ngeqq}{}"), eg8("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{}"), eg8("\\nleqq", "\\html@mathml{\\@nleqq}{}"), eg8("\\nleqslant", "\\html@mathml{\\@nleqslant}{}"), eg8("\\nshortmid", "\\html@mathml{\\@nshortmid}{}"), eg8("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{}"), eg8("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{}"), eg8("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{}"), eg8("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{}"), eg8("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{}"), eg8("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{}"), eg8("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{}"), eg8("\\imath", "\\html@mathml{\\@imath}{}"), eg8("\\jmath", "\\html@mathml{\\@jmath}{}"), eg8("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`}}"), eg8("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`}}"), eg8("", "\\llbracket"), eg8("", "\\rrbracket"), eg8("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`}}"), eg8("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`}}"), eg8("", "\\lBrace"), eg8("", "\\rBrace"), eg8("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`}}"), eg8("", "\\minuso"), eg8("\\darr", "\\downarrow"), eg8("\\dArr", "\\Downarrow"), eg8("\\Darr", "\\Downarrow"), eg8("\\lang", "\\langle"), eg8("\\rang", "\\rangle"), eg8("\\uarr", "\\uparrow"), eg8("\\uArr", "\\Uparrow"), eg8("\\Uarr", "\\Uparrow"), eg8("\\N", "\\mathbb{N}"), eg8("\\R", "\\mathbb{R}"), eg8("\\Z", "\\mathbb{Z}"), eg8("\\alef", "\\aleph"), eg8("\\alefsym", "\\aleph"), eg8("\\Alpha", "\\mathrm{A}"), eg8("\\Beta", "\\mathrm{B}"), eg8("\\bull", "\\bullet"), eg8("\\Chi", "\\mathrm{X}"), eg8("\\clubs", "\\clubsuit"), eg8("\\cnums", "\\mathbb{C}"), eg8("\\Complex", "\\mathbb{C}"), eg8("\\Dagger", "\\ddagger"), eg8("\\diamonds", "\\diamondsuit"), eg8("\\empty", "\\emptyset"), eg8("\\Epsilon", "\\mathrm{E}"), eg8("\\Eta", "\\mathrm{H}"), eg8("\\exist", "\\exists"), eg8("\\harr", "\\leftrightarrow"), eg8("\\hArr", "\\Leftrightarrow"), eg8("\\Harr", "\\Leftrightarrow"), eg8("\\hearts", "\\heartsuit"), eg8("\\image", "\\Im"), eg8("\\infin", "\\infty"), eg8("\\Iota", "\\mathrm{I}"), eg8("\\isin", "\\in"), eg8("\\Kappa", "\\mathrm{K}"), eg8("\\larr", "\\leftarrow"), eg8("\\lArr", "\\Leftarrow"), eg8("\\Larr", "\\Leftarrow"), eg8("\\lrarr", "\\leftrightarrow"), eg8("\\lrArr", "\\Leftrightarrow"), eg8("\\Lrarr", "\\Leftrightarrow"), eg8("\\Mu", "\\mathrm{M}"), eg8("\\natnums", "\\mathbb{N}"), eg8("\\Nu", "\\mathrm{N}"), eg8("\\Omicron", "\\mathrm{O}"), eg8("\\plusmn", "\\pm"), eg8("\\rarr", "\\rightarrow"), eg8("\\rArr", "\\Rightarrow"), eg8("\\Rarr", "\\Rightarrow"), eg8("\\real", "\\Re"), eg8("\\reals", "\\mathbb{R}"), eg8("\\Reals", "\\mathbb{R}"), eg8("\\Rho", "\\mathrm{P}"), eg8("\\sdot", "\\cdot"), eg8("\\sect", "\\S"), eg8("\\spades", "\\spadesuit"), eg8("\\sub", "\\subset"), eg8("\\sube", "\\subseteq"), eg8("\\supe", "\\supseteq"), eg8("\\Tau", "\\mathrm{T}"), eg8("\\thetasym", "\\vartheta"), eg8("\\weierp", "\\wp"), eg8("\\Zeta", "\\mathrm{Z}"), eg8("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}"), eg8("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}"), eg8("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits"), eg8("\\bra", "\\mathinner{\\langle{#1}|}"), eg8("\\ket", "\\mathinner{|{#1}\\rangle}"), eg8("\\braket", "\\mathinner{\\langle{#1}\\rangle}"), eg8("\\Bra", "\\left\\langle#1\\right|"), eg8("\\Ket", "\\left|#1\\right\\rangle");
var emJ = h((e) => (t) => {
	var r = t.consumeArg().tokens, i = t.consumeArg().tokens, n = t.consumeArg().tokens, a = t.consumeArg().tokens, s = t.macros.get("|"), o = t.macros.get("\\|");
	t.macros.beginGroup();
	var l = h((t) => (r) => {
		e && (r.macros.set("|", s), n.length && r.macros.set("\\|", o));
		var a = t;
		return !t && n.length && "|" === r.future().text && (r.popToken(), a = !0), {
			tokens: a ? n : i,
			numArgs: 0
		};
	}, "midMacro");
	t.macros.set("|", l(!1)), n.length && t.macros.set("\\|", l(!0));
	var u = t.consumeArg().tokens, d = t.expandTokens([
		...a,
		...u,
		...r
	]);
	return t.macros.endGroup(), {
		tokens: d.reverse(),
		numArgs: 0
	};
}, "braketHelper");
eg8("\\bra@ket", emJ(!1)), eg8("\\bra@set", emJ(!0)), eg8("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}"), eg8("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}"), eg8("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}"), eg8("\\angln", "{\\angl n}"), eg8("\\blue", "\\textcolor{##6495ed}{#1}"), eg8("\\orange", "\\textcolor{##ffa500}{#1}"), eg8("\\pink", "\\textcolor{##ff00af}{#1}"), eg8("\\red", "\\textcolor{##df0030}{#1}"), eg8("\\green", "\\textcolor{##28ae7b}{#1}"), eg8("\\gray", "\\textcolor{gray}{#1}"), eg8("\\purple", "\\textcolor{##9d38bd}{#1}"), eg8("\\blueA", "\\textcolor{##ccfaff}{#1}"), eg8("\\blueB", "\\textcolor{##80f6ff}{#1}"), eg8("\\blueC", "\\textcolor{##63d9ea}{#1}"), eg8("\\blueD", "\\textcolor{##11accd}{#1}"), eg8("\\blueE", "\\textcolor{##0c7f99}{#1}"), eg8("\\tealA", "\\textcolor{##94fff5}{#1}"), eg8("\\tealB", "\\textcolor{##26edd5}{#1}"), eg8("\\tealC", "\\textcolor{##01d1c1}{#1}"), eg8("\\tealD", "\\textcolor{##01a995}{#1}"), eg8("\\tealE", "\\textcolor{##208170}{#1}"), eg8("\\greenA", "\\textcolor{##b6ffb0}{#1}"), eg8("\\greenB", "\\textcolor{##8af281}{#1}"), eg8("\\greenC", "\\textcolor{##74cf70}{#1}"), eg8("\\greenD", "\\textcolor{##1fab54}{#1}"), eg8("\\greenE", "\\textcolor{##0d923f}{#1}"), eg8("\\goldA", "\\textcolor{##ffd0a9}{#1}"), eg8("\\goldB", "\\textcolor{##ffbb71}{#1}"), eg8("\\goldC", "\\textcolor{##ff9c39}{#1}"), eg8("\\goldD", "\\textcolor{##e07d10}{#1}"), eg8("\\goldE", "\\textcolor{##a75a05}{#1}"), eg8("\\redA", "\\textcolor{##fca9a9}{#1}"), eg8("\\redB", "\\textcolor{##ff8482}{#1}"), eg8("\\redC", "\\textcolor{##f9685d}{#1}"), eg8("\\redD", "\\textcolor{##e84d39}{#1}"), eg8("\\redE", "\\textcolor{##bc2612}{#1}"), eg8("\\maroonA", "\\textcolor{##ffbde0}{#1}"), eg8("\\maroonB", "\\textcolor{##ff92c6}{#1}"), eg8("\\maroonC", "\\textcolor{##ed5fa6}{#1}"), eg8("\\maroonD", "\\textcolor{##ca337c}{#1}"), eg8("\\maroonE", "\\textcolor{##9e034e}{#1}"), eg8("\\purpleA", "\\textcolor{##ddd7ff}{#1}"), eg8("\\purpleB", "\\textcolor{##c6b9fc}{#1}"), eg8("\\purpleC", "\\textcolor{##aa87ff}{#1}"), eg8("\\purpleD", "\\textcolor{##7854ab}{#1}"), eg8("\\purpleE", "\\textcolor{##543b78}{#1}"), eg8("\\mintA", "\\textcolor{##f5f9e8}{#1}"), eg8("\\mintB", "\\textcolor{##edf2df}{#1}"), eg8("\\mintC", "\\textcolor{##e0e5cc}{#1}"), eg8("\\grayA", "\\textcolor{##f6f7f7}{#1}"), eg8("\\grayB", "\\textcolor{##f0f1f2}{#1}"), eg8("\\grayC", "\\textcolor{##e3e5e6}{#1}"), eg8("\\grayD", "\\textcolor{##d6d8da}{#1}"), eg8("\\grayE", "\\textcolor{##babec2}{#1}"), eg8("\\grayF", "\\textcolor{##888d93}{#1}"), eg8("\\grayG", "\\textcolor{##626569}{#1}"), eg8("\\grayH", "\\textcolor{##3b3e40}{#1}"), eg8("\\grayI", "\\textcolor{##21242c}{#1}"), eg8("\\kaBlue", "\\textcolor{##314453}{#1}"), eg8("\\kaGreen", "\\textcolor{##71B307}{#1}");
var em0 = {
	"^": !0,
	_: !0,
	"\\limits": !0,
	"\\nolimits": !0
}, em1 = class {
	static {
		h(this, "MacroExpander");
	}
	constructor(e, t, r) {
		this.settings = void 0, this.expansionCount = void 0, this.lexer = void 0, this.macros = void 0, this.stack = void 0, this.mode = void 0, this.settings = t, this.expansionCount = 0, this.feed(e), this.macros = new emV(eg7, t.macros), this.mode = r, this.stack = [];
	}
	feed(e) {
		this.lexer = new emY(e, this.settings);
	}
	switchMode(e) {
		this.mode = e;
	}
	beginGroup() {
		this.macros.beginGroup();
	}
	endGroup() {
		this.macros.endGroup();
	}
	endGroups() {
		this.macros.endGroups();
	}
	future() {
		return 0 === this.stack.length && this.pushToken(this.lexer.lex()), this.stack[this.stack.length - 1];
	}
	popToken() {
		return this.future(), this.stack.pop();
	}
	pushToken(e) {
		this.stack.push(e);
	}
	pushTokens(e) {
		this.stack.push(...e);
	}
	scanArgument(e) {
		var t, r, i;
		if (e) {
			if (this.consumeSpaces(), "[" !== this.future().text) return null;
			t = this.popToken(), {tokens: i, end: r} = this.consumeArg(["]"]);
		} else ({tokens: i, start: t, end: r} = this.consumeArg());
		return this.pushToken(new edv("EOF", r.loc)), this.pushTokens(i), t.range(r, "");
	}
	consumeSpaces() {
		for (;;) if (" " === this.future().text) this.stack.pop();
		else break;
	}
	consumeArg(e) {
		var t = [], r = e && e.length > 0;
		r || this.consumeSpaces();
		var i, n = this.future(), a = 0, s = 0;
		do {
			if (i = this.popToken(), t.push(i), "{" === i.text) ++a;
			else if ("}" === i.text) {
				if (-1 == --a) throw new edx("Extra }", i);
			} else if ("EOF" === i.text) throw new edx("Unexpected end of input in a macro argument, expected '" + (e && r ? e[s] : "}") + "'", i);
			if (e && r) if ((0 === a || 1 === a && "{" === e[s]) && i.text === e[s]) {
				if (++s === e.length) {
					t.splice(-s, s);
					break;
				}
			} else s = 0;
		} while (0 !== a || r);
		return "{" === n.text && "}" === t[t.length - 1].text && (t.pop(), t.shift()), t.reverse(), {
			tokens: t,
			start: n,
			end: i
		};
	}
	consumeArgs(e, t) {
		if (t) {
			if (t.length !== e + 1) throw new edx("The length of delimiters doesn't match the number of args!");
			for (var r = t[0], i = 0; i < r.length; i++) {
				var n = this.popToken();
				if (r[i] !== n.text) throw new edx("Use of the macro doesn't match its definition", n);
			}
		}
		for (var a = [], s = 0; s < e; s++) a.push(this.consumeArg(t && t[s + 1]).tokens);
		return a;
	}
	countExpansion(e) {
		if (this.expansionCount += e, this.expansionCount > this.settings.maxExpand) throw new edx("Too many expansions: infinite loop or need to increase maxExpand setting");
	}
	expandOnce(e) {
		var t = this.popToken(), r = t.text, i = t.noexpand ? null : this._getExpansion(r);
		if (null == i || e && i.unexpandable) {
			if (e && null == i && "\\" === r[0] && !this.isDefined(r)) throw new edx("Undefined control sequence: " + r);
			return this.pushToken(t), !1;
		}
		this.countExpansion(1);
		var n = i.tokens, a = this.consumeArgs(i.numArgs, i.delimiters);
		if (i.numArgs) {
			n = n.slice();
			for (var s = n.length - 1; s >= 0; --s) {
				var o = n[s];
				if ("#" === o.text) {
					if (0 === s) throw new edx("Incomplete placeholder at end of macro body", o);
					if ("#" === (o = n[--s]).text) n.splice(s + 1, 1);
					else if (/^[1-9]$/.test(o.text)) n.splice(s, 2, ...a[o.text - 1]);
					else throw new edx("Not a valid argument number", o);
				}
			}
		}
		return this.pushTokens(n), n.length;
	}
	expandAfterFuture() {
		return this.expandOnce(), this.future();
	}
	expandNextToken() {
		for (;;) if (!1 === this.expandOnce()) {
			var e = this.stack.pop();
			return e.treatAsRelax && (e.text = "\\relax"), e;
		}
		throw Error();
	}
	expandMacro(e) {
		return this.macros.has(e) ? this.expandTokens([new edv(e)]) : void 0;
	}
	expandTokens(e) {
		var t = [], r = this.stack.length;
		for (this.pushTokens(e); this.stack.length > r;) if (!1 === this.expandOnce(!0)) {
			var i = this.stack.pop();
			i.treatAsRelax && (i.noexpand = !1, i.treatAsRelax = !1), t.push(i);
		}
		return this.countExpansion(t.length), t;
	}
	expandMacroAsText(e) {
		var t = this.expandMacro(e);
		return t && t.map((e) => e.text).join("");
	}
	_getExpansion(e) {
		var t = this.macros.get(e);
		if (null == t) return t;
		if (1 === e.length) {
			var r = this.lexer.catcodes[e];
			if (null != r && 13 !== r) return;
		}
		var i = "function" == typeof t ? t(this) : t;
		if ("string" == typeof i) {
			var n = 0;
			if (-1 !== i.indexOf("#")) for (var a = i.replace(/##/g, ""); -1 !== a.indexOf("#" + (n + 1));) ++n;
			for (var s = new emY(i, this.settings), o = [], l = s.lex(); "EOF" !== l.text;) o.push(l), l = s.lex();
			return o.reverse(), {
				tokens: o,
				numArgs: n
			};
		}
		return i;
	}
	isDefined(e) {
		return this.macros.has(e) || efE.hasOwnProperty(e) || epA.math.hasOwnProperty(e) || epA.text.hasOwnProperty(e) || em0.hasOwnProperty(e);
	}
	isExpandable(e) {
		var t = this.macros.get(e);
		return null != t ? "string" == typeof t || "function" == typeof t || !t.unexpandable : efE.hasOwnProperty(e) && !efE[e].primitive;
	}
}, em2 = /^[]/, em4 = Object.freeze({
	"": "+",
	"": "-",
	"": "=",
	"": "(",
	"": ")",
	"": "0",
	"": "1",
	"": "2",
	"": "3",
	"": "4",
	"": "5",
	"": "6",
	"": "7",
	"": "8",
	"": "9",
	: "a",
	: "e",
	: "h",
	: "i",
	: "j",
	: "k",
	: "l",
	: "m",
	: "n",
	: "o",
	: "p",
	: "r",
	: "s",
	: "t",
	: "u",
	: "v",
	: "x",
	: "",
	: "",
	: "",
	: "",
	: "",
	"": "+",
	"": "-",
	"": "=",
	"": "(",
	"": ")",
	"": "0",
	"": "1",
	"": "2",
	"": "3",
	"": "4",
	"": "5",
	"": "6",
	"": "7",
	"": "8",
	"": "9",
	: "A",
	: "B",
	: "D",
	: "E",
	: "G",
	: "H",
	: "I",
	: "J",
	: "K",
	: "L",
	: "M",
	: "N",
	: "O",
	: "P",
	: "R",
	: "T",
	: "U",
	: "V",
	: "W",
	: "a",
	: "b",
	: "c",
	: "d",
	: "e",
	: "f",
	: "g",
	: "h",
	: "i",
	: "j",
	: "k",
	: "l",
	: "m",
	: "n",
	: "o",
	: "p",
	: "r",
	: "s",
	: "t",
	: "u",
	: "v",
	: "w",
	: "x",
	: "y",
	: "z",
	: "",
	: "",
	: "",
	: "",
	: "",
	: ""
}), em5 = {
	"": {
		text: "\\'",
		math: "\\acute"
	},
	"": {
		text: "\\`",
		math: "\\grave"
	},
	"": {
		text: "\\\"",
		math: "\\ddot"
	},
	"": {
		text: "\\~",
		math: "\\tilde"
	},
	"": {
		text: "\\=",
		math: "\\bar"
	},
	"": {
		text: "\\u",
		math: "\\breve"
	},
	"": {
		text: "\\v",
		math: "\\check"
	},
	"": {
		text: "\\^",
		math: "\\hat"
	},
	"": {
		text: "\\.",
		math: "\\dot"
	},
	"": {
		text: "\\r",
		math: "\\mathring"
	},
	"": { text: "\\H" },
	"": { text: "\\c" }
}, em3 = {
	: "a",
	: "a",
	: "a",
	: "a",
	: "a",
	: "a",
	: "a",
	: "a",
	: "a",
	: "a",
	: "a",
	: "a",
	: "a",
	: "a",
	: "a",
	: "a",
	: "a",
	: "a",
	: "a",
	: "b",
	: "c",
	: "c",
	: "c",
	: "c",
	: "c",
	: "c",
	: "d",
	: "d",
	: "d",
	: "e",
	: "e",
	: "e",
	: "e",
	: "e",
	: "e",
	: "e",
	: "e",
	: "e",
	: "e",
	: "e",
	: "e",
	: "e",
	: "e",
	: "e",
	: "e",
	: "f",
	: "g",
	: "g",
	: "g",
	: "g",
	: "g",
	: "g",
	: "g",
	: "h",
	: "h",
	: "h",
	: "h",
	: "h",
	: "i",
	: "i",
	: "i",
	: "i",
	: "i",
	: "i",
	: "i",
	: "i",
	: "i",
	: "j",
	: "j",
	: "k",
	: "k",
	: "k",
	: "l",
	: "l",
	: "l",
	: "m",
	: "m",
	: "n",
	: "n",
	: "n",
	: "n",
	: "n",
	: "n",
	: "o",
	: "o",
	: "o",
	: "o",
	: "o",
	: "o",
	: "o",
	: "o",
	: "o",
	: "o",
	: "o",
	: "o",
	: "o",
	: "o",
	: "o",
	: "o",
	: "o",
	: "o",
	: "o",
	: "o",
	: "p",
	: "p",
	: "r",
	: "r",
	: "r",
	: "r",
	: "s",
	: "s",
	: "s",
	: "s",
	: "s",
	: "s",
	: "s",
	: "t",
	: "t",
	: "t",
	: "t",
	: "u",
	: "u",
	: "u",
	: "u",
	: "u",
	: "u",
	: "u",
	: "u",
	: "u",
	: "u",
	: "u",
	: "u",
	: "u",
	: "u",
	: "u",
	: "u",
	: "v",
	: "w",
	: "w",
	: "w",
	: "w",
	: "w",
	: "w",
	: "x",
	: "x",
	: "y",
	: "y",
	: "y",
	: "y",
	: "y",
	: "y",
	: "y",
	: "y",
	: "z",
	: "z",
	: "z",
	: "z",
	: "A",
	: "A",
	: "A",
	: "A",
	: "A",
	: "A",
	: "A",
	: "A",
	: "A",
	: "A",
	: "A",
	: "A",
	: "A",
	: "A",
	: "A",
	: "A",
	: "A",
	: "A",
	: "A",
	: "B",
	: "C",
	: "C",
	: "C",
	: "C",
	: "C",
	: "C",
	: "D",
	: "D",
	: "D",
	: "E",
	: "E",
	: "E",
	: "E",
	: "E",
	: "E",
	: "E",
	: "E",
	: "E",
	: "E",
	: "E",
	: "E",
	: "E",
	: "E",
	: "E",
	: "E",
	: "F",
	: "G",
	: "G",
	: "G",
	: "G",
	: "G",
	: "G",
	: "G",
	: "H",
	: "H",
	: "H",
	: "H",
	: "H",
	: "I",
	: "I",
	: "I",
	: "I",
	: "I",
	: "I",
	: "I",
	: "I",
	: "I",
	: "I",
	: "J",
	: "K",
	: "K",
	: "K",
	: "L",
	: "L",
	: "L",
	: "M",
	: "M",
	: "N",
	: "N",
	: "N",
	: "N",
	: "N",
	: "N",
	: "O",
	: "O",
	: "O",
	: "O",
	: "O",
	: "O",
	: "O",
	: "O",
	: "O",
	: "O",
	: "O",
	: "O",
	: "O",
	: "O",
	: "O",
	: "O",
	: "O",
	: "O",
	: "O",
	: "O",
	: "P",
	: "P",
	: "R",
	: "R",
	: "R",
	: "R",
	: "S",
	: "S",
	: "S",
	: "S",
	: "S",
	: "S",
	: "S",
	: "T",
	: "T",
	: "T",
	: "U",
	: "U",
	: "U",
	: "U",
	: "U",
	: "U",
	: "U",
	: "U",
	: "U",
	: "U",
	: "U",
	: "U",
	: "U",
	: "U",
	: "U",
	: "U",
	: "V",
	: "W",
	: "W",
	: "W",
	: "W",
	: "W",
	: "X",
	: "X",
	: "Y",
	: "Y",
	: "Y",
	: "Y",
	: "Y",
	: "Y",
	: "Y",
	: "Z",
	: "Z",
	: "Z",
	: "Z",
	: "",
	: "",
	: "",
	: "",
	: "",
	: "",
	: "",
	: "",
	: "",
	: "",
	: "",
	: "",
	: "",
	: "",
	: "",
	: "",
	: "",
	: "",
	: "",
	: "",
	: "",
	: "",
	: "",
	: "",
	: "",
	: "",
	: "",
	: "",
	: "",
	: "",
	: "",
	: "",
	: ""
}, em6 = class e {
	static {
		h(this, "Parser");
	}
	constructor(e, t) {
		this.mode = void 0, this.gullet = void 0, this.settings = void 0, this.leftrightDepth = void 0, this.nextToken = void 0, this.mode = "math", this.gullet = new em1(e, t, this.mode), this.settings = t, this.leftrightDepth = 0;
	}
	expect(e, t) {
		if (void 0 === t && (t = !0), this.fetch().text !== e) throw new edx("Expected '" + e + "', got '" + this.fetch().text + "'", this.fetch());
		t && this.consume();
	}
	consume() {
		this.nextToken = null;
	}
	fetch() {
		return this.nextToken ??= this.gullet.expandNextToken(), this.nextToken;
	}
	switchMode(e) {
		this.mode = e, this.gullet.switchMode(e);
	}
	parse() {
		this.settings.globalGroup || this.gullet.beginGroup(), this.settings.colorIsTextColor && this.gullet.macros.set("\\color", "\\textcolor");
		try {
			var e = this.parseExpression(!1);
			return this.expect("EOF"), this.settings.globalGroup || this.gullet.endGroup(), e;
		} finally {
			this.gullet.endGroups();
		}
	}
	subparse(e) {
		var t = this.nextToken;
		this.consume(), this.gullet.pushToken(new edv("}")), this.gullet.pushTokens(e);
		var r = this.parseExpression(!1);
		return this.expect("}"), this.nextToken = t, r;
	}
	parseExpression(t, r) {
		for (var i = [];;) {
			"math" === this.mode && this.consumeSpaces();
			var n = this.fetch();
			if (-1 !== e.endOfExpression.indexOf(n.text) || r && n.text === r || t && efE[n.text] && efE[n.text].infix) break;
			var a = this.parseAtom(r);
			if (a) {
				if ("internal" === a.type) continue;
			} else break;
			i.push(a);
		}
		return "text" === this.mode && this.formLigatures(i), this.handleInfixNodes(i);
	}
	handleInfixNodes(e) {
		for (var t, r = -1, i = 0; i < e.length; i++) if ("infix" === e[i].type) {
			if (-1 !== r) throw new edx("only one infix operator per group", e[i].token);
			r = i, t = e[i].replaceWith;
		}
		if (-1 === r || !t) return e;
		var n, a, s = e.slice(0, r), o = e.slice(r + 1);
		return n = 1 === s.length && "ordgroup" === s[0].type ? s[0] : {
			type: "ordgroup",
			mode: this.mode,
			body: s
		}, a = 1 === o.length && "ordgroup" === o[0].type ? o[0] : {
			type: "ordgroup",
			mode: this.mode,
			body: o
		}, ["\\\\abovefrac" === t ? this.callFunction(t, [
			n,
			e[r],
			a
		], []) : this.callFunction(t, [n, a], [])];
	}
	handleSupSubscript(e) {
		var t, r = this.fetch(), i = r.text;
		this.consume(), this.consumeSpaces();
		do
			t = this.parseGroup(e);
		while ((null == t ? void 0 : t.type) === "internal");
		if (!t) throw new edx("Expected group after '" + i + "'", r);
		return t;
	}
	formatUnsupportedCmd(e) {
		for (var t = [], r = 0; r < e.length; r++) t.push({
			type: "textord",
			mode: "text",
			text: e[r]
		});
		var i = {
			type: "text",
			mode: this.mode,
			body: t
		};
		return {
			type: "color",
			mode: this.mode,
			color: this.settings.errorColor,
			body: [i]
		};
	}
	parseAtom(e) {
		var t, r, i = this.parseGroup("atom", e);
		if (i?.type === "internal" || "text" === this.mode) return i;
		for (;;) {
			this.consumeSpaces();
			var n = this.fetch();
			if ("\\limits" === n.text || "\\nolimits" === n.text) {
				if (i && "op" === i.type) i.limits = "\\limits" === n.text, i.alwaysHandleSupSub = !0;
				else if (i && "operatorname" === i.type) i.alwaysHandleSupSub && (i.limits = "\\limits" === n.text);
				else throw new edx("Limit controls must follow a math operator", n);
				this.consume();
			} else if ("^" === n.text) {
				if (t) throw new edx("Double superscript", n);
				t = this.handleSupSubscript("superscript");
			} else if ("_" === n.text) {
				if (r) throw new edx("Double subscript", n);
				r = this.handleSupSubscript("subscript");
			} else if ("'" === n.text) {
				if (t) throw new edx("Double superscript", n);
				var a = {
					type: "textord",
					mode: this.mode,
					text: "\\prime"
				}, s = [a];
				for (this.consume(); "'" === this.fetch().text;) s.push(a), this.consume();
				"^" === this.fetch().text && s.push(this.handleSupSubscript("superscript")), t = {
					type: "ordgroup",
					mode: this.mode,
					body: s
				};
			} else if (em4[n.text]) {
				var o = em2.test(n.text), l = [];
				for (l.push(new edv(em4[n.text])), this.consume();;) {
					var h = this.fetch().text;
					if (!em4[h] || em2.test(h) !== o) break;
					l.unshift(new edv(em4[h])), this.consume();
				}
				var u = this.subparse(l);
				o ? r = {
					type: "ordgroup",
					mode: "math",
					body: u
				} : t = {
					type: "ordgroup",
					mode: "math",
					body: u
				};
			} else break;
		}
		return t || r ? {
			type: "supsub",
			mode: this.mode,
			base: i,
			sup: t,
			sub: r
		} : i;
	}
	parseFunction(e, t) {
		var r = this.fetch(), i = r.text, n = efE[i];
		if (!n) return null;
		if (this.consume(), t && "atom" !== t && !n.allowedInArgument) throw new edx("Got function '" + i + "' with no arguments" + (t ? " as " + t : ""), r);
		if ("text" === this.mode && !n.allowedInText) throw new edx("Can't use function '" + i + "' in text mode", r);
		if ("math" === this.mode && !1 === n.allowedInMath) throw new edx("Can't use function '" + i + "' in math mode", r);
		var { args: a, optArgs: s } = this.parseArguments(i, n);
		return this.callFunction(i, a, s, r, e);
	}
	callFunction(e, t, r, i, n) {
		var a = efE[e];
		if (a && a.handler) return a.handler({
			funcName: e,
			parser: this,
			token: i,
			breakOnTokenText: n
		}, t, r);
		throw new edx("No function handler for " + e);
	}
	parseArguments(e, t) {
		var r = t.numArgs + t.numOptionalArgs;
		if (0 === r) return {
			args: [],
			optArgs: []
		};
		for (var i = [], n = [], a = 0; a < r; a++) {
			var s = t.argTypes && t.argTypes[a], o = a < t.numOptionalArgs;
			(t.primitive && null == s || "sqrt" === t.type && 1 === a && null == n[0]) && (s = "primitive");
			var l = this.parseGroupOfType("argument to '" + e + "'", s, o);
			if (o) n.push(l);
			else if (null != l) i.push(l);
			else throw new edx("Null argument, please report this as a bug");
		}
		return {
			args: i,
			optArgs: n
		};
	}
	parseGroupOfType(e, t, r) {
		switch (t) {
			case "color": return this.parseColorGroup(r);
			case "size": return this.parseSizeGroup(r);
			case "url": return this.parseUrlGroup(r);
			case "math":
			case "text": return this.parseArgumentGroup(r, t);
			case "hbox":
				var i = this.parseArgumentGroup(r, "text");
				return null != i ? {
					type: "styling",
					mode: i.mode,
					body: [i],
					style: "text"
				} : null;
			case "raw":
				var n = this.parseStringGroup("raw", r);
				return null != n ? {
					type: "raw",
					mode: "text",
					string: n.text
				} : null;
			case "primitive":
				if (r) throw new edx("A primitive argument cannot be optional");
				var a = this.parseGroup(e);
				if (null == a) throw new edx("Expected group as " + e, this.fetch());
				return a;
			case "original":
			case null:
			case void 0: return this.parseArgumentGroup(r);
			default: throw new edx("Unknown group type as " + e, this.fetch());
		}
	}
	consumeSpaces() {
		for (; " " === this.fetch().text;) this.consume();
	}
	parseStringGroup(e, t) {
		var r = this.gullet.scanArgument(t);
		if (null == r) return null;
		for (var i, n = ""; "EOF" !== (i = this.fetch()).text;) n += i.text, this.consume();
		return this.consume(), r.text = n, r;
	}
	parseRegexGroup(e, t) {
		for (var r, i = this.fetch(), n = i, a = ""; "EOF" !== (r = this.fetch()).text && e.test(a + r.text);) a += (n = r).text, this.consume();
		if ("" === a) throw new edx("Invalid " + t + ": '" + i.text + "'", i);
		return i.range(n, a);
	}
	parseColorGroup(e) {
		var t = this.parseStringGroup("color", e);
		if (null == t) return null;
		var r = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(t.text);
		if (!r) throw new edx("Invalid color: '" + t.text + "'", t);
		var i = r[0];
		return /^[0-9a-f]{6}$/i.test(i) && (i = "#" + i), {
			type: "color-token",
			mode: this.mode,
			color: i
		};
	}
	parseSizeGroup(e) {
		var t, r = !1;
		if (this.gullet.consumeSpaces(), !(t = e || "{" === this.gullet.future().text ? this.parseStringGroup("size", e) : this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size"))) return null;
		e || 0 !== t.text.length || (t.text = "0pt", r = !0);
		var i = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(t.text);
		if (!i) throw new edx("Invalid size: '" + t.text + "'", t);
		var n = {
			number: +(i[1] + i[2]),
			unit: i[3]
		};
		if (!epl(n)) throw new edx("Invalid unit: '" + n.unit + "'", t);
		return {
			type: "size",
			mode: this.mode,
			value: n,
			isBlank: r
		};
	}
	parseUrlGroup(e) {
		this.gullet.lexer.setCatcode("%", 13), this.gullet.lexer.setCatcode("~", 12);
		var t = this.parseStringGroup("url", e);
		if (this.gullet.lexer.setCatcode("%", 14), this.gullet.lexer.setCatcode("~", 13), null == t) return null;
		var r = t.text.replace(/\\([#$%&~_^{}])/g, "$1");
		return {
			type: "url",
			mode: this.mode,
			url: r
		};
	}
	parseArgumentGroup(e, t) {
		var r = this.gullet.scanArgument(e);
		if (null == r) return null;
		var i = this.mode;
		t && this.switchMode(t), this.gullet.beginGroup();
		var n = this.parseExpression(!1, "EOF");
		this.expect("EOF"), this.gullet.endGroup();
		var a = {
			type: "ordgroup",
			mode: this.mode,
			loc: r.loc,
			body: n
		};
		return t && this.switchMode(i), a;
	}
	parseGroup(e, t) {
		var r, i = this.fetch(), n = i.text;
		if ("{" === n || "\\begingroup" === n) {
			this.consume();
			var a = "{" === n ? "}" : "\\endgroup";
			this.gullet.beginGroup();
			var s = this.parseExpression(!1, a), o = this.fetch();
			this.expect(a), this.gullet.endGroup(), r = {
				type: "ordgroup",
				mode: this.mode,
				loc: edy.range(i, o),
				body: s,
				semisimple: "\\begingroup" === n || void 0
			};
		} else if (null == (r = this.parseFunction(t, e) || this.parseSymbol()) && "\\" === n[0] && !em0.hasOwnProperty(n)) {
			if (this.settings.throwOnError) throw new edx("Undefined control sequence: " + n, i);
			r = this.formatUnsupportedCmd(n), this.consume();
		}
		return r;
	}
	formLigatures(e) {
		for (var t = e.length - 1, r = 0; r < t; ++r) {
			var i = e[r], n = i.text;
			"-" === n && "-" === e[r + 1].text && (r + 1 < t && "-" === e[r + 2].text ? (e.splice(r, 3, {
				type: "textord",
				mode: "text",
				loc: edy.range(i, e[r + 2]),
				text: "---"
			}), t -= 2) : (e.splice(r, 2, {
				type: "textord",
				mode: "text",
				loc: edy.range(i, e[r + 1]),
				text: "--"
			}), t -= 1)), ("'" === n || "`" === n) && e[r + 1].text === n && (e.splice(r, 2, {
				type: "textord",
				mode: "text",
				loc: edy.range(i, e[r + 1]),
				text: n + n
			}), t -= 1);
		}
	}
	parseSymbol() {
		var e = this.fetch(), t = e.text;
		if (/^\\verb[^a-zA-Z]/.test(t)) {
			this.consume();
			var r = t.slice(5), i = "*" === r.charAt(0);
			if (i && (r = r.slice(1)), r.length < 2 || r.charAt(0) !== r.slice(-1)) throw new edx(`\\verb assertion failed --
                    please report what input caused this bug`);
			return {
				type: "verb",
				mode: "text",
				body: r = r.slice(1, -1),
				star: i
			};
		}
		em3.hasOwnProperty(t[0]) && !epA[this.mode][t[0]] && (this.settings.strict && "math" === this.mode && this.settings.reportNonstrict("unicodeTextInMathMode", "Accented Unicode text character \"" + t[0] + "\" used in math mode", e), t = em3[t[0]] + t.slice(1));
		var n = emj.exec(t);
		if (n && ("i" === (t = t.substring(0, n.index)) ? t = "" : "j" === t && (t = "")), epA[this.mode][t]) {
			this.settings.strict && "math" === this.mode && ep4.indexOf(t) >= 0 && this.settings.reportNonstrict("unicodeTextInMathMode", "Latin-1/Unicode text character \"" + t[0] + "\" used in math mode", e);
			var a, s = epA[this.mode][t].group, o = edy.range(e);
			a = epC.hasOwnProperty(s) ? {
				type: "atom",
				mode: this.mode,
				family: s,
				loc: o,
				text: t
			} : {
				type: s,
				mode: this.mode,
				loc: o,
				text: t
			};
		} else {
			if (!(t.charCodeAt(0) >= 128)) return null;
			this.settings.strict && (edY(t.charCodeAt(0)) ? "math" === this.mode && this.settings.reportNonstrict("unicodeTextInMathMode", "Unicode text character \"" + t[0] + "\" used in math mode", e) : this.settings.reportNonstrict("unknownSymbol", "Unrecognized Unicode character \"" + t[0] + "\" (" + t.charCodeAt(0) + ")", e)), a = {
				type: "textord",
				mode: "text",
				loc: edy.range(e),
				text: t
			};
		}
		if (this.consume(), n) for (var l = 0; l < n[0].length; l++) {
			var h = n[0][l];
			if (!em5[h]) throw new edx("Unknown accent ' " + h + "'", e);
			var u = em5[h][this.mode] || em5[h].text;
			if (!u) throw new edx("Accent " + h + " unsupported in " + this.mode + " mode", e);
			a = {
				type: "accent",
				mode: this.mode,
				loc: edy.range(e),
				label: u,
				isStretchy: !1,
				isShifty: !0,
				base: a
			};
		}
		return a;
	}
};
em6.endOfExpression = [
	"}",
	"\\endgroup",
	"\\end",
	"\\right",
	"&"
];
var em7 = h(function(e, t) {
	if (!("string" == typeof e || e instanceof String)) throw TypeError("KaTeX can only parse string typed expression");
	var r = new em6(e, t);
	delete r.gullet.macros.current["\\df@tag"];
	var i = r.parse();
	if (delete r.gullet.macros.current["\\current@color"], delete r.gullet.macros.current["\\color"], r.gullet.macros.get("\\df@tag")) {
		if (!t.displayMode) throw new edx("\\tag works only in display equations");
		i = [{
			type: "tag",
			mode: "text",
			body: i,
			tag: r.subparse([new edv("\\df@tag")])
		}];
	}
	return i;
}, "parseTree"), em8 = h(function(e, t, r) {
	t.textContent = "";
	var i = eyr(e, r).toNode();
	t.appendChild(i);
}, "render");
"u" > typeof document && "CSS1Compat" !== document.compatMode && ("u" > typeof console && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype."), em8 = h(function() {
	throw new edx("KaTeX doesn't work in quirks mode.");
}, "render"));
var em9 = h(function(e, t) {
	return eyr(e, t).toMarkup();
}, "renderToString"), eye = h(function(e, t) {
	return em7(e, new edM(t));
}, "generateParseTree"), eyt = h(function(e, t, r) {
	if (r.throwOnError || !(e instanceof edx)) throw e;
	var i = efx.makeSpan(["katex-error"], [new epb(t)]);
	return i.setAttribute("title", e.toString()), i.setAttribute("style", "color:" + r.errorColor), i;
}, "renderError"), eyr = h(function(e, t) {
	var r = new edM(t);
	try {
		return ef6(em7(e, r), e, r);
	} catch (t) {
		return eyt(t, e, r);
	}
}, "renderToDomTree"), eyi = h(function(e, t) {
	var r = new edM(t);
	try {
		return ef7(em7(e, r), e, r);
	} catch (t) {
		return eyt(t, e, r);
	}
}, "renderToHTMLTree"), eyn = "0.16.22", eya = {
	Span: epm,
	Anchor: epy,
	SymbolNode: epb,
	SvgNode: epw,
	PathNode: epk,
	LineNode: epT
}, eys = {
	version: eyn,
	render: em8,
	renderToString: em9,
	ParseError: edx,
	SETTINGS_SCHEMA: edN,
	__parse: eye,
	__renderToDomTree: eyr,
	__renderToHTMLTree: eyi,
	__setFontMetrics: ed8,
	__defineSymbol: epL,
	__defineFunction: efA,
	__defineMacro: eg8,
	__domTree: eya
}, eyo = function() {
	var e = h(function(e, t, r, i) {
		for (r = r || {}, i = e.length; i--; r[e[i]] = t);
		return r;
	}, "o"), t = [1, 4], r = [1, 13], i = [1, 12], n = [1, 15], a = [1, 16], s = [1, 20], o = [1, 19], l = [
		6,
		7,
		8
	], u = [1, 26], d = [1, 24], p = [1, 25], f = [
		6,
		7,
		11
	], g = [
		1,
		6,
		13,
		15,
		16,
		19,
		22
	], m = [1, 33], y = [1, 34], v = [
		1,
		6,
		7,
		11,
		13,
		15,
		16,
		19,
		22
	], x = {
		trace: h(function() {}, "trace"),
		yy: {},
		symbols_: {
			error: 2,
			start: 3,
			mindMap: 4,
			spaceLines: 5,
			SPACELINE: 6,
			NL: 7,
			MINDMAP: 8,
			document: 9,
			stop: 10,
			EOF: 11,
			statement: 12,
			SPACELIST: 13,
			node: 14,
			ICON: 15,
			CLASS: 16,
			nodeWithId: 17,
			nodeWithoutId: 18,
			NODE_DSTART: 19,
			NODE_DESCR: 20,
			NODE_DEND: 21,
			NODE_ID: 22,
			$accept: 0,
			$end: 1
		},
		terminals_: {
			2: "error",
			6: "SPACELINE",
			7: "NL",
			8: "MINDMAP",
			11: "EOF",
			13: "SPACELIST",
			15: "ICON",
			16: "CLASS",
			19: "NODE_DSTART",
			20: "NODE_DESCR",
			21: "NODE_DEND",
			22: "NODE_ID"
		},
		productions_: [
			0,
			[3, 1],
			[3, 2],
			[5, 1],
			[5, 2],
			[5, 2],
			[4, 2],
			[4, 3],
			[10, 1],
			[10, 1],
			[10, 1],
			[10, 2],
			[10, 2],
			[9, 3],
			[9, 2],
			[12, 2],
			[12, 2],
			[12, 2],
			[12, 1],
			[12, 1],
			[12, 1],
			[12, 1],
			[12, 1],
			[14, 1],
			[14, 1],
			[18, 3],
			[17, 1],
			[17, 4]
		],
		performAction: h(function(e, t, r, i, n, a, s) {
			var o = a.length - 1;
			switch (n) {
				case 6:
				case 7: return i;
				case 8:
					i.getLogger().trace("Stop NL ");
					break;
				case 9:
					i.getLogger().trace("Stop EOF ");
					break;
				case 11:
					i.getLogger().trace("Stop NL2 ");
					break;
				case 12:
					i.getLogger().trace("Stop EOF2 ");
					break;
				case 15:
					i.getLogger().info("Node: ", a[o].id), i.addNode(a[o - 1].length, a[o].id, a[o].descr, a[o].type);
					break;
				case 16:
					i.getLogger().trace("Icon: ", a[o]), i.decorateNode({ icon: a[o] });
					break;
				case 17:
				case 21:
					i.decorateNode({ class: a[o] });
					break;
				case 18:
					i.getLogger().trace("SPACELIST");
					break;
				case 19:
					i.getLogger().trace("Node: ", a[o].id), i.addNode(0, a[o].id, a[o].descr, a[o].type);
					break;
				case 20:
					i.decorateNode({ icon: a[o] });
					break;
				case 25:
					i.getLogger().trace("node found ..", a[o - 2]), this.$ = {
						id: a[o - 1],
						descr: a[o - 1],
						type: i.getType(a[o - 2], a[o])
					};
					break;
				case 26:
					this.$ = {
						id: a[o],
						descr: a[o],
						type: i.nodeType.DEFAULT
					};
					break;
				case 27: i.getLogger().trace("node found ..", a[o - 3]), this.$ = {
					id: a[o - 3],
					descr: a[o - 1],
					type: i.getType(a[o - 2], a[o])
				};
			}
		}, "anonymous"),
		table: [
			{
				3: 1,
				4: 2,
				5: 3,
				6: [1, 5],
				8: t
			},
			{ 1: [3] },
			{ 1: [2, 1] },
			{
				4: 6,
				6: [1, 7],
				7: [1, 8],
				8: t
			},
			{
				6: r,
				7: [1, 10],
				9: 9,
				12: 11,
				13: i,
				14: 14,
				15: n,
				16: a,
				17: 17,
				18: 18,
				19: s,
				22: o
			},
			e(l, [2, 3]),
			{ 1: [2, 2] },
			e(l, [2, 4]),
			e(l, [2, 5]),
			{
				1: [2, 6],
				6: r,
				12: 21,
				13: i,
				14: 14,
				15: n,
				16: a,
				17: 17,
				18: 18,
				19: s,
				22: o
			},
			{
				6: r,
				9: 22,
				12: 11,
				13: i,
				14: 14,
				15: n,
				16: a,
				17: 17,
				18: 18,
				19: s,
				22: o
			},
			{
				6: u,
				7: d,
				10: 23,
				11: p
			},
			e(f, [2, 22], {
				17: 17,
				18: 18,
				14: 27,
				15: [1, 28],
				16: [1, 29],
				19: s,
				22: o
			}),
			e(f, [2, 18]),
			e(f, [2, 19]),
			e(f, [2, 20]),
			e(f, [2, 21]),
			e(f, [2, 23]),
			e(f, [2, 24]),
			e(f, [2, 26], { 19: [1, 30] }),
			{ 20: [1, 31] },
			{
				6: u,
				7: d,
				10: 32,
				11: p
			},
			{
				1: [2, 7],
				6: r,
				12: 21,
				13: i,
				14: 14,
				15: n,
				16: a,
				17: 17,
				18: 18,
				19: s,
				22: o
			},
			e(g, [2, 14], {
				7: m,
				11: y
			}),
			e(v, [2, 8]),
			e(v, [2, 9]),
			e(v, [2, 10]),
			e(f, [2, 15]),
			e(f, [2, 16]),
			e(f, [2, 17]),
			{ 20: [1, 35] },
			{ 21: [1, 36] },
			e(g, [2, 13], {
				7: m,
				11: y
			}),
			e(v, [2, 11]),
			e(v, [2, 12]),
			{ 21: [1, 37] },
			e(f, [2, 25]),
			e(f, [2, 27])
		],
		defaultActions: {
			2: [2, 1],
			6: [2, 2]
		},
		parseError: h(function(e, t) {
			if (t.recoverable) this.trace(e);
			else {
				var r = Error(e);
				throw r.hash = t, r;
			}
		}, "parseError"),
		parse: h(function(e) {
			var t = this, r = [0], i = [], n = [null], a = [], s = this.table, o = "", l = 0, u = 0, d = 0, p = a.slice.call(arguments, 1), f = Object.create(this.lexer), g = {};
			for (var m in this.yy) Object.prototype.hasOwnProperty.call(this.yy, m) && (g[m] = this.yy[m]);
			f.setInput(e, g), g.lexer = f, g.parser = this, typeof f.yylloc > "u" && (f.yylloc = {});
			var y = f.yylloc;
			a.push(y);
			var v = f.options && f.options.ranges;
			function x() {
				var e;
				return "number" != typeof (e = i.pop() || f.lex() || 1) && (e instanceof Array && (e = (i = e).pop()), e = t.symbols_[e] || e), e;
			}
			"function" == typeof g.parseError ? this.parseError = g.parseError : this.parseError = Object.getPrototypeOf(this).parseError, h(function(e) {
				r.length = r.length - 2 * e, n.length = n.length - e, a.length = a.length - e;
			}, "popStack"), h(x, "lex");
			for (var b, w, k, T, _, E, C, S, A, L = {};;) {
				if (k = r[r.length - 1], this.defaultActions[k] ? T = this.defaultActions[k] : ((null === b || typeof b > "u") && (b = x()), T = s[k] && s[k][b]), typeof T > "u" || !T.length || !T[0]) {
					var R = "";
					for (E in A = [], s[k]) this.terminals_[E] && E > 2 && A.push("'" + this.terminals_[E] + "'");
					R = f.showPosition ? "Parse error on line " + (l + 1) + `:
` + f.showPosition() + `
Expecting ` + A.join(", ") + ", got '" + (this.terminals_[b] || b) + "'" : "Parse error on line " + (l + 1) + ": Unexpected " + (1 == b ? "end of input" : "'" + (this.terminals_[b] || b) + "'"), this.parseError(R, {
						text: f.match,
						token: this.terminals_[b] || b,
						line: f.yylineno,
						loc: y,
						expected: A
					});
				}
				if (T[0] instanceof Array && T.length > 1) throw Error("Parse Error: multiple actions possible at state: " + k + ", token: " + b);
				switch (T[0]) {
					case 1:
						r.push(b), n.push(f.yytext), a.push(f.yylloc), r.push(T[1]), b = null, w ? (b = w, w = null) : (u = f.yyleng, o = f.yytext, l = f.yylineno, y = f.yylloc, d > 0 && d--);
						break;
					case 2:
						if (C = this.productions_[T[1]][1], L.$ = n[n.length - C], L._$ = {
							first_line: a[a.length - (C || 1)].first_line,
							last_line: a[a.length - 1].last_line,
							first_column: a[a.length - (C || 1)].first_column,
							last_column: a[a.length - 1].last_column
						}, v && (L._$.range = [a[a.length - (C || 1)].range[0], a[a.length - 1].range[1]]), "u" > typeof (_ = this.performAction.apply(L, [
							o,
							u,
							l,
							g,
							T[1],
							n,
							a
						].concat(p)))) return _;
						C && (r = r.slice(0, -1 * C * 2), n = n.slice(0, -1 * C), a = a.slice(0, -1 * C)), r.push(this.productions_[T[1]][0]), n.push(L.$), a.push(L._$), S = s[r[r.length - 2]][r[r.length - 1]], r.push(S);
						break;
					case 3: return !0;
				}
			}
			return !0;
		}, "parse")
	};
	function b() {
		this.yy = {};
	}
	return x.lexer = {
		EOF: 1,
		parseError: h(function(e, t) {
			if (this.yy.parser) this.yy.parser.parseError(e, t);
			else throw Error(e);
		}, "parseError"),
		setInput: h(function(e, t) {
			return this.yy = t || this.yy || {}, this._input = e, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
				first_line: 1,
				first_column: 0,
				last_line: 1,
				last_column: 0
			}, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
		}, "setInput"),
		input: h(function() {
			var e = this._input[0];
			return this.yytext += e, this.yyleng++, this.offset++, this.match += e, this.matched += e, e.match(/(?:\r\n?|\n).*/g) ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), e;
		}, "input"),
		unput: h(function(e) {
			var t = e.length, r = e.split(/(?:\r\n?|\n)/g);
			this._input = e + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - t), this.offset -= t;
			var i = this.match.split(/(?:\r\n?|\n)/g);
			this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), r.length - 1 && (this.yylineno -= r.length - 1);
			var n = this.yylloc.range;
			return this.yylloc = {
				first_line: this.yylloc.first_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.first_column,
				last_column: r ? (r.length === i.length ? this.yylloc.first_column : 0) + i[i.length - r.length].length - r[0].length : this.yylloc.first_column - t
			}, this.options.ranges && (this.yylloc.range = [n[0], n[0] + this.yyleng - t]), this.yyleng = this.yytext.length, this;
		}, "unput"),
		more: h(function() {
			return this._more = !0, this;
		}, "more"),
		reject: h(function() {
			return this.options.backtrack_lexer ? (this._backtrack = !0, this) : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "reject"),
		less: h(function(e) {
			this.unput(this.match.slice(e));
		}, "less"),
		pastInput: h(function() {
			var e = this.matched.substr(0, this.matched.length - this.match.length);
			return (e.length > 20 ? "..." : "") + e.substr(-20).replace(/\n/g, "");
		}, "pastInput"),
		upcomingInput: h(function() {
			var e = this.match;
			return e.length < 20 && (e += this._input.substr(0, 20 - e.length)), (e.substr(0, 20) + (e.length > 20 ? "..." : "")).replace(/\n/g, "");
		}, "upcomingInput"),
		showPosition: h(function() {
			var e = this.pastInput(), t = Array(e.length + 1).join("-");
			return e + this.upcomingInput() + `
` + t + "^";
		}, "showPosition"),
		test_match: h(function(e, t) {
			var r, i, n;
			if (this.options.backtrack_lexer && (n = {
				yylineno: this.yylineno,
				yylloc: {
					first_line: this.yylloc.first_line,
					last_line: this.last_line,
					first_column: this.yylloc.first_column,
					last_column: this.yylloc.last_column
				},
				yytext: this.yytext,
				match: this.match,
				matches: this.matches,
				matched: this.matched,
				yyleng: this.yyleng,
				offset: this.offset,
				_more: this._more,
				_input: this._input,
				yy: this.yy,
				conditionStack: this.conditionStack.slice(0),
				done: this.done
			}, this.options.ranges && (n.yylloc.range = this.yylloc.range.slice(0))), (i = e[0].match(/(?:\r\n?|\n).*/g)) && (this.yylineno += i.length), this.yylloc = {
				first_line: this.yylloc.last_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.last_column,
				last_column: i ? i[i.length - 1].length - i[i.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + e[0].length
			}, this.yytext += e[0], this.match += e[0], this.matches = e, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(e[0].length), this.matched += e[0], r = this.performAction.call(this, this.yy, this, t, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), r) return r;
			if (this._backtrack) for (var a in n) this[a] = n[a];
			return !1;
		}, "test_match"),
		next: h(function() {
			if (this.done) return this.EOF;
			this._input || (this.done = !0), this._more || (this.yytext = "", this.match = "");
			for (var e, t, r, i, n = this._currentRules(), a = 0; a < n.length; a++) if ((r = this._input.match(this.rules[n[a]])) && (!t || r[0].length > t[0].length)) {
				if (t = r, i = a, this.options.backtrack_lexer) {
					if (!1 !== (e = this.test_match(r, n[a]))) return e;
					if (!this._backtrack) return !1;
					t = !1;
					continue;
				} else if (!this.options.flex) break;
			}
			return t ? !1 !== (e = this.test_match(t, n[i])) && e : "" === this._input ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "next"),
		lex: h(function() {
			return this.next() || this.lex();
		}, "lex"),
		begin: h(function(e) {
			this.conditionStack.push(e);
		}, "begin"),
		popState: h(function() {
			return this.conditionStack.length - 1 > 0 ? this.conditionStack.pop() : this.conditionStack[0];
		}, "popState"),
		_currentRules: h(function() {
			return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
		}, "_currentRules"),
		topState: h(function(e) {
			return (e = this.conditionStack.length - 1 - Math.abs(e || 0)) >= 0 ? this.conditionStack[e] : "INITIAL";
		}, "topState"),
		pushState: h(function(e) {
			this.begin(e);
		}, "pushState"),
		stateStackSize: h(function() {
			return this.conditionStack.length;
		}, "stateStackSize"),
		options: { "case-insensitive": !0 },
		performAction: h(function(e, t, r, i) {
			switch (r) {
				case 0: return e.getLogger().trace("Found comment", t.yytext), 6;
				case 1: return 8;
				case 2:
					this.begin("CLASS");
					break;
				case 3: return this.popState(), 16;
				case 4:
				case 23:
				case 26:
					this.popState();
					break;
				case 5:
					e.getLogger().trace("Begin icon"), this.begin("ICON");
					break;
				case 6: return e.getLogger().trace("SPACELINE"), 6;
				case 7: return 7;
				case 8: return 15;
				case 9:
					e.getLogger().trace("end icon"), this.popState();
					break;
				case 10: return e.getLogger().trace("Exploding node"), this.begin("NODE"), 19;
				case 11: return e.getLogger().trace("Cloud"), this.begin("NODE"), 19;
				case 12: return e.getLogger().trace("Explosion Bang"), this.begin("NODE"), 19;
				case 13: return e.getLogger().trace("Cloud Bang"), this.begin("NODE"), 19;
				case 14:
				case 15:
				case 16:
				case 17: return this.begin("NODE"), 19;
				case 18: return 13;
				case 19: return 22;
				case 20: return 11;
				case 21:
					this.begin("NSTR2");
					break;
				case 22: return "NODE_DESCR";
				case 24:
					e.getLogger().trace("Starting NSTR"), this.begin("NSTR");
					break;
				case 25: return e.getLogger().trace("description:", t.yytext), "NODE_DESCR";
				case 27: return this.popState(), e.getLogger().trace("node end ))"), "NODE_DEND";
				case 28: return this.popState(), e.getLogger().trace("node end )"), "NODE_DEND";
				case 29: return this.popState(), e.getLogger().trace("node end ...", t.yytext), "NODE_DEND";
				case 30:
				case 33:
				case 34: return this.popState(), e.getLogger().trace("node end (("), "NODE_DEND";
				case 31:
				case 32: return this.popState(), e.getLogger().trace("node end (-"), "NODE_DEND";
				case 35:
				case 36: return e.getLogger().trace("Long description:", t.yytext), 20;
			}
		}, "anonymous"),
		rules: [
			/^(?:\s*%%.*)/i,
			/^(?:mindmap\b)/i,
			/^(?::::)/i,
			/^(?:.+)/i,
			/^(?:\n)/i,
			/^(?:::icon\()/i,
			/^(?:[\s]+[\n])/i,
			/^(?:[\n]+)/i,
			/^(?:[^\)]+)/i,
			/^(?:\))/i,
			/^(?:-\))/i,
			/^(?:\(-)/i,
			/^(?:\)\))/i,
			/^(?:\))/i,
			/^(?:\(\()/i,
			/^(?:\{\{)/i,
			/^(?:\()/i,
			/^(?:\[)/i,
			/^(?:[\s]+)/i,
			/^(?:[^\(\[\n\)\{\}]+)/i,
			/^(?:$)/i,
			/^(?:["][`])/i,
			/^(?:[^`"]+)/i,
			/^(?:[`]["])/i,
			/^(?:["])/i,
			/^(?:[^"]+)/i,
			/^(?:["])/i,
			/^(?:[\)]\))/i,
			/^(?:[\)])/i,
			/^(?:[\]])/i,
			/^(?:\}\})/i,
			/^(?:\(-)/i,
			/^(?:-\))/i,
			/^(?:\(\()/i,
			/^(?:\()/i,
			/^(?:[^\)\]\(\}]+)/i,
			/^(?:.+(?!\(\())/i
		],
		conditions: {
			CLASS: {
				rules: [3, 4],
				inclusive: !1
			},
			ICON: {
				rules: [8, 9],
				inclusive: !1
			},
			NSTR2: {
				rules: [22, 23],
				inclusive: !1
			},
			NSTR: {
				rules: [25, 26],
				inclusive: !1
			},
			NODE: {
				rules: [
					21,
					24,
					27,
					28,
					29,
					30,
					31,
					32,
					33,
					34,
					35,
					36
				],
				inclusive: !1
			},
			INITIAL: {
				rules: [
					0,
					1,
					2,
					5,
					6,
					7,
					10,
					11,
					12,
					13,
					14,
					15,
					16,
					17,
					18,
					19,
					20
				],
				inclusive: !0
			}
		}
	}, h(b, "Parser"), b.prototype = x, x.Parser = b, new b();
}();
eyo.parser = eyo;
var eyl = [];
for (let e = 0; e < 256; ++e) eyl.push((e + 256).toString(16).slice(1));
function eyc(e, t = 0) {
	return (eyl[e[t + 0]] + eyl[e[t + 1]] + eyl[e[t + 2]] + eyl[e[t + 3]] + "-" + eyl[e[t + 4]] + eyl[e[t + 5]] + "-" + eyl[e[t + 6]] + eyl[e[t + 7]] + "-" + eyl[e[t + 8]] + eyl[e[t + 9]] + "-" + eyl[e[t + 10]] + eyl[e[t + 11]] + eyl[e[t + 12]] + eyl[e[t + 13]] + eyl[e[t + 14]] + eyl[e[t + 15]]).toLowerCase();
}
h(eyc, "unsafeStringify");
var eyh, eyu = new Uint8Array(16);
function eyd() {
	if (!eyh) {
		if (typeof crypto > "u" || !crypto.getRandomValues) throw Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
		eyh = crypto.getRandomValues.bind(crypto);
	}
	return eyh(eyu);
}
h(eyd, "rng");
var eyp = { randomUUID: "u" > typeof crypto && crypto.randomUUID && crypto.randomUUID.bind(crypto) };
function eyf(e, t, r) {
	if (eyp.randomUUID && !t && !e) return eyp.randomUUID();
	let i = (e = e || {}).random ?? e.rng?.() ?? eyd();
	if (i.length < 16) throw Error("Random bytes length must be >= 16");
	if (i[6] = 15 & i[6] | 64, i[8] = 63 & i[8] | 128, t) {
		if ((r = r || 0) < 0 || r + 16 > t.length) throw RangeError(`UUID byte range ${r}:${r + 15} is out of buffer bounds`);
		for (let e = 0; e < 16; ++e) t[r + e] = i[e];
		return t;
	}
	return eyc(i);
}
h(eyf, "v4");
var eyg = {
	DEFAULT: 0,
	NO_BORDER: 0,
	ROUNDED_RECT: 1,
	RECT: 2,
	CIRCLE: 3,
	CLOUD: 4,
	BANG: 5,
	HEXAGON: 6
}, eym = class {
	constructor() {
		this.nodes = [], this.count = 0, this.elements = {}, this.getLogger = this.getLogger.bind(this), this.nodeType = eyg, this.clear(), this.getType = this.getType.bind(this), this.getElementById = this.getElementById.bind(this), this.getParent = this.getParent.bind(this), this.getMindmap = this.getMindmap.bind(this), this.addNode = this.addNode.bind(this), this.decorateNode = this.decorateNode.bind(this);
	}
	static {
		h(this, "MindmapDB");
	}
	clear() {
		this.nodes = [], this.count = 0, this.elements = {}, this.baseLevel = void 0;
	}
	getParent(e) {
		for (let t = this.nodes.length - 1; t >= 0; t--) if (this.nodes[t].level < e) return this.nodes[t];
		return null;
	}
	getMindmap() {
		return this.nodes.length > 0 ? this.nodes[0] : null;
	}
	addNode(e, t, r, i) {
		wQ.info("addNode", e, t, r, i);
		let n = !1;
		0 === this.nodes.length ? (this.baseLevel = e, e = 0, n = !0) : void 0 !== this.baseLevel && (e -= this.baseLevel, n = !1);
		let a = IA(), s = a.mindmap?.padding ?? Ip.mindmap.padding;
		switch (i) {
			case this.nodeType.ROUNDED_RECT:
			case this.nodeType.RECT:
			case this.nodeType.HEXAGON: s *= 2;
		}
		let o = {
			id: this.count++,
			nodeId: MO(t, a),
			level: e,
			descr: MO(r, a),
			type: i,
			children: [],
			width: a.mindmap?.maxNodeWidth ?? Ip.mindmap.maxNodeWidth,
			padding: s,
			isRoot: n
		}, l = this.getParent(e);
		if (l) l.children.push(o), this.nodes.push(o);
		else if (n) this.nodes.push(o);
		else throw Error(`There can be only one root. No parent could be found for ("${o.descr}")`);
	}
	getType(e, t) {
		switch (wQ.debug("In get type", e, t), e) {
			case "[": return this.nodeType.RECT;
			case "(": return ")" === t ? this.nodeType.ROUNDED_RECT : this.nodeType.CLOUD;
			case "((": return this.nodeType.CIRCLE;
			case ")": return this.nodeType.CLOUD;
			case "))": return this.nodeType.BANG;
			case "{{": return this.nodeType.HEXAGON;
			default: return this.nodeType.DEFAULT;
		}
	}
	setElementForId(e, t) {
		this.elements[e] = t;
	}
	getElementById(e) {
		return this.elements[e];
	}
	decorateNode(e) {
		if (!e) return;
		let t = IA(), r = this.nodes[this.nodes.length - 1];
		e.icon && (r.icon = MO(e.icon, t)), e.class && (r.class = MO(e.class, t));
	}
	type2Str(e) {
		switch (e) {
			case this.nodeType.DEFAULT: return "no-border";
			case this.nodeType.RECT: return "rect";
			case this.nodeType.ROUNDED_RECT: return "rounded-rect";
			case this.nodeType.CIRCLE: return "circle";
			case this.nodeType.CLOUD: return "cloud";
			case this.nodeType.BANG: return "bang";
			case this.nodeType.HEXAGON: return "hexgon";
			default: return "no-border";
		}
	}
	assignSections(e, t) {
		if (0 === e.level ? e.section = void 0 : e.section = t, e.children) for (let [r, i] of e.children.entries()) {
			let n = 0 === e.level ? r : t;
			this.assignSections(i, n);
		}
	}
	flattenNodes(e, t) {
		let r = ["mindmap-node"];
		!0 === e.isRoot ? r.push("section-root", "section--1") : void 0 !== e.section && r.push(`section-${e.section}`), e.class && r.push(e.class);
		let i = r.join(" "), n = h((e) => {
			switch (e) {
				case eyg.CIRCLE: return "mindmapCircle";
				case eyg.RECT: return "rect";
				case eyg.ROUNDED_RECT: return "rounded";
				case eyg.CLOUD: return "cloud";
				case eyg.BANG: return "bang";
				case eyg.HEXAGON: return "hexagon";
				case eyg.DEFAULT: return "defaultMindmapNode";
				case eyg.NO_BORDER:
				default: return "rect";
			}
		}, "getShapeFromType"), a = {
			id: e.id.toString(),
			domId: "node_" + e.id.toString(),
			label: e.descr,
			isGroup: !1,
			shape: n(e.type),
			width: e.width,
			height: e.height ?? 0,
			padding: e.padding,
			cssClasses: i,
			cssStyles: [],
			look: "default",
			icon: e.icon,
			x: e.x,
			y: e.y,
			level: e.level,
			nodeId: e.nodeId,
			type: e.type,
			section: e.section
		};
		if (t.push(a), e.children) for (let r of e.children) this.flattenNodes(r, t);
	}
	generateEdges(e, t) {
		if (e.children) for (let r of e.children) {
			let i = "edge";
			void 0 !== r.section && (i += ` section-edge-${r.section}`);
			let n = e.level + 1;
			i += ` edge-depth-${n}`;
			let a = {
				id: `edge_${e.id}_${r.id}`,
				start: e.id.toString(),
				end: r.id.toString(),
				type: "normal",
				curve: "basis",
				thickness: "normal",
				look: "default",
				classes: i,
				depth: e.level,
				section: r.section
			};
			t.push(a), this.generateEdges(r, t);
		}
	}
	getData() {
		let e = this.getMindmap(), t = IA();
		if (void 0 !== I$().layout || (t.layout = "cose-bilkent"), !e) return {
			nodes: [],
			edges: [],
			config: t
		};
		wQ.debug("getData: mindmapRoot", e, t), this.assignSections(e);
		let r = [], i = [];
		this.flattenNodes(e, r), this.generateEdges(e, i), wQ.debug(`getData: processed ${r.length} nodes and ${i.length} edges`);
		let n = /* @__PURE__ */ new Map();
		for (let e of r) n.set(e.id, {
			shape: e.shape,
			width: e.width,
			height: e.height,
			padding: e.padding
		});
		return {
			nodes: r,
			edges: i,
			config: t,
			rootNode: e,
			markers: ["point"],
			direction: "TB",
			nodeSpacing: 50,
			rankSpacing: 50,
			shapes: Object.fromEntries(n),
			type: "mindmap",
			diagramId: "mindmap-" + eyf()
		};
	}
	getLogger() {
		return wQ;
	}
}, eyy = { draw: h(async (e, t, r, i) => {
	wQ.debug(`Rendering mindmap diagram
` + e);
	let n = i.db, a = n.getData(), s = JW(t, a.config.securityLevel);
	a.type = i.type, a.layoutAlgorithm = ein(a.config.layout, { fallback: "cose-bilkent" }), a.diagramId = t, n.getMindmap() && (a.nodes.forEach((e) => {
		"rounded" === e.shape ? (e.radius = 15, e.taper = 15, e.stroke = "none", e.width = 0, e.padding = 15) : "circle" === e.shape ? e.padding = 10 : "rect" === e.shape && (e.width = 0, e.padding = 10);
	}), await eii(a, s), JY(s, a.config.mindmap?.padding ?? Ip.mindmap.padding, "mindmapDiagram", a.config.mindmap?.useMaxWidth ?? Ip.mindmap.useMaxWidth));
}, "draw") }, eyv = h((e) => {
	let t = "";
	for (let t = 0; t < e.THEME_COLOR_LIMIT; t++) e["lineColor" + t] = e["lineColor" + t] || e["cScaleInv" + t], N2(e["lineColor" + t]) ? e["lineColor" + t] = N5(e["lineColor" + t], 20) : e["lineColor" + t] = N3(e["lineColor" + t], 20);
	for (let r = 0; r < e.THEME_COLOR_LIMIT; r++) {
		let i = "" + (17 - 3 * r);
		t += `
    .section-${r - 1} rect, .section-${r - 1} path, .section-${r - 1} circle, .section-${r - 1} polygon, .section-${r - 1} path  {
      fill: ${e["cScale" + r]};
    }
    .section-${r - 1} text {
     fill: ${e["cScaleLabel" + r]};
    }
    .node-icon-${r - 1} {
      font-size: 40px;
      color: ${e["cScaleLabel" + r]};
    }
    .section-edge-${r - 1}{
      stroke: ${e["cScale" + r]};
    }
    .edge-depth-${r - 1}{
      stroke-width: ${i};
    }
    .section-${r - 1} line {
      stroke: ${e["cScaleInv" + r]} ;
      stroke-width: 3;
    }

    .disabled, .disabled circle, .disabled text {
      fill: lightgray;
    }
    .disabled text {
      fill: #efefef;
    }
    `;
	}
	return t;
}, "genSections"), eyx = {
	get db() {
		return new eym();
	},
	renderer: eyy,
	parser: eyo,
	styles: h((e) => `
  .edge {
    stroke-width: 3;
  }
  ${eyv(e)}
  .section-root rect, .section-root path, .section-root circle, .section-root polygon  {
    fill: ${e.git0};
  }
  .section-root text {
    fill: ${e.gitBranchLabel0};
  }
  .section-root span {
    color: ${e.gitBranchLabel0};
  }
  .section-2 span {
    color: ${e.gitBranchLabel0};
  }
  .icon-container {
    height:100%;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .edge {
    fill: none;
  }
  .mindmap-node-label {
    dy: 1em;
    alignment-baseline: middle;
    text-anchor: middle;
    dominant-baseline: middle;
    text-align: center;
  }
`, "getStyles")
}, eyb = Ip.pie, eyw = {
	sections: /* @__PURE__ */ new Map(),
	showData: !1,
	config: eyb
}, eyk = eyw.sections, eyT = eyw.showData, ey_ = structuredClone(eyb), eyE = {
	getConfig: h(() => structuredClone(ey_), "getConfig"),
	clear: h(() => {
		eyk = /* @__PURE__ */ new Map(), eyT = eyw.showData, Dn();
	}, "clear"),
	setDiagramTitle: Dc,
	getDiagramTitle: Dh,
	setAccTitle: Da,
	getAccTitle: Ds,
	setAccDescription: Do,
	getAccDescription: Dl,
	addSection: h(({ label: e, value: t }) => {
		if (t < 0) throw Error(`"${e}" has invalid value: ${t}. Negative values are not allowed in pie charts. All slice values must be >= 0.`);
		eyk.has(e) || (eyk.set(e, t), wQ.debug(`added new section: ${e}, with value: ${t}`));
	}, "addSection"),
	getSections: h(() => eyk, "getSections"),
	setShowData: h((e) => {
		eyT = e;
	}, "setShowData"),
	getShowData: h(() => eyT, "getShowData")
}, eyC = h((e, t) => {
	w_(e, t), t.setShowData(e.showData), e.sections.map(t.addSection);
}, "populateDb"), eyS = { parse: h(async (e) => {
	let t = await wS("pie", e);
	wQ.debug(t), eyC(t, eyE);
}, "parse") }, eyA = h((e) => `
  .pieCircle{
    stroke: ${e.pieStrokeColor};
    stroke-width : ${e.pieStrokeWidth};
    opacity : ${e.pieOpacity};
  }
  .pieOuterCircle{
    stroke: ${e.pieOuterStrokeColor};
    stroke-width: ${e.pieOuterStrokeWidth};
    fill: none;
  }
  .pieTitleText {
    text-anchor: middle;
    font-size: ${e.pieTitleTextSize};
    fill: ${e.pieTitleTextColor};
    font-family: ${e.fontFamily};
  }
  .slice {
    font-family: ${e.fontFamily};
    fill: ${e.pieSectionTextColor};
    font-size:${e.pieSectionTextSize};
    // fill: white;
  }
  .legend text {
    fill: ${e.pieLegendTextColor};
    font-family: ${e.fontFamily};
    font-size: ${e.pieLegendTextSize};
  }
`, "getStyles"), eyL = h((e) => {
	let t = [...e.values()].reduce((e, t) => e + t, 0), r = [...e.entries()].map(([e, t]) => ({
		label: e,
		value: t
	})).filter((e) => e.value / t * 100 >= 1).sort((e, t) => t.value - e.value);
	return A7().value((e) => e.value)(r);
}, "createPieArcs"), eyR = {
	parser: eyS,
	db: eyE,
	renderer: { draw: h((e, t, r, i) => {
		wQ.debug(`rendering pie chart
` + e);
		let n = i.db, a = IA(), s = V5(n.getConfig(), a.pie), o = Dy(t), l = o.append("g");
		l.attr("transform", "translate(225,225)");
		let { themeVariables: h } = a, [u] = V4(h.pieOuterStrokeWidth);
		u ??= 2;
		let d = s.textPosition, p = AQ().innerRadius(0).outerRadius(185), f = AQ().innerRadius(185 * d).outerRadius(185 * d);
		l.append("circle").attr("cx", 0).attr("cy", 0).attr("r", 185 + u / 2).attr("class", "pieOuterCircle");
		let g = n.getSections(), m = eyL(g), y = [
			h.pie1,
			h.pie2,
			h.pie3,
			h.pie4,
			h.pie5,
			h.pie6,
			h.pie7,
			h.pie8,
			h.pie9,
			h.pie10,
			h.pie11,
			h.pie12
		], v = 0;
		g.forEach((e) => {
			v += e;
		});
		let x = m.filter((e) => "0" !== (e.data.value / v * 100).toFixed(0)), b = Cm(y);
		l.selectAll("mySlices").data(x).enter().append("path").attr("d", p).attr("fill", (e) => b(e.data.label)).attr("class", "pieCircle"), l.selectAll("mySlices").data(x).enter().append("text").text((e) => (e.data.value / v * 100).toFixed(0) + "%").attr("transform", (e) => "translate(" + f.centroid(e) + ")").style("text-anchor", "middle").attr("class", "slice"), l.append("text").text(n.getDiagramTitle()).attr("x", 0).attr("y", -200).attr("class", "pieTitleText");
		let w = [...g.entries()].map(([e, t]) => ({
			label: e,
			value: t
		})), k = l.selectAll(".legend").data(w).enter().append("g").attr("class", "legend").attr("transform", (e, t) => "translate(216," + (22 * t - 22 * w.length / 2) + ")");
		k.append("rect").attr("width", 18).attr("height", 18).style("fill", (e) => b(e.label)).style("stroke", (e) => b(e.label)), k.append("text").attr("x", 22).attr("y", 14).text((e) => n.getShowData() ? `${e.label} [${e.value}]` : e.label);
		let T = 512 + Math.max(...k.selectAll("text").nodes().map((e) => e?.getBoundingClientRect().width ?? 0));
		o.attr("viewBox", `0 0 ${T} 450`), M5(o, 450, T, s.useMaxWidth);
	}, "draw") },
	styles: eyA
}, eyN = function() {
	var e = h(function(e, t, r, i) {
		for (r = r || {}, i = e.length; i--; r[e[i]] = t);
		return r;
	}, "o"), t = [1, 3], r = [1, 4], i = [1, 5], n = [1, 6], a = [1, 7], s = [
		1,
		4,
		5,
		10,
		12,
		13,
		14,
		18,
		25,
		35,
		37,
		39,
		41,
		42,
		48,
		50,
		51,
		52,
		53,
		54,
		55,
		56,
		57,
		60,
		61,
		63,
		64,
		65,
		66,
		67
	], o = [
		1,
		4,
		5,
		10,
		12,
		13,
		14,
		18,
		25,
		28,
		35,
		37,
		39,
		41,
		42,
		48,
		50,
		51,
		52,
		53,
		54,
		55,
		56,
		57,
		60,
		61,
		63,
		64,
		65,
		66,
		67
	], l = [
		55,
		56,
		57
	], u = [2, 36], d = [1, 37], p = [1, 36], f = [1, 38], g = [1, 35], m = [1, 43], y = [1, 41], v = [1, 14], x = [1, 23], b = [1, 18], w = [1, 19], k = [1, 20], T = [1, 21], _ = [1, 22], E = [1, 24], C = [1, 25], S = [1, 26], A = [1, 27], L = [1, 28], R = [1, 29], N = [1, 32], I = [1, 33], M = [1, 34], D = [1, 39], O = [1, 40], $ = [1, 42], P = [1, 44], B = [1, 62], F = [1, 61], z = [
		4,
		5,
		8,
		10,
		12,
		13,
		14,
		18,
		44,
		47,
		49,
		55,
		56,
		57,
		63,
		64,
		65,
		66,
		67
	], U = [1, 65], G = [1, 66], q = [1, 67], j = [1, 68], W = [1, 69], Y = [1, 70], V = [1, 71], H = [1, 72], X = [1, 73], K = [1, 74], Z = [1, 75], Q = [1, 76], J = [
		4,
		5,
		6,
		7,
		8,
		9,
		10,
		11,
		12,
		13,
		14,
		15,
		18
	], ee = [1, 90], et = [1, 91], er = [1, 92], ei = [1, 99], en = [1, 93], ea = [1, 96], es = [1, 94], eo = [1, 95], el = [1, 97], ec = [1, 98], eh = [1, 102], eu = [
		10,
		55,
		56,
		57
	], ed = [
		4,
		5,
		6,
		8,
		10,
		11,
		13,
		17,
		18,
		19,
		20,
		55,
		56,
		57
	], ep = {
		trace: h(function() {}, "trace"),
		yy: {},
		symbols_: {
			error: 2,
			idStringToken: 3,
			ALPHA: 4,
			NUM: 5,
			NODE_STRING: 6,
			DOWN: 7,
			MINUS: 8,
			DEFAULT: 9,
			COMMA: 10,
			COLON: 11,
			AMP: 12,
			BRKT: 13,
			MULT: 14,
			UNICODE_TEXT: 15,
			styleComponent: 16,
			UNIT: 17,
			SPACE: 18,
			STYLE: 19,
			PCT: 20,
			idString: 21,
			style: 22,
			stylesOpt: 23,
			classDefStatement: 24,
			CLASSDEF: 25,
			start: 26,
			eol: 27,
			QUADRANT: 28,
			document: 29,
			line: 30,
			statement: 31,
			axisDetails: 32,
			quadrantDetails: 33,
			points: 34,
			title: 35,
			title_value: 36,
			acc_title: 37,
			acc_title_value: 38,
			acc_descr: 39,
			acc_descr_value: 40,
			acc_descr_multiline_value: 41,
			section: 42,
			text: 43,
			point_start: 44,
			point_x: 45,
			point_y: 46,
			class_name: 47,
			"X-AXIS": 48,
			"AXIS-TEXT-DELIMITER": 49,
			"Y-AXIS": 50,
			QUADRANT_1: 51,
			QUADRANT_2: 52,
			QUADRANT_3: 53,
			QUADRANT_4: 54,
			NEWLINE: 55,
			SEMI: 56,
			EOF: 57,
			alphaNumToken: 58,
			textNoTagsToken: 59,
			STR: 60,
			MD_STR: 61,
			alphaNum: 62,
			PUNCTUATION: 63,
			PLUS: 64,
			EQUALS: 65,
			DOT: 66,
			UNDERSCORE: 67,
			$accept: 0,
			$end: 1
		},
		terminals_: {
			2: "error",
			4: "ALPHA",
			5: "NUM",
			6: "NODE_STRING",
			7: "DOWN",
			8: "MINUS",
			9: "DEFAULT",
			10: "COMMA",
			11: "COLON",
			12: "AMP",
			13: "BRKT",
			14: "MULT",
			15: "UNICODE_TEXT",
			17: "UNIT",
			18: "SPACE",
			19: "STYLE",
			20: "PCT",
			25: "CLASSDEF",
			28: "QUADRANT",
			35: "title",
			36: "title_value",
			37: "acc_title",
			38: "acc_title_value",
			39: "acc_descr",
			40: "acc_descr_value",
			41: "acc_descr_multiline_value",
			42: "section",
			44: "point_start",
			45: "point_x",
			46: "point_y",
			47: "class_name",
			48: "X-AXIS",
			49: "AXIS-TEXT-DELIMITER",
			50: "Y-AXIS",
			51: "QUADRANT_1",
			52: "QUADRANT_2",
			53: "QUADRANT_3",
			54: "QUADRANT_4",
			55: "NEWLINE",
			56: "SEMI",
			57: "EOF",
			60: "STR",
			61: "MD_STR",
			63: "PUNCTUATION",
			64: "PLUS",
			65: "EQUALS",
			66: "DOT",
			67: "UNDERSCORE"
		},
		productions_: [
			0,
			[3, 1],
			[3, 1],
			[3, 1],
			[3, 1],
			[3, 1],
			[3, 1],
			[3, 1],
			[3, 1],
			[3, 1],
			[3, 1],
			[3, 1],
			[3, 1],
			[16, 1],
			[16, 1],
			[16, 1],
			[16, 1],
			[16, 1],
			[16, 1],
			[16, 1],
			[16, 1],
			[16, 1],
			[16, 1],
			[21, 1],
			[21, 2],
			[22, 1],
			[22, 2],
			[23, 1],
			[23, 3],
			[24, 5],
			[26, 2],
			[26, 2],
			[26, 2],
			[29, 0],
			[29, 2],
			[30, 2],
			[31, 0],
			[31, 1],
			[31, 2],
			[31, 1],
			[31, 1],
			[31, 1],
			[31, 2],
			[31, 2],
			[31, 2],
			[31, 1],
			[31, 1],
			[34, 4],
			[34, 5],
			[34, 5],
			[34, 6],
			[32, 4],
			[32, 3],
			[32, 2],
			[32, 4],
			[32, 3],
			[32, 2],
			[33, 2],
			[33, 2],
			[33, 2],
			[33, 2],
			[27, 1],
			[27, 1],
			[27, 1],
			[43, 1],
			[43, 2],
			[43, 1],
			[43, 1],
			[62, 1],
			[62, 2],
			[58, 1],
			[58, 1],
			[58, 1],
			[58, 1],
			[58, 1],
			[58, 1],
			[58, 1],
			[58, 1],
			[58, 1],
			[58, 1],
			[58, 1],
			[59, 1],
			[59, 1],
			[59, 1]
		],
		performAction: h(function(e, t, r, i, n, a, s) {
			var o = a.length - 1;
			switch (n) {
				case 23:
				case 68:
					this.$ = a[o];
					break;
				case 24:
				case 69:
					this.$ = a[o - 1] + "" + a[o];
					break;
				case 26:
					this.$ = a[o - 1] + a[o];
					break;
				case 27:
					this.$ = [a[o].trim()];
					break;
				case 28:
					a[o - 2].push(a[o].trim()), this.$ = a[o - 2];
					break;
				case 29:
					this.$ = a[o - 4], i.addClass(a[o - 2], a[o]);
					break;
				case 37:
					this.$ = [];
					break;
				case 42:
					this.$ = a[o].trim(), i.setDiagramTitle(this.$);
					break;
				case 43:
					this.$ = a[o].trim(), i.setAccTitle(this.$);
					break;
				case 44:
				case 45:
					this.$ = a[o].trim(), i.setAccDescription(this.$);
					break;
				case 46:
					i.addSection(a[o].substr(8)), this.$ = a[o].substr(8);
					break;
				case 47:
					i.addPoint(a[o - 3], "", a[o - 1], a[o], []);
					break;
				case 48:
					i.addPoint(a[o - 4], a[o - 3], a[o - 1], a[o], []);
					break;
				case 49:
					i.addPoint(a[o - 4], "", a[o - 2], a[o - 1], a[o]);
					break;
				case 50:
					i.addPoint(a[o - 5], a[o - 4], a[o - 2], a[o - 1], a[o]);
					break;
				case 51:
					i.setXAxisLeftText(a[o - 2]), i.setXAxisRightText(a[o]);
					break;
				case 52:
					a[o - 1].text += "  ", i.setXAxisLeftText(a[o - 1]);
					break;
				case 53:
					i.setXAxisLeftText(a[o]);
					break;
				case 54:
					i.setYAxisBottomText(a[o - 2]), i.setYAxisTopText(a[o]);
					break;
				case 55:
					a[o - 1].text += "  ", i.setYAxisBottomText(a[o - 1]);
					break;
				case 56:
					i.setYAxisBottomText(a[o]);
					break;
				case 57:
					i.setQuadrant1Text(a[o]);
					break;
				case 58:
					i.setQuadrant2Text(a[o]);
					break;
				case 59:
					i.setQuadrant3Text(a[o]);
					break;
				case 60:
					i.setQuadrant4Text(a[o]);
					break;
				case 64:
				case 66:
					this.$ = {
						text: a[o],
						type: "text"
					};
					break;
				case 65:
					this.$ = {
						text: a[o - 1].text + "" + a[o],
						type: a[o - 1].type
					};
					break;
				case 67: this.$ = {
					text: a[o],
					type: "markdown"
				};
			}
		}, "anonymous"),
		table: [
			{
				18: t,
				26: 1,
				27: 2,
				28: r,
				55: i,
				56: n,
				57: a
			},
			{ 1: [3] },
			{
				18: t,
				26: 8,
				27: 2,
				28: r,
				55: i,
				56: n,
				57: a
			},
			{
				18: t,
				26: 9,
				27: 2,
				28: r,
				55: i,
				56: n,
				57: a
			},
			e(s, [2, 33], { 29: 10 }),
			e(o, [2, 61]),
			e(o, [2, 62]),
			e(o, [2, 63]),
			{ 1: [2, 30] },
			{ 1: [2, 31] },
			e(l, u, {
				30: 11,
				31: 12,
				24: 13,
				32: 15,
				33: 16,
				34: 17,
				43: 30,
				58: 31,
				1: [2, 32],
				4: d,
				5: p,
				10: f,
				12: g,
				13: m,
				14: y,
				18: v,
				25: x,
				35: b,
				37: w,
				39: k,
				41: T,
				42: _,
				48: E,
				50: C,
				51: S,
				52: A,
				53: L,
				54: R,
				60: N,
				61: I,
				63: M,
				64: D,
				65: O,
				66: $,
				67: P
			}),
			e(s, [2, 34]),
			{
				27: 45,
				55: i,
				56: n,
				57: a
			},
			e(l, [2, 37]),
			e(l, u, {
				24: 13,
				32: 15,
				33: 16,
				34: 17,
				43: 30,
				58: 31,
				31: 46,
				4: d,
				5: p,
				10: f,
				12: g,
				13: m,
				14: y,
				18: v,
				25: x,
				35: b,
				37: w,
				39: k,
				41: T,
				42: _,
				48: E,
				50: C,
				51: S,
				52: A,
				53: L,
				54: R,
				60: N,
				61: I,
				63: M,
				64: D,
				65: O,
				66: $,
				67: P
			}),
			e(l, [2, 39]),
			e(l, [2, 40]),
			e(l, [2, 41]),
			{ 36: [1, 47] },
			{ 38: [1, 48] },
			{ 40: [1, 49] },
			e(l, [2, 45]),
			e(l, [2, 46]),
			{ 18: [1, 50] },
			{
				4: d,
				5: p,
				10: f,
				12: g,
				13: m,
				14: y,
				43: 51,
				58: 31,
				60: N,
				61: I,
				63: M,
				64: D,
				65: O,
				66: $,
				67: P
			},
			{
				4: d,
				5: p,
				10: f,
				12: g,
				13: m,
				14: y,
				43: 52,
				58: 31,
				60: N,
				61: I,
				63: M,
				64: D,
				65: O,
				66: $,
				67: P
			},
			{
				4: d,
				5: p,
				10: f,
				12: g,
				13: m,
				14: y,
				43: 53,
				58: 31,
				60: N,
				61: I,
				63: M,
				64: D,
				65: O,
				66: $,
				67: P
			},
			{
				4: d,
				5: p,
				10: f,
				12: g,
				13: m,
				14: y,
				43: 54,
				58: 31,
				60: N,
				61: I,
				63: M,
				64: D,
				65: O,
				66: $,
				67: P
			},
			{
				4: d,
				5: p,
				10: f,
				12: g,
				13: m,
				14: y,
				43: 55,
				58: 31,
				60: N,
				61: I,
				63: M,
				64: D,
				65: O,
				66: $,
				67: P
			},
			{
				4: d,
				5: p,
				10: f,
				12: g,
				13: m,
				14: y,
				43: 56,
				58: 31,
				60: N,
				61: I,
				63: M,
				64: D,
				65: O,
				66: $,
				67: P
			},
			{
				4: d,
				5: p,
				8: B,
				10: f,
				12: g,
				13: m,
				14: y,
				18: F,
				44: [1, 57],
				47: [1, 58],
				58: 60,
				59: 59,
				63: M,
				64: D,
				65: O,
				66: $,
				67: P
			},
			e(z, [2, 64]),
			e(z, [2, 66]),
			e(z, [2, 67]),
			e(z, [2, 70]),
			e(z, [2, 71]),
			e(z, [2, 72]),
			e(z, [2, 73]),
			e(z, [2, 74]),
			e(z, [2, 75]),
			e(z, [2, 76]),
			e(z, [2, 77]),
			e(z, [2, 78]),
			e(z, [2, 79]),
			e(z, [2, 80]),
			e(s, [2, 35]),
			e(l, [2, 38]),
			e(l, [2, 42]),
			e(l, [2, 43]),
			e(l, [2, 44]),
			{
				3: 64,
				4: U,
				5: G,
				6: q,
				7: j,
				8: W,
				9: Y,
				10: V,
				11: H,
				12: X,
				13: K,
				14: Z,
				15: Q,
				21: 63
			},
			e(l, [2, 53], {
				59: 59,
				58: 60,
				4: d,
				5: p,
				8: B,
				10: f,
				12: g,
				13: m,
				14: y,
				18: F,
				49: [1, 77],
				63: M,
				64: D,
				65: O,
				66: $,
				67: P
			}),
			e(l, [2, 56], {
				59: 59,
				58: 60,
				4: d,
				5: p,
				8: B,
				10: f,
				12: g,
				13: m,
				14: y,
				18: F,
				49: [1, 78],
				63: M,
				64: D,
				65: O,
				66: $,
				67: P
			}),
			e(l, [2, 57], {
				59: 59,
				58: 60,
				4: d,
				5: p,
				8: B,
				10: f,
				12: g,
				13: m,
				14: y,
				18: F,
				63: M,
				64: D,
				65: O,
				66: $,
				67: P
			}),
			e(l, [2, 58], {
				59: 59,
				58: 60,
				4: d,
				5: p,
				8: B,
				10: f,
				12: g,
				13: m,
				14: y,
				18: F,
				63: M,
				64: D,
				65: O,
				66: $,
				67: P
			}),
			e(l, [2, 59], {
				59: 59,
				58: 60,
				4: d,
				5: p,
				8: B,
				10: f,
				12: g,
				13: m,
				14: y,
				18: F,
				63: M,
				64: D,
				65: O,
				66: $,
				67: P
			}),
			e(l, [2, 60], {
				59: 59,
				58: 60,
				4: d,
				5: p,
				8: B,
				10: f,
				12: g,
				13: m,
				14: y,
				18: F,
				63: M,
				64: D,
				65: O,
				66: $,
				67: P
			}),
			{ 45: [1, 79] },
			{ 44: [1, 80] },
			e(z, [2, 65]),
			e(z, [2, 81]),
			e(z, [2, 82]),
			e(z, [2, 83]),
			{
				3: 82,
				4: U,
				5: G,
				6: q,
				7: j,
				8: W,
				9: Y,
				10: V,
				11: H,
				12: X,
				13: K,
				14: Z,
				15: Q,
				18: [1, 81]
			},
			e(J, [2, 23]),
			e(J, [2, 1]),
			e(J, [2, 2]),
			e(J, [2, 3]),
			e(J, [2, 4]),
			e(J, [2, 5]),
			e(J, [2, 6]),
			e(J, [2, 7]),
			e(J, [2, 8]),
			e(J, [2, 9]),
			e(J, [2, 10]),
			e(J, [2, 11]),
			e(J, [2, 12]),
			e(l, [2, 52], {
				58: 31,
				43: 83,
				4: d,
				5: p,
				10: f,
				12: g,
				13: m,
				14: y,
				60: N,
				61: I,
				63: M,
				64: D,
				65: O,
				66: $,
				67: P
			}),
			e(l, [2, 55], {
				58: 31,
				43: 84,
				4: d,
				5: p,
				10: f,
				12: g,
				13: m,
				14: y,
				60: N,
				61: I,
				63: M,
				64: D,
				65: O,
				66: $,
				67: P
			}),
			{ 46: [1, 85] },
			{ 45: [1, 86] },
			{
				4: ee,
				5: et,
				6: er,
				8: ei,
				11: en,
				13: ea,
				16: 89,
				17: es,
				18: eo,
				19: el,
				20: ec,
				22: 88,
				23: 87
			},
			e(J, [2, 24]),
			e(l, [2, 51], {
				59: 59,
				58: 60,
				4: d,
				5: p,
				8: B,
				10: f,
				12: g,
				13: m,
				14: y,
				18: F,
				63: M,
				64: D,
				65: O,
				66: $,
				67: P
			}),
			e(l, [2, 54], {
				59: 59,
				58: 60,
				4: d,
				5: p,
				8: B,
				10: f,
				12: g,
				13: m,
				14: y,
				18: F,
				63: M,
				64: D,
				65: O,
				66: $,
				67: P
			}),
			e(l, [2, 47], {
				22: 88,
				16: 89,
				23: 100,
				4: ee,
				5: et,
				6: er,
				8: ei,
				11: en,
				13: ea,
				17: es,
				18: eo,
				19: el,
				20: ec
			}),
			{ 46: [1, 101] },
			e(l, [2, 29], { 10: eh }),
			e(eu, [2, 27], {
				16: 103,
				4: ee,
				5: et,
				6: er,
				8: ei,
				11: en,
				13: ea,
				17: es,
				18: eo,
				19: el,
				20: ec
			}),
			e(ed, [2, 25]),
			e(ed, [2, 13]),
			e(ed, [2, 14]),
			e(ed, [2, 15]),
			e(ed, [2, 16]),
			e(ed, [2, 17]),
			e(ed, [2, 18]),
			e(ed, [2, 19]),
			e(ed, [2, 20]),
			e(ed, [2, 21]),
			e(ed, [2, 22]),
			e(l, [2, 49], { 10: eh }),
			e(l, [2, 48], {
				22: 88,
				16: 89,
				23: 104,
				4: ee,
				5: et,
				6: er,
				8: ei,
				11: en,
				13: ea,
				17: es,
				18: eo,
				19: el,
				20: ec
			}),
			{
				4: ee,
				5: et,
				6: er,
				8: ei,
				11: en,
				13: ea,
				16: 89,
				17: es,
				18: eo,
				19: el,
				20: ec,
				22: 105
			},
			e(ed, [2, 26]),
			e(l, [2, 50], { 10: eh }),
			e(eu, [2, 28], {
				16: 103,
				4: ee,
				5: et,
				6: er,
				8: ei,
				11: en,
				13: ea,
				17: es,
				18: eo,
				19: el,
				20: ec
			})
		],
		defaultActions: {
			8: [2, 30],
			9: [2, 31]
		},
		parseError: h(function(e, t) {
			if (t.recoverable) this.trace(e);
			else {
				var r = Error(e);
				throw r.hash = t, r;
			}
		}, "parseError"),
		parse: h(function(e) {
			var t = this, r = [0], i = [], n = [null], a = [], s = this.table, o = "", l = 0, u = 0, d = 0, p = a.slice.call(arguments, 1), f = Object.create(this.lexer), g = {};
			for (var m in this.yy) Object.prototype.hasOwnProperty.call(this.yy, m) && (g[m] = this.yy[m]);
			f.setInput(e, g), g.lexer = f, g.parser = this, typeof f.yylloc > "u" && (f.yylloc = {});
			var y = f.yylloc;
			a.push(y);
			var v = f.options && f.options.ranges;
			function x() {
				var e;
				return "number" != typeof (e = i.pop() || f.lex() || 1) && (e instanceof Array && (e = (i = e).pop()), e = t.symbols_[e] || e), e;
			}
			"function" == typeof g.parseError ? this.parseError = g.parseError : this.parseError = Object.getPrototypeOf(this).parseError, h(function(e) {
				r.length = r.length - 2 * e, n.length = n.length - e, a.length = a.length - e;
			}, "popStack"), h(x, "lex");
			for (var b, w, k, T, _, E, C, S, A, L = {};;) {
				if (k = r[r.length - 1], this.defaultActions[k] ? T = this.defaultActions[k] : ((null === b || typeof b > "u") && (b = x()), T = s[k] && s[k][b]), typeof T > "u" || !T.length || !T[0]) {
					var R = "";
					for (E in A = [], s[k]) this.terminals_[E] && E > 2 && A.push("'" + this.terminals_[E] + "'");
					R = f.showPosition ? "Parse error on line " + (l + 1) + `:
` + f.showPosition() + `
Expecting ` + A.join(", ") + ", got '" + (this.terminals_[b] || b) + "'" : "Parse error on line " + (l + 1) + ": Unexpected " + (1 == b ? "end of input" : "'" + (this.terminals_[b] || b) + "'"), this.parseError(R, {
						text: f.match,
						token: this.terminals_[b] || b,
						line: f.yylineno,
						loc: y,
						expected: A
					});
				}
				if (T[0] instanceof Array && T.length > 1) throw Error("Parse Error: multiple actions possible at state: " + k + ", token: " + b);
				switch (T[0]) {
					case 1:
						r.push(b), n.push(f.yytext), a.push(f.yylloc), r.push(T[1]), b = null, w ? (b = w, w = null) : (u = f.yyleng, o = f.yytext, l = f.yylineno, y = f.yylloc, d > 0 && d--);
						break;
					case 2:
						if (C = this.productions_[T[1]][1], L.$ = n[n.length - C], L._$ = {
							first_line: a[a.length - (C || 1)].first_line,
							last_line: a[a.length - 1].last_line,
							first_column: a[a.length - (C || 1)].first_column,
							last_column: a[a.length - 1].last_column
						}, v && (L._$.range = [a[a.length - (C || 1)].range[0], a[a.length - 1].range[1]]), "u" > typeof (_ = this.performAction.apply(L, [
							o,
							u,
							l,
							g,
							T[1],
							n,
							a
						].concat(p)))) return _;
						C && (r = r.slice(0, -1 * C * 2), n = n.slice(0, -1 * C), a = a.slice(0, -1 * C)), r.push(this.productions_[T[1]][0]), n.push(L.$), a.push(L._$), S = s[r[r.length - 2]][r[r.length - 1]], r.push(S);
						break;
					case 3: return !0;
				}
			}
			return !0;
		}, "parse")
	};
	function ef() {
		this.yy = {};
	}
	return ep.lexer = {
		EOF: 1,
		parseError: h(function(e, t) {
			if (this.yy.parser) this.yy.parser.parseError(e, t);
			else throw Error(e);
		}, "parseError"),
		setInput: h(function(e, t) {
			return this.yy = t || this.yy || {}, this._input = e, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
				first_line: 1,
				first_column: 0,
				last_line: 1,
				last_column: 0
			}, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
		}, "setInput"),
		input: h(function() {
			var e = this._input[0];
			return this.yytext += e, this.yyleng++, this.offset++, this.match += e, this.matched += e, e.match(/(?:\r\n?|\n).*/g) ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), e;
		}, "input"),
		unput: h(function(e) {
			var t = e.length, r = e.split(/(?:\r\n?|\n)/g);
			this._input = e + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - t), this.offset -= t;
			var i = this.match.split(/(?:\r\n?|\n)/g);
			this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), r.length - 1 && (this.yylineno -= r.length - 1);
			var n = this.yylloc.range;
			return this.yylloc = {
				first_line: this.yylloc.first_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.first_column,
				last_column: r ? (r.length === i.length ? this.yylloc.first_column : 0) + i[i.length - r.length].length - r[0].length : this.yylloc.first_column - t
			}, this.options.ranges && (this.yylloc.range = [n[0], n[0] + this.yyleng - t]), this.yyleng = this.yytext.length, this;
		}, "unput"),
		more: h(function() {
			return this._more = !0, this;
		}, "more"),
		reject: h(function() {
			return this.options.backtrack_lexer ? (this._backtrack = !0, this) : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "reject"),
		less: h(function(e) {
			this.unput(this.match.slice(e));
		}, "less"),
		pastInput: h(function() {
			var e = this.matched.substr(0, this.matched.length - this.match.length);
			return (e.length > 20 ? "..." : "") + e.substr(-20).replace(/\n/g, "");
		}, "pastInput"),
		upcomingInput: h(function() {
			var e = this.match;
			return e.length < 20 && (e += this._input.substr(0, 20 - e.length)), (e.substr(0, 20) + (e.length > 20 ? "..." : "")).replace(/\n/g, "");
		}, "upcomingInput"),
		showPosition: h(function() {
			var e = this.pastInput(), t = Array(e.length + 1).join("-");
			return e + this.upcomingInput() + `
` + t + "^";
		}, "showPosition"),
		test_match: h(function(e, t) {
			var r, i, n;
			if (this.options.backtrack_lexer && (n = {
				yylineno: this.yylineno,
				yylloc: {
					first_line: this.yylloc.first_line,
					last_line: this.last_line,
					first_column: this.yylloc.first_column,
					last_column: this.yylloc.last_column
				},
				yytext: this.yytext,
				match: this.match,
				matches: this.matches,
				matched: this.matched,
				yyleng: this.yyleng,
				offset: this.offset,
				_more: this._more,
				_input: this._input,
				yy: this.yy,
				conditionStack: this.conditionStack.slice(0),
				done: this.done
			}, this.options.ranges && (n.yylloc.range = this.yylloc.range.slice(0))), (i = e[0].match(/(?:\r\n?|\n).*/g)) && (this.yylineno += i.length), this.yylloc = {
				first_line: this.yylloc.last_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.last_column,
				last_column: i ? i[i.length - 1].length - i[i.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + e[0].length
			}, this.yytext += e[0], this.match += e[0], this.matches = e, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(e[0].length), this.matched += e[0], r = this.performAction.call(this, this.yy, this, t, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), r) return r;
			if (this._backtrack) for (var a in n) this[a] = n[a];
			return !1;
		}, "test_match"),
		next: h(function() {
			if (this.done) return this.EOF;
			this._input || (this.done = !0), this._more || (this.yytext = "", this.match = "");
			for (var e, t, r, i, n = this._currentRules(), a = 0; a < n.length; a++) if ((r = this._input.match(this.rules[n[a]])) && (!t || r[0].length > t[0].length)) {
				if (t = r, i = a, this.options.backtrack_lexer) {
					if (!1 !== (e = this.test_match(r, n[a]))) return e;
					if (!this._backtrack) return !1;
					t = !1;
					continue;
				} else if (!this.options.flex) break;
			}
			return t ? !1 !== (e = this.test_match(t, n[i])) && e : "" === this._input ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "next"),
		lex: h(function() {
			return this.next() || this.lex();
		}, "lex"),
		begin: h(function(e) {
			this.conditionStack.push(e);
		}, "begin"),
		popState: h(function() {
			return this.conditionStack.length - 1 > 0 ? this.conditionStack.pop() : this.conditionStack[0];
		}, "popState"),
		_currentRules: h(function() {
			return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
		}, "_currentRules"),
		topState: h(function(e) {
			return (e = this.conditionStack.length - 1 - Math.abs(e || 0)) >= 0 ? this.conditionStack[e] : "INITIAL";
		}, "topState"),
		pushState: h(function(e) {
			this.begin(e);
		}, "pushState"),
		stateStackSize: h(function() {
			return this.conditionStack.length;
		}, "stateStackSize"),
		options: { "case-insensitive": !0 },
		performAction: h(function(e, t, r, i) {
			switch (r) {
				case 0:
				case 1:
				case 3: break;
				case 2: return 55;
				case 4: return this.begin("title"), 35;
				case 5: return this.popState(), "title_value";
				case 6: return this.begin("acc_title"), 37;
				case 7: return this.popState(), "acc_title_value";
				case 8: return this.begin("acc_descr"), 39;
				case 9: return this.popState(), "acc_descr_value";
				case 10:
					this.begin("acc_descr_multiline");
					break;
				case 11:
				case 23:
				case 25:
				case 31:
					this.popState();
					break;
				case 12: return "acc_descr_multiline_value";
				case 13: return 48;
				case 14: return 50;
				case 15: return 49;
				case 16: return 51;
				case 17: return 52;
				case 18: return 53;
				case 19: return 54;
				case 20: return 25;
				case 21:
					this.begin("md_string");
					break;
				case 22: return "MD_STR";
				case 24:
					this.begin("string");
					break;
				case 26: return "STR";
				case 27:
					this.begin("class_name");
					break;
				case 28: return this.popState(), 47;
				case 29: return this.begin("point_start"), 44;
				case 30: return this.begin("point_x"), 45;
				case 32:
					this.popState(), this.begin("point_y");
					break;
				case 33: return this.popState(), 46;
				case 34: return 28;
				case 35: return 4;
				case 36: return 11;
				case 37: return 64;
				case 38: return 10;
				case 39:
				case 40: return 65;
				case 41: return 14;
				case 42: return 13;
				case 43: return 67;
				case 44: return 66;
				case 45: return 12;
				case 46: return 8;
				case 47: return 5;
				case 48: return 18;
				case 49: return 56;
				case 50: return 63;
				case 51: return 57;
			}
		}, "anonymous"),
		rules: [
			/^(?:%%(?!\{)[^\n]*)/i,
			/^(?:[^\}]%%[^\n]*)/i,
			/^(?:[\n\r]+)/i,
			/^(?:%%[^\n]*)/i,
			/^(?:title\b)/i,
			/^(?:(?!\n||)*[^\n]*)/i,
			/^(?:accTitle\s*:\s*)/i,
			/^(?:(?!\n||)*[^\n]*)/i,
			/^(?:accDescr\s*:\s*)/i,
			/^(?:(?!\n||)*[^\n]*)/i,
			/^(?:accDescr\s*\{\s*)/i,
			/^(?:[\}])/i,
			/^(?:[^\}]*)/i,
			/^(?: *x-axis *)/i,
			/^(?: *y-axis *)/i,
			/^(?: *--+> *)/i,
			/^(?: *quadrant-1 *)/i,
			/^(?: *quadrant-2 *)/i,
			/^(?: *quadrant-3 *)/i,
			/^(?: *quadrant-4 *)/i,
			/^(?:classDef\b)/i,
			/^(?:["][`])/i,
			/^(?:[^`"]+)/i,
			/^(?:[`]["])/i,
			/^(?:["])/i,
			/^(?:["])/i,
			/^(?:[^"]*)/i,
			/^(?::::)/i,
			/^(?:^\w+)/i,
			/^(?:\s*:\s*\[\s*)/i,
			/^(?:(1)|(0(.\d+)?))/i,
			/^(?:\s*\] *)/i,
			/^(?:\s*,\s*)/i,
			/^(?:(1)|(0(.\d+)?))/i,
			/^(?: *quadrantChart *)/i,
			/^(?:[A-Za-z]+)/i,
			/^(?::)/i,
			/^(?:\+)/i,
			/^(?:,)/i,
			/^(?:=)/i,
			/^(?:=)/i,
			/^(?:\*)/i,
			/^(?:#)/i,
			/^(?:[\_])/i,
			/^(?:\.)/i,
			/^(?:&)/i,
			/^(?:-)/i,
			/^(?:[0-9]+)/i,
			/^(?:\s)/i,
			/^(?:;)/i,
			/^(?:[!"#$%&'*+,-.`?\\_/])/i,
			/^(?:$)/i
		],
		conditions: {
			class_name: {
				rules: [28],
				inclusive: !1
			},
			point_y: {
				rules: [33],
				inclusive: !1
			},
			point_x: {
				rules: [32],
				inclusive: !1
			},
			point_start: {
				rules: [30, 31],
				inclusive: !1
			},
			acc_descr_multiline: {
				rules: [11, 12],
				inclusive: !1
			},
			acc_descr: {
				rules: [9],
				inclusive: !1
			},
			acc_title: {
				rules: [7],
				inclusive: !1
			},
			title: {
				rules: [5],
				inclusive: !1
			},
			md_string: {
				rules: [22, 23],
				inclusive: !1
			},
			string: {
				rules: [25, 26],
				inclusive: !1
			},
			INITIAL: {
				rules: [
					0,
					1,
					2,
					3,
					4,
					6,
					8,
					10,
					13,
					14,
					15,
					16,
					17,
					18,
					19,
					20,
					21,
					24,
					27,
					29,
					34,
					35,
					36,
					37,
					38,
					39,
					40,
					41,
					42,
					43,
					44,
					45,
					46,
					47,
					48,
					49,
					50,
					51
				],
				inclusive: !0
			}
		}
	}, h(ef, "Parser"), ef.prototype = ep, ep.Parser = ef, new ef();
}();
eyN.parser = eyN;
var eyI = Io(), eyM = class {
	constructor() {
		this.classes = /* @__PURE__ */ new Map(), this.config = this.getDefaultConfig(), this.themeConfig = this.getDefaultThemeConfig(), this.data = this.getDefaultData();
	}
	static {
		h(this, "QuadrantBuilder");
	}
	getDefaultData() {
		return {
			titleText: "",
			quadrant1Text: "",
			quadrant2Text: "",
			quadrant3Text: "",
			quadrant4Text: "",
			xAxisLeftText: "",
			xAxisRightText: "",
			yAxisBottomText: "",
			yAxisTopText: "",
			points: []
		};
	}
	getDefaultConfig() {
		return {
			showXAxis: !0,
			showYAxis: !0,
			showTitle: !0,
			chartHeight: Ip.quadrantChart?.chartWidth || 500,
			chartWidth: Ip.quadrantChart?.chartHeight || 500,
			titlePadding: Ip.quadrantChart?.titlePadding || 10,
			titleFontSize: Ip.quadrantChart?.titleFontSize || 20,
			quadrantPadding: Ip.quadrantChart?.quadrantPadding || 5,
			xAxisLabelPadding: Ip.quadrantChart?.xAxisLabelPadding || 5,
			yAxisLabelPadding: Ip.quadrantChart?.yAxisLabelPadding || 5,
			xAxisLabelFontSize: Ip.quadrantChart?.xAxisLabelFontSize || 16,
			yAxisLabelFontSize: Ip.quadrantChart?.yAxisLabelFontSize || 16,
			quadrantLabelFontSize: Ip.quadrantChart?.quadrantLabelFontSize || 16,
			quadrantTextTopPadding: Ip.quadrantChart?.quadrantTextTopPadding || 5,
			pointTextPadding: Ip.quadrantChart?.pointTextPadding || 5,
			pointLabelFontSize: Ip.quadrantChart?.pointLabelFontSize || 12,
			pointRadius: Ip.quadrantChart?.pointRadius || 5,
			xAxisPosition: Ip.quadrantChart?.xAxisPosition || "top",
			yAxisPosition: Ip.quadrantChart?.yAxisPosition || "left",
			quadrantInternalBorderStrokeWidth: Ip.quadrantChart?.quadrantInternalBorderStrokeWidth || 1,
			quadrantExternalBorderStrokeWidth: Ip.quadrantChart?.quadrantExternalBorderStrokeWidth || 2
		};
	}
	getDefaultThemeConfig() {
		return {
			quadrant1Fill: eyI.quadrant1Fill,
			quadrant2Fill: eyI.quadrant2Fill,
			quadrant3Fill: eyI.quadrant3Fill,
			quadrant4Fill: eyI.quadrant4Fill,
			quadrant1TextFill: eyI.quadrant1TextFill,
			quadrant2TextFill: eyI.quadrant2TextFill,
			quadrant3TextFill: eyI.quadrant3TextFill,
			quadrant4TextFill: eyI.quadrant4TextFill,
			quadrantPointFill: eyI.quadrantPointFill,
			quadrantPointTextFill: eyI.quadrantPointTextFill,
			quadrantXAxisTextFill: eyI.quadrantXAxisTextFill,
			quadrantYAxisTextFill: eyI.quadrantYAxisTextFill,
			quadrantTitleFill: eyI.quadrantTitleFill,
			quadrantInternalBorderStrokeFill: eyI.quadrantInternalBorderStrokeFill,
			quadrantExternalBorderStrokeFill: eyI.quadrantExternalBorderStrokeFill
		};
	}
	clear() {
		this.config = this.getDefaultConfig(), this.themeConfig = this.getDefaultThemeConfig(), this.data = this.getDefaultData(), this.classes = /* @__PURE__ */ new Map(), wQ.info("clear called");
	}
	setData(e) {
		this.data = {
			...this.data,
			...e
		};
	}
	addPoints(e) {
		this.data.points = [...e, ...this.data.points];
	}
	addClass(e, t) {
		this.classes.set(e, t);
	}
	setConfig(e) {
		wQ.trace("setConfig called with: ", e), this.config = {
			...this.config,
			...e
		};
	}
	setThemeConfig(e) {
		wQ.trace("setThemeConfig called with: ", e), this.themeConfig = {
			...this.themeConfig,
			...e
		};
	}
	calculateSpace(e, t, r, i) {
		let n = 2 * this.config.xAxisLabelPadding + this.config.xAxisLabelFontSize, a = {
			top: "top" === e && t ? n : 0,
			bottom: "bottom" === e && t ? n : 0
		}, s = 2 * this.config.yAxisLabelPadding + this.config.yAxisLabelFontSize, o = {
			left: "left" === this.config.yAxisPosition && r ? s : 0,
			right: "right" === this.config.yAxisPosition && r ? s : 0
		}, l = this.config.titleFontSize + 2 * this.config.titlePadding, h = { top: i ? l : 0 }, u = this.config.quadrantPadding + o.left, d = this.config.quadrantPadding + a.top + h.top, p = this.config.chartWidth - 2 * this.config.quadrantPadding - o.left - o.right, f = this.config.chartHeight - 2 * this.config.quadrantPadding - a.top - a.bottom - h.top;
		return {
			xAxisSpace: a,
			yAxisSpace: o,
			titleSpace: h,
			quadrantSpace: {
				quadrantLeft: u,
				quadrantTop: d,
				quadrantWidth: p,
				quadrantHalfWidth: p / 2,
				quadrantHeight: f,
				quadrantHalfHeight: f / 2
			}
		};
	}
	getAxisLabels(e, t, r, i) {
		let { quadrantSpace: n, titleSpace: a } = i, { quadrantHalfHeight: s, quadrantHeight: o, quadrantLeft: l, quadrantHalfWidth: h, quadrantTop: u, quadrantWidth: d } = n, p = !!this.data.xAxisRightText, f = !!this.data.yAxisTopText, g = [];
		return this.data.xAxisLeftText && t && g.push({
			text: this.data.xAxisLeftText,
			fill: this.themeConfig.quadrantXAxisTextFill,
			x: l + (p ? h / 2 : 0),
			y: "top" === e ? this.config.xAxisLabelPadding + a.top : this.config.xAxisLabelPadding + u + o + this.config.quadrantPadding,
			fontSize: this.config.xAxisLabelFontSize,
			verticalPos: p ? "center" : "left",
			horizontalPos: "top",
			rotation: 0
		}), this.data.xAxisRightText && t && g.push({
			text: this.data.xAxisRightText,
			fill: this.themeConfig.quadrantXAxisTextFill,
			x: l + h + (p ? h / 2 : 0),
			y: "top" === e ? this.config.xAxisLabelPadding + a.top : this.config.xAxisLabelPadding + u + o + this.config.quadrantPadding,
			fontSize: this.config.xAxisLabelFontSize,
			verticalPos: p ? "center" : "left",
			horizontalPos: "top",
			rotation: 0
		}), this.data.yAxisBottomText && r && g.push({
			text: this.data.yAxisBottomText,
			fill: this.themeConfig.quadrantYAxisTextFill,
			x: "left" === this.config.yAxisPosition ? this.config.yAxisLabelPadding : this.config.yAxisLabelPadding + l + d + this.config.quadrantPadding,
			y: u + o - (f ? s / 2 : 0),
			fontSize: this.config.yAxisLabelFontSize,
			verticalPos: f ? "center" : "left",
			horizontalPos: "top",
			rotation: -90
		}), this.data.yAxisTopText && r && g.push({
			text: this.data.yAxisTopText,
			fill: this.themeConfig.quadrantYAxisTextFill,
			x: "left" === this.config.yAxisPosition ? this.config.yAxisLabelPadding : this.config.yAxisLabelPadding + l + d + this.config.quadrantPadding,
			y: u + s - (f ? s / 2 : 0),
			fontSize: this.config.yAxisLabelFontSize,
			verticalPos: f ? "center" : "left",
			horizontalPos: "top",
			rotation: -90
		}), g;
	}
	getQuadrants(e) {
		let { quadrantSpace: t } = e, { quadrantHalfHeight: r, quadrantLeft: i, quadrantHalfWidth: n, quadrantTop: a } = t, s = [
			{
				text: {
					text: this.data.quadrant1Text,
					fill: this.themeConfig.quadrant1TextFill,
					x: 0,
					y: 0,
					fontSize: this.config.quadrantLabelFontSize,
					verticalPos: "center",
					horizontalPos: "middle",
					rotation: 0
				},
				x: i + n,
				y: a,
				width: n,
				height: r,
				fill: this.themeConfig.quadrant1Fill
			},
			{
				text: {
					text: this.data.quadrant2Text,
					fill: this.themeConfig.quadrant2TextFill,
					x: 0,
					y: 0,
					fontSize: this.config.quadrantLabelFontSize,
					verticalPos: "center",
					horizontalPos: "middle",
					rotation: 0
				},
				x: i,
				y: a,
				width: n,
				height: r,
				fill: this.themeConfig.quadrant2Fill
			},
			{
				text: {
					text: this.data.quadrant3Text,
					fill: this.themeConfig.quadrant3TextFill,
					x: 0,
					y: 0,
					fontSize: this.config.quadrantLabelFontSize,
					verticalPos: "center",
					horizontalPos: "middle",
					rotation: 0
				},
				x: i,
				y: a + r,
				width: n,
				height: r,
				fill: this.themeConfig.quadrant3Fill
			},
			{
				text: {
					text: this.data.quadrant4Text,
					fill: this.themeConfig.quadrant4TextFill,
					x: 0,
					y: 0,
					fontSize: this.config.quadrantLabelFontSize,
					verticalPos: "center",
					horizontalPos: "middle",
					rotation: 0
				},
				x: i + n,
				y: a + r,
				width: n,
				height: r,
				fill: this.themeConfig.quadrant4Fill
			}
		];
		for (let e of s) e.text.x = e.x + e.width / 2, 0 === this.data.points.length ? (e.text.y = e.y + e.height / 2, e.text.horizontalPos = "middle") : (e.text.y = e.y + this.config.quadrantTextTopPadding, e.text.horizontalPos = "top");
		return s;
	}
	getQuadrantPoints(e) {
		let { quadrantSpace: t } = e, { quadrantHeight: r, quadrantLeft: i, quadrantTop: n, quadrantWidth: a } = t, s = CR().domain([0, 1]).range([i, a + i]), o = CR().domain([0, 1]).range([r + n, n]);
		return this.data.points.map((e) => {
			let t = this.classes.get(e.className);
			return t && (e = {
				...t,
				...e
			}), {
				x: s(e.x),
				y: o(e.y),
				fill: e.color ?? this.themeConfig.quadrantPointFill,
				radius: e.radius ?? this.config.pointRadius,
				text: {
					text: e.text,
					fill: this.themeConfig.quadrantPointTextFill,
					x: s(e.x),
					y: o(e.y) + this.config.pointTextPadding,
					verticalPos: "center",
					horizontalPos: "top",
					fontSize: this.config.pointLabelFontSize,
					rotation: 0
				},
				strokeColor: e.strokeColor ?? this.themeConfig.quadrantPointFill,
				strokeWidth: e.strokeWidth ?? "0px"
			};
		});
	}
	getBorders(e) {
		let t = this.config.quadrantExternalBorderStrokeWidth / 2, { quadrantSpace: r } = e, { quadrantHalfHeight: i, quadrantHeight: n, quadrantLeft: a, quadrantHalfWidth: s, quadrantTop: o, quadrantWidth: l } = r;
		return [
			{
				strokeFill: this.themeConfig.quadrantExternalBorderStrokeFill,
				strokeWidth: this.config.quadrantExternalBorderStrokeWidth,
				x1: a - t,
				y1: o,
				x2: a + l + t,
				y2: o
			},
			{
				strokeFill: this.themeConfig.quadrantExternalBorderStrokeFill,
				strokeWidth: this.config.quadrantExternalBorderStrokeWidth,
				x1: a + l,
				y1: o + t,
				x2: a + l,
				y2: o + n - t
			},
			{
				strokeFill: this.themeConfig.quadrantExternalBorderStrokeFill,
				strokeWidth: this.config.quadrantExternalBorderStrokeWidth,
				x1: a - t,
				y1: o + n,
				x2: a + l + t,
				y2: o + n
			},
			{
				strokeFill: this.themeConfig.quadrantExternalBorderStrokeFill,
				strokeWidth: this.config.quadrantExternalBorderStrokeWidth,
				x1: a,
				y1: o + t,
				x2: a,
				y2: o + n - t
			},
			{
				strokeFill: this.themeConfig.quadrantInternalBorderStrokeFill,
				strokeWidth: this.config.quadrantInternalBorderStrokeWidth,
				x1: a + s,
				y1: o + t,
				x2: a + s,
				y2: o + n - t
			},
			{
				strokeFill: this.themeConfig.quadrantInternalBorderStrokeFill,
				strokeWidth: this.config.quadrantInternalBorderStrokeWidth,
				x1: a + t,
				y1: o + i,
				x2: a + l - t,
				y2: o + i
			}
		];
	}
	getTitle(e) {
		if (e) return {
			text: this.data.titleText,
			fill: this.themeConfig.quadrantTitleFill,
			fontSize: this.config.titleFontSize,
			horizontalPos: "top",
			verticalPos: "center",
			rotation: 0,
			y: this.config.titlePadding,
			x: this.config.chartWidth / 2
		};
	}
	build() {
		let e = this.config.showXAxis && !!(this.data.xAxisLeftText || this.data.xAxisRightText), t = this.config.showYAxis && !!(this.data.yAxisTopText || this.data.yAxisBottomText), r = this.config.showTitle && !!this.data.titleText, i = this.data.points.length > 0 ? "bottom" : this.config.xAxisPosition, n = this.calculateSpace(i, e, t, r);
		return {
			points: this.getQuadrantPoints(n),
			quadrants: this.getQuadrants(n),
			axisLabels: this.getAxisLabels(i, e, t, n),
			borderLines: this.getBorders(n),
			title: this.getTitle(r)
		};
	}
}, eyD = class extends Error {
	static {
		h(this, "InvalidStyleError");
	}
	constructor(e, t, r) {
		super(`value for ${e} ${t} is invalid, please use a valid ${r}`), this.name = "InvalidStyleError";
	}
};
function eyO(e) {
	return !/^#?([\dA-Fa-f]{6}|[\dA-Fa-f]{3})$/.test(e);
}
function ey$(e) {
	return !/^\d+$/.test(e);
}
function eyP(e) {
	return !/^\d+px$/.test(e);
}
h(eyO, "validateHexCode"), h(ey$, "validateNumber"), h(eyP, "validateSizeInPixels");
var eyB = IA();
function eyF(e) {
	return MO(e.trim(), eyB);
}
h(eyF, "textSanitizer");
var eyz = new eyM();
function eyU(e) {
	eyz.setData({ quadrant1Text: eyF(e.text) });
}
function eyG(e) {
	eyz.setData({ quadrant2Text: eyF(e.text) });
}
function eyq(e) {
	eyz.setData({ quadrant3Text: eyF(e.text) });
}
function eyj(e) {
	eyz.setData({ quadrant4Text: eyF(e.text) });
}
function eyW(e) {
	eyz.setData({ xAxisLeftText: eyF(e.text) });
}
function eyY(e) {
	eyz.setData({ xAxisRightText: eyF(e.text) });
}
function eyV(e) {
	eyz.setData({ yAxisTopText: eyF(e.text) });
}
function eyH(e) {
	eyz.setData({ yAxisBottomText: eyF(e.text) });
}
function eyX(e) {
	let t = {};
	for (let r of e) {
		let [e, i] = r.trim().split(/\s*:\s*/);
		if ("radius" === e) {
			if (ey$(i)) throw new eyD(e, i, "number");
			t.radius = parseInt(i);
		} else if ("color" === e) {
			if (eyO(i)) throw new eyD(e, i, "hex code");
			t.color = i;
		} else if ("stroke-color" === e) {
			if (eyO(i)) throw new eyD(e, i, "hex code");
			t.strokeColor = i;
		} else if ("stroke-width" === e) {
			if (eyP(i)) throw new eyD(e, i, "number of pixels (eg. 10px)");
			t.strokeWidth = i;
		} else throw Error(`style named ${e} is not supported.`);
	}
	return t;
}
function eyK(e, t, r, i, n) {
	let a = eyX(n);
	eyz.addPoints([{
		x: r,
		y: i,
		text: eyF(e.text),
		className: t,
		...a
	}]);
}
function eyZ(e, t) {
	eyz.addClass(e, eyX(t));
}
function eyQ(e) {
	eyz.setConfig({ chartWidth: e });
}
function eyJ(e) {
	eyz.setConfig({ chartHeight: e });
}
function ey0() {
	let { themeVariables: e, quadrantChart: t } = IA();
	return t && eyz.setConfig(t), eyz.setThemeConfig({
		quadrant1Fill: e.quadrant1Fill,
		quadrant2Fill: e.quadrant2Fill,
		quadrant3Fill: e.quadrant3Fill,
		quadrant4Fill: e.quadrant4Fill,
		quadrant1TextFill: e.quadrant1TextFill,
		quadrant2TextFill: e.quadrant2TextFill,
		quadrant3TextFill: e.quadrant3TextFill,
		quadrant4TextFill: e.quadrant4TextFill,
		quadrantPointFill: e.quadrantPointFill,
		quadrantPointTextFill: e.quadrantPointTextFill,
		quadrantXAxisTextFill: e.quadrantXAxisTextFill,
		quadrantYAxisTextFill: e.quadrantYAxisTextFill,
		quadrantExternalBorderStrokeFill: e.quadrantExternalBorderStrokeFill,
		quadrantInternalBorderStrokeFill: e.quadrantInternalBorderStrokeFill,
		quadrantTitleFill: e.quadrantTitleFill
	}), eyz.setData({ titleText: Dh() }), eyz.build();
}
h(eyU, "setQuadrant1Text"), h(eyG, "setQuadrant2Text"), h(eyq, "setQuadrant3Text"), h(eyj, "setQuadrant4Text"), h(eyW, "setXAxisLeftText"), h(eyY, "setXAxisRightText"), h(eyV, "setYAxisTopText"), h(eyH, "setYAxisBottomText"), h(eyX, "parseStyles"), h(eyK, "addPoint"), h(eyZ, "addClass"), h(eyQ, "setWidth"), h(eyJ, "setHeight"), h(ey0, "getQuadrantData");
var ey1 = {
	parser: eyN,
	db: {
		setWidth: eyQ,
		setHeight: eyJ,
		setQuadrant1Text: eyU,
		setQuadrant2Text: eyG,
		setQuadrant3Text: eyq,
		setQuadrant4Text: eyj,
		setXAxisLeftText: eyW,
		setXAxisRightText: eyY,
		setYAxisTopText: eyV,
		setYAxisBottomText: eyH,
		parseStyles: eyX,
		addPoint: eyK,
		addClass: eyZ,
		getQuadrantData: ey0,
		clear: h(function() {
			eyz.clear(), Dn();
		}, "clear"),
		setAccTitle: Da,
		getAccTitle: Ds,
		setDiagramTitle: Dc,
		getDiagramTitle: Dh,
		getAccDescription: Dl,
		setAccDescription: Do
	},
	renderer: { draw: h((e, t, r, i) => {
		function n(e) {
			return "top" === e ? "hanging" : "middle";
		}
		function a(e) {
			return "left" === e ? "start" : "middle";
		}
		function s(e) {
			return `translate(${e.x}, ${e.y}) rotate(${e.rotation || 0})`;
		}
		h(n, "getDominantBaseLine"), h(a, "getTextAnchor"), h(s, "getTransformation");
		let o = IA();
		wQ.debug(`Rendering quadrant chart
` + e);
		let l = o.securityLevel, u;
		"sandbox" === l && (u = _t("#i" + t));
		let d = ("sandbox" === l ? _t(u.nodes()[0].contentDocument.body) : _t("body")).select(`[id="${t}"]`), p = d.append("g").attr("class", "main"), f = o.quadrantChart?.chartWidth ?? 500, g = o.quadrantChart?.chartHeight ?? 500;
		M5(d, g, f, o.quadrantChart?.useMaxWidth ?? !0), d.attr("viewBox", "0 0 " + f + " " + g), i.db.setHeight(g), i.db.setWidth(f);
		let m = i.db.getQuadrantData(), y = p.append("g").attr("class", "quadrants"), v = p.append("g").attr("class", "border"), x = p.append("g").attr("class", "data-points"), b = p.append("g").attr("class", "labels"), w = p.append("g").attr("class", "title");
		m.title && w.append("text").attr("x", 0).attr("y", 0).attr("fill", m.title.fill).attr("font-size", m.title.fontSize).attr("dominant-baseline", n(m.title.horizontalPos)).attr("text-anchor", a(m.title.verticalPos)).attr("transform", s(m.title)).text(m.title.text), m.borderLines && v.selectAll("line").data(m.borderLines).enter().append("line").attr("x1", (e) => e.x1).attr("y1", (e) => e.y1).attr("x2", (e) => e.x2).attr("y2", (e) => e.y2).style("stroke", (e) => e.strokeFill).style("stroke-width", (e) => e.strokeWidth);
		let k = y.selectAll("g.quadrant").data(m.quadrants).enter().append("g").attr("class", "quadrant");
		k.append("rect").attr("x", (e) => e.x).attr("y", (e) => e.y).attr("width", (e) => e.width).attr("height", (e) => e.height).attr("fill", (e) => e.fill), k.append("text").attr("x", 0).attr("y", 0).attr("fill", (e) => e.text.fill).attr("font-size", (e) => e.text.fontSize).attr("dominant-baseline", (e) => n(e.text.horizontalPos)).attr("text-anchor", (e) => a(e.text.verticalPos)).attr("transform", (e) => s(e.text)).text((e) => e.text.text), b.selectAll("g.label").data(m.axisLabels).enter().append("g").attr("class", "label").append("text").attr("x", 0).attr("y", 0).text((e) => e.text).attr("fill", (e) => e.fill).attr("font-size", (e) => e.fontSize).attr("dominant-baseline", (e) => n(e.horizontalPos)).attr("text-anchor", (e) => a(e.verticalPos)).attr("transform", (e) => s(e));
		let T = x.selectAll("g.data-point").data(m.points).enter().append("g").attr("class", "data-point");
		T.append("circle").attr("cx", (e) => e.x).attr("cy", (e) => e.y).attr("r", (e) => e.radius).attr("fill", (e) => e.fill).attr("stroke", (e) => e.strokeColor).attr("stroke-width", (e) => e.strokeWidth), T.append("text").attr("x", 0).attr("y", 0).text((e) => e.text.text).attr("fill", (e) => e.text.fill).attr("font-size", (e) => e.text.fontSize).attr("dominant-baseline", (e) => n(e.text.horizontalPos)).attr("text-anchor", (e) => a(e.text.verticalPos)).attr("transform", (e) => s(e.text));
	}, "draw") },
	styles: h(() => "", "styles")
}, ey2 = function() {
	var e = h(function(e, t, r, i) {
		for (r = r || {}, i = e.length; i--; r[e[i]] = t);
		return r;
	}, "o"), t = [1, 3], r = [1, 4], i = [1, 5], n = [1, 6], a = [
		5,
		6,
		8,
		9,
		11,
		13,
		21,
		22,
		23,
		24,
		41,
		42,
		43,
		44,
		45,
		46,
		54,
		72,
		74,
		77,
		89,
		90
	], s = [1, 22], o = [2, 7], l = [1, 26], u = [1, 27], d = [1, 28], p = [1, 29], f = [1, 33], g = [1, 34], m = [1, 35], y = [1, 36], v = [1, 37], x = [1, 38], b = [1, 24], w = [1, 31], k = [1, 32], T = [1, 30], _ = [1, 39], E = [1, 40], C = [
		5,
		8,
		9,
		11,
		13,
		21,
		22,
		23,
		24,
		41,
		42,
		43,
		44,
		45,
		46,
		54,
		72,
		74,
		77,
		89,
		90
	], S = [1, 61], A = [89, 90], L = [
		5,
		8,
		9,
		11,
		13,
		21,
		22,
		23,
		24,
		27,
		29,
		41,
		42,
		43,
		44,
		45,
		46,
		54,
		61,
		63,
		72,
		74,
		75,
		76,
		77,
		80,
		81,
		82,
		83,
		84,
		85,
		86,
		87,
		88,
		89,
		90
	], R = [27, 29], N = [1, 70], I = [1, 71], M = [1, 72], D = [1, 73], O = [1, 74], $ = [1, 75], P = [1, 76], B = [1, 83], F = [1, 80], z = [1, 84], U = [1, 85], G = [1, 86], q = [1, 87], j = [1, 88], W = [1, 89], Y = [1, 90], V = [1, 91], H = [1, 92], X = [
		5,
		8,
		9,
		11,
		13,
		21,
		22,
		23,
		24,
		27,
		41,
		42,
		43,
		44,
		45,
		46,
		54,
		72,
		74,
		75,
		76,
		77,
		80,
		81,
		82,
		83,
		84,
		85,
		86,
		87,
		88,
		89,
		90
	], K = [63, 64], Z = [1, 101], Q = [
		5,
		8,
		9,
		11,
		13,
		21,
		22,
		23,
		24,
		41,
		42,
		43,
		44,
		45,
		46,
		54,
		72,
		74,
		76,
		77,
		89,
		90
	], J = [
		5,
		8,
		9,
		11,
		13,
		21,
		22,
		23,
		24,
		41,
		42,
		43,
		44,
		45,
		46,
		54,
		72,
		74,
		75,
		76,
		77,
		80,
		81,
		82,
		83,
		84,
		85,
		86,
		87,
		88,
		89,
		90
	], ee = [1, 110], et = [1, 106], er = [1, 107], ei = [1, 108], en = [1, 109], ea = [1, 111], es = [1, 116], eo = [1, 117], el = [1, 114], ec = [1, 115], eh = {
		trace: h(function() {}, "trace"),
		yy: {},
		symbols_: {
			error: 2,
			start: 3,
			directive: 4,
			NEWLINE: 5,
			RD: 6,
			diagram: 7,
			EOF: 8,
			acc_title: 9,
			acc_title_value: 10,
			acc_descr: 11,
			acc_descr_value: 12,
			acc_descr_multiline_value: 13,
			requirementDef: 14,
			elementDef: 15,
			relationshipDef: 16,
			direction: 17,
			styleStatement: 18,
			classDefStatement: 19,
			classStatement: 20,
			direction_tb: 21,
			direction_bt: 22,
			direction_rl: 23,
			direction_lr: 24,
			requirementType: 25,
			requirementName: 26,
			STRUCT_START: 27,
			requirementBody: 28,
			STYLE_SEPARATOR: 29,
			idList: 30,
			ID: 31,
			COLONSEP: 32,
			id: 33,
			TEXT: 34,
			text: 35,
			RISK: 36,
			riskLevel: 37,
			VERIFYMTHD: 38,
			verifyType: 39,
			STRUCT_STOP: 40,
			REQUIREMENT: 41,
			FUNCTIONAL_REQUIREMENT: 42,
			INTERFACE_REQUIREMENT: 43,
			PERFORMANCE_REQUIREMENT: 44,
			PHYSICAL_REQUIREMENT: 45,
			DESIGN_CONSTRAINT: 46,
			LOW_RISK: 47,
			MED_RISK: 48,
			HIGH_RISK: 49,
			VERIFY_ANALYSIS: 50,
			VERIFY_DEMONSTRATION: 51,
			VERIFY_INSPECTION: 52,
			VERIFY_TEST: 53,
			ELEMENT: 54,
			elementName: 55,
			elementBody: 56,
			TYPE: 57,
			type: 58,
			DOCREF: 59,
			ref: 60,
			END_ARROW_L: 61,
			relationship: 62,
			LINE: 63,
			END_ARROW_R: 64,
			CONTAINS: 65,
			COPIES: 66,
			DERIVES: 67,
			SATISFIES: 68,
			VERIFIES: 69,
			REFINES: 70,
			TRACES: 71,
			CLASSDEF: 72,
			stylesOpt: 73,
			CLASS: 74,
			ALPHA: 75,
			COMMA: 76,
			STYLE: 77,
			style: 78,
			styleComponent: 79,
			NUM: 80,
			COLON: 81,
			UNIT: 82,
			SPACE: 83,
			BRKT: 84,
			PCT: 85,
			MINUS: 86,
			LABEL: 87,
			SEMICOLON: 88,
			unqString: 89,
			qString: 90,
			$accept: 0,
			$end: 1
		},
		terminals_: {
			2: "error",
			5: "NEWLINE",
			6: "RD",
			8: "EOF",
			9: "acc_title",
			10: "acc_title_value",
			11: "acc_descr",
			12: "acc_descr_value",
			13: "acc_descr_multiline_value",
			21: "direction_tb",
			22: "direction_bt",
			23: "direction_rl",
			24: "direction_lr",
			27: "STRUCT_START",
			29: "STYLE_SEPARATOR",
			31: "ID",
			32: "COLONSEP",
			34: "TEXT",
			36: "RISK",
			38: "VERIFYMTHD",
			40: "STRUCT_STOP",
			41: "REQUIREMENT",
			42: "FUNCTIONAL_REQUIREMENT",
			43: "INTERFACE_REQUIREMENT",
			44: "PERFORMANCE_REQUIREMENT",
			45: "PHYSICAL_REQUIREMENT",
			46: "DESIGN_CONSTRAINT",
			47: "LOW_RISK",
			48: "MED_RISK",
			49: "HIGH_RISK",
			50: "VERIFY_ANALYSIS",
			51: "VERIFY_DEMONSTRATION",
			52: "VERIFY_INSPECTION",
			53: "VERIFY_TEST",
			54: "ELEMENT",
			57: "TYPE",
			59: "DOCREF",
			61: "END_ARROW_L",
			63: "LINE",
			64: "END_ARROW_R",
			65: "CONTAINS",
			66: "COPIES",
			67: "DERIVES",
			68: "SATISFIES",
			69: "VERIFIES",
			70: "REFINES",
			71: "TRACES",
			72: "CLASSDEF",
			74: "CLASS",
			75: "ALPHA",
			76: "COMMA",
			77: "STYLE",
			80: "NUM",
			81: "COLON",
			82: "UNIT",
			83: "SPACE",
			84: "BRKT",
			85: "PCT",
			86: "MINUS",
			87: "LABEL",
			88: "SEMICOLON",
			89: "unqString",
			90: "qString"
		},
		productions_: [
			0,
			[3, 3],
			[3, 2],
			[3, 4],
			[4, 2],
			[4, 2],
			[4, 1],
			[7, 0],
			[7, 2],
			[7, 2],
			[7, 2],
			[7, 2],
			[7, 2],
			[7, 2],
			[7, 2],
			[7, 2],
			[7, 2],
			[17, 1],
			[17, 1],
			[17, 1],
			[17, 1],
			[14, 5],
			[14, 7],
			[28, 5],
			[28, 5],
			[28, 5],
			[28, 5],
			[28, 2],
			[28, 1],
			[25, 1],
			[25, 1],
			[25, 1],
			[25, 1],
			[25, 1],
			[25, 1],
			[37, 1],
			[37, 1],
			[37, 1],
			[39, 1],
			[39, 1],
			[39, 1],
			[39, 1],
			[15, 5],
			[15, 7],
			[56, 5],
			[56, 5],
			[56, 2],
			[56, 1],
			[16, 5],
			[16, 5],
			[62, 1],
			[62, 1],
			[62, 1],
			[62, 1],
			[62, 1],
			[62, 1],
			[62, 1],
			[19, 3],
			[20, 3],
			[20, 3],
			[30, 1],
			[30, 3],
			[30, 1],
			[30, 3],
			[18, 3],
			[73, 1],
			[73, 3],
			[78, 1],
			[78, 2],
			[79, 1],
			[79, 1],
			[79, 1],
			[79, 1],
			[79, 1],
			[79, 1],
			[79, 1],
			[79, 1],
			[79, 1],
			[79, 1],
			[26, 1],
			[26, 1],
			[33, 1],
			[33, 1],
			[35, 1],
			[35, 1],
			[55, 1],
			[55, 1],
			[58, 1],
			[58, 1],
			[60, 1],
			[60, 1]
		],
		performAction: h(function(e, t, r, i, n, a, s) {
			var o = a.length - 1;
			switch (n) {
				case 4:
					this.$ = a[o].trim(), i.setAccTitle(this.$);
					break;
				case 5:
				case 6:
					this.$ = a[o].trim(), i.setAccDescription(this.$);
					break;
				case 7:
					this.$ = [];
					break;
				case 17:
					i.setDirection("TB");
					break;
				case 18:
					i.setDirection("BT");
					break;
				case 19:
					i.setDirection("RL");
					break;
				case 20:
					i.setDirection("LR");
					break;
				case 21:
					i.addRequirement(a[o - 3], a[o - 4]);
					break;
				case 22:
					i.addRequirement(a[o - 5], a[o - 6]), i.setClass([a[o - 5]], a[o - 3]);
					break;
				case 23:
					i.setNewReqId(a[o - 2]);
					break;
				case 24:
					i.setNewReqText(a[o - 2]);
					break;
				case 25:
					i.setNewReqRisk(a[o - 2]);
					break;
				case 26:
					i.setNewReqVerifyMethod(a[o - 2]);
					break;
				case 29:
					this.$ = i.RequirementType.REQUIREMENT;
					break;
				case 30:
					this.$ = i.RequirementType.FUNCTIONAL_REQUIREMENT;
					break;
				case 31:
					this.$ = i.RequirementType.INTERFACE_REQUIREMENT;
					break;
				case 32:
					this.$ = i.RequirementType.PERFORMANCE_REQUIREMENT;
					break;
				case 33:
					this.$ = i.RequirementType.PHYSICAL_REQUIREMENT;
					break;
				case 34:
					this.$ = i.RequirementType.DESIGN_CONSTRAINT;
					break;
				case 35:
					this.$ = i.RiskLevel.LOW_RISK;
					break;
				case 36:
					this.$ = i.RiskLevel.MED_RISK;
					break;
				case 37:
					this.$ = i.RiskLevel.HIGH_RISK;
					break;
				case 38:
					this.$ = i.VerifyType.VERIFY_ANALYSIS;
					break;
				case 39:
					this.$ = i.VerifyType.VERIFY_DEMONSTRATION;
					break;
				case 40:
					this.$ = i.VerifyType.VERIFY_INSPECTION;
					break;
				case 41:
					this.$ = i.VerifyType.VERIFY_TEST;
					break;
				case 42:
					i.addElement(a[o - 3]);
					break;
				case 43:
					i.addElement(a[o - 5]), i.setClass([a[o - 5]], a[o - 3]);
					break;
				case 44:
					i.setNewElementType(a[o - 2]);
					break;
				case 45:
					i.setNewElementDocRef(a[o - 2]);
					break;
				case 48:
					i.addRelationship(a[o - 2], a[o], a[o - 4]);
					break;
				case 49:
					i.addRelationship(a[o - 2], a[o - 4], a[o]);
					break;
				case 50:
					this.$ = i.Relationships.CONTAINS;
					break;
				case 51:
					this.$ = i.Relationships.COPIES;
					break;
				case 52:
					this.$ = i.Relationships.DERIVES;
					break;
				case 53:
					this.$ = i.Relationships.SATISFIES;
					break;
				case 54:
					this.$ = i.Relationships.VERIFIES;
					break;
				case 55:
					this.$ = i.Relationships.REFINES;
					break;
				case 56:
					this.$ = i.Relationships.TRACES;
					break;
				case 57:
					this.$ = a[o - 2], i.defineClass(a[o - 1], a[o]);
					break;
				case 58:
					i.setClass(a[o - 1], a[o]);
					break;
				case 59:
					i.setClass([a[o - 2]], a[o]);
					break;
				case 60:
				case 62:
				case 65:
					this.$ = [a[o]];
					break;
				case 61:
				case 63:
					this.$ = a[o - 2].concat([a[o]]);
					break;
				case 64:
					this.$ = a[o - 2], i.setCssStyle(a[o - 1], a[o]);
					break;
				case 66:
					a[o - 2].push(a[o]), this.$ = a[o - 2];
					break;
				case 68: this.$ = a[o - 1] + a[o];
			}
		}, "anonymous"),
		table: [
			{
				3: 1,
				4: 2,
				6: t,
				9: r,
				11: i,
				13: n
			},
			{ 1: [3] },
			{
				3: 8,
				4: 2,
				5: [1, 7],
				6: t,
				9: r,
				11: i,
				13: n
			},
			{ 5: [1, 9] },
			{ 10: [1, 10] },
			{ 12: [1, 11] },
			e(a, [2, 6]),
			{
				3: 12,
				4: 2,
				6: t,
				9: r,
				11: i,
				13: n
			},
			{ 1: [2, 2] },
			{
				4: 17,
				5: s,
				7: 13,
				8: o,
				9: r,
				11: i,
				13: n,
				14: 14,
				15: 15,
				16: 16,
				17: 18,
				18: 19,
				19: 20,
				20: 21,
				21: l,
				22: u,
				23: d,
				24: p,
				25: 23,
				33: 25,
				41: f,
				42: g,
				43: m,
				44: y,
				45: v,
				46: x,
				54: b,
				72: w,
				74: k,
				77: T,
				89: _,
				90: E
			},
			e(a, [2, 4]),
			e(a, [2, 5]),
			{ 1: [2, 1] },
			{ 8: [1, 41] },
			{
				4: 17,
				5: s,
				7: 42,
				8: o,
				9: r,
				11: i,
				13: n,
				14: 14,
				15: 15,
				16: 16,
				17: 18,
				18: 19,
				19: 20,
				20: 21,
				21: l,
				22: u,
				23: d,
				24: p,
				25: 23,
				33: 25,
				41: f,
				42: g,
				43: m,
				44: y,
				45: v,
				46: x,
				54: b,
				72: w,
				74: k,
				77: T,
				89: _,
				90: E
			},
			{
				4: 17,
				5: s,
				7: 43,
				8: o,
				9: r,
				11: i,
				13: n,
				14: 14,
				15: 15,
				16: 16,
				17: 18,
				18: 19,
				19: 20,
				20: 21,
				21: l,
				22: u,
				23: d,
				24: p,
				25: 23,
				33: 25,
				41: f,
				42: g,
				43: m,
				44: y,
				45: v,
				46: x,
				54: b,
				72: w,
				74: k,
				77: T,
				89: _,
				90: E
			},
			{
				4: 17,
				5: s,
				7: 44,
				8: o,
				9: r,
				11: i,
				13: n,
				14: 14,
				15: 15,
				16: 16,
				17: 18,
				18: 19,
				19: 20,
				20: 21,
				21: l,
				22: u,
				23: d,
				24: p,
				25: 23,
				33: 25,
				41: f,
				42: g,
				43: m,
				44: y,
				45: v,
				46: x,
				54: b,
				72: w,
				74: k,
				77: T,
				89: _,
				90: E
			},
			{
				4: 17,
				5: s,
				7: 45,
				8: o,
				9: r,
				11: i,
				13: n,
				14: 14,
				15: 15,
				16: 16,
				17: 18,
				18: 19,
				19: 20,
				20: 21,
				21: l,
				22: u,
				23: d,
				24: p,
				25: 23,
				33: 25,
				41: f,
				42: g,
				43: m,
				44: y,
				45: v,
				46: x,
				54: b,
				72: w,
				74: k,
				77: T,
				89: _,
				90: E
			},
			{
				4: 17,
				5: s,
				7: 46,
				8: o,
				9: r,
				11: i,
				13: n,
				14: 14,
				15: 15,
				16: 16,
				17: 18,
				18: 19,
				19: 20,
				20: 21,
				21: l,
				22: u,
				23: d,
				24: p,
				25: 23,
				33: 25,
				41: f,
				42: g,
				43: m,
				44: y,
				45: v,
				46: x,
				54: b,
				72: w,
				74: k,
				77: T,
				89: _,
				90: E
			},
			{
				4: 17,
				5: s,
				7: 47,
				8: o,
				9: r,
				11: i,
				13: n,
				14: 14,
				15: 15,
				16: 16,
				17: 18,
				18: 19,
				19: 20,
				20: 21,
				21: l,
				22: u,
				23: d,
				24: p,
				25: 23,
				33: 25,
				41: f,
				42: g,
				43: m,
				44: y,
				45: v,
				46: x,
				54: b,
				72: w,
				74: k,
				77: T,
				89: _,
				90: E
			},
			{
				4: 17,
				5: s,
				7: 48,
				8: o,
				9: r,
				11: i,
				13: n,
				14: 14,
				15: 15,
				16: 16,
				17: 18,
				18: 19,
				19: 20,
				20: 21,
				21: l,
				22: u,
				23: d,
				24: p,
				25: 23,
				33: 25,
				41: f,
				42: g,
				43: m,
				44: y,
				45: v,
				46: x,
				54: b,
				72: w,
				74: k,
				77: T,
				89: _,
				90: E
			},
			{
				4: 17,
				5: s,
				7: 49,
				8: o,
				9: r,
				11: i,
				13: n,
				14: 14,
				15: 15,
				16: 16,
				17: 18,
				18: 19,
				19: 20,
				20: 21,
				21: l,
				22: u,
				23: d,
				24: p,
				25: 23,
				33: 25,
				41: f,
				42: g,
				43: m,
				44: y,
				45: v,
				46: x,
				54: b,
				72: w,
				74: k,
				77: T,
				89: _,
				90: E
			},
			{
				4: 17,
				5: s,
				7: 50,
				8: o,
				9: r,
				11: i,
				13: n,
				14: 14,
				15: 15,
				16: 16,
				17: 18,
				18: 19,
				19: 20,
				20: 21,
				21: l,
				22: u,
				23: d,
				24: p,
				25: 23,
				33: 25,
				41: f,
				42: g,
				43: m,
				44: y,
				45: v,
				46: x,
				54: b,
				72: w,
				74: k,
				77: T,
				89: _,
				90: E
			},
			{
				26: 51,
				89: [1, 52],
				90: [1, 53]
			},
			{
				55: 54,
				89: [1, 55],
				90: [1, 56]
			},
			{
				29: [1, 59],
				61: [1, 57],
				63: [1, 58]
			},
			e(C, [2, 17]),
			e(C, [2, 18]),
			e(C, [2, 19]),
			e(C, [2, 20]),
			{
				30: 60,
				33: 62,
				75: S,
				89: _,
				90: E
			},
			{
				30: 63,
				33: 62,
				75: S,
				89: _,
				90: E
			},
			{
				30: 64,
				33: 62,
				75: S,
				89: _,
				90: E
			},
			e(A, [2, 29]),
			e(A, [2, 30]),
			e(A, [2, 31]),
			e(A, [2, 32]),
			e(A, [2, 33]),
			e(A, [2, 34]),
			e(L, [2, 81]),
			e(L, [2, 82]),
			{ 1: [2, 3] },
			{ 8: [2, 8] },
			{ 8: [2, 9] },
			{ 8: [2, 10] },
			{ 8: [2, 11] },
			{ 8: [2, 12] },
			{ 8: [2, 13] },
			{ 8: [2, 14] },
			{ 8: [2, 15] },
			{ 8: [2, 16] },
			{
				27: [1, 65],
				29: [1, 66]
			},
			e(R, [2, 79]),
			e(R, [2, 80]),
			{
				27: [1, 67],
				29: [1, 68]
			},
			e(R, [2, 85]),
			e(R, [2, 86]),
			{
				62: 69,
				65: N,
				66: I,
				67: M,
				68: D,
				69: O,
				70: $,
				71: P
			},
			{
				62: 77,
				65: N,
				66: I,
				67: M,
				68: D,
				69: O,
				70: $,
				71: P
			},
			{
				30: 78,
				33: 62,
				75: S,
				89: _,
				90: E
			},
			{
				73: 79,
				75: B,
				76: F,
				78: 81,
				79: 82,
				80: z,
				81: U,
				82: G,
				83: q,
				84: j,
				85: W,
				86: Y,
				87: V,
				88: H
			},
			e(X, [2, 60]),
			e(X, [2, 62]),
			{
				73: 93,
				75: B,
				76: F,
				78: 81,
				79: 82,
				80: z,
				81: U,
				82: G,
				83: q,
				84: j,
				85: W,
				86: Y,
				87: V,
				88: H
			},
			{
				30: 94,
				33: 62,
				75: S,
				76: F,
				89: _,
				90: E
			},
			{ 5: [1, 95] },
			{
				30: 96,
				33: 62,
				75: S,
				89: _,
				90: E
			},
			{ 5: [1, 97] },
			{
				30: 98,
				33: 62,
				75: S,
				89: _,
				90: E
			},
			{ 63: [1, 99] },
			e(K, [2, 50]),
			e(K, [2, 51]),
			e(K, [2, 52]),
			e(K, [2, 53]),
			e(K, [2, 54]),
			e(K, [2, 55]),
			e(K, [2, 56]),
			{ 64: [1, 100] },
			e(C, [2, 59], { 76: F }),
			e(C, [2, 64], { 76: Z }),
			{
				33: 103,
				75: [1, 102],
				89: _,
				90: E
			},
			e(Q, [2, 65], {
				79: 104,
				75: B,
				80: z,
				81: U,
				82: G,
				83: q,
				84: j,
				85: W,
				86: Y,
				87: V,
				88: H
			}),
			e(J, [2, 67]),
			e(J, [2, 69]),
			e(J, [2, 70]),
			e(J, [2, 71]),
			e(J, [2, 72]),
			e(J, [2, 73]),
			e(J, [2, 74]),
			e(J, [2, 75]),
			e(J, [2, 76]),
			e(J, [2, 77]),
			e(J, [2, 78]),
			e(C, [2, 57], { 76: Z }),
			e(C, [2, 58], { 76: F }),
			{
				5: ee,
				28: 105,
				31: et,
				34: er,
				36: ei,
				38: en,
				40: ea
			},
			{
				27: [1, 112],
				76: F
			},
			{
				5: es,
				40: eo,
				56: 113,
				57: el,
				59: ec
			},
			{
				27: [1, 118],
				76: F
			},
			{
				33: 119,
				89: _,
				90: E
			},
			{
				33: 120,
				89: _,
				90: E
			},
			{
				75: B,
				78: 121,
				79: 82,
				80: z,
				81: U,
				82: G,
				83: q,
				84: j,
				85: W,
				86: Y,
				87: V,
				88: H
			},
			e(X, [2, 61]),
			e(X, [2, 63]),
			e(J, [2, 68]),
			e(C, [2, 21]),
			{ 32: [1, 122] },
			{ 32: [1, 123] },
			{ 32: [1, 124] },
			{ 32: [1, 125] },
			{
				5: ee,
				28: 126,
				31: et,
				34: er,
				36: ei,
				38: en,
				40: ea
			},
			e(C, [2, 28]),
			{ 5: [1, 127] },
			e(C, [2, 42]),
			{ 32: [1, 128] },
			{ 32: [1, 129] },
			{
				5: es,
				40: eo,
				56: 130,
				57: el,
				59: ec
			},
			e(C, [2, 47]),
			{ 5: [1, 131] },
			e(C, [2, 48]),
			e(C, [2, 49]),
			e(Q, [2, 66], {
				79: 104,
				75: B,
				80: z,
				81: U,
				82: G,
				83: q,
				84: j,
				85: W,
				86: Y,
				87: V,
				88: H
			}),
			{
				33: 132,
				89: _,
				90: E
			},
			{
				35: 133,
				89: [1, 134],
				90: [1, 135]
			},
			{
				37: 136,
				47: [1, 137],
				48: [1, 138],
				49: [1, 139]
			},
			{
				39: 140,
				50: [1, 141],
				51: [1, 142],
				52: [1, 143],
				53: [1, 144]
			},
			e(C, [2, 27]),
			{
				5: ee,
				28: 145,
				31: et,
				34: er,
				36: ei,
				38: en,
				40: ea
			},
			{
				58: 146,
				89: [1, 147],
				90: [1, 148]
			},
			{
				60: 149,
				89: [1, 150],
				90: [1, 151]
			},
			e(C, [2, 46]),
			{
				5: es,
				40: eo,
				56: 152,
				57: el,
				59: ec
			},
			{ 5: [1, 153] },
			{ 5: [1, 154] },
			{ 5: [2, 83] },
			{ 5: [2, 84] },
			{ 5: [1, 155] },
			{ 5: [2, 35] },
			{ 5: [2, 36] },
			{ 5: [2, 37] },
			{ 5: [1, 156] },
			{ 5: [2, 38] },
			{ 5: [2, 39] },
			{ 5: [2, 40] },
			{ 5: [2, 41] },
			e(C, [2, 22]),
			{ 5: [1, 157] },
			{ 5: [2, 87] },
			{ 5: [2, 88] },
			{ 5: [1, 158] },
			{ 5: [2, 89] },
			{ 5: [2, 90] },
			e(C, [2, 43]),
			{
				5: ee,
				28: 159,
				31: et,
				34: er,
				36: ei,
				38: en,
				40: ea
			},
			{
				5: ee,
				28: 160,
				31: et,
				34: er,
				36: ei,
				38: en,
				40: ea
			},
			{
				5: ee,
				28: 161,
				31: et,
				34: er,
				36: ei,
				38: en,
				40: ea
			},
			{
				5: ee,
				28: 162,
				31: et,
				34: er,
				36: ei,
				38: en,
				40: ea
			},
			{
				5: es,
				40: eo,
				56: 163,
				57: el,
				59: ec
			},
			{
				5: es,
				40: eo,
				56: 164,
				57: el,
				59: ec
			},
			e(C, [2, 23]),
			e(C, [2, 24]),
			e(C, [2, 25]),
			e(C, [2, 26]),
			e(C, [2, 44]),
			e(C, [2, 45])
		],
		defaultActions: {
			8: [2, 2],
			12: [2, 1],
			41: [2, 3],
			42: [2, 8],
			43: [2, 9],
			44: [2, 10],
			45: [2, 11],
			46: [2, 12],
			47: [2, 13],
			48: [2, 14],
			49: [2, 15],
			50: [2, 16],
			134: [2, 83],
			135: [2, 84],
			137: [2, 35],
			138: [2, 36],
			139: [2, 37],
			141: [2, 38],
			142: [2, 39],
			143: [2, 40],
			144: [2, 41],
			147: [2, 87],
			148: [2, 88],
			150: [2, 89],
			151: [2, 90]
		},
		parseError: h(function(e, t) {
			if (t.recoverable) this.trace(e);
			else {
				var r = Error(e);
				throw r.hash = t, r;
			}
		}, "parseError"),
		parse: h(function(e) {
			var t = this, r = [0], i = [], n = [null], a = [], s = this.table, o = "", l = 0, u = 0, d = 0, p = a.slice.call(arguments, 1), f = Object.create(this.lexer), g = {};
			for (var m in this.yy) Object.prototype.hasOwnProperty.call(this.yy, m) && (g[m] = this.yy[m]);
			f.setInput(e, g), g.lexer = f, g.parser = this, typeof f.yylloc > "u" && (f.yylloc = {});
			var y = f.yylloc;
			a.push(y);
			var v = f.options && f.options.ranges;
			function x() {
				var e;
				return "number" != typeof (e = i.pop() || f.lex() || 1) && (e instanceof Array && (e = (i = e).pop()), e = t.symbols_[e] || e), e;
			}
			"function" == typeof g.parseError ? this.parseError = g.parseError : this.parseError = Object.getPrototypeOf(this).parseError, h(function(e) {
				r.length = r.length - 2 * e, n.length = n.length - e, a.length = a.length - e;
			}, "popStack"), h(x, "lex");
			for (var b, w, k, T, _, E, C, S, A, L = {};;) {
				if (k = r[r.length - 1], this.defaultActions[k] ? T = this.defaultActions[k] : ((null === b || typeof b > "u") && (b = x()), T = s[k] && s[k][b]), typeof T > "u" || !T.length || !T[0]) {
					var R = "";
					for (E in A = [], s[k]) this.terminals_[E] && E > 2 && A.push("'" + this.terminals_[E] + "'");
					R = f.showPosition ? "Parse error on line " + (l + 1) + `:
` + f.showPosition() + `
Expecting ` + A.join(", ") + ", got '" + (this.terminals_[b] || b) + "'" : "Parse error on line " + (l + 1) + ": Unexpected " + (1 == b ? "end of input" : "'" + (this.terminals_[b] || b) + "'"), this.parseError(R, {
						text: f.match,
						token: this.terminals_[b] || b,
						line: f.yylineno,
						loc: y,
						expected: A
					});
				}
				if (T[0] instanceof Array && T.length > 1) throw Error("Parse Error: multiple actions possible at state: " + k + ", token: " + b);
				switch (T[0]) {
					case 1:
						r.push(b), n.push(f.yytext), a.push(f.yylloc), r.push(T[1]), b = null, w ? (b = w, w = null) : (u = f.yyleng, o = f.yytext, l = f.yylineno, y = f.yylloc, d > 0 && d--);
						break;
					case 2:
						if (C = this.productions_[T[1]][1], L.$ = n[n.length - C], L._$ = {
							first_line: a[a.length - (C || 1)].first_line,
							last_line: a[a.length - 1].last_line,
							first_column: a[a.length - (C || 1)].first_column,
							last_column: a[a.length - 1].last_column
						}, v && (L._$.range = [a[a.length - (C || 1)].range[0], a[a.length - 1].range[1]]), "u" > typeof (_ = this.performAction.apply(L, [
							o,
							u,
							l,
							g,
							T[1],
							n,
							a
						].concat(p)))) return _;
						C && (r = r.slice(0, -1 * C * 2), n = n.slice(0, -1 * C), a = a.slice(0, -1 * C)), r.push(this.productions_[T[1]][0]), n.push(L.$), a.push(L._$), S = s[r[r.length - 2]][r[r.length - 1]], r.push(S);
						break;
					case 3: return !0;
				}
			}
			return !0;
		}, "parse")
	};
	function eu() {
		this.yy = {};
	}
	return eh.lexer = {
		EOF: 1,
		parseError: h(function(e, t) {
			if (this.yy.parser) this.yy.parser.parseError(e, t);
			else throw Error(e);
		}, "parseError"),
		setInput: h(function(e, t) {
			return this.yy = t || this.yy || {}, this._input = e, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
				first_line: 1,
				first_column: 0,
				last_line: 1,
				last_column: 0
			}, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
		}, "setInput"),
		input: h(function() {
			var e = this._input[0];
			return this.yytext += e, this.yyleng++, this.offset++, this.match += e, this.matched += e, e.match(/(?:\r\n?|\n).*/g) ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), e;
		}, "input"),
		unput: h(function(e) {
			var t = e.length, r = e.split(/(?:\r\n?|\n)/g);
			this._input = e + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - t), this.offset -= t;
			var i = this.match.split(/(?:\r\n?|\n)/g);
			this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), r.length - 1 && (this.yylineno -= r.length - 1);
			var n = this.yylloc.range;
			return this.yylloc = {
				first_line: this.yylloc.first_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.first_column,
				last_column: r ? (r.length === i.length ? this.yylloc.first_column : 0) + i[i.length - r.length].length - r[0].length : this.yylloc.first_column - t
			}, this.options.ranges && (this.yylloc.range = [n[0], n[0] + this.yyleng - t]), this.yyleng = this.yytext.length, this;
		}, "unput"),
		more: h(function() {
			return this._more = !0, this;
		}, "more"),
		reject: h(function() {
			return this.options.backtrack_lexer ? (this._backtrack = !0, this) : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "reject"),
		less: h(function(e) {
			this.unput(this.match.slice(e));
		}, "less"),
		pastInput: h(function() {
			var e = this.matched.substr(0, this.matched.length - this.match.length);
			return (e.length > 20 ? "..." : "") + e.substr(-20).replace(/\n/g, "");
		}, "pastInput"),
		upcomingInput: h(function() {
			var e = this.match;
			return e.length < 20 && (e += this._input.substr(0, 20 - e.length)), (e.substr(0, 20) + (e.length > 20 ? "..." : "")).replace(/\n/g, "");
		}, "upcomingInput"),
		showPosition: h(function() {
			var e = this.pastInput(), t = Array(e.length + 1).join("-");
			return e + this.upcomingInput() + `
` + t + "^";
		}, "showPosition"),
		test_match: h(function(e, t) {
			var r, i, n;
			if (this.options.backtrack_lexer && (n = {
				yylineno: this.yylineno,
				yylloc: {
					first_line: this.yylloc.first_line,
					last_line: this.last_line,
					first_column: this.yylloc.first_column,
					last_column: this.yylloc.last_column
				},
				yytext: this.yytext,
				match: this.match,
				matches: this.matches,
				matched: this.matched,
				yyleng: this.yyleng,
				offset: this.offset,
				_more: this._more,
				_input: this._input,
				yy: this.yy,
				conditionStack: this.conditionStack.slice(0),
				done: this.done
			}, this.options.ranges && (n.yylloc.range = this.yylloc.range.slice(0))), (i = e[0].match(/(?:\r\n?|\n).*/g)) && (this.yylineno += i.length), this.yylloc = {
				first_line: this.yylloc.last_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.last_column,
				last_column: i ? i[i.length - 1].length - i[i.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + e[0].length
			}, this.yytext += e[0], this.match += e[0], this.matches = e, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(e[0].length), this.matched += e[0], r = this.performAction.call(this, this.yy, this, t, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), r) return r;
			if (this._backtrack) for (var a in n) this[a] = n[a];
			return !1;
		}, "test_match"),
		next: h(function() {
			if (this.done) return this.EOF;
			this._input || (this.done = !0), this._more || (this.yytext = "", this.match = "");
			for (var e, t, r, i, n = this._currentRules(), a = 0; a < n.length; a++) if ((r = this._input.match(this.rules[n[a]])) && (!t || r[0].length > t[0].length)) {
				if (t = r, i = a, this.options.backtrack_lexer) {
					if (!1 !== (e = this.test_match(r, n[a]))) return e;
					if (!this._backtrack) return !1;
					t = !1;
					continue;
				} else if (!this.options.flex) break;
			}
			return t ? !1 !== (e = this.test_match(t, n[i])) && e : "" === this._input ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "next"),
		lex: h(function() {
			return this.next() || this.lex();
		}, "lex"),
		begin: h(function(e) {
			this.conditionStack.push(e);
		}, "begin"),
		popState: h(function() {
			return this.conditionStack.length - 1 > 0 ? this.conditionStack.pop() : this.conditionStack[0];
		}, "popState"),
		_currentRules: h(function() {
			return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
		}, "_currentRules"),
		topState: h(function(e) {
			return (e = this.conditionStack.length - 1 - Math.abs(e || 0)) >= 0 ? this.conditionStack[e] : "INITIAL";
		}, "topState"),
		pushState: h(function(e) {
			this.begin(e);
		}, "pushState"),
		stateStackSize: h(function() {
			return this.conditionStack.length;
		}, "stateStackSize"),
		options: { "case-insensitive": !0 },
		performAction: h(function(e, t, r, i) {
			switch (r) {
				case 0: return "title";
				case 1: return this.begin("acc_title"), 9;
				case 2: return this.popState(), "acc_title_value";
				case 3: return this.begin("acc_descr"), 11;
				case 4: return this.popState(), "acc_descr_value";
				case 5:
					this.begin("acc_descr_multiline");
					break;
				case 6:
				case 58:
				case 65:
					this.popState();
					break;
				case 7: return "acc_descr_multiline_value";
				case 8: return 21;
				case 9: return 22;
				case 10: return 23;
				case 11: return 24;
				case 12: return 5;
				case 13:
				case 14:
				case 15:
				case 56: break;
				case 16: return 8;
				case 17: return 6;
				case 18: return 27;
				case 19: return 40;
				case 20: return 29;
				case 21: return 32;
				case 22: return 31;
				case 23: return 34;
				case 24: return 36;
				case 25: return 38;
				case 26: return 41;
				case 27: return 42;
				case 28: return 43;
				case 29: return 44;
				case 30: return 45;
				case 31: return 46;
				case 32: return 47;
				case 33: return 48;
				case 34: return 49;
				case 35: return 50;
				case 36: return 51;
				case 37: return 52;
				case 38: return 53;
				case 39: return 54;
				case 40: return 65;
				case 41: return 66;
				case 42: return 67;
				case 43: return 68;
				case 44: return 69;
				case 45: return 70;
				case 46: return 71;
				case 47: return 57;
				case 48: return 59;
				case 49: return this.begin("style"), 77;
				case 50:
				case 68: return 75;
				case 51: return 81;
				case 52: return 88;
				case 53: return "PERCENT";
				case 54: return 86;
				case 55: return 84;
				case 57:
				case 64:
					this.begin("string");
					break;
				case 59: return this.begin("style"), 72;
				case 60: return this.begin("style"), 74;
				case 61: return 61;
				case 62: return 64;
				case 63: return 63;
				case 66: return "qString";
				case 67: return t.yytext = t.yytext.trim(), 89;
				case 69: return 80;
				case 70: return 76;
			}
		}, "anonymous"),
		rules: [
			/^(?:title\s[^#\n;]+)/i,
			/^(?:accTitle\s*:\s*)/i,
			/^(?:(?!\n||)*[^\n]*)/i,
			/^(?:accDescr\s*:\s*)/i,
			/^(?:(?!\n||)*[^\n]*)/i,
			/^(?:accDescr\s*\{\s*)/i,
			/^(?:[\}])/i,
			/^(?:[^\}]*)/i,
			/^(?:.*direction\s+TB[^\n]*)/i,
			/^(?:.*direction\s+BT[^\n]*)/i,
			/^(?:.*direction\s+RL[^\n]*)/i,
			/^(?:.*direction\s+LR[^\n]*)/i,
			/^(?:(\r?\n)+)/i,
			/^(?:\s+)/i,
			/^(?:#[^\n]*)/i,
			/^(?:%[^\n]*)/i,
			/^(?:$)/i,
			/^(?:requirementDiagram\b)/i,
			/^(?:\{)/i,
			/^(?:\})/i,
			/^(?::{3})/i,
			/^(?::)/i,
			/^(?:id\b)/i,
			/^(?:text\b)/i,
			/^(?:risk\b)/i,
			/^(?:verifyMethod\b)/i,
			/^(?:requirement\b)/i,
			/^(?:functionalRequirement\b)/i,
			/^(?:interfaceRequirement\b)/i,
			/^(?:performanceRequirement\b)/i,
			/^(?:physicalRequirement\b)/i,
			/^(?:designConstraint\b)/i,
			/^(?:low\b)/i,
			/^(?:medium\b)/i,
			/^(?:high\b)/i,
			/^(?:analysis\b)/i,
			/^(?:demonstration\b)/i,
			/^(?:inspection\b)/i,
			/^(?:test\b)/i,
			/^(?:element\b)/i,
			/^(?:contains\b)/i,
			/^(?:copies\b)/i,
			/^(?:derives\b)/i,
			/^(?:satisfies\b)/i,
			/^(?:verifies\b)/i,
			/^(?:refines\b)/i,
			/^(?:traces\b)/i,
			/^(?:type\b)/i,
			/^(?:docref\b)/i,
			/^(?:style\b)/i,
			/^(?:\w+)/i,
			/^(?::)/i,
			/^(?:;)/i,
			/^(?:%)/i,
			/^(?:-)/i,
			/^(?:#)/i,
			/^(?: )/i,
			/^(?:["])/i,
			/^(?:\n)/i,
			/^(?:classDef\b)/i,
			/^(?:class\b)/i,
			/^(?:<-)/i,
			/^(?:->)/i,
			/^(?:-)/i,
			/^(?:["])/i,
			/^(?:["])/i,
			/^(?:[^"]*)/i,
			/^(?:[\w][^:,\r\n\{\<\>\-\=]*)/i,
			/^(?:\w+)/i,
			/^(?:[0-9]+)/i,
			/^(?:,)/i
		],
		conditions: {
			acc_descr_multiline: {
				rules: [
					6,
					7,
					68,
					69,
					70
				],
				inclusive: !1
			},
			acc_descr: {
				rules: [
					4,
					68,
					69,
					70
				],
				inclusive: !1
			},
			acc_title: {
				rules: [
					2,
					68,
					69,
					70
				],
				inclusive: !1
			},
			style: {
				rules: [
					50,
					51,
					52,
					53,
					54,
					55,
					56,
					57,
					58,
					68,
					69,
					70
				],
				inclusive: !1
			},
			unqString: {
				rules: [
					68,
					69,
					70
				],
				inclusive: !1
			},
			token: {
				rules: [
					68,
					69,
					70
				],
				inclusive: !1
			},
			string: {
				rules: [
					65,
					66,
					68,
					69,
					70
				],
				inclusive: !1
			},
			INITIAL: {
				rules: [
					0,
					1,
					3,
					5,
					8,
					9,
					10,
					11,
					12,
					13,
					14,
					15,
					16,
					17,
					18,
					19,
					20,
					21,
					22,
					23,
					24,
					25,
					26,
					27,
					28,
					29,
					30,
					31,
					32,
					33,
					34,
					35,
					36,
					37,
					38,
					39,
					40,
					41,
					42,
					43,
					44,
					45,
					46,
					47,
					48,
					49,
					59,
					60,
					61,
					62,
					63,
					64,
					67,
					68,
					69,
					70
				],
				inclusive: !0
			}
		}
	}, h(eu, "Parser"), eu.prototype = eh, eh.Parser = eu, new eu();
}();
ey2.parser = ey2;
var ey4 = class {
	constructor() {
		this.relations = [], this.latestRequirement = this.getInitialRequirement(), this.requirements = /* @__PURE__ */ new Map(), this.latestElement = this.getInitialElement(), this.elements = /* @__PURE__ */ new Map(), this.classes = /* @__PURE__ */ new Map(), this.direction = "TB", this.RequirementType = {
			REQUIREMENT: "Requirement",
			FUNCTIONAL_REQUIREMENT: "Functional Requirement",
			INTERFACE_REQUIREMENT: "Interface Requirement",
			PERFORMANCE_REQUIREMENT: "Performance Requirement",
			PHYSICAL_REQUIREMENT: "Physical Requirement",
			DESIGN_CONSTRAINT: "Design Constraint"
		}, this.RiskLevel = {
			LOW_RISK: "Low",
			MED_RISK: "Medium",
			HIGH_RISK: "High"
		}, this.VerifyType = {
			VERIFY_ANALYSIS: "Analysis",
			VERIFY_DEMONSTRATION: "Demonstration",
			VERIFY_INSPECTION: "Inspection",
			VERIFY_TEST: "Test"
		}, this.Relationships = {
			CONTAINS: "contains",
			COPIES: "copies",
			DERIVES: "derives",
			SATISFIES: "satisfies",
			VERIFIES: "verifies",
			REFINES: "refines",
			TRACES: "traces"
		}, this.setAccTitle = Da, this.getAccTitle = Ds, this.setAccDescription = Do, this.getAccDescription = Dl, this.setDiagramTitle = Dc, this.getDiagramTitle = Dh, this.getConfig = h(() => IA().requirement, "getConfig"), this.clear(), this.setDirection = this.setDirection.bind(this), this.addRequirement = this.addRequirement.bind(this), this.setNewReqId = this.setNewReqId.bind(this), this.setNewReqRisk = this.setNewReqRisk.bind(this), this.setNewReqText = this.setNewReqText.bind(this), this.setNewReqVerifyMethod = this.setNewReqVerifyMethod.bind(this), this.addElement = this.addElement.bind(this), this.setNewElementType = this.setNewElementType.bind(this), this.setNewElementDocRef = this.setNewElementDocRef.bind(this), this.addRelationship = this.addRelationship.bind(this), this.setCssStyle = this.setCssStyle.bind(this), this.setClass = this.setClass.bind(this), this.defineClass = this.defineClass.bind(this), this.setAccTitle = this.setAccTitle.bind(this), this.setAccDescription = this.setAccDescription.bind(this);
	}
	static {
		h(this, "RequirementDB");
	}
	getDirection() {
		return this.direction;
	}
	setDirection(e) {
		this.direction = e;
	}
	resetLatestRequirement() {
		this.latestRequirement = this.getInitialRequirement();
	}
	resetLatestElement() {
		this.latestElement = this.getInitialElement();
	}
	getInitialRequirement() {
		return {
			requirementId: "",
			text: "",
			risk: "",
			verifyMethod: "",
			name: "",
			type: "",
			cssStyles: [],
			classes: ["default"]
		};
	}
	getInitialElement() {
		return {
			name: "",
			type: "",
			docRef: "",
			cssStyles: [],
			classes: ["default"]
		};
	}
	addRequirement(e, t) {
		return this.requirements.has(e) || this.requirements.set(e, {
			name: e,
			type: t,
			requirementId: this.latestRequirement.requirementId,
			text: this.latestRequirement.text,
			risk: this.latestRequirement.risk,
			verifyMethod: this.latestRequirement.verifyMethod,
			cssStyles: [],
			classes: ["default"]
		}), this.resetLatestRequirement(), this.requirements.get(e);
	}
	getRequirements() {
		return this.requirements;
	}
	setNewReqId(e) {
		void 0 !== this.latestRequirement && (this.latestRequirement.requirementId = e);
	}
	setNewReqText(e) {
		void 0 !== this.latestRequirement && (this.latestRequirement.text = e);
	}
	setNewReqRisk(e) {
		void 0 !== this.latestRequirement && (this.latestRequirement.risk = e);
	}
	setNewReqVerifyMethod(e) {
		void 0 !== this.latestRequirement && (this.latestRequirement.verifyMethod = e);
	}
	addElement(e) {
		return this.elements.has(e) || (this.elements.set(e, {
			name: e,
			type: this.latestElement.type,
			docRef: this.latestElement.docRef,
			cssStyles: [],
			classes: ["default"]
		}), wQ.info("Added new element: ", e)), this.resetLatestElement(), this.elements.get(e);
	}
	getElements() {
		return this.elements;
	}
	setNewElementType(e) {
		void 0 !== this.latestElement && (this.latestElement.type = e);
	}
	setNewElementDocRef(e) {
		void 0 !== this.latestElement && (this.latestElement.docRef = e);
	}
	addRelationship(e, t, r) {
		this.relations.push({
			type: e,
			src: t,
			dst: r
		});
	}
	getRelationships() {
		return this.relations;
	}
	clear() {
		this.relations = [], this.resetLatestRequirement(), this.requirements = /* @__PURE__ */ new Map(), this.resetLatestElement(), this.elements = /* @__PURE__ */ new Map(), this.classes = /* @__PURE__ */ new Map(), Dn();
	}
	setCssStyle(e, t) {
		for (let r of e) {
			let e = this.requirements.get(r) ?? this.elements.get(r);
			if (!t || !e) return;
			for (let r of t) r.includes(",") ? e.cssStyles.push(...r.split(",")) : e.cssStyles.push(r);
		}
	}
	setClass(e, t) {
		for (let r of e) {
			let e = this.requirements.get(r) ?? this.elements.get(r);
			if (e) for (let r of t) {
				e.classes.push(r);
				let t = this.classes.get(r)?.styles;
				t && e.cssStyles.push(...t);
			}
		}
	}
	defineClass(e, t) {
		for (let r of e) {
			let e = this.classes.get(r);
			void 0 === e && (e = {
				id: r,
				styles: [],
				textStyles: []
			}, this.classes.set(r, e)), t && t.forEach(function(t) {
				if (/color/.exec(t)) {
					let r = t.replace("fill", "bgFill");
					e.textStyles.push(r);
				}
				e.styles.push(t);
			}), this.requirements.forEach((e) => {
				e.classes.includes(r) && e.cssStyles.push(...t.flatMap((e) => e.split(",")));
			}), this.elements.forEach((e) => {
				e.classes.includes(r) && e.cssStyles.push(...t.flatMap((e) => e.split(",")));
			});
		}
	}
	getClasses() {
		return this.classes;
	}
	getData() {
		let e = IA(), t = [], r = [];
		for (let r of this.requirements.values()) r.id = r.name, r.cssStyles = r.cssStyles, r.cssClasses = r.classes.join(" "), r.shape = "requirementBox", r.look = e.look, t.push(r);
		for (let r of this.elements.values()) r.shape = "requirementBox", r.look = e.look, r.id = r.name, r.cssStyles = r.cssStyles, r.cssClasses = r.classes.join(" "), t.push(r);
		for (let t of this.relations) {
			let i = 0, n = t.type === this.Relationships.CONTAINS, a = {
				id: `${t.src}-${t.dst}-${i}`,
				start: this.requirements.get(t.src)?.name ?? this.elements.get(t.src)?.name,
				end: this.requirements.get(t.dst)?.name ?? this.elements.get(t.dst)?.name,
				label: `&lt;&lt;${t.type}&gt;&gt;`,
				classes: "relationshipLine",
				style: ["fill:none", n ? "" : "stroke-dasharray: 10,7"],
				labelpos: "c",
				thickness: "normal",
				type: "normal",
				pattern: n ? "normal" : "dashed",
				arrowTypeStart: n ? "requirement_contains" : "",
				arrowTypeEnd: n ? "" : "requirement_arrow",
				look: e.look
			};
			r.push(a), i++;
		}
		return {
			nodes: t,
			edges: r,
			other: {},
			config: e,
			direction: this.getDirection()
		};
	}
}, ey5 = h((e) => `

  marker {
    fill: ${e.relationColor};
    stroke: ${e.relationColor};
  }

  marker.cross {
    stroke: ${e.lineColor};
  }

  svg {
    font-family: ${e.fontFamily};
    font-size: ${e.fontSize};
  }

  .reqBox {
    fill: ${e.requirementBackground};
    fill-opacity: 1.0;
    stroke: ${e.requirementBorderColor};
    stroke-width: ${e.requirementBorderSize};
  }
  
  .reqTitle, .reqLabel{
    fill:  ${e.requirementTextColor};
  }
  .reqLabelBox {
    fill: ${e.relationLabelBackground};
    fill-opacity: 1.0;
  }

  .req-title-line {
    stroke: ${e.requirementBorderColor};
    stroke-width: ${e.requirementBorderSize};
  }
  .relationshipLine {
    stroke: ${e.relationColor};
    stroke-width: 1;
  }
  .relationshipLabel {
    fill: ${e.relationLabelColor};
  }
  .divider {
    stroke: ${e.nodeBorder};
    stroke-width: 1;
  }
  .label {
    font-family: ${e.fontFamily};
    color: ${e.nodeTextColor || e.textColor};
  }
  .label text,span {
    fill: ${e.nodeTextColor || e.textColor};
    color: ${e.nodeTextColor || e.textColor};
  }
  .labelBkg {
    background-color: ${e.edgeLabelBackground};
  }

`, "getStyles"), ey3 = {};
d(ey3, { draw: () => ey6 });
var ey6 = h(async function(e, t, r, i) {
	wQ.info("REF0:"), wQ.info("Drawing requirement diagram (unified)", t);
	let { securityLevel: n, state: a, layout: s } = IA(), o = i.db.getData(), l = JW(t, n);
	o.type = i.type, o.layoutAlgorithm = ein(s), o.nodeSpacing = a?.nodeSpacing ?? 50, o.rankSpacing = a?.rankSpacing ?? 50, o.markers = ["requirement_contains", "requirement_arrow"], o.diagramId = t, await eii(o, l), V2(l, "requirementDiagramTitleText", a?.titleTopMargin ?? 25, i.db.getDiagramTitle()), JY(l, 8, "requirementDiagram", a?.useMaxWidth ?? !0);
}, "draw"), ey7 = {
	parser: ey2,
	get db() {
		return new ey4();
	},
	renderer: ey3,
	styles: ey5
}, ey8 = function() {
	var e = h(function(e, t, r, i) {
		for (r = r || {}, i = e.length; i--; r[e[i]] = t);
		return r;
	}, "o"), t = [1, 9], r = [1, 10], i = [
		1,
		5,
		10,
		12
	], n = {
		trace: h(function() {}, "trace"),
		yy: {},
		symbols_: {
			error: 2,
			start: 3,
			SANKEY: 4,
			NEWLINE: 5,
			csv: 6,
			opt_eof: 7,
			record: 8,
			csv_tail: 9,
			EOF: 10,
			"field[source]": 11,
			COMMA: 12,
			"field[target]": 13,
			"field[value]": 14,
			field: 15,
			escaped: 16,
			non_escaped: 17,
			DQUOTE: 18,
			ESCAPED_TEXT: 19,
			NON_ESCAPED_TEXT: 20,
			$accept: 0,
			$end: 1
		},
		terminals_: {
			2: "error",
			4: "SANKEY",
			5: "NEWLINE",
			10: "EOF",
			11: "field[source]",
			12: "COMMA",
			13: "field[target]",
			14: "field[value]",
			18: "DQUOTE",
			19: "ESCAPED_TEXT",
			20: "NON_ESCAPED_TEXT"
		},
		productions_: [
			0,
			[3, 4],
			[6, 2],
			[9, 2],
			[9, 0],
			[7, 1],
			[7, 0],
			[8, 5],
			[15, 1],
			[15, 1],
			[16, 3],
			[17, 1]
		],
		performAction: h(function(e, t, r, i, n, a, s) {
			var o = a.length - 1;
			switch (n) {
				case 7:
					let l = i.findOrCreateNode(a[o - 4].trim().replaceAll("\"\"", "\"")), h = i.findOrCreateNode(a[o - 2].trim().replaceAll("\"\"", "\"")), u = parseFloat(a[o].trim());
					i.addLink(l, h, u);
					break;
				case 8:
				case 9:
				case 11:
					this.$ = a[o];
					break;
				case 10: this.$ = a[o - 1];
			}
		}, "anonymous"),
		table: [
			{
				3: 1,
				4: [1, 2]
			},
			{ 1: [3] },
			{ 5: [1, 3] },
			{
				6: 4,
				8: 5,
				15: 6,
				16: 7,
				17: 8,
				18: t,
				20: r
			},
			{
				1: [2, 6],
				7: 11,
				10: [1, 12]
			},
			e(r, [2, 4], {
				9: 13,
				5: [1, 14]
			}),
			{ 12: [1, 15] },
			e(i, [2, 8]),
			e(i, [2, 9]),
			{ 19: [1, 16] },
			e(i, [2, 11]),
			{ 1: [2, 1] },
			{ 1: [2, 5] },
			e(r, [2, 2]),
			{
				6: 17,
				8: 5,
				15: 6,
				16: 7,
				17: 8,
				18: t,
				20: r
			},
			{
				15: 18,
				16: 7,
				17: 8,
				18: t,
				20: r
			},
			{ 18: [1, 19] },
			e(r, [2, 3]),
			{ 12: [1, 20] },
			e(i, [2, 10]),
			{
				15: 21,
				16: 7,
				17: 8,
				18: t,
				20: r
			},
			e([
				1,
				5,
				10
			], [2, 7])
		],
		defaultActions: {
			11: [2, 1],
			12: [2, 5]
		},
		parseError: h(function(e, t) {
			if (t.recoverable) this.trace(e);
			else {
				var r = Error(e);
				throw r.hash = t, r;
			}
		}, "parseError"),
		parse: h(function(e) {
			var t = this, r = [0], i = [], n = [null], a = [], s = this.table, o = "", l = 0, u = 0, d = 0, p = a.slice.call(arguments, 1), f = Object.create(this.lexer), g = {};
			for (var m in this.yy) Object.prototype.hasOwnProperty.call(this.yy, m) && (g[m] = this.yy[m]);
			f.setInput(e, g), g.lexer = f, g.parser = this, typeof f.yylloc > "u" && (f.yylloc = {});
			var y = f.yylloc;
			a.push(y);
			var v = f.options && f.options.ranges;
			function x() {
				var e;
				return "number" != typeof (e = i.pop() || f.lex() || 1) && (e instanceof Array && (e = (i = e).pop()), e = t.symbols_[e] || e), e;
			}
			"function" == typeof g.parseError ? this.parseError = g.parseError : this.parseError = Object.getPrototypeOf(this).parseError, h(function(e) {
				r.length = r.length - 2 * e, n.length = n.length - e, a.length = a.length - e;
			}, "popStack"), h(x, "lex");
			for (var b, w, k, T, _, E, C, S, A, L = {};;) {
				if (k = r[r.length - 1], this.defaultActions[k] ? T = this.defaultActions[k] : ((null === b || typeof b > "u") && (b = x()), T = s[k] && s[k][b]), typeof T > "u" || !T.length || !T[0]) {
					var R = "";
					for (E in A = [], s[k]) this.terminals_[E] && E > 2 && A.push("'" + this.terminals_[E] + "'");
					R = f.showPosition ? "Parse error on line " + (l + 1) + `:
` + f.showPosition() + `
Expecting ` + A.join(", ") + ", got '" + (this.terminals_[b] || b) + "'" : "Parse error on line " + (l + 1) + ": Unexpected " + (1 == b ? "end of input" : "'" + (this.terminals_[b] || b) + "'"), this.parseError(R, {
						text: f.match,
						token: this.terminals_[b] || b,
						line: f.yylineno,
						loc: y,
						expected: A
					});
				}
				if (T[0] instanceof Array && T.length > 1) throw Error("Parse Error: multiple actions possible at state: " + k + ", token: " + b);
				switch (T[0]) {
					case 1:
						r.push(b), n.push(f.yytext), a.push(f.yylloc), r.push(T[1]), b = null, w ? (b = w, w = null) : (u = f.yyleng, o = f.yytext, l = f.yylineno, y = f.yylloc, d > 0 && d--);
						break;
					case 2:
						if (C = this.productions_[T[1]][1], L.$ = n[n.length - C], L._$ = {
							first_line: a[a.length - (C || 1)].first_line,
							last_line: a[a.length - 1].last_line,
							first_column: a[a.length - (C || 1)].first_column,
							last_column: a[a.length - 1].last_column
						}, v && (L._$.range = [a[a.length - (C || 1)].range[0], a[a.length - 1].range[1]]), "u" > typeof (_ = this.performAction.apply(L, [
							o,
							u,
							l,
							g,
							T[1],
							n,
							a
						].concat(p)))) return _;
						C && (r = r.slice(0, -1 * C * 2), n = n.slice(0, -1 * C), a = a.slice(0, -1 * C)), r.push(this.productions_[T[1]][0]), n.push(L.$), a.push(L._$), S = s[r[r.length - 2]][r[r.length - 1]], r.push(S);
						break;
					case 3: return !0;
				}
			}
			return !0;
		}, "parse")
	};
	function a() {
		this.yy = {};
	}
	return n.lexer = {
		EOF: 1,
		parseError: h(function(e, t) {
			if (this.yy.parser) this.yy.parser.parseError(e, t);
			else throw Error(e);
		}, "parseError"),
		setInput: h(function(e, t) {
			return this.yy = t || this.yy || {}, this._input = e, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
				first_line: 1,
				first_column: 0,
				last_line: 1,
				last_column: 0
			}, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
		}, "setInput"),
		input: h(function() {
			var e = this._input[0];
			return this.yytext += e, this.yyleng++, this.offset++, this.match += e, this.matched += e, e.match(/(?:\r\n?|\n).*/g) ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), e;
		}, "input"),
		unput: h(function(e) {
			var t = e.length, r = e.split(/(?:\r\n?|\n)/g);
			this._input = e + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - t), this.offset -= t;
			var i = this.match.split(/(?:\r\n?|\n)/g);
			this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), r.length - 1 && (this.yylineno -= r.length - 1);
			var n = this.yylloc.range;
			return this.yylloc = {
				first_line: this.yylloc.first_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.first_column,
				last_column: r ? (r.length === i.length ? this.yylloc.first_column : 0) + i[i.length - r.length].length - r[0].length : this.yylloc.first_column - t
			}, this.options.ranges && (this.yylloc.range = [n[0], n[0] + this.yyleng - t]), this.yyleng = this.yytext.length, this;
		}, "unput"),
		more: h(function() {
			return this._more = !0, this;
		}, "more"),
		reject: h(function() {
			return this.options.backtrack_lexer ? (this._backtrack = !0, this) : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "reject"),
		less: h(function(e) {
			this.unput(this.match.slice(e));
		}, "less"),
		pastInput: h(function() {
			var e = this.matched.substr(0, this.matched.length - this.match.length);
			return (e.length > 20 ? "..." : "") + e.substr(-20).replace(/\n/g, "");
		}, "pastInput"),
		upcomingInput: h(function() {
			var e = this.match;
			return e.length < 20 && (e += this._input.substr(0, 20 - e.length)), (e.substr(0, 20) + (e.length > 20 ? "..." : "")).replace(/\n/g, "");
		}, "upcomingInput"),
		showPosition: h(function() {
			var e = this.pastInput(), t = Array(e.length + 1).join("-");
			return e + this.upcomingInput() + `
` + t + "^";
		}, "showPosition"),
		test_match: h(function(e, t) {
			var r, i, n;
			if (this.options.backtrack_lexer && (n = {
				yylineno: this.yylineno,
				yylloc: {
					first_line: this.yylloc.first_line,
					last_line: this.last_line,
					first_column: this.yylloc.first_column,
					last_column: this.yylloc.last_column
				},
				yytext: this.yytext,
				match: this.match,
				matches: this.matches,
				matched: this.matched,
				yyleng: this.yyleng,
				offset: this.offset,
				_more: this._more,
				_input: this._input,
				yy: this.yy,
				conditionStack: this.conditionStack.slice(0),
				done: this.done
			}, this.options.ranges && (n.yylloc.range = this.yylloc.range.slice(0))), (i = e[0].match(/(?:\r\n?|\n).*/g)) && (this.yylineno += i.length), this.yylloc = {
				first_line: this.yylloc.last_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.last_column,
				last_column: i ? i[i.length - 1].length - i[i.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + e[0].length
			}, this.yytext += e[0], this.match += e[0], this.matches = e, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(e[0].length), this.matched += e[0], r = this.performAction.call(this, this.yy, this, t, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), r) return r;
			if (this._backtrack) for (var a in n) this[a] = n[a];
			return !1;
		}, "test_match"),
		next: h(function() {
			if (this.done) return this.EOF;
			this._input || (this.done = !0), this._more || (this.yytext = "", this.match = "");
			for (var e, t, r, i, n = this._currentRules(), a = 0; a < n.length; a++) if ((r = this._input.match(this.rules[n[a]])) && (!t || r[0].length > t[0].length)) {
				if (t = r, i = a, this.options.backtrack_lexer) {
					if (!1 !== (e = this.test_match(r, n[a]))) return e;
					if (!this._backtrack) return !1;
					t = !1;
					continue;
				} else if (!this.options.flex) break;
			}
			return t ? !1 !== (e = this.test_match(t, n[i])) && e : "" === this._input ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "next"),
		lex: h(function() {
			return this.next() || this.lex();
		}, "lex"),
		begin: h(function(e) {
			this.conditionStack.push(e);
		}, "begin"),
		popState: h(function() {
			return this.conditionStack.length - 1 > 0 ? this.conditionStack.pop() : this.conditionStack[0];
		}, "popState"),
		_currentRules: h(function() {
			return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
		}, "_currentRules"),
		topState: h(function(e) {
			return (e = this.conditionStack.length - 1 - Math.abs(e || 0)) >= 0 ? this.conditionStack[e] : "INITIAL";
		}, "topState"),
		pushState: h(function(e) {
			this.begin(e);
		}, "pushState"),
		stateStackSize: h(function() {
			return this.conditionStack.length;
		}, "stateStackSize"),
		options: { "case-insensitive": !0 },
		performAction: h(function(e, t, r, i) {
			switch (r) {
				case 0:
				case 1: return this.pushState("csv"), 4;
				case 2: return 10;
				case 3: return 5;
				case 4: return 12;
				case 5: return this.pushState("escaped_text"), 18;
				case 6: return 20;
				case 7: return this.popState("escaped_text"), 18;
				case 8: return 19;
			}
		}, "anonymous"),
		rules: [
			/^(?:sankey-beta\b)/i,
			/^(?:sankey\b)/i,
			/^(?:$)/i,
			/^(?:((\u000D\u000A)|(\u000A)))/i,
			/^(?:(\u002C))/i,
			/^(?:(\u0022))/i,
			/^(?:([\u0020-\u0021\u0023-\u002B\u002D-\u007E])*)/i,
			/^(?:(\u0022)(?!(\u0022)))/i,
			/^(?:(([\u0020-\u0021\u0023-\u002B\u002D-\u007E])|(\u002C)|(\u000D)|(\u000A)|(\u0022)(\u0022))*)/i
		],
		conditions: {
			csv: {
				rules: [
					2,
					3,
					4,
					5,
					6,
					7,
					8
				],
				inclusive: !1
			},
			escaped_text: {
				rules: [7, 8],
				inclusive: !1
			},
			INITIAL: {
				rules: [
					0,
					1,
					2,
					3,
					4,
					5,
					6,
					7,
					8
				],
				inclusive: !0
			}
		}
	}, h(a, "Parser"), a.prototype = n, n.Parser = a, new a();
}();
ey8.parser = ey8;
var ey9 = [], eve = [], evt = /* @__PURE__ */ new Map(), evr = h(() => {
	ey9 = [], eve = [], evt = /* @__PURE__ */ new Map(), Dn();
}, "clear"), evi = class {
	constructor(e, t, r = 0) {
		this.source = e, this.target = t, this.value = r;
	}
	static {
		h(this, "SankeyLink");
	}
}, evn = h((e, t, r) => {
	ey9.push(new evi(e, t, r));
}, "addLink"), eva = class {
	constructor(e) {
		this.ID = e;
	}
	static {
		h(this, "SankeyNode");
	}
}, evs = h((e) => {
	e = M1.sanitizeText(e, IA());
	let t = evt.get(e);
	return void 0 === t && (t = new eva(e), evt.set(e, t), eve.push(t)), t;
}, "findOrCreateNode"), evo = h(() => eve, "getNodes"), evl = h(() => ey9, "getLinks"), evc = h(() => ({
	nodes: eve.map((e) => ({ id: e.ID })),
	links: ey9.map((e) => ({
		source: e.source.ID,
		target: e.target.ID,
		value: e.value
	}))
}), "getGraph"), evh = {
	nodesMap: evt,
	getConfig: h(() => IA().sankey, "getConfig"),
	getNodes: evo,
	getLinks: evl,
	getGraph: evc,
	addLink: evn,
	findOrCreateNode: evs,
	getAccTitle: Ds,
	setAccTitle: Da,
	getAccDescription: Dl,
	setAccDescription: Do,
	getDiagramTitle: Dh,
	setDiagramTitle: Dc,
	clear: evr
};
function evu(e, t) {
	let r;
	if (void 0 === t) for (let t of e) null != t && (r < t || void 0 === r && t >= t) && (r = t);
	else {
		let i = -1;
		for (let n of e) null != (n = t(n, ++i, e)) && (r < n || void 0 === r && n >= n) && (r = n);
	}
	return r;
}
function evd(e, t) {
	let r;
	if (void 0 === t) for (let t of e) null != t && (r > t || void 0 === r && t >= t) && (r = t);
	else {
		let i = -1;
		for (let n of e) null != (n = t(n, ++i, e)) && (r > n || void 0 === r && n >= n) && (r = n);
	}
	return r;
}
function evp(e, t) {
	let r = 0;
	if (void 0 === t) for (let t of e) (t *= 1) && (r += t);
	else {
		let i = -1;
		for (let n of e) (n = +t(n, ++i, e)) && (r += n);
	}
	return r;
}
function evf(e) {
	return e.target.depth;
}
function evg(e) {
	return e.depth;
}
function evm(e, t) {
	return t - 1 - e.height;
}
function evy(e, t) {
	return e.sourceLinks.length ? e.depth : t - 1;
}
function evv(e) {
	return e.targetLinks.length ? e.depth : e.sourceLinks.length ? evd(e.sourceLinks, evf) - 1 : 0;
}
function evx(e) {
	return function() {
		return e;
	};
}
function evb(e, t) {
	return evk(e.source, t.source) || e.index - t.index;
}
function evw(e, t) {
	return evk(e.target, t.target) || e.index - t.index;
}
function evk(e, t) {
	return e.y0 - t.y0;
}
function evT(e) {
	return e.value;
}
function ev_(e) {
	return e.index;
}
function evE(e) {
	return e.nodes;
}
function evC(e) {
	return e.links;
}
function evS(e, t) {
	let r = e.get(t);
	if (!r) throw Error("missing: " + t);
	return r;
}
function evA({ nodes: e }) {
	for (let t of e) {
		let e = t.y0, r = e;
		for (let r of t.sourceLinks) r.y0 = e + r.width / 2, e += r.width;
		for (let e of t.targetLinks) e.y1 = r + e.width / 2, r += e.width;
	}
}
function evL() {
	let e = 0, t = 0, r = 1, i = 1, n = 24, a = 8, s, o = ev_, l = evy, u, d, p = evE, f = evC, g = 6;
	function m() {
		let e = {
			nodes: p.apply(null, arguments),
			links: f.apply(null, arguments)
		};
		return y(e), v(e), x(e), b(e), T(e), evA(e), e;
	}
	function y({ nodes: e, links: t }) {
		for (let [t, r] of e.entries()) r.index = t, r.sourceLinks = [], r.targetLinks = [];
		let r = new Map(e.map((t, r) => [o(t, r, e), t]));
		for (let [e, i] of t.entries()) {
			i.index = e;
			let { source: t, target: n } = i;
			"object" != typeof t && (t = i.source = evS(r, t)), "object" != typeof n && (n = i.target = evS(r, n)), t.sourceLinks.push(i), n.targetLinks.push(i);
		}
		if (null != d) for (let { sourceLinks: t, targetLinks: r } of e) t.sort(d), r.sort(d);
	}
	function v({ nodes: e }) {
		for (let t of e) t.value = void 0 === t.fixedValue ? Math.max(evp(t.sourceLinks, evT), evp(t.targetLinks, evT)) : t.fixedValue;
	}
	function x({ nodes: e }) {
		let t = e.length, r = new Set(e), i = /* @__PURE__ */ new Set(), n = 0;
		for (; r.size;) {
			for (let e of r) for (let { target: t } of (e.depth = n, e.sourceLinks)) i.add(t);
			if (++n > t) throw Error("circular link");
			r = i, i = /* @__PURE__ */ new Set();
		}
	}
	function b({ nodes: e }) {
		let t = e.length, r = new Set(e), i = /* @__PURE__ */ new Set(), n = 0;
		for (; r.size;) {
			for (let e of r) for (let { source: t } of (e.height = n, e.targetLinks)) i.add(t);
			if (++n > t) throw Error("circular link");
			r = i, i = /* @__PURE__ */ new Set();
		}
	}
	function w({ nodes: t }) {
		let i = evu(t, (e) => e.depth) + 1, a = (r - e - n) / (i - 1), s = Array(i);
		for (let r of t) {
			let t = Math.max(0, Math.min(i - 1, Math.floor(l.call(null, r, i))));
			r.layer = t, r.x0 = e + t * a, r.x1 = r.x0 + n, s[t] ? s[t].push(r) : s[t] = [r];
		}
		if (u) for (let e of s) e.sort(u);
		return s;
	}
	function k(e) {
		let r = evd(e, (e) => (i - t - (e.length - 1) * s) / evp(e, evT));
		for (let n of e) {
			let e = t;
			for (let t of n) for (let i of (t.y0 = e, t.y1 = e + t.value * r, e = t.y1 + s, t.sourceLinks)) i.width = i.value * r;
			e = (i - e + s) / (n.length + 1);
			for (let t = 0; t < n.length; ++t) {
				let r = n[t];
				r.y0 += e * (t + 1), r.y1 += e * (t + 1);
			}
			R(n);
		}
	}
	function T(e) {
		let r = w(e);
		s = Math.min(a, (i - t) / (evu(r, (e) => e.length) - 1)), k(r);
		for (let e = 0; e < g; ++e) {
			let t = Math.pow(.99, e), i = Math.max(1 - t, (e + 1) / g);
			E(r, t, i), _(r, t, i);
		}
	}
	function _(e, t, r) {
		for (let i = 1, n = e.length; i < n; ++i) {
			let n = e[i];
			for (let e of n) {
				let r = 0, i = 0;
				for (let { source: t, value: n } of e.targetLinks) {
					let a = n * (e.layer - t.layer);
					r += N(t, e) * a, i += a;
				}
				if (!(i > 0)) continue;
				let n = (r / i - e.y0) * t;
				e.y0 += n, e.y1 += n, L(e);
			}
			void 0 === u && n.sort(evk), C(n, r);
		}
	}
	function E(e, t, r) {
		for (let i = e.length - 2; i >= 0; --i) {
			let n = e[i];
			for (let e of n) {
				let r = 0, i = 0;
				for (let { target: t, value: n } of e.sourceLinks) {
					let a = n * (t.layer - e.layer);
					r += I(e, t) * a, i += a;
				}
				if (!(i > 0)) continue;
				let n = (r / i - e.y0) * t;
				e.y0 += n, e.y1 += n, L(e);
			}
			void 0 === u && n.sort(evk), C(n, r);
		}
	}
	function C(e, r) {
		let n = e.length >> 1, a = e[n];
		A(e, a.y0 - s, n - 1, r), S(e, a.y1 + s, n + 1, r), A(e, i, e.length - 1, r), S(e, t, 0, r);
	}
	function S(e, t, r, i) {
		for (; r < e.length; ++r) {
			let n = e[r], a = (t - n.y0) * i;
			a > 1e-6 && (n.y0 += a, n.y1 += a), t = n.y1 + s;
		}
	}
	function A(e, t, r, i) {
		for (; r >= 0; --r) {
			let n = e[r], a = (n.y1 - t) * i;
			a > 1e-6 && (n.y0 -= a, n.y1 -= a), t = n.y0 - s;
		}
	}
	function L({ sourceLinks: e, targetLinks: t }) {
		if (void 0 === d) {
			for (let { source: { sourceLinks: e } } of t) e.sort(evw);
			for (let { target: { targetLinks: t } } of e) t.sort(evb);
		}
	}
	function R(e) {
		if (void 0 === d) for (let { sourceLinks: t, targetLinks: r } of e) t.sort(evw), r.sort(evb);
	}
	function N(e, t) {
		let r = e.y0 - (e.sourceLinks.length - 1) * s / 2;
		for (let { target: i, width: n } of e.sourceLinks) {
			if (i === t) break;
			r += n + s;
		}
		for (let { source: i, width: n } of t.targetLinks) {
			if (i === e) break;
			r -= n;
		}
		return r;
	}
	function I(e, t) {
		let r = t.y0 - (t.targetLinks.length - 1) * s / 2;
		for (let { source: i, width: n } of t.targetLinks) {
			if (i === e) break;
			r += n + s;
		}
		for (let { target: i, width: n } of e.sourceLinks) {
			if (i === t) break;
			r -= n;
		}
		return r;
	}
	return h(m, "sankey"), m.update = function(e) {
		return evA(e), e;
	}, m.nodeId = function(e) {
		return arguments.length ? (o = "function" == typeof e ? e : evx(e), m) : o;
	}, m.nodeAlign = function(e) {
		return arguments.length ? (l = "function" == typeof e ? e : evx(e), m) : l;
	}, m.nodeSort = function(e) {
		return arguments.length ? (u = e, m) : u;
	}, m.nodeWidth = function(e) {
		return arguments.length ? (n = +e, m) : n;
	}, m.nodePadding = function(e) {
		return arguments.length ? (a = s = +e, m) : a;
	}, m.nodes = function(e) {
		return arguments.length ? (p = "function" == typeof e ? e : evx(e), m) : p;
	}, m.links = function(e) {
		return arguments.length ? (f = "function" == typeof e ? e : evx(e), m) : f;
	}, m.linkSort = function(e) {
		return arguments.length ? (d = e, m) : d;
	}, m.size = function(n) {
		return arguments.length ? (e = t = 0, r = +n[0], i = +n[1], m) : [r - e, i - t];
	}, m.extent = function(n) {
		return arguments.length ? (e = +n[0][0], r = +n[1][0], t = +n[0][1], i = +n[1][1], m) : [[e, t], [r, i]];
	}, m.iterations = function(e) {
		return arguments.length ? (g = +e, m) : g;
	}, h(y, "computeNodeLinks"), h(v, "computeNodeValues"), h(x, "computeNodeDepths"), h(b, "computeNodeHeights"), h(w, "computeNodeLayers"), h(k, "initializeNodeBreadths"), h(T, "computeNodeBreadths"), h(_, "relaxLeftToRight"), h(E, "relaxRightToLeft"), h(C, "resolveCollisions"), h(S, "resolveCollisionsTopToBottom"), h(A, "resolveCollisionsBottomToTop"), h(L, "reorderNodeLinks"), h(R, "reorderLinks"), h(N, "targetTop"), h(I, "sourceTop"), m;
}
h(evu, "max"), h(evd, "min"), h(evp, "sum"), h(evf, "targetDepth"), h(evg, "left"), h(evm, "right"), h(evy, "justify"), h(evv, "center"), h(evx, "constant"), h(evb, "ascendingSourceBreadth"), h(evw, "ascendingTargetBreadth"), h(evk, "ascendingBreadth"), h(evT, "value"), h(ev_, "defaultId"), h(evE, "defaultNodes"), h(evC, "defaultLinks"), h(evS, "find"), h(evA, "computeLinkBreadths"), h(evL, "Sankey");
var evR = Math.PI, evN = 2 * evR, evI = evN - 1e-6;
function evM() {
	this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = "";
}
function evD() {
	return new evM();
}
function evO(e) {
	return h(function() {
		return e;
	}, "constant");
}
function ev$(e) {
	return e[0];
}
function evP(e) {
	return e[1];
}
h(evM, "Path"), h(evD, "path"), evM.prototype = evD.prototype = {
	constructor: evM,
	moveTo: h(function(e, t) {
		this._ += "M" + (this._x0 = this._x1 = +e) + "," + (this._y0 = this._y1 = +t);
	}, "moveTo"),
	closePath: h(function() {
		null !== this._x1 && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
	}, "closePath"),
	lineTo: h(function(e, t) {
		this._ += "L" + (this._x1 = +e) + "," + (this._y1 = +t);
	}, "lineTo"),
	quadraticCurveTo: h(function(e, t, r, i) {
		this._ += "Q" + +e + "," + +t + "," + (this._x1 = +r) + "," + (this._y1 = +i);
	}, "quadraticCurveTo"),
	bezierCurveTo: h(function(e, t, r, i, n, a) {
		this._ += "C" + +e + "," + +t + "," + +r + "," + +i + "," + (this._x1 = +n) + "," + (this._y1 = +a);
	}, "bezierCurveTo"),
	arcTo: h(function(e, t, r, i, n) {
		e *= 1, t *= 1, r *= 1, i *= 1, n *= 1;
		var a = this._x1, s = this._y1, o = r - e, l = i - t, h = a - e, u = s - t, d = h * h + u * u;
		if (n < 0) throw Error("negative radius: " + n);
		if (null === this._x1) this._ += "M" + (this._x1 = e) + "," + (this._y1 = t);
		else if (d > 1e-6) if (Math.abs(u * o - l * h) > 1e-6 && n) {
			var p = r - a, f = i - s, g = o * o + l * l, m = Math.sqrt(g), y = Math.sqrt(d), v = n * Math.tan((evR - Math.acos((g + d - (p * p + f * f)) / (2 * m * y))) / 2), x = v / y, b = v / m;
			Math.abs(x - 1) > 1e-6 && (this._ += "L" + (e + x * h) + "," + (t + x * u)), this._ += "A" + n + "," + n + ",0,0," + +(u * p > h * f) + "," + (this._x1 = e + b * o) + "," + (this._y1 = t + b * l);
		} else this._ += "L" + (this._x1 = e) + "," + (this._y1 = t);
	}, "arcTo"),
	arc: h(function(e, t, r, i, n, a) {
		e *= 1, t *= 1, r *= 1, a = !!a;
		var s = r * Math.cos(i), o = r * Math.sin(i), l = e + s, h = t + o, u = 1 ^ a, d = a ? i - n : n - i;
		if (r < 0) throw Error("negative radius: " + r);
		null === this._x1 ? this._ += "M" + l + "," + h : (Math.abs(this._x1 - l) > 1e-6 || Math.abs(this._y1 - h) > 1e-6) && (this._ += "L" + l + "," + h), r && (d < 0 && (d = d % evN + evN), d > evI ? this._ += "A" + r + "," + r + ",0,1," + u + "," + (e - s) + "," + (t - o) + "A" + r + "," + r + ",0,1," + u + "," + (this._x1 = l) + "," + (this._y1 = h) : d > 1e-6 && (this._ += "A" + r + "," + r + ",0," + +(d >= evR) + "," + u + "," + (this._x1 = e + r * Math.cos(n)) + "," + (this._y1 = t + r * Math.sin(n))));
	}, "arc"),
	rect: h(function(e, t, r, i) {
		this._ += "M" + (this._x0 = this._x1 = +e) + "," + (this._y0 = this._y1 = +t) + "h" + +r + "v" + +i + "h" + -r + "Z";
	}, "rect"),
	toString: h(function() {
		return this._;
	}, "toString")
}, h(evO, "default"), h(ev$, "x"), h(evP, "y");
var evB = Array.prototype.slice;
function evF(e) {
	return e.source;
}
function evz(e) {
	return e.target;
}
function evU(e) {
	var t = evF, r = evz, i = ev$, n = evP, a = null;
	function s() {
		var s, o = evB.call(arguments), l = t.apply(this, o), h = r.apply(this, o);
		if (a || (a = s = evD()), e(a, +i.apply(this, (o[0] = l, o)), +n.apply(this, o), +i.apply(this, (o[0] = h, o)), +n.apply(this, o)), s) return a = null, s + "" || null;
	}
	return h(s, "link"), s.source = function(e) {
		return arguments.length ? (t = e, s) : t;
	}, s.target = function(e) {
		return arguments.length ? (r = e, s) : r;
	}, s.x = function(e) {
		return arguments.length ? (i = "function" == typeof e ? e : evO(+e), s) : i;
	}, s.y = function(e) {
		return arguments.length ? (n = "function" == typeof e ? e : evO(+e), s) : n;
	}, s.context = function(e) {
		return arguments.length ? (a = e ?? null, s) : a;
	}, s;
}
function evG(e, t, r, i, n) {
	e.moveTo(t, r), e.bezierCurveTo(t = (t + i) / 2, r, t, n, i, n);
}
function evq() {
	return evU(evG);
}
function evj(e) {
	return [e.source.x1, e.y0];
}
function evW(e) {
	return [e.target.x0, e.y1];
}
function evY() {
	return evq().source(evj).target(evW);
}
h(evF, "linkSource"), h(evz, "linkTarget"), h(evU, "link"), h(evG, "curveHorizontal"), h(evq, "linkHorizontal"), h(evj, "horizontalSource"), h(evW, "horizontalTarget"), h(evY, "default");
var evV = class e {
	static {
		h(this, "Uid");
	}
	static {
		this.count = 0;
	}
	static next(t) {
		return new e(t + ++e.count);
	}
	constructor(e) {
		this.id = e, this.href = `#${e}`;
	}
	toString() {
		return "url(" + this.href + ")";
	}
}, evH = {
	left: evg,
	right: evm,
	center: evv,
	justify: evy
}, evX = { draw: h(function(e, t, r, i) {
	let n, { securityLevel: a, sankey: s } = IA(), o = Iv.sankey, l;
	"sandbox" === a && (l = _t("#i" + t));
	let u = "sandbox" === a ? _t(l.nodes()[0].contentDocument.body) : _t("body"), d = "sandbox" === a ? u.select(`[id="${t}"]`) : _t(`[id="${t}"]`), p = s?.width ?? o.width, f = s?.height ?? o.width, g = s?.useMaxWidth ?? o.useMaxWidth, m = s?.nodeAlignment ?? o.nodeAlignment, y = s?.prefix ?? o.prefix, v = s?.suffix ?? o.suffix, x = s?.showValues ?? o.showValues, b = i.db.getGraph(), w = evH[m];
	evL().nodeId((e) => e.id).nodeWidth(10).nodePadding(10 + 15 * !!x).nodeAlign(w).extent([[0, 0], [p, f]])(b);
	let k = Cm(AT);
	d.append("g").attr("class", "nodes").selectAll(".node").data(b.nodes).join("g").attr("class", "node").attr("id", (e) => (e.uid = evV.next("node-")).id).attr("transform", function(e) {
		return "translate(" + e.x0 + "," + e.y0 + ")";
	}).attr("x", (e) => e.x0).attr("y", (e) => e.y0).append("rect").attr("height", (e) => e.y1 - e.y0).attr("width", (e) => e.x1 - e.x0).attr("fill", (e) => k(e.id));
	let T = h(({ id: e, value: t }) => x ? `${e}
${y}${Math.round(100 * t) / 100}${v}` : e, "getText");
	d.append("g").attr("class", "node-labels").attr("font-size", 14).selectAll("text").data(b.nodes).join("text").attr("x", (e) => e.x0 < p / 2 ? e.x1 + 6 : e.x0 - 6).attr("y", (e) => (e.y1 + e.y0) / 2).attr("dy", `${x ? "0" : "0.35"}em`).attr("text-anchor", (e) => e.x0 < p / 2 ? "start" : "end").text(T);
	let _ = d.append("g").attr("class", "links").attr("fill", "none").attr("stroke-opacity", .5).selectAll(".link").data(b.links).join("g").attr("class", "link").style("mix-blend-mode", "multiply"), E = s?.linkColor ?? "gradient";
	if ("gradient" === E) {
		let e = _.append("linearGradient").attr("id", (e) => (e.uid = evV.next("linearGradient-")).id).attr("gradientUnits", "userSpaceOnUse").attr("x1", (e) => e.source.x1).attr("x2", (e) => e.target.x0);
		e.append("stop").attr("offset", "0%").attr("stop-color", (e) => k(e.source.id)), e.append("stop").attr("offset", "100%").attr("stop-color", (e) => k(e.target.id));
	}
	switch (E) {
		case "gradient":
			n = h((e) => e.uid, "coloring");
			break;
		case "source":
			n = h((e) => k(e.source.id), "coloring");
			break;
		case "target":
			n = h((e) => k(e.target.id), "coloring");
			break;
		default: n = E;
	}
	_.append("path").attr("d", evY()).attr("stroke", n).attr("stroke-width", (e) => Math.max(1, e.width)), M3(void 0, d, 0, g);
}, "draw") }, evK = h((e) => e.replaceAll(/^[^\S\n\r]+|[^\S\n\r]+$/g, "").replaceAll(/([\n\r])+/g, `
`).trim(), "prepareTextForParsing"), evZ = h((e) => `.label {
      font-family: ${e.fontFamily};
    }`, "getStyles"), evQ = ey8.parse.bind(ey8);
ey8.parse = (e) => evQ(evK(e));
var evJ = {
	styles: evZ,
	parser: ey8,
	db: evh,
	renderer: evX
}, ev0 = function() {
	var e = h(function(e, t, r, i) {
		for (r = r || {}, i = e.length; i--; r[e[i]] = t);
		return r;
	}, "o"), t = [1, 2], r = [1, 3], i = [1, 4], n = [2, 4], a = [1, 9], s = [1, 11], o = [1, 13], l = [1, 14], u = [1, 16], d = [1, 17], p = [1, 18], f = [1, 24], g = [1, 25], m = [1, 26], y = [1, 27], v = [1, 28], x = [1, 29], b = [1, 30], w = [1, 31], k = [1, 32], T = [1, 33], _ = [1, 34], E = [1, 35], C = [1, 36], S = [1, 37], A = [1, 38], L = [1, 39], R = [1, 41], N = [1, 42], I = [1, 43], M = [1, 44], D = [1, 45], O = [1, 46], $ = [
		1,
		4,
		5,
		13,
		14,
		16,
		18,
		21,
		23,
		29,
		30,
		31,
		33,
		35,
		36,
		37,
		38,
		39,
		41,
		43,
		44,
		46,
		47,
		48,
		49,
		50,
		52,
		53,
		55,
		60,
		61,
		62,
		63,
		71
	], P = [2, 71], B = [
		4,
		5,
		16,
		50,
		52,
		53
	], F = [
		4,
		5,
		13,
		14,
		16,
		18,
		21,
		23,
		29,
		30,
		31,
		33,
		35,
		36,
		37,
		38,
		39,
		41,
		43,
		44,
		46,
		50,
		52,
		53,
		55,
		60,
		61,
		62,
		63,
		71
	], z = [
		4,
		5,
		13,
		14,
		16,
		18,
		21,
		23,
		29,
		30,
		31,
		33,
		35,
		36,
		37,
		38,
		39,
		41,
		43,
		44,
		46,
		49,
		50,
		52,
		53,
		55,
		60,
		61,
		62,
		63,
		71
	], U = [
		4,
		5,
		13,
		14,
		16,
		18,
		21,
		23,
		29,
		30,
		31,
		33,
		35,
		36,
		37,
		38,
		39,
		41,
		43,
		44,
		46,
		48,
		50,
		52,
		53,
		55,
		60,
		61,
		62,
		63,
		71
	], G = [
		4,
		5,
		13,
		14,
		16,
		18,
		21,
		23,
		29,
		30,
		31,
		33,
		35,
		36,
		37,
		38,
		39,
		41,
		43,
		44,
		46,
		47,
		50,
		52,
		53,
		55,
		60,
		61,
		62,
		63,
		71
	], q = [
		69,
		70,
		71
	], j = [1, 127], W = {
		trace: h(function() {}, "trace"),
		yy: {},
		symbols_: {
			error: 2,
			start: 3,
			SPACE: 4,
			NEWLINE: 5,
			SD: 6,
			document: 7,
			line: 8,
			statement: 9,
			box_section: 10,
			box_line: 11,
			participant_statement: 12,
			create: 13,
			box: 14,
			restOfLine: 15,
			end: 16,
			signal: 17,
			autonumber: 18,
			NUM: 19,
			off: 20,
			activate: 21,
			actor: 22,
			deactivate: 23,
			note_statement: 24,
			links_statement: 25,
			link_statement: 26,
			properties_statement: 27,
			details_statement: 28,
			title: 29,
			legacy_title: 30,
			acc_title: 31,
			acc_title_value: 32,
			acc_descr: 33,
			acc_descr_value: 34,
			acc_descr_multiline_value: 35,
			loop: 36,
			rect: 37,
			opt: 38,
			alt: 39,
			else_sections: 40,
			par: 41,
			par_sections: 42,
			par_over: 43,
			critical: 44,
			option_sections: 45,
			break: 46,
			option: 47,
			and: 48,
			else: 49,
			participant: 50,
			AS: 51,
			participant_actor: 52,
			destroy: 53,
			actor_with_config: 54,
			note: 55,
			placement: 56,
			text2: 57,
			over: 58,
			actor_pair: 59,
			links: 60,
			link: 61,
			properties: 62,
			details: 63,
			spaceList: 64,
			",": 65,
			left_of: 66,
			right_of: 67,
			signaltype: 68,
			"+": 69,
			"-": 70,
			ACTOR: 71,
			config_object: 72,
			CONFIG_START: 73,
			CONFIG_CONTENT: 74,
			CONFIG_END: 75,
			SOLID_OPEN_ARROW: 76,
			DOTTED_OPEN_ARROW: 77,
			SOLID_ARROW: 78,
			BIDIRECTIONAL_SOLID_ARROW: 79,
			DOTTED_ARROW: 80,
			BIDIRECTIONAL_DOTTED_ARROW: 81,
			SOLID_CROSS: 82,
			DOTTED_CROSS: 83,
			SOLID_POINT: 84,
			DOTTED_POINT: 85,
			TXT: 86,
			$accept: 0,
			$end: 1
		},
		terminals_: {
			2: "error",
			4: "SPACE",
			5: "NEWLINE",
			6: "SD",
			13: "create",
			14: "box",
			15: "restOfLine",
			16: "end",
			18: "autonumber",
			19: "NUM",
			20: "off",
			21: "activate",
			23: "deactivate",
			29: "title",
			30: "legacy_title",
			31: "acc_title",
			32: "acc_title_value",
			33: "acc_descr",
			34: "acc_descr_value",
			35: "acc_descr_multiline_value",
			36: "loop",
			37: "rect",
			38: "opt",
			39: "alt",
			41: "par",
			43: "par_over",
			44: "critical",
			46: "break",
			47: "option",
			48: "and",
			49: "else",
			50: "participant",
			51: "AS",
			52: "participant_actor",
			53: "destroy",
			55: "note",
			58: "over",
			60: "links",
			61: "link",
			62: "properties",
			63: "details",
			65: ",",
			66: "left_of",
			67: "right_of",
			69: "+",
			70: "-",
			71: "ACTOR",
			73: "CONFIG_START",
			74: "CONFIG_CONTENT",
			75: "CONFIG_END",
			76: "SOLID_OPEN_ARROW",
			77: "DOTTED_OPEN_ARROW",
			78: "SOLID_ARROW",
			79: "BIDIRECTIONAL_SOLID_ARROW",
			80: "DOTTED_ARROW",
			81: "BIDIRECTIONAL_DOTTED_ARROW",
			82: "SOLID_CROSS",
			83: "DOTTED_CROSS",
			84: "SOLID_POINT",
			85: "DOTTED_POINT",
			86: "TXT"
		},
		productions_: [
			0,
			[3, 2],
			[3, 2],
			[3, 2],
			[7, 0],
			[7, 2],
			[8, 2],
			[8, 1],
			[8, 1],
			[10, 0],
			[10, 2],
			[11, 2],
			[11, 1],
			[11, 1],
			[9, 1],
			[9, 2],
			[9, 4],
			[9, 2],
			[9, 4],
			[9, 3],
			[9, 3],
			[9, 2],
			[9, 3],
			[9, 3],
			[9, 2],
			[9, 2],
			[9, 2],
			[9, 2],
			[9, 2],
			[9, 1],
			[9, 1],
			[9, 2],
			[9, 2],
			[9, 1],
			[9, 4],
			[9, 4],
			[9, 4],
			[9, 4],
			[9, 4],
			[9, 4],
			[9, 4],
			[9, 4],
			[45, 1],
			[45, 4],
			[42, 1],
			[42, 4],
			[40, 1],
			[40, 4],
			[12, 5],
			[12, 3],
			[12, 5],
			[12, 3],
			[12, 3],
			[12, 3],
			[24, 4],
			[24, 4],
			[25, 3],
			[26, 3],
			[27, 3],
			[28, 3],
			[64, 2],
			[64, 1],
			[59, 3],
			[59, 1],
			[56, 1],
			[56, 1],
			[17, 5],
			[17, 5],
			[17, 4],
			[54, 2],
			[72, 3],
			[22, 1],
			[68, 1],
			[68, 1],
			[68, 1],
			[68, 1],
			[68, 1],
			[68, 1],
			[68, 1],
			[68, 1],
			[68, 1],
			[68, 1],
			[57, 1]
		],
		performAction: h(function(e, t, r, i, n, a, s) {
			var o = a.length - 1;
			switch (n) {
				case 3: return i.apply(a[o]), a[o];
				case 4:
				case 9:
				case 8:
				case 13:
					this.$ = [];
					break;
				case 5:
				case 10:
					a[o - 1].push(a[o]), this.$ = a[o - 1];
					break;
				case 6:
				case 7:
				case 11:
				case 12:
				case 63:
					this.$ = a[o];
					break;
				case 15:
					a[o].type = "createParticipant", this.$ = a[o];
					break;
				case 16:
					a[o - 1].unshift({
						type: "boxStart",
						boxData: i.parseBoxData(a[o - 2])
					}), a[o - 1].push({
						type: "boxEnd",
						boxText: a[o - 2]
					}), this.$ = a[o - 1];
					break;
				case 18:
					this.$ = {
						type: "sequenceIndex",
						sequenceIndex: Number(a[o - 2]),
						sequenceIndexStep: Number(a[o - 1]),
						sequenceVisible: !0,
						signalType: i.LINETYPE.AUTONUMBER
					};
					break;
				case 19:
					this.$ = {
						type: "sequenceIndex",
						sequenceIndex: Number(a[o - 1]),
						sequenceIndexStep: 1,
						sequenceVisible: !0,
						signalType: i.LINETYPE.AUTONUMBER
					};
					break;
				case 20:
					this.$ = {
						type: "sequenceIndex",
						sequenceVisible: !1,
						signalType: i.LINETYPE.AUTONUMBER
					};
					break;
				case 21:
					this.$ = {
						type: "sequenceIndex",
						sequenceVisible: !0,
						signalType: i.LINETYPE.AUTONUMBER
					};
					break;
				case 22:
					this.$ = {
						type: "activeStart",
						signalType: i.LINETYPE.ACTIVE_START,
						actor: a[o - 1].actor
					};
					break;
				case 23:
					this.$ = {
						type: "activeEnd",
						signalType: i.LINETYPE.ACTIVE_END,
						actor: a[o - 1].actor
					};
					break;
				case 29:
					i.setDiagramTitle(a[o].substring(6)), this.$ = a[o].substring(6);
					break;
				case 30:
					i.setDiagramTitle(a[o].substring(7)), this.$ = a[o].substring(7);
					break;
				case 31:
					this.$ = a[o].trim(), i.setAccTitle(this.$);
					break;
				case 32:
				case 33:
					this.$ = a[o].trim(), i.setAccDescription(this.$);
					break;
				case 34:
					a[o - 1].unshift({
						type: "loopStart",
						loopText: i.parseMessage(a[o - 2]),
						signalType: i.LINETYPE.LOOP_START
					}), a[o - 1].push({
						type: "loopEnd",
						loopText: a[o - 2],
						signalType: i.LINETYPE.LOOP_END
					}), this.$ = a[o - 1];
					break;
				case 35:
					a[o - 1].unshift({
						type: "rectStart",
						color: i.parseMessage(a[o - 2]),
						signalType: i.LINETYPE.RECT_START
					}), a[o - 1].push({
						type: "rectEnd",
						color: i.parseMessage(a[o - 2]),
						signalType: i.LINETYPE.RECT_END
					}), this.$ = a[o - 1];
					break;
				case 36:
					a[o - 1].unshift({
						type: "optStart",
						optText: i.parseMessage(a[o - 2]),
						signalType: i.LINETYPE.OPT_START
					}), a[o - 1].push({
						type: "optEnd",
						optText: i.parseMessage(a[o - 2]),
						signalType: i.LINETYPE.OPT_END
					}), this.$ = a[o - 1];
					break;
				case 37:
					a[o - 1].unshift({
						type: "altStart",
						altText: i.parseMessage(a[o - 2]),
						signalType: i.LINETYPE.ALT_START
					}), a[o - 1].push({
						type: "altEnd",
						signalType: i.LINETYPE.ALT_END
					}), this.$ = a[o - 1];
					break;
				case 38:
					a[o - 1].unshift({
						type: "parStart",
						parText: i.parseMessage(a[o - 2]),
						signalType: i.LINETYPE.PAR_START
					}), a[o - 1].push({
						type: "parEnd",
						signalType: i.LINETYPE.PAR_END
					}), this.$ = a[o - 1];
					break;
				case 39:
					a[o - 1].unshift({
						type: "parStart",
						parText: i.parseMessage(a[o - 2]),
						signalType: i.LINETYPE.PAR_OVER_START
					}), a[o - 1].push({
						type: "parEnd",
						signalType: i.LINETYPE.PAR_END
					}), this.$ = a[o - 1];
					break;
				case 40:
					a[o - 1].unshift({
						type: "criticalStart",
						criticalText: i.parseMessage(a[o - 2]),
						signalType: i.LINETYPE.CRITICAL_START
					}), a[o - 1].push({
						type: "criticalEnd",
						signalType: i.LINETYPE.CRITICAL_END
					}), this.$ = a[o - 1];
					break;
				case 41:
					a[o - 1].unshift({
						type: "breakStart",
						breakText: i.parseMessage(a[o - 2]),
						signalType: i.LINETYPE.BREAK_START
					}), a[o - 1].push({
						type: "breakEnd",
						optText: i.parseMessage(a[o - 2]),
						signalType: i.LINETYPE.BREAK_END
					}), this.$ = a[o - 1];
					break;
				case 43:
					this.$ = a[o - 3].concat([{
						type: "option",
						optionText: i.parseMessage(a[o - 1]),
						signalType: i.LINETYPE.CRITICAL_OPTION
					}, a[o]]);
					break;
				case 45:
					this.$ = a[o - 3].concat([{
						type: "and",
						parText: i.parseMessage(a[o - 1]),
						signalType: i.LINETYPE.PAR_AND
					}, a[o]]);
					break;
				case 47:
					this.$ = a[o - 3].concat([{
						type: "else",
						altText: i.parseMessage(a[o - 1]),
						signalType: i.LINETYPE.ALT_ELSE
					}, a[o]]);
					break;
				case 48:
					a[o - 3].draw = "participant", a[o - 3].type = "addParticipant", a[o - 3].description = i.parseMessage(a[o - 1]), this.$ = a[o - 3];
					break;
				case 49:
				case 53:
					a[o - 1].draw = "participant", a[o - 1].type = "addParticipant", this.$ = a[o - 1];
					break;
				case 50:
					a[o - 3].draw = "actor", a[o - 3].type = "addParticipant", a[o - 3].description = i.parseMessage(a[o - 1]), this.$ = a[o - 3];
					break;
				case 51:
					a[o - 1].draw = "actor", a[o - 1].type = "addParticipant", this.$ = a[o - 1];
					break;
				case 52:
					a[o - 1].type = "destroyParticipant", this.$ = a[o - 1];
					break;
				case 54:
					this.$ = [a[o - 1], {
						type: "addNote",
						placement: a[o - 2],
						actor: a[o - 1].actor,
						text: a[o]
					}];
					break;
				case 55:
					a[o - 2] = [].concat(a[o - 1], a[o - 1]).slice(0, 2), a[o - 2][0] = a[o - 2][0].actor, a[o - 2][1] = a[o - 2][1].actor, this.$ = [a[o - 1], {
						type: "addNote",
						placement: i.PLACEMENT.OVER,
						actor: a[o - 2].slice(0, 2),
						text: a[o]
					}];
					break;
				case 56:
					this.$ = [a[o - 1], {
						type: "addLinks",
						actor: a[o - 1].actor,
						text: a[o]
					}];
					break;
				case 57:
					this.$ = [a[o - 1], {
						type: "addALink",
						actor: a[o - 1].actor,
						text: a[o]
					}];
					break;
				case 58:
					this.$ = [a[o - 1], {
						type: "addProperties",
						actor: a[o - 1].actor,
						text: a[o]
					}];
					break;
				case 59:
					this.$ = [a[o - 1], {
						type: "addDetails",
						actor: a[o - 1].actor,
						text: a[o]
					}];
					break;
				case 62:
					this.$ = [a[o - 2], a[o]];
					break;
				case 64:
					this.$ = i.PLACEMENT.LEFTOF;
					break;
				case 65:
					this.$ = i.PLACEMENT.RIGHTOF;
					break;
				case 66:
					this.$ = [
						a[o - 4],
						a[o - 1],
						{
							type: "addMessage",
							from: a[o - 4].actor,
							to: a[o - 1].actor,
							signalType: a[o - 3],
							msg: a[o],
							activate: !0
						},
						{
							type: "activeStart",
							signalType: i.LINETYPE.ACTIVE_START,
							actor: a[o - 1].actor
						}
					];
					break;
				case 67:
					this.$ = [
						a[o - 4],
						a[o - 1],
						{
							type: "addMessage",
							from: a[o - 4].actor,
							to: a[o - 1].actor,
							signalType: a[o - 3],
							msg: a[o]
						},
						{
							type: "activeEnd",
							signalType: i.LINETYPE.ACTIVE_END,
							actor: a[o - 4].actor
						}
					];
					break;
				case 68:
					this.$ = [
						a[o - 3],
						a[o - 1],
						{
							type: "addMessage",
							from: a[o - 3].actor,
							to: a[o - 1].actor,
							signalType: a[o - 2],
							msg: a[o]
						}
					];
					break;
				case 69:
					this.$ = {
						type: "addParticipant",
						actor: a[o - 1],
						config: a[o]
					};
					break;
				case 70:
					this.$ = a[o - 1].trim();
					break;
				case 71:
					this.$ = {
						type: "addParticipant",
						actor: a[o]
					};
					break;
				case 72:
					this.$ = i.LINETYPE.SOLID_OPEN;
					break;
				case 73:
					this.$ = i.LINETYPE.DOTTED_OPEN;
					break;
				case 74:
					this.$ = i.LINETYPE.SOLID;
					break;
				case 75:
					this.$ = i.LINETYPE.BIDIRECTIONAL_SOLID;
					break;
				case 76:
					this.$ = i.LINETYPE.DOTTED;
					break;
				case 77:
					this.$ = i.LINETYPE.BIDIRECTIONAL_DOTTED;
					break;
				case 78:
					this.$ = i.LINETYPE.SOLID_CROSS;
					break;
				case 79:
					this.$ = i.LINETYPE.DOTTED_CROSS;
					break;
				case 80:
					this.$ = i.LINETYPE.SOLID_POINT;
					break;
				case 81:
					this.$ = i.LINETYPE.DOTTED_POINT;
					break;
				case 82: this.$ = i.parseMessage(a[o].trim().substring(1));
			}
		}, "anonymous"),
		table: [
			{
				3: 1,
				4: t,
				5: r,
				6: i
			},
			{ 1: [3] },
			{
				3: 5,
				4: t,
				5: r,
				6: i
			},
			{
				3: 6,
				4: t,
				5: r,
				6: i
			},
			e([
				1,
				4,
				5,
				13,
				14,
				18,
				21,
				23,
				29,
				30,
				31,
				33,
				35,
				36,
				37,
				38,
				39,
				41,
				43,
				44,
				46,
				50,
				52,
				53,
				55,
				60,
				61,
				62,
				63,
				71
			], n, { 7: 7 }),
			{ 1: [2, 1] },
			{ 1: [2, 2] },
			{
				1: [2, 3],
				4: a,
				5: s,
				8: 8,
				9: 10,
				12: 12,
				13: o,
				14: l,
				17: 15,
				18: u,
				21: d,
				22: 40,
				23: p,
				24: 19,
				25: 20,
				26: 21,
				27: 22,
				28: 23,
				29: f,
				30: g,
				31: m,
				33: y,
				35: v,
				36: x,
				37: b,
				38: w,
				39: k,
				41: T,
				43: _,
				44: E,
				46: C,
				50: S,
				52: A,
				53: L,
				55: R,
				60: N,
				61: I,
				62: M,
				63: D,
				71: O
			},
			e($, [2, 5]),
			{
				9: 47,
				12: 12,
				13: o,
				14: l,
				17: 15,
				18: u,
				21: d,
				22: 40,
				23: p,
				24: 19,
				25: 20,
				26: 21,
				27: 22,
				28: 23,
				29: f,
				30: g,
				31: m,
				33: y,
				35: v,
				36: x,
				37: b,
				38: w,
				39: k,
				41: T,
				43: _,
				44: E,
				46: C,
				50: S,
				52: A,
				53: L,
				55: R,
				60: N,
				61: I,
				62: M,
				63: D,
				71: O
			},
			e($, [2, 7]),
			e($, [2, 8]),
			e($, [2, 14]),
			{
				12: 48,
				50: S,
				52: A,
				53: L
			},
			{ 15: [1, 49] },
			{ 5: [1, 50] },
			{
				5: [1, 53],
				19: [1, 51],
				20: [1, 52]
			},
			{
				22: 54,
				71: O
			},
			{
				22: 55,
				71: O
			},
			{ 5: [1, 56] },
			{ 5: [1, 57] },
			{ 5: [1, 58] },
			{ 5: [1, 59] },
			{ 5: [1, 60] },
			e($, [2, 29]),
			e($, [2, 30]),
			{ 32: [1, 61] },
			{ 34: [1, 62] },
			e($, [2, 33]),
			{ 15: [1, 63] },
			{ 15: [1, 64] },
			{ 15: [1, 65] },
			{ 15: [1, 66] },
			{ 15: [1, 67] },
			{ 15: [1, 68] },
			{ 15: [1, 69] },
			{ 15: [1, 70] },
			{
				22: 71,
				54: 72,
				71: [1, 73]
			},
			{
				22: 74,
				71: O
			},
			{
				22: 75,
				71: O
			},
			{
				68: 76,
				76: [1, 77],
				77: [1, 78],
				78: [1, 79],
				79: [1, 80],
				80: [1, 81],
				81: [1, 82],
				82: [1, 83],
				83: [1, 84],
				84: [1, 85],
				85: [1, 86]
			},
			{
				56: 87,
				58: [1, 88],
				66: [1, 89],
				67: [1, 90]
			},
			{
				22: 91,
				71: O
			},
			{
				22: 92,
				71: O
			},
			{
				22: 93,
				71: O
			},
			{
				22: 94,
				71: O
			},
			e([
				5,
				51,
				65,
				76,
				77,
				78,
				79,
				80,
				81,
				82,
				83,
				84,
				85,
				86
			], P),
			e($, [2, 6]),
			e($, [2, 15]),
			e(B, [2, 9], { 10: 95 }),
			e($, [2, 17]),
			{
				5: [1, 97],
				19: [1, 96]
			},
			{ 5: [1, 98] },
			e($, [2, 21]),
			{ 5: [1, 99] },
			{ 5: [1, 100] },
			e($, [2, 24]),
			e($, [2, 25]),
			e($, [2, 26]),
			e($, [2, 27]),
			e($, [2, 28]),
			e($, [2, 31]),
			e($, [2, 32]),
			e(F, n, { 7: 101 }),
			e(F, n, { 7: 102 }),
			e(F, n, { 7: 103 }),
			e(z, n, {
				40: 104,
				7: 105
			}),
			e(U, n, {
				42: 106,
				7: 107
			}),
			e(U, n, {
				7: 107,
				42: 108
			}),
			e(G, n, {
				45: 109,
				7: 110
			}),
			e(F, n, { 7: 111 }),
			{
				5: [1, 113],
				51: [1, 112]
			},
			{ 5: [1, 114] },
			e([5, 51], P, {
				72: 115,
				73: [1, 116]
			}),
			{
				5: [1, 118],
				51: [1, 117]
			},
			{ 5: [1, 119] },
			{
				22: 122,
				69: [1, 120],
				70: [1, 121],
				71: O
			},
			e(q, [2, 72]),
			e(q, [2, 73]),
			e(q, [2, 74]),
			e(q, [2, 75]),
			e(q, [2, 76]),
			e(q, [2, 77]),
			e(q, [2, 78]),
			e(q, [2, 79]),
			e(q, [2, 80]),
			e(q, [2, 81]),
			{
				22: 123,
				71: O
			},
			{
				22: 125,
				59: 124,
				71: O
			},
			{ 71: [2, 64] },
			{ 71: [2, 65] },
			{
				57: 126,
				86: j
			},
			{
				57: 128,
				86: j
			},
			{
				57: 129,
				86: j
			},
			{
				57: 130,
				86: j
			},
			{
				4: [1, 133],
				5: [1, 135],
				11: 132,
				12: 134,
				16: [1, 131],
				50: S,
				52: A,
				53: L
			},
			{ 5: [1, 136] },
			e($, [2, 19]),
			e($, [2, 20]),
			e($, [2, 22]),
			e($, [2, 23]),
			{
				4: a,
				5: s,
				8: 8,
				9: 10,
				12: 12,
				13: o,
				14: l,
				16: [1, 137],
				17: 15,
				18: u,
				21: d,
				22: 40,
				23: p,
				24: 19,
				25: 20,
				26: 21,
				27: 22,
				28: 23,
				29: f,
				30: g,
				31: m,
				33: y,
				35: v,
				36: x,
				37: b,
				38: w,
				39: k,
				41: T,
				43: _,
				44: E,
				46: C,
				50: S,
				52: A,
				53: L,
				55: R,
				60: N,
				61: I,
				62: M,
				63: D,
				71: O
			},
			{
				4: a,
				5: s,
				8: 8,
				9: 10,
				12: 12,
				13: o,
				14: l,
				16: [1, 138],
				17: 15,
				18: u,
				21: d,
				22: 40,
				23: p,
				24: 19,
				25: 20,
				26: 21,
				27: 22,
				28: 23,
				29: f,
				30: g,
				31: m,
				33: y,
				35: v,
				36: x,
				37: b,
				38: w,
				39: k,
				41: T,
				43: _,
				44: E,
				46: C,
				50: S,
				52: A,
				53: L,
				55: R,
				60: N,
				61: I,
				62: M,
				63: D,
				71: O
			},
			{
				4: a,
				5: s,
				8: 8,
				9: 10,
				12: 12,
				13: o,
				14: l,
				16: [1, 139],
				17: 15,
				18: u,
				21: d,
				22: 40,
				23: p,
				24: 19,
				25: 20,
				26: 21,
				27: 22,
				28: 23,
				29: f,
				30: g,
				31: m,
				33: y,
				35: v,
				36: x,
				37: b,
				38: w,
				39: k,
				41: T,
				43: _,
				44: E,
				46: C,
				50: S,
				52: A,
				53: L,
				55: R,
				60: N,
				61: I,
				62: M,
				63: D,
				71: O
			},
			{ 16: [1, 140] },
			{
				4: a,
				5: s,
				8: 8,
				9: 10,
				12: 12,
				13: o,
				14: l,
				16: [2, 46],
				17: 15,
				18: u,
				21: d,
				22: 40,
				23: p,
				24: 19,
				25: 20,
				26: 21,
				27: 22,
				28: 23,
				29: f,
				30: g,
				31: m,
				33: y,
				35: v,
				36: x,
				37: b,
				38: w,
				39: k,
				41: T,
				43: _,
				44: E,
				46: C,
				49: [1, 141],
				50: S,
				52: A,
				53: L,
				55: R,
				60: N,
				61: I,
				62: M,
				63: D,
				71: O
			},
			{ 16: [1, 142] },
			{
				4: a,
				5: s,
				8: 8,
				9: 10,
				12: 12,
				13: o,
				14: l,
				16: [2, 44],
				17: 15,
				18: u,
				21: d,
				22: 40,
				23: p,
				24: 19,
				25: 20,
				26: 21,
				27: 22,
				28: 23,
				29: f,
				30: g,
				31: m,
				33: y,
				35: v,
				36: x,
				37: b,
				38: w,
				39: k,
				41: T,
				43: _,
				44: E,
				46: C,
				48: [1, 143],
				50: S,
				52: A,
				53: L,
				55: R,
				60: N,
				61: I,
				62: M,
				63: D,
				71: O
			},
			{ 16: [1, 144] },
			{ 16: [1, 145] },
			{
				4: a,
				5: s,
				8: 8,
				9: 10,
				12: 12,
				13: o,
				14: l,
				16: [2, 42],
				17: 15,
				18: u,
				21: d,
				22: 40,
				23: p,
				24: 19,
				25: 20,
				26: 21,
				27: 22,
				28: 23,
				29: f,
				30: g,
				31: m,
				33: y,
				35: v,
				36: x,
				37: b,
				38: w,
				39: k,
				41: T,
				43: _,
				44: E,
				46: C,
				47: [1, 146],
				50: S,
				52: A,
				53: L,
				55: R,
				60: N,
				61: I,
				62: M,
				63: D,
				71: O
			},
			{
				4: a,
				5: s,
				8: 8,
				9: 10,
				12: 12,
				13: o,
				14: l,
				16: [1, 147],
				17: 15,
				18: u,
				21: d,
				22: 40,
				23: p,
				24: 19,
				25: 20,
				26: 21,
				27: 22,
				28: 23,
				29: f,
				30: g,
				31: m,
				33: y,
				35: v,
				36: x,
				37: b,
				38: w,
				39: k,
				41: T,
				43: _,
				44: E,
				46: C,
				50: S,
				52: A,
				53: L,
				55: R,
				60: N,
				61: I,
				62: M,
				63: D,
				71: O
			},
			{ 15: [1, 148] },
			e($, [2, 49]),
			e($, [2, 53]),
			{ 5: [2, 69] },
			{ 74: [1, 149] },
			{ 15: [1, 150] },
			e($, [2, 51]),
			e($, [2, 52]),
			{
				22: 151,
				71: O
			},
			{
				22: 152,
				71: O
			},
			{
				57: 153,
				86: j
			},
			{
				57: 154,
				86: j
			},
			{
				57: 155,
				86: j
			},
			{
				65: [1, 156],
				86: [2, 63]
			},
			{ 5: [2, 56] },
			{ 5: [2, 82] },
			{ 5: [2, 57] },
			{ 5: [2, 58] },
			{ 5: [2, 59] },
			e($, [2, 16]),
			e(B, [2, 10]),
			{
				12: 157,
				50: S,
				52: A,
				53: L
			},
			e(B, [2, 12]),
			e(B, [2, 13]),
			e($, [2, 18]),
			e($, [2, 34]),
			e($, [2, 35]),
			e($, [2, 36]),
			e($, [2, 37]),
			{ 15: [1, 158] },
			e($, [2, 38]),
			{ 15: [1, 159] },
			e($, [2, 39]),
			e($, [2, 40]),
			{ 15: [1, 160] },
			e($, [2, 41]),
			{ 5: [1, 161] },
			{ 75: [1, 162] },
			{ 5: [1, 163] },
			{
				57: 164,
				86: j
			},
			{
				57: 165,
				86: j
			},
			{ 5: [2, 68] },
			{ 5: [2, 54] },
			{ 5: [2, 55] },
			{
				22: 166,
				71: O
			},
			e(B, [2, 11]),
			e(z, n, {
				7: 105,
				40: 167
			}),
			e(U, n, {
				7: 107,
				42: 168
			}),
			e(G, n, {
				7: 110,
				45: 169
			}),
			e($, [2, 48]),
			{ 5: [2, 70] },
			e($, [2, 50]),
			{ 5: [2, 66] },
			{ 5: [2, 67] },
			{ 86: [2, 62] },
			{ 16: [2, 47] },
			{ 16: [2, 45] },
			{ 16: [2, 43] }
		],
		defaultActions: {
			5: [2, 1],
			6: [2, 2],
			89: [2, 64],
			90: [2, 65],
			115: [2, 69],
			126: [2, 56],
			127: [2, 82],
			128: [2, 57],
			129: [2, 58],
			130: [2, 59],
			153: [2, 68],
			154: [2, 54],
			155: [2, 55],
			162: [2, 70],
			164: [2, 66],
			165: [2, 67],
			166: [2, 62],
			167: [2, 47],
			168: [2, 45],
			169: [2, 43]
		},
		parseError: h(function(e, t) {
			if (t.recoverable) this.trace(e);
			else {
				var r = Error(e);
				throw r.hash = t, r;
			}
		}, "parseError"),
		parse: h(function(e) {
			var t = this, r = [0], i = [], n = [null], a = [], s = this.table, o = "", l = 0, u = 0, d = 0, p = a.slice.call(arguments, 1), f = Object.create(this.lexer), g = {};
			for (var m in this.yy) Object.prototype.hasOwnProperty.call(this.yy, m) && (g[m] = this.yy[m]);
			f.setInput(e, g), g.lexer = f, g.parser = this, typeof f.yylloc > "u" && (f.yylloc = {});
			var y = f.yylloc;
			a.push(y);
			var v = f.options && f.options.ranges;
			function x() {
				var e;
				return "number" != typeof (e = i.pop() || f.lex() || 1) && (e instanceof Array && (e = (i = e).pop()), e = t.symbols_[e] || e), e;
			}
			"function" == typeof g.parseError ? this.parseError = g.parseError : this.parseError = Object.getPrototypeOf(this).parseError, h(function(e) {
				r.length = r.length - 2 * e, n.length = n.length - e, a.length = a.length - e;
			}, "popStack"), h(x, "lex");
			for (var b, w, k, T, _, E, C, S, A, L = {};;) {
				if (k = r[r.length - 1], this.defaultActions[k] ? T = this.defaultActions[k] : ((null === b || typeof b > "u") && (b = x()), T = s[k] && s[k][b]), typeof T > "u" || !T.length || !T[0]) {
					var R = "";
					for (E in A = [], s[k]) this.terminals_[E] && E > 2 && A.push("'" + this.terminals_[E] + "'");
					R = f.showPosition ? "Parse error on line " + (l + 1) + `:
` + f.showPosition() + `
Expecting ` + A.join(", ") + ", got '" + (this.terminals_[b] || b) + "'" : "Parse error on line " + (l + 1) + ": Unexpected " + (1 == b ? "end of input" : "'" + (this.terminals_[b] || b) + "'"), this.parseError(R, {
						text: f.match,
						token: this.terminals_[b] || b,
						line: f.yylineno,
						loc: y,
						expected: A
					});
				}
				if (T[0] instanceof Array && T.length > 1) throw Error("Parse Error: multiple actions possible at state: " + k + ", token: " + b);
				switch (T[0]) {
					case 1:
						r.push(b), n.push(f.yytext), a.push(f.yylloc), r.push(T[1]), b = null, w ? (b = w, w = null) : (u = f.yyleng, o = f.yytext, l = f.yylineno, y = f.yylloc, d > 0 && d--);
						break;
					case 2:
						if (C = this.productions_[T[1]][1], L.$ = n[n.length - C], L._$ = {
							first_line: a[a.length - (C || 1)].first_line,
							last_line: a[a.length - 1].last_line,
							first_column: a[a.length - (C || 1)].first_column,
							last_column: a[a.length - 1].last_column
						}, v && (L._$.range = [a[a.length - (C || 1)].range[0], a[a.length - 1].range[1]]), "u" > typeof (_ = this.performAction.apply(L, [
							o,
							u,
							l,
							g,
							T[1],
							n,
							a
						].concat(p)))) return _;
						C && (r = r.slice(0, -1 * C * 2), n = n.slice(0, -1 * C), a = a.slice(0, -1 * C)), r.push(this.productions_[T[1]][0]), n.push(L.$), a.push(L._$), S = s[r[r.length - 2]][r[r.length - 1]], r.push(S);
						break;
					case 3: return !0;
				}
			}
			return !0;
		}, "parse")
	};
	function Y() {
		this.yy = {};
	}
	return W.lexer = {
		EOF: 1,
		parseError: h(function(e, t) {
			if (this.yy.parser) this.yy.parser.parseError(e, t);
			else throw Error(e);
		}, "parseError"),
		setInput: h(function(e, t) {
			return this.yy = t || this.yy || {}, this._input = e, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
				first_line: 1,
				first_column: 0,
				last_line: 1,
				last_column: 0
			}, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
		}, "setInput"),
		input: h(function() {
			var e = this._input[0];
			return this.yytext += e, this.yyleng++, this.offset++, this.match += e, this.matched += e, e.match(/(?:\r\n?|\n).*/g) ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), e;
		}, "input"),
		unput: h(function(e) {
			var t = e.length, r = e.split(/(?:\r\n?|\n)/g);
			this._input = e + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - t), this.offset -= t;
			var i = this.match.split(/(?:\r\n?|\n)/g);
			this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), r.length - 1 && (this.yylineno -= r.length - 1);
			var n = this.yylloc.range;
			return this.yylloc = {
				first_line: this.yylloc.first_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.first_column,
				last_column: r ? (r.length === i.length ? this.yylloc.first_column : 0) + i[i.length - r.length].length - r[0].length : this.yylloc.first_column - t
			}, this.options.ranges && (this.yylloc.range = [n[0], n[0] + this.yyleng - t]), this.yyleng = this.yytext.length, this;
		}, "unput"),
		more: h(function() {
			return this._more = !0, this;
		}, "more"),
		reject: h(function() {
			return this.options.backtrack_lexer ? (this._backtrack = !0, this) : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "reject"),
		less: h(function(e) {
			this.unput(this.match.slice(e));
		}, "less"),
		pastInput: h(function() {
			var e = this.matched.substr(0, this.matched.length - this.match.length);
			return (e.length > 20 ? "..." : "") + e.substr(-20).replace(/\n/g, "");
		}, "pastInput"),
		upcomingInput: h(function() {
			var e = this.match;
			return e.length < 20 && (e += this._input.substr(0, 20 - e.length)), (e.substr(0, 20) + (e.length > 20 ? "..." : "")).replace(/\n/g, "");
		}, "upcomingInput"),
		showPosition: h(function() {
			var e = this.pastInput(), t = Array(e.length + 1).join("-");
			return e + this.upcomingInput() + `
` + t + "^";
		}, "showPosition"),
		test_match: h(function(e, t) {
			var r, i, n;
			if (this.options.backtrack_lexer && (n = {
				yylineno: this.yylineno,
				yylloc: {
					first_line: this.yylloc.first_line,
					last_line: this.last_line,
					first_column: this.yylloc.first_column,
					last_column: this.yylloc.last_column
				},
				yytext: this.yytext,
				match: this.match,
				matches: this.matches,
				matched: this.matched,
				yyleng: this.yyleng,
				offset: this.offset,
				_more: this._more,
				_input: this._input,
				yy: this.yy,
				conditionStack: this.conditionStack.slice(0),
				done: this.done
			}, this.options.ranges && (n.yylloc.range = this.yylloc.range.slice(0))), (i = e[0].match(/(?:\r\n?|\n).*/g)) && (this.yylineno += i.length), this.yylloc = {
				first_line: this.yylloc.last_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.last_column,
				last_column: i ? i[i.length - 1].length - i[i.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + e[0].length
			}, this.yytext += e[0], this.match += e[0], this.matches = e, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(e[0].length), this.matched += e[0], r = this.performAction.call(this, this.yy, this, t, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), r) return r;
			if (this._backtrack) for (var a in n) this[a] = n[a];
			return !1;
		}, "test_match"),
		next: h(function() {
			if (this.done) return this.EOF;
			this._input || (this.done = !0), this._more || (this.yytext = "", this.match = "");
			for (var e, t, r, i, n = this._currentRules(), a = 0; a < n.length; a++) if ((r = this._input.match(this.rules[n[a]])) && (!t || r[0].length > t[0].length)) {
				if (t = r, i = a, this.options.backtrack_lexer) {
					if (!1 !== (e = this.test_match(r, n[a]))) return e;
					if (!this._backtrack) return !1;
					t = !1;
					continue;
				} else if (!this.options.flex) break;
			}
			return t ? !1 !== (e = this.test_match(t, n[i])) && e : "" === this._input ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "next"),
		lex: h(function() {
			return this.next() || this.lex();
		}, "lex"),
		begin: h(function(e) {
			this.conditionStack.push(e);
		}, "begin"),
		popState: h(function() {
			return this.conditionStack.length - 1 > 0 ? this.conditionStack.pop() : this.conditionStack[0];
		}, "popState"),
		_currentRules: h(function() {
			return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
		}, "_currentRules"),
		topState: h(function(e) {
			return (e = this.conditionStack.length - 1 - Math.abs(e || 0)) >= 0 ? this.conditionStack[e] : "INITIAL";
		}, "topState"),
		pushState: h(function(e) {
			this.begin(e);
		}, "pushState"),
		stateStackSize: h(function() {
			return this.conditionStack.length;
		}, "stateStackSize"),
		options: { "case-insensitive": !0 },
		performAction: h(function(e, t, r, i) {
			switch (r) {
				case 0:
				case 56:
				case 72: return 5;
				case 1:
				case 2:
				case 3:
				case 4:
				case 5: break;
				case 6: return 19;
				case 7: return this.begin("CONFIG"), 73;
				case 8: return 74;
				case 9: return this.popState(), this.popState(), 75;
				case 10:
				case 57: return t.yytext = t.yytext.trim(), 71;
				case 11:
				case 17: return t.yytext = t.yytext.trim(), this.begin("ALIAS"), 71;
				case 12: return this.begin("LINE"), 14;
				case 13: return this.begin("ID"), 50;
				case 14: return this.begin("ID"), 52;
				case 15: return 13;
				case 16: return this.begin("ID"), 53;
				case 18: return this.popState(), this.popState(), this.begin("LINE"), 51;
				case 19: return this.popState(), this.popState(), 5;
				case 20: return this.begin("LINE"), 36;
				case 21: return this.begin("LINE"), 37;
				case 22: return this.begin("LINE"), 38;
				case 23: return this.begin("LINE"), 39;
				case 24: return this.begin("LINE"), 49;
				case 25: return this.begin("LINE"), 41;
				case 26: return this.begin("LINE"), 43;
				case 27: return this.begin("LINE"), 48;
				case 28: return this.begin("LINE"), 44;
				case 29: return this.begin("LINE"), 47;
				case 30: return this.begin("LINE"), 46;
				case 31: return this.popState(), 15;
				case 32: return 16;
				case 33: return 66;
				case 34: return 67;
				case 35: return 60;
				case 36: return 61;
				case 37: return 62;
				case 38: return 63;
				case 39: return 58;
				case 40: return 55;
				case 41: return this.begin("ID"), 21;
				case 42: return this.begin("ID"), 23;
				case 43: return 29;
				case 44: return 30;
				case 45: return this.begin("acc_title"), 31;
				case 46: return this.popState(), "acc_title_value";
				case 47: return this.begin("acc_descr"), 33;
				case 48: return this.popState(), "acc_descr_value";
				case 49:
					this.begin("acc_descr_multiline");
					break;
				case 50:
					this.popState();
					break;
				case 51: return "acc_descr_multiline_value";
				case 52: return 6;
				case 53: return 18;
				case 54: return 20;
				case 55: return 65;
				case 58: return 78;
				case 59: return 79;
				case 60: return 80;
				case 61: return 81;
				case 62: return 76;
				case 63: return 77;
				case 64: return 82;
				case 65: return 83;
				case 66: return 84;
				case 67: return 85;
				case 68:
				case 69: return 86;
				case 70: return 69;
				case 71: return 70;
				case 73: return "INVALID";
			}
		}, "anonymous"),
		rules: [
			/^(?:[\n]+)/i,
			/^(?:\s+)/i,
			/^(?:((?!\n)\s)+)/i,
			/^(?:#[^\n]*)/i,
			/^(?:%(?!\{)[^\n]*)/i,
			/^(?:[^\}]%%[^\n]*)/i,
			/^(?:[0-9]+(?=[ \n]+))/i,
			/^(?:@\{)/i,
			/^(?:[^\}]+)/i,
			/^(?:\})/i,
			/^(?:[^\<->\->:\n,;@\s]+(?=@\{))/i,
			/^(?:[^\<->\->:\n,;@]+?([\-]*[^\<->\->:\n,;@]+?)*?(?=((?!\n)\s)+as(?!\n)\s|[#\n;]|$))/i,
			/^(?:box\b)/i,
			/^(?:participant\b)/i,
			/^(?:actor\b)/i,
			/^(?:create\b)/i,
			/^(?:destroy\b)/i,
			/^(?:[^<\->\->:\n,;]+?([\-]*[^<\->\->:\n,;]+?)*?(?=((?!\n)\s)+as(?!\n)\s|[#\n;]|$))/i,
			/^(?:as\b)/i,
			/^(?:(?:))/i,
			/^(?:loop\b)/i,
			/^(?:rect\b)/i,
			/^(?:opt\b)/i,
			/^(?:alt\b)/i,
			/^(?:else\b)/i,
			/^(?:par\b)/i,
			/^(?:par_over\b)/i,
			/^(?:and\b)/i,
			/^(?:critical\b)/i,
			/^(?:option\b)/i,
			/^(?:break\b)/i,
			/^(?:(?:[:]?(?:no)?wrap)?[^#\n;]*)/i,
			/^(?:end\b)/i,
			/^(?:left of\b)/i,
			/^(?:right of\b)/i,
			/^(?:links\b)/i,
			/^(?:link\b)/i,
			/^(?:properties\b)/i,
			/^(?:details\b)/i,
			/^(?:over\b)/i,
			/^(?:note\b)/i,
			/^(?:activate\b)/i,
			/^(?:deactivate\b)/i,
			/^(?:title\s[^#\n;]+)/i,
			/^(?:title:\s[^#\n;]+)/i,
			/^(?:accTitle\s*:\s*)/i,
			/^(?:(?!\n||)*[^\n]*)/i,
			/^(?:accDescr\s*:\s*)/i,
			/^(?:(?!\n||)*[^\n]*)/i,
			/^(?:accDescr\s*\{\s*)/i,
			/^(?:[\}])/i,
			/^(?:[^\}]*)/i,
			/^(?:sequenceDiagram\b)/i,
			/^(?:autonumber\b)/i,
			/^(?:off\b)/i,
			/^(?:,)/i,
			/^(?:;)/i,
			/^(?:[^+<\->\->:\n,;]+((?!(-x|--x|-\)|--\)))[\-]*[^\+<\->\->:\n,;]+)*)/i,
			/^(?:->>)/i,
			/^(?:<<->>)/i,
			/^(?:-->>)/i,
			/^(?:<<-->>)/i,
			/^(?:->)/i,
			/^(?:-->)/i,
			/^(?:-[x])/i,
			/^(?:--[x])/i,
			/^(?:-[\)])/i,
			/^(?:--[\)])/i,
			/^(?::(?:(?:no)?wrap)?[^#\n;]*)/i,
			/^(?::)/i,
			/^(?:\+)/i,
			/^(?:-)/i,
			/^(?:$)/i,
			/^(?:.)/i
		],
		conditions: {
			acc_descr_multiline: {
				rules: [50, 51],
				inclusive: !1
			},
			acc_descr: {
				rules: [48],
				inclusive: !1
			},
			acc_title: {
				rules: [46],
				inclusive: !1
			},
			ID: {
				rules: [
					2,
					3,
					7,
					10,
					11,
					17
				],
				inclusive: !1
			},
			ALIAS: {
				rules: [
					2,
					3,
					18,
					19
				],
				inclusive: !1
			},
			LINE: {
				rules: [
					2,
					3,
					31
				],
				inclusive: !1
			},
			CONFIG: {
				rules: [8, 9],
				inclusive: !1
			},
			CONFIG_DATA: {
				rules: [],
				inclusive: !1
			},
			INITIAL: {
				rules: [
					0,
					1,
					3,
					4,
					5,
					6,
					12,
					13,
					14,
					15,
					16,
					20,
					21,
					22,
					23,
					24,
					25,
					26,
					27,
					28,
					29,
					30,
					32,
					33,
					34,
					35,
					36,
					37,
					38,
					39,
					40,
					41,
					42,
					43,
					44,
					45,
					47,
					49,
					52,
					53,
					54,
					55,
					56,
					57,
					58,
					59,
					60,
					61,
					62,
					63,
					64,
					65,
					66,
					67,
					68,
					69,
					70,
					71,
					72,
					73
				],
				inclusive: !0
			}
		}
	}, h(Y, "Parser"), Y.prototype = W, W.Parser = Y, new Y();
}();
ev0.parser = ev0;
var ev1 = {
	SOLID: 0,
	DOTTED: 1,
	NOTE: 2,
	SOLID_CROSS: 3,
	DOTTED_CROSS: 4,
	SOLID_OPEN: 5,
	DOTTED_OPEN: 6,
	LOOP_START: 10,
	LOOP_END: 11,
	ALT_START: 12,
	ALT_ELSE: 13,
	ALT_END: 14,
	OPT_START: 15,
	OPT_END: 16,
	ACTIVE_START: 17,
	ACTIVE_END: 18,
	PAR_START: 19,
	PAR_AND: 20,
	PAR_END: 21,
	RECT_START: 22,
	RECT_END: 23,
	SOLID_POINT: 24,
	DOTTED_POINT: 25,
	AUTONUMBER: 26,
	CRITICAL_START: 27,
	CRITICAL_OPTION: 28,
	CRITICAL_END: 29,
	BREAK_START: 30,
	BREAK_END: 31,
	PAR_OVER_START: 32,
	BIDIRECTIONAL_SOLID: 33,
	BIDIRECTIONAL_DOTTED: 34
}, ev2 = {
	FILLED: 0,
	OPEN: 1
}, ev4 = {
	LEFTOF: 0,
	RIGHTOF: 1,
	OVER: 2
}, ev5 = class {
	constructor() {
		this.state = new eh_(() => ({
			prevActor: void 0,
			actors: /* @__PURE__ */ new Map(),
			createdActors: /* @__PURE__ */ new Map(),
			destroyedActors: /* @__PURE__ */ new Map(),
			boxes: [],
			messages: [],
			notes: [],
			sequenceNumbersEnabled: !1,
			wrapEnabled: void 0,
			currentBox: void 0,
			lastCreated: void 0,
			lastDestroyed: void 0
		})), this.setAccTitle = Da, this.setAccDescription = Do, this.setDiagramTitle = Dc, this.getAccTitle = Ds, this.getAccDescription = Dl, this.getDiagramTitle = Dh, this.apply = this.apply.bind(this), this.parseBoxData = this.parseBoxData.bind(this), this.parseMessage = this.parseMessage.bind(this), this.clear(), this.setWrap(IA().wrap), this.LINETYPE = ev1, this.ARROWTYPE = ev2, this.PLACEMENT = ev4;
	}
	static {
		h(this, "SequenceDB");
	}
	addBox(e) {
		this.state.records.boxes.push({
			name: e.text,
			wrap: e.wrap ?? this.autoWrap(),
			fill: e.color,
			actorKeys: []
		}), this.state.records.currentBox = this.state.records.boxes.slice(-1)[0];
	}
	addActor(e, t, r, i, n) {
		let a = this.state.records.currentBox, s;
		void 0 !== n && (s = elT(n.includes(`
`) ? n + `
` : `{
` + n + `
}`, { schema: eof }));
		i = s?.type ?? i;
		let o = this.state.records.actors.get(e);
		if (o) {
			if (this.state.records.currentBox && o.box && this.state.records.currentBox !== o.box) throw Error(`A same participant should only be defined in one Box: ${o.name} can't be in '${o.box.name}' and in '${this.state.records.currentBox.name}' at the same time.`);
			if (a = o.box ? o.box : this.state.records.currentBox, o.box = a, o && t === o.name && null == r) return;
		}
		if (r?.text ?? (r = {
			text: t,
			type: i
		}), (null == i || null == r.text) && (r = {
			text: t,
			type: i
		}), this.state.records.actors.set(e, {
			box: a,
			name: t,
			description: r.text,
			wrap: r.wrap ?? this.autoWrap(),
			prevActor: this.state.records.prevActor,
			links: {},
			properties: {},
			actorCnt: null,
			rectData: null,
			type: i ?? "participant"
		}), this.state.records.prevActor) {
			let t = this.state.records.actors.get(this.state.records.prevActor);
			t && (t.nextActor = e);
		}
		this.state.records.currentBox && this.state.records.currentBox.actorKeys.push(e), this.state.records.prevActor = e;
	}
	activationCount(e) {
		let t, r = 0;
		if (!e) return 0;
		for (t = 0; t < this.state.records.messages.length; t++) this.state.records.messages[t].type === this.LINETYPE.ACTIVE_START && this.state.records.messages[t].from === e && r++, this.state.records.messages[t].type === this.LINETYPE.ACTIVE_END && this.state.records.messages[t].from === e && r--;
		return r;
	}
	addMessage(e, t, r, i) {
		this.state.records.messages.push({
			id: this.state.records.messages.length.toString(),
			from: e,
			to: t,
			message: r.text,
			wrap: r.wrap ?? this.autoWrap(),
			answer: i
		});
	}
	addSignal(e, t, r, i, n = !1) {
		if (i === this.LINETYPE.ACTIVE_END && 1 > this.activationCount(e ?? "")) {
			let t = Error("Trying to inactivate an inactive participant (" + e + ")");
			throw t.hash = {
				text: "->>-",
				token: "->>-",
				line: "1",
				loc: {
					first_line: 1,
					last_line: 1,
					first_column: 1,
					last_column: 1
				},
				expected: ["'ACTIVE_PARTICIPANT'"]
			}, t;
		}
		return this.state.records.messages.push({
			id: this.state.records.messages.length.toString(),
			from: e,
			to: t,
			message: r?.text ?? "",
			wrap: r?.wrap ?? this.autoWrap(),
			type: i,
			activate: n
		}), !0;
	}
	hasAtLeastOneBox() {
		return this.state.records.boxes.length > 0;
	}
	hasAtLeastOneBoxWithTitle() {
		return this.state.records.boxes.some((e) => e.name);
	}
	getMessages() {
		return this.state.records.messages;
	}
	getBoxes() {
		return this.state.records.boxes;
	}
	getActors() {
		return this.state.records.actors;
	}
	getCreatedActors() {
		return this.state.records.createdActors;
	}
	getDestroyedActors() {
		return this.state.records.destroyedActors;
	}
	getActor(e) {
		return this.state.records.actors.get(e);
	}
	getActorKeys() {
		return [...this.state.records.actors.keys()];
	}
	enableSequenceNumbers() {
		this.state.records.sequenceNumbersEnabled = !0;
	}
	disableSequenceNumbers() {
		this.state.records.sequenceNumbersEnabled = !1;
	}
	showSequenceNumbers() {
		return this.state.records.sequenceNumbersEnabled;
	}
	setWrap(e) {
		this.state.records.wrapEnabled = e;
	}
	extractWrap(e) {
		if (void 0 === e) return {};
		e = e.trim();
		let t = null !== /^:?wrap:/.exec(e) || null === /^:?nowrap:/.exec(e) && void 0;
		return {
			cleanedText: (void 0 === t ? e : e.replace(/^:?(?:no)?wrap:/, "")).trim(),
			wrap: t
		};
	}
	autoWrap() {
		return void 0 !== this.state.records.wrapEnabled ? this.state.records.wrapEnabled : IA().sequence?.wrap ?? !1;
	}
	clear() {
		this.state.reset(), Dn();
	}
	parseMessage(e) {
		let t = e.trim(), { wrap: r, cleanedText: i } = this.extractWrap(t), n = {
			text: i,
			wrap: r
		};
		return wQ.debug(`parseMessage: ${JSON.stringify(n)}`), n;
	}
	parseBoxData(e) {
		let t = /^((?:rgba?|hsla?)\s*\(.*\)|\w*)(.*)$/.exec(e), r = t?.[1] ? t[1].trim() : "transparent", i = t?.[2] ? t[2].trim() : void 0;
		if (window?.CSS) window.CSS.supports("color", r) || (r = "transparent", i = e.trim());
		else {
			let t = new Option().style;
			t.color = r, t.color !== r && (r = "transparent", i = e.trim());
		}
		let { wrap: n, cleanedText: a } = this.extractWrap(i);
		return {
			text: a ? MO(a, IA()) : void 0,
			color: r,
			wrap: n
		};
	}
	addNote(e, t, r) {
		let i = {
			actor: e,
			placement: t,
			message: r.text,
			wrap: r.wrap ?? this.autoWrap()
		}, n = [].concat(e, e);
		this.state.records.notes.push(i), this.state.records.messages.push({
			id: this.state.records.messages.length.toString(),
			from: n[0],
			to: n[1],
			message: r.text,
			wrap: r.wrap ?? this.autoWrap(),
			type: this.LINETYPE.NOTE,
			placement: t
		});
	}
	addLinks(e, t) {
		let r = this.getActor(e);
		try {
			let e = MO(t.text, IA());
			e = (e = e.replace(/&equals;/g, "=")).replace(/&amp;/g, "&");
			let i = JSON.parse(e);
			this.insertLinks(r, i);
		} catch (e) {
			wQ.error("error while parsing actor link text", e);
		}
	}
	addALink(e, t) {
		let r = this.getActor(e);
		try {
			let e = {}, i = MO(t.text, IA()), n = i.indexOf("@");
			e[(i = (i = i.replace(/&equals;/g, "=")).replace(/&amp;/g, "&")).slice(0, n - 1).trim()] = i.slice(n + 1).trim(), this.insertLinks(r, e);
		} catch (e) {
			wQ.error("error while parsing actor link text", e);
		}
	}
	insertLinks(e, t) {
		if (null == e.links) e.links = t;
		else for (let r in t) e.links[r] = t[r];
	}
	addProperties(e, t) {
		let r = this.getActor(e);
		try {
			let e = MO(t.text, IA()), i = JSON.parse(e);
			this.insertProperties(r, i);
		} catch (e) {
			wQ.error("error while parsing actor properties text", e);
		}
	}
	insertProperties(e, t) {
		if (null == e.properties) e.properties = t;
		else for (let r in t) e.properties[r] = t[r];
	}
	boxEnd() {
		this.state.records.currentBox = void 0;
	}
	addDetails(e, t) {
		let r = this.getActor(e), i = document.getElementById(t.text);
		try {
			let e = i.innerHTML, t = JSON.parse(e);
			t.properties && this.insertProperties(r, t.properties), t.links && this.insertLinks(r, t.links);
		} catch (e) {
			wQ.error("error while parsing actor details text", e);
		}
	}
	getActorProperty(e, t) {
		if (e?.properties !== void 0) return e.properties[t];
	}
	apply(e) {
		if (Array.isArray(e)) e.forEach((e) => {
			this.apply(e);
		});
		else switch (e.type) {
			case "sequenceIndex":
				this.state.records.messages.push({
					id: this.state.records.messages.length.toString(),
					from: void 0,
					to: void 0,
					message: {
						start: e.sequenceIndex,
						step: e.sequenceIndexStep,
						visible: e.sequenceVisible
					},
					wrap: !1,
					type: e.signalType
				});
				break;
			case "addParticipant":
				this.addActor(e.actor, e.actor, e.description, e.draw, e.config);
				break;
			case "createParticipant":
				if (this.state.records.actors.has(e.actor)) throw Error("It is not possible to have actors with the same id, even if one is destroyed before the next is created. Use 'AS' aliases to simulate the behavior");
				this.state.records.lastCreated = e.actor, this.addActor(e.actor, e.actor, e.description, e.draw, e.config), this.state.records.createdActors.set(e.actor, this.state.records.messages.length);
				break;
			case "destroyParticipant":
				this.state.records.lastDestroyed = e.actor, this.state.records.destroyedActors.set(e.actor, this.state.records.messages.length);
				break;
			case "activeStart":
			case "activeEnd":
				this.addSignal(e.actor, void 0, void 0, e.signalType);
				break;
			case "addNote":
				this.addNote(e.actor, e.placement, e.text);
				break;
			case "addLinks":
				this.addLinks(e.actor, e.text);
				break;
			case "addALink":
				this.addALink(e.actor, e.text);
				break;
			case "addProperties":
				this.addProperties(e.actor, e.text);
				break;
			case "addDetails":
				this.addDetails(e.actor, e.text);
				break;
			case "addMessage":
				if (this.state.records.lastCreated) {
					if (e.to !== this.state.records.lastCreated) throw Error("The created participant " + this.state.records.lastCreated.name + " does not have an associated creating message after its declaration. Please check the sequence diagram.");
					this.state.records.lastCreated = void 0;
				} else if (this.state.records.lastDestroyed) {
					if (e.to !== this.state.records.lastDestroyed && e.from !== this.state.records.lastDestroyed) throw Error("The destroyed participant " + this.state.records.lastDestroyed.name + " does not have an associated destroying message after its declaration. Please check the sequence diagram.");
					this.state.records.lastDestroyed = void 0;
				}
				this.addSignal(e.from, e.to, e.msg, e.signalType, e.activate);
				break;
			case "boxStart":
				this.addBox(e.boxData);
				break;
			case "boxEnd":
				this.boxEnd();
				break;
			case "loopStart":
				this.addSignal(void 0, void 0, e.loopText, e.signalType);
				break;
			case "loopEnd":
			case "rectEnd":
			case "optEnd":
			case "altEnd":
			case "parEnd":
			case "criticalEnd":
			case "breakEnd":
				this.addSignal(void 0, void 0, void 0, e.signalType);
				break;
			case "rectStart":
				this.addSignal(void 0, void 0, e.color, e.signalType);
				break;
			case "optStart":
				this.addSignal(void 0, void 0, e.optText, e.signalType);
				break;
			case "altStart":
			case "else":
				this.addSignal(void 0, void 0, e.altText, e.signalType);
				break;
			case "setAccTitle":
				Da(e.text);
				break;
			case "parStart":
			case "and":
				this.addSignal(void 0, void 0, e.parText, e.signalType);
				break;
			case "criticalStart":
				this.addSignal(void 0, void 0, e.criticalText, e.signalType);
				break;
			case "option":
				this.addSignal(void 0, void 0, e.optionText, e.signalType);
				break;
			case "breakStart": this.addSignal(void 0, void 0, e.breakText, e.signalType);
		}
	}
	getConfig() {
		return IA().sequence;
	}
}, ev3 = h((e) => `.actor {
    stroke: ${e.actorBorder};
    fill: ${e.actorBkg};
  }

  text.actor > tspan {
    fill: ${e.actorTextColor};
    stroke: none;
  }

  .actor-line {
    stroke: ${e.actorLineColor};
  }
  
  .innerArc {
    stroke-width: 1.5;
    stroke-dasharray: none;
  }

  .messageLine0 {
    stroke-width: 1.5;
    stroke-dasharray: none;
    stroke: ${e.signalColor};
  }

  .messageLine1 {
    stroke-width: 1.5;
    stroke-dasharray: 2, 2;
    stroke: ${e.signalColor};
  }

  #arrowhead path {
    fill: ${e.signalColor};
    stroke: ${e.signalColor};
  }

  .sequenceNumber {
    fill: ${e.sequenceNumberColor};
  }

  #sequencenumber {
    fill: ${e.signalColor};
  }

  #crosshead path {
    fill: ${e.signalColor};
    stroke: ${e.signalColor};
  }

  .messageText {
    fill: ${e.signalTextColor};
    stroke: none;
  }

  .labelBox {
    stroke: ${e.labelBoxBorderColor};
    fill: ${e.labelBoxBkgColor};
  }

  .labelText, .labelText > tspan {
    fill: ${e.labelTextColor};
    stroke: none;
  }

  .loopText, .loopText > tspan {
    fill: ${e.loopTextColor};
    stroke: none;
  }

  .loopLine {
    stroke-width: 2px;
    stroke-dasharray: 2, 2;
    stroke: ${e.labelBoxBorderColor};
    fill: ${e.labelBoxBorderColor};
  }

  .note {
    //stroke: #decc93;
    stroke: ${e.noteBorderColor};
    fill: ${e.noteBkgColor};
  }

  .noteText, .noteText > tspan {
    fill: ${e.noteTextColor};
    stroke: none;
  }

  .activation0 {
    fill: ${e.activationBkgColor};
    stroke: ${e.activationBorderColor};
  }

  .activation1 {
    fill: ${e.activationBkgColor};
    stroke: ${e.activationBorderColor};
  }

  .activation2 {
    fill: ${e.activationBkgColor};
    stroke: ${e.activationBorderColor};
  }

  .actorPopupMenu {
    position: absolute;
  }

  .actorPopupMenuPanel {
    position: absolute;
    fill: ${e.actorBkg};
    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
    filter: drop-shadow(3px 5px 2px rgb(0 0 0 / 0.4));
}
  .actor-man line {
    stroke: ${e.actorBorder};
    fill: ${e.actorBkg};
  }
  .actor-man circle, line {
    stroke: ${e.actorBorder};
    fill: ${e.actorBkg};
    stroke-width: 2px;
  }

`, "getStyles"), ev6 = g(Vk(), 1), ev7 = "actor-top", ev8 = "actor-bottom", ev9 = "actor-box", exe = "actor-man", ext = h(function(e, t) {
	return QS(e, t);
}, "drawRect"), exr = h(function(e, t, r, i, n) {
	if (void 0 === t.links || null === t.links || 0 === Object.keys(t.links).length) return {
		height: 0,
		width: 0
	};
	let a = t.links, s = t.actorCnt, o = t.rectData;
	var l = "none";
	n && (l = "block !important");
	let h = e.append("g");
	h.attr("id", "actor" + s + "_popup"), h.attr("class", "actorPopupMenu"), h.attr("display", l);
	var u = "";
	void 0 !== o.class && (u = " " + o.class);
	let d = o.width > r ? o.width : r, p = h.append("rect");
	if (p.attr("class", "actorPopupMenuPanel" + u), p.attr("x", o.x), p.attr("y", o.height), p.attr("fill", o.fill), p.attr("stroke", o.stroke), p.attr("width", d), p.attr("height", o.height), p.attr("rx", o.rx), p.attr("ry", o.ry), null != a) {
		var f = 20;
		for (let e in a) {
			var g = h.append("a"), m = (0, ev6.sanitizeUrl)(a[e]);
			g.attr("xlink:href", m), g.attr("target", "_blank"), exM(i)(e, g, o.x + 10, o.height + f, d, 20, { class: "actor" }, i), f += 30;
		}
	}
	return p.attr("height", f), {
		height: o.height + f,
		width: d
	};
}, "drawPopup"), exi = h(function(e) {
	return "var pu = document.getElementById('" + e + "'); if (pu != null) { pu.style.display = pu.style.display == 'block' ? 'none' : 'block'; }";
}, "popupMenuToggle"), exn = h(async function(e, t, r = null) {
	let i = e.append("foreignObject"), n = await M0(t.text, IA()), a = i.append("xhtml:div").attr("style", "width: fit-content;").attr("xmlns", "http://www.w3.org/1999/xhtml").html(n).node().getBoundingClientRect();
	if (i.attr("height", Math.round(a.height)).attr("width", Math.round(a.width)), "noteText" === t.class) {
		let r = e.node().firstChild;
		r.setAttribute("height", a.height + 2 * t.textMargin);
		let n = r.getBBox();
		i.attr("x", Math.round(n.x + n.width / 2 - a.width / 2)).attr("y", Math.round(n.y + n.height / 2 - a.height / 2));
	} else if (r) {
		let { startx: e, stopx: n, starty: s } = r;
		if (e > n) {
			let t = e;
			e = n, n = t;
		}
		i.attr("x", Math.round(e + Math.abs(e - n) / 2 - a.width / 2)), "loopText" === t.class ? i.attr("y", Math.round(s)) : i.attr("y", Math.round(s - a.height));
	}
	return [i];
}, "drawKatex"), exa = h(function(e, t) {
	let r = 0, i = 0, n = t.text.split(M1.lineBreakRegex), [a, s] = V4(t.fontSize), o = [], l = 0, u = h(() => t.y, "yfunc");
	if (void 0 !== t.valign && void 0 !== t.textMargin && t.textMargin > 0) switch (t.valign) {
		case "top":
		case "start":
			u = h(() => Math.round(t.y + t.textMargin), "yfunc");
			break;
		case "middle":
		case "center":
			u = h(() => Math.round(t.y + (r + i + t.textMargin) / 2), "yfunc");
			break;
		case "bottom":
		case "end": u = h(() => Math.round(t.y + (r + i + 2 * t.textMargin) - t.textMargin), "yfunc");
	}
	if (void 0 !== t.anchor && void 0 !== t.textMargin && void 0 !== t.width) switch (t.anchor) {
		case "left":
		case "start":
			t.x = Math.round(t.x + t.textMargin), t.anchor = "start", t.dominantBaseline = "middle", t.alignmentBaseline = "middle";
			break;
		case "middle":
		case "center":
			t.x = Math.round(t.x + t.width / 2), t.anchor = "middle", t.dominantBaseline = "middle", t.alignmentBaseline = "middle";
			break;
		case "right":
		case "end": t.x = Math.round(t.x + t.width - t.textMargin), t.anchor = "end", t.dominantBaseline = "middle", t.alignmentBaseline = "middle";
	}
	for (let [h, d] of n.entries()) {
		void 0 !== t.textMargin && 0 === t.textMargin && void 0 !== a && (l = h * a);
		let n = e.append("text");
		n.attr("x", t.x), n.attr("y", u()), void 0 !== t.anchor && n.attr("text-anchor", t.anchor).attr("dominant-baseline", t.dominantBaseline).attr("alignment-baseline", t.alignmentBaseline), void 0 !== t.fontFamily && n.style("font-family", t.fontFamily), void 0 !== s && n.style("font-size", s), void 0 !== t.fontWeight && n.style("font-weight", t.fontWeight), void 0 !== t.fill && n.attr("fill", t.fill), void 0 !== t.class && n.attr("class", t.class), void 0 !== t.dy ? n.attr("dy", t.dy) : 0 !== l && n.attr("dy", l);
		let p = d || "";
		if (t.tspan) {
			let e = n.append("tspan");
			e.attr("x", t.x), void 0 !== t.fill && e.attr("fill", t.fill), e.text(p);
		} else n.text(p);
		void 0 !== t.valign && void 0 !== t.textMargin && t.textMargin > 0 && (i += (n._groups || n)[0][0].getBBox().height, r = i), o.push(n);
	}
	return o;
}, "drawText"), exs = h(function(e, t) {
	function r(e, t, r, i, n) {
		return e + "," + t + " " + (e + r) + "," + t + " " + (e + r) + "," + (t + i - n) + " " + (e + r - 1.2 * n) + "," + (t + i) + " " + e + "," + (t + i);
	}
	h(r, "genPoints");
	let i = e.append("polygon");
	return i.attr("points", r(t.x, t.y, t.width, t.height, 7)), i.attr("class", "labelBox"), t.y = t.y + t.height / 2, exa(e, t), i;
}, "drawLabel"), exo = -1, exl = h((e, t, r, i) => {
	e.select && r.forEach((r) => {
		let n = t.get(r), a = e.select("#actor" + n.actorCnt);
		!i.mirrorActors && n.stopy ? a.attr("y2", n.stopy + n.height / 2) : i.mirrorActors && a.attr("y2", n.stopy);
	});
}, "fixLifeLineHeights"), exc = h(function(e, t, r, i) {
	let n = i ? t.stopy : t.starty, a = t.x + t.width / 2, s = n + t.height, o = e.append("g").lower();
	var l = o;
	i || (exo++, Object.keys(t.links || {}).length && !r.forceMenus && l.attr("onclick", exi(`actor${exo}_popup`)).attr("cursor", "pointer"), l.append("line").attr("id", "actor" + exo).attr("x1", a).attr("y1", s).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", t.name), l = o.append("g"), t.actorCnt = exo, null != t.links && l.attr("id", "root-" + exo));
	let h = QI();
	var u = "actor";
	t.properties?.class ? u = t.properties.class : h.fill = "#eaeaea", i ? u += ` ${ev8}` : u += ` ${ev7}`, h.x = t.x, h.y = n, h.width = t.width, h.height = t.height, h.class = u, h.rx = 3, h.ry = 3, h.name = t.name;
	let d = ext(l, h);
	if (t.rectData = h, t.properties?.icon) {
		let e = t.properties.icon.trim();
		"@" === e.charAt(0) ? QN(l, h.x + h.width - 20, h.y + 10, e.substr(1)) : QR(l, h.x + h.width - 20, h.y + 10, e);
	}
	exI(r, MZ(t.description))(t.description, l, h.x, h.y, h.width, h.height, { class: `actor ${ev9}` }, r);
	let p = t.height;
	if (d.node) {
		let e = d.node().getBBox();
		t.height = e.height, p = e.height;
	}
	return p;
}, "drawActorTypeParticipant"), exh = h(function(e, t, r, i) {
	let n = i ? t.stopy : t.starty, a = t.x + t.width / 2, s = n + t.height, o = e.append("g").lower();
	var l = o;
	i || (exo++, Object.keys(t.links || {}).length && !r.forceMenus && l.attr("onclick", exi(`actor${exo}_popup`)).attr("cursor", "pointer"), l.append("line").attr("id", "actor" + exo).attr("x1", a).attr("y1", s).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", t.name), l = o.append("g"), t.actorCnt = exo, null != t.links && l.attr("id", "root-" + exo));
	let h = QI();
	var u = "actor";
	t.properties?.class ? u = t.properties.class : h.fill = "#eaeaea", i ? u += ` ${ev8}` : u += ` ${ev7}`, h.x = t.x, h.y = n, h.width = t.width, h.height = t.height, h.class = u, h.name = t.name;
	let d = {
		...h,
		x: h.x + -6,
		y: h.y + 6,
		class: "actor"
	}, p = ext(l, h);
	if (ext(l, d), t.rectData = h, t.properties?.icon) {
		let e = t.properties.icon.trim();
		"@" === e.charAt(0) ? QN(l, h.x + h.width - 20, h.y + 10, e.substr(1)) : QR(l, h.x + h.width - 20, h.y + 10, e);
	}
	exI(r, MZ(t.description))(t.description, l, h.x - 6, h.y + 6, h.width, h.height, { class: `actor ${ev9}` }, r);
	let f = t.height;
	if (p.node) {
		let e = p.node().getBBox();
		t.height = e.height, f = e.height;
	}
	return f;
}, "drawActorTypeCollections"), exu = h(function(e, t, r, i) {
	let n = i ? t.stopy : t.starty, a = t.x + t.width / 2, s = n + t.height, o = e.append("g").lower(), l = o;
	i || (exo++, Object.keys(t.links || {}).length && !r.forceMenus && l.attr("onclick", exi(`actor${exo}_popup`)).attr("cursor", "pointer"), l.append("line").attr("id", "actor" + exo).attr("x1", a).attr("y1", s).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", t.name), l = o.append("g"), t.actorCnt = exo, null != t.links && l.attr("id", "root-" + exo));
	let h = QI(), u = "actor";
	t.properties?.class ? u = t.properties.class : h.fill = "#eaeaea", i ? u += ` ${ev8}` : u += ` ${ev7}`, h.x = t.x, h.y = n, h.width = t.width, h.height = t.height, h.class = u, h.name = t.name;
	let d = h.height / 2, p = d / (2.5 + h.height / 50), f = l.append("g"), g = l.append("g");
	if (f.append("path").attr("d", `M ${h.x},${h.y + d}
    a ${p},${d} 0 0 0 0,${h.height}
    h ${h.width - 2 * p}
    a ${p},${d} 0 0 0 0,-${h.height}
    Z
  `).attr("class", u), g.append("path").attr("d", `M ${h.x},${h.y + d}
      a ${p},${d} 0 0 0 0,${h.height}`).attr("stroke", "#666").attr("stroke-width", "1px").attr("class", u), f.attr("transform", `translate(${p}, ${-(h.height / 2)})`), g.attr("transform", `translate(${h.width - p}, ${-h.height / 2})`), t.rectData = h, t.properties?.icon) {
		let e = t.properties.icon.trim(), r = h.x + h.width - 20, i = h.y + 10;
		"@" === e.charAt(0) ? QN(l, r, i, e.substr(1)) : QR(l, r, i, e);
	}
	exI(r, MZ(t.description))(t.description, l, h.x, h.y, h.width, h.height, { class: `actor ${ev9}` }, r);
	let m = t.height, y = f.select("path:last-child");
	if (y.node()) {
		let e = y.node().getBBox();
		t.height = e.height, m = e.height;
	}
	return m;
}, "drawActorTypeQueue"), exd = h(function(e, t, r, i) {
	let n = i ? t.stopy : t.starty, a = t.x + t.width / 2, s = n + 75, o = e.append("g").lower();
	i || (exo++, o.append("line").attr("id", "actor" + exo).attr("x1", a).attr("y1", s).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", t.name), t.actorCnt = exo);
	let l = e.append("g"), h = exe;
	i ? h += ` ${ev8}` : h += ` ${ev7}`, l.attr("class", h), l.attr("name", t.name);
	let u = QI();
	u.x = t.x, u.y = n, u.fill = "#eaeaea", u.width = t.width, u.height = t.height, u.class = "actor";
	let d = t.x + t.width / 2, p = n + 30;
	return l.append("defs").append("marker").attr("id", "filled-head-control").attr("refX", 11).attr("refY", 5.8).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "172.5").append("path").attr("d", "M 14.4 5.6 L 7.2 10.4 L 8.8 5.6 L 7.2 0.8 Z"), l.append("circle").attr("cx", d).attr("cy", p).attr("r", 18).attr("fill", "#eaeaf7").attr("stroke", "#666").attr("stroke-width", 1.2), l.append("line").attr("marker-end", "url(#filled-head-control)").attr("transform", `translate(${d}, ${p - 18})`), t.height = l.node().getBBox().height + 2 * (r?.sequence?.labelBoxHeight ?? 0), exI(r, MZ(t.description))(t.description, l, u.x, u.y + 18 + (i ? 5 : 10), u.width, u.height, { class: `actor ${exe}` }, r), t.height;
}, "drawActorTypeControl"), exp = h(function(e, t, r, i) {
	let n = i ? t.stopy : t.starty, a = t.x + t.width / 2, s = n + 75, o = e.append("g").lower(), l = e.append("g"), h = exe;
	i ? h += ` ${ev8}` : h += ` ${ev7}`, l.attr("class", h), l.attr("name", t.name);
	let u = QI();
	u.x = t.x, u.y = n, u.fill = "#eaeaea", u.width = t.width, u.height = t.height, u.class = "actor";
	let d = t.x + t.width / 2, p = n + (i ? 10 : 25);
	return l.append("circle").attr("cx", d).attr("cy", p).attr("r", 18).attr("width", t.width).attr("height", t.height), l.append("line").attr("x1", d - 18).attr("x2", d + 18).attr("y1", p + 18).attr("y2", p + 18).attr("stroke", "#333").attr("stroke-width", 2), t.height = l.node().getBBox().height + (r?.sequence?.labelBoxHeight ?? 0), i || (exo++, o.append("line").attr("id", "actor" + exo).attr("x1", a).attr("y1", s).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", t.name), t.actorCnt = exo), exI(r, MZ(t.description))(t.description, l, u.x, u.y + (i ? (p - n + 18 - 5) / 2 : (p + 18 - n) / 2), u.width, u.height, { class: `actor ${exe}` }, r), l.attr("transform", "translate(0, 9)"), t.height;
}, "drawActorTypeEntity"), exf = h(function(e, t, r, i) {
	let n = i ? t.stopy : t.starty, a = t.x + t.width / 2, s = n + t.height + 2 * r.boxTextMargin, o = e.append("g").lower(), l = o;
	i || (exo++, Object.keys(t.links || {}).length && !r.forceMenus && l.attr("onclick", exi(`actor${exo}_popup`)).attr("cursor", "pointer"), l.append("line").attr("id", "actor" + exo).attr("x1", a).attr("y1", s).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", t.name), l = o.append("g"), t.actorCnt = exo, null != t.links && l.attr("id", "root-" + exo));
	let h = QI(), u = "actor";
	t.properties?.class ? u = t.properties.class : h.fill = "#eaeaea", i ? u += ` ${ev8}` : u += ` ${ev7}`, h.x = t.x, h.y = n, h.width = t.width, h.height = t.height, h.class = u, h.name = t.name, h.x = t.x, h.y = n;
	let d = h.width / 4, p = h.width / 4, f = d / 2, g = f / (2.5 + d / 50), m = l.append("g"), y = `
  M ${h.x},${h.y + g}
  a ${f},${g} 0 0 0 ${d},0
  a ${f},${g} 0 0 0 -${d},0
  l 0,${p - 2 * g}
  a ${f},${g} 0 0 0 ${d},0
  l 0,-${p - 2 * g}
`;
	m.append("path").attr("d", y).attr("fill", "#eaeaea").attr("stroke", "#000").attr("stroke-width", 1).attr("class", u), i ? m.attr("transform", `translate(${1.5 * d}, ${h.height / 4 - 2 * g})`) : m.attr("transform", `translate(${1.5 * d}, ${(h.height + g) / 4})`), t.rectData = h, exI(r, MZ(t.description))(t.description, l, h.x, h.y + (i ? (h.height + p) / 4 : (h.height + g) / 2), h.width, h.height, { class: `actor ${ev9}` }, r);
	let v = m.select("path:last-child");
	return v.node() && (t.height = v.node().getBBox().height + (r.sequence.labelBoxHeight ?? 0)), t.height;
}, "drawActorTypeDatabase"), exg = h(function(e, t, r, i) {
	let n = i ? t.stopy : t.starty, a = t.x + t.width / 2, s = n + 80, o = e.append("g").lower();
	i || (exo++, o.append("line").attr("id", "actor" + exo).attr("x1", a).attr("y1", s).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", t.name), t.actorCnt = exo);
	let l = e.append("g"), h = exe;
	i ? h += ` ${ev8}` : h += ` ${ev7}`, l.attr("class", h), l.attr("name", t.name);
	let u = QI();
	return u.x = t.x, u.y = n, u.fill = "#eaeaea", u.width = t.width, u.height = t.height, u.class = "actor", l.append("line").attr("id", "actor-man-torso" + exo).attr("x1", t.x + t.width / 2 - 75).attr("y1", n + 10).attr("x2", t.x + t.width / 2 - 15).attr("y2", n + 10), l.append("line").attr("id", "actor-man-arms" + exo).attr("x1", t.x + t.width / 2 - 75).attr("y1", n + 0).attr("x2", t.x + t.width / 2 - 75).attr("y2", n + 20), l.append("circle").attr("cx", t.x + t.width / 2).attr("cy", n + 10).attr("r", 30), t.height = l.node().getBBox().height + (r.sequence.labelBoxHeight ?? 0), exI(r, MZ(t.description))(t.description, l, u.x, u.y + (i ? 11 : 18), u.width, u.height, { class: `actor ${exe}` }, r), l.attr("transform", "translate(0,22)"), t.height;
}, "drawActorTypeBoundary"), exm = h(function(e, t, r, i) {
	let n = i ? t.stopy : t.starty, a = t.x + t.width / 2, s = n + 80, o = e.append("g").lower();
	i || (exo++, o.append("line").attr("id", "actor" + exo).attr("x1", a).attr("y1", s).attr("x2", a).attr("y2", 2e3).attr("class", "actor-line 200").attr("stroke-width", "0.5px").attr("stroke", "#999").attr("name", t.name), t.actorCnt = exo);
	let l = e.append("g"), h = exe;
	i ? h += ` ${ev8}` : h += ` ${ev7}`, l.attr("class", h), l.attr("name", t.name);
	let u = QI();
	u.x = t.x, u.y = n, u.fill = "#eaeaea", u.width = t.width, u.height = t.height, u.class = "actor", u.rx = 3, u.ry = 3, l.append("line").attr("id", "actor-man-torso" + exo).attr("x1", a).attr("y1", n + 25).attr("x2", a).attr("y2", n + 45), l.append("line").attr("id", "actor-man-arms" + exo).attr("x1", a - 18).attr("y1", n + 33).attr("x2", a + 18).attr("y2", n + 33), l.append("line").attr("x1", a - 18).attr("y1", n + 60).attr("x2", a).attr("y2", n + 45), l.append("line").attr("x1", a).attr("y1", n + 45).attr("x2", a + 18 - 2).attr("y2", n + 60);
	let d = l.append("circle");
	return d.attr("cx", t.x + t.width / 2), d.attr("cy", n + 10), d.attr("r", 15), d.attr("width", t.width), d.attr("height", t.height), t.height = l.node().getBBox().height, exI(r, MZ(t.description))(t.description, l, u.x, u.y + 35, u.width, u.height, { class: `actor ${exe}` }, r), t.height;
}, "drawActorTypeActor"), exy = h(async function(e, t, r, i) {
	switch (t.type) {
		case "actor": return await exm(e, t, r, i);
		case "participant": return await exc(e, t, r, i);
		case "boundary": return await exg(e, t, r, i);
		case "control": return await exd(e, t, r, i);
		case "entity": return await exp(e, t, r, i);
		case "database": return await exf(e, t, r, i);
		case "collections": return await exh(e, t, r, i);
		case "queue": return await exu(e, t, r, i);
	}
}, "drawActor"), exv = h(function(e, t, r) {
	let i = e.append("g");
	exk(i, t), t.name && exI(r)(t.name, i, t.x, t.y + r.boxTextMargin + (t.textMaxHeight || 0) / 2, t.width, 0, { class: "text" }, r), i.lower();
}, "drawBox"), exx = h(function(e) {
	return e.append("g");
}, "anchorElement"), exb = h(function(e, t, r, i, n) {
	let a = QI(), s = t.anchored;
	a.x = t.startx, a.y = t.starty, a.class = "activation" + n % 3, a.width = t.stopx - t.startx, a.height = r - t.starty, ext(s, a);
}, "drawActivation"), exw = h(async function(e, t, r, i) {
	let { boxMargin: n, boxTextMargin: a, labelBoxHeight: s, labelBoxWidth: o, messageFontFamily: l, messageFontSize: u, messageFontWeight: d } = i, p = e.append("g"), f = h(function(e, t, r, i) {
		return p.append("line").attr("x1", e).attr("y1", t).attr("x2", r).attr("y2", i).attr("class", "loopLine");
	}, "drawLoopLine");
	f(t.startx, t.starty, t.stopx, t.starty), f(t.stopx, t.starty, t.stopx, t.stopy), f(t.startx, t.stopy, t.stopx, t.stopy), f(t.startx, t.starty, t.startx, t.stopy), void 0 !== t.sections && t.sections.forEach(function(e) {
		f(t.startx, e.y, t.stopx, e.y).style("stroke-dasharray", "3, 3");
	});
	let g = QM();
	g.text = r, g.x = t.startx, g.y = t.starty, g.fontFamily = l, g.fontSize = u, g.fontWeight = d, g.anchor = "middle", g.valign = "middle", g.tspan = !1, g.width = o || 50, g.height = s || 20, g.textMargin = a, g.class = "labelText", exs(p, g), (g = exR()).text = t.title, g.x = t.startx + o / 2 + (t.stopx - t.startx) / 2, g.y = t.starty + n + a, g.anchor = "middle", g.valign = "middle", g.textMargin = a, g.class = "loopText", g.fontFamily = l, g.fontSize = u, g.fontWeight = d, g.wrap = !0;
	let m = MZ(g.text) ? await exn(p, g, t) : exa(p, g);
	if (void 0 !== t.sectionTitles) {
		for (let [e, r] of Object.entries(t.sectionTitles)) if (r.message) {
			g.text = r.message, g.x = t.startx + (t.stopx - t.startx) / 2, g.y = t.sections[e].y + n + a, g.class = "loopText", g.anchor = "middle", g.valign = "middle", g.tspan = !1, g.fontFamily = l, g.fontSize = u, g.fontWeight = d, g.wrap = t.wrap, MZ(g.text) ? (t.starty = t.sections[e].y, await exn(p, g, t)) : exa(p, g);
			let i = Math.round(m.map((e) => (e._groups || e)[0][0].getBBox().height).reduce((e, t) => e + t));
			t.sections[e].height += i - (n + a);
		}
	}
	return t.height = Math.round(t.stopy - t.starty), p;
}, "drawLoop"), exk = h(function(e, t) {
	QA(e, t);
}, "drawBackgroundRect"), exT = h(function(e) {
	e.append("defs").append("symbol").attr("id", "database").attr("fill-rule", "evenodd").attr("clip-rule", "evenodd").append("path").attr("transform", "scale(.5)").attr("d", "M12.258.001l.256.004.255.005.253.008.251.01.249.012.247.015.246.016.242.019.241.02.239.023.236.024.233.027.231.028.229.031.225.032.223.034.22.036.217.038.214.04.211.041.208.043.205.045.201.046.198.048.194.05.191.051.187.053.183.054.18.056.175.057.172.059.168.06.163.061.16.063.155.064.15.066.074.033.073.033.071.034.07.034.069.035.068.035.067.035.066.035.064.036.064.036.062.036.06.036.06.037.058.037.058.037.055.038.055.038.053.038.052.038.051.039.05.039.048.039.047.039.045.04.044.04.043.04.041.04.04.041.039.041.037.041.036.041.034.041.033.042.032.042.03.042.029.042.027.042.026.043.024.043.023.043.021.043.02.043.018.044.017.043.015.044.013.044.012.044.011.045.009.044.007.045.006.045.004.045.002.045.001.045v17l-.001.045-.002.045-.004.045-.006.045-.007.045-.009.044-.011.045-.012.044-.013.044-.015.044-.017.043-.018.044-.02.043-.021.043-.023.043-.024.043-.026.043-.027.042-.029.042-.03.042-.032.042-.033.042-.034.041-.036.041-.037.041-.039.041-.04.041-.041.04-.043.04-.044.04-.045.04-.047.039-.048.039-.05.039-.051.039-.052.038-.053.038-.055.038-.055.038-.058.037-.058.037-.06.037-.06.036-.062.036-.064.036-.064.036-.066.035-.067.035-.068.035-.069.035-.07.034-.071.034-.073.033-.074.033-.15.066-.155.064-.16.063-.163.061-.168.06-.172.059-.175.057-.18.056-.183.054-.187.053-.191.051-.194.05-.198.048-.201.046-.205.045-.208.043-.211.041-.214.04-.217.038-.22.036-.223.034-.225.032-.229.031-.231.028-.233.027-.236.024-.239.023-.241.02-.242.019-.246.016-.247.015-.249.012-.251.01-.253.008-.255.005-.256.004-.258.001-.258-.001-.256-.004-.255-.005-.253-.008-.251-.01-.249-.012-.247-.015-.245-.016-.243-.019-.241-.02-.238-.023-.236-.024-.234-.027-.231-.028-.228-.031-.226-.032-.223-.034-.22-.036-.217-.038-.214-.04-.211-.041-.208-.043-.204-.045-.201-.046-.198-.048-.195-.05-.19-.051-.187-.053-.184-.054-.179-.056-.176-.057-.172-.059-.167-.06-.164-.061-.159-.063-.155-.064-.151-.066-.074-.033-.072-.033-.072-.034-.07-.034-.069-.035-.068-.035-.067-.035-.066-.035-.064-.036-.063-.036-.062-.036-.061-.036-.06-.037-.058-.037-.057-.037-.056-.038-.055-.038-.053-.038-.052-.038-.051-.039-.049-.039-.049-.039-.046-.039-.046-.04-.044-.04-.043-.04-.041-.04-.04-.041-.039-.041-.037-.041-.036-.041-.034-.041-.033-.042-.032-.042-.03-.042-.029-.042-.027-.042-.026-.043-.024-.043-.023-.043-.021-.043-.02-.043-.018-.044-.017-.043-.015-.044-.013-.044-.012-.044-.011-.045-.009-.044-.007-.045-.006-.045-.004-.045-.002-.045-.001-.045v-17l.001-.045.002-.045.004-.045.006-.045.007-.045.009-.044.011-.045.012-.044.013-.044.015-.044.017-.043.018-.044.02-.043.021-.043.023-.043.024-.043.026-.043.027-.042.029-.042.03-.042.032-.042.033-.042.034-.041.036-.041.037-.041.039-.041.04-.041.041-.04.043-.04.044-.04.046-.04.046-.039.049-.039.049-.039.051-.039.052-.038.053-.038.055-.038.056-.038.057-.037.058-.037.06-.037.061-.036.062-.036.063-.036.064-.036.066-.035.067-.035.068-.035.069-.035.07-.034.072-.034.072-.033.074-.033.151-.066.155-.064.159-.063.164-.061.167-.06.172-.059.176-.057.179-.056.184-.054.187-.053.19-.051.195-.05.198-.048.201-.046.204-.045.208-.043.211-.041.214-.04.217-.038.22-.036.223-.034.226-.032.228-.031.231-.028.234-.027.236-.024.238-.023.241-.02.243-.019.245-.016.247-.015.249-.012.251-.01.253-.008.255-.005.256-.004.258-.001.258.001zm-9.258 20.499v.01l.001.021.003.021.004.022.005.021.006.022.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.023.018.024.019.024.021.024.022.025.023.024.024.025.052.049.056.05.061.051.066.051.07.051.075.051.079.052.084.052.088.052.092.052.097.052.102.051.105.052.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.048.144.049.147.047.152.047.155.047.16.045.163.045.167.043.171.043.176.041.178.041.183.039.187.039.19.037.194.035.197.035.202.033.204.031.209.03.212.029.216.027.219.025.222.024.226.021.23.02.233.018.236.016.24.015.243.012.246.01.249.008.253.005.256.004.259.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.021.224-.024.22-.026.216-.027.212-.028.21-.031.205-.031.202-.034.198-.034.194-.036.191-.037.187-.039.183-.04.179-.04.175-.042.172-.043.168-.044.163-.045.16-.046.155-.046.152-.047.148-.048.143-.049.139-.049.136-.05.131-.05.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.053.083-.051.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.05.023-.024.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.023.01-.022.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.127l-.077.055-.08.053-.083.054-.085.053-.087.052-.09.052-.093.051-.095.05-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.045-.118.044-.12.043-.122.042-.124.042-.126.041-.128.04-.13.04-.132.038-.134.038-.135.037-.138.037-.139.035-.142.035-.143.034-.144.033-.147.032-.148.031-.15.03-.151.03-.153.029-.154.027-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.01-.179.008-.179.008-.181.006-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.006-.179-.008-.179-.008-.178-.01-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.027-.153-.029-.151-.03-.15-.03-.148-.031-.146-.032-.145-.033-.143-.034-.141-.035-.14-.035-.137-.037-.136-.037-.134-.038-.132-.038-.13-.04-.128-.04-.126-.041-.124-.042-.122-.042-.12-.044-.117-.043-.116-.045-.113-.045-.112-.046-.109-.047-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.05-.093-.052-.09-.051-.087-.052-.085-.053-.083-.054-.08-.054-.077-.054v4.127zm0-5.654v.011l.001.021.003.021.004.021.005.022.006.022.007.022.009.022.01.022.011.023.012.023.013.023.015.024.016.023.017.024.018.024.019.024.021.024.022.024.023.025.024.024.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.052.11.051.114.051.119.052.123.05.127.051.131.05.135.049.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.044.171.042.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.022.23.02.233.018.236.016.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.012.241-.015.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.048.139-.05.136-.049.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.051.051-.049.023-.025.023-.024.021-.025.02-.024.019-.024.018-.024.017-.024.015-.023.014-.023.013-.024.012-.022.01-.023.01-.023.008-.022.006-.022.006-.022.004-.021.004-.022.001-.021.001-.021v-4.139l-.077.054-.08.054-.083.054-.085.052-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.044-.118.044-.12.044-.122.042-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.035-.143.033-.144.033-.147.033-.148.031-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.009-.179.009-.179.007-.181.007-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.007-.179-.007-.179-.009-.178-.009-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.031-.146-.033-.145-.033-.143-.033-.141-.035-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.04-.126-.041-.124-.042-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.051-.093-.051-.09-.051-.087-.053-.085-.052-.083-.054-.08-.054-.077-.054v4.139zm0-5.666v.011l.001.02.003.022.004.021.005.022.006.021.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.024.018.023.019.024.021.025.022.024.023.024.024.025.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.051.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.043.171.043.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.021.23.02.233.018.236.017.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.013.241-.014.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.049.139-.049.136-.049.131-.051.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.049.023-.025.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.022.01-.023.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.153l-.077.054-.08.054-.083.053-.085.053-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.048-.105.048-.106.048-.109.046-.111.046-.114.046-.115.044-.118.044-.12.043-.122.043-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.034-.143.034-.144.033-.147.032-.148.032-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.024-.161.024-.162.023-.163.023-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.01-.178.01-.179.009-.179.007-.181.006-.182.006-.182.004-.184.003-.184.001-.185.001-.185-.001-.184-.001-.184-.003-.182-.004-.182-.006-.181-.006-.179-.007-.179-.009-.178-.01-.176-.01-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.023-.162-.023-.161-.024-.159-.024-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.032-.146-.032-.145-.033-.143-.034-.141-.034-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.041-.126-.041-.124-.041-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.048-.105-.048-.102-.048-.1-.05-.097-.049-.095-.051-.093-.051-.09-.052-.087-.052-.085-.053-.083-.053-.08-.054-.077-.054v4.153zm8.74-8.179l-.257.004-.254.005-.25.008-.247.011-.244.012-.241.014-.237.016-.233.018-.231.021-.226.022-.224.023-.22.026-.216.027-.212.028-.21.031-.205.032-.202.033-.198.034-.194.036-.191.038-.187.038-.183.04-.179.041-.175.042-.172.043-.168.043-.163.045-.16.046-.155.046-.152.048-.148.048-.143.048-.139.049-.136.05-.131.05-.126.051-.123.051-.118.051-.114.052-.11.052-.106.052-.101.052-.096.052-.092.052-.088.052-.083.052-.079.052-.074.051-.07.052-.065.051-.06.05-.056.05-.051.05-.023.025-.023.024-.021.024-.02.025-.019.024-.018.024-.017.023-.015.024-.014.023-.013.023-.012.023-.01.023-.01.022-.008.022-.006.023-.006.021-.004.022-.004.021-.001.021-.001.021.001.021.001.021.004.021.004.022.006.021.006.023.008.022.01.022.01.023.012.023.013.023.014.023.015.024.017.023.018.024.019.024.02.025.021.024.023.024.023.025.051.05.056.05.06.05.065.051.07.052.074.051.079.052.083.052.088.052.092.052.096.052.101.052.106.052.11.052.114.052.118.051.123.051.126.051.131.05.136.05.139.049.143.048.148.048.152.048.155.046.16.046.163.045.168.043.172.043.175.042.179.041.183.04.187.038.191.038.194.036.198.034.202.033.205.032.21.031.212.028.216.027.22.026.224.023.226.022.231.021.233.018.237.016.241.014.244.012.247.011.25.008.254.005.257.004.26.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.022.224-.023.22-.026.216-.027.212-.028.21-.031.205-.032.202-.033.198-.034.194-.036.191-.038.187-.038.183-.04.179-.041.175-.042.172-.043.168-.043.163-.045.16-.046.155-.046.152-.048.148-.048.143-.048.139-.049.136-.05.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.05.051-.05.023-.025.023-.024.021-.024.02-.025.019-.024.018-.024.017-.023.015-.024.014-.023.013-.023.012-.023.01-.023.01-.022.008-.022.006-.023.006-.021.004-.022.004-.021.001-.021.001-.021-.001-.021-.001-.021-.004-.021-.004-.022-.006-.021-.006-.023-.008-.022-.01-.022-.01-.023-.012-.023-.013-.023-.014-.023-.015-.024-.017-.023-.018-.024-.019-.024-.02-.025-.021-.024-.023-.024-.023-.025-.051-.05-.056-.05-.06-.05-.065-.051-.07-.052-.074-.051-.079-.052-.083-.052-.088-.052-.092-.052-.096-.052-.101-.052-.106-.052-.11-.052-.114-.052-.118-.051-.123-.051-.126-.051-.131-.05-.136-.05-.139-.049-.143-.048-.148-.048-.152-.048-.155-.046-.16-.046-.163-.045-.168-.043-.172-.043-.175-.042-.179-.041-.183-.04-.187-.038-.191-.038-.194-.036-.198-.034-.202-.033-.205-.032-.21-.031-.212-.028-.216-.027-.22-.026-.224-.023-.226-.022-.231-.021-.233-.018-.237-.016-.241-.014-.244-.012-.247-.011-.25-.008-.254-.005-.257-.004-.26-.001-.26.001z");
}, "insertDatabaseIcon"), ex_ = h(function(e) {
	e.append("defs").append("symbol").attr("id", "computer").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr("d", "M2 2v13h20v-13h-20zm18 11h-16v-9h16v9zm-10.228 6l.466-1h3.524l.467 1h-4.457zm14.228 3h-24l2-6h2.104l-1.33 4h18.45l-1.297-4h2.073l2 6zm-5-10h-14v-7h14v7z");
}, "insertComputerIcon"), exE = h(function(e) {
	e.append("defs").append("symbol").attr("id", "clock").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr("d", "M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm5.848 12.459c.202.038.202.333.001.372-1.907.361-6.045 1.111-6.547 1.111-.719 0-1.301-.582-1.301-1.301 0-.512.77-5.447 1.125-7.445.034-.192.312-.181.343.014l.985 6.238 5.394 1.011z");
}, "insertClockIcon"), exC = h(function(e) {
	e.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 7.9).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto-start-reverse").append("path").attr("d", "M -1 0 L 10 5 L 0 10 z");
}, "insertArrowHead"), exS = h(function(e) {
	e.append("defs").append("marker").attr("id", "filled-head").attr("refX", 15.5).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
}, "insertArrowFilledHead"), exA = h(function(e) {
	e.append("defs").append("marker").attr("id", "sequencenumber").attr("refX", 15).attr("refY", 15).attr("markerWidth", 60).attr("markerHeight", 40).attr("orient", "auto").append("circle").attr("cx", 15).attr("cy", 15).attr("r", 6);
}, "insertSequenceNumber"), exL = h(function(e) {
	e.append("defs").append("marker").attr("id", "crosshead").attr("markerWidth", 15).attr("markerHeight", 8).attr("orient", "auto").attr("refX", 4).attr("refY", 4.5).append("path").attr("fill", "none").attr("stroke", "#000000").style("stroke-dasharray", "0, 0").attr("stroke-width", "1pt").attr("d", "M 1,2 L 6,7 M 6,2 L 1,7");
}, "insertArrowCrossHead"), exR = h(function() {
	return {
		x: 0,
		y: 0,
		fill: void 0,
		anchor: void 0,
		style: "#666",
		width: void 0,
		height: void 0,
		textMargin: 0,
		rx: 0,
		ry: 0,
		tspan: !0,
		valign: void 0
	};
}, "getTextObj"), exN = h(function() {
	return {
		x: 0,
		y: 0,
		fill: "#EDF2AE",
		stroke: "#666",
		width: 100,
		anchor: "start",
		height: 100,
		rx: 0,
		ry: 0
	};
}, "getNoteRect"), exI = function() {
	function e(e, t, r, i, a, s, o) {
		n(t.append("text").attr("x", r + a / 2).attr("y", i + s / 2 + 5).style("text-anchor", "middle").text(e), o);
	}
	function t(e, t, r, i, a, s, o, l) {
		let { actorFontSize: h, actorFontFamily: u, actorFontWeight: d } = l, [p, f] = V4(h), g = e.split(M1.lineBreakRegex);
		for (let e = 0; e < g.length; e++) {
			let l = e * p - p * (g.length - 1) / 2, h = t.append("text").attr("x", r + a / 2).attr("y", i).style("text-anchor", "middle").style("font-size", f).style("font-weight", d).style("font-family", u);
			h.append("tspan").attr("x", r + a / 2).attr("dy", l).text(g[e]), h.attr("y", i + s / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central"), n(h, o);
		}
	}
	function r(e, r, i, a, s, o, l, h) {
		let u = r.append("switch"), d = u.append("foreignObject").attr("x", i).attr("y", a).attr("width", s).attr("height", o).append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
		d.append("div").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(e), t(e, u, i, a, s, o, l, h), n(d, l);
	}
	async function i(e, r, i, a, s, o, l, h) {
		let u = await MQ(e, IA()), d = r.append("switch"), p = d.append("foreignObject").attr("x", i + s / 2 - u.width / 2).attr("y", a + o / 2 - u.height / 2).attr("width", u.width).attr("height", u.height).append("xhtml:div").style("height", "100%").style("width", "100%");
		p.append("div").style("text-align", "center").style("vertical-align", "middle").html(await M0(e, IA())), t(e, d, i, a, s, o, l, h), n(p, l);
	}
	function n(e, t) {
		for (let r in t) t.hasOwnProperty(r) && e.attr(r, t[r]);
	}
	return h(e, "byText"), h(t, "byTspan"), h(r, "byFo"), h(i, "byKatex"), h(n, "_setTextAttrs"), function(n, a = !1) {
		return a ? i : "fo" === n.textPlacement ? r : "old" === n.textPlacement ? e : t;
	};
}(), exM = function() {
	function e(e, t, r, n, a, s, o) {
		i(t.append("text").attr("x", r).attr("y", n).style("text-anchor", "start").text(e), o);
	}
	function t(e, t, r, n, a, s, o, l) {
		let { actorFontSize: h, actorFontFamily: u, actorFontWeight: d } = l, p = e.split(M1.lineBreakRegex);
		for (let e = 0; e < p.length; e++) {
			let a = e * h - h * (p.length - 1) / 2, l = t.append("text").attr("x", r).attr("y", n).style("text-anchor", "start").style("font-size", h).style("font-weight", d).style("font-family", u);
			l.append("tspan").attr("x", r).attr("dy", a).text(p[e]), l.attr("y", n + s / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central"), i(l, o);
		}
	}
	function r(e, r, n, a, s, o, l, h) {
		let u = r.append("switch"), d = u.append("foreignObject").attr("x", n).attr("y", a).attr("width", s).attr("height", o).append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
		d.append("div").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(e), t(e, u, n, a, s, o, l, h), i(d, l);
	}
	function i(e, t) {
		for (let r in t) t.hasOwnProperty(r) && e.attr(r, t[r]);
	}
	return h(e, "byText"), h(t, "byTspan"), h(r, "byFo"), h(i, "_setTextAttrs"), function(i) {
		return "fo" === i.textPlacement ? r : "old" === i.textPlacement ? e : t;
	};
}(), exD = {
	drawRect: ext,
	drawText: exa,
	drawLabel: exs,
	drawActor: exy,
	drawBox: exv,
	drawPopup: exr,
	anchorElement: exx,
	drawActivation: exb,
	drawLoop: exw,
	drawBackgroundRect: exk,
	insertArrowHead: exC,
	insertArrowFilledHead: exS,
	insertSequenceNumber: exA,
	insertArrowCrossHead: exL,
	insertDatabaseIcon: exT,
	insertComputerIcon: ex_,
	insertClockIcon: exE,
	getTextObj: exR,
	getNoteRect: exN,
	fixLifeLineHeights: exl,
	sanitizeUrl: ev6.sanitizeUrl
}, exO = {}, ex$ = {
	data: {
		startx: void 0,
		stopx: void 0,
		starty: void 0,
		stopy: void 0
	},
	verticalPos: 0,
	sequenceItems: [],
	activations: [],
	models: {
		getHeight: h(function() {
			return Math.max.apply(null, 0 === this.actors.length ? [0] : this.actors.map((e) => e.height || 0)) + (0 === this.loops.length ? 0 : this.loops.map((e) => e.height || 0).reduce((e, t) => e + t)) + (0 === this.messages.length ? 0 : this.messages.map((e) => e.height || 0).reduce((e, t) => e + t)) + (0 === this.notes.length ? 0 : this.notes.map((e) => e.height || 0).reduce((e, t) => e + t));
		}, "getHeight"),
		clear: h(function() {
			this.actors = [], this.boxes = [], this.loops = [], this.messages = [], this.notes = [];
		}, "clear"),
		addBox: h(function(e) {
			this.boxes.push(e);
		}, "addBox"),
		addActor: h(function(e) {
			this.actors.push(e);
		}, "addActor"),
		addLoop: h(function(e) {
			this.loops.push(e);
		}, "addLoop"),
		addMessage: h(function(e) {
			this.messages.push(e);
		}, "addMessage"),
		addNote: h(function(e) {
			this.notes.push(e);
		}, "addNote"),
		lastActor: h(function() {
			return this.actors[this.actors.length - 1];
		}, "lastActor"),
		lastLoop: h(function() {
			return this.loops[this.loops.length - 1];
		}, "lastLoop"),
		lastMessage: h(function() {
			return this.messages[this.messages.length - 1];
		}, "lastMessage"),
		lastNote: h(function() {
			return this.notes[this.notes.length - 1];
		}, "lastNote"),
		actors: [],
		boxes: [],
		loops: [],
		messages: [],
		notes: []
	},
	init: h(function() {
		this.sequenceItems = [], this.activations = [], this.models.clear(), this.data = {
			startx: void 0,
			stopx: void 0,
			starty: void 0,
			stopy: void 0
		}, this.verticalPos = 0, exY(IA());
	}, "init"),
	updateVal: h(function(e, t, r, i) {
		void 0 === e[t] ? e[t] = r : e[t] = i(r, e[t]);
	}, "updateVal"),
	updateBounds: h(function(e, t, r, i) {
		let n = this, a = 0;
		function s(s) {
			return h(function(o) {
				a++;
				let l = n.sequenceItems.length - a + 1;
				n.updateVal(o, "starty", t - l * exO.boxMargin, Math.min), n.updateVal(o, "stopy", i + l * exO.boxMargin, Math.max), n.updateVal(ex$.data, "startx", e - l * exO.boxMargin, Math.min), n.updateVal(ex$.data, "stopx", r + l * exO.boxMargin, Math.max), "activation" !== s && (n.updateVal(o, "startx", e - l * exO.boxMargin, Math.min), n.updateVal(o, "stopx", r + l * exO.boxMargin, Math.max), n.updateVal(ex$.data, "starty", t - l * exO.boxMargin, Math.min), n.updateVal(ex$.data, "stopy", i + l * exO.boxMargin, Math.max));
			}, "updateItemBounds");
		}
		h(s, "updateFn"), this.sequenceItems.forEach(s()), this.activations.forEach(s("activation"));
	}, "updateBounds"),
	insert: h(function(e, t, r, i) {
		let n = M1.getMin(e, r), a = M1.getMax(e, r), s = M1.getMin(t, i), o = M1.getMax(t, i);
		this.updateVal(ex$.data, "startx", n, Math.min), this.updateVal(ex$.data, "starty", s, Math.min), this.updateVal(ex$.data, "stopx", a, Math.max), this.updateVal(ex$.data, "stopy", o, Math.max), this.updateBounds(n, s, a, o);
	}, "insert"),
	newActivation: h(function(e, t, r) {
		let i = r.get(e.from), n = exV(e.from).length || 0, a = i.x + i.width / 2 + (n - 1) * exO.activationWidth / 2;
		this.activations.push({
			startx: a,
			starty: this.verticalPos + 2,
			stopx: a + exO.activationWidth,
			stopy: void 0,
			actor: e.from,
			anchored: exD.anchorElement(t)
		});
	}, "newActivation"),
	endActivation: h(function(e) {
		let t = this.activations.map(function(e) {
			return e.actor;
		}).lastIndexOf(e.from);
		return this.activations.splice(t, 1)[0];
	}, "endActivation"),
	createLoop: h(function(e = {
		message: void 0,
		wrap: !1,
		width: void 0
	}, t) {
		return {
			startx: void 0,
			starty: this.verticalPos,
			stopx: void 0,
			stopy: void 0,
			title: e.message,
			wrap: e.wrap,
			width: e.width,
			height: 0,
			fill: t
		};
	}, "createLoop"),
	newLoop: h(function(e = {
		message: void 0,
		wrap: !1,
		width: void 0
	}, t) {
		this.sequenceItems.push(this.createLoop(e, t));
	}, "newLoop"),
	endLoop: h(function() {
		return this.sequenceItems.pop();
	}, "endLoop"),
	isLoopOverlap: h(function() {
		return !!this.sequenceItems.length && this.sequenceItems[this.sequenceItems.length - 1].overlap;
	}, "isLoopOverlap"),
	addSectionToLoop: h(function(e) {
		let t = this.sequenceItems.pop();
		t.sections = t.sections || [], t.sectionTitles = t.sectionTitles || [], t.sections.push({
			y: ex$.getVerticalPos(),
			height: 0
		}), t.sectionTitles.push(e), this.sequenceItems.push(t);
	}, "addSectionToLoop"),
	saveVerticalPos: h(function() {
		this.isLoopOverlap() && (this.savedVerticalPos = this.verticalPos);
	}, "saveVerticalPos"),
	resetVerticalPos: h(function() {
		this.isLoopOverlap() && (this.verticalPos = this.savedVerticalPos);
	}, "resetVerticalPos"),
	bumpVerticalPos: h(function(e) {
		this.verticalPos = this.verticalPos + e, this.data.stopy = M1.getMax(this.data.stopy, this.verticalPos);
	}, "bumpVerticalPos"),
	getVerticalPos: h(function() {
		return this.verticalPos;
	}, "getVerticalPos"),
	getBounds: h(function() {
		return {
			bounds: this.data,
			models: this.models
		};
	}, "getBounds")
}, exP = h(async function(e, t) {
	ex$.bumpVerticalPos(exO.boxMargin), t.height = exO.boxMargin, t.starty = ex$.getVerticalPos();
	let r = QI();
	r.x = t.startx, r.y = t.starty, r.width = t.width || exO.width, r.class = "note";
	let i = e.append("g"), n = exD.drawRect(i, r), a = QM();
	a.x = t.startx, a.y = t.starty, a.width = r.width, a.dy = "1em", a.text = t.message, a.class = "noteText", a.fontFamily = exO.noteFontFamily, a.fontSize = exO.noteFontSize, a.fontWeight = exO.noteFontWeight, a.anchor = exO.noteAlign, a.textMargin = exO.noteMargin, a.valign = "center";
	let s = Math.round((MZ(a.text) ? await exn(i, a) : exa(i, a)).map((e) => (e._groups || e)[0][0].getBBox().height).reduce((e, t) => e + t));
	n.attr("height", s + 2 * exO.noteMargin), t.height += s + 2 * exO.noteMargin, ex$.bumpVerticalPos(s + 2 * exO.noteMargin), t.stopy = t.starty + s + 2 * exO.noteMargin, t.stopx = t.startx + r.width, ex$.insert(t.startx, t.starty, t.stopx, t.stopy), ex$.models.addNote(t);
}, "drawNote"), exB = h((e) => ({
	fontFamily: e.messageFontFamily,
	fontSize: e.messageFontSize,
	fontWeight: e.messageFontWeight
}), "messageFont"), exF = h((e) => ({
	fontFamily: e.noteFontFamily,
	fontSize: e.noteFontSize,
	fontWeight: e.noteFontWeight
}), "noteFont"), exz = h((e) => ({
	fontFamily: e.actorFontFamily,
	fontSize: e.actorFontSize,
	fontWeight: e.actorFontWeight
}), "actorFont");
async function exU(e, t) {
	ex$.bumpVerticalPos(10);
	let { startx: r, stopx: i, message: n } = t, a = M1.splitBreaks(n).length, s = MZ(n), o = s ? await MQ(n, IA()) : VQ(n, exB(exO));
	if (!s) {
		let e = o.height / a;
		t.height += e, ex$.bumpVerticalPos(e);
	}
	let l, h = o.height - 10, u = o.width;
	if (r === i) {
		l = ex$.getVerticalPos() + h, exO.rightAngles || (h += exO.boxMargin, l = ex$.getVerticalPos() + h), h += 30;
		let e = M1.getMax(u / 2, exO.width / 2);
		ex$.insert(r - e, ex$.getVerticalPos() - 10 + h, i + e, ex$.getVerticalPos() + 30 + h);
	} else h += exO.boxMargin, l = ex$.getVerticalPos() + h, ex$.insert(r, l - 10, i, l);
	return ex$.bumpVerticalPos(h), t.height += h, t.stopy = t.starty + t.height, ex$.insert(t.fromBounds, t.starty, t.toBounds, t.stopy), l;
}
h(exU, "boundMessage");
var exG = h(async function(e, t, r, i) {
	let { startx: n, stopx: a, starty: s, message: o, type: l, sequenceIndex: h, sequenceVisible: u } = t, d = VQ(o, exB(exO)), p = QM();
	p.x = n, p.y = s + 10, p.width = a - n, p.class = "messageText", p.dy = "1em", p.text = o, p.fontFamily = exO.messageFontFamily, p.fontSize = exO.messageFontSize, p.fontWeight = exO.messageFontWeight, p.anchor = exO.messageAlign, p.valign = "center", p.textMargin = exO.wrapPadding, p.tspan = !1, MZ(p.text) ? await exn(e, p, {
		startx: n,
		stopx: a,
		starty: r
	}) : exa(e, p);
	let f = d.width, g;
	n === a ? g = exO.rightAngles ? e.append("path").attr("d", `M  ${n},${r} H ${n + M1.getMax(exO.width / 2, f / 2)} V ${r + 25} H ${n}`) : e.append("path").attr("d", "M " + n + "," + r + " C " + (n + 60) + "," + (r - 10) + " " + (n + 60) + "," + (r + 30) + " " + n + "," + (r + 20)) : ((g = e.append("line")).attr("x1", n), g.attr("y1", r), g.attr("x2", a), g.attr("y2", r)), l === i.db.LINETYPE.DOTTED || l === i.db.LINETYPE.DOTTED_CROSS || l === i.db.LINETYPE.DOTTED_POINT || l === i.db.LINETYPE.DOTTED_OPEN || l === i.db.LINETYPE.BIDIRECTIONAL_DOTTED ? (g.style("stroke-dasharray", "3, 3"), g.attr("class", "messageLine1")) : g.attr("class", "messageLine0");
	let m = "";
	exO.arrowMarkerAbsolute && (m = MU(!0)), g.attr("stroke-width", 2), g.attr("stroke", "none"), g.style("fill", "none"), (l === i.db.LINETYPE.SOLID || l === i.db.LINETYPE.DOTTED) && g.attr("marker-end", "url(" + m + "#arrowhead)"), (l === i.db.LINETYPE.BIDIRECTIONAL_SOLID || l === i.db.LINETYPE.BIDIRECTIONAL_DOTTED) && (g.attr("marker-start", "url(" + m + "#arrowhead)"), g.attr("marker-end", "url(" + m + "#arrowhead)")), (l === i.db.LINETYPE.SOLID_POINT || l === i.db.LINETYPE.DOTTED_POINT) && g.attr("marker-end", "url(" + m + "#filled-head)"), (l === i.db.LINETYPE.SOLID_CROSS || l === i.db.LINETYPE.DOTTED_CROSS) && g.attr("marker-end", "url(" + m + "#crosshead)"), (u || exO.showSequenceNumbers) && ((l === i.db.LINETYPE.BIDIRECTIONAL_SOLID || l === i.db.LINETYPE.BIDIRECTIONAL_DOTTED) && (n < a ? g.attr("x1", n + 12) : g.attr("x1", n + 6)), e.append("line").attr("x1", n).attr("y1", r).attr("x2", n).attr("y2", r).attr("stroke-width", 0).attr("marker-start", "url(" + m + "#sequencenumber)"), e.append("text").attr("x", n).attr("y", r + 4).attr("font-family", "sans-serif").attr("font-size", "12px").attr("text-anchor", "middle").attr("class", "sequenceNumber").text(h));
}, "drawMessage"), exq = h(function(e, t, r, i, n, a, s) {
	let o = 0, l = 0, h, u = 0;
	for (let e of i) {
		let i = t.get(e), a = i.box;
		h && h != a && (s || ex$.models.addBox(h), l += exO.boxMargin + h.margin), a && a != h && (s || (a.x = o + l, a.y = n), l += a.margin), i.width = i.width || exO.width, i.height = M1.getMax(i.height || exO.height, exO.height), i.margin = i.margin || exO.actorMargin, u = M1.getMax(u, i.height), r.get(i.name) && (l += i.width / 2), i.x = o + l, i.starty = ex$.getVerticalPos(), ex$.insert(i.x, n, i.x + i.width, i.height), o += i.width + l, i.box && (i.box.width = o + a.margin - i.box.x), l = i.margin, h = i.box, ex$.models.addActor(i);
	}
	h && !s && ex$.models.addBox(h), ex$.bumpVerticalPos(u);
}, "addActorRenderingData"), exj = h(async function(e, t, r, i) {
	if (i) {
		let i = 0;
		for (let n of (ex$.bumpVerticalPos(2 * exO.boxMargin), r)) {
			let r = t.get(n);
			r.stopy || (r.stopy = ex$.getVerticalPos());
			let a = await exD.drawActor(e, r, exO, !0);
			i = M1.getMax(i, a);
		}
		ex$.bumpVerticalPos(i + exO.boxMargin);
	} else for (let i of r) {
		let r = t.get(i);
		await exD.drawActor(e, r, exO, !1);
	}
}, "drawActors"), exW = h(function(e, t, r, i) {
	let n = 0, a = 0;
	for (let s of r) {
		let r = t.get(s), o = exJ(r), l = exD.drawPopup(e, r, o, exO, exO.forceMenus, i);
		l.height > n && (n = l.height), l.width + r.x > a && (a = l.width + r.x);
	}
	return {
		maxHeight: n,
		maxWidth: a
	};
}, "drawActorsPopup"), exY = h(function(e) {
	NF(exO, e), e.fontFamily && (exO.actorFontFamily = exO.noteFontFamily = exO.messageFontFamily = e.fontFamily), e.fontSize && (exO.actorFontSize = exO.noteFontSize = exO.messageFontSize = e.fontSize), e.fontWeight && (exO.actorFontWeight = exO.noteFontWeight = exO.messageFontWeight = e.fontWeight);
}, "setConf"), exV = h(function(e) {
	return ex$.activations.filter(function(t) {
		return t.actor === e;
	});
}, "actorActivations"), exH = h(function(e, t) {
	let r = t.get(e), i = exV(e);
	return [i.reduce(function(e, t) {
		return M1.getMin(e, t.startx);
	}, r.x + r.width / 2 - 1), i.reduce(function(e, t) {
		return M1.getMax(e, t.stopx);
	}, r.x + r.width / 2 + 1)];
}, "activationBounds");
function exX(e, t, r, i, n) {
	ex$.bumpVerticalPos(r);
	let a = i;
	if (t.id && t.message && e[t.id]) {
		let r = e[t.id].width, n = exB(exO);
		t.message = VW(`[${t.message}]`, r - 2 * exO.wrapPadding, n), t.width = r, t.wrap = !0;
		let s = VQ(t.message, n), o = M1.getMax(s.height, exO.labelBoxHeight);
		a = i + o, wQ.debug(`${o} - ${t.message}`);
	}
	n(t), ex$.bumpVerticalPos(a);
}
function exK(e, t, r, i, n, a, s) {
	function o(r, i) {
		r.x < n.get(e.from).x ? (ex$.insert(t.stopx - i, t.starty, t.startx, t.stopy + r.height / 2 + exO.noteMargin), t.stopx = t.stopx + i) : (ex$.insert(t.startx, t.starty, t.stopx + i, t.stopy + r.height / 2 + exO.noteMargin), t.stopx = t.stopx - i);
	}
	function l(r, i) {
		r.x < n.get(e.to).x ? (ex$.insert(t.startx - i, t.starty, t.stopx, t.stopy + r.height / 2 + exO.noteMargin), t.startx = t.startx + i) : (ex$.insert(t.stopx, t.starty, t.startx + i, t.stopy + r.height / 2 + exO.noteMargin), t.startx = t.startx - i);
	}
	h(o, "receiverAdjustment"), h(l, "senderAdjustment");
	let u = [
		"actor",
		"control",
		"entity",
		"database"
	];
	if (a.get(e.to) == i) {
		let t = n.get(e.to);
		o(t, u.includes(t.type) ? 21 : t.width / 2 + 3), t.starty = r - t.height / 2, ex$.bumpVerticalPos(t.height / 2);
	} else if (s.get(e.from) == i) {
		let t = n.get(e.from);
		exO.mirrorActors && l(t, u.includes(t.type) ? 18 : t.width / 2), t.stopy = r - t.height / 2, ex$.bumpVerticalPos(t.height / 2);
	} else if (s.get(e.to) == i) {
		let t = n.get(e.to);
		exO.mirrorActors && o(t, u.includes(t.type) ? 21 : t.width / 2 + 3), t.stopy = r - t.height / 2, ex$.bumpVerticalPos(t.height / 2);
	}
}
h(exX, "adjustLoopHeightForWrap"), h(exK, "adjustCreatedDestroyedData");
var exZ = h(async function(e, t, r, i) {
	let n, { securityLevel: a, sequence: s } = IA();
	exO = s, "sandbox" === a && (n = _t("#i" + t));
	let o = "sandbox" === a ? _t(n.nodes()[0].contentDocument.body) : _t("body"), l = "sandbox" === a ? n.nodes()[0].contentDocument : document;
	ex$.init(), wQ.debug(i.db);
	let u = "sandbox" === a ? o.select(`[id="${t}"]`) : _t(`[id="${t}"]`), d = i.db.getActors(), p = i.db.getCreatedActors(), f = i.db.getDestroyedActors(), g = i.db.getBoxes(), m = i.db.getActorKeys(), y = i.db.getMessages(), v = i.db.getDiagramTitle(), x = i.db.hasAtLeastOneBox(), b = i.db.hasAtLeastOneBoxWithTitle(), w = await exQ(d, y, i);
	if (exO.height = await ex0(d, w, g), exD.insertComputerIcon(u), exD.insertDatabaseIcon(u), exD.insertClockIcon(u), x && (ex$.bumpVerticalPos(exO.boxMargin), b && ex$.bumpVerticalPos(g[0].textMaxHeight)), !0 === exO.hideUnusedParticipants) {
		let e = /* @__PURE__ */ new Set();
		y.forEach((t) => {
			e.add(t.from), e.add(t.to);
		}), m = m.filter((t) => e.has(t));
	}
	exq(u, d, p, m, 0, y, !1);
	let k = await ex4(y, d, w, i);
	function T(e, t) {
		let r = ex$.endActivation(e);
		r.starty + 18 > t && (r.starty = t - 6, t += 12), exD.drawActivation(u, r, t, exO, exV(e.from).length), ex$.insert(r.startx, t - 10, r.stopx, t);
	}
	exD.insertArrowHead(u), exD.insertArrowCrossHead(u), exD.insertArrowFilledHead(u), exD.insertSequenceNumber(u), h(T, "activeEnd");
	let _ = 1, E = 1, C = [], S = [], A = 0;
	for (let e of y) {
		let t, r, n;
		switch (e.type) {
			case i.db.LINETYPE.NOTE:
				ex$.resetVerticalPos(), r = e.noteModel, await exP(u, r);
				break;
			case i.db.LINETYPE.ACTIVE_START:
				ex$.newActivation(e, u, d);
				break;
			case i.db.LINETYPE.ACTIVE_END:
				T(e, ex$.getVerticalPos());
				break;
			case i.db.LINETYPE.LOOP_START:
				exX(k, e, exO.boxMargin, exO.boxMargin + exO.boxTextMargin, (e) => ex$.newLoop(e));
				break;
			case i.db.LINETYPE.LOOP_END:
				t = ex$.endLoop(), await exD.drawLoop(u, t, "loop", exO), ex$.bumpVerticalPos(t.stopy - ex$.getVerticalPos()), ex$.models.addLoop(t);
				break;
			case i.db.LINETYPE.RECT_START:
				exX(k, e, exO.boxMargin, exO.boxMargin, (e) => ex$.newLoop(void 0, e.message));
				break;
			case i.db.LINETYPE.RECT_END:
				t = ex$.endLoop(), S.push(t), ex$.models.addLoop(t), ex$.bumpVerticalPos(t.stopy - ex$.getVerticalPos());
				break;
			case i.db.LINETYPE.OPT_START:
				exX(k, e, exO.boxMargin, exO.boxMargin + exO.boxTextMargin, (e) => ex$.newLoop(e));
				break;
			case i.db.LINETYPE.OPT_END:
				t = ex$.endLoop(), await exD.drawLoop(u, t, "opt", exO), ex$.bumpVerticalPos(t.stopy - ex$.getVerticalPos()), ex$.models.addLoop(t);
				break;
			case i.db.LINETYPE.ALT_START:
				exX(k, e, exO.boxMargin, exO.boxMargin + exO.boxTextMargin, (e) => ex$.newLoop(e));
				break;
			case i.db.LINETYPE.ALT_ELSE:
				exX(k, e, exO.boxMargin + exO.boxTextMargin, exO.boxMargin, (e) => ex$.addSectionToLoop(e));
				break;
			case i.db.LINETYPE.ALT_END:
				t = ex$.endLoop(), await exD.drawLoop(u, t, "alt", exO), ex$.bumpVerticalPos(t.stopy - ex$.getVerticalPos()), ex$.models.addLoop(t);
				break;
			case i.db.LINETYPE.PAR_START:
			case i.db.LINETYPE.PAR_OVER_START:
				exX(k, e, exO.boxMargin, exO.boxMargin + exO.boxTextMargin, (e) => ex$.newLoop(e)), ex$.saveVerticalPos();
				break;
			case i.db.LINETYPE.PAR_AND:
				exX(k, e, exO.boxMargin + exO.boxTextMargin, exO.boxMargin, (e) => ex$.addSectionToLoop(e));
				break;
			case i.db.LINETYPE.PAR_END:
				t = ex$.endLoop(), await exD.drawLoop(u, t, "par", exO), ex$.bumpVerticalPos(t.stopy - ex$.getVerticalPos()), ex$.models.addLoop(t);
				break;
			case i.db.LINETYPE.AUTONUMBER:
				_ = e.message.start || _, E = e.message.step || E, e.message.visible ? i.db.enableSequenceNumbers() : i.db.disableSequenceNumbers();
				break;
			case i.db.LINETYPE.CRITICAL_START:
				exX(k, e, exO.boxMargin, exO.boxMargin + exO.boxTextMargin, (e) => ex$.newLoop(e));
				break;
			case i.db.LINETYPE.CRITICAL_OPTION:
				exX(k, e, exO.boxMargin + exO.boxTextMargin, exO.boxMargin, (e) => ex$.addSectionToLoop(e));
				break;
			case i.db.LINETYPE.CRITICAL_END:
				t = ex$.endLoop(), await exD.drawLoop(u, t, "critical", exO), ex$.bumpVerticalPos(t.stopy - ex$.getVerticalPos()), ex$.models.addLoop(t);
				break;
			case i.db.LINETYPE.BREAK_START:
				exX(k, e, exO.boxMargin, exO.boxMargin + exO.boxTextMargin, (e) => ex$.newLoop(e));
				break;
			case i.db.LINETYPE.BREAK_END:
				t = ex$.endLoop(), await exD.drawLoop(u, t, "break", exO), ex$.bumpVerticalPos(t.stopy - ex$.getVerticalPos()), ex$.models.addLoop(t);
				break;
			default: try {
				(n = e.msgModel).starty = ex$.getVerticalPos(), n.sequenceIndex = _, n.sequenceVisible = i.db.showSequenceNumbers();
				let t = await exU(u, n);
				exK(e, n, t, A, d, p, f), C.push({
					messageModel: n,
					lineStartY: t
				}), ex$.models.addMessage(n);
			} catch (e) {
				wQ.error("error while drawing message", e);
			}
		}
		[
			i.db.LINETYPE.SOLID_OPEN,
			i.db.LINETYPE.DOTTED_OPEN,
			i.db.LINETYPE.SOLID,
			i.db.LINETYPE.DOTTED,
			i.db.LINETYPE.SOLID_CROSS,
			i.db.LINETYPE.DOTTED_CROSS,
			i.db.LINETYPE.SOLID_POINT,
			i.db.LINETYPE.DOTTED_POINT,
			i.db.LINETYPE.BIDIRECTIONAL_SOLID,
			i.db.LINETYPE.BIDIRECTIONAL_DOTTED
		].includes(e.type) && (_ += E), A++;
	}
	for (let e of (wQ.debug("createdActors", p), wQ.debug("destroyedActors", f), await exj(u, d, m, !1), C)) await exG(u, e.messageModel, e.lineStartY, i);
	for (let e of (exO.mirrorActors && await exj(u, d, m, !0), S.forEach((e) => exD.drawBackgroundRect(u, e)), exl(u, d, m, exO), ex$.models.boxes)) {
		e.height = ex$.getVerticalPos() - e.y, ex$.insert(e.x, e.y, e.x + e.width, e.height);
		let t = 2 * exO.boxMargin;
		e.startx = e.x - t, e.starty = e.y - .25 * t, e.stopx = e.startx + e.width + 2 * t, e.stopy = e.starty + e.height + .75 * t, e.stroke = "rgb(0,0,0, 0.5)", exD.drawBox(u, e, exO);
	}
	x && ex$.bumpVerticalPos(exO.boxMargin);
	let L = exW(u, d, m, l), { bounds: R } = ex$.getBounds();
	void 0 === R.startx && (R.startx = 0), void 0 === R.starty && (R.starty = 0), void 0 === R.stopx && (R.stopx = 0), void 0 === R.stopy && (R.stopy = 0);
	let N = R.stopy - R.starty;
	N < L.maxHeight && (N = L.maxHeight);
	let I = N + 2 * exO.diagramMarginY;
	exO.mirrorActors && (I = I - exO.boxMargin + exO.bottomMarginAdj);
	let M = R.stopx - R.startx;
	M < L.maxWidth && (M = L.maxWidth);
	let D = M + 2 * exO.diagramMarginX;
	v && u.append("text").text(v).attr("x", (R.stopx - R.startx) / 2 - 2 * exO.diagramMarginX).attr("y", -25), M5(u, I, D, exO.useMaxWidth);
	let O = 40 * !!v;
	u.attr("viewBox", R.startx - exO.diagramMarginX + " -" + (exO.diagramMarginY + O) + " " + D + " " + (I + O)), wQ.debug("models:", ex$.models);
}, "draw");
async function exQ(e, t, r) {
	let i = {};
	for (let n of t) if (e.get(n.to) && e.get(n.from)) {
		let t = e.get(n.to);
		if (n.placement === r.db.PLACEMENT.LEFTOF && !t.prevActor || n.placement === r.db.PLACEMENT.RIGHTOF && !t.nextActor) continue;
		let a = void 0 !== n.placement, s = !a, o = a ? exF(exO) : exB(exO), l = n.wrap ? VW(n.message, exO.width - 2 * exO.wrapPadding, o) : n.message, h = (MZ(l) ? await MQ(n.message, IA()) : VQ(l, o)).width + 2 * exO.wrapPadding;
		s && n.from === t.nextActor ? i[n.to] = M1.getMax(i[n.to] || 0, h) : s && n.from === t.prevActor ? i[n.from] = M1.getMax(i[n.from] || 0, h) : s && n.from === n.to ? (i[n.from] = M1.getMax(i[n.from] || 0, h / 2), i[n.to] = M1.getMax(i[n.to] || 0, h / 2)) : n.placement === r.db.PLACEMENT.RIGHTOF ? i[n.from] = M1.getMax(i[n.from] || 0, h) : n.placement === r.db.PLACEMENT.LEFTOF ? i[t.prevActor] = M1.getMax(i[t.prevActor] || 0, h) : n.placement === r.db.PLACEMENT.OVER && (t.prevActor && (i[t.prevActor] = M1.getMax(i[t.prevActor] || 0, h / 2)), t.nextActor && (i[n.from] = M1.getMax(i[n.from] || 0, h / 2)));
	}
	return wQ.debug("maxMessageWidthPerActor:", i), i;
}
h(exQ, "getMaxMessageWidthPerActor");
var exJ = h(function(e) {
	let t = 0, r = exz(exO);
	for (let i in e.links) {
		let e = VQ(i, r).width + 2 * exO.wrapPadding + 2 * exO.boxMargin;
		t < e && (t = e);
	}
	return t;
}, "getRequiredPopupWidth");
async function ex0(e, t, r) {
	let i = 0;
	for (let t of e.keys()) {
		let r = e.get(t);
		r.wrap && (r.description = VW(r.description, exO.width - 2 * exO.wrapPadding, exz(exO)));
		let n = MZ(r.description) ? await MQ(r.description, IA()) : VQ(r.description, exz(exO));
		r.width = r.wrap ? exO.width : M1.getMax(exO.width, n.width + 2 * exO.wrapPadding), r.height = r.wrap ? M1.getMax(n.height, exO.height) : exO.height, i = M1.getMax(i, r.height);
	}
	for (let r in t) {
		let i = e.get(r);
		if (!i) continue;
		let n = e.get(i.nextActor);
		if (!n) {
			let e = t[r] + exO.actorMargin - i.width / 2;
			i.margin = M1.getMax(e, exO.actorMargin);
			continue;
		}
		let a = t[r] + exO.actorMargin - i.width / 2 - n.width / 2;
		i.margin = M1.getMax(a, exO.actorMargin);
	}
	let n = 0;
	return r.forEach((t) => {
		let r = exB(exO), i = t.actorKeys.reduce((t, r) => t += e.get(r).width + (e.get(r).margin || 0), 0);
		i += 8 * exO.boxMargin, i -= 2 * exO.boxTextMargin, t.wrap && (t.name = VW(t.name, i - 2 * exO.wrapPadding, r));
		let a = VQ(t.name, r);
		n = M1.getMax(a.height, n);
		let s = M1.getMax(i, a.width + 2 * exO.wrapPadding);
		if (t.margin = exO.boxTextMargin, i < s) {
			let e = (s - i) / 2;
			t.margin += e;
		}
	}), r.forEach((e) => e.textMaxHeight = n), M1.getMax(i, exO.height);
}
h(ex0, "calculateActorMargins");
var ex1 = h(async function(e, t, r) {
	let i = t.get(e.from), n = t.get(e.to), a = i.x, s = n.x, o = e.wrap && e.message, l = MZ(e.message) ? await MQ(e.message, IA()) : VQ(o ? VW(e.message, exO.width, exF(exO)) : e.message, exF(exO)), h = {
		width: o ? exO.width : M1.getMax(exO.width, l.width + 2 * exO.noteMargin),
		height: 0,
		startx: i.x,
		stopx: 0,
		starty: 0,
		stopy: 0,
		message: e.message
	};
	return e.placement === r.db.PLACEMENT.RIGHTOF ? (h.width = o ? M1.getMax(exO.width, l.width) : M1.getMax(i.width / 2 + n.width / 2, l.width + 2 * exO.noteMargin), h.startx = a + (i.width + exO.actorMargin) / 2) : e.placement === r.db.PLACEMENT.LEFTOF ? (h.width = o ? M1.getMax(exO.width, l.width + 2 * exO.noteMargin) : M1.getMax(i.width / 2 + n.width / 2, l.width + 2 * exO.noteMargin), h.startx = a - h.width + (i.width - exO.actorMargin) / 2) : e.to === e.from ? (l = VQ(o ? VW(e.message, M1.getMax(exO.width, i.width), exF(exO)) : e.message, exF(exO)), h.width = o ? M1.getMax(exO.width, i.width) : M1.getMax(i.width, exO.width, l.width + 2 * exO.noteMargin), h.startx = a + (i.width - h.width) / 2) : (h.width = Math.abs(a + i.width / 2 - (s + n.width / 2)) + exO.actorMargin, h.startx = a < s ? a + i.width / 2 - exO.actorMargin / 2 : s + n.width / 2 - exO.actorMargin / 2), o && (h.message = VW(e.message, h.width - 2 * exO.wrapPadding, exF(exO))), wQ.debug(`NM:[${h.startx},${h.stopx},${h.starty},${h.stopy}:${h.width},${h.height}=${e.message}]`), h;
}, "buildNoteModel"), ex2 = h(function(e, t, r) {
	if (![
		r.db.LINETYPE.SOLID_OPEN,
		r.db.LINETYPE.DOTTED_OPEN,
		r.db.LINETYPE.SOLID,
		r.db.LINETYPE.DOTTED,
		r.db.LINETYPE.SOLID_CROSS,
		r.db.LINETYPE.DOTTED_CROSS,
		r.db.LINETYPE.SOLID_POINT,
		r.db.LINETYPE.DOTTED_POINT,
		r.db.LINETYPE.BIDIRECTIONAL_SOLID,
		r.db.LINETYPE.BIDIRECTIONAL_DOTTED
	].includes(e.type)) return {};
	let [i, n] = exH(e.from, t), [a, s] = exH(e.to, t), o = i <= a, l = o ? n : i, u = o ? a : s, d = Math.abs(a - s) > 2, p = h((e) => o ? -e : e, "adjustValue");
	e.from === e.to ? u = l : (e.activate && !d && (u += p(exO.activationWidth / 2 - 1)), [r.db.LINETYPE.SOLID_OPEN, r.db.LINETYPE.DOTTED_OPEN].includes(e.type) || (u += p(3)), [r.db.LINETYPE.BIDIRECTIONAL_SOLID, r.db.LINETYPE.BIDIRECTIONAL_DOTTED].includes(e.type) && (l -= p(3)));
	let f = [
		i,
		n,
		a,
		s
	], g = Math.abs(l - u);
	e.wrap && e.message && (e.message = VW(e.message, M1.getMax(g + 2 * exO.wrapPadding, exO.width), exB(exO)));
	let m = VQ(e.message, exB(exO));
	return {
		width: M1.getMax(e.wrap ? 0 : m.width + 2 * exO.wrapPadding, g + 2 * exO.wrapPadding, exO.width),
		height: 0,
		startx: l,
		stopx: u,
		starty: 0,
		stopy: 0,
		message: e.message,
		type: e.type,
		wrap: e.wrap,
		fromBounds: Math.min.apply(null, f),
		toBounds: Math.max.apply(null, f)
	};
}, "buildMessageModel"), ex4 = h(async function(e, t, r, i) {
	let n = {}, a = [], s, o, l;
	for (let r of e) {
		switch (r.type) {
			case i.db.LINETYPE.LOOP_START:
			case i.db.LINETYPE.ALT_START:
			case i.db.LINETYPE.OPT_START:
			case i.db.LINETYPE.PAR_START:
			case i.db.LINETYPE.PAR_OVER_START:
			case i.db.LINETYPE.CRITICAL_START:
			case i.db.LINETYPE.BREAK_START:
				a.push({
					id: r.id,
					msg: r.message,
					from: Number.MAX_SAFE_INTEGER,
					to: Number.MIN_SAFE_INTEGER,
					width: 0
				});
				break;
			case i.db.LINETYPE.ALT_ELSE:
			case i.db.LINETYPE.PAR_AND:
			case i.db.LINETYPE.CRITICAL_OPTION:
				r.message && (n[(s = a.pop()).id] = s, n[r.id] = s, a.push(s));
				break;
			case i.db.LINETYPE.LOOP_END:
			case i.db.LINETYPE.ALT_END:
			case i.db.LINETYPE.OPT_END:
			case i.db.LINETYPE.PAR_END:
			case i.db.LINETYPE.CRITICAL_END:
			case i.db.LINETYPE.BREAK_END:
				n[(s = a.pop()).id] = s;
				break;
			case i.db.LINETYPE.ACTIVE_START:
				{
					let e = t.get(r.from ? r.from : r.to.actor), i = exV(r.from ? r.from : r.to.actor).length, n = e.x + e.width / 2 + (i - 1) * exO.activationWidth / 2, a = {
						startx: n,
						stopx: n + exO.activationWidth,
						actor: r.from,
						enabled: !0
					};
					ex$.activations.push(a);
				}
				break;
			case i.db.LINETYPE.ACTIVE_END: {
				let e = ex$.activations.map((e) => e.actor).lastIndexOf(r.from);
				ex$.activations.splice(e, 1).splice(0, 1);
			}
		}
		void 0 !== r.placement ? (o = await ex1(r, t, i), r.noteModel = o, a.forEach((e) => {
			(s = e).from = M1.getMin(s.from, o.startx), s.to = M1.getMax(s.to, o.startx + o.width), s.width = M1.getMax(s.width, Math.abs(s.from - s.to)) - exO.labelBoxWidth;
		})) : (l = ex2(r, t, i), r.msgModel = l, l.startx && l.stopx && a.length > 0 && a.forEach((e) => {
			if (s = e, l.startx === l.stopx) {
				let e = t.get(r.from), i = t.get(r.to);
				s.from = M1.getMin(e.x - l.width / 2, e.x - e.width / 2, s.from), s.to = M1.getMax(i.x + l.width / 2, i.x + e.width / 2, s.to), s.width = M1.getMax(s.width, Math.abs(s.to - s.from)) - exO.labelBoxWidth;
			} else s.from = M1.getMin(l.startx, s.from), s.to = M1.getMax(l.stopx, s.to), s.width = M1.getMax(s.width, l.width) - exO.labelBoxWidth;
		}));
	}
	return ex$.activations = [], wQ.debug("Loop type widths:", n), n;
}, "calculateLoopBounds"), ex5 = {
	parser: ev0,
	get db() {
		return new ev5();
	},
	renderer: {
		bounds: ex$,
		drawActors: exj,
		drawActorsPopup: exW,
		setConf: exY,
		draw: exZ
	},
	styles: ev3,
	init: h((e) => {
		e.sequence || (e.sequence = {}), e.wrap && (e.sequence.wrap = e.wrap, IS({ sequence: { wrap: e.wrap } }));
	}, "init")
}, ex3 = function() {
	var e = h(function(e, t, r, i) {
		for (r = r || {}, i = e.length; i--; r[e[i]] = t);
		return r;
	}, "o"), t = [1, 2], r = [1, 3], i = [1, 4], n = [2, 4], a = [1, 9], s = [1, 11], o = [1, 16], l = [1, 17], u = [1, 18], d = [1, 19], p = [1, 33], f = [1, 20], g = [1, 21], m = [1, 22], y = [1, 23], v = [1, 24], x = [1, 26], b = [1, 27], w = [1, 28], k = [1, 29], T = [1, 30], _ = [1, 31], E = [1, 32], C = [1, 35], S = [1, 36], A = [1, 37], L = [1, 38], R = [1, 34], N = [
		1,
		4,
		5,
		16,
		17,
		19,
		21,
		22,
		24,
		25,
		26,
		27,
		28,
		29,
		33,
		35,
		37,
		38,
		41,
		45,
		48,
		51,
		52,
		53,
		54,
		57
	], I = [
		1,
		4,
		5,
		14,
		15,
		16,
		17,
		19,
		21,
		22,
		24,
		25,
		26,
		27,
		28,
		29,
		33,
		35,
		37,
		38,
		39,
		40,
		41,
		45,
		48,
		51,
		52,
		53,
		54,
		57
	], M = [
		4,
		5,
		16,
		17,
		19,
		21,
		22,
		24,
		25,
		26,
		27,
		28,
		29,
		33,
		35,
		37,
		38,
		41,
		45,
		48,
		51,
		52,
		53,
		54,
		57
	], D = {
		trace: h(function() {}, "trace"),
		yy: {},
		symbols_: {
			error: 2,
			start: 3,
			SPACE: 4,
			NL: 5,
			SD: 6,
			document: 7,
			line: 8,
			statement: 9,
			classDefStatement: 10,
			styleStatement: 11,
			cssClassStatement: 12,
			idStatement: 13,
			DESCR: 14,
			"-->": 15,
			HIDE_EMPTY: 16,
			scale: 17,
			WIDTH: 18,
			COMPOSIT_STATE: 19,
			STRUCT_START: 20,
			STRUCT_STOP: 21,
			STATE_DESCR: 22,
			AS: 23,
			ID: 24,
			FORK: 25,
			JOIN: 26,
			CHOICE: 27,
			CONCURRENT: 28,
			note: 29,
			notePosition: 30,
			NOTE_TEXT: 31,
			direction: 32,
			acc_title: 33,
			acc_title_value: 34,
			acc_descr: 35,
			acc_descr_value: 36,
			acc_descr_multiline_value: 37,
			CLICK: 38,
			STRING: 39,
			HREF: 40,
			classDef: 41,
			CLASSDEF_ID: 42,
			CLASSDEF_STYLEOPTS: 43,
			DEFAULT: 44,
			style: 45,
			STYLE_IDS: 46,
			STYLEDEF_STYLEOPTS: 47,
			class: 48,
			CLASSENTITY_IDS: 49,
			STYLECLASS: 50,
			direction_tb: 51,
			direction_bt: 52,
			direction_rl: 53,
			direction_lr: 54,
			eol: 55,
			";": 56,
			EDGE_STATE: 57,
			STYLE_SEPARATOR: 58,
			left_of: 59,
			right_of: 60,
			$accept: 0,
			$end: 1
		},
		terminals_: {
			2: "error",
			4: "SPACE",
			5: "NL",
			6: "SD",
			14: "DESCR",
			15: "-->",
			16: "HIDE_EMPTY",
			17: "scale",
			18: "WIDTH",
			19: "COMPOSIT_STATE",
			20: "STRUCT_START",
			21: "STRUCT_STOP",
			22: "STATE_DESCR",
			23: "AS",
			24: "ID",
			25: "FORK",
			26: "JOIN",
			27: "CHOICE",
			28: "CONCURRENT",
			29: "note",
			31: "NOTE_TEXT",
			33: "acc_title",
			34: "acc_title_value",
			35: "acc_descr",
			36: "acc_descr_value",
			37: "acc_descr_multiline_value",
			38: "CLICK",
			39: "STRING",
			40: "HREF",
			41: "classDef",
			42: "CLASSDEF_ID",
			43: "CLASSDEF_STYLEOPTS",
			44: "DEFAULT",
			45: "style",
			46: "STYLE_IDS",
			47: "STYLEDEF_STYLEOPTS",
			48: "class",
			49: "CLASSENTITY_IDS",
			50: "STYLECLASS",
			51: "direction_tb",
			52: "direction_bt",
			53: "direction_rl",
			54: "direction_lr",
			56: ";",
			57: "EDGE_STATE",
			58: "STYLE_SEPARATOR",
			59: "left_of",
			60: "right_of"
		},
		productions_: [
			0,
			[3, 2],
			[3, 2],
			[3, 2],
			[7, 0],
			[7, 2],
			[8, 2],
			[8, 1],
			[8, 1],
			[9, 1],
			[9, 1],
			[9, 1],
			[9, 1],
			[9, 2],
			[9, 3],
			[9, 4],
			[9, 1],
			[9, 2],
			[9, 1],
			[9, 4],
			[9, 3],
			[9, 6],
			[9, 1],
			[9, 1],
			[9, 1],
			[9, 1],
			[9, 4],
			[9, 4],
			[9, 1],
			[9, 2],
			[9, 2],
			[9, 1],
			[9, 5],
			[9, 5],
			[10, 3],
			[10, 3],
			[11, 3],
			[12, 3],
			[32, 1],
			[32, 1],
			[32, 1],
			[32, 1],
			[55, 1],
			[55, 1],
			[13, 1],
			[13, 1],
			[13, 3],
			[13, 3],
			[30, 1],
			[30, 1]
		],
		performAction: h(function(e, t, r, i, n, a, s) {
			var o = a.length - 1;
			switch (n) {
				case 3: return i.setRootDoc(a[o]), a[o];
				case 4:
					this.$ = [];
					break;
				case 5:
					"nl" != a[o] && (a[o - 1].push(a[o]), this.$ = a[o - 1]);
					break;
				case 6:
				case 7:
				case 12:
					this.$ = a[o];
					break;
				case 8:
					this.$ = "nl";
					break;
				case 13:
					let l = a[o - 1];
					l.description = i.trimColon(a[o]), this.$ = l;
					break;
				case 14:
					this.$ = {
						stmt: "relation",
						state1: a[o - 2],
						state2: a[o]
					};
					break;
				case 15:
					let h = i.trimColon(a[o]);
					this.$ = {
						stmt: "relation",
						state1: a[o - 3],
						state2: a[o - 1],
						description: h
					};
					break;
				case 19:
					this.$ = {
						stmt: "state",
						id: a[o - 3],
						type: "default",
						description: "",
						doc: a[o - 1]
					};
					break;
				case 20:
					var u = a[o], d = a[o - 2].trim();
					if (a[o].match(":")) {
						var p = a[o].split(":");
						u = p[0], d = [d, p[1]];
					}
					this.$ = {
						stmt: "state",
						id: u,
						type: "default",
						description: d
					};
					break;
				case 21:
					this.$ = {
						stmt: "state",
						id: a[o - 3],
						type: "default",
						description: a[o - 5],
						doc: a[o - 1]
					};
					break;
				case 22:
					this.$ = {
						stmt: "state",
						id: a[o],
						type: "fork"
					};
					break;
				case 23:
					this.$ = {
						stmt: "state",
						id: a[o],
						type: "join"
					};
					break;
				case 24:
					this.$ = {
						stmt: "state",
						id: a[o],
						type: "choice"
					};
					break;
				case 25:
					this.$ = {
						stmt: "state",
						id: i.getDividerId(),
						type: "divider"
					};
					break;
				case 26:
					this.$ = {
						stmt: "state",
						id: a[o - 1].trim(),
						note: {
							position: a[o - 2].trim(),
							text: a[o].trim()
						}
					};
					break;
				case 29:
					this.$ = a[o].trim(), i.setAccTitle(this.$);
					break;
				case 30:
				case 31:
					this.$ = a[o].trim(), i.setAccDescription(this.$);
					break;
				case 32:
					this.$ = {
						stmt: "click",
						id: a[o - 3],
						url: a[o - 2],
						tooltip: a[o - 1]
					};
					break;
				case 33:
					this.$ = {
						stmt: "click",
						id: a[o - 3],
						url: a[o - 1],
						tooltip: ""
					};
					break;
				case 34:
				case 35:
					this.$ = {
						stmt: "classDef",
						id: a[o - 1].trim(),
						classes: a[o].trim()
					};
					break;
				case 36:
					this.$ = {
						stmt: "style",
						id: a[o - 1].trim(),
						styleClass: a[o].trim()
					};
					break;
				case 37:
					this.$ = {
						stmt: "applyClass",
						id: a[o - 1].trim(),
						styleClass: a[o].trim()
					};
					break;
				case 38:
					i.setDirection("TB"), this.$ = {
						stmt: "dir",
						value: "TB"
					};
					break;
				case 39:
					i.setDirection("BT"), this.$ = {
						stmt: "dir",
						value: "BT"
					};
					break;
				case 40:
					i.setDirection("RL"), this.$ = {
						stmt: "dir",
						value: "RL"
					};
					break;
				case 41:
					i.setDirection("LR"), this.$ = {
						stmt: "dir",
						value: "LR"
					};
					break;
				case 44:
				case 45:
					this.$ = {
						stmt: "state",
						id: a[o].trim(),
						type: "default",
						description: ""
					};
					break;
				case 46:
				case 47: this.$ = {
					stmt: "state",
					id: a[o - 2].trim(),
					classes: [a[o].trim()],
					type: "default",
					description: ""
				};
			}
		}, "anonymous"),
		table: [
			{
				3: 1,
				4: t,
				5: r,
				6: i
			},
			{ 1: [3] },
			{
				3: 5,
				4: t,
				5: r,
				6: i
			},
			{
				3: 6,
				4: t,
				5: r,
				6: i
			},
			e([
				1,
				4,
				5,
				16,
				17,
				19,
				22,
				24,
				25,
				26,
				27,
				28,
				29,
				33,
				35,
				37,
				38,
				41,
				45,
				48,
				51,
				52,
				53,
				54,
				57
			], n, { 7: 7 }),
			{ 1: [2, 1] },
			{ 1: [2, 2] },
			{
				1: [2, 3],
				4: a,
				5: s,
				8: 8,
				9: 10,
				10: 12,
				11: 13,
				12: 14,
				13: 15,
				16: o,
				17: l,
				19: u,
				22: d,
				24: p,
				25: f,
				26: g,
				27: m,
				28: y,
				29: v,
				32: 25,
				33: x,
				35: b,
				37: w,
				38: k,
				41: T,
				45: _,
				48: E,
				51: C,
				52: S,
				53: A,
				54: L,
				57: R
			},
			e(N, [2, 5]),
			{
				9: 39,
				10: 12,
				11: 13,
				12: 14,
				13: 15,
				16: o,
				17: l,
				19: u,
				22: d,
				24: p,
				25: f,
				26: g,
				27: m,
				28: y,
				29: v,
				32: 25,
				33: x,
				35: b,
				37: w,
				38: k,
				41: T,
				45: _,
				48: E,
				51: C,
				52: S,
				53: A,
				54: L,
				57: R
			},
			e(N, [2, 7]),
			e(N, [2, 8]),
			e(N, [2, 9]),
			e(N, [2, 10]),
			e(N, [2, 11]),
			e(N, [2, 12], {
				14: [1, 40],
				15: [1, 41]
			}),
			e(N, [2, 16]),
			{ 18: [1, 42] },
			e(N, [2, 18], { 20: [1, 43] }),
			{ 23: [1, 44] },
			e(N, [2, 22]),
			e(N, [2, 23]),
			e(N, [2, 24]),
			e(N, [2, 25]),
			{
				30: 45,
				31: [1, 46],
				59: [1, 47],
				60: [1, 48]
			},
			e(N, [2, 28]),
			{ 34: [1, 49] },
			{ 36: [1, 50] },
			e(N, [2, 31]),
			{
				13: 51,
				24: p,
				57: R
			},
			{
				42: [1, 52],
				44: [1, 53]
			},
			{ 46: [1, 54] },
			{ 49: [1, 55] },
			e(I, [2, 44], { 58: [1, 56] }),
			e(I, [2, 45], { 58: [1, 57] }),
			e(N, [2, 38]),
			e(N, [2, 39]),
			e(N, [2, 40]),
			e(N, [2, 41]),
			e(N, [2, 6]),
			e(N, [2, 13]),
			{
				13: 58,
				24: p,
				57: R
			},
			e(N, [2, 17]),
			e(M, n, { 7: 59 }),
			{ 24: [1, 60] },
			{ 24: [1, 61] },
			{ 23: [1, 62] },
			{ 24: [2, 48] },
			{ 24: [2, 49] },
			e(N, [2, 29]),
			e(N, [2, 30]),
			{
				39: [1, 63],
				40: [1, 64]
			},
			{ 43: [1, 65] },
			{ 43: [1, 66] },
			{ 47: [1, 67] },
			{ 50: [1, 68] },
			{ 24: [1, 69] },
			{ 24: [1, 70] },
			e(N, [2, 14], { 14: [1, 71] }),
			{
				4: a,
				5: s,
				8: 8,
				9: 10,
				10: 12,
				11: 13,
				12: 14,
				13: 15,
				16: o,
				17: l,
				19: u,
				21: [1, 72],
				22: d,
				24: p,
				25: f,
				26: g,
				27: m,
				28: y,
				29: v,
				32: 25,
				33: x,
				35: b,
				37: w,
				38: k,
				41: T,
				45: _,
				48: E,
				51: C,
				52: S,
				53: A,
				54: L,
				57: R
			},
			e(N, [2, 20], { 20: [1, 73] }),
			{ 31: [1, 74] },
			{ 24: [1, 75] },
			{ 39: [1, 76] },
			{ 39: [1, 77] },
			e(N, [2, 34]),
			e(N, [2, 35]),
			e(N, [2, 36]),
			e(N, [2, 37]),
			e(I, [2, 46]),
			e(I, [2, 47]),
			e(N, [2, 15]),
			e(N, [2, 19]),
			e(M, n, { 7: 78 }),
			e(N, [2, 26]),
			e(N, [2, 27]),
			{ 5: [1, 79] },
			{ 5: [1, 80] },
			{
				4: a,
				5: s,
				8: 8,
				9: 10,
				10: 12,
				11: 13,
				12: 14,
				13: 15,
				16: o,
				17: l,
				19: u,
				21: [1, 81],
				22: d,
				24: p,
				25: f,
				26: g,
				27: m,
				28: y,
				29: v,
				32: 25,
				33: x,
				35: b,
				37: w,
				38: k,
				41: T,
				45: _,
				48: E,
				51: C,
				52: S,
				53: A,
				54: L,
				57: R
			},
			e(N, [2, 32]),
			e(N, [2, 33]),
			e(N, [2, 21])
		],
		defaultActions: {
			5: [2, 1],
			6: [2, 2],
			47: [2, 48],
			48: [2, 49]
		},
		parseError: h(function(e, t) {
			if (t.recoverable) this.trace(e);
			else {
				var r = Error(e);
				throw r.hash = t, r;
			}
		}, "parseError"),
		parse: h(function(e) {
			var t = this, r = [0], i = [], n = [null], a = [], s = this.table, o = "", l = 0, u = 0, d = 0, p = a.slice.call(arguments, 1), f = Object.create(this.lexer), g = {};
			for (var m in this.yy) Object.prototype.hasOwnProperty.call(this.yy, m) && (g[m] = this.yy[m]);
			f.setInput(e, g), g.lexer = f, g.parser = this, typeof f.yylloc > "u" && (f.yylloc = {});
			var y = f.yylloc;
			a.push(y);
			var v = f.options && f.options.ranges;
			function x() {
				var e;
				return "number" != typeof (e = i.pop() || f.lex() || 1) && (e instanceof Array && (e = (i = e).pop()), e = t.symbols_[e] || e), e;
			}
			"function" == typeof g.parseError ? this.parseError = g.parseError : this.parseError = Object.getPrototypeOf(this).parseError, h(function(e) {
				r.length = r.length - 2 * e, n.length = n.length - e, a.length = a.length - e;
			}, "popStack"), h(x, "lex");
			for (var b, w, k, T, _, E, C, S, A, L = {};;) {
				if (k = r[r.length - 1], this.defaultActions[k] ? T = this.defaultActions[k] : ((null === b || typeof b > "u") && (b = x()), T = s[k] && s[k][b]), typeof T > "u" || !T.length || !T[0]) {
					var R = "";
					for (E in A = [], s[k]) this.terminals_[E] && E > 2 && A.push("'" + this.terminals_[E] + "'");
					R = f.showPosition ? "Parse error on line " + (l + 1) + `:
` + f.showPosition() + `
Expecting ` + A.join(", ") + ", got '" + (this.terminals_[b] || b) + "'" : "Parse error on line " + (l + 1) + ": Unexpected " + (1 == b ? "end of input" : "'" + (this.terminals_[b] || b) + "'"), this.parseError(R, {
						text: f.match,
						token: this.terminals_[b] || b,
						line: f.yylineno,
						loc: y,
						expected: A
					});
				}
				if (T[0] instanceof Array && T.length > 1) throw Error("Parse Error: multiple actions possible at state: " + k + ", token: " + b);
				switch (T[0]) {
					case 1:
						r.push(b), n.push(f.yytext), a.push(f.yylloc), r.push(T[1]), b = null, w ? (b = w, w = null) : (u = f.yyleng, o = f.yytext, l = f.yylineno, y = f.yylloc, d > 0 && d--);
						break;
					case 2:
						if (C = this.productions_[T[1]][1], L.$ = n[n.length - C], L._$ = {
							first_line: a[a.length - (C || 1)].first_line,
							last_line: a[a.length - 1].last_line,
							first_column: a[a.length - (C || 1)].first_column,
							last_column: a[a.length - 1].last_column
						}, v && (L._$.range = [a[a.length - (C || 1)].range[0], a[a.length - 1].range[1]]), "u" > typeof (_ = this.performAction.apply(L, [
							o,
							u,
							l,
							g,
							T[1],
							n,
							a
						].concat(p)))) return _;
						C && (r = r.slice(0, -1 * C * 2), n = n.slice(0, -1 * C), a = a.slice(0, -1 * C)), r.push(this.productions_[T[1]][0]), n.push(L.$), a.push(L._$), S = s[r[r.length - 2]][r[r.length - 1]], r.push(S);
						break;
					case 3: return !0;
				}
			}
			return !0;
		}, "parse")
	};
	function O() {
		this.yy = {};
	}
	return D.lexer = {
		EOF: 1,
		parseError: h(function(e, t) {
			if (this.yy.parser) this.yy.parser.parseError(e, t);
			else throw Error(e);
		}, "parseError"),
		setInput: h(function(e, t) {
			return this.yy = t || this.yy || {}, this._input = e, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
				first_line: 1,
				first_column: 0,
				last_line: 1,
				last_column: 0
			}, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
		}, "setInput"),
		input: h(function() {
			var e = this._input[0];
			return this.yytext += e, this.yyleng++, this.offset++, this.match += e, this.matched += e, e.match(/(?:\r\n?|\n).*/g) ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), e;
		}, "input"),
		unput: h(function(e) {
			var t = e.length, r = e.split(/(?:\r\n?|\n)/g);
			this._input = e + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - t), this.offset -= t;
			var i = this.match.split(/(?:\r\n?|\n)/g);
			this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), r.length - 1 && (this.yylineno -= r.length - 1);
			var n = this.yylloc.range;
			return this.yylloc = {
				first_line: this.yylloc.first_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.first_column,
				last_column: r ? (r.length === i.length ? this.yylloc.first_column : 0) + i[i.length - r.length].length - r[0].length : this.yylloc.first_column - t
			}, this.options.ranges && (this.yylloc.range = [n[0], n[0] + this.yyleng - t]), this.yyleng = this.yytext.length, this;
		}, "unput"),
		more: h(function() {
			return this._more = !0, this;
		}, "more"),
		reject: h(function() {
			return this.options.backtrack_lexer ? (this._backtrack = !0, this) : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "reject"),
		less: h(function(e) {
			this.unput(this.match.slice(e));
		}, "less"),
		pastInput: h(function() {
			var e = this.matched.substr(0, this.matched.length - this.match.length);
			return (e.length > 20 ? "..." : "") + e.substr(-20).replace(/\n/g, "");
		}, "pastInput"),
		upcomingInput: h(function() {
			var e = this.match;
			return e.length < 20 && (e += this._input.substr(0, 20 - e.length)), (e.substr(0, 20) + (e.length > 20 ? "..." : "")).replace(/\n/g, "");
		}, "upcomingInput"),
		showPosition: h(function() {
			var e = this.pastInput(), t = Array(e.length + 1).join("-");
			return e + this.upcomingInput() + `
` + t + "^";
		}, "showPosition"),
		test_match: h(function(e, t) {
			var r, i, n;
			if (this.options.backtrack_lexer && (n = {
				yylineno: this.yylineno,
				yylloc: {
					first_line: this.yylloc.first_line,
					last_line: this.last_line,
					first_column: this.yylloc.first_column,
					last_column: this.yylloc.last_column
				},
				yytext: this.yytext,
				match: this.match,
				matches: this.matches,
				matched: this.matched,
				yyleng: this.yyleng,
				offset: this.offset,
				_more: this._more,
				_input: this._input,
				yy: this.yy,
				conditionStack: this.conditionStack.slice(0),
				done: this.done
			}, this.options.ranges && (n.yylloc.range = this.yylloc.range.slice(0))), (i = e[0].match(/(?:\r\n?|\n).*/g)) && (this.yylineno += i.length), this.yylloc = {
				first_line: this.yylloc.last_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.last_column,
				last_column: i ? i[i.length - 1].length - i[i.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + e[0].length
			}, this.yytext += e[0], this.match += e[0], this.matches = e, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(e[0].length), this.matched += e[0], r = this.performAction.call(this, this.yy, this, t, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), r) return r;
			if (this._backtrack) for (var a in n) this[a] = n[a];
			return !1;
		}, "test_match"),
		next: h(function() {
			if (this.done) return this.EOF;
			this._input || (this.done = !0), this._more || (this.yytext = "", this.match = "");
			for (var e, t, r, i, n = this._currentRules(), a = 0; a < n.length; a++) if ((r = this._input.match(this.rules[n[a]])) && (!t || r[0].length > t[0].length)) {
				if (t = r, i = a, this.options.backtrack_lexer) {
					if (!1 !== (e = this.test_match(r, n[a]))) return e;
					if (!this._backtrack) return !1;
					t = !1;
					continue;
				} else if (!this.options.flex) break;
			}
			return t ? !1 !== (e = this.test_match(t, n[i])) && e : "" === this._input ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "next"),
		lex: h(function() {
			return this.next() || this.lex();
		}, "lex"),
		begin: h(function(e) {
			this.conditionStack.push(e);
		}, "begin"),
		popState: h(function() {
			return this.conditionStack.length - 1 > 0 ? this.conditionStack.pop() : this.conditionStack[0];
		}, "popState"),
		_currentRules: h(function() {
			return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
		}, "_currentRules"),
		topState: h(function(e) {
			return (e = this.conditionStack.length - 1 - Math.abs(e || 0)) >= 0 ? this.conditionStack[e] : "INITIAL";
		}, "topState"),
		pushState: h(function(e) {
			this.begin(e);
		}, "pushState"),
		stateStackSize: h(function() {
			return this.conditionStack.length;
		}, "stateStackSize"),
		options: { "case-insensitive": !0 },
		performAction: h(function(e, t, r, i) {
			switch (r) {
				case 0: return 38;
				case 1: return 40;
				case 2: return 39;
				case 3: return 44;
				case 4:
				case 45: return 51;
				case 5:
				case 46: return 52;
				case 6:
				case 47: return 53;
				case 7:
				case 48: return 54;
				case 8:
				case 9:
				case 11:
				case 12:
				case 13:
				case 14:
				case 57:
				case 59:
				case 65: break;
				case 10:
				case 80: return 5;
				case 15:
				case 35: return this.pushState("SCALE"), 17;
				case 16:
				case 36: return 18;
				case 17:
				case 23:
				case 37:
				case 52:
				case 55:
					this.popState();
					break;
				case 18: return this.begin("acc_title"), 33;
				case 19: return this.popState(), "acc_title_value";
				case 20: return this.begin("acc_descr"), 35;
				case 21: return this.popState(), "acc_descr_value";
				case 22:
					this.begin("acc_descr_multiline");
					break;
				case 24: return "acc_descr_multiline_value";
				case 25: return this.pushState("CLASSDEF"), 41;
				case 26: return this.popState(), this.pushState("CLASSDEFID"), "DEFAULT_CLASSDEF_ID";
				case 27: return this.popState(), this.pushState("CLASSDEFID"), 42;
				case 28: return this.popState(), 43;
				case 29: return this.pushState("CLASS"), 48;
				case 30: return this.popState(), this.pushState("CLASS_STYLE"), 49;
				case 31: return this.popState(), 50;
				case 32: return this.pushState("STYLE"), 45;
				case 33: return this.popState(), this.pushState("STYLEDEF_STYLES"), 46;
				case 34: return this.popState(), 47;
				case 38:
					this.pushState("STATE");
					break;
				case 39:
				case 42: return this.popState(), t.yytext = t.yytext.slice(0, -8).trim(), 25;
				case 40:
				case 43: return this.popState(), t.yytext = t.yytext.slice(0, -8).trim(), 26;
				case 41:
				case 44: return this.popState(), t.yytext = t.yytext.slice(0, -10).trim(), 27;
				case 49:
					this.pushState("STATE_STRING");
					break;
				case 50: return this.pushState("STATE_ID"), "AS";
				case 51:
				case 67: return this.popState(), "ID";
				case 53: return "STATE_DESCR";
				case 54: return 19;
				case 56: return this.popState(), this.pushState("struct"), 20;
				case 58: return this.popState(), 21;
				case 60: return this.begin("NOTE"), 29;
				case 61: return this.popState(), this.pushState("NOTE_ID"), 59;
				case 62: return this.popState(), this.pushState("NOTE_ID"), 60;
				case 63:
					this.popState(), this.pushState("FLOATING_NOTE");
					break;
				case 64: return this.popState(), this.pushState("FLOATING_NOTE_ID"), "AS";
				case 66: return "NOTE_TEXT";
				case 68: return this.popState(), this.pushState("NOTE_TEXT"), 24;
				case 69: return this.popState(), t.yytext = t.yytext.substr(2).trim(), 31;
				case 70: return this.popState(), t.yytext = t.yytext.slice(0, -8).trim(), 31;
				case 71:
				case 72: return 6;
				case 73: return 16;
				case 74: return 57;
				case 75: return 24;
				case 76: return t.yytext = t.yytext.trim(), 14;
				case 77: return 15;
				case 78: return 28;
				case 79: return 58;
				case 81: return "INVALID";
			}
		}, "anonymous"),
		rules: [
			/^(?:click\b)/i,
			/^(?:href\b)/i,
			/^(?:"[^"]*")/i,
			/^(?:default\b)/i,
			/^(?:.*direction\s+TB[^\n]*)/i,
			/^(?:.*direction\s+BT[^\n]*)/i,
			/^(?:.*direction\s+RL[^\n]*)/i,
			/^(?:.*direction\s+LR[^\n]*)/i,
			/^(?:%%(?!\{)[^\n]*)/i,
			/^(?:[^\}]%%[^\n]*)/i,
			/^(?:[\n]+)/i,
			/^(?:[\s]+)/i,
			/^(?:((?!\n)\s)+)/i,
			/^(?:#[^\n]*)/i,
			/^(?:%[^\n]*)/i,
			/^(?:scale\s+)/i,
			/^(?:\d+)/i,
			/^(?:\s+width\b)/i,
			/^(?:accTitle\s*:\s*)/i,
			/^(?:(?!\n||)*[^\n]*)/i,
			/^(?:accDescr\s*:\s*)/i,
			/^(?:(?!\n||)*[^\n]*)/i,
			/^(?:accDescr\s*\{\s*)/i,
			/^(?:[\}])/i,
			/^(?:[^\}]*)/i,
			/^(?:classDef\s+)/i,
			/^(?:DEFAULT\s+)/i,
			/^(?:\w+\s+)/i,
			/^(?:[^\n]*)/i,
			/^(?:class\s+)/i,
			/^(?:(\w+)+((,\s*\w+)*))/i,
			/^(?:[^\n]*)/i,
			/^(?:style\s+)/i,
			/^(?:[\w,]+\s+)/i,
			/^(?:[^\n]*)/i,
			/^(?:scale\s+)/i,
			/^(?:\d+)/i,
			/^(?:\s+width\b)/i,
			/^(?:state\s+)/i,
			/^(?:.*<<fork>>)/i,
			/^(?:.*<<join>>)/i,
			/^(?:.*<<choice>>)/i,
			/^(?:.*\[\[fork\]\])/i,
			/^(?:.*\[\[join\]\])/i,
			/^(?:.*\[\[choice\]\])/i,
			/^(?:.*direction\s+TB[^\n]*)/i,
			/^(?:.*direction\s+BT[^\n]*)/i,
			/^(?:.*direction\s+RL[^\n]*)/i,
			/^(?:.*direction\s+LR[^\n]*)/i,
			/^(?:["])/i,
			/^(?:\s*as\s+)/i,
			/^(?:[^\n\{]*)/i,
			/^(?:["])/i,
			/^(?:[^"]*)/i,
			/^(?:[^\n\s\{]+)/i,
			/^(?:\n)/i,
			/^(?:\{)/i,
			/^(?:%%(?!\{)[^\n]*)/i,
			/^(?:\})/i,
			/^(?:[\n])/i,
			/^(?:note\s+)/i,
			/^(?:left of\b)/i,
			/^(?:right of\b)/i,
			/^(?:")/i,
			/^(?:\s*as\s*)/i,
			/^(?:["])/i,
			/^(?:[^"]*)/i,
			/^(?:[^\n]*)/i,
			/^(?:\s*[^:\n\s\-]+)/i,
			/^(?:\s*:[^:\n;]+)/i,
			/^(?:[\s\S]*?end note\b)/i,
			/^(?:stateDiagram\s+)/i,
			/^(?:stateDiagram-v2\s+)/i,
			/^(?:hide empty description\b)/i,
			/^(?:\[\*\])/i,
			/^(?:[^:\n\s\-\{]+)/i,
			/^(?:\s*:[^:\n;]+)/i,
			/^(?:-->)/i,
			/^(?:--)/i,
			/^(?::::)/i,
			/^(?:$)/i,
			/^(?:.)/i
		],
		conditions: {
			LINE: {
				rules: [12, 13],
				inclusive: !1
			},
			struct: {
				rules: [
					12,
					13,
					25,
					29,
					32,
					38,
					45,
					46,
					47,
					48,
					57,
					58,
					59,
					60,
					74,
					75,
					76,
					77,
					78
				],
				inclusive: !1
			},
			FLOATING_NOTE_ID: {
				rules: [67],
				inclusive: !1
			},
			FLOATING_NOTE: {
				rules: [
					64,
					65,
					66
				],
				inclusive: !1
			},
			NOTE_TEXT: {
				rules: [69, 70],
				inclusive: !1
			},
			NOTE_ID: {
				rules: [68],
				inclusive: !1
			},
			NOTE: {
				rules: [
					61,
					62,
					63
				],
				inclusive: !1
			},
			STYLEDEF_STYLEOPTS: {
				rules: [],
				inclusive: !1
			},
			STYLEDEF_STYLES: {
				rules: [34],
				inclusive: !1
			},
			STYLE_IDS: {
				rules: [],
				inclusive: !1
			},
			STYLE: {
				rules: [33],
				inclusive: !1
			},
			CLASS_STYLE: {
				rules: [31],
				inclusive: !1
			},
			CLASS: {
				rules: [30],
				inclusive: !1
			},
			CLASSDEFID: {
				rules: [28],
				inclusive: !1
			},
			CLASSDEF: {
				rules: [26, 27],
				inclusive: !1
			},
			acc_descr_multiline: {
				rules: [23, 24],
				inclusive: !1
			},
			acc_descr: {
				rules: [21],
				inclusive: !1
			},
			acc_title: {
				rules: [19],
				inclusive: !1
			},
			SCALE: {
				rules: [
					16,
					17,
					36,
					37
				],
				inclusive: !1
			},
			ALIAS: {
				rules: [],
				inclusive: !1
			},
			STATE_ID: {
				rules: [51],
				inclusive: !1
			},
			STATE_STRING: {
				rules: [52, 53],
				inclusive: !1
			},
			FORK_STATE: {
				rules: [],
				inclusive: !1
			},
			STATE: {
				rules: [
					12,
					13,
					39,
					40,
					41,
					42,
					43,
					44,
					49,
					50,
					54,
					55,
					56
				],
				inclusive: !1
			},
			ID: {
				rules: [12, 13],
				inclusive: !1
			},
			INITIAL: {
				rules: [
					0,
					1,
					2,
					3,
					4,
					5,
					6,
					7,
					8,
					9,
					10,
					11,
					13,
					14,
					15,
					18,
					20,
					22,
					25,
					29,
					32,
					35,
					38,
					56,
					60,
					71,
					72,
					73,
					74,
					75,
					76,
					77,
					79,
					80,
					81
				],
				inclusive: !0
			}
		}
	}, h(O, "Parser"), O.prototype = D, D.Parser = O, new O();
}();
ex3.parser = ex3;
var ex6 = "state", ex7 = "root", ex8 = "relation", ex9 = "default", ebe = "divider", ebt = "fill:none", ebr = "fill: #333", ebi = "text", ebn = "normal", eba = "rect", ebs = "rectWithTitle", ebo = "divider", ebl = "roundedWithTitle", ebc = "statediagram", ebh = `${ebc}-state`, ebu = "transition", ebd = `${ebu} note-edge`, ebp = `${ebc}-note`, ebf = `${ebc}-cluster`, ebg = `${ebc}-cluster-alt`, ebm = "parent", eby = "note", ebv = "----", ebx = `${ebv}${eby}`, ebb = `${ebv}${ebm}`, ebw = h((e, t = "TB") => {
	if (!e.doc) return t;
	let r = t;
	for (let t of e.doc) "dir" === t.stmt && (r = t.value);
	return r;
}, "getDir"), ebk = {
	getClasses: h(function(e, t) {
		return t.db.getClasses();
	}, "getClasses"),
	draw: h(async function(e, t, r, i) {
		wQ.info("REF0:"), wQ.info("Drawing state diagram (v2)", t);
		let { securityLevel: n, state: a, layout: s } = IA();
		i.db.extract(i.db.getRootDocV2());
		let o = i.db.getData(), l = JW(t, n);
		o.type = i.type, o.layoutAlgorithm = s, o.nodeSpacing = a?.nodeSpacing || 50, o.rankSpacing = a?.rankSpacing || 50, o.markers = ["barb"], o.diagramId = t, await eii(o, l);
		try {
			("function" == typeof i.db.getLinks ? i.db.getLinks() : /* @__PURE__ */ new Map()).forEach((e, t) => {
				let r = "string" == typeof t ? t : "string" == typeof t?.id ? t.id : "";
				if (!r) return void wQ.warn(" Invalid or missing stateId from key:", JSON.stringify(t));
				let i = l.node()?.querySelectorAll("g"), n;
				if (i?.forEach((e) => {
					e.textContent?.trim() === r && (n = e);
				}), !n) return void wQ.warn(" Could not find node matching text:", r);
				let a = n.parentNode;
				if (!a) return void wQ.warn(" Node has no parent, cannot wrap:", r);
				let s = document.createElementNS("http://www.w3.org/2000/svg", "a"), o = e.url.replace(/^"+|"+$/g, "");
				if (s.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", o), s.setAttribute("target", "_blank"), e.tooltip) {
					let t = e.tooltip.replace(/^"+|"+$/g, "");
					s.setAttribute("title", t);
				}
				a.replaceChild(s, n), s.appendChild(n), wQ.info(" Wrapped node in <a> tag for:", r, e.url);
			});
		} catch (e) {
			wQ.error(" Error injecting clickable links:", e);
		}
		V2(l, "statediagramTitleText", a?.titleTopMargin ?? 25, i.db.getDiagramTitle()), JY(l, 8, ebc, a?.useMaxWidth ?? !0);
	}, "draw"),
	getDir: ebw
}, ebT = /* @__PURE__ */ new Map(), eb_ = 0;
function ebE(e = "", t = 0, r = "", i = ebv) {
	return `state-${e}${null !== r && r.length > 0 ? `${i}${r}` : ""}-${t}`;
}
h(ebE, "stateDomId");
var ebC = h((e, t, r, i, n, a, s, o) => {
	wQ.trace("items", t), t.forEach((t) => {
		switch (t.stmt) {
			case ex6:
			case ex9:
				ebI(e, t, r, i, n, a, s, o);
				break;
			case ex8: {
				ebI(e, t.state1, r, i, n, a, s, o), ebI(e, t.state2, r, i, n, a, s, o);
				let l = {
					id: "edge" + eb_,
					start: t.state1.id,
					end: t.state2.id,
					arrowhead: "normal",
					arrowTypeEnd: "arrow_barb",
					style: ebt,
					labelStyle: "",
					label: M1.sanitizeText(t.description ?? "", IA()),
					arrowheadStyle: ebr,
					labelpos: "c",
					labelType: ebi,
					thickness: ebn,
					classes: ebu,
					look: s
				};
				n.push(l), eb_++;
			}
		}
	});
}, "setupDoc"), ebS = h((e, t = "TB") => {
	let r = t;
	if (e.doc) for (let t of e.doc) "dir" === t.stmt && (r = t.value);
	return r;
}, "getDir");
function ebA(e, t, r) {
	if (!t.id || "</join></fork>" === t.id || "</choice>" === t.id) return;
	t.cssClasses && (Array.isArray(t.cssCompiledStyles) || (t.cssCompiledStyles = []), t.cssClasses.split(" ").forEach((e) => {
		let i = r.get(e);
		i && (t.cssCompiledStyles = [...t.cssCompiledStyles ?? [], ...i.styles]);
	}));
	let i = e.find((e) => e.id === t.id);
	i ? Object.assign(i, t) : e.push(t);
}
function ebL(e) {
	return e?.classes?.join(" ") ?? "";
}
function ebR(e) {
	return e?.styles ?? [];
}
h(ebA, "insertOrUpdateNode"), h(ebL, "getClassesFromDbInfo"), h(ebR, "getStylesFromDbInfo");
var ebN, ebI = h((e, t, r, i, n, a, s, o) => {
	let l = t.id, h = r.get(l), u = ebL(h), d = ebR(h), p = IA();
	if (wQ.info("dataFetcher parsedItem", t, h, d), "root" !== l) {
		let r = eba;
		!0 === t.start ? r = "stateStart" : !1 === t.start && (r = "stateEnd"), t.type !== ex9 && (r = t.type), ebT.get(l) || ebT.set(l, {
			id: l,
			shape: r,
			description: M1.sanitizeText(l, p),
			cssClasses: `${u} ${ebh}`,
			cssStyles: d
		});
		let h = ebT.get(l);
		t.description && (Array.isArray(h.description) ? (h.shape = ebs, h.description.push(t.description)) : h.description?.length && h.description.length > 0 ? (h.shape = ebs, h.description === l ? h.description = [t.description] : h.description = [h.description, t.description]) : (h.shape = eba, h.description = t.description), h.description = M1.sanitizeTextOrArray(h.description, p)), h.description?.length === 1 && h.shape === ebs && ("group" === h.type ? h.shape = ebl : h.shape = eba), !h.type && t.doc && (wQ.info("Setting cluster for XCX", l, ebS(t)), h.type = "group", h.isGroup = !0, h.dir = ebS(t), h.shape = t.type === ebe ? ebo : ebl, h.cssClasses = `${h.cssClasses} ${ebf} ${a ? ebg : ""}`);
		let f = {
			labelStyle: "",
			shape: h.shape,
			label: h.description,
			cssClasses: h.cssClasses,
			cssCompiledStyles: [],
			cssStyles: h.cssStyles,
			id: l,
			dir: h.dir,
			domId: ebE(l, eb_),
			type: h.type,
			isGroup: "group" === h.type,
			padding: 8,
			rx: 10,
			ry: 10,
			look: s
		};
		if (f.shape === ebo && (f.label = ""), e && "root" !== e.id && (wQ.trace("Setting node ", l, " to be child of its parent ", e.id), f.parentId = e.id), f.centerLabel = !0, t.note) {
			let e = {
				labelStyle: "",
				shape: "note",
				label: t.note.text,
				cssClasses: ebp,
				cssStyles: [],
				cssCompiledStyles: [],
				id: l + ebx + "-" + eb_,
				domId: ebE(l, eb_, eby),
				type: h.type,
				isGroup: "group" === h.type,
				padding: p.flowchart?.padding,
				look: s,
				position: t.note.position
			}, r = l + ebb, a = {
				labelStyle: "",
				shape: "noteGroup",
				label: t.note.text,
				cssClasses: h.cssClasses,
				cssStyles: [],
				id: l + ebb,
				domId: ebE(l, eb_, ebm),
				type: "group",
				isGroup: !0,
				padding: 16,
				look: s,
				position: t.note.position
			};
			eb_++, a.id = r, e.parentId = r, ebA(i, a, o), ebA(i, e, o), ebA(i, f, o);
			let u = l, d = e.id;
			"left of" === t.note.position && (u = e.id, d = l), n.push({
				id: u + "-" + d,
				start: u,
				end: d,
				arrowhead: "none",
				arrowTypeEnd: "",
				style: ebt,
				labelStyle: "",
				classes: ebd,
				arrowheadStyle: ebr,
				labelpos: "c",
				labelType: ebi,
				thickness: ebn,
				look: s
			});
		} else ebA(i, f, o);
	}
	t.doc && (wQ.trace("Adding nodes children "), ebC(t, t.doc, r, i, n, !a, s, o));
}, "dataFetcher"), ebM = h(() => {
	ebT.clear(), eb_ = 0;
}, "reset"), ebD = "start", ebO = "color", eb$ = "fill", ebP = h(() => /* @__PURE__ */ new Map(), "newClassesList"), ebB = h(() => ({
	relations: [],
	states: /* @__PURE__ */ new Map(),
	documents: {}
}), "newDoc"), ebF = h((e) => JSON.parse(JSON.stringify(e)), "clone"), ebz = class {
	constructor(e) {
		this.version = e, this.nodes = [], this.edges = [], this.rootDoc = [], this.classes = ebP(), this.documents = { root: ebB() }, this.currentDocument = this.documents.root, this.startEndCount = 0, this.dividerCnt = 0, this.links = /* @__PURE__ */ new Map(), this.getAccTitle = Ds, this.setAccTitle = Da, this.getAccDescription = Dl, this.setAccDescription = Do, this.setDiagramTitle = Dc, this.getDiagramTitle = Dh, this.clear(), this.setRootDoc = this.setRootDoc.bind(this), this.getDividerId = this.getDividerId.bind(this), this.setDirection = this.setDirection.bind(this), this.trimColon = this.trimColon.bind(this);
	}
	static {
		h(this, "StateDB");
	}
	static {
		this.relationType = {
			AGGREGATION: 0,
			EXTENSION: 1,
			COMPOSITION: 2,
			DEPENDENCY: 3
		};
	}
	extract(e) {
		for (let t of (this.clear(!0), Array.isArray(e) ? e : e.doc)) switch (t.stmt) {
			case ex6:
				this.addState(t.id.trim(), t.type, t.doc, t.description, t.note);
				break;
			case ex8:
				this.addRelation(t.state1, t.state2, t.description);
				break;
			case "classDef":
				this.addStyleClass(t.id.trim(), t.classes);
				break;
			case "style":
				this.handleStyleDef(t);
				break;
			case "applyClass":
				this.setCssClass(t.id.trim(), t.styleClass);
				break;
			case "click": this.addLink(t.id, t.url, t.tooltip);
		}
		let t = this.getStates(), r = IA();
		for (let e of (ebM(), ebI(void 0, this.getRootDocV2(), t, this.nodes, this.edges, !0, r.look, this.classes), this.nodes)) if (Array.isArray(e.label)) {
			if (e.description = e.label.slice(1), e.isGroup && e.description.length > 0) throw Error(`Group nodes can only have label. Remove the additional description for node [${e.id}]`);
			e.label = e.label[0];
		}
	}
	handleStyleDef(e) {
		let t = e.id.trim().split(","), r = e.styleClass.split(",");
		for (let e of t) {
			let t = this.getState(e);
			if (!t) {
				let r = e.trim();
				this.addState(r), t = this.getState(r);
			}
			t && (t.styles = r.map((e) => e.replace(/;/g, "")?.trim()));
		}
	}
	setRootDoc(e) {
		wQ.info("Setting root doc", e), this.rootDoc = e, 1 === this.version ? this.extract(e) : this.extract(this.getRootDocV2());
	}
	docTranslator(e, t, r) {
		if (t.stmt === ex8) {
			this.docTranslator(e, t.state1, !0), this.docTranslator(e, t.state2, !1);
			return;
		}
		if (t.stmt === ex6 && ("[*]" === t.id ? (t.id = e.id + (r ? "_start" : "_end"), t.start = r) : t.id = t.id.trim()), t.stmt !== ex7 && t.stmt !== ex6 || !t.doc) return;
		let i = [], n = [];
		for (let e of t.doc) if (e.type === ebe) {
			let t = ebF(e);
			t.doc = ebF(n), i.push(t), n = [];
		} else n.push(e);
		if (i.length > 0 && n.length > 0) {
			let e = {
				stmt: ex6,
				id: Vz(),
				type: "divider",
				doc: ebF(n)
			};
			i.push(ebF(e)), t.doc = i;
		}
		t.doc.forEach((e) => this.docTranslator(t, e, !0));
	}
	getRootDocV2() {
		return this.docTranslator({
			id: ex7,
			stmt: ex7
		}, {
			id: ex7,
			stmt: ex7,
			doc: this.rootDoc
		}, !0), {
			id: ex7,
			doc: this.rootDoc
		};
	}
	addState(e, t = ex9, r, i, n, a, s, o) {
		let l = e?.trim();
		if (this.currentDocument.states.has(l)) {
			let e = this.currentDocument.states.get(l);
			if (!e) throw Error(`State not found: ${l}`);
			e.doc || (e.doc = r), e.type || (e.type = t);
		} else wQ.info("Adding state ", l, i), this.currentDocument.states.set(l, {
			stmt: ex6,
			id: l,
			descriptions: [],
			type: t,
			doc: r,
			note: n,
			classes: [],
			styles: [],
			textStyles: []
		});
		if (i && (wQ.info("Setting state description", l, i), (Array.isArray(i) ? i : [i]).forEach((e) => this.addDescription(l, e.trim()))), n) {
			let e = this.currentDocument.states.get(l);
			if (!e) throw Error(`State not found: ${l}`);
			e.note = n, e.note.text = M1.sanitizeText(e.note.text, IA());
		}
		a && (wQ.info("Setting state classes", l, a), (Array.isArray(a) ? a : [a]).forEach((e) => this.setCssClass(l, e.trim()))), s && (wQ.info("Setting state styles", l, s), (Array.isArray(s) ? s : [s]).forEach((e) => this.setStyle(l, e.trim()))), o && (wQ.info("Setting state styles", l, s), (Array.isArray(o) ? o : [o]).forEach((e) => this.setTextStyle(l, e.trim())));
	}
	clear(e) {
		this.nodes = [], this.edges = [], this.documents = { root: ebB() }, this.currentDocument = this.documents.root, this.startEndCount = 0, this.classes = ebP(), e || (this.links = /* @__PURE__ */ new Map(), Dn());
	}
	getState(e) {
		return this.currentDocument.states.get(e);
	}
	getStates() {
		return this.currentDocument.states;
	}
	logDocuments() {
		wQ.info("Documents = ", this.documents);
	}
	getRelations() {
		return this.currentDocument.relations;
	}
	addLink(e, t, r) {
		this.links.set(e, {
			url: t,
			tooltip: r
		}), wQ.warn("Adding link", e, t, r);
	}
	getLinks() {
		return this.links;
	}
	startIdIfNeeded(e = "") {
		return "[*]" === e ? (this.startEndCount++, `${ebD}${this.startEndCount}`) : e;
	}
	startTypeIfNeeded(e = "", t = ex9) {
		return "[*]" === e ? ebD : t;
	}
	endIdIfNeeded(e = "") {
		return "[*]" === e ? (this.startEndCount++, `end${this.startEndCount}`) : e;
	}
	endTypeIfNeeded(e = "", t = ex9) {
		return "[*]" === e ? "end" : t;
	}
	addRelationObjs(e, t, r = "") {
		let i = this.startIdIfNeeded(e.id.trim()), n = this.startTypeIfNeeded(e.id.trim(), e.type), a = this.startIdIfNeeded(t.id.trim()), s = this.startTypeIfNeeded(t.id.trim(), t.type);
		this.addState(i, n, e.doc, e.description, e.note, e.classes, e.styles, e.textStyles), this.addState(a, s, t.doc, t.description, t.note, t.classes, t.styles, t.textStyles), this.currentDocument.relations.push({
			id1: i,
			id2: a,
			relationTitle: M1.sanitizeText(r, IA())
		});
	}
	addRelation(e, t, r) {
		if ("object" == typeof e && "object" == typeof t) this.addRelationObjs(e, t, r);
		else if ("string" == typeof e && "string" == typeof t) {
			let i = this.startIdIfNeeded(e.trim()), n = this.startTypeIfNeeded(e), a = this.endIdIfNeeded(t.trim()), s = this.endTypeIfNeeded(t);
			this.addState(i, n), this.addState(a, s), this.currentDocument.relations.push({
				id1: i,
				id2: a,
				relationTitle: r ? M1.sanitizeText(r, IA()) : void 0
			});
		}
	}
	addDescription(e, t) {
		let r = this.currentDocument.states.get(e), i = t.startsWith(":") ? t.replace(":", "").trim() : t;
		r?.descriptions?.push(M1.sanitizeText(i, IA()));
	}
	cleanupLabel(e) {
		return e.startsWith(":") ? e.slice(2).trim() : e.trim();
	}
	getDividerId() {
		return this.dividerCnt++, `divider-id-${this.dividerCnt}`;
	}
	addStyleClass(e, t = "") {
		this.classes.has(e) || this.classes.set(e, {
			id: e,
			styles: [],
			textStyles: []
		});
		let r = this.classes.get(e);
		t && r && t.split(",").forEach((e) => {
			let t = e.replace(/([^;]*);/, "$1").trim();
			if (RegExp(ebO).exec(e)) {
				let e = t.replace(eb$, "bgFill").replace(ebO, eb$);
				r.textStyles.push(e);
			}
			r.styles.push(t);
		});
	}
	getClasses() {
		return this.classes;
	}
	setCssClass(e, t) {
		e.split(",").forEach((e) => {
			let r = this.getState(e);
			if (!r) {
				let t = e.trim();
				this.addState(t), r = this.getState(t);
			}
			r?.classes?.push(t);
		});
	}
	setStyle(e, t) {
		this.getState(e)?.styles?.push(t);
	}
	setTextStyle(e, t) {
		this.getState(e)?.textStyles?.push(t);
	}
	getDirectionStatement() {
		return this.rootDoc.find((e) => "dir" === e.stmt);
	}
	getDirection() {
		return this.getDirectionStatement()?.value ?? "TB";
	}
	setDirection(e) {
		let t = this.getDirectionStatement();
		t ? t.value = e : this.rootDoc.unshift({
			stmt: "dir",
			value: e
		});
	}
	trimColon(e) {
		return e.startsWith(":") ? e.slice(1).trim() : e.trim();
	}
	getData() {
		let e = IA();
		return {
			nodes: this.nodes,
			edges: this.edges,
			other: {},
			config: e,
			direction: ebw(this.getRootDocV2())
		};
	}
	getConfig() {
		return IA().state;
	}
}, ebU = h((e) => `
defs #statediagram-barbEnd {
    fill: ${e.transitionColor};
    stroke: ${e.transitionColor};
  }
g.stateGroup text {
  fill: ${e.nodeBorder};
  stroke: none;
  font-size: 10px;
}
g.stateGroup text {
  fill: ${e.textColor};
  stroke: none;
  font-size: 10px;

}
g.stateGroup .state-title {
  font-weight: bolder;
  fill: ${e.stateLabelColor};
}

g.stateGroup rect {
  fill: ${e.mainBkg};
  stroke: ${e.nodeBorder};
}

g.stateGroup line {
  stroke: ${e.lineColor};
  stroke-width: 1;
}

.transition {
  stroke: ${e.transitionColor};
  stroke-width: 1;
  fill: none;
}

.stateGroup .composit {
  fill: ${e.background};
  border-bottom: 1px
}

.stateGroup .alt-composit {
  fill: #e0e0e0;
  border-bottom: 1px
}

.state-note {
  stroke: ${e.noteBorderColor};
  fill: ${e.noteBkgColor};

  text {
    fill: ${e.noteTextColor};
    stroke: none;
    font-size: 10px;
  }
}

.stateLabel .box {
  stroke: none;
  stroke-width: 0;
  fill: ${e.mainBkg};
  opacity: 0.5;
}

.edgeLabel .label rect {
  fill: ${e.labelBackgroundColor};
  opacity: 0.5;
}
.edgeLabel {
  background-color: ${e.edgeLabelBackground};
  p {
    background-color: ${e.edgeLabelBackground};
  }
  rect {
    opacity: 0.5;
    background-color: ${e.edgeLabelBackground};
    fill: ${e.edgeLabelBackground};
  }
  text-align: center;
}
.edgeLabel .label text {
  fill: ${e.transitionLabelColor || e.tertiaryTextColor};
}
.label div .edgeLabel {
  color: ${e.transitionLabelColor || e.tertiaryTextColor};
}

.stateLabel text {
  fill: ${e.stateLabelColor};
  font-size: 10px;
  font-weight: bold;
}

.node circle.state-start {
  fill: ${e.specialStateColor};
  stroke: ${e.specialStateColor};
}

.node .fork-join {
  fill: ${e.specialStateColor};
  stroke: ${e.specialStateColor};
}

.node circle.state-end {
  fill: ${e.innerEndBackground};
  stroke: ${e.background};
  stroke-width: 1.5
}
.end-state-inner {
  fill: ${e.compositeBackground || e.background};
  // stroke: ${e.background};
  stroke-width: 1.5
}

.node rect {
  fill: ${e.stateBkg || e.mainBkg};
  stroke: ${e.stateBorder || e.nodeBorder};
  stroke-width: 1px;
}
.node polygon {
  fill: ${e.mainBkg};
  stroke: ${e.stateBorder || e.nodeBorder};;
  stroke-width: 1px;
}
#statediagram-barbEnd {
  fill: ${e.lineColor};
}

.statediagram-cluster rect {
  fill: ${e.compositeTitleBackground};
  stroke: ${e.stateBorder || e.nodeBorder};
  stroke-width: 1px;
}

.cluster-label, .nodeLabel {
  color: ${e.stateLabelColor};
  // line-height: 1;
}

.statediagram-cluster rect.outer {
  rx: 5px;
  ry: 5px;
}
.statediagram-state .divider {
  stroke: ${e.stateBorder || e.nodeBorder};
}

.statediagram-state .title-state {
  rx: 5px;
  ry: 5px;
}
.statediagram-cluster.statediagram-cluster .inner {
  fill: ${e.compositeBackground || e.background};
}
.statediagram-cluster.statediagram-cluster-alt .inner {
  fill: ${e.altBackground ? e.altBackground : "#efefef"};
}

.statediagram-cluster .inner {
  rx:0;
  ry:0;
}

.statediagram-state rect.basic {
  rx: 5px;
  ry: 5px;
}
.statediagram-state rect.divider {
  stroke-dasharray: 10,10;
  fill: ${e.altBackground ? e.altBackground : "#efefef"};
}

.note-edge {
  stroke-dasharray: 5;
}

.statediagram-note rect {
  fill: ${e.noteBkgColor};
  stroke: ${e.noteBorderColor};
  stroke-width: 1px;
  rx: 0;
  ry: 0;
}
.statediagram-note rect {
  fill: ${e.noteBkgColor};
  stroke: ${e.noteBorderColor};
  stroke-width: 1px;
  rx: 0;
  ry: 0;
}

.statediagram-note text {
  fill: ${e.noteTextColor};
}

.statediagram-note .nodeLabel {
  color: ${e.noteTextColor};
}
.statediagram .edgeLabel {
  color: red; // ${e.noteTextColor};
}

#dependencyStart, #dependencyEnd {
  fill: ${e.lineColor};
  stroke: ${e.lineColor};
  stroke-width: 1;
}

.statediagramTitleText {
  text-anchor: middle;
  font-size: 18px;
  fill: ${e.textColor};
}
`, "getStyles"), ebG = h((e) => e.append("circle").attr("class", "start-state").attr("r", IA().state.sizeUnit).attr("cx", IA().state.padding + IA().state.sizeUnit).attr("cy", IA().state.padding + IA().state.sizeUnit), "drawStartState"), ebq = h((e) => e.append("line").style("stroke", "grey").style("stroke-dasharray", "3").attr("x1", IA().state.textHeight).attr("class", "divider").attr("x2", 2 * IA().state.textHeight).attr("y1", 0).attr("y2", 0), "drawDivider"), ebj = h((e, t) => {
	let r = e.append("text").attr("x", 2 * IA().state.padding).attr("y", IA().state.textHeight + 2 * IA().state.padding).attr("font-size", IA().state.fontSize).attr("class", "state-title").text(t.id), i = r.node().getBBox();
	return e.insert("rect", ":first-child").attr("x", IA().state.padding).attr("y", IA().state.padding).attr("width", i.width + 2 * IA().state.padding).attr("height", i.height + 2 * IA().state.padding).attr("rx", IA().state.radius), r;
}, "drawSimpleState"), ebW = h((e, t) => {
	let r = h(function(e, t, r) {
		let i = e.append("tspan").attr("x", 2 * IA().state.padding).text(t);
		r || i.attr("dy", IA().state.textHeight);
	}, "addTspan"), i = e.append("text").attr("x", 2 * IA().state.padding).attr("y", IA().state.textHeight + 1.3 * IA().state.padding).attr("font-size", IA().state.fontSize).attr("class", "state-title").text(t.descriptions[0]).node().getBBox(), n = i.height, a = e.append("text").attr("x", IA().state.padding).attr("y", n + .4 * IA().state.padding + IA().state.dividerMargin + IA().state.textHeight).attr("class", "state-description"), s = !0, o = !0;
	t.descriptions.forEach(function(e) {
		s || (r(a, e, o), o = !1), s = !1;
	});
	let l = e.append("line").attr("x1", IA().state.padding).attr("y1", IA().state.padding + n + IA().state.dividerMargin / 2).attr("y2", IA().state.padding + n + IA().state.dividerMargin / 2).attr("class", "descr-divider"), u = a.node().getBBox(), d = Math.max(u.width, i.width);
	return l.attr("x2", d + 3 * IA().state.padding), e.insert("rect", ":first-child").attr("x", IA().state.padding).attr("y", IA().state.padding).attr("width", d + 2 * IA().state.padding).attr("height", u.height + n + 2 * IA().state.padding).attr("rx", IA().state.radius), e;
}, "drawDescrState"), ebY = h((e, t, r) => {
	let i = IA().state.padding, n = 2 * IA().state.padding, a = e.node().getBBox(), s = a.width, o = a.x, l = e.append("text").attr("x", 0).attr("y", IA().state.titleShift).attr("font-size", IA().state.fontSize).attr("class", "state-title").text(t.id), h = l.node().getBBox().width + n, u = Math.max(h, s);
	u === s && (u += n);
	let d, p = e.node().getBBox();
	t.doc, d = o - i, h > s && (d = (s - u) / 2 + i), Math.abs(o - p.x) < i && h > s && (d = o - (h - s) / 2);
	let f = 1 - IA().state.textHeight;
	return e.insert("rect", ":first-child").attr("x", d).attr("y", f).attr("class", r ? "alt-composit" : "composit").attr("width", u).attr("height", p.height + IA().state.textHeight + IA().state.titleShift + 1).attr("rx", "0"), l.attr("x", d + i), h <= s && l.attr("x", o + (u - n) / 2 - h / 2 + i), e.insert("rect", ":first-child").attr("x", d).attr("y", IA().state.titleShift - IA().state.textHeight - IA().state.padding).attr("width", u).attr("height", 3 * IA().state.textHeight).attr("rx", IA().state.radius), e.insert("rect", ":first-child").attr("x", d).attr("y", IA().state.titleShift - IA().state.textHeight - IA().state.padding).attr("width", u).attr("height", p.height + 3 + 2 * IA().state.textHeight).attr("rx", IA().state.radius), e;
}, "addTitleAndBox"), ebV = h((e) => (e.append("circle").attr("class", "end-state-outer").attr("r", IA().state.sizeUnit + IA().state.miniPadding).attr("cx", IA().state.padding + IA().state.sizeUnit + IA().state.miniPadding).attr("cy", IA().state.padding + IA().state.sizeUnit + IA().state.miniPadding), e.append("circle").attr("class", "end-state-inner").attr("r", IA().state.sizeUnit).attr("cx", IA().state.padding + IA().state.sizeUnit + 2).attr("cy", IA().state.padding + IA().state.sizeUnit + 2)), "drawEndState"), ebH = h((e, t) => {
	let r = IA().state.forkWidth, i = IA().state.forkHeight;
	if (t.parentId) {
		let e = r;
		r = i, i = e;
	}
	return e.append("rect").style("stroke", "black").style("fill", "black").attr("width", r).attr("height", i).attr("x", IA().state.padding).attr("y", IA().state.padding);
}, "drawForkJoinState"), ebX = h((e, t, r, i) => {
	let n = 0, a = i.append("text");
	a.style("text-anchor", "start"), a.attr("class", "noteText");
	let s = e.replace(/\r\n/g, "<br/>"), o = (s = s.replace(/\n/g, "<br/>")).split(M1.lineBreakRegex), l = 1.25 * IA().state.noteMargin;
	for (let e of o) {
		let i = e.trim();
		if (i.length > 0) {
			let e = a.append("tspan");
			e.text(i), 0 === l && (l += e.node().getBBox().height), n += l, e.attr("x", t + IA().state.noteMargin), e.attr("y", r + n + 1.25 * IA().state.noteMargin);
		}
	}
	return {
		textWidth: a.node().getBBox().width,
		textHeight: n
	};
}, "_drawLongText"), ebK = h((e, t) => {
	t.attr("class", "state-note");
	let r = t.append("rect").attr("x", 0).attr("y", IA().state.padding), { textWidth: i, textHeight: n } = ebX(e, 0, 0, t.append("g"));
	return r.attr("height", n + 2 * IA().state.noteMargin), r.attr("width", i + 2 * IA().state.noteMargin), r;
}, "drawNote"), ebZ = h(function(e, t) {
	let r = t.id, i = {
		id: r,
		label: t.id,
		width: 0,
		height: 0
	}, n = e.append("g").attr("id", r).attr("class", "stateGroup");
	"start" === t.type && ebG(n), "end" === t.type && ebV(n), ("fork" === t.type || "join" === t.type) && ebH(n, t), "note" === t.type && ebK(t.note.text, n), "divider" === t.type && ebq(n), "default" === t.type && 0 === t.descriptions.length && ebj(n, t), "default" === t.type && t.descriptions.length > 0 && ebW(n, t);
	let a = n.node().getBBox();
	return i.width = a.width + 2 * IA().state.padding, i.height = a.height + 2 * IA().state.padding, i;
}, "drawState"), ebQ = 0, ebJ = h(function(e, t, r) {
	let i = h(function(e) {
		switch (e) {
			case ebz.relationType.AGGREGATION: return "aggregation";
			case ebz.relationType.EXTENSION: return "extension";
			case ebz.relationType.COMPOSITION: return "composition";
			case ebz.relationType.DEPENDENCY: return "dependency";
		}
	}, "getRelationType");
	t.points = t.points.filter((e) => !Number.isNaN(e.y));
	let n = t.points, a = A5().x(function(e) {
		return e.x;
	}).y(function(e) {
		return e.y;
	}).curve(Li), s = e.append("path").attr("d", a(n)).attr("id", "edge" + ebQ).attr("class", "transition"), o = "";
	if (IA().state.arrowMarkerAbsolute && (o = MU(!0)), s.attr("marker-end", "url(" + o + "#" + i(ebz.relationType.DEPENDENCY) + "End)"), void 0 !== r.title) {
		let i = e.append("g").attr("class", "stateLabel"), { x: n, y: a } = VD(t.points), s = M1.getRows(r.title), o = 0, l = [], h = 0, u = 0;
		for (let e = 0; e <= s.length; e++) {
			let t = i.append("text").attr("text-anchor", "middle").text(s[e]).attr("x", n).attr("y", a + o), r = t.node().getBBox();
			h = Math.max(h, r.width), u = Math.min(u, r.x), wQ.info(r.x, n, a + o), 0 === o && (o = t.node().getBBox().height, wQ.info("Title height", o, a)), l.push(t);
		}
		let d = o * s.length;
		if (s.length > 1) {
			let e = (s.length - 1) * o * .5;
			l.forEach((t, r) => t.attr("y", a + r * o - e)), d = o * s.length;
		}
		let p = i.node().getBBox();
		i.insert("rect", ":first-child").attr("class", "box").attr("x", n - h / 2 - IA().state.padding / 2).attr("y", a - d / 2 - IA().state.padding / 2 - 3.5).attr("width", h + IA().state.padding).attr("height", d + IA().state.padding), wQ.info(p);
	}
	ebQ++;
}, "drawEdge"), eb0 = {}, eb1 = h(function() {}, "setConf"), eb2 = h(function(e) {
	e.append("defs").append("marker").attr("id", "dependencyEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
}, "insertMarkers"), eb4 = h(function(e, t, r, i) {
	ebN = IA().state;
	let n = IA().securityLevel, a;
	"sandbox" === n && (a = _t("#i" + t));
	let s = "sandbox" === n ? _t(a.nodes()[0].contentDocument.body) : _t("body"), o = "sandbox" === n ? a.nodes()[0].contentDocument : document;
	wQ.debug("Rendering diagram " + e);
	let l = s.select(`[id='${t}']`);
	eb2(l), eb3(i.db.getRootDoc(), l, void 0, !1, s, o, i);
	let h = ebN.padding, u = l.node().getBBox(), d = u.width + 2 * h, p = u.height + 2 * h;
	M5(l, p, 1.75 * d, ebN.useMaxWidth), l.attr("viewBox", `${u.x - ebN.padding}  ${u.y - ebN.padding} ` + d + " " + p);
}, "draw"), eb5 = h((e) => e ? e.length * ebN.fontSizeFactor : 1, "getLabelWidth"), eb3 = h((e, t, r, i, n, a, s) => {
	let o = new KD({
		compound: !0,
		multigraph: !0
	}), l, h = !0;
	for (l = 0; l < e.length; l++) if ("relation" === e[l].stmt) {
		h = !1;
		break;
	}
	r ? o.setGraph({
		rankdir: "LR",
		multigraph: !0,
		compound: !0,
		ranker: "tight-tree",
		ranksep: h ? 1 : ebN.edgeLengthFactor,
		nodeSep: h ? 1 : 50,
		isMultiGraph: !0
	}) : o.setGraph({
		rankdir: "TB",
		multigraph: !0,
		compound: !0,
		ranksep: h ? 1 : ebN.edgeLengthFactor,
		nodeSep: h ? 1 : 50,
		ranker: "tight-tree",
		isMultiGraph: !0
	}), o.setDefaultEdgeLabel(function() {
		return {};
	});
	let u = s.db.getStates(), d = s.db.getRelations();
	for (let e of Object.keys(u)) {
		let l, h = u[e];
		if (r && (h.parentId = r), h.doc) {
			let e = t.append("g").attr("id", h.id).attr("class", "stateGroup");
			l = eb3(h.doc, e, h.id, !i, n, a, s);
			{
				let t = (e = ebY(e, h, i)).node().getBBox();
				l.width = t.width, l.height = t.height + ebN.padding / 2, eb0[h.id] = { y: ebN.compositTitleSize };
			}
		} else l = ebZ(t, h, o);
		if (h.note) {
			let e = ebZ(t, {
				descriptions: [],
				id: h.id + "-note",
				note: h.note,
				type: "note"
			}, o);
			"left of" === h.note.position ? (o.setNode(l.id + "-note", e), o.setNode(l.id, l)) : (o.setNode(l.id, l), o.setNode(l.id + "-note", e)), o.setParent(l.id, l.id + "-group"), o.setParent(l.id + "-note", l.id + "-group");
		} else o.setNode(l.id, l);
	}
	wQ.debug("Count=", o.nodeCount(), o);
	let p = 0;
	d.forEach(function(e) {
		p++, wQ.debug("Setting edge", e), o.setEdge(e.id1, e.id2, {
			relation: e,
			width: eb5(e.title),
			height: ebN.labelHeight * M1.getRows(e.title).length,
			labelpos: "c"
		}, "id" + p);
	}), eac(o), wQ.debug("Graph after layout", o.nodes());
	let f = t.node();
	o.nodes().forEach(function(e) {
		void 0 !== e && void 0 !== o.node(e) ? (wQ.warn("Node " + e + ": " + JSON.stringify(o.node(e))), n.select("#" + f.id + " #" + e).attr("transform", "translate(" + (o.node(e).x - o.node(e).width / 2) + "," + (o.node(e).y + (eb0[e] ? eb0[e].y : 0) - o.node(e).height / 2) + " )"), n.select("#" + f.id + " #" + e).attr("data-x-shift", o.node(e).x - o.node(e).width / 2), a.querySelectorAll("#" + f.id + " #" + e + " .divider").forEach((e) => {
			let t = e.parentElement, r = 0, i = 0;
			t && (t.parentElement && (r = t.parentElement.getBBox().width), Number.isNaN(i = parseInt(t.getAttribute("data-x-shift"), 10)) && (i = 0)), e.setAttribute("x1", 0 - i + 8), e.setAttribute("x2", r - i - 8);
		})) : wQ.debug("No Node " + e + ": " + JSON.stringify(o.node(e)));
	});
	let g = f.getBBox();
	o.edges().forEach(function(e) {
		void 0 !== e && void 0 !== o.edge(e) && (wQ.debug("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(o.edge(e))), ebJ(t, o.edge(e), o.edge(e).relation));
	});
	let m = {
		id: r || "root",
		label: r || "root",
		width: 0,
		height: 0
	};
	return m.width = (g = f.getBBox()).width + 2 * ebN.padding, m.height = g.height + 2 * ebN.padding, wQ.debug("Doc rendered", m, o), m;
}, "renderDoc"), eb6 = {
	parser: ex3,
	get db() {
		return new ebz(1);
	},
	renderer: {
		setConf: eb1,
		draw: eb4
	},
	styles: ebU,
	init: h((e) => {
		e.state || (e.state = {}), e.state.arrowMarkerAbsolute = e.arrowMarkerAbsolute;
	}, "init")
}, eb7 = {
	parser: ex3,
	get db() {
		return new ebz(2);
	},
	renderer: ebk,
	styles: ebU,
	init: h((e) => {
		e.state || (e.state = {}), e.state.arrowMarkerAbsolute = e.arrowMarkerAbsolute;
	}, "init")
}, eb8 = function() {
	var e = h(function(e, t, r, i) {
		for (r = r || {}, i = e.length; i--; r[e[i]] = t);
		return r;
	}, "o"), t = [
		6,
		8,
		10,
		11,
		12,
		14,
		16,
		17,
		20,
		21
	], r = [1, 9], i = [1, 10], n = [1, 11], a = [1, 12], s = [1, 13], o = [1, 16], l = [1, 17], u = {
		trace: h(function() {}, "trace"),
		yy: {},
		symbols_: {
			error: 2,
			start: 3,
			timeline: 4,
			document: 5,
			EOF: 6,
			line: 7,
			SPACE: 8,
			statement: 9,
			NEWLINE: 10,
			title: 11,
			acc_title: 12,
			acc_title_value: 13,
			acc_descr: 14,
			acc_descr_value: 15,
			acc_descr_multiline_value: 16,
			section: 17,
			period_statement: 18,
			event_statement: 19,
			period: 20,
			event: 21,
			$accept: 0,
			$end: 1
		},
		terminals_: {
			2: "error",
			4: "timeline",
			6: "EOF",
			8: "SPACE",
			10: "NEWLINE",
			11: "title",
			12: "acc_title",
			13: "acc_title_value",
			14: "acc_descr",
			15: "acc_descr_value",
			16: "acc_descr_multiline_value",
			17: "section",
			20: "period",
			21: "event"
		},
		productions_: [
			0,
			[3, 3],
			[5, 0],
			[5, 2],
			[7, 2],
			[7, 1],
			[7, 1],
			[7, 1],
			[9, 1],
			[9, 2],
			[9, 2],
			[9, 1],
			[9, 1],
			[9, 1],
			[9, 1],
			[18, 1],
			[19, 1]
		],
		performAction: h(function(e, t, r, i, n, a, s) {
			var o = a.length - 1;
			switch (n) {
				case 1: return a[o - 1];
				case 2:
				case 6:
				case 7:
					this.$ = [];
					break;
				case 3:
					a[o - 1].push(a[o]), this.$ = a[o - 1];
					break;
				case 4:
				case 5:
					this.$ = a[o];
					break;
				case 8:
					i.getCommonDb().setDiagramTitle(a[o].substr(6)), this.$ = a[o].substr(6);
					break;
				case 9:
					this.$ = a[o].trim(), i.getCommonDb().setAccTitle(this.$);
					break;
				case 10:
				case 11:
					this.$ = a[o].trim(), i.getCommonDb().setAccDescription(this.$);
					break;
				case 12:
					i.addSection(a[o].substr(8)), this.$ = a[o].substr(8);
					break;
				case 15:
					i.addTask(a[o], 0, ""), this.$ = a[o];
					break;
				case 16: i.addEvent(a[o].substr(2)), this.$ = a[o];
			}
		}, "anonymous"),
		table: [
			{
				3: 1,
				4: [1, 2]
			},
			{ 1: [3] },
			e(t, [2, 2], { 5: 3 }),
			{
				6: [1, 4],
				7: 5,
				8: [1, 6],
				9: 7,
				10: [1, 8],
				11: r,
				12: i,
				14: n,
				16: a,
				17: s,
				18: 14,
				19: 15,
				20: o,
				21: l
			},
			e(t, [2, 7], { 1: [2, 1] }),
			e(t, [2, 3]),
			{
				9: 18,
				11: r,
				12: i,
				14: n,
				16: a,
				17: s,
				18: 14,
				19: 15,
				20: o,
				21: l
			},
			e(t, [2, 5]),
			e(t, [2, 6]),
			e(t, [2, 8]),
			{ 13: [1, 19] },
			{ 15: [1, 20] },
			e(t, [2, 11]),
			e(t, [2, 12]),
			e(t, [2, 13]),
			e(t, [2, 14]),
			e(t, [2, 15]),
			e(t, [2, 16]),
			e(t, [2, 4]),
			e(t, [2, 9]),
			e(t, [2, 10])
		],
		defaultActions: {},
		parseError: h(function(e, t) {
			if (t.recoverable) this.trace(e);
			else {
				var r = Error(e);
				throw r.hash = t, r;
			}
		}, "parseError"),
		parse: h(function(e) {
			var t = this, r = [0], i = [], n = [null], a = [], s = this.table, o = "", l = 0, u = 0, d = 0, p = a.slice.call(arguments, 1), f = Object.create(this.lexer), g = {};
			for (var m in this.yy) Object.prototype.hasOwnProperty.call(this.yy, m) && (g[m] = this.yy[m]);
			f.setInput(e, g), g.lexer = f, g.parser = this, typeof f.yylloc > "u" && (f.yylloc = {});
			var y = f.yylloc;
			a.push(y);
			var v = f.options && f.options.ranges;
			function x() {
				var e;
				return "number" != typeof (e = i.pop() || f.lex() || 1) && (e instanceof Array && (e = (i = e).pop()), e = t.symbols_[e] || e), e;
			}
			"function" == typeof g.parseError ? this.parseError = g.parseError : this.parseError = Object.getPrototypeOf(this).parseError, h(function(e) {
				r.length = r.length - 2 * e, n.length = n.length - e, a.length = a.length - e;
			}, "popStack"), h(x, "lex");
			for (var b, w, k, T, _, E, C, S, A, L = {};;) {
				if (k = r[r.length - 1], this.defaultActions[k] ? T = this.defaultActions[k] : ((null === b || typeof b > "u") && (b = x()), T = s[k] && s[k][b]), typeof T > "u" || !T.length || !T[0]) {
					var R = "";
					for (E in A = [], s[k]) this.terminals_[E] && E > 2 && A.push("'" + this.terminals_[E] + "'");
					R = f.showPosition ? "Parse error on line " + (l + 1) + `:
` + f.showPosition() + `
Expecting ` + A.join(", ") + ", got '" + (this.terminals_[b] || b) + "'" : "Parse error on line " + (l + 1) + ": Unexpected " + (1 == b ? "end of input" : "'" + (this.terminals_[b] || b) + "'"), this.parseError(R, {
						text: f.match,
						token: this.terminals_[b] || b,
						line: f.yylineno,
						loc: y,
						expected: A
					});
				}
				if (T[0] instanceof Array && T.length > 1) throw Error("Parse Error: multiple actions possible at state: " + k + ", token: " + b);
				switch (T[0]) {
					case 1:
						r.push(b), n.push(f.yytext), a.push(f.yylloc), r.push(T[1]), b = null, w ? (b = w, w = null) : (u = f.yyleng, o = f.yytext, l = f.yylineno, y = f.yylloc, d > 0 && d--);
						break;
					case 2:
						if (C = this.productions_[T[1]][1], L.$ = n[n.length - C], L._$ = {
							first_line: a[a.length - (C || 1)].first_line,
							last_line: a[a.length - 1].last_line,
							first_column: a[a.length - (C || 1)].first_column,
							last_column: a[a.length - 1].last_column
						}, v && (L._$.range = [a[a.length - (C || 1)].range[0], a[a.length - 1].range[1]]), "u" > typeof (_ = this.performAction.apply(L, [
							o,
							u,
							l,
							g,
							T[1],
							n,
							a
						].concat(p)))) return _;
						C && (r = r.slice(0, -1 * C * 2), n = n.slice(0, -1 * C), a = a.slice(0, -1 * C)), r.push(this.productions_[T[1]][0]), n.push(L.$), a.push(L._$), S = s[r[r.length - 2]][r[r.length - 1]], r.push(S);
						break;
					case 3: return !0;
				}
			}
			return !0;
		}, "parse")
	};
	function d() {
		this.yy = {};
	}
	return u.lexer = {
		EOF: 1,
		parseError: h(function(e, t) {
			if (this.yy.parser) this.yy.parser.parseError(e, t);
			else throw Error(e);
		}, "parseError"),
		setInput: h(function(e, t) {
			return this.yy = t || this.yy || {}, this._input = e, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
				first_line: 1,
				first_column: 0,
				last_line: 1,
				last_column: 0
			}, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
		}, "setInput"),
		input: h(function() {
			var e = this._input[0];
			return this.yytext += e, this.yyleng++, this.offset++, this.match += e, this.matched += e, e.match(/(?:\r\n?|\n).*/g) ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), e;
		}, "input"),
		unput: h(function(e) {
			var t = e.length, r = e.split(/(?:\r\n?|\n)/g);
			this._input = e + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - t), this.offset -= t;
			var i = this.match.split(/(?:\r\n?|\n)/g);
			this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), r.length - 1 && (this.yylineno -= r.length - 1);
			var n = this.yylloc.range;
			return this.yylloc = {
				first_line: this.yylloc.first_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.first_column,
				last_column: r ? (r.length === i.length ? this.yylloc.first_column : 0) + i[i.length - r.length].length - r[0].length : this.yylloc.first_column - t
			}, this.options.ranges && (this.yylloc.range = [n[0], n[0] + this.yyleng - t]), this.yyleng = this.yytext.length, this;
		}, "unput"),
		more: h(function() {
			return this._more = !0, this;
		}, "more"),
		reject: h(function() {
			return this.options.backtrack_lexer ? (this._backtrack = !0, this) : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "reject"),
		less: h(function(e) {
			this.unput(this.match.slice(e));
		}, "less"),
		pastInput: h(function() {
			var e = this.matched.substr(0, this.matched.length - this.match.length);
			return (e.length > 20 ? "..." : "") + e.substr(-20).replace(/\n/g, "");
		}, "pastInput"),
		upcomingInput: h(function() {
			var e = this.match;
			return e.length < 20 && (e += this._input.substr(0, 20 - e.length)), (e.substr(0, 20) + (e.length > 20 ? "..." : "")).replace(/\n/g, "");
		}, "upcomingInput"),
		showPosition: h(function() {
			var e = this.pastInput(), t = Array(e.length + 1).join("-");
			return e + this.upcomingInput() + `
` + t + "^";
		}, "showPosition"),
		test_match: h(function(e, t) {
			var r, i, n;
			if (this.options.backtrack_lexer && (n = {
				yylineno: this.yylineno,
				yylloc: {
					first_line: this.yylloc.first_line,
					last_line: this.last_line,
					first_column: this.yylloc.first_column,
					last_column: this.yylloc.last_column
				},
				yytext: this.yytext,
				match: this.match,
				matches: this.matches,
				matched: this.matched,
				yyleng: this.yyleng,
				offset: this.offset,
				_more: this._more,
				_input: this._input,
				yy: this.yy,
				conditionStack: this.conditionStack.slice(0),
				done: this.done
			}, this.options.ranges && (n.yylloc.range = this.yylloc.range.slice(0))), (i = e[0].match(/(?:\r\n?|\n).*/g)) && (this.yylineno += i.length), this.yylloc = {
				first_line: this.yylloc.last_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.last_column,
				last_column: i ? i[i.length - 1].length - i[i.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + e[0].length
			}, this.yytext += e[0], this.match += e[0], this.matches = e, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(e[0].length), this.matched += e[0], r = this.performAction.call(this, this.yy, this, t, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), r) return r;
			if (this._backtrack) for (var a in n) this[a] = n[a];
			return !1;
		}, "test_match"),
		next: h(function() {
			if (this.done) return this.EOF;
			this._input || (this.done = !0), this._more || (this.yytext = "", this.match = "");
			for (var e, t, r, i, n = this._currentRules(), a = 0; a < n.length; a++) if ((r = this._input.match(this.rules[n[a]])) && (!t || r[0].length > t[0].length)) {
				if (t = r, i = a, this.options.backtrack_lexer) {
					if (!1 !== (e = this.test_match(r, n[a]))) return e;
					if (!this._backtrack) return !1;
					t = !1;
					continue;
				} else if (!this.options.flex) break;
			}
			return t ? !1 !== (e = this.test_match(t, n[i])) && e : "" === this._input ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "next"),
		lex: h(function() {
			return this.next() || this.lex();
		}, "lex"),
		begin: h(function(e) {
			this.conditionStack.push(e);
		}, "begin"),
		popState: h(function() {
			return this.conditionStack.length - 1 > 0 ? this.conditionStack.pop() : this.conditionStack[0];
		}, "popState"),
		_currentRules: h(function() {
			return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
		}, "_currentRules"),
		topState: h(function(e) {
			return (e = this.conditionStack.length - 1 - Math.abs(e || 0)) >= 0 ? this.conditionStack[e] : "INITIAL";
		}, "topState"),
		pushState: h(function(e) {
			this.begin(e);
		}, "pushState"),
		stateStackSize: h(function() {
			return this.conditionStack.length;
		}, "stateStackSize"),
		options: { "case-insensitive": !0 },
		performAction: h(function(e, t, r, i) {
			switch (r) {
				case 0:
				case 1:
				case 3:
				case 4: break;
				case 2: return 10;
				case 5: return 4;
				case 6: return 11;
				case 7: return this.begin("acc_title"), 12;
				case 8: return this.popState(), "acc_title_value";
				case 9: return this.begin("acc_descr"), 14;
				case 10: return this.popState(), "acc_descr_value";
				case 11:
					this.begin("acc_descr_multiline");
					break;
				case 12:
					this.popState();
					break;
				case 13: return "acc_descr_multiline_value";
				case 14: return 17;
				case 15: return 21;
				case 16: return 20;
				case 17: return 6;
				case 18: return "INVALID";
			}
		}, "anonymous"),
		rules: [
			/^(?:%(?!\{)[^\n]*)/i,
			/^(?:[^\}]%%[^\n]*)/i,
			/^(?:[\n]+)/i,
			/^(?:\s+)/i,
			/^(?:#[^\n]*)/i,
			/^(?:timeline\b)/i,
			/^(?:title\s[^\n]+)/i,
			/^(?:accTitle\s*:\s*)/i,
			/^(?:(?!\n||)*[^\n]*)/i,
			/^(?:accDescr\s*:\s*)/i,
			/^(?:(?!\n||)*[^\n]*)/i,
			/^(?:accDescr\s*\{\s*)/i,
			/^(?:[\}])/i,
			/^(?:[^\}]*)/i,
			/^(?:section\s[^:\n]+)/i,
			/^(?::\s(?:[^:\n]|:(?!\s))+)/i,
			/^(?:[^#:\n]+)/i,
			/^(?:$)/i,
			/^(?:.)/i
		],
		conditions: {
			acc_descr_multiline: {
				rules: [12, 13],
				inclusive: !1
			},
			acc_descr: {
				rules: [10],
				inclusive: !1
			},
			acc_title: {
				rules: [8],
				inclusive: !1
			},
			INITIAL: {
				rules: [
					0,
					1,
					2,
					3,
					4,
					5,
					6,
					7,
					9,
					11,
					14,
					15,
					16,
					17,
					18
				],
				inclusive: !0
			}
		}
	}, h(d, "Parser"), d.prototype = u, u.Parser = d, new d();
}();
eb8.parser = eb8;
var eb9 = {};
d(eb9, {
	addEvent: () => ewu,
	addSection: () => ewo,
	addTask: () => ewh,
	addTaskOrg: () => ewd,
	clear: () => ews,
	default: () => ewf,
	getCommonDb: () => ewa,
	getSections: () => ewl,
	getTasks: () => ewc
});
var ewe = "", ewt = 0, ewr = [], ewi = [], ewn = [], ewa = h(() => M9, "getCommonDb"), ews = h(function() {
	ewr.length = 0, ewi.length = 0, ewe = "", ewn.length = 0, Dn();
}, "clear"), ewo = h(function(e) {
	ewe = e, ewr.push(e);
}, "addSection"), ewl = h(function() {
	return ewr;
}, "getSections"), ewc = h(function() {
	let e = ewp(), t = 0;
	for (; !e && t < 100;) e = ewp(), t++;
	return ewi.push(...ewn), ewi;
}, "getTasks"), ewh = h(function(e, t, r) {
	let i = {
		id: ewt++,
		section: ewe,
		type: ewe,
		task: e,
		score: t || 0,
		events: r ? [r] : []
	};
	ewn.push(i);
}, "addTask"), ewu = h(function(e) {
	ewn.find((e) => e.id === ewt - 1).events.push(e);
}, "addEvent"), ewd = h(function(e) {
	let t = {
		section: ewe,
		type: ewe,
		description: e,
		task: e,
		classes: []
	};
	ewi.push(t);
}, "addTaskOrg"), ewp = h(function() {
	let e = h(function(e) {
		return ewn[e].processed;
	}, "compileTask"), t = !0;
	for (let [r, i] of ewn.entries()) e(r), t = t && i.processed;
	return t;
}, "compileTasks"), ewf = {
	clear: ews,
	getCommonDb: ewa,
	addSection: ewo,
	getSections: ewl,
	getTasks: ewc,
	addTask: ewh,
	addTaskOrg: ewd,
	addEvent: ewu
};
h(function(e, t) {
	let r = e.append("rect");
	return r.attr("x", t.x), r.attr("y", t.y), r.attr("fill", t.fill), r.attr("stroke", t.stroke), r.attr("width", t.width), r.attr("height", t.height), r.attr("rx", t.rx), r.attr("ry", t.ry), void 0 !== t.class && r.attr("class", t.class), r;
}, "drawRect");
h(function(e, t) {
	let r = e.append("circle").attr("cx", t.cx).attr("cy", t.cy).attr("class", "face").attr("r", 15).attr("stroke-width", 2).attr("overflow", "visible"), i = e.append("g");
	function n(e) {
		let r = AQ().startAngle(Math.PI / 2).endAngle(Math.PI / 2 * 3).innerRadius(7.5).outerRadius(6.8181818181818175);
		e.append("path").attr("class", "mouth").attr("d", r).attr("transform", "translate(" + t.cx + "," + (t.cy + 2) + ")");
	}
	function a(e) {
		let r = AQ().startAngle(3 * Math.PI / 2).endAngle(Math.PI / 2 * 5).innerRadius(7.5).outerRadius(6.8181818181818175);
		e.append("path").attr("class", "mouth").attr("d", r).attr("transform", "translate(" + t.cx + "," + (t.cy + 7) + ")");
	}
	function s(e) {
		e.append("line").attr("class", "mouth").attr("stroke", 2).attr("x1", t.cx - 5).attr("y1", t.cy + 7).attr("x2", t.cx + 5).attr("y2", t.cy + 7).attr("class", "mouth").attr("stroke-width", "1px").attr("stroke", "#666");
	}
	return i.append("circle").attr("cx", t.cx - 5).attr("cy", t.cy - 5).attr("r", 1.5).attr("stroke-width", 2).attr("fill", "#666").attr("stroke", "#666"), i.append("circle").attr("cx", t.cx + 5).attr("cy", t.cy - 5).attr("r", 1.5).attr("stroke-width", 2).attr("fill", "#666").attr("stroke", "#666"), h(n, "smile"), h(a, "sad"), h(s, "ambivalent"), t.score > 3 ? n(i) : t.score < 3 ? a(i) : s(i), r;
}, "drawFace");
h(function(e, t) {
	let r = t.text.replace(/<br\s*\/?>/gi, " "), i = e.append("text");
	i.attr("x", t.x), i.attr("y", t.y), i.attr("class", "legend"), i.style("text-anchor", t.anchor), void 0 !== t.class && i.attr("class", t.class);
	let n = i.append("tspan");
	return n.attr("x", t.x + 2 * t.textMargin), n.text(r), i;
}, "drawText");
h(function() {
	return {
		x: 0,
		y: 0,
		width: 100,
		anchor: "start",
		height: 100,
		rx: 0,
		ry: 0
	};
}, "getNoteRect");
(function() {
	function e(e, t, r, n, a, s, o, l) {
		i(t.append("text").attr("x", r + a / 2).attr("y", n + s / 2 + 5).style("font-color", l).style("text-anchor", "middle").text(e), o);
	}
	function t(e, t, r, n, a, s, o, l, h) {
		let { taskFontSize: u, taskFontFamily: d } = l, p = e.split(/<br\s*\/?>/gi);
		for (let e = 0; e < p.length; e++) {
			let l = e * u - u * (p.length - 1) / 2, f = t.append("text").attr("x", r + a / 2).attr("y", n).attr("fill", h).style("text-anchor", "middle").style("font-size", u).style("font-family", d);
			f.append("tspan").attr("x", r + a / 2).attr("dy", l).text(p[e]), f.attr("y", n + s / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central"), i(f, o);
		}
	}
	function r(e, r, n, a, s, o, l, h) {
		let u = r.append("switch"), d = u.append("foreignObject").attr("x", n).attr("y", a).attr("width", s).attr("height", o).attr("position", "fixed").append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
		d.append("div").attr("class", "label").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(e), t(e, u, n, a, s, o, l, h), i(d, l);
	}
	function i(e, t) {
		for (let r in t) r in t && e.attr(r, t[r]);
	}
	return h(e, "byText"), h(t, "byTspan"), h(r, "byFo"), h(i, "_setTextAttrs"), function(i) {
		return "fo" === i.textPlacement ? r : "old" === i.textPlacement ? e : t;
	};
})();
var eww = h(function(e) {
	e.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 5).attr("refY", 2).attr("markerWidth", 6).attr("markerHeight", 4).attr("orient", "auto").append("path").attr("d", "M 0,0 V 4 L6,2 Z");
}, "initGraphics");
function ewk(e, t) {
	e.each(function() {
		var e, r = _t(this), i = r.text().split(/(\s+|<br>)/).reverse(), n = [], a = r.attr("y"), s = parseFloat(r.attr("dy")), o = r.text(null).append("tspan").attr("x", 0).attr("y", a).attr("dy", s + "em");
		for (let s = 0; s < i.length; s++) e = i[i.length - 1 - s], n.push(e), o.text(n.join(" ").trim()), (o.node().getComputedTextLength() > t || "<br>" === e) && (n.pop(), o.text(n.join(" ").trim()), n = "<br>" === e ? [""] : [e], o = r.append("tspan").attr("x", 0).attr("y", a).attr("dy", "1.1em").text(e));
	});
}
h(ewk, "wrap");
var ewT = h(function(e, t, r, i) {
	let n = r % 12 - 1, a = e.append("g");
	t.section = n, a.attr("class", (t.class ? t.class + " " : "") + "timeline-node section-" + n);
	let s = a.append("g"), o = a.append("g"), l = o.append("text").text(t.descr).attr("dy", "1em").attr("alignment-baseline", "middle").attr("dominant-baseline", "middle").attr("text-anchor", "middle").call(ewk, t.width).node().getBBox(), h = i.fontSize?.replace ? i.fontSize.replace("px", "") : i.fontSize;
	return t.height = l.height + 1.1 * h * .5 + t.padding, t.height = Math.max(t.height, t.maxHeight), t.width = t.width + 2 * t.padding, o.attr("transform", "translate(" + t.width / 2 + ", " + t.padding / 2 + ")"), ewE(s, t, n, i), t;
}, "drawNode"), ew_ = h(function(e, t, r) {
	let i = e.append("g"), n = i.append("text").text(t.descr).attr("dy", "1em").attr("alignment-baseline", "middle").attr("dominant-baseline", "middle").attr("text-anchor", "middle").call(ewk, t.width).node().getBBox(), a = r.fontSize?.replace ? r.fontSize.replace("px", "") : r.fontSize;
	return i.remove(), n.height + 1.1 * a * .5 + t.padding;
}, "getVirtualNodeHeight"), ewE = h(function(e, t, r) {
	e.append("path").attr("id", "node-" + t.id).attr("class", "node-bkg node-" + t.type).attr("d", `M0 ${t.height - 5} v${-t.height + 10} q0,-5 5,-5 h${t.width - 10} q5,0 5,5 v${t.height - 5} H0 Z`), e.append("line").attr("class", "node-line-" + r).attr("x1", 0).attr("y1", t.height).attr("x2", t.width).attr("y2", t.height);
}, "defaultBkg"), ewC = h(function(e, t, r, i) {
	let n = IA(), a = n.timeline?.leftMargin ?? 50;
	wQ.debug("timeline", i.db);
	let s = n.securityLevel, o;
	"sandbox" === s && (o = _t("#i" + t));
	let l = ("sandbox" === s ? _t(o.nodes()[0].contentDocument.body) : _t("body")).select("#" + t);
	l.append("g");
	let h = i.db.getTasks(), u = i.db.getCommonDb().getDiagramTitle();
	wQ.debug("task", h), eww(l);
	let d = i.db.getSections();
	wQ.debug("sections", d);
	let p = 0, f = 0, g = 0, m = 0, y = 50 + a, v = 50;
	m = 50;
	let x = 0, b = !0;
	d.forEach(function(e) {
		let t = ew_(l, {
			number: x,
			descr: e,
			section: x,
			width: 150,
			padding: 20,
			maxHeight: p
		}, n);
		wQ.debug("sectionHeight before draw", t), p = Math.max(p, t + 20);
	});
	let w = 0, k = 0;
	for (let [e, t] of (wQ.debug("tasks.length", h.length), h.entries())) {
		let r = ew_(l, {
			number: e,
			descr: t,
			section: t.section,
			width: 150,
			padding: 20,
			maxHeight: f
		}, n);
		wQ.debug("taskHeight before draw", r), f = Math.max(f, r + 20), w = Math.max(w, t.events.length);
		let i = 0;
		for (let e of t.events) i += ew_(l, {
			descr: e,
			section: t.section,
			number: t.section,
			width: 150,
			padding: 20,
			maxHeight: 50
		}, n);
		t.events.length > 0 && (i += (t.events.length - 1) * 10), k = Math.max(k, i);
	}
	wQ.debug("maxSectionHeight before draw", p), wQ.debug("maxTaskHeight before draw", f), d && d.length > 0 ? d.forEach((e) => {
		let t = h.filter((t) => t.section === e), r = {
			number: x,
			descr: e,
			section: x,
			width: 200 * Math.max(t.length, 1) - 50,
			padding: 20,
			maxHeight: p
		};
		wQ.debug("sectionNode", r);
		let i = l.append("g"), a = ewT(i, r, x, n);
		wQ.debug("sectionNode output", a), i.attr("transform", `translate(${y}, ${m})`), v += p + 50, t.length > 0 && ewS(l, t, x, y, v, f, n, w, k, p, !1), y += 200 * Math.max(t.length, 1), v = m, x++;
	}) : (b = !1, ewS(l, h, x, y, v, f, n, w, k, p, !0));
	let T = l.node().getBBox();
	wQ.debug("bounds", T), u && l.append("text").text(u).attr("x", T.width / 2 - a).attr("font-size", "4ex").attr("font-weight", "bold").attr("y", 20), g = b ? p + f + 150 : f + 100, l.append("g").attr("class", "lineWrapper").append("line").attr("x1", a).attr("y1", g).attr("x2", T.width + 3 * a).attr("y2", g).attr("stroke-width", 4).attr("stroke", "black").attr("marker-end", "url(#arrowhead)"), M3(void 0, l, n.timeline?.padding ?? 50, n.timeline?.useMaxWidth ?? !1);
}, "draw"), ewS = h(function(e, t, r, i, n, a, s, o, l, h, u) {
	for (let o of t) {
		let t = {
			descr: o.task,
			section: r,
			number: r,
			width: 150,
			padding: 20,
			maxHeight: a
		};
		wQ.debug("taskNode", t);
		let h = e.append("g").attr("class", "taskWrapper"), d = ewT(h, t, r, s).height;
		if (wQ.debug("taskHeight after draw", d), h.attr("transform", `translate(${i}, ${n})`), a = Math.max(a, d), o.events) {
			let t = e.append("g").attr("class", "lineWrapper");
			n += 100, ewA(e, o.events, r, i, n, s), n -= 100, t.append("line").attr("x1", i + 95).attr("y1", n + a).attr("x2", i + 95).attr("y2", n + a + 100 + l + 100).attr("stroke-width", 2).attr("stroke", "black").attr("marker-end", "url(#arrowhead)").attr("stroke-dasharray", "5,5");
		}
		i += 200, u && !s.timeline?.disableMulticolor && r++;
	}
}, "drawTasks"), ewA = h(function(e, t, r, i, n, a) {
	let s = 0, o = n;
	for (let o of (n += 100, t)) {
		let t = {
			descr: o,
			section: r,
			number: r,
			width: 150,
			padding: 20,
			maxHeight: 50
		};
		wQ.debug("eventNode", t);
		let l = e.append("g").attr("class", "eventWrapper"), h = ewT(l, t, r, a).height;
		s += h, l.attr("transform", `translate(${i}, ${n})`), n = n + 10 + h;
	}
	return n = o, s;
}, "drawEvents"), ewL = {
	setConf: h(() => {}, "setConf"),
	draw: ewC
}, ewR = h((e) => {
	let t = "";
	for (let t = 0; t < e.THEME_COLOR_LIMIT; t++) e["lineColor" + t] = e["lineColor" + t] || e["cScaleInv" + t], N2(e["lineColor" + t]) ? e["lineColor" + t] = N5(e["lineColor" + t], 20) : e["lineColor" + t] = N3(e["lineColor" + t], 20);
	for (let r = 0; r < e.THEME_COLOR_LIMIT; r++) {
		let i = "" + (17 - 3 * r);
		t += `
    .section-${r - 1} rect, .section-${r - 1} path, .section-${r - 1} circle, .section-${r - 1} path  {
      fill: ${e["cScale" + r]};
    }
    .section-${r - 1} text {
     fill: ${e["cScaleLabel" + r]};
    }
    .node-icon-${r - 1} {
      font-size: 40px;
      color: ${e["cScaleLabel" + r]};
    }
    .section-edge-${r - 1}{
      stroke: ${e["cScale" + r]};
    }
    .edge-depth-${r - 1}{
      stroke-width: ${i};
    }
    .section-${r - 1} line {
      stroke: ${e["cScaleInv" + r]} ;
      stroke-width: 3;
    }

    .lineWrapper line{
      stroke: ${e["cScaleLabel" + r]} ;
    }

    .disabled, .disabled circle, .disabled text {
      fill: lightgray;
    }
    .disabled text {
      fill: #efefef;
    }
    `;
	}
	return t;
}, "genSections"), ewN = {
	db: eb9,
	renderer: ewL,
	parser: eb8,
	styles: h((e) => `
  .edge {
    stroke-width: 3;
  }
  ${ewR(e)}
  .section-root rect, .section-root path, .section-root circle  {
    fill: ${e.git0};
  }
  .section-root text {
    fill: ${e.gitBranchLabel0};
  }
  .icon-container {
    height:100%;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .edge {
    fill: none;
  }
  .eventWrapper  {
   filter: brightness(120%);
  }
`, "getStyles")
}, ewI = function() {
	var e = h(function(e, t, r, i) {
		for (r = r || {}, i = e.length; i--; r[e[i]] = t);
		return r;
	}, "o"), t = [
		1,
		10,
		12,
		14,
		16,
		18,
		19,
		21,
		23
	], r = [2, 6], i = [1, 3], n = [1, 5], a = [1, 6], s = [1, 7], o = [
		1,
		5,
		10,
		12,
		14,
		16,
		18,
		19,
		21,
		23,
		34,
		35,
		36
	], l = [1, 25], u = [1, 26], d = [1, 28], p = [1, 29], f = [1, 30], g = [1, 31], m = [1, 32], y = [1, 33], v = [1, 34], x = [1, 35], b = [1, 36], w = [1, 37], k = [1, 43], T = [1, 42], _ = [1, 47], E = [1, 50], C = [
		1,
		10,
		12,
		14,
		16,
		18,
		19,
		21,
		23,
		34,
		35,
		36
	], S = [
		1,
		10,
		12,
		14,
		16,
		18,
		19,
		21,
		23,
		24,
		26,
		27,
		28,
		34,
		35,
		36
	], A = [
		1,
		10,
		12,
		14,
		16,
		18,
		19,
		21,
		23,
		24,
		26,
		27,
		28,
		34,
		35,
		36,
		41,
		42,
		43,
		44,
		45,
		46,
		47,
		48,
		49,
		50
	], L = [1, 64], R = {
		trace: h(function() {}, "trace"),
		yy: {},
		symbols_: {
			error: 2,
			start: 3,
			eol: 4,
			XYCHART: 5,
			chartConfig: 6,
			document: 7,
			CHART_ORIENTATION: 8,
			statement: 9,
			title: 10,
			text: 11,
			X_AXIS: 12,
			parseXAxis: 13,
			Y_AXIS: 14,
			parseYAxis: 15,
			LINE: 16,
			plotData: 17,
			BAR: 18,
			acc_title: 19,
			acc_title_value: 20,
			acc_descr: 21,
			acc_descr_value: 22,
			acc_descr_multiline_value: 23,
			SQUARE_BRACES_START: 24,
			commaSeparatedNumbers: 25,
			SQUARE_BRACES_END: 26,
			NUMBER_WITH_DECIMAL: 27,
			COMMA: 28,
			xAxisData: 29,
			bandData: 30,
			ARROW_DELIMITER: 31,
			commaSeparatedTexts: 32,
			yAxisData: 33,
			NEWLINE: 34,
			SEMI: 35,
			EOF: 36,
			alphaNum: 37,
			STR: 38,
			MD_STR: 39,
			alphaNumToken: 40,
			AMP: 41,
			NUM: 42,
			ALPHA: 43,
			PLUS: 44,
			EQUALS: 45,
			MULT: 46,
			DOT: 47,
			BRKT: 48,
			MINUS: 49,
			UNDERSCORE: 50,
			$accept: 0,
			$end: 1
		},
		terminals_: {
			2: "error",
			5: "XYCHART",
			8: "CHART_ORIENTATION",
			10: "title",
			12: "X_AXIS",
			14: "Y_AXIS",
			16: "LINE",
			18: "BAR",
			19: "acc_title",
			20: "acc_title_value",
			21: "acc_descr",
			22: "acc_descr_value",
			23: "acc_descr_multiline_value",
			24: "SQUARE_BRACES_START",
			26: "SQUARE_BRACES_END",
			27: "NUMBER_WITH_DECIMAL",
			28: "COMMA",
			31: "ARROW_DELIMITER",
			34: "NEWLINE",
			35: "SEMI",
			36: "EOF",
			38: "STR",
			39: "MD_STR",
			41: "AMP",
			42: "NUM",
			43: "ALPHA",
			44: "PLUS",
			45: "EQUALS",
			46: "MULT",
			47: "DOT",
			48: "BRKT",
			49: "MINUS",
			50: "UNDERSCORE"
		},
		productions_: [
			0,
			[3, 2],
			[3, 3],
			[3, 2],
			[3, 1],
			[6, 1],
			[7, 0],
			[7, 2],
			[9, 2],
			[9, 2],
			[9, 2],
			[9, 2],
			[9, 2],
			[9, 3],
			[9, 2],
			[9, 3],
			[9, 2],
			[9, 2],
			[9, 1],
			[17, 3],
			[25, 3],
			[25, 1],
			[13, 1],
			[13, 2],
			[13, 1],
			[29, 1],
			[29, 3],
			[30, 3],
			[32, 3],
			[32, 1],
			[15, 1],
			[15, 2],
			[15, 1],
			[33, 3],
			[4, 1],
			[4, 1],
			[4, 1],
			[11, 1],
			[11, 1],
			[11, 1],
			[37, 1],
			[37, 2],
			[40, 1],
			[40, 1],
			[40, 1],
			[40, 1],
			[40, 1],
			[40, 1],
			[40, 1],
			[40, 1],
			[40, 1],
			[40, 1]
		],
		performAction: h(function(e, t, r, i, n, a, s) {
			var o = a.length - 1;
			switch (n) {
				case 5:
					i.setOrientation(a[o]);
					break;
				case 9:
					i.setDiagramTitle(a[o].text.trim());
					break;
				case 12:
					i.setLineData({
						text: "",
						type: "text"
					}, a[o]);
					break;
				case 13:
					i.setLineData(a[o - 1], a[o]);
					break;
				case 14:
					i.setBarData({
						text: "",
						type: "text"
					}, a[o]);
					break;
				case 15:
					i.setBarData(a[o - 1], a[o]);
					break;
				case 16:
					this.$ = a[o].trim(), i.setAccTitle(this.$);
					break;
				case 17:
				case 18:
					this.$ = a[o].trim(), i.setAccDescription(this.$);
					break;
				case 19:
				case 27:
					this.$ = a[o - 1];
					break;
				case 20:
					this.$ = [Number(a[o - 2]), ...a[o]];
					break;
				case 21:
					this.$ = [Number(a[o])];
					break;
				case 22:
					i.setXAxisTitle(a[o]);
					break;
				case 23:
					i.setXAxisTitle(a[o - 1]);
					break;
				case 24:
					i.setXAxisTitle({
						type: "text",
						text: ""
					});
					break;
				case 25:
					i.setXAxisBand(a[o]);
					break;
				case 26:
					i.setXAxisRangeData(Number(a[o - 2]), Number(a[o]));
					break;
				case 28:
					this.$ = [a[o - 2], ...a[o]];
					break;
				case 29:
					this.$ = [a[o]];
					break;
				case 30:
					i.setYAxisTitle(a[o]);
					break;
				case 31:
					i.setYAxisTitle(a[o - 1]);
					break;
				case 32:
					i.setYAxisTitle({
						type: "text",
						text: ""
					});
					break;
				case 33:
					i.setYAxisRangeData(Number(a[o - 2]), Number(a[o]));
					break;
				case 37:
				case 38:
					this.$ = {
						text: a[o],
						type: "text"
					};
					break;
				case 39:
					this.$ = {
						text: a[o],
						type: "markdown"
					};
					break;
				case 40:
					this.$ = a[o];
					break;
				case 41: this.$ = a[o - 1] + "" + a[o];
			}
		}, "anonymous"),
		table: [
			e(t, r, {
				3: 1,
				4: 2,
				7: 4,
				5: i,
				34: n,
				35: a,
				36: s
			}),
			{ 1: [3] },
			e(t, r, {
				4: 2,
				7: 4,
				3: 8,
				5: i,
				34: n,
				35: a,
				36: s
			}),
			e(t, r, {
				4: 2,
				7: 4,
				6: 9,
				3: 10,
				5: i,
				8: [1, 11],
				34: n,
				35: a,
				36: s
			}),
			{
				1: [2, 4],
				9: 12,
				10: [1, 13],
				12: [1, 14],
				14: [1, 15],
				16: [1, 16],
				18: [1, 17],
				19: [1, 18],
				21: [1, 19],
				23: [1, 20]
			},
			e(o, [2, 34]),
			e(o, [2, 35]),
			e(o, [2, 36]),
			{ 1: [2, 1] },
			e(t, r, {
				4: 2,
				7: 4,
				3: 21,
				5: i,
				34: n,
				35: a,
				36: s
			}),
			{ 1: [2, 3] },
			e(o, [2, 5]),
			e(t, [2, 7], {
				4: 22,
				34: n,
				35: a,
				36: s
			}),
			{
				11: 23,
				37: 24,
				38: l,
				39: u,
				40: 27,
				41: d,
				42: p,
				43: f,
				44: g,
				45: m,
				46: y,
				47: v,
				48: x,
				49: b,
				50: w
			},
			{
				11: 39,
				13: 38,
				24: k,
				27: T,
				29: 40,
				30: 41,
				37: 24,
				38: l,
				39: u,
				40: 27,
				41: d,
				42: p,
				43: f,
				44: g,
				45: m,
				46: y,
				47: v,
				48: x,
				49: b,
				50: w
			},
			{
				11: 45,
				15: 44,
				27: _,
				33: 46,
				37: 24,
				38: l,
				39: u,
				40: 27,
				41: d,
				42: p,
				43: f,
				44: g,
				45: m,
				46: y,
				47: v,
				48: x,
				49: b,
				50: w
			},
			{
				11: 49,
				17: 48,
				24: E,
				37: 24,
				38: l,
				39: u,
				40: 27,
				41: d,
				42: p,
				43: f,
				44: g,
				45: m,
				46: y,
				47: v,
				48: x,
				49: b,
				50: w
			},
			{
				11: 52,
				17: 51,
				24: E,
				37: 24,
				38: l,
				39: u,
				40: 27,
				41: d,
				42: p,
				43: f,
				44: g,
				45: m,
				46: y,
				47: v,
				48: x,
				49: b,
				50: w
			},
			{ 20: [1, 53] },
			{ 22: [1, 54] },
			e(C, [2, 18]),
			{ 1: [2, 2] },
			e(C, [2, 8]),
			e(C, [2, 9]),
			e(S, [2, 37], {
				40: 55,
				41: d,
				42: p,
				43: f,
				44: g,
				45: m,
				46: y,
				47: v,
				48: x,
				49: b,
				50: w
			}),
			e(S, [2, 38]),
			e(S, [2, 39]),
			e(A, [2, 40]),
			e(A, [2, 42]),
			e(A, [2, 43]),
			e(A, [2, 44]),
			e(A, [2, 45]),
			e(A, [2, 46]),
			e(A, [2, 47]),
			e(A, [2, 48]),
			e(A, [2, 49]),
			e(A, [2, 50]),
			e(A, [2, 51]),
			e(C, [2, 10]),
			e(C, [2, 22], {
				30: 41,
				29: 56,
				24: k,
				27: T
			}),
			e(C, [2, 24]),
			e(C, [2, 25]),
			{ 31: [1, 57] },
			{
				11: 59,
				32: 58,
				37: 24,
				38: l,
				39: u,
				40: 27,
				41: d,
				42: p,
				43: f,
				44: g,
				45: m,
				46: y,
				47: v,
				48: x,
				49: b,
				50: w
			},
			e(C, [2, 11]),
			e(C, [2, 30], {
				33: 60,
				27: _
			}),
			e(C, [2, 32]),
			{ 31: [1, 61] },
			e(C, [2, 12]),
			{
				17: 62,
				24: E
			},
			{
				25: 63,
				27: L
			},
			e(C, [2, 14]),
			{
				17: 65,
				24: E
			},
			e(C, [2, 16]),
			e(C, [2, 17]),
			e(A, [2, 41]),
			e(C, [2, 23]),
			{ 27: [1, 66] },
			{ 26: [1, 67] },
			{
				26: [2, 29],
				28: [1, 68]
			},
			e(C, [2, 31]),
			{ 27: [1, 69] },
			e(C, [2, 13]),
			{ 26: [1, 70] },
			{
				26: [2, 21],
				28: [1, 71]
			},
			e(C, [2, 15]),
			e(C, [2, 26]),
			e(C, [2, 27]),
			{
				11: 59,
				32: 72,
				37: 24,
				38: l,
				39: u,
				40: 27,
				41: d,
				42: p,
				43: f,
				44: g,
				45: m,
				46: y,
				47: v,
				48: x,
				49: b,
				50: w
			},
			e(C, [2, 33]),
			e(C, [2, 19]),
			{
				25: 73,
				27: L
			},
			{ 26: [2, 28] },
			{ 26: [2, 20] }
		],
		defaultActions: {
			8: [2, 1],
			10: [2, 3],
			21: [2, 2],
			72: [2, 28],
			73: [2, 20]
		},
		parseError: h(function(e, t) {
			if (t.recoverable) this.trace(e);
			else {
				var r = Error(e);
				throw r.hash = t, r;
			}
		}, "parseError"),
		parse: h(function(e) {
			var t = this, r = [0], i = [], n = [null], a = [], s = this.table, o = "", l = 0, u = 0, d = 0, p = a.slice.call(arguments, 1), f = Object.create(this.lexer), g = {};
			for (var m in this.yy) Object.prototype.hasOwnProperty.call(this.yy, m) && (g[m] = this.yy[m]);
			f.setInput(e, g), g.lexer = f, g.parser = this, typeof f.yylloc > "u" && (f.yylloc = {});
			var y = f.yylloc;
			a.push(y);
			var v = f.options && f.options.ranges;
			function x() {
				var e;
				return "number" != typeof (e = i.pop() || f.lex() || 1) && (e instanceof Array && (e = (i = e).pop()), e = t.symbols_[e] || e), e;
			}
			"function" == typeof g.parseError ? this.parseError = g.parseError : this.parseError = Object.getPrototypeOf(this).parseError, h(function(e) {
				r.length = r.length - 2 * e, n.length = n.length - e, a.length = a.length - e;
			}, "popStack"), h(x, "lex");
			for (var b, w, k, T, _, E, C, S, A, L = {};;) {
				if (k = r[r.length - 1], this.defaultActions[k] ? T = this.defaultActions[k] : ((null === b || typeof b > "u") && (b = x()), T = s[k] && s[k][b]), typeof T > "u" || !T.length || !T[0]) {
					var R = "";
					for (E in A = [], s[k]) this.terminals_[E] && E > 2 && A.push("'" + this.terminals_[E] + "'");
					R = f.showPosition ? "Parse error on line " + (l + 1) + `:
` + f.showPosition() + `
Expecting ` + A.join(", ") + ", got '" + (this.terminals_[b] || b) + "'" : "Parse error on line " + (l + 1) + ": Unexpected " + (1 == b ? "end of input" : "'" + (this.terminals_[b] || b) + "'"), this.parseError(R, {
						text: f.match,
						token: this.terminals_[b] || b,
						line: f.yylineno,
						loc: y,
						expected: A
					});
				}
				if (T[0] instanceof Array && T.length > 1) throw Error("Parse Error: multiple actions possible at state: " + k + ", token: " + b);
				switch (T[0]) {
					case 1:
						r.push(b), n.push(f.yytext), a.push(f.yylloc), r.push(T[1]), b = null, w ? (b = w, w = null) : (u = f.yyleng, o = f.yytext, l = f.yylineno, y = f.yylloc, d > 0 && d--);
						break;
					case 2:
						if (C = this.productions_[T[1]][1], L.$ = n[n.length - C], L._$ = {
							first_line: a[a.length - (C || 1)].first_line,
							last_line: a[a.length - 1].last_line,
							first_column: a[a.length - (C || 1)].first_column,
							last_column: a[a.length - 1].last_column
						}, v && (L._$.range = [a[a.length - (C || 1)].range[0], a[a.length - 1].range[1]]), "u" > typeof (_ = this.performAction.apply(L, [
							o,
							u,
							l,
							g,
							T[1],
							n,
							a
						].concat(p)))) return _;
						C && (r = r.slice(0, -1 * C * 2), n = n.slice(0, -1 * C), a = a.slice(0, -1 * C)), r.push(this.productions_[T[1]][0]), n.push(L.$), a.push(L._$), S = s[r[r.length - 2]][r[r.length - 1]], r.push(S);
						break;
					case 3: return !0;
				}
			}
			return !0;
		}, "parse")
	};
	function N() {
		this.yy = {};
	}
	return R.lexer = {
		EOF: 1,
		parseError: h(function(e, t) {
			if (this.yy.parser) this.yy.parser.parseError(e, t);
			else throw Error(e);
		}, "parseError"),
		setInput: h(function(e, t) {
			return this.yy = t || this.yy || {}, this._input = e, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
				first_line: 1,
				first_column: 0,
				last_line: 1,
				last_column: 0
			}, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
		}, "setInput"),
		input: h(function() {
			var e = this._input[0];
			return this.yytext += e, this.yyleng++, this.offset++, this.match += e, this.matched += e, e.match(/(?:\r\n?|\n).*/g) ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), e;
		}, "input"),
		unput: h(function(e) {
			var t = e.length, r = e.split(/(?:\r\n?|\n)/g);
			this._input = e + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - t), this.offset -= t;
			var i = this.match.split(/(?:\r\n?|\n)/g);
			this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), r.length - 1 && (this.yylineno -= r.length - 1);
			var n = this.yylloc.range;
			return this.yylloc = {
				first_line: this.yylloc.first_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.first_column,
				last_column: r ? (r.length === i.length ? this.yylloc.first_column : 0) + i[i.length - r.length].length - r[0].length : this.yylloc.first_column - t
			}, this.options.ranges && (this.yylloc.range = [n[0], n[0] + this.yyleng - t]), this.yyleng = this.yytext.length, this;
		}, "unput"),
		more: h(function() {
			return this._more = !0, this;
		}, "more"),
		reject: h(function() {
			return this.options.backtrack_lexer ? (this._backtrack = !0, this) : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "reject"),
		less: h(function(e) {
			this.unput(this.match.slice(e));
		}, "less"),
		pastInput: h(function() {
			var e = this.matched.substr(0, this.matched.length - this.match.length);
			return (e.length > 20 ? "..." : "") + e.substr(-20).replace(/\n/g, "");
		}, "pastInput"),
		upcomingInput: h(function() {
			var e = this.match;
			return e.length < 20 && (e += this._input.substr(0, 20 - e.length)), (e.substr(0, 20) + (e.length > 20 ? "..." : "")).replace(/\n/g, "");
		}, "upcomingInput"),
		showPosition: h(function() {
			var e = this.pastInput(), t = Array(e.length + 1).join("-");
			return e + this.upcomingInput() + `
` + t + "^";
		}, "showPosition"),
		test_match: h(function(e, t) {
			var r, i, n;
			if (this.options.backtrack_lexer && (n = {
				yylineno: this.yylineno,
				yylloc: {
					first_line: this.yylloc.first_line,
					last_line: this.last_line,
					first_column: this.yylloc.first_column,
					last_column: this.yylloc.last_column
				},
				yytext: this.yytext,
				match: this.match,
				matches: this.matches,
				matched: this.matched,
				yyleng: this.yyleng,
				offset: this.offset,
				_more: this._more,
				_input: this._input,
				yy: this.yy,
				conditionStack: this.conditionStack.slice(0),
				done: this.done
			}, this.options.ranges && (n.yylloc.range = this.yylloc.range.slice(0))), (i = e[0].match(/(?:\r\n?|\n).*/g)) && (this.yylineno += i.length), this.yylloc = {
				first_line: this.yylloc.last_line,
				last_line: this.yylineno + 1,
				first_column: this.yylloc.last_column,
				last_column: i ? i[i.length - 1].length - i[i.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + e[0].length
			}, this.yytext += e[0], this.match += e[0], this.matches = e, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(e[0].length), this.matched += e[0], r = this.performAction.call(this, this.yy, this, t, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), r) return r;
			if (this._backtrack) for (var a in n) this[a] = n[a];
			return !1;
		}, "test_match"),
		next: h(function() {
			if (this.done) return this.EOF;
			this._input || (this.done = !0), this._more || (this.yytext = "", this.match = "");
			for (var e, t, r, i, n = this._currentRules(), a = 0; a < n.length; a++) if ((r = this._input.match(this.rules[n[a]])) && (!t || r[0].length > t[0].length)) {
				if (t = r, i = a, this.options.backtrack_lexer) {
					if (!1 !== (e = this.test_match(r, n[a]))) return e;
					if (!this._backtrack) return !1;
					t = !1;
					continue;
				} else if (!this.options.flex) break;
			}
			return t ? !1 !== (e = this.test_match(t, n[i])) && e : "" === this._input ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
				text: "",
				token: null,
				line: this.yylineno
			});
		}, "next"),
		lex: h(function() {
			return this.next() || this.lex();
		}, "lex"),
		begin: h(function(e) {
			this.conditionStack.push(e);
		}, "begin"),
		popState: h(function() {
			return this.conditionStack.length - 1 > 0 ? this.conditionStack.pop() : this.conditionStack[0];
		}, "popState"),
		_currentRules: h(function() {
			return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
		}, "_currentRules"),
		topState: h(function(e) {
			return (e = this.conditionStack.length - 1 - Math.abs(e || 0)) >= 0 ? this.conditionStack[e] : "INITIAL";
		}, "topState"),
		pushState: h(function(e) {
			this.begin(e);
		}, "pushState"),
		stateStackSize: h(function() {
			return this.conditionStack.length;
		}, "stateStackSize"),
		options: { "case-insensitive": !0 },
		performAction: h(function(e, t, r, i) {
			switch (r) {
				case 0:
				case 1:
				case 5:
				case 44: break;
				case 2:
				case 3: return this.popState(), 34;
				case 4: return 34;
				case 6: return 10;
				case 7: return this.pushState("acc_title"), 19;
				case 8: return this.popState(), "acc_title_value";
				case 9: return this.pushState("acc_descr"), 21;
				case 10: return this.popState(), "acc_descr_value";
				case 11:
					this.pushState("acc_descr_multiline");
					break;
				case 12:
				case 26:
				case 28:
					this.popState();
					break;
				case 13: return "acc_descr_multiline_value";
				case 14:
				case 15: return 5;
				case 16: return 8;
				case 17: return this.pushState("axis_data"), "X_AXIS";
				case 18: return this.pushState("axis_data"), "Y_AXIS";
				case 19: return this.pushState("axis_band_data"), 24;
				case 20: return 31;
				case 21: return this.pushState("data"), 16;
				case 22: return this.pushState("data"), 18;
				case 23: return this.pushState("data_inner"), 24;
				case 24: return 27;
				case 25: return this.popState(), 26;
				case 27:
					this.pushState("string");
					break;
				case 29: return "STR";
				case 30: return 24;
				case 31: return 26;
				case 32: return 43;
				case 33: return "COLON";
				case 34: return 44;
				case 35: return 28;
				case 36: return 45;
				case 37: return 46;
				case 38: return 48;
				case 39: return 50;
				case 40: return 47;
				case 41: return 41;
				case 42: return 49;
				case 43: return 42;
				case 45: return 35;
				case 46: return 36;
			}
		}, "anonymous"),
		rules: [
			/^(?:%%(?!\{)[^\n]*)/i,
			/^(?:[^\}]%%[^\n]*)/i,
			/^(?:(\r?\n))/i,
			/^(?:(\r?\n))/i,
			/^(?:[\n\r]+)/i,
			/^(?:%%[^\n]*)/i,
			/^(?:title\b)/i,
			/^(?:accTitle\s*:\s*)/i,
			/^(?:(?!\n||)*[^\n]*)/i,
			/^(?:accDescr\s*:\s*)/i,
			/^(?:(?!\n||)*[^\n]*)/i,
			/^(?:accDescr\s*\{\s*)/i,
			/^(?:\{)/i,
			/^(?:[^\}]*)/i,
			/^(?:xychart-beta\b)/i,
			/^(?:xychart\b)/i,
			/^(?:(?:vertical|horizontal))/i,
			/^(?:x-axis\b)/i,
			/^(?:y-axis\b)/i,
			/^(?:\[)/i,
			/^(?:-->)/i,
			/^(?:line\b)/i,
			/^(?:bar\b)/i,
			/^(?:\[)/i,
			/^(?:[+-]?(?:\d+(?:\.\d+)?|\.\d+))/i,
			/^(?:\])/i,
			/^(?:(?:`\)                                    \{ this\.pushState\(md_string\); \}\n<md_string>\(\?:\(\?!`"\)\.\)\+                  \{ return MD_STR; \}\n<md_string>\(\?:`))/i,
			/^(?:["])/i,
			/^(?:["])/i,
			/^(?:[^"]*)/i,
			/^(?:\[)/i,
			/^(?:\])/i,
			/^(?:[A-Za-z]+)/i,
			/^(?::)/i,
			/^(?:\+)/i,
			/^(?:,)/i,
			/^(?:=)/i,
			/^(?:\*)/i,
			/^(?:#)/i,
			/^(?:[\_])/i,
			/^(?:\.)/i,
			/^(?:&)/i,
			/^(?:-)/i,
			/^(?:[0-9]+)/i,
			/^(?:\s+)/i,
			/^(?:;)/i,
			/^(?:$)/i
		],
		conditions: {
			data_inner: {
				rules: [
					0,
					1,
					4,
					5,
					6,
					7,
					9,
					11,
					14,
					15,
					16,
					17,
					18,
					21,
					22,
					24,
					25,
					26,
					27,
					30,
					31,
					32,
					33,
					34,
					35,
					36,
					37,
					38,
					39,
					40,
					41,
					42,
					43,
					44,
					45,
					46
				],
				inclusive: !0
			},
			data: {
				rules: [
					0,
					1,
					3,
					4,
					5,
					6,
					7,
					9,
					11,
					14,
					15,
					16,
					17,
					18,
					21,
					22,
					23,
					26,
					27,
					30,
					31,
					32,
					33,
					34,
					35,
					36,
					37,
					38,
					39,
					40,
					41,
					42,
					43,
					44,
					45,
					46
				],
				inclusive: !0
			},
			axis_band_data: {
				rules: [
					0,
					1,
					4,
					5,
					6,
					7,
					9,
					11,
					14,
					15,
					16,
					17,
					18,
					21,
					22,
					25,
					26,
					27,
					30,
					31,
					32,
					33,
					34,
					35,
					36,
					37,
					38,
					39,
					40,
					41,
					42,
					43,
					44,
					45,
					46
				],
				inclusive: !0
			},
			axis_data: {
				rules: [
					0,
					1,
					2,
					4,
					5,
					6,
					7,
					9,
					11,
					14,
					15,
					16,
					17,
					18,
					19,
					20,
					21,
					22,
					24,
					26,
					27,
					30,
					31,
					32,
					33,
					34,
					35,
					36,
					37,
					38,
					39,
					40,
					41,
					42,
					43,
					44,
					45,
					46
				],
				inclusive: !0
			},
			acc_descr_multiline: {
				rules: [12, 13],
				inclusive: !1
			},
			acc_descr: {
				rules: [10],
				inclusive: !1
			},
			acc_title: {
				rules: [8],
				inclusive: !1
			},
			title: {
				rules: [],
				inclusive: !1
			},
			md_string: {
				rules: [],
				inclusive: !1
			},
			string: {
				rules: [28, 29],
				inclusive: !1
			},
			INITIAL: {
				rules: [
					0,
					1,
					4,
					5,
					6,
					7,
					9,
					11,
					14,
					15,
					16,
					17,
					18,
					21,
					22,
					26,
					27,
					30,
					31,
					32,
					33,
					34,
					35,
					36,
					37,
					38,
					39,
					40,
					41,
					42,
					43,
					44,
					45,
					46
				],
				inclusive: !0
			}
		}
	}, h(N, "Parser"), N.prototype = R, R.Parser = N, new N();
}();
function ewM(e) {
	return "bar" === e.type;
}
function ewD(e) {
	return "band" === e.type;
}
function ewO(e) {
	return "linear" === e.type;
}
ewI.parser = ewI, h(ewM, "isBarPlot"), h(ewD, "isBandAxisData"), h(ewO, "isLinearAxisData");
var ew$ = class {
	constructor(e) {
		this.parentGroup = e;
	}
	static {
		h(this, "TextDimensionCalculatorWithFont");
	}
	getMaxDimension(e, t) {
		if (!this.parentGroup) return {
			width: e.reduce((e, t) => Math.max(t.length, e), 0) * t,
			height: t
		};
		let r = {
			width: 0,
			height: 0
		}, i = this.parentGroup.append("g").attr("visibility", "hidden").attr("font-size", t);
		for (let n of e) {
			let e = XH(i, 1, n), a = e ? e.width : n.length * t, s = e ? e.height : t;
			r.width = Math.max(r.width, a), r.height = Math.max(r.height, s);
		}
		return i.remove(), r;
	}
}, ewP = class {
	constructor(e, t, r, i) {
		this.axisConfig = e, this.title = t, this.textDimensionCalculator = r, this.axisThemeConfig = i, this.boundingRect = {
			x: 0,
			y: 0,
			width: 0,
			height: 0
		}, this.axisPosition = "left", this.showTitle = !1, this.showLabel = !1, this.showTick = !1, this.showAxisLine = !1, this.outerPadding = 0, this.titleTextHeight = 0, this.labelTextHeight = 0, this.range = [0, 10], this.boundingRect = {
			x: 0,
			y: 0,
			width: 0,
			height: 0
		}, this.axisPosition = "left";
	}
	static {
		h(this, "BaseAxis");
	}
	setRange(e) {
		this.range = e, "left" === this.axisPosition || "right" === this.axisPosition ? this.boundingRect.height = e[1] - e[0] : this.boundingRect.width = e[1] - e[0], this.recalculateScale();
	}
	getRange() {
		return [this.range[0] + this.outerPadding, this.range[1] - this.outerPadding];
	}
	setAxisPosition(e) {
		this.axisPosition = e, this.setRange(this.range);
	}
	getTickDistance() {
		let e = this.getRange();
		return Math.abs(e[0] - e[1]) / this.getTickValues().length;
	}
	getAxisOuterPadding() {
		return this.outerPadding;
	}
	getLabelDimension() {
		return this.textDimensionCalculator.getMaxDimension(this.getTickValues().map((e) => e.toString()), this.axisConfig.labelFontSize);
	}
	recalculateOuterPaddingToDrawBar() {
		.7 * this.getTickDistance() > 2 * this.outerPadding && (this.outerPadding = Math.floor(.7 * this.getTickDistance() / 2)), this.recalculateScale();
	}
	calculateSpaceIfDrawnHorizontally(e) {
		let t = e.height;
		if (this.axisConfig.showAxisLine && t > this.axisConfig.axisLineWidth && (t -= this.axisConfig.axisLineWidth, this.showAxisLine = !0), this.axisConfig.showLabel) {
			let r = this.getLabelDimension(), i = .2 * e.width;
			this.outerPadding = Math.min(r.width / 2, i);
			let n = r.height + 2 * this.axisConfig.labelPadding;
			this.labelTextHeight = r.height, n <= t && (t -= n, this.showLabel = !0);
		}
		if (this.axisConfig.showTick && t >= this.axisConfig.tickLength && (this.showTick = !0, t -= this.axisConfig.tickLength), this.axisConfig.showTitle && this.title) {
			let e = this.textDimensionCalculator.getMaxDimension([this.title], this.axisConfig.titleFontSize), r = e.height + 2 * this.axisConfig.titlePadding;
			this.titleTextHeight = e.height, r <= t && (t -= r, this.showTitle = !0);
		}
		this.boundingRect.width = e.width, this.boundingRect.height = e.height - t;
	}
	calculateSpaceIfDrawnVertical(e) {
		let t = e.width;
		if (this.axisConfig.showAxisLine && t > this.axisConfig.axisLineWidth && (t -= this.axisConfig.axisLineWidth, this.showAxisLine = !0), this.axisConfig.showLabel) {
			let r = this.getLabelDimension(), i = .2 * e.height;
			this.outerPadding = Math.min(r.height / 2, i);
			let n = r.width + 2 * this.axisConfig.labelPadding;
			n <= t && (t -= n, this.showLabel = !0);
		}
		if (this.axisConfig.showTick && t >= this.axisConfig.tickLength && (this.showTick = !0, t -= this.axisConfig.tickLength), this.axisConfig.showTitle && this.title) {
			let e = this.textDimensionCalculator.getMaxDimension([this.title], this.axisConfig.titleFontSize), r = e.height + 2 * this.axisConfig.titlePadding;
			this.titleTextHeight = e.height, r <= t && (t -= r, this.showTitle = !0);
		}
		this.boundingRect.width = e.width - t, this.boundingRect.height = e.height;
	}
	calculateSpace(e) {
		return "left" === this.axisPosition || "right" === this.axisPosition ? this.calculateSpaceIfDrawnVertical(e) : this.calculateSpaceIfDrawnHorizontally(e), this.recalculateScale(), {
			width: this.boundingRect.width,
			height: this.boundingRect.height
		};
	}
	setBoundingBoxXY(e) {
		this.boundingRect.x = e.x, this.boundingRect.y = e.y;
	}
	getDrawableElementsForLeftAxis() {
		let e = [];
		if (this.showAxisLine) {
			let t = this.boundingRect.x + this.boundingRect.width - this.axisConfig.axisLineWidth / 2;
			e.push({
				type: "path",
				groupTexts: ["left-axis", "axisl-line"],
				data: [{
					path: `M ${t},${this.boundingRect.y} L ${t},${this.boundingRect.y + this.boundingRect.height} `,
					strokeFill: this.axisThemeConfig.axisLineColor,
					strokeWidth: this.axisConfig.axisLineWidth
				}]
			});
		}
		if (this.showLabel && e.push({
			type: "text",
			groupTexts: ["left-axis", "label"],
			data: this.getTickValues().map((e) => ({
				text: e.toString(),
				x: this.boundingRect.x + this.boundingRect.width - (this.showLabel ? this.axisConfig.labelPadding : 0) - (this.showTick ? this.axisConfig.tickLength : 0) - (this.showAxisLine ? this.axisConfig.axisLineWidth : 0),
				y: this.getScaleValue(e),
				fill: this.axisThemeConfig.labelColor,
				fontSize: this.axisConfig.labelFontSize,
				rotation: 0,
				verticalPos: "middle",
				horizontalPos: "right"
			}))
		}), this.showTick) {
			let t = this.boundingRect.x + this.boundingRect.width - (this.showAxisLine ? this.axisConfig.axisLineWidth : 0);
			e.push({
				type: "path",
				groupTexts: ["left-axis", "ticks"],
				data: this.getTickValues().map((e) => ({
					path: `M ${t},${this.getScaleValue(e)} L ${t - this.axisConfig.tickLength},${this.getScaleValue(e)}`,
					strokeFill: this.axisThemeConfig.tickColor,
					strokeWidth: this.axisConfig.tickWidth
				}))
			});
		}
		return this.showTitle && e.push({
			type: "text",
			groupTexts: ["left-axis", "title"],
			data: [{
				text: this.title,
				x: this.boundingRect.x + this.axisConfig.titlePadding,
				y: this.boundingRect.y + this.boundingRect.height / 2,
				fill: this.axisThemeConfig.titleColor,
				fontSize: this.axisConfig.titleFontSize,
				rotation: 270,
				verticalPos: "top",
				horizontalPos: "center"
			}]
		}), e;
	}
	getDrawableElementsForBottomAxis() {
		let e = [];
		if (this.showAxisLine) {
			let t = this.boundingRect.y + this.axisConfig.axisLineWidth / 2;
			e.push({
				type: "path",
				groupTexts: ["bottom-axis", "axis-line"],
				data: [{
					path: `M ${this.boundingRect.x},${t} L ${this.boundingRect.x + this.boundingRect.width},${t}`,
					strokeFill: this.axisThemeConfig.axisLineColor,
					strokeWidth: this.axisConfig.axisLineWidth
				}]
			});
		}
		if (this.showLabel && e.push({
			type: "text",
			groupTexts: ["bottom-axis", "label"],
			data: this.getTickValues().map((e) => ({
				text: e.toString(),
				x: this.getScaleValue(e),
				y: this.boundingRect.y + this.axisConfig.labelPadding + (this.showTick ? this.axisConfig.tickLength : 0) + (this.showAxisLine ? this.axisConfig.axisLineWidth : 0),
				fill: this.axisThemeConfig.labelColor,
				fontSize: this.axisConfig.labelFontSize,
				rotation: 0,
				verticalPos: "top",
				horizontalPos: "center"
			}))
		}), this.showTick) {
			let t = this.boundingRect.y + (this.showAxisLine ? this.axisConfig.axisLineWidth : 0);
			e.push({
				type: "path",
				groupTexts: ["bottom-axis", "ticks"],
				data: this.getTickValues().map((e) => ({
					path: `M ${this.getScaleValue(e)},${t} L ${this.getScaleValue(e)},${t + this.axisConfig.tickLength}`,
					strokeFill: this.axisThemeConfig.tickColor,
					strokeWidth: this.axisConfig.tickWidth
				}))
			});
		}
		return this.showTitle && e.push({
			type: "text",
			groupTexts: ["bottom-axis", "title"],
			data: [{
				text: this.title,
				x: this.range[0] + (this.range[1] - this.range[0]) / 2,
				y: this.boundingRect.y + this.boundingRect.height - this.axisConfig.titlePadding - this.titleTextHeight,
				fill: this.axisThemeConfig.titleColor,
				fontSize: this.axisConfig.titleFontSize,
				rotation: 0,
				verticalPos: "top",
				horizontalPos: "center"
			}]
		}), e;
	}
	getDrawableElementsForTopAxis() {
		let e = [];
		if (this.showAxisLine) {
			let t = this.boundingRect.y + this.boundingRect.height - this.axisConfig.axisLineWidth / 2;
			e.push({
				type: "path",
				groupTexts: ["top-axis", "axis-line"],
				data: [{
					path: `M ${this.boundingRect.x},${t} L ${this.boundingRect.x + this.boundingRect.width},${t}`,
					strokeFill: this.axisThemeConfig.axisLineColor,
					strokeWidth: this.axisConfig.axisLineWidth
				}]
			});
		}
		if (this.showLabel && e.push({
			type: "text",
			groupTexts: ["top-axis", "label"],
			data: this.getTickValues().map((e) => ({
				text: e.toString(),
				x: this.getScaleValue(e),
				y: this.boundingRect.y + (this.showTitle ? this.titleTextHeight + 2 * this.axisConfig.titlePadding : 0) + this.axisConfig.labelPadding,
				fill: this.axisThemeConfig.labelColor,
				fontSize: this.axisConfig.labelFontSize,
				rotation: 0,
				verticalPos: "top",
				horizontalPos: "center"
			}))
		}), this.showTick) {
			let t = this.boundingRect.y;
			e.push({
				type: "path",
				groupTexts: ["top-axis", "ticks"],
				data: this.getTickValues().map((e) => ({
					path: `M ${this.getScaleValue(e)},${t + this.boundingRect.height - (this.showAxisLine ? this.axisConfig.axisLineWidth : 0)} L ${this.getScaleValue(e)},${t + this.boundingRect.height - this.axisConfig.tickLength - (this.showAxisLine ? this.axisConfig.axisLineWidth : 0)}`,
					strokeFill: this.axisThemeConfig.tickColor,
					strokeWidth: this.axisConfig.tickWidth
				}))
			});
		}
		return this.showTitle && e.push({
			type: "text",
			groupTexts: ["top-axis", "title"],
			data: [{
				text: this.title,
				x: this.boundingRect.x + this.boundingRect.width / 2,
				y: this.boundingRect.y + this.axisConfig.titlePadding,
				fill: this.axisThemeConfig.titleColor,
				fontSize: this.axisConfig.titleFontSize,
				rotation: 0,
				verticalPos: "top",
				horizontalPos: "center"
			}]
		}), e;
	}
	getDrawableElements() {
		if ("left" === this.axisPosition) return this.getDrawableElementsForLeftAxis();
		if ("right" === this.axisPosition) throw Error("Drawing of right axis is not implemented");
		return "bottom" === this.axisPosition ? this.getDrawableElementsForBottomAxis() : "top" === this.axisPosition ? this.getDrawableElementsForTopAxis() : [];
	}
}, ewB = class extends ewP {
	static {
		h(this, "BandAxis");
	}
	constructor(e, t, r, i, n) {
		super(e, i, n, t), this.categories = r, this.scale = Aw().domain(this.categories).range(this.getRange());
	}
	setRange(e) {
		super.setRange(e);
	}
	recalculateScale() {
		this.scale = Aw().domain(this.categories).range(this.getRange()).paddingInner(1).paddingOuter(0).align(.5), wQ.trace("BandAxis axis final categories, range: ", this.categories, this.getRange());
	}
	getTickValues() {
		return this.categories;
	}
	getScaleValue(e) {
		return this.scale(e) ?? this.getRange()[0];
	}
}, ewF = class extends ewP {
	static {
		h(this, "LinearAxis");
	}
	constructor(e, t, r, i, n) {
		super(e, i, n, t), this.domain = r, this.scale = CR().domain(this.domain).range(this.getRange());
	}
	getTickValues() {
		return this.scale.ticks();
	}
	recalculateScale() {
		let e = [...this.domain];
		"left" === this.axisPosition && e.reverse(), this.scale = CR().domain(e).range(this.getRange());
	}
	getScaleValue(e) {
		return this.scale(e);
	}
};
function ewz(e, t, r, i) {
	let n = new ew$(i);
	return ewD(e) ? new ewB(t, r, e.categories, e.title, n) : new ewF(t, r, [e.min, e.max], e.title, n);
}
h(ewz, "getAxis");
var ewU = class {
	constructor(e, t, r, i) {
		this.textDimensionCalculator = e, this.chartConfig = t, this.chartData = r, this.chartThemeConfig = i, this.boundingRect = {
			x: 0,
			y: 0,
			width: 0,
			height: 0
		}, this.showChartTitle = !1;
	}
	static {
		h(this, "ChartTitle");
	}
	setBoundingBoxXY(e) {
		this.boundingRect.x = e.x, this.boundingRect.y = e.y;
	}
	calculateSpace(e) {
		let t = this.textDimensionCalculator.getMaxDimension([this.chartData.title], this.chartConfig.titleFontSize), r = Math.max(t.width, e.width), i = t.height + 2 * this.chartConfig.titlePadding;
		return t.width <= r && t.height <= i && this.chartConfig.showTitle && this.chartData.title && (this.boundingRect.width = r, this.boundingRect.height = i, this.showChartTitle = !0), {
			width: this.boundingRect.width,
			height: this.boundingRect.height
		};
	}
	getDrawableElements() {
		let e = [];
		return this.showChartTitle && e.push({
			groupTexts: ["chart-title"],
			type: "text",
			data: [{
				fontSize: this.chartConfig.titleFontSize,
				text: this.chartData.title,
				verticalPos: "middle",
				horizontalPos: "center",
				x: this.boundingRect.x + this.boundingRect.width / 2,
				y: this.boundingRect.y + this.boundingRect.height / 2,
				fill: this.chartThemeConfig.titleColor,
				rotation: 0
			}]
		}), e;
	}
};
function ewG(e, t, r, i) {
	return new ewU(new ew$(i), e, t, r);
}
h(ewG, "getChartTitleComponent");
var ewq = class {
	constructor(e, t, r, i, n) {
		this.plotData = e, this.xAxis = t, this.yAxis = r, this.orientation = i, this.plotIndex = n;
	}
	static {
		h(this, "LinePlot");
	}
	getDrawableElement() {
		let e = this.plotData.data.map((e) => [this.xAxis.getScaleValue(e[0]), this.yAxis.getScaleValue(e[1])]), t;
		return (t = "horizontal" === this.orientation ? A5().y((e) => e[0]).x((e) => e[1])(e) : A5().x((e) => e[0]).y((e) => e[1])(e)) ? [{
			groupTexts: ["plot", `line-plot-${this.plotIndex}`],
			type: "path",
			data: [{
				path: t,
				strokeFill: this.plotData.strokeFill,
				strokeWidth: this.plotData.strokeWidth
			}]
		}] : [];
	}
}, ewj = class {
	constructor(e, t, r, i, n, a) {
		this.barData = e, this.boundingRect = t, this.xAxis = r, this.yAxis = i, this.orientation = n, this.plotIndex = a;
	}
	static {
		h(this, "BarPlot");
	}
	getDrawableElement() {
		let e = this.barData.data.map((e) => [this.xAxis.getScaleValue(e[0]), this.yAxis.getScaleValue(e[1])]), t = .95 * Math.min(2 * this.xAxis.getAxisOuterPadding(), this.xAxis.getTickDistance()), r = t / 2;
		return "horizontal" === this.orientation ? [{
			groupTexts: ["plot", `bar-plot-${this.plotIndex}`],
			type: "rect",
			data: e.map((e) => ({
				x: this.boundingRect.x,
				y: e[0] - r,
				height: t,
				width: e[1] - this.boundingRect.x,
				fill: this.barData.fill,
				strokeWidth: 0,
				strokeFill: this.barData.fill
			}))
		}] : [{
			groupTexts: ["plot", `bar-plot-${this.plotIndex}`],
			type: "rect",
			data: e.map((e) => ({
				x: e[0] - r,
				y: e[1],
				width: t,
				height: this.boundingRect.y + this.boundingRect.height - e[1],
				fill: this.barData.fill,
				strokeWidth: 0,
				strokeFill: this.barData.fill
			}))
		}];
	}
}, ewW = class {
	constructor(e, t, r) {
		this.chartConfig = e, this.chartData = t, this.chartThemeConfig = r, this.boundingRect = {
			x: 0,
			y: 0,
			width: 0,
			height: 0
		};
	}
	static {
		h(this, "BasePlot");
	}
	setAxes(e, t) {
		this.xAxis = e, this.yAxis = t;
	}
	setBoundingBoxXY(e) {
		this.boundingRect.x = e.x, this.boundingRect.y = e.y;
	}
	calculateSpace(e) {
		return this.boundingRect.width = e.width, this.boundingRect.height = e.height, {
			width: this.boundingRect.width,
			height: this.boundingRect.height
		};
	}
	getDrawableElements() {
		if (!(this.xAxis && this.yAxis)) throw Error("Axes must be passed to render Plots");
		let e = [];
		for (let [t, r] of this.chartData.plots.entries()) switch (r.type) {
			case "line":
				{
					let i = new ewq(r, this.xAxis, this.yAxis, this.chartConfig.chartOrientation, t);
					e.push(...i.getDrawableElement());
				}
				break;
			case "bar": {
				let i = new ewj(r, this.boundingRect, this.xAxis, this.yAxis, this.chartConfig.chartOrientation, t);
				e.push(...i.getDrawableElement());
			}
		}
		return e;
	}
};
function ewY(e, t, r) {
	return new ewW(e, t, r);
}
h(ewY, "getPlotComponent");
var ewV, ewH = class {
	constructor(e, t, r, i) {
		this.chartConfig = e, this.chartData = t, this.componentStore = {
			title: ewG(e, t, r, i),
			plot: ewY(e, t, r),
			xAxis: ewz(t.xAxis, e.xAxis, {
				titleColor: r.xAxisTitleColor,
				labelColor: r.xAxisLabelColor,
				tickColor: r.xAxisTickColor,
				axisLineColor: r.xAxisLineColor
			}, i),
			yAxis: ewz(t.yAxis, e.yAxis, {
				titleColor: r.yAxisTitleColor,
				labelColor: r.yAxisLabelColor,
				tickColor: r.yAxisTickColor,
				axisLineColor: r.yAxisLineColor
			}, i)
		};
	}
	static {
		h(this, "Orchestrator");
	}
	calculateVerticalSpace() {
		let e = this.chartConfig.width, t = this.chartConfig.height, r = 0, i = 0, n = Math.floor(e * this.chartConfig.plotReservedSpacePercent / 100), a = Math.floor(t * this.chartConfig.plotReservedSpacePercent / 100), s = this.componentStore.plot.calculateSpace({
			width: n,
			height: a
		});
		e -= s.width, t -= s.height, i = (s = this.componentStore.title.calculateSpace({
			width: this.chartConfig.width,
			height: t
		})).height, t -= s.height, this.componentStore.xAxis.setAxisPosition("bottom"), s = this.componentStore.xAxis.calculateSpace({
			width: e,
			height: t
		}), t -= s.height, this.componentStore.yAxis.setAxisPosition("left"), r = (s = this.componentStore.yAxis.calculateSpace({
			width: e,
			height: t
		})).width, (e -= s.width) > 0 && (n += e, e = 0), t > 0 && (a += t, t = 0), this.componentStore.plot.calculateSpace({
			width: n,
			height: a
		}), this.componentStore.plot.setBoundingBoxXY({
			x: r,
			y: i
		}), this.componentStore.xAxis.setRange([r, r + n]), this.componentStore.xAxis.setBoundingBoxXY({
			x: r,
			y: i + a
		}), this.componentStore.yAxis.setRange([i, i + a]), this.componentStore.yAxis.setBoundingBoxXY({
			x: 0,
			y: i
		}), this.chartData.plots.some((e) => ewM(e)) && this.componentStore.xAxis.recalculateOuterPaddingToDrawBar();
	}
	calculateHorizontalSpace() {
		let e = this.chartConfig.width, t = this.chartConfig.height, r = 0, i = 0, n = 0, a = Math.floor(e * this.chartConfig.plotReservedSpacePercent / 100), s = Math.floor(t * this.chartConfig.plotReservedSpacePercent / 100), o = this.componentStore.plot.calculateSpace({
			width: a,
			height: s
		});
		e -= o.width, t -= o.height, r = (o = this.componentStore.title.calculateSpace({
			width: this.chartConfig.width,
			height: t
		})).height, t -= o.height, this.componentStore.xAxis.setAxisPosition("left"), o = this.componentStore.xAxis.calculateSpace({
			width: e,
			height: t
		}), e -= o.width, i = o.width, this.componentStore.yAxis.setAxisPosition("top"), o = this.componentStore.yAxis.calculateSpace({
			width: e,
			height: t
		}), t -= o.height, n = r + o.height, e > 0 && (a += e, e = 0), t > 0 && (s += t, t = 0), this.componentStore.plot.calculateSpace({
			width: a,
			height: s
		}), this.componentStore.plot.setBoundingBoxXY({
			x: i,
			y: n
		}), this.componentStore.yAxis.setRange([i, i + a]), this.componentStore.yAxis.setBoundingBoxXY({
			x: i,
			y: r
		}), this.componentStore.xAxis.setRange([n, n + s]), this.componentStore.xAxis.setBoundingBoxXY({
			x: 0,
			y: n
		}), this.chartData.plots.some((e) => ewM(e)) && this.componentStore.xAxis.recalculateOuterPaddingToDrawBar();
	}
	calculateSpace() {
		"horizontal" === this.chartConfig.chartOrientation ? this.calculateHorizontalSpace() : this.calculateVerticalSpace();
	}
	getDrawableElement() {
		this.calculateSpace();
		let e = [];
		for (let t of (this.componentStore.plot.setAxes(this.componentStore.xAxis, this.componentStore.yAxis), Object.values(this.componentStore))) e.push(...t.getDrawableElements());
		return e;
	}
}, ewX = class {
	static {
		h(this, "XYChartBuilder");
	}
	static build(e, t, r, i) {
		return new ewH(e, t, r, i).getDrawableElement();
	}
}, ewK = 0, ewZ = ew5(), ewQ = ew4(), ewJ = ew3(), ew0 = ewQ.plotColorPalette.split(",").map((e) => e.trim()), ew1 = !1, ew2 = !1;
function ew4() {
	let e = Io(), t = IA();
	return V5(e.xyChart, t.themeVariables.xyChart);
}
function ew5() {
	let e = IA();
	return V5(Ip.xyChart, e.xyChart);
}
function ew3() {
	return {
		yAxis: {
			type: "linear",
			title: "",
			min: Infinity,
			max: -Infinity
		},
		xAxis: {
			type: "band",
			title: "",
			categories: []
		},
		title: "",
		plots: []
	};
}
function ew6(e) {
	let t = IA();
	return MO(e.trim(), t);
}
function ew7(e) {
	ewV = e;
}
function ew8(e) {
	"horizontal" === e ? ewZ.chartOrientation = "horizontal" : ewZ.chartOrientation = "vertical";
}
function ew9(e) {
	ewJ.xAxis.title = ew6(e.text);
}
function eke(e, t) {
	ewJ.xAxis = {
		type: "linear",
		title: ewJ.xAxis.title,
		min: e,
		max: t
	}, ew1 = !0;
}
function ekt(e) {
	ewJ.xAxis = {
		type: "band",
		title: ewJ.xAxis.title,
		categories: e.map((e) => ew6(e.text))
	}, ew1 = !0;
}
function ekr(e) {
	ewJ.yAxis.title = ew6(e.text);
}
function eki(e, t) {
	ewJ.yAxis = {
		type: "linear",
		title: ewJ.yAxis.title,
		min: e,
		max: t
	}, ew2 = !0;
}
function ekn(e) {
	let t = Math.min(...e), r = Math.max(...e), i = ewO(ewJ.yAxis) ? ewJ.yAxis.min : Infinity, n = ewO(ewJ.yAxis) ? ewJ.yAxis.max : -Infinity;
	ewJ.yAxis = {
		type: "linear",
		title: ewJ.yAxis.title,
		min: Math.min(i, t),
		max: Math.max(n, r)
	};
}
function eka(e) {
	let t = [];
	if (0 === e.length) return t;
	if (ew1 || eke(Math.min(ewO(ewJ.xAxis) ? ewJ.xAxis.min : Infinity, 1), Math.max(ewO(ewJ.xAxis) ? ewJ.xAxis.max : -Infinity, e.length)), ew2 || ekn(e), ewD(ewJ.xAxis) && (t = ewJ.xAxis.categories.map((t, r) => [t, e[r]])), ewO(ewJ.xAxis)) {
		let r = ewJ.xAxis.min, i = ewJ.xAxis.max, n = (i - r) / (e.length - 1), a = [];
		for (let e = r; e <= i; e += n) a.push(`${e}`);
		t = a.map((t, r) => [t, e[r]]);
	}
	return t;
}
function eks(e) {
	return ew0[0 === e ? 0 : e % ew0.length];
}
function eko(e, t) {
	let r = eka(t);
	ewJ.plots.push({
		type: "line",
		strokeFill: eks(ewK),
		strokeWidth: 2,
		data: r
	}), ewK++;
}
function ekl(e, t) {
	let r = eka(t);
	ewJ.plots.push({
		type: "bar",
		fill: eks(ewK),
		data: r
	}), ewK++;
}
function ekc() {
	if (0 === ewJ.plots.length) throw Error("No Plot to render, please provide a plot with some data");
	return ewJ.title = Dh(), ewX.build(ewZ, ewJ, ewQ, ewV);
}
function ekh() {
	return ewQ;
}
function eku() {
	return ewZ;
}
function ekd() {
	return ewJ;
}
h(ew4, "getChartDefaultThemeConfig"), h(ew5, "getChartDefaultConfig"), h(ew3, "getChartDefaultData"), h(ew6, "textSanitizer"), h(ew7, "setTmpSVGG"), h(ew8, "setOrientation"), h(ew9, "setXAxisTitle"), h(eke, "setXAxisRangeData"), h(ekt, "setXAxisBand"), h(ekr, "setYAxisTitle"), h(eki, "setYAxisRangeData"), h(ekn, "setYAxisRangeFromPlotData"), h(eka, "transformDataWithoutCategory"), h(eks, "getPlotColorFromPalette"), h(eko, "setLineData"), h(ekl, "setBarData"), h(ekc, "getDrawableElem"), h(ekh, "getChartThemeConfig"), h(eku, "getChartConfig"), h(ekd, "getXYChartData");
var ekp = {
	parser: ewI,
	db: {
		getDrawableElem: ekc,
		clear: h(function() {
			Dn(), ewK = 0, ewZ = ew5(), ewJ = ew3(), ew0 = (ewQ = ew4()).plotColorPalette.split(",").map((e) => e.trim()), ew1 = !1, ew2 = !1;
		}, "clear"),
		setAccTitle: Da,
		getAccTitle: Ds,
		setDiagramTitle: Dc,
		getDiagramTitle: Dh,
		getAccDescription: Dl,
		setAccDescription: Do,
		setOrientation: ew8,
		setXAxisTitle: ew9,
		setXAxisRangeData: eke,
		setXAxisBand: ekt,
		setYAxisTitle: ekr,
		setYAxisRangeData: eki,
		setLineData: eko,
		setBarData: ekl,
		setTmpSVGG: ew7,
		getChartThemeConfig: ekh,
		getChartConfig: eku,
		getXYChartData: ekd
	},
	renderer: { draw: h((e, t, r, i) => {
		let n = i.db, a = n.getChartThemeConfig(), s = n.getChartConfig(), o = n.getXYChartData().plots[0].data.map((e) => e[1]);
		function l(e) {
			return "top" === e ? "text-before-edge" : "middle";
		}
		function u(e) {
			return "left" === e ? "start" : "right" === e ? "end" : "middle";
		}
		function d(e) {
			return `translate(${e.x}, ${e.y}) rotate(${e.rotation || 0})`;
		}
		h(l, "getDominantBaseLine"), h(u, "getTextAnchor"), h(d, "getTextTransformation"), wQ.debug(`Rendering xychart chart
` + e);
		let p = Dy(t), f = p.append("g").attr("class", "main"), g = f.append("rect").attr("width", s.width).attr("height", s.height).attr("class", "background");
		M5(p, s.height, s.width, !0), p.attr("viewBox", `0 0 ${s.width} ${s.height}`), g.attr("fill", a.backgroundColor), n.setTmpSVGG(p.append("g").attr("class", "mermaid-tmp-group"));
		let m = n.getDrawableElem(), y = {};
		function v(e) {
			let t = f, r = "";
			for (let [i] of e.entries()) {
				let n = f;
				i > 0 && y[r] && (n = y[r]), r += e[i], (t = y[r]) || (t = y[r] = n.append("g").attr("class", e[i]));
			}
			return t;
		}
		for (let e of (h(v, "getGroup"), m)) {
			if (0 === e.data.length) continue;
			let t = v(e.groupTexts);
			switch (e.type) {
				case "rect":
					if (t.selectAll("rect").data(e.data).enter().append("rect").attr("x", (e) => e.x).attr("y", (e) => e.y).attr("width", (e) => e.width).attr("height", (e) => e.height).attr("fill", (e) => e.fill).attr("stroke", (e) => e.strokeFill).attr("stroke-width", (e) => e.strokeWidth), s.showDataLabel) if ("horizontal" === s.chartOrientation) {
						let r = function(e, t) {
							let { data: r, label: i } = e;
							return t * i.length * .7 <= r.width - 10;
						};
						h(r, "fitsHorizontally");
						let i = e.data.map((e, t) => ({
							data: e,
							label: o[t].toString()
						})).filter((e) => e.data.width > 0 && e.data.height > 0), n = Math.floor(Math.min(...i.map((e) => {
							let { data: t } = e, i = .7 * t.height;
							for (; !r(e, i) && i > 0;) i -= 1;
							return i;
						})));
						t.selectAll("text").data(i).enter().append("text").attr("x", (e) => e.data.x + e.data.width - 10).attr("y", (e) => e.data.y + e.data.height / 2).attr("text-anchor", "end").attr("dominant-baseline", "middle").attr("fill", "black").attr("font-size", `${n}px`).text((e) => e.label);
					} else {
						let r = function(e, t, r) {
							let { data: i, label: n } = e, a = t * n.length * .7, s = i.x + i.width / 2, o = s - a / 2, l = s + a / 2, h = o >= i.x && l <= i.x + i.width, u = i.y + r + t <= i.y + i.height;
							return h && u;
						};
						h(r, "fitsInBar");
						let i = e.data.map((e, t) => ({
							data: e,
							label: o[t].toString()
						})).filter((e) => e.data.width > 0 && e.data.height > 0), n = Math.floor(Math.min(...i.map((e) => {
							let { data: t, label: i } = e, n = t.width / (.7 * i.length);
							for (; !r(e, n, 10) && n > 0;) n -= 1;
							return n;
						})));
						t.selectAll("text").data(i).enter().append("text").attr("x", (e) => e.data.x + e.data.width / 2).attr("y", (e) => e.data.y + 10).attr("text-anchor", "middle").attr("dominant-baseline", "hanging").attr("fill", "black").attr("font-size", `${n}px`).text((e) => e.label);
					}
					break;
				case "text":
					t.selectAll("text").data(e.data).enter().append("text").attr("x", 0).attr("y", 0).attr("fill", (e) => e.fill).attr("font-size", (e) => e.fontSize).attr("dominant-baseline", (e) => l(e.verticalPos)).attr("text-anchor", (e) => u(e.horizontalPos)).attr("transform", (e) => d(e)).text((e) => e.text);
					break;
				case "path": t.selectAll("path").data(e.data).enter().append("path").attr("d", (e) => e.path).attr("fill", (e) => e.fill ? e.fill : "none").attr("stroke", (e) => e.strokeFill).attr("stroke-width", (e) => e.strokeWidth);
			}
		}
	}, "draw") }
}, ekf = {
	id: "c4",
	detector: h((e) => /^\s*C4Context|C4Container|C4Component|C4Dynamic|C4Deployment/.test(e), "detector"),
	loader: h(async () => {
		let { diagram: e } = await r(async () => {
			let { diagram: e } = await import("./vendor-mermaid.Cx1XVLz5.chunk.js");
			return { diagram: e };
		}, []);
		return {
			id: "c4",
			diagram: e
		};
	}, "loader")
}, ekg = "flowchart", ekm = {
	id: ekg,
	detector: h((e, t) => t?.flowchart?.defaultRenderer !== "dagre-wrapper" && t?.flowchart?.defaultRenderer !== "elk" && /^\s*graph/.test(e), "detector"),
	loader: h(async () => {
		let { diagram: e } = await r(async () => {
			let { diagram: e } = await import("./vendor-mermaid.05lsJZWW.chunk.js");
			return { diagram: e };
		}, []);
		return {
			id: ekg,
			diagram: e
		};
	}, "loader")
}, eky = "flowchart-v2", ekv = {
	id: eky,
	detector: h((e, t) => t?.flowchart?.defaultRenderer !== "dagre-d3" && (t?.flowchart?.defaultRenderer === "elk" && (t.layout = "elk"), !!/^\s*graph/.test(e) && t?.flowchart?.defaultRenderer === "dagre-wrapper" || /^\s*flowchart/.test(e)), "detector"),
	loader: h(async () => {
		let { diagram: e } = await r(async () => {
			let { diagram: e } = await import("./vendor-mermaid.05lsJZWW.chunk.js");
			return { diagram: e };
		}, []);
		return {
			id: eky,
			diagram: e
		};
	}, "loader")
}, ekx = {
	id: "er",
	detector: h((e) => /^\s*erDiagram/.test(e), "detector"),
	loader: h(async () => {
		let { diagram: e } = await r(async () => {
			let { diagram: e } = await import("./vendor-mermaid.CHGcRN3L.chunk.js");
			return { diagram: e };
		}, []);
		return {
			id: "er",
			diagram: e
		};
	}, "loader")
}, ekb = "gitGraph", ekw = {
	id: ekb,
	detector: h((e) => /^\s*gitGraph/.test(e), "detector"),
	loader: h(async () => {
		let { diagram: e } = await r(async () => {
			let { diagram: e } = await import("./vendor-mermaid.BgspjZ9X.chunk.js");
			return { diagram: e };
		}, []);
		return {
			id: ekb,
			diagram: e
		};
	}, "loader")
}, ekk = "gantt", ekT = {
	id: ekk,
	detector: h((e) => /^\s*gantt/.test(e), "detector"),
	loader: h(async () => {
		let { diagram: e } = await r(async () => {
			let { diagram: e } = await import("./vendor-mermaid.aun6R-iT.chunk.js");
			return { diagram: e };
		}, []);
		return {
			id: ekk,
			diagram: e
		};
	}, "loader")
}, ek_ = "info", ekE = {
	id: ek_,
	detector: h((e) => /^\s*info/.test(e), "detector"),
	loader: h(async () => {
		let { diagram: e } = await r(async () => {
			let { diagram: e } = await import("./vendor-mermaid.BJigFdVg.chunk.js");
			return { diagram: e };
		}, []);
		return {
			id: ek_,
			diagram: e
		};
	}, "loader")
}, ekC = {
	id: "pie",
	detector: h((e) => /^\s*pie/.test(e), "detector"),
	loader: h(async () => {
		let { diagram: e } = await r(async () => {
			let { diagram: e } = await import("./vendor-mermaid.CrxAQhgp.chunk.js");
			return { diagram: e };
		}, []);
		return {
			id: "pie",
			diagram: e
		};
	}, "loader")
}, ekS = "quadrantChart", ekA = {
	id: ekS,
	detector: h((e) => /^\s*quadrantChart/.test(e), "detector"),
	loader: h(async () => {
		let { diagram: e } = await r(async () => {
			let { diagram: e } = await import("./vendor-mermaid.DRMTfwEA.chunk.js");
			return { diagram: e };
		}, []);
		return {
			id: ekS,
			diagram: e
		};
	}, "loader")
}, ekL = "xychart", ekR = {
	id: ekL,
	detector: h((e) => /^\s*xychart(-beta)?/.test(e), "detector"),
	loader: h(async () => {
		let { diagram: e } = await r(async () => {
			let { diagram: e } = await import("./vendor-mermaid.D2nw8MAN.chunk.js");
			return { diagram: e };
		}, []);
		return {
			id: ekL,
			diagram: e
		};
	}, "loader")
}, ekN = "requirement", ekI = {
	id: ekN,
	detector: h((e) => /^\s*requirement(Diagram)?/.test(e), "detector"),
	loader: h(async () => {
		let { diagram: e } = await r(async () => {
			let { diagram: e } = await import("./vendor-mermaid.NNS6R3C2.chunk.js");
			return { diagram: e };
		}, []);
		return {
			id: ekN,
			diagram: e
		};
	}, "loader")
}, ekM = "sequence", ekD = {
	id: ekM,
	detector: h((e) => /^\s*sequenceDiagram/.test(e), "detector"),
	loader: h(async () => {
		let { diagram: e } = await r(async () => {
			let { diagram: e } = await import("./vendor-mermaid.B2tpIA4D.chunk.js");
			return { diagram: e };
		}, []);
		return {
			id: ekM,
			diagram: e
		};
	}, "loader")
}, ekO = "class", ek$ = {
	id: ekO,
	detector: h((e, t) => t?.class?.defaultRenderer !== "dagre-wrapper" && /^\s*classDiagram/.test(e), "detector"),
	loader: h(async () => {
		let { diagram: e } = await r(async () => {
			let { diagram: e } = await import("./vendor-mermaid.B5WaN9PH.chunk.js");
			return { diagram: e };
		}, []);
		return {
			id: ekO,
			diagram: e
		};
	}, "loader")
}, ekP = "classDiagram", ekB = {
	id: ekP,
	detector: h((e, t) => !!/^\s*classDiagram/.test(e) && t?.class?.defaultRenderer === "dagre-wrapper" || /^\s*classDiagram-v2/.test(e), "detector"),
	loader: h(async () => {
		let { diagram: e } = await r(async () => {
			let { diagram: e } = await import("./vendor-mermaid.DaQ3J3X4.chunk.js");
			return { diagram: e };
		}, []);
		return {
			id: ekP,
			diagram: e
		};
	}, "loader")
}, ekF = "state", ekz = {
	id: ekF,
	detector: h((e, t) => t?.state?.defaultRenderer !== "dagre-wrapper" && /^\s*stateDiagram/.test(e), "detector"),
	loader: h(async () => {
		let { diagram: e } = await r(async () => {
			let { diagram: e } = await import("./vendor-mermaid.BKTUNnmD.chunk.js");
			return { diagram: e };
		}, []);
		return {
			id: ekF,
			diagram: e
		};
	}, "loader")
}, ekU = "stateDiagram", ekG = {
	id: ekU,
	detector: h((e, t) => !!(/^\s*stateDiagram-v2/.test(e) || /^\s*stateDiagram/.test(e) && t?.state?.defaultRenderer === "dagre-wrapper"), "detector"),
	loader: h(async () => {
		let { diagram: e } = await r(async () => {
			let { diagram: e } = await import("./vendor-mermaid.DuZl-Bgi.chunk.js");
			return { diagram: e };
		}, []);
		return {
			id: ekU,
			diagram: e
		};
	}, "loader")
}, ekq = "journey", ekj = {
	id: ekq,
	detector: h((e) => /^\s*journey/.test(e), "detector"),
	loader: h(async () => {
		let { diagram: e } = await r(async () => {
			let { diagram: e } = await import("./vendor-mermaid.BZk50gYD.chunk.js");
			return { diagram: e };
		}, []);
		return {
			id: ekq,
			diagram: e
		};
	}, "loader")
}, ekW = { draw: h((e, t, r) => {
	wQ.debug(`rendering svg for syntax error
`);
	let i = Dy(t), n = i.append("g");
	i.attr("viewBox", "0 0 2412 512"), M5(i, 100, 512, !0), n.append("path").attr("class", "error-icon").attr("d", "m411.313,123.313c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32-9.375,9.375-20.688-20.688c-12.484-12.5-32.766-12.5-45.25,0l-16,16c-1.261,1.261-2.304,2.648-3.31,4.051-21.739-8.561-45.324-13.426-70.065-13.426-105.867,0-192,86.133-192,192s86.133,192 192,192 192-86.133 192-192c0-24.741-4.864-48.327-13.426-70.065 1.402-1.007 2.79-2.049 4.051-3.31l16-16c12.5-12.492 12.5-32.758 0-45.25l-20.688-20.688 9.375-9.375 32.001-31.999zm-219.313,100.687c-52.938,0-96,43.063-96,96 0,8.836-7.164,16-16,16s-16-7.164-16-16c0-70.578 57.422-128 128-128 8.836,0 16,7.164 16,16s-7.164,16-16,16z"), n.append("path").attr("class", "error-icon").attr("d", "m459.02,148.98c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l16,16c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16.001-16z"), n.append("path").attr("class", "error-icon").attr("d", "m340.395,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16-16c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l15.999,16z"), n.append("path").attr("class", "error-icon").attr("d", "m400,64c8.844,0 16-7.164 16-16v-32c0-8.836-7.156-16-16-16-8.844,0-16,7.164-16,16v32c0,8.836 7.156,16 16,16z"), n.append("path").attr("class", "error-icon").attr("d", "m496,96.586h-32c-8.844,0-16,7.164-16,16 0,8.836 7.156,16 16,16h32c8.844,0 16-7.164 16-16 0-8.836-7.156-16-16-16z"), n.append("path").attr("class", "error-icon").attr("d", "m436.98,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688l32-32c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32c-6.251,6.25-6.251,16.375-0.001,22.625z"), n.append("text").attr("class", "error-text").attr("x", 1440).attr("y", 250).attr("font-size", "150px").style("text-anchor", "middle").text("Syntax error in text"), n.append("text").attr("class", "error-text").attr("x", 1250).attr("y", 400).attr("font-size", "100px").style("text-anchor", "middle").text(`mermaid version ${r}`);
}, "draw") }, ekY = {
	db: {},
	renderer: ekW,
	parser: { parse: h(() => {}, "parse") }
}, ekV = "flowchart-elk", ekH = {
	id: ekV,
	detector: h((e, t = {}) => !!(/^\s*flowchart-elk/.test(e) || /^\s*(flowchart|graph)/.test(e) && t?.flowchart?.defaultRenderer === "elk") && (t.layout = "elk", !0), "detector"),
	loader: h(async () => {
		let { diagram: e } = await r(async () => {
			let { diagram: e } = await import("./vendor-mermaid.05lsJZWW.chunk.js");
			return { diagram: e };
		}, []);
		return {
			id: ekV,
			diagram: e
		};
	}, "loader")
}, ekX = "timeline", ekK = {
	id: ekX,
	detector: h((e) => /^\s*timeline/.test(e), "detector"),
	loader: h(async () => {
		let { diagram: e } = await r(async () => {
			let { diagram: e } = await import("./vendor-mermaid.CJIR3_lc.chunk.js");
			return { diagram: e };
		}, []);
		return {
			id: ekX,
			diagram: e
		};
	}, "loader")
}, ekZ = "mindmap", ekQ = {
	id: ekZ,
	detector: h((e) => /^\s*mindmap/.test(e), "detector"),
	loader: h(async () => {
		let { diagram: e } = await r(async () => {
			let { diagram: e } = await import("./vendor-mermaid.BWjyJW2O.chunk.js");
			return { diagram: e };
		}, []);
		return {
			id: ekZ,
			diagram: e
		};
	}, "loader")
}, ekJ = "kanban", ek0 = {
	id: ekJ,
	detector: h((e) => /^\s*kanban/.test(e), "detector"),
	loader: h(async () => {
		let { diagram: e } = await r(async () => {
			let { diagram: e } = await import("./vendor-mermaid.CZajZCiW.chunk.js");
			return { diagram: e };
		}, []);
		return {
			id: ekJ,
			diagram: e
		};
	}, "loader")
}, ek1 = "sankey", ek2 = {
	id: ek1,
	detector: h((e) => /^\s*sankey(-beta)?/.test(e), "detector"),
	loader: h(async () => {
		let { diagram: e } = await r(async () => {
			let { diagram: e } = await import("./vendor-mermaid.ldQWRqUX.chunk.js");
			return { diagram: e };
		}, []);
		return {
			id: ek1,
			diagram: e
		};
	}, "loader")
}, ek4 = "packet", ek5 = {
	id: ek4,
	detector: h((e) => /^\s*packet(-beta)?/.test(e), "detector"),
	loader: h(async () => {
		let { diagram: e } = await r(async () => {
			let { diagram: e } = await import("./vendor-mermaid.DJrgTE8e.chunk.js");
			return { diagram: e };
		}, []);
		return {
			id: ek4,
			diagram: e
		};
	}, "loader")
}, ek3 = "radar", ek6 = {
	id: ek3,
	detector: h((e) => /^\s*radar-beta/.test(e), "detector"),
	loader: h(async () => {
		let { diagram: e } = await r(async () => {
			let { diagram: e } = await import("./vendor-mermaid.Dqdtxg-9.chunk.js");
			return { diagram: e };
		}, []);
		return {
			id: ek3,
			diagram: e
		};
	}, "loader")
}, ek7 = "block", ek8 = {
	id: ek7,
	detector: h((e) => /^\s*block(-beta)?/.test(e), "detector"),
	loader: h(async () => {
		let { diagram: e } = await r(async () => {
			let { diagram: e } = await import("./vendor-mermaid.B-KDiTia.chunk.js");
			return { diagram: e };
		}, []);
		return {
			id: ek7,
			diagram: e
		};
	}, "loader")
}, ek9 = "architecture", eTe = {
	id: ek9,
	detector: h((e) => /^\s*architecture/.test(e), "detector"),
	loader: h(async () => {
		let { diagram: e } = await r(async () => {
			let { diagram: e } = await import("./vendor-mermaid.DEBLWOHx.chunk.js");
			return { diagram: e };
		}, []);
		return {
			id: ek9,
			diagram: e
		};
	}, "loader")
}, eTt = "treemap", eTr = {
	id: eTt,
	detector: h((e) => /^\s*treemap/.test(e), "detector"),
	loader: h(async () => {
		let { diagram: e } = await r(async () => {
			let { diagram: e } = await import("./vendor-mermaid.D35Hw9Ed.chunk.js");
			return { diagram: e };
		}, []);
		return {
			id: eTt,
			diagram: e
		};
	}, "loader")
}, eTi = !1, eTn = h(() => {
	eTi || (eTi = !0, Df("error", ekY, (e) => "error" === e.toLowerCase().trim()), Df("---", {
		db: { clear: h(() => {}, "clear") },
		styles: {},
		renderer: { draw: h(() => {}, "draw") },
		parser: { parse: h(() => {
			throw Error("Diagrams beginning with --- are not valid. If you were trying to use a YAML front-matter, please ensure that you've correctly opened and closed the YAML front-matter with un-indented `---` blocks");
		}, "parse") },
		init: h(() => null, "init")
	}, (e) => e.toLowerCase().trimStart().startsWith("---")), N$(ekH, ekQ, eTe), N$(ekf, ek0, ekB, ek$, ekx, ekT, ekE, ekC, ekI, ekD, ekv, ekm, ekK, ekw, ekG, ekz, ekj, ekA, ek2, ek5, ekR, ek8, ek6, eTr));
}, "addDiagrams"), eTa = h(async () => {
	wQ.debug("Loading registered diagrams");
	let e = (await Promise.allSettled(Object.entries(ND).map(async ([e, { detector: t, loader: r }]) => {
		if (r) try {
			Dg(e);
		} catch {
			try {
				let { diagram: e, id: i } = await r();
				Df(i, e, t);
			} catch (t) {
				throw wQ.error(`Failed to load external diagram with key ${e}. Removing from detectors.`), delete ND[e], t;
			}
		}
	}))).filter((e) => "rejected" === e.status);
	if (e.length > 0) {
		for (let t of (wQ.error(`Failed to load ${e.length} external diagrams`), e)) wQ.error(t);
		throw Error(`Failed to load ${e.length} external diagrams`);
	}
}, "loadRegisteredDiagrams"), eTs = "comm", eTo = "rule", eTl = "decl", eTc = Math.abs, eTh = String.fromCharCode;
function eTu(e) {
	return e.trim();
}
function eTd(e, t, r) {
	return e.replace(t, r);
}
function eTp(e, t, r) {
	return e.indexOf(t, r);
}
function eTf(e, t) {
	return 0 | e.charCodeAt(t);
}
function eTg(e, t, r) {
	return e.slice(t, r);
}
function eTm(e) {
	return e.length;
}
function eTy(e) {
	return e.length;
}
function eTv(e, t) {
	return t.push(e), e;
}
h(eTu, "trim"), h(eTd, "replace"), h(eTp, "indexof"), h(eTf, "charat"), h(eTg, "substr"), h(eTm, "strlen"), h(eTy, "sizeof"), h(eTv, "append");
var eTx = 1, eTb = 1, eTw = 0, eTk = 0, eTT = 0, eT_ = "";
function eTE(e, t, r, i, n, a, s, o) {
	return {
		value: e,
		root: t,
		parent: r,
		type: i,
		props: n,
		children: a,
		line: eTx,
		column: eTb,
		length: s,
		return: "",
		siblings: o
	};
}
function eTC() {
	return eTT;
}
function eTS() {
	return eTT = eTk > 0 ? eTf(eT_, --eTk) : 0, eTb--, 10 === eTT && (eTb = 1, eTx--), eTT;
}
function eTA() {
	return eTT = eTk < eTw ? eTf(eT_, eTk++) : 0, eTb++, 10 === eTT && (eTb = 1, eTx++), eTT;
}
function eTL() {
	return eTf(eT_, eTk);
}
function eTR() {
	return eTk;
}
function eTN(e, t) {
	return eTg(eT_, e, t);
}
function eTI(e) {
	switch (e) {
		case 0:
		case 9:
		case 10:
		case 13:
		case 32: return 5;
		case 33:
		case 43:
		case 44:
		case 47:
		case 62:
		case 64:
		case 126:
		case 59:
		case 123:
		case 125: return 4;
		case 58: return 3;
		case 34:
		case 39:
		case 40:
		case 91: return 2;
		case 41:
		case 93: return 1;
	}
	return 0;
}
function eTM(e) {
	return eTx = eTb = 1, eTw = eTm(eT_ = e), eTk = 0, [];
}
function eTD(e) {
	return eT_ = "", e;
}
function eTO(e) {
	return eTu(eTN(eTk - 1, eTB(91 === e ? e + 2 : 40 === e ? e + 1 : e)));
}
function eT$(e) {
	for (; (eTT = eTL()) && eTT < 33;) eTA();
	return eTI(e) > 2 || eTI(eTT) > 3 ? "" : " ";
}
function eTP(e, t) {
	for (; --t && eTA() && !(eTT < 48 || eTT > 102 || eTT > 57 && eTT < 65 || eTT > 70 && eTT < 97););
	return eTN(e, eTR() + (t < 6 && 32 == eTL() && 32 == eTA()));
}
function eTB(e) {
	for (; eTA();) switch (eTT) {
		case e: return eTk;
		case 34:
		case 39:
			34 !== e && 39 !== e && eTB(eTT);
			break;
		case 40:
			41 === e && eTB(e);
			break;
		case 92: eTA();
	}
	return eTk;
}
function eTF(e, t) {
	for (; eTA() && e + eTT !== 57 && (e + eTT !== 84 || 47 !== eTL()););
	return "/*" + eTN(t, eTk - 1) + "*" + eTh(47 === e ? e : eTA());
}
function eTz(e) {
	for (; !eTI(eTL());) eTA();
	return eTN(e, eTk);
}
function eTU(e) {
	return eTD(eTG("", null, null, null, [""], e = eTM(e), 0, [0], e));
}
function eTG(e, t, r, i, n, a, s, o, l) {
	for (var h = 0, u = 0, d = s, p = 0, f = 0, g = 0, m = 1, y = 1, v = 1, x = 0, b = "", w = n, k = a, T = i, _ = b; y;) switch (g = x, x = eTA()) {
		case 40: if (108 != g && 58 == eTf(_, d - 1)) {
			-1 != eTp(_ += eTd(eTO(x), "&", "&\f"), "&\f", eTc(h ? o[h - 1] : 0)) && (v = -1);
			break;
		}
		case 34:
		case 39:
		case 91:
			_ += eTO(x);
			break;
		case 9:
		case 10:
		case 13:
		case 32:
			_ += eT$(g);
			break;
		case 92:
			_ += eTP(eTR() - 1, 7);
			continue;
		case 47:
			switch (eTL()) {
				case 42:
				case 47:
					eTv(eTj(eTF(eTA(), eTR()), t, r, l), l), (5 == eTI(g || 1) || 5 == eTI(eTL() || 1)) && eTm(_) && " " !== eTg(_, -1, void 0) && (_ += " ");
					break;
				default: _ += "/";
			}
			break;
		case 123 * m: o[h++] = eTm(_) * v;
		case 125 * m:
		case 59:
		case 0:
			switch (x) {
				case 0:
				case 125: y = 0;
				case 59 + u:
					-1 == v && (_ = eTd(_, /\f/g, "")), f > 0 && (eTm(_) - d || 0 === m && 47 === g) && eTv(f > 32 ? eTW(_ + ";", i, r, d - 1, l) : eTW(eTd(_, " ", "") + ";", i, r, d - 2, l), l);
					break;
				case 59: _ += ";";
				default: if (eTv(T = eTq(_, t, r, h, u, n, o, b, w = [], k = [], d, a), a), 123 === x) if (0 === u) eTG(_, t, T, T, w, a, d, o, k);
				else {
					switch (p) {
						case 99: if (110 === eTf(_, 3)) break;
						case 108: if (97 === eTf(_, 2)) break;
						default: u = 0;
						case 100:
						case 109:
						case 115:
					}
					u ? eTG(e, T, T, i && eTv(eTq(e, T, T, 0, 0, n, o, b, n, w = [], d, k), k), n, k, d, o, i ? w : k) : eTG(_, T, T, T, [""], k, 0, o, k);
				}
			}
			h = u = f = 0, m = v = 1, b = _ = "", d = s;
			break;
		case 58: d = 1 + eTm(_), f = g;
		default:
			if (m < 1) {
				if (123 == x) --m;
				else if (125 == x && 0 == m++ && 125 == eTS()) continue;
			}
			switch (_ += eTh(x), x * m) {
				case 38:
					v = u > 0 ? 1 : (_ += "\f", -1);
					break;
				case 44:
					o[h++] = (eTm(_) - 1) * v, v = 1;
					break;
				case 64:
					45 === eTL() && (_ += eTO(eTA())), p = eTL(), u = d = eTm(b = _ += eTz(eTR())), x++;
					break;
				case 45: 45 === g && 2 == eTm(_) && (m = 0);
			}
	}
	return a;
}
function eTq(e, t, r, i, n, a, s, o, l, h, u, d) {
	for (var p = n - 1, f = 0 === n ? a : [""], g = eTy(f), m = 0, y = 0, v = 0; m < i; ++m) for (var x = 0, b = eTg(e, p + 1, p = eTc(y = s[m])), w = e; x < g; ++x) (w = eTu(y > 0 ? f[x] + " " + b : eTd(b, /&\f/g, f[x]))) && (l[v++] = w);
	return eTE(e, t, r, 0 === n ? eTo : o, l, h, u, d);
}
function eTj(e, t, r, i) {
	return eTE(e, t, r, eTs, eTh(eTC()), eTg(e, 2, -2), 0, i);
}
function eTW(e, t, r, i, n) {
	return eTE(e, t, r, eTl, eTg(e, 0, i), eTg(e, i + 1, -1), i, n);
}
function eTY(e, t) {
	for (var r = "", i = 0; i < e.length; i++) r += t(e[i], i, e, t) || "";
	return r;
}
function eTV(e, t, r, i) {
	switch (e.type) {
		case "@layer": if (e.children.length) break;
		case "@import":
		case "@namespace":
		case eTl: return e.return = e.return || e.value;
		case eTs: return "";
		case "@keyframes": return e.return = e.value + "{" + eTY(e.children, i) + "}";
		case eTo: if (!eTm(e.value = e.props.join(","))) return "";
	}
	return eTm(r = eTY(e.children, i)) ? e.return = e.value + "{" + r + "}" : "";
}
function eTH(e, t) {
	e.attr("role", "graphics-document document"), "" !== t && e.attr("aria-roledescription", t);
}
function eTX(e, t, r, i) {
	if (void 0 !== e.insert) {
		if (r) {
			let t = `chart-desc-${i}`;
			e.attr("aria-describedby", t), e.insert("desc", ":first-child").attr("id", t).text(r);
		}
		if (t) {
			let r = `chart-title-${i}`;
			e.attr("aria-labelledby", r), e.insert("title", ":first-child").attr("id", r).text(t);
		}
	}
}
h(eTE, "node"), h(eTC, "char"), h(eTS, "prev"), h(eTA, "next"), h(eTL, "peek"), h(eTR, "caret"), h(eTN, "slice"), h(eTI, "token"), h(eTM, "alloc"), h(eTD, "dealloc"), h(eTO, "delimit"), h(eT$, "whitespace"), h(eTP, "escaping"), h(eTB, "delimiter"), h(eTF, "commenter"), h(eTz, "identifier"), h(eTU, "compile"), h(eTG, "parse"), h(eTq, "ruleset"), h(eTj, "comment"), h(eTW, "declaration"), h(eTY, "serialize"), h(eTV, "stringify"), h(eTH, "setA11yDiagramInfo"), h(eTX, "addSVGa11yTitleDescription");
var eTK = class e {
	constructor(e, t, r, i, n) {
		this.type = e, this.text = t, this.db = r, this.parser = i, this.renderer = n;
	}
	static {
		h(this, "Diagram");
	}
	static async fromText(t, r = {}) {
		let i = IA(), n = NO(t, i);
		t = V3(t) + `
`;
		try {
			Dg(n);
		} catch {
			let e = NB(n);
			if (!e) throw new NM(`Diagram ${n} not found.`);
			let { id: t, diagram: r } = await e();
			Df(t, r);
		}
		let { db: a, parser: s, renderer: o, init: l } = Dg(n);
		return s.parser && (s.parser.yy = a), a.clear?.(), l?.(i), r.title && a.setDiagramTitle?.(r.title), await s.parse(t), new e(n, t, a, s, o);
	}
	async render(e, t) {
		await this.renderer.draw(this.text, e, t, this);
	}
	getParser() {
		return this.parser;
	}
	getType() {
		return this.type;
	}
}, eTZ = [], eTQ = h(() => {
	eTZ.forEach((e) => {
		e();
	}), eTZ = [];
}, "attachFunctions"), eTJ = h((e) => e.replace(/^\s*%%(?!{)[^\n]+\n?/gm, "").trimStart(), "cleanupComments");
function eT0(e) {
	let t = e.match(NR);
	if (!t) return {
		text: e,
		metadata: {}
	};
	let r = elT(t[1], { schema: eof }) ?? {};
	r = "object" != typeof r || Array.isArray(r) ? {} : r;
	let i = {};
	return r.displayMode && (i.displayMode = r.displayMode.toString()), r.title && (i.title = r.title.toString()), r.config && (i.config = r.config), {
		text: e.slice(t[0].length),
		metadata: i
	};
}
h(eT0, "extractFrontMatter");
var eT1 = h((e) => e.replace(/\r\n?/g, `
`).replace(/<(\w+)([^>]*)>/g, (e, t, r) => "<" + t + r.replace(/="([^"]*)"/g, "='$1'") + ">"), "cleanupText"), eT2 = h((e) => {
	let { text: t, metadata: r } = eT0(e), { displayMode: i, title: n, config: a = {} } = r;
	return i && (a.gantt || (a.gantt = {}), a.gantt.displayMode = i), {
		title: n,
		config: a,
		text: t
	};
}, "processFrontmatter"), eT4 = h((e) => {
	let t = VC(e) ?? {}, r = VS(e, "wrap");
	return Array.isArray(r) ? t.wrap = r.some(({ type: e }) => "wrap" === e) : r?.type === "wrap" && (t.wrap = !0), {
		text: VA(e),
		directive: t
	};
}, "processDirectives");
function eT5(e) {
	let t = eT2(eT1(e)), r = eT4(t.text), i = V5(t.config, r.directive);
	return {
		code: e = eTJ(r.text),
		title: t.title,
		config: i
	};
}
function eT3(e) {
	return btoa(Array.from(new TextEncoder().encode(e), (e) => String.fromCodePoint(e)).join(""));
}
h(eT5, "preprocessDiagram"), h(eT3, "toBase64");
var eT6 = ["foreignobject"], eT7 = ["dominant-baseline"];
function eT8(e) {
	let t = eT5(e);
	return IN(), IR(t.config ?? {}), t;
}
async function eT9(e, t) {
	eTn();
	try {
		let { code: t, config: r } = eT8(e);
		return {
			diagramType: (await e_h(t)).type,
			config: r
		};
	} catch (e) {
		if (t?.suppressErrors) return !1;
		throw e;
	}
}
h(eT8, "processAndSetConfigs"), h(eT9, "parse");
var e_e = h((e, t, r = []) => `
.${e} ${t} { ${r.join(" !important; ")} !important; }`, "cssImportantStyles"), e_t = h((e, t = /* @__PURE__ */ new Map()) => {
	let r = "";
	if (void 0 !== e.themeCSS && (r += `
${e.themeCSS}`), void 0 !== e.fontFamily && (r += `
:root { --mermaid-font-family: ${e.fontFamily}}`), void 0 !== e.altFontFamily && (r += `
:root { --mermaid-alt-font-family: ${e.altFontFamily}}`), t instanceof Map) {
		let i = e.htmlLabels ?? e.flowchart?.htmlLabels ? ["> *", "span"] : [
			"rect",
			"polygon",
			"ellipse",
			"circle",
			"path"
		];
		t.forEach((e) => {
			t3(e.styles) || i.forEach((t) => {
				r += e_e(e.id, t, e.styles);
			}), t3(e.textStyles) || (r += e_e(e.id, "tspan", (e?.textStyles || []).map((e) => e.replace("color", "fill"))));
		});
	}
	return r;
}, "createCssStyles"), e_r = h((e, t, r, i) => eTY(eTU(`${i}{${M7(t, e_t(e, r), e.themeVariables)}}`), eTV), "createUserStyles"), e_i = h((e = "", t, r) => {
	let i = e;
	return r || t || (i = i.replace(/marker-end="url\([\d+./:=?A-Za-z-]*?#/g, "marker-end=\"url(#")), i = (i = V6(i)).replace(/<br>/g, "<br/>");
}, "cleanUpSvgCode"), e_n = h((e = "", t) => `<iframe style="width:100%;height:${t?.viewBox?.baseVal?.height ? t.viewBox.baseVal.height + "px" : "100%"};border:0;margin:0;" src="data:text/html;charset=UTF-8;base64,${eT3(`<body style="margin:0">${e}</body>`)}" sandbox="allow-top-navigation-by-user-activation allow-popups">
  The "iframe" tag is not supported by your browser.
</iframe>`, "putIntoIFrame"), e_a = h((e, t, r, i, n) => {
	let a = e.append("div");
	a.attr("id", r), i && a.attr("style", i);
	let s = a.append("svg").attr("id", t).attr("width", "100%").attr("xmlns", "http://www.w3.org/2000/svg");
	return n && s.attr("xmlns:xlink", n), s.append("g"), e;
}, "appendDivSvgG");
function e_s(e, t) {
	return e.append("iframe").attr("id", t).attr("style", "width: 100%; height: 100%;").attr("sandbox", "");
}
h(e_s, "sandboxedIframe");
var e_o = h((e, t, r, i) => {
	e.getElementById(t)?.remove(), e.getElementById(r)?.remove(), e.getElementById(i)?.remove();
}, "removeExistingElements"), e_l = h(async function(e, t, r) {
	let i, n;
	eTn();
	let a = eT8(t);
	t = a.code;
	let s = IA();
	wQ.debug(s), t.length > (s?.maxTextSize ?? 5e4) && (t = "graph TB;a[Maximum text size in diagram exceeded];style a fill:#faa");
	let o = "#" + e, l = "i" + e, u = "#" + l, d = "d" + e, p = "#" + d, f = h(() => {
		let e = _t(m ? u : p).node();
		e && "remove" in e && e.remove();
	}, "removeTempElements"), g = _t("body"), m = "sandbox" === s.securityLevel, y = "loose" === s.securityLevel, v = s.fontFamily;
	void 0 !== r ? ((r && (r.innerHTML = ""), m) ? (g = _t(e_s(_t(r), l).nodes()[0].contentDocument.body)).node().style.margin = 0 : g = _t(r), e_a(g, e, d, `font-family: ${v}`, "http://www.w3.org/1999/xlink")) : ((e_o(document, e, d, l), m) ? (g = _t(e_s(_t("body"), l).nodes()[0].contentDocument.body)).node().style.margin = 0 : g = _t("body"), e_a(g, e, d));
	try {
		i = await eTK.fromText(t, { title: a.title });
	} catch (e) {
		if (s.suppressErrorRendering) throw f(), e;
		i = await eTK.fromText("error"), n = e;
	}
	let x = g.select(p).node(), b = i.type, w = x.firstChild, k = w.firstChild, T = e_r(s, b, i.renderer.getClasses?.(t, i), o), _ = document.createElement("style");
	_.innerHTML = T, w.insertBefore(_, k);
	try {
		await i.renderer.draw(t, e, euk, i);
	} catch (r) {
		throw s.suppressErrorRendering ? f() : ekW.draw(t, e, euk), r;
	}
	e_u(b, g.select(`${p} svg`), i.db.getAccTitle?.(), i.db.getAccDescription?.()), g.select(`[id="${e}"]`).selectAll("foreignobject > *").attr("xmlns", "http://www.w3.org/1999/xhtml");
	let E = g.select(p).node().innerHTML;
	if ((wQ.debug("config.arrowMarkerAbsolute", s.arrowMarkerAbsolute), E = e_i(E, m, MG(s.arrowMarkerAbsolute)), m) ? E = e_n(E, g.select(p + " svg").node()) : y || (E = MA.sanitize(E, {
		ADD_TAGS: eT6,
		ADD_ATTR: eT7,
		HTML_INTEGRATION_POINTS: { foreignobject: !0 }
	})), eTQ(), n) throw n;
	return f(), {
		diagramType: b,
		svg: E,
		bindFunctions: i.db.bindFunctions
	};
}, "render");
function e_c(e = {}) {
	let t = NF({}, e);
	t?.fontFamily && !t.themeVariables?.fontFamily && (t.themeVariables || (t.themeVariables = {}), t.themeVariables.fontFamily = t.fontFamily), I_(t), t?.theme && t.theme in Iu ? t.themeVariables = Iu[t.theme].getThemeVariables(t.themeVariables) : t && (t.themeVariables = Iu.default.getThemeVariables(t.themeVariables)), wJ(("object" == typeof t ? IT(t) : IC()).logLevel), eTn();
}
h(e_c, "initialize");
var e_h = h((e, t = {}) => {
	let { code: r } = eT5(e);
	return eTK.fromText(r, t);
}, "getDiagramFromText");
function e_u(e, t, r, i) {
	eTH(t, e), eTX(t, r, i, t.attr("id"));
}
h(e_u, "addA11yInfo");
var e_d = Object.freeze({
	render: e_l,
	parse: eT9,
	getDiagramFromText: e_h,
	initialize: e_c,
	getConfig: IA,
	setConfig: IS,
	getSiteConfig: IC,
	updateSiteConfig: IE,
	reset: h(() => {
		IN();
	}, "reset"),
	globalReset: h(() => {
		IN(Iv);
	}, "globalReset"),
	defaultConfig: Iv
});
wJ(IA().logLevel), IN(IA());
var e_p = h((e, t, r) => {
	wQ.warn(e), V1(e) ? (r && r(e.str, e.hash), t.push({
		...e,
		message: e.str,
		error: e
	})) : (r && r(e), e instanceof Error && t.push({
		str: e.message,
		message: e.message,
		hash: e.name,
		error: e
	}));
}, "handleError"), e_f = h(async function(e = { querySelector: ".mermaid" }) {
	try {
		await e_g(e);
	} catch (t) {
		if (V1(t) && wQ.error(t.str), e_C.parseError && e_C.parseError(t), !e.suppressErrors) throw wQ.error("Use the suppressErrors option to suppress these errors"), t;
	}
}, "run"), e_g = h(async function({ postRenderCallback: e, querySelector: t, nodes: r } = { querySelector: ".mermaid" }) {
	let i, n = e_d.getConfig();
	if (wQ.debug(`${e ? "" : "No "}Callback function found`), r) i = r;
	else if (t) i = document.querySelectorAll(t);
	else throw Error("Nodes and querySelector are both undefined");
	wQ.debug(`Found ${i.length} diagrams`), n?.startOnLoad !== void 0 && (wQ.debug("Start On Load: " + n?.startOnLoad), e_d.updateSiteConfig({ startOnLoad: n?.startOnLoad }));
	let a = new VJ(n.deterministicIds, n.deterministicIDSeed), s, o = [];
	for (let t of Array.from(i)) {
		if (wQ.info("Rendering diagram: " + t.id), t.getAttribute("data-processed")) continue;
		t.setAttribute("data-processed", "true");
		let r = `mermaid-${a.next()}`, i = VC(s = HI(V0(s = t.innerHTML)).trim().replace(/<br\s*\/?>/gi, "<br/>"));
		i && wQ.debug("Detected early reinit: ", i);
		try {
			let { svg: i, bindFunctions: n } = await e_E(r, s, t);
			t.innerHTML = i, e && await e(r), n && n(t);
		} catch (e) {
			e_p(e, o, e_C.parseError);
		}
	}
	if (o.length > 0) throw o[0];
}, "runThrowsErrors"), e_m = h(function(e) {
	e_d.initialize(e);
}, "initialize"), e_y = h(async function(e, t, r) {
	wQ.warn("mermaid.init is deprecated. Please use run instead."), e && e_m(e);
	let i = {
		postRenderCallback: r,
		querySelector: ".mermaid"
	};
	"string" == typeof t ? i.querySelector = t : t && (t instanceof HTMLElement ? i.nodes = [t] : i.nodes = t), await e_f(i);
}, "init"), e_v = h(async (e, { lazyLoad: t = !0 } = {}) => {
	eTn(), N$(...e), !1 === t && await eTa();
}, "registerExternalDiagrams"), e_x = h(function() {
	if (e_C.startOnLoad) {
		let { startOnLoad: e } = e_d.getConfig();
		e && e_C.run().catch((e) => wQ.error("Mermaid failed to initialize", e));
	}
}, "contentLoaded");
"u" > typeof document && window.addEventListener("load", e_x, !1);
var e_b = h(function(e) {
	e_C.parseError = e;
}, "setParseErrorHandler"), e_w = [], e_k = !1, e_T = h(async () => {
	if (!e_k) {
		for (e_k = !0; e_w.length > 0;) {
			let e = e_w.shift();
			if (e) try {
				await e();
			} catch (e) {
				wQ.error("Error executing queue", e);
			}
		}
		e_k = !1;
	}
}, "executeQueue"), e__ = h(async (e, t) => new Promise((r, i) => {
	let n = h(() => new Promise((n, a) => {
		e_d.parse(e, t).then((e) => {
			n(e), r(e);
		}, (e) => {
			wQ.error("Error parsing", e), e_C.parseError?.(e), a(e), i(e);
		});
	}), "performCall");
	e_w.push(n), e_T().catch(i);
}), "parse"), e_E = h((e, t, r) => new Promise((i, n) => {
	let a = h(() => new Promise((a, s) => {
		e_d.render(e, t, r).then((e) => {
			a(e), i(e);
		}, (e) => {
			wQ.error("Error parsing", e), e_C.parseError?.(e), s(e), n(e);
		});
	}), "performCall");
	e_w.push(a), e_T().catch(n);
}), "render"), e_C = {
	startOnLoad: !0,
	mermaidAPI: e_d,
	parse: e__,
	render: e_E,
	init: e_y,
	run: e_f,
	registerExternalDiagrams: e_v,
	registerLayoutLoaders: eir,
	initialize: e_m,
	parseError: void 0,
	contentLoaded: e_x,
	setParseErrorHandler: e_b,
	detectType: NO,
	registerIconPacks: HA,
	getRegisteredDiagramsMetadata: h(() => Object.keys(ND).map((e) => ({ id: e })), "getRegisteredDiagramsMetadata")
}, e_S = e_C;
export { wN as $, ehT as A, Jj as B, eys as C, edt as D, edm as E, ea9 as F, wH as G, KM as H, ea0 as I, wU as J, wV as K, eiS as L, esB as M, esI as N, euE as O, es_ as P, wD as Q, eim as R, eye as S, edx as T, X0 as U, QE as V, X1 as W, wB as X, wP as Y, wO as Z, eya as _, eb6 as a, epL as b, ey7 as c, eyx as d, wR as et, efA as f, eyn as g, eyi as h, eb7 as i, ece as j, euw as k, ey1 as l, ed8 as m, ekp as n, wk as nt, ex5 as o, eyr as p, wz as q, ewN as r, r as rt, evJ as s, e_S as t, wT as tt, eyR as u, em8 as v, edN as w, eg8 as x, em9 as y, eig as z };
